LY)
    {
        p1->bChangesOnly = p2->bChangesOnly;
    }
    if (dwMask & PROP_WEBCRAWL_CHANNELFLAGS)
    {
        p1->fChannelFlags = p2->fChannelFlags;
    }

    p1->dwFlags |= (p2->dwFlags & fMask & (~PROP_WEBCRAWL_COOKIE));

    return S_OK;
}


INT_PTR CALLBACK SummarizeDesktopSubscriptionDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SUBSCRIBE_ADI_INFO* pInfo = (SUBSCRIBE_ADI_INFO*)GetProp(hDlg,SUBSCRIBEADIPROP);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        pInfo = (SUBSCRIBE_ADI_INFO*)lParam;
        ASSERT (pInfo);
        SetProp (hDlg, SUBSCRIBEADIPROP, (HANDLE)pInfo);
        {   //block to declare vars to update captions
            TCHAR sz[MAX_URL];

            if (pInfo->subsType == SUBSTYPE_DESKTOPCHANNEL)
            {
                if(MLLoadString(
                    (pInfo->pSubsInfo->bNeedPassword ? IDS_DESKTOPCHANNEL_SUMMARY_TEXT : IDS_DESKTOPCHANNEL_SUMMARY_NOPW),
                    sz, ARRAYSIZE(sz)))
                {
                    SetDlgItemText(hDlg, IDC_DESKTOP_SUMMARY_TEXT, sz);
                }
            }

            MyOleStrToStrN (sz, ARRAYSIZE(sz), pInfo->pwszName);
            SetListViewToString(GetDlgItem(hDlg, IDC_SUBSCRIBE_ADI_NAME), sz);
            MyOleStrToStrN (sz, ARRAYSIZE(sz), pInfo->pwszUrl);
            SetListViewToString (GetDlgItem (hDlg, IDC_SUBSCRIBE_ADI_URL), sz);
        }
        break;

    case WM_COMMAND:
        ASSERT (pInfo);
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDCANCEL:
            EndDialog(hDlg, IDCANCEL);
            break;

        case IDOK:
            //subscription happens in calling function when we return IDOK
            EndDialog(hDlg, IDOK);
            break;

        case IDC_SUBSCRIBE_CUSTOMIZE:
            //run through wizard in NOSAVE mode
            if (pInfo->pMgr &&
                S_OK == pInfo->pMgr->CreateSubscriptionNoSummary (hDlg, pInfo->pwszUrl,
                                        pInfo->pwszName, pInfo->dwFlags | CREATESUBS_NOSAVE,
                                        pInfo->subsType, pInfo->pSubsInfo))
            {
                SendMessage (hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
            }
            break;
        }
        break;

        case WM_NOTIFY:
            if (LOWORD(wParam) == IDC_SUBSCRIBE_ADI_URL)
            {
                NM_LISTVIEW * pnmlv = (NM_LISTVIEW *)lParam;
                if (pnmlv->hdr.code == LVN_GETINFOTIP)
                {
                    TCHAR szURL[MAX_URL];
                    LV_ITEM lvi = {0};
                    lvi.mask = LVIF_TEXT;
                    lvi.pszText = szURL;
                    lvi.cchTextMax = ARRAYSIZE(szURL);
                    if (!ListView_GetItem (GetDlgItem (hDlg, IDC_SUBSCRIBE_ADI_URL), &lvi))
                        return FALSE;

                    NMLVGETINFOTIP  * pTip = (NMLVGETINFOTIP *)pnmlv;
                    ASSERT(pTip);
                    StrCpyN(pTip->pszText, szURL, pTip->cchTextMax);
                    return TRUE;
                }
            }
        break;

    case WM_DESTROY:
        RemoveProp (hDlg, SUBSCRIBEADIPROP);
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\subitem.h ===
#ifndef _subitem_h
#define _subitem_h

HRESULT BlobToVariant(BYTE *pData, DWORD cbData, VARIANT *pVar, DWORD *pcbUsed, BOOL fStream = FALSE);

class CEnumItemProperties : public IEnumItemProperties
{
public:
    CEnumItemProperties();
    HRESULT Initialize(const SUBSCRIPTIONCOOKIE *pCookie, ISubscriptionItem *psi);
    HRESULT CopyItem(ITEMPROP *pip, WCHAR *pwszName, VARIANT *pVar);
    HRESULT CopyRange(ULONG nStart, ULONG nCount, ITEMPROP *ppip, ULONG *pnCopied);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumItemProperties
    STDMETHODIMP Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ ITEMPROP *rgelt,
        /* [out] */ ULONG *pceltFetched);
    
    STDMETHODIMP Skip( 
        /* [in] */ ULONG celt);
    
    STDMETHODIMP Reset( void);
    
    STDMETHODIMP Clone( 
        /* [out] */ IEnumItemProperties **ppenum);
    
    STDMETHODIMP GetCount( 
        /* [out] */ ULONG *pnCount);

private:
    ~CEnumItemProperties();

    ULONG       m_cRef;
    ULONG       m_nCurrent;
    ULONG       m_nCount;

    ITEMPROP    *m_pItemProps;
};

class CSubscriptionItem : public ISubscriptionItem 
{
public:
    CSubscriptionItem(const SUBSCRIPTIONCOOKIE *pCookie, HKEY hkey);
    HRESULT Read(HKEY hkeyIn, const WCHAR *pwszValueName, BYTE *pData, DWORD dwDataSize);
    HRESULT ReadWithAlloc(HKEY hkeyIn, const WCHAR *pwszValueName, BYTE **ppData, DWORD *pdwDataSize);
    HRESULT Write(HKEY hkeyIn, const WCHAR *pwszValueName, BYTE *pData, DWORD dwDataSize);

    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISubscriptionItem
    STDMETHODIMP GetCookie(SUBSCRIPTIONCOOKIE *pCookie);
    STDMETHODIMP GetSubscriptionItemInfo( 
        /* [out] */ SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo);
    
    STDMETHODIMP SetSubscriptionItemInfo( 
        /* [in] */ const SUBSCRIPTIONITEMINFO *pSubscriptionItemInfo);
    
    STDMETHODIMP ReadProperties( 
        ULONG nCount,
        /* [size_is][in] */ const LPCWSTR rgwszName[],
        /* [size_is][out] */ VARIANT rgValue[]);
    
    STDMETHODIMP WriteProperties( 
        ULONG nCount,
        /* [size_is][in] */ const LPCWSTR rgwszName[],
        /* [size_is][in] */ const VARIANT rgValue[]);
    
    STDMETHODIMP EnumProperties( 
        /* [out] */ IEnumItemProperties **ppEnumItemProperties);

    STDMETHODIMP NotifyChanged();

private:
    ~CSubscriptionItem();
    ULONG               m_cRef;
    SUBSCRIPTIONCOOKIE  m_Cookie;
    DWORD               m_dwFlags;
};

#endif // _subitem_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\strlist.h ===
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
#ifndef _STRINGLST_H
#define _STRINGLST_H

// Helper functions to properly create CWCStringList.
class CWCStringList;
CWCStringList *CreateCWCStringList(int iInitBufSize=4096);

// BSTR is DWORD length followed by null-term OLECHAR (WCHAR) data
//
//----------------------------------------------------------------------------
// CWCStringList is used to store array of non-duplicate strings. Used for
//   dependency and link storage.
//
// Limitations:
//  1) Strings can only be added and never removed from list
//  2) No duplicate strings can ever be stored
//
// Stores all strings in one big block of memory
// It's efficient at ensuring there are no duplicate strings.
// Scalable. Uses hash. Expands to the limit of memory.
//
// Usage:
//  Create the class. Call Init() and destroy if it fails.
//  Add the strings with AddString
//  Use NumStrings() and GetString() to iterate through all of the stored strings.
//
//  The state can be saved and restored with IPersistStream operations
//
//  We take up memory when we're loaded. Don't initialize one of these objects
//  until you're going to use it.
//----------------------------------------------------------------------------

const int STRING_HASH_SIZE = 127;      // should be prime

const TCHAR PARSE_STRING_DELIM = TEXT('\n');     // To separate URLs

// We're not an OLE object but support IPersistStream members to make saving
//  & restoring easier
class CWCStringList {
public:
    CWCStringList();
virtual ~CWCStringList();

    // Return from AddString
    enum { STRLST_FAIL=0, STRLST_DUPLICATE=1, STRLST_ADDED=2 };

// iInitBufSize is minimum starting buffer size, or -1 for default
virtual BOOL Init(int iInitBufSize=-1);

virtual int   AddString(LPCWSTR lpwstr, DWORD_PTR dwData = 0, int *piNum = NULL);
virtual DWORD_PTR GetStringData(int iNum) { return 0; }
virtual void  SetStringData(int iNum, DWORD_PTR dw) { return; }

    int     NumStrings() { return m_iNumStrings; }

    // iLen must be length in characters of string, not counting null term.
    // -1 if unknown.
    BOOL    FindString(LPCWSTR lpwstr, int iLen, int *piNum=NULL);

    // Returns const pointer to within stringlist's memory
    LPCWSTR GetString    (int iNum)
                {
                    ASSERT(iNum < m_iNumStrings);
                    return m_psiStrings[iNum].lpwstr;
                }

    // Returns length of string in characters
    int     GetStringLen (int iNum)
                { 
                    ASSERT(iNum < m_iNumStrings);
                    return m_psiStrings[iNum].iLen;
                }

    // Returns new BSTR. Free with SysFreeString when you're done.
    BSTR    GetBSTR     (int iNum);

    // IUnknown members
//  STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
//  STDMETHODIMP_(ULONG) AddRef(void);
//  STDMETHODIMP_(ULONG) Release(void);

    // IPersistStream members
//  STDMETHODIMP         GetClassID(CLSID *pClassID);
    STDMETHODIMP         IsDirty(void);         // Always returns TRUE
    STDMETHODIMP         Load(IStream *pStm);
    STDMETHODIMP         Save(IStream *pStm, BOOL fClearDirty);
    STDMETHODIMP         GetSizeMax(ULARGE_INTEGER *pcbSize);

    enum { DEFAULT_INIT_BUF_SIZE = 4096 };

protected:
    void    CleanUp();
    void    Clear();
    void    Reset();

    BOOL    InitializeFromBuffer();

    BOOL    m_fValid;                   // Are our buffers initialized?
    int     m_iNumStrings;              // # of strings so far.
    int     m_iMaxStrings;              // # of elements in m_psiStrings

private:
    typedef struct tagStringIndex {
        LPCWSTR         lpwstr;  // pointer to string text in m_pBuffer
        int             iLen;    // length of this string in characters w/o null term
        tagStringIndex* psiNext; // index of next string with same hash value
    } STRING_INDEX, *PSTRING_INDEX, *LPSTRING_INDEX;

    LPSTR   m_pBuffer;                  // Holds all strings
    int     m_iBufEnd;                  // Last byte used in buffer
    int     m_iBufSize;

    LPSTRING_INDEX  m_psiStrings;               // dynamically allocated array
    LPSTRING_INDEX  m_Hash[STRING_HASH_SIZE];   // hash table (array of ptrs within m_psiStrings)
    int             m_iLastHash;                // used to avoid recalculating hashes

    BOOL InsertToHash(LPCWSTR lpwstr, int iLen, BOOL fAlreadyHashed);
    int Hash(LPCWSTR lpwstr, int iLen)
    {
        unsigned long hash=0;

        while (iLen--)
        {
            hash = (hash<<5) + hash + *lpwstr++;
        }

        return m_iLastHash = (int)(hash % STRING_HASH_SIZE);
    }

#ifdef DEBUG
    void SpewHashStats(BOOL fVerbose);
#endif
};

// Helper macros to create the string lists
inline CWCStringList *CreateCWCStringList(int iInitBufSize)
{
    CWCStringList *pRet = new CWCStringList();
    if (pRet->Init(iInitBufSize))
    {
        return pRet;
    }
    delete pRet;
    return NULL;
}

// CWCDwordStringList stores an extra DWORD of data along with each string.
// This data does not get persisted

class CWCDwordStringList : public CWCStringList {

public:
    CWCDwordStringList();
    ~CWCDwordStringList();

    // these are all virtual
    BOOL    Init(int iInitBufSize=-1);
    int     AddString(LPCWSTR psz, DWORD_PTR dwData = 0, int *piNum = NULL);
    DWORD_PTR GetStringData(int iNum) { return m_pData[iNum]; }
    void    SetStringData(int iNum, DWORD_PTR dw) { m_pData[iNum] = dw; }

private:
    DWORD_PTR *m_pData;      // data our caller wants attached to the strings
};

#endif // _STRINGLST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\strlist.cpp ===
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------
#include "private.h"
#include "strlist.h"

#define TF_THISMODULE   TF_STRINGLIST

//----------------------------------------------------------------------------
// CWCStringList

CWCStringList::CWCStringList()
{
    // We may be able to remove this Clear() call if we guarantee that
    //  1) the new operator zero inits
    //  2) we don't use this class on the stack
    Clear();
}

CWCStringList::~CWCStringList()
{
#ifdef DEBUG
    if (m_iNumStrings > 100)
        SpewHashStats(TRUE);
#endif

    CleanUp();
}

// Clean up any allocated memory
void CWCStringList::CleanUp()
{
    // Must free buffers even if not m_fValid, because we may have
    // gotten only partway through Init() before running into a problem.

    if (m_pBuffer)
    {
        MemFree(m_pBuffer);
        m_pBuffer = NULL;
    }

    if (m_psiStrings)
    {
        MemFree(m_psiStrings);
        m_psiStrings = NULL;
    }

    m_fValid = FALSE;
}

// Clear our internal structures to prepare to be initialized. Assumes we
//  have no allocated memory (call CleanUp())
void CWCStringList::Clear()
{
    m_fValid = FALSE;
    m_iBufEnd = m_iBufSize = m_iNumStrings = m_iMaxStrings = 0;
    m_pBuffer = NULL;
    m_psiStrings = NULL;
    ZeroMemory(m_Hash, sizeof(m_Hash));
}

void CWCStringList::Reset()
{
    if (m_fValid || m_pBuffer || m_psiStrings)
    {
        CleanUp();
        Clear();
    }
}

BOOL CWCStringList::Init(int iInitBufSize)
{
    if (m_fValid)
    {
        DBG("WCStringList::Init called when already initialized");
        Reset();
    }

    if (iInitBufSize <= 0)
    {
        iInitBufSize = DEFAULT_INIT_BUF_SIZE;
    }

    m_iMaxStrings = iInitBufSize >> 5;  // this is relatively arbitrary but doesn't matter much

    m_pBuffer = (LPSTR)MemAlloc(LMEM_FIXED, iInitBufSize);
    m_psiStrings = (LPSTRING_INDEX)MemAlloc(LMEM_FIXED, m_iMaxStrings * sizeof(STRING_INDEX));

    if ((NULL == m_psiStrings) ||
        (NULL == m_pBuffer))
    {
        DBG_WARN("Init() memory allocation failed");

        CleanUp();
        return FALSE;
    }

    *m_pBuffer = 0;

    m_iBufSize = iInitBufSize;
    m_iBufEnd = 0;
    m_fValid = TRUE;

    return TRUE;
}


// Sets up our internal data structures (hash and string_index)
// Sets m_iBufEnd.
// We must already be Init()ialized and the data in m_pBuffer
BOOL CWCStringList::InitializeFromBuffer()
{
    LPCWSTR pNext;
    int iLen;

    if (!m_fValid)
        return FALSE;

    pNext = (LPCWSTR)m_pBuffer;

    while (((LPSTR)pNext-m_pBuffer) < m_iBufSize)
    {
        iLen = lstrlenW(pNext);
        InsertToHash(pNext, iLen, FALSE);
        pNext += iLen+1;
    }

    m_iBufEnd = (int)((LPSTR)pNext - m_pBuffer);

    return TRUE;
}


//
// IPersistStream members
//
// We save
// DWORD containing total length in bytes that follows. Will be
//  multiple of four; may have 0-4 extra pad bytes on the end.
// String data.
//
// Smallest data we store is 4 bytes of zeroes. We still end up taking
//  memory when we get restored. Don't instantiate one of these objects
//  until you're going to use it.
STDMETHODIMP CWCStringList::IsDirty(void)
{
    DBG("CWCStringList::IsDirty returning S_OK (true) as always");

    return S_OK;
}

STDMETHODIMP CWCStringList::Load(IStream *pStm)
{
    HRESULT hr;
    ULONG   cbRead;
    DWORD   dwDataSize;

    DBG("CWCStringList::Load");

    if (NULL==pStm)
        return E_POINTER;

    // Clean up our object
    Reset();

    // Load our data
    hr = pStm->Read(&dwDataSize, sizeof(DWORD), &cbRead);
    if (FAILED(hr) || cbRead != sizeof(DWORD))
        return STG_E_READFAULT;

    if (0 == dwDataSize)
    {
        if (!Init(512))     // Start with small buffer since we're empty
            return E_OUTOFMEMORY;
        return S_OK;
    }

    if (!Init(dwDataSize))
        return E_OUTOFMEMORY;

    ASSERT(dwDataSize <= (DWORD)m_iBufSize);

    // Read in the string data
    hr = pStm->Read(m_pBuffer, dwDataSize, &cbRead);
    if (FAILED(hr) || cbRead != dwDataSize)
        return STG_E_READFAULT;

    // Set up hash tables etc.
    InitializeFromBuffer();

    DBG("CWCStringList::Load success");

    return NOERROR;
}

STDMETHODIMP CWCStringList::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr;
    ULONG   cbWritten;
    DWORD   dwDataSize, dwZero=0;
    DWORD   dwZeroPad;

    DBG("CWCStringList::Save");

    if (NULL==pStm)
        return E_POINTER;

    // First write our data
    dwDataSize = (m_iBufEnd+3) & 0xFFFFFFFC; // multiple of four

    if ((0 == m_iBufSize) || (0 == m_iNumStrings))
    {
        dwDataSize = 0;
    }

    hr = pStm->Write(&dwDataSize, sizeof(DWORD), &cbWritten);
    if (FAILED(hr) || sizeof(DWORD) != cbWritten)
        return STG_E_WRITEFAULT;

    if (dwDataSize > 0)
    {
        hr = pStm->Write(m_pBuffer, m_iBufSize, &cbWritten);
        if (FAILED(hr) || sizeof(DWORD) != cbWritten)
            return STG_E_WRITEFAULT;

        dwZeroPad = dwDataSize - m_iBufSize;

        ASSERT(dwZeroPad<4);
        if (dwZeroPad && dwZeroPad<4)
        {
            hr = pStm->Write(&dwZero, dwZeroPad, &cbWritten);
            if (FAILED(hr) || (dwZeroPad != cbWritten))
                return STG_E_WRITEFAULT;
        }
    }

    DBG("CWCStringList::Save success");

    return NOERROR;
}

STDMETHODIMP CWCStringList::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DBG("CWCStringList::GetSizeMax");

    if (NULL==pcbSize)
        return E_POINTER;

    pcbSize->LowPart = 0;
    pcbSize->HighPart = 0;

    pcbSize->LowPart = m_iBufEnd + 8;

    return NOERROR;
}

// Returns a BSTR
BSTR CWCStringList::GetBSTR(int iNum)
{
    LPCWSTR lpStr = GetString(iNum);

    return SysAllocStringLen(lpStr, GetStringLen(iNum));
}

// Returns FALSE if string is not found
// Places string index (for GetString()) in *piNum only if string is found.
BOOL CWCStringList::FindString(LPCWSTR lpwstr, int iLen, int *piNum/*=NULL*/)
{
    int             iHash;
    LPSTRING_INDEX  psi;

    if (!lpwstr)
        return FALSE;

    if (iLen < 0)
        iLen = lstrlenW(lpwstr);

    iHash = Hash(lpwstr, iLen);
    for (psi = m_Hash[iHash]; psi; psi = psi->psiNext)
    {
        if ((psi->iLen == iLen) && memcmp(psi->lpwstr, lpwstr, iLen * sizeof(WCHAR)) == 0)
        {
            if (piNum)
                *piNum = (int) (psi-m_psiStrings);
            return TRUE;        // String is a duplicate
        }
    }

    return FALSE;
}

// returns STRLST_FAIL on failure,
//         STRLST_DUPLICATE if the string already existed, and
//         STRLST_ADDED if it's new
int CWCStringList::AddString(LPCWSTR lpwstr, DWORD_PTR dwData /*=NULL*/, int *piNum /*=NULL*/)
{
    int iSize, iLen;

    if (!lpwstr)
        return STRLST_FAIL;

    iLen = lstrlenW(lpwstr);

    if (!m_fValid || !m_pBuffer)
    {
        DBG_WARN("WCStringList: AddString() called with invalid instance");
        return STRLST_FAIL;
    }

    if (dwData != 0)
        DBG_WARN("Value for dwData passed into CWCStringList::AddString");

    if (FindString(lpwstr, iLen, piNum))
        return STRLST_DUPLICATE;        // String is a duplicate

    // iSize will be size in bytes including null term
    iSize = (iLen+1)*sizeof(WCHAR);

    // Append string to current buffer
    if (iSize >= (m_iBufSize - m_iBufEnd))
    {
        int iOldBufSize = m_iBufSize;

        // Grow buffer.
        m_iBufSize *= 2;     // This way the number of reallocs drops off logarithmically
        if (m_iBufEnd + iSize > m_iBufSize)
        {
            DBG("StringList special growing size");
            m_iBufSize = m_iBufEnd + iSize;
        }

        TraceMsg(TF_THISMODULE,"StringList growing to size %d",m_iBufSize);

        LPSTR pBuf = (LPSTR)MemReAlloc((HLOCAL)m_pBuffer, m_iBufSize, LMEM_MOVEABLE);
        if (!pBuf)
        {
            m_iBufSize = iOldBufSize;
            DBG_WARN("WCStringList: ReAlloc() failure");
            // Realloc failure: our old memory is still present
            return 0;
        }
        // Let's be clever and fix all our pointers instead of getting faults
        if (m_pBuffer != pBuf)
        {
            int i;
            LPSTRING_INDEX psi;
            for (i=0, psi=&m_psiStrings[0]; i<m_iNumStrings; i++, psi++)
            {
                psi->lpwstr = (LPWSTR)(((LPSTR)psi->lpwstr - m_pBuffer) + pBuf);
            }

            m_pBuffer = pBuf;
        }
    }

    if (piNum)
        *piNum = m_iNumStrings;

    LPWSTR pBufEnd = (LPWSTR)(m_pBuffer + m_iBufEnd);

    StrCpyNW(pBufEnd, lpwstr, (m_iBufSize - m_iBufEnd) / sizeof(WCHAR));

    if (!InsertToHash(pBufEnd, iLen, TRUE))
        return 0;
    m_iBufEnd += iSize;

    return STRLST_ADDED;           // indicate we added a new string
}


BOOL CWCStringList::InsertToHash(LPCWSTR lpwstr, int iLen, BOOL fAlreadyHashed)
{
    int iHash = fAlreadyHashed ? m_iLastHash : Hash(lpwstr, iLen);

    // grow psiStrings if needed
    ASSERT(m_iNumStrings <= m_iMaxStrings);
    if (m_iNumStrings >= m_iMaxStrings)
    {
        m_iMaxStrings *= 2;
        TraceMsg(TF_THISMODULE, "StringList growing max strings to %d", m_iMaxStrings);
        LPSTRING_INDEX psiBuf = (LPSTRING_INDEX)MemReAlloc((HLOCAL)m_psiStrings,
            m_iMaxStrings * sizeof(STRING_INDEX), LMEM_MOVEABLE);
        if (!psiBuf)
        {
            // Realloc failure: Old memory still present
            DBG_WARN("WCStringList::InsertToHash() ReAlloc failure");
            m_iMaxStrings /= 2;
            return FALSE;
        }
        // More cleverness
        if (m_psiStrings != psiBuf)
        {
            int i;
            LPSTRING_INDEX psi, *ppsi;

            for (i=0, psi=psiBuf; i<m_iNumStrings; i++, psi++)
            {
                if (psi->psiNext)
                    psi->psiNext = (psi->psiNext - m_psiStrings) + psiBuf;
            }
            for (i=0, ppsi=m_Hash; i<STRING_HASH_SIZE; i++, ppsi++)
            {
                if (*ppsi)
                    *ppsi = (*ppsi - m_psiStrings) + psiBuf;
            }

            m_psiStrings = psiBuf;
        }
    }

    m_psiStrings[m_iNumStrings].lpwstr  = lpwstr;
    m_psiStrings[m_iNumStrings].iLen    = iLen;
    m_psiStrings[m_iNumStrings].psiNext = m_Hash[iHash];
    m_Hash[iHash] = &m_psiStrings[m_iNumStrings];
    m_iNumStrings++;
    return TRUE;
}


#ifdef DEBUG
// WARNING: this clobbers the hash
void CWCStringList::SpewHashStats(BOOL fVerbose)
{
/*
    int i;
    for (i = 0; i < STRING_HASH_SIZE; ++i)
    {
        int c = 0;

        for (tagStringIndex *p = m_Hash[i]; p; p = p->psiNext)
            ++c;

        if (c)
            TraceMsg(TF_THISMODULE,"%10d%12d", i, c);
    }
*/

 
    TraceMsg(TF_THISMODULE,"### Hash size: %d       Num. entries:%7d", STRING_HASH_SIZE, m_iNumStrings);
    int i,n;
    if (fVerbose)
    {
        TraceMsg(TF_THISMODULE," # of entries    # of keys with that many");
        for (i=0,n=0; n<STRING_HASH_SIZE; i++)
        {
            int k=0;
            for (int j=0; j<STRING_HASH_SIZE; j++)
            {
                int c=0;
                for (tagStringIndex* p=m_Hash[j]; p; p=p->psiNext)
                    c++;
                if (c == i)
                    k++;
            }
            if (k)
            {
                TraceMsg(TF_THISMODULE,"%10d%12d", i, k);
                n += k;
            }
        }
    }

/*
    int total=0;
    if (fVerbose)
    {
        TraceMsg(TF_THISMODULE," length   # of strings with that length",1);
        for (i=0,n=0; n<m_iNumStrings; i++)
        {
            int k=0;
            for (int j=0; j<m_iNumStrings; j++)
            {
                if (m_psiStrings[j].iLen == i)
                    k++;
            }
            if (k)
            {
                if (fVerbose)
                    TraceMsg(TF_THISMODULE,"%5d%10d", i, k);
                n += k;
                total += k*(k+1)/2;
            }
        }
    }
    TraceMsg(TF_THISMODULE,"### Average compares without hash * 100:%5d", total*100/m_iNumStrings);

    total=0;
    for (i=0; i<STRING_HASH_SIZE; i++)
    {
        for (tagStringIndex* p=m_Hash[i]; p; p=p->psiNext)
        {
            if (p->iLen < 0) continue;
            int n=1;
            for (tagStringIndex* q=p->psiNext; q; q=q->psiNext)
            {
                if (p->iLen == q->iLen)
                {
                    n++;
                    q->iLen = -1;
                }
            }
            total += n*(n+1)/2;
        }
    }
    TraceMsg(TF_THISMODULE,"### Average compares with hash * 100:%8d", total*100/m_iNumStrings);
*/
}
#endif

//----------------------------------------------------------------------------
// CWCDwordStringList
CWCDwordStringList::CWCDwordStringList() : CWCStringList()
{
}

CWCDwordStringList::~CWCDwordStringList()
{
    if (m_pData)
        MemFree((HLOCAL)m_pData);
}

BOOL CWCDwordStringList::Init(int iInitBufSize/*=-1*/)
{
    if (!CWCStringList::Init(iInitBufSize))
        return FALSE;

    m_pData = (DWORD_PTR*)MemAlloc(LMEM_FIXED, m_iMaxStrings * sizeof(DWORD));
    if (NULL == m_pData)
        return FALSE;

    return TRUE;
}

int CWCDwordStringList::AddString(LPCWSTR psz, DWORD_PTR dwData/*=0*/, int* piNum/*=NULL*/)
{
    int iOldMaxStrings = m_iMaxStrings;     // track changes in m_iMaxStrings by this call:
    int iNum;
    int iResult = CWCStringList::AddString(psz, 0, &iNum);

    if (iResult == 0)
        return 0;

    if (iOldMaxStrings != m_iMaxStrings)    // make sure we have enough data space
    {
        DWORD_PTR *pData;
//      TraceMsg(TF_THISMODULE, "DwordStringList expanding dwords to %d", m_iMaxStrings);
        pData = (DWORD_PTR*)MemReAlloc((HLOCAL)m_pData, m_iMaxStrings * sizeof(DWORD),
            LMEM_MOVEABLE);
        ASSERT(pData);
        if (!pData)
        {
            DBG_WARN("Realloc failure in DwordStringList");
            MemFree(m_pData);
            m_pData = NULL;         // This is bad
            return 0;
        }

        m_pData = pData;
    }

    if (iResult == 2)       // only set data value if this is a new string
    {
        m_pData[iNum] = dwData;
    }

    if (piNum)
        *piNum = iNum;
    return iResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\trkcache.h ===
// 
// Pei-Hwa Lin (peiwhal), Feb 3, 1997
//
#include "msxml.h"

#ifndef TRACKCACHE_H_
#define TRACKCACHE_H_

#define MAX_CONTENT_LENGTH 2048

#define TRK_BOTH    0x00000000
#define TRK_OFFLINE 0x00000001
#define TRK_ONLINE  0x00000002

// default internet cache entry info size
#define MY_CACHE_FILE_ENTRY_SIZE     2048

#define MY_WEBCHECK_POST_REG \
        WEBCHECK_REGKEY TEXT("\\Log")

const TCHAR c_szEmptyLog[] = TEXT(" ");
#define c_ccEmptyLog (ARRAYSIZE(c_szEmptyLog) - 1)

LPTSTR ReadTrackingPrefix(void);

HRESULT CreateLogCacheEntry(LPCTSTR lpPfxUrl, FILETIME ftExpire, FILETIME ftModified, DWORD dwPurgeTime);

//////////////////////////////////////////////////////////////////////////
//
// Utility Class
//
//////////////////////////////////////////////////////////////////////////
class CChannelAgent;
class CTrackingCacheClassFactory;

class CUrlTrackingCache
{

protected:
    ULONG           m_cRef;         // OLE ref count

public:
     CUrlTrackingCache(ISubscriptionItem* pCDFStartItem,
                       LPCWSTR pwszURL);
    ~CUrlTrackingCache();

    HRESULT              ProcessTrackingInItem(IXMLElement *pTracking, LPCWSTR pwszUrl, BOOL fForceLog);
    HRESULT              ProcessTrackingInLog (IXMLElement *pTracking);

    LPCWSTR              get_PostURL(void) { return _pwszPostUrl; }

protected:
    HRESULT              RunChildElement(IXMLElement* pElement);
    HRESULT              ProcessItemInEnum(LPCWSTR pwszTagName, IXMLElement *pItem);
    HRESULT              ReadAttribute(IXMLElement* pItem, LPCWSTR pwszAttributeName, LPWSTR* pwszAttributeValue);
    //HRESULT              DoLogEventAttribute(IXMLElement* pItem, LPCWSTR pwszAttributeName);

    void                 Init(LPCWSTR pwszURL);

    void                 DoBaseURL(LPCWSTR pwszURL);
    BOOL                 IsValidURL(LPCTSTR lpszURL);             
    BOOL                 ConvertToPrefixedUrl(LPCTSTR lpszUrl, LPTSTR * lplpPrefixedUrl);
    LPINTERNET_CACHE_ENTRY_INFO  RetrieveUrlCacheEntry(LPCTSTR lpUrl);
    HRESULT              CreatePrefixedCacheEntry(LPCTSTR lpUrl);
    
    HRESULT              AddToTrackingCacheEntry(LPCWSTR pwszUrl);

private:
    // channel properties
    //data
    GROUPID                 _groupId;

    LPWSTR                  _pwszPostUrl;
    LPWSTR                  _pwszEncodingMethod;
    LPWSTR                  _pwszPurgeTime;
    BOOL                    _bTrackIt;

    LPTSTR                  _pszChannelUrlSite;
    LPTSTR                  _pszPostUrlSite;
    LPTSTR                  _lpPfx;
    DWORD                   _dwPurgeTime;            // in Day
    DWORD                   _ConnectionScope;

    ISubscriptionItem*      _pCDFStartItem;
};

#endif TRACKCACHE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\utils.cpp ===
#include "private.h"
#include "chanmgr.h"
#include "chanmgrp.h"
#include "shguidp.h"
#include "resource.h"
#define DECL_CRTFREE
#include <crtfree.h>


#include <mluisupp.h>

#define TF_DUMPTRIGGER              0x80000000

#define PtrDifference(x,y)          ((LPBYTE)(x)-(LPBYTE)(y))

// Invoke Command verb strings
const CHAR c_szOpen[]          = "open";
const CHAR c_szDelete[]        = "delete";
const CHAR c_szProperties[]    = "properties";
const CHAR c_szCopy[]          = "copy";
const CHAR c_szRename[]        = "rename";
const CHAR c_szPaste[]         = "paste";

static TCHAR szNone[40] = {0};
static TCHAR szUnknown[40] = {0};

// For each notification handler CLSID in the registry, send a single CommandId and Cookie to each handler.
void FireSubscriptionEvent(int nCmdID, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie_ua)
{
    HKEY hkey;
    SUBSCRIPTIONCOOKIE cookie_buf;
    SUBSCRIPTIONCOOKIE *pCookie;

    ASSERT( pCookie_ua );

    if ( ! pCookie_ua )
    {
        TraceMsg(TF_ERROR, "FireSubscriptionEvent() - pCookie_ua is NULL!");
        return;
    }

    //
    // Make an aligned copy of pCookie_ua and set a pointer to it.
    //

    cookie_buf = *pCookie_ua;
    pCookie = &cookie_buf;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WEBCHECK_REGKEY_NOTF, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        LPOLESTR pszCookie;

        if (SUCCEEDED(StringFromCLSID(*pCookie, &pszCookie)))
        {
            VARIANT varCookie;

            varCookie.vt = VT_BSTR;
            varCookie.bstrVal = SysAllocString(pszCookie);

            if (varCookie.bstrVal)
            {
                for (int i = 0; ; i++)
                {
                    TCHAR szClsid[GUIDSTR_MAX];
                    DWORD cchClsid = ARRAYSIZE(szClsid);
                    DWORD dwType;
                    DWORD dwData;
                    DWORD cbData = sizeof(dwData);

                    int result = RegEnumValue(hkey, i, szClsid, &cchClsid, NULL, &dwType, (LPBYTE)&dwData, &cbData);

                    if (ERROR_NO_MORE_ITEMS == result)
                    {
                        break;
                    }

                    if ((ERROR_SUCCESS == result) && (dwData & nCmdID))
                    {
                        WCHAR wszClsid[GUIDSTR_MAX];
                        CLSID clsid;

                        SHTCharToUnicode(szClsid, wszClsid, ARRAYSIZE(wszClsid));

                        HRESULT hr = CLSIDFromString(wszClsid, &clsid);

                        if (SUCCEEDED(hr))
                        {
                            IOleCommandTarget *pCmdTarget;

                            hr = CoCreateInstance(*(&clsid), NULL, CLSCTX_ALL, IID_IOleCommandTarget, (void **)&pCmdTarget);
                            if (SUCCEEDED(hr))
                            {
                                pCmdTarget->Exec(&CLSID_SubscriptionMgr, nCmdID, 0, &varCookie, NULL);
                                pCmdTarget->Release();
                            }
                        }
                    }
                }

                VariantClear(&varCookie);
            }

            CoTaskMemFree(pszCookie);
        }

        RegCloseKey( hkey );
    }
}

HRESULT IExtractIcon_GetIconLocationThunk(IExtractIconW *peiw, UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    HRESULT hr;
    WCHAR *pwszIconFile = new WCHAR[cchMax];

    if (NULL != pwszIconFile)
    {
        hr = peiw->GetIconLocation(uFlags, pwszIconFile, cchMax, piIndex, pwFlags);

        if (SUCCEEDED(hr))
        {
            WideCharToMultiByte(CP_ACP, 0, pwszIconFile, -1, szIconFile, cchMax, NULL, NULL);
        }

        delete [] pwszIconFile;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT IExtractIcon_ExtractThunk(IExtractIconW *peiw, LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    HRESULT hr;
    int len = lstrlenA(pszFile) + 1;
    WCHAR *pwszFile = new WCHAR[len];

    if (NULL != pwszFile)
    {
        MultiByteToWideChar(CP_ACP, 0, pszFile, len, pwszFile, len);

        hr = peiw->Extract(pwszFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);

        delete [] pwszFile;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

DWORD Random(DWORD nMax)
{
    static DWORD dwSeed = GetTickCount();

    if (nMax)
    {
        return dwSeed = (dwSeed * 214013L + 2531011L) % nMax;
    }
    else
    {
        return 0;
    }
}

void CreateCookie(GUID UNALIGNED *pCookie_ua)
{
    static DWORD dwCount = 0;

    union CUCookie
    {
        GUID guidCookie;
        struct XCookie {
            FILETIME ft;
            DWORD    dwCount;
            DWORD    dwRand;
        } x;
    };

    CUCookie uc;
    GetSystemTimeAsFileTime(&uc.x.ft);
    uc.x.dwCount = dwCount++;
    uc.x.dwRand = Random(0xffffffff);

    *pCookie_ua = uc.guidCookie;
}

void VariantTimeToFileTime(double dt, FILETIME& ft)
{
    SYSTEMTIME st;

    VariantTimeToSystemTime(dt, &st);
    SystemTimeToFileTime(&st, &ft);
}

//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Cache helper functions
//

// Caller should MemFree *lpCacheConfigInfo when done. Should pass *lpCacheConfigInfo
//  into SetCacheSize
HRESULT GetCacheInfo(
    LPINTERNET_CACHE_CONFIG_INFOA *lplpCacheConfigInfo,
    DWORD                        *pdwSizeInKB,
    DWORD                        *pdwPercent)
{
    HRESULT hr = S_OK;
    LPINTERNET_CACHE_CONFIG_INFOA lpCCI = NULL;
    DWORD dwSize;

    dwSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);

    lpCCI = (LPINTERNET_CACHE_CONFIG_INFOA)MemAlloc(LPTR, dwSize);

    if (!lpCCI)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    lpCCI->dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);

    if (!GetUrlCacheConfigInfoA(lpCCI, &dwSize, CACHE_CONFIG_CONTENT_PATHS_FC))
    {
        hr = E_FAIL; // HRESULT_FROM_WIN32(GetLastError());
        goto cleanup;
    }

    // there should be at least one cache path structure
    if (dwSize < sizeof(INTERNET_CACHE_CONFIG_INFOA) ||
        lpCCI->dwNumCachePaths != 1)
    {
        // something is messed up
        hr = E_FAIL;
        goto cleanup;
    }

    *lplpCacheConfigInfo = lpCCI;
    *pdwSizeInKB = lpCCI->dwQuota;
    *pdwPercent = 10; // good faith estimate

    ASSERT(*pdwSizeInKB);   // Better not be 0...

cleanup:

    if (FAILED(hr))
    {
        SAFELOCALFREE(lpCCI);
    }

    return hr;
}

HRESULT SetCacheSize(
            LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
            DWORD                        dwSizeInKB)
{
//  lpCacheConfigInfo->dwNumCachePaths = 1;
//  lpCacheConfigInfo->CachePaths[0].dwCacheSize = dwSizeInKB;
    lpCacheConfigInfo->dwContainer = 0; // CONTENT;
    lpCacheConfigInfo->dwQuota = dwSizeInKB;

    if (!SetUrlCacheConfigInfoA(lpCacheConfigInfo, CACHE_CONFIG_QUOTA_FC))
    {
        return E_FAIL; // HRESULT_FROM_WIN32(GetLastError());
    }

    return S_OK;
}


//////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////

//
// Registry helper functions
//
BOOL ReadRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                   void *pData, DWORD dwBytes)
{
    return ERROR_SUCCESS == SHRegGetValue(hkeyRoot, pszKey, pszValue, SRRF_RT_ANY | SRRF_NOEXPAND, NULL, pData, &dwBytes);
}

BOOL WriteRegValue(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue,
                    void *pData, DWORD dwBytes, DWORD dwType)
{
    HKEY    hkey;
    long    lResult;
    DWORD   dwStatus;

    lResult = RegCreateKeyEx(hkeyRoot, pszKey, 0, NULL,
            REG_OPTION_NON_VOLATILE, KEY_SET_VALUE, NULL, &hkey, &dwStatus);
    if (lResult != ERROR_SUCCESS) {
        return FALSE;
    }

    lResult = RegSetValueEx(hkey, pszValue, 0, dwType, (BYTE *)pData, dwBytes);
    RegCloseKey(hkey);

    return (lResult == ERROR_SUCCESS) ? TRUE : FALSE;
}

DWORD ReadRegDWORD(HKEY hkeyRoot, const TCHAR *pszKey, const TCHAR *pszValue)
{
    DWORD dwData;
    if (ReadRegValue(hkeyRoot, pszKey, pszValue, &dwData, sizeof(dwData)))
        return dwData;
    else
        return 0;
}

HRESULT CreateShellFolderPath(LPCTSTR pszPath, LPCTSTR pszGUID, BOOL bUICLSID)
{
    if (!PathFileExists(pszPath))
        CreateDirectory(pszPath, NULL);

    // Mark the folder as a system directory
    if (SetFileAttributes(pszPath, FILE_ATTRIBUTE_READONLY))
    {
        TCHAR szDesktopIni[MAX_PATH];
        // Write in the desktop.ini the cache folder class ID
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);

        // (First, flush the cache to make sure the desktop.ini
        // file is really created.)
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);
        WritePrivateProfileString(TEXT(".ShellClassInfo"), bUICLSID ? TEXT("UICLSID") : TEXT("CLSID"), pszGUID, szDesktopIni);
        WritePrivateProfileString(NULL, NULL, NULL, szDesktopIni);

        // Hide the desktop.ini since the shell does not selectively
        // hide it.
        SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_HIDDEN);

        return NOERROR;
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("Cannot make %s a system folder"), pszPath);
        return E_FAIL;
    }
}

void CleanupShellFolder(LPCTSTR pszPath)
{
    if (PathFileExists(pszPath))
    {
        TCHAR szDesktopIni[MAX_PATH];

        // make the history a normal folder
        SetFileAttributes(pszPath, FILE_ATTRIBUTE_NORMAL);
        PathCombine(szDesktopIni, pszPath, TEXT("desktop.ini"));

        // If the desktop.ini already exists, make sure it is writable
        if (PathFileExists(szDesktopIni))
        {
            SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
            DeleteFile(szDesktopIni);
        }

        // remove the history directory
        RemoveDirectory(pszPath);
    }
}

BOOL GetSubscriptionFolderPath(LPTSTR pszPath, DWORD cchPath)
{
    DWORD dwDummy;
    HKEY hk;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                        REGSTR_PATH_SUBSCRIPTION,
                                        0, TEXT(""),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy))
    {
        DWORD cbData = cchPath * sizeof(TCHAR);
        if (ERROR_SUCCESS != SHRegGetValue(hk, NULL, REGSTR_VAL_DIRECTORY, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, pszPath, &cbData))
        {
            TCHAR szWindows[MAX_PATH];
            GetWindowsDirectory(szWindows, ARRAYSIZE(szWindows));
            PathCombine(pszPath, szWindows, TEXT("Offline Web Pages"));
        }
        RegCloseKey(hk);

        return TRUE;
    }
    return FALSE;
}

HRESULT GetChannelPath(LPCTSTR pszURL, LPTSTR pszPath, int cch,
                       IChannelMgrPriv** ppIChannelMgrPriv)
{
    ASSERT(pszURL);
    ASSERT(pszPath || 0 == cch);
    ASSERT(ppIChannelMgrPriv);

    HRESULT hr;
    BOOL    bCoinit = FALSE;

    hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IChannelMgrPriv, (void**)ppIChannelMgrPriv);

    if ((hr == CO_E_NOTINITIALIZED || hr == REGDB_E_IIDNOTREG) &&
        SUCCEEDED(CoInitialize(NULL)))
    {
        bCoinit = TRUE;
        hr = CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                          IID_IChannelMgrPriv, (void**)ppIChannelMgrPriv);
    }

    if (SUCCEEDED(hr))
    {
        ASSERT(*ppIChannelMgrPriv);

        IChannelMgr* pIChannelMgr;

        hr = (*ppIChannelMgrPriv)->QueryInterface(IID_IChannelMgr,
                                                (void**)&pIChannelMgr);

        if (SUCCEEDED(hr))
        {
            ASSERT(pIChannelMgr);

            WCHAR wszURL[INTERNET_MAX_URL_LENGTH];
            MyStrToOleStrN(wszURL, ARRAYSIZE(wszURL), pszURL);

            IEnumChannels* pIEnumChannels;

            hr = pIChannelMgr->EnumChannels(CHANENUM_ALLFOLDERS | CHANENUM_PATH,
                                            wszURL, &pIEnumChannels);

            if (SUCCEEDED(hr))
            {
                ASSERT(pIEnumChannels);

                CHANNELENUMINFO ci;

                if (S_OK == pIEnumChannels->Next(1, &ci, NULL))
                {
                    MyOleStrToStrN(pszPath, cch, ci.pszPath);

                    CoTaskMemFree(ci.pszPath);
                }
                else
                {
                    hr = E_FAIL;
                }

                pIEnumChannels->Release();
            }

            pIChannelMgr->Release();
        }

    }

    if (bCoinit)
        CoUninitialize();

    ASSERT((SUCCEEDED(hr) && *ppIChannelMgrPriv) || FAILED(hr));

    return hr;
}


//  Caller is responsible for calling ILFree on *ppidl.
HRESULT ConvertPathToPidl(LPCTSTR path, LPITEMIDLIST * ppidl)
{
    WCHAR wszPath[MAX_PATH];
    IShellFolder * pDesktopFolder;
    HRESULT hr;

    ASSERT(path && ppidl);
    * ppidl = NULL;

    MyStrToOleStrN(wszPath, MAX_PATH, path);
    hr = SHGetDesktopFolder(&pDesktopFolder);
    if (hr != NOERROR)
        return hr;

    ULONG uChEaten;

    hr = pDesktopFolder->ParseDisplayName(NULL, NULL, wszPath,
                                            &uChEaten, ppidl, NULL);
    SAFERELEASE(pDesktopFolder);

    return hr;
}

LPITEMIDLIST    GetSubscriptionFolderPidl(void)
{
    TCHAR szPath[MAX_PATH];
    static LPITEMIDLIST pidlFolder = NULL;  //  We leak here.

    if (!pidlFolder)  {
        if (!(GetSubscriptionFolderPath(szPath, ARRAYSIZE(szPath))))
            return NULL;
        if (FAILED(ConvertPathToPidl(szPath, &pidlFolder)))
            return NULL;
        ASSERT(pidlFolder);
    }
    return (LPITEMIDLIST)pidlFolder;
}

STDAPI OfflineFolderRegisterServer(void)
{
    TCHAR szOldSubscriptionPath[MAX_PATH];

    GetWindowsDirectory(szOldSubscriptionPath, ARRAYSIZE(szOldSubscriptionPath));
    PathCombine(szOldSubscriptionPath, szOldSubscriptionPath, TEXT("Subscriptions"));
    CleanupShellFolder(szOldSubscriptionPath);

    TCHAR szPath[MAX_PATH];

    if (!(GetSubscriptionFolderPath(szPath, ARRAYSIZE(szPath))))
        goto CleanUp;

    // we pass FALSE because history folder uses CLSID
    if (FAILED(CreateShellFolderPath(szPath, TEXT("{F5175861-2688-11d0-9C5E-00AA00A45957}"), FALSE)))
        goto CleanUp;

    return NOERROR;

CleanUp:        // cleanup stuff if any of our reg stuff fails

    return E_FAIL;
}

STDAPI OfflineFolderUnregisterServer(void)
{
    TCHAR szPath[MAX_PATH];

    if (!(GetSubscriptionFolderPath(szPath, ARRAYSIZE(szPath))))
        goto CleanUp;

    // we pass FALSE because history folder uses CLSID
    CleanupShellFolder(szPath);

    return NOERROR;

CleanUp:        // cleanup stuff if any of our reg stuff fails

    return E_FAIL;
}



HMENU LoadPopupMenu(UINT id, UINT uSubOffset)
{
    HMENU hmParent, hmPopup;

    hmParent = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(id));
    if (!hmParent)
        return NULL;

    hmPopup = GetSubMenu(hmParent, uSubOffset);
    RemoveMenu(hmParent, uSubOffset, MF_BYPOSITION);
    DestroyMenu(hmParent);

    return hmPopup;
}

UINT MergePopupMenu(HMENU *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu,  UINT idCmdFirst, UINT idCmdLast)
{
    HMENU hmMerge;

    if (*phMenu == NULL)
    {
        *phMenu = CreatePopupMenu();
        if (*phMenu == NULL)
            return 0;

        indexMenu = 0;    // at the bottom
    }

    hmMerge = LoadPopupMenu(idResource, uSubOffset);
    if (!hmMerge)
        return 0;

    idCmdLast = Shell_MergeMenus(*phMenu, hmMerge, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);

    DestroyMenu(hmMerge);
    return idCmdLast;
}

HMENU GetMenuFromID(HMENU hmenu, UINT idm)
{
    MENUITEMINFO mii = { sizeof(mii), MIIM_SUBMENU, 0, 0, 0, NULL, NULL, NULL, 0, NULL, 0 };
    GetMenuItemInfo(hmenu, idm, FALSE, &mii);
    return mii.hSubMenu;
}

UINT MergeMenuHierarchy(HMENU hmenuDst, HMENU hmenuSrc, UINT idcMin, UINT idcMax, BOOL bTop)
{
    UINT idcMaxUsed = idcMin;
    int imi = GetMenuItemCount(hmenuSrc);

    while (--imi >= 0)
    {
        MENUITEMINFO mii = {
                sizeof(MENUITEMINFO),
                MIIM_ID | MIIM_SUBMENU,
                0,/* fType */ 0,/* fState */ 0,/*wId*/ NULL,
                NULL, NULL, 0,
                NULL, 0 };

        if (GetMenuItemInfo(hmenuSrc, imi, TRUE, &mii))
        {
            UINT idcT = Shell_MergeMenus(
                            GetMenuFromID(hmenuDst, mii.wID),
                            mii.hSubMenu, (bTop)?0:1024, idcMin, idcMax,
                            MM_ADDSEPARATOR | MM_SUBMENUSHAVEIDS);
            idcMaxUsed = max(idcMaxUsed, idcT);
        }
    }
    return idcMaxUsed;
}

///////////////////////////////////////////////////////////////////////////////
//
// Helper Fuctions for item.cpp and folder.cpp
//
///////////////////////////////////////////////////////////////////////////////

int _CompareURL(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    return UrlCompare(URL(&(pooi1->ooe)), URL(&(pooi2->ooe)), TRUE);
}

int _CompareShortName(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    PCTSTR pszNameLocal1;
    PCTSTR pszNameLocal2;

    LPTSTR szNameUnaligned1 = NAME(&(pooi1->ooe));
    LPTSTR szNameUnaligned2 = NAME(&(pooi2->ooe));

    TSTR_ALIGNED_STACK_COPY( &pszNameLocal1, szNameUnaligned1 );
    TSTR_ALIGNED_STACK_COPY( &pszNameLocal2, szNameUnaligned2 );

    return StrCmp( pszNameLocal1, pszNameLocal2 );
}

int _CompareLastUpdate(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    if (pooi1->ooe.m_LastUpdated - pooi2->ooe.m_LastUpdated > 0)
        return 1;
    return -1;
}

int _CompareCookie(REFCLSID cookie1, REFCLSID cookie2)
{
    return memcmp(&cookie1, &cookie2, sizeof(CLSID));
}

int _CompareStatus(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    return StrCmp(STATUS(&(pooi1->ooe)), STATUS(&(pooi2->ooe)));
}

int _CompareIdentities(LPMYPIDL pooi1, LPMYPIDL pooi2)
{
    if (pooi1->ooe.clsidDest != pooi2->ooe.clsidDest)
        return -1;

    if (!IsNativeAgent(pooi1->ooe.clsidDest))
        return _CompareCookie(pooi1->ooe.m_Cookie, pooi2->ooe.m_Cookie);

    return _CompareURL(pooi1, pooi2);
}

BOOL _ValidateIDListArray(UINT cidl, LPCITEMIDLIST *ppidl)
{
    UINT i;

    for (i = 0; i < cidl; i++)
    {
        if (!IS_VALID_MYPIDL(ppidl[i]))
            return FALSE;
    }

    return TRUE;
}

int _LaunchApp(HWND hwnd, LPCTSTR pszPath)
{
    SHELLEXECUTEINFO ei = { 0 };

    ei.cbSize           = sizeof(SHELLEXECUTEINFO);
    ei.hwnd             = hwnd;
    ei.lpFile           = pszPath;
    ei.nShow            = SW_SHOWNORMAL;

    return ShellExecuteEx(&ei);
}

void _GenerateEvent(LONG lEventId, LPITEMIDLIST pidlIn, LPITEMIDLIST pidlNewIn, BOOL bRefresh)
{
    LPITEMIDLIST pidlFolder = GetSubscriptionFolderPidl();
    if (!pidlFolder)
        return;

    LPITEMIDLIST pidl = ILCombine(pidlFolder, pidlIn);
    if (pidl)
    {
        if (pidlNewIn)
        {
            LPITEMIDLIST pidlNew = ILCombine(pidlFolder, pidlNewIn);
            if (pidlNew)
            {
                SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, pidlNew);
                ILFree(pidlNew);
            }
        }
        else
        {
            SHChangeNotify(lEventId, SHCNF_IDLIST, pidl, NULL);
        }
        if (bRefresh)
            SHChangeNotifyHandleEvents();
        ILFree(pidl);
    }
}

BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;

    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_NATIVEFNTCTL_CLASS | ICC_DATE_CLASSES;
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}

const struct {
    LPCSTR pszVerb;
    UINT idCmd;
} rgcmds[] = {
    { c_szOpen,         RSVIDM_OPEN },
    { c_szCopy,         RSVIDM_COPY },
    { c_szRename,       RSVIDM_RENAME},
    { c_szPaste,        RSVIDM_PASTE},
    { c_szDelete,       RSVIDM_DELETE },
    { c_szProperties,   RSVIDM_PROPERTIES }
};

int _GetCmdID(LPCSTR pszCmd)
{
    if (HIWORD(pszCmd))
    {
        int i;
        for (i = 0; i < ARRAYSIZE(rgcmds); i++)
        {
            if (lstrcmpiA(rgcmds[i].pszVerb, pszCmd) == 0)
            {
                return rgcmds[i].idCmd;
            }
        }

        return -1;  // unknown
    }
    return (int)LOWORD(pszCmd);
}

BOOL CALLBACK _AddOnePropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER * ppsh = (PROPSHEETHEADER *) lParam;

    if (ppsh->nPages < MAX_PROP_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

HRESULT _CreatePropSheet(HWND hwnd, POOEBuf pBuf)
{
    ASSERT(pBuf);

    ISubscriptionMgr    * pSub= NULL;
    HRESULT hr = CoInitialize(NULL);
    RETURN_ON_FAILURE(hr);

    hr = CoCreateInstance(CLSID_SubscriptionMgr, NULL, CLSCTX_INPROC_SERVER,
                IID_ISubscriptionMgr, (void **)&pSub);
    CoUninitialize();
    RETURN_ON_FAILURE(hr);
    ASSERT(pSub);

    BSTR bstrURL = NULL;
    hr = CreateBSTRFromTSTR(&bstrURL, pBuf->m_URL);
    if (S_OK == hr)
        hr = pSub->ShowSubscriptionProperties(bstrURL, hwnd);
    SAFERELEASE(pSub);
    SAFEFREEBSTR(bstrURL);
    return hr;
}

//  Note:
//      We return FALSE on illegal DATE data.

BOOL DATE2DateTimeString(CFileTime& ft, LPTSTR pszText, int cchText)
{
    SYSTEMTIME st;

    if (ft == 0)    {
        if (szUnknown[0] == 0)
            MLLoadString(IDS_UNKNOWN, szUnknown, ARRAYSIZE(szUnknown));

        StrCpyN(pszText, szUnknown, cchText);
        return FALSE;
    }

    if (!FileTimeToSystemTime(&ft, &st))
    {
        if (szNone[0] == 0)
            MLLoadString(IDS_NONE, szNone, ARRAYSIZE(szNone));

        StrCpyN(pszText, szNone, cchText);
        return FALSE;
    }
    GetDateFormat(LOCALE_USER_DEFAULT, DATE_SHORTDATE, &st, NULL, pszText, cchText);
    StrCatBuff(pszText, L" ", cchText);

    int nLen = lstrlen(pszText);

    if (nLen >= cchText)
    {
        return FALSE;
    }        
    pszText += nLen;
    GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &st, NULL, pszText, cchText - nLen);
    return TRUE;
}

void CopyToOOEBuf(POOEntry pooe, POOEBuf pBuf)
{
    ASSERT(pooe);
    ASSERT(pBuf);

    pBuf->dwFlags           = pooe->dwFlags;
    pBuf->m_LastUpdated     = pooe->m_LastUpdated;
    pBuf->m_NextUpdate      = pooe->m_NextUpdate;
    pBuf->m_SizeLimit       = pooe->m_SizeLimit;
    pBuf->m_ActualSize      = pooe->m_ActualSize;
    pBuf->m_RecurseLevels   = pooe->m_RecurseLevels;
    pBuf->m_RecurseFlags    = pooe->m_RecurseFlags;
    pBuf->m_Priority        = pooe->m_Priority;
    pBuf->bDesktop          = pooe->bDesktop;
    pBuf->bChannel          = pooe->bChannel;
    pBuf->bMail             = pooe->bMail;
    pBuf->bGleam            = pooe->bGleam;
    pBuf->bChangesOnly      = pooe->bChangesOnly;
    pBuf->fChannelFlags     = pooe->fChannelFlags;
    pBuf->bNeedPassword     = pooe->bNeedPassword;
    pBuf->m_Cookie          = pooe->m_Cookie;
    pBuf->groupCookie       = pooe->groupCookie;
    pBuf->grfTaskTrigger    = pooe->grfTaskTrigger;
    pBuf->m_Trigger         = pooe->m_Trigger;
    pBuf->clsidDest         = pooe->clsidDest;
    pBuf->status            = pooe->status;

    StrCpyN(pBuf->m_URL,       URL(pooe),      ARRAYSIZE(pBuf->m_URL));
    StrCpyN(pBuf->m_Name,      NAME(pooe),     ARRAYSIZE(pBuf->m_Name));
    StrCpyN(pBuf->username,    UNAME(pooe),    ARRAYSIZE(pBuf->username));
    StrCpyN(pBuf->password,    PASSWD(pooe),   ARRAYSIZE(pBuf->password));
    StrCpyN(pBuf->statusStr,   STATUS(pooe),   ARRAYSIZE(pBuf->statusStr));
}

void CopyToMyPooe(POOEBuf pBuf, POOEntry pooe)
{
    UINT    offset = sizeof(OOEntry);
    UINT    srcLen = lstrlen(pBuf->m_URL) + 1;

    ASSERT(pooe);
    ASSERT(pBuf);

    pooe->dwFlags           = pBuf->dwFlags;
    pooe->m_LastUpdated     = pBuf->m_LastUpdated;
    pooe->m_NextUpdate      = pBuf->m_NextUpdate;
    pooe->m_SizeLimit       = pBuf->m_SizeLimit;
    pooe->m_ActualSize      = pBuf->m_ActualSize;
    pooe->m_RecurseLevels   = pBuf->m_RecurseLevels;
    pooe->m_Priority        = pBuf->m_Priority;
    pooe->m_RecurseFlags    = pBuf->m_RecurseFlags;
    pooe->bDesktop          = pBuf->bDesktop;
    pooe->bChannel          = pBuf->bChannel;
    pooe->bMail             = pBuf->bMail;
    pooe->bGleam            = pBuf->bGleam;
    pooe->bChangesOnly      = pBuf->bChangesOnly;
    pooe->fChannelFlags     = pBuf->fChannelFlags;
    pooe->bNeedPassword     = pBuf->bNeedPassword;
    pooe->m_Cookie          = pBuf->m_Cookie;
    pooe->groupCookie       = pBuf->groupCookie;
    pooe->m_Trigger         = pBuf->m_Trigger;
    pooe->grfTaskTrigger    = pBuf->grfTaskTrigger;
    pooe->clsidDest         = pBuf->clsidDest;
    pooe->status            = pBuf->status;

    pooe->m_URL = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->m_URL) + 1;
    StrCpyN(pooe->m_URL, pBuf->m_URL, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->m_URL = (LPTSTR) PtrDifference(pooe->m_URL, pooe);

    pooe->m_Name = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->m_Name) + 1;
    StrCpyN(pooe->m_Name, pBuf->m_Name, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->m_Name = (LPTSTR) PtrDifference(pooe->m_Name, pooe);

    pooe->username = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->username) + 1;
    StrCpyN(pooe->username, pBuf->username, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->username = (LPTSTR) PtrDifference(pooe->username, pooe);

    pooe->password = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->password) + 1;
    StrCpyN(pooe->password, pBuf->password, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->password = (LPTSTR) PtrDifference(pooe->password, pooe);

    pooe->statusStr = (LPTSTR)((LPBYTE)pooe + offset);
    srcLen = lstrlen(pBuf->statusStr) + 1;
    StrCpyN(pooe->statusStr, pBuf->statusStr, srcLen);
    offset += srcLen * sizeof (TCHAR);
    pooe->statusStr = (LPTSTR) PtrDifference(pooe->statusStr, pooe);

    pooe->dwSize = offset;
}

UINT BufferSize(POOEBuf pBuf)
{
    UINT strLen = 0;
    ASSERT(pBuf);

    strLen += lstrlen(pBuf->m_URL)      + 1;
    strLen += lstrlen(pBuf->m_Name)     + 1;
    strLen += lstrlen(pBuf->username)   + 1;
    strLen += lstrlen(pBuf->password)   + 1;
    strLen += lstrlen(pBuf->statusStr)  + 1;

    return strLen * sizeof(TCHAR);
}


typedef struct
{
    int cItems;
    LPCTSTR pszName;
    LPCTSTR pszUrl;
} DELETE_CONFIRM_INFO;

INT_PTR CALLBACK ConfirmDeleteDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

    switch(message) {

        case WM_INITDIALOG:
        {
            DELETE_CONFIRM_INFO* pInfo = (DELETE_CONFIRM_INFO*)lParam;
            ASSERT (pInfo);
            ASSERT(pInfo->cItems == 1);

            SetListViewToString (GetDlgItem (hDlg, IDC_NAME), pInfo->pszName);
            SetListViewToString (GetDlgItem (hDlg, IDC_LOCATION), pInfo->pszUrl);
        }
        break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDYES:
                case IDNO:
                case IDCANCEL:
                    EndDialog(hDlg, wParam);
                    break;
            }
            break;

        case WM_NOTIFY:
            if (LOWORD(wParam) == IDC_LOCATION)
            {
                NM_LISTVIEW * pnmlv = (NM_LISTVIEW *)lParam;
                ASSERT(pnmlv);
                if (pnmlv->hdr.code == LVN_GETINFOTIP)
                {
                    TCHAR szURL[MAX_URL];
                    LV_ITEM lvi = {0};
                    lvi.mask = LVIF_TEXT;
                    lvi.pszText = szURL;
                    lvi.cchTextMax = ARRAYSIZE(szURL);
                    if (!ListView_GetItem (GetDlgItem (hDlg, IDC_LOCATION), &lvi))
                        return FALSE;

                    NMLVGETINFOTIP  * pTip = (NMLVGETINFOTIP *)pnmlv;
                    ASSERT(pTip->pszText);
                    StrCpyN(pTip->pszText, szURL, pTip->cchTextMax);
                    return TRUE;
                }
            }
        return FALSE;

        default:
            return FALSE;

    } // end of switch

    return TRUE;
}

BOOL ConfirmDelete(HWND hwnd, UINT cItems, LPMYPIDL * ppidl)
{
    ASSERT(ppidl);
    INT_PTR iRet;

    // Check if the user is restricted from deleting URLs.
    // If they're deleting multiple, we'll fail if any can fail.
    UINT i;
    for (i = 0; i < cItems; i++)
    {
        if (ppidl[i]->ooe.bChannel)
        {
            if (SHRestricted2(REST_NoRemovingChannels, URL(&(ppidl[i]->ooe)), 0))
            {
                if (IsWindow(hwnd))
                    SGMessageBox(hwnd, IDS_RESTRICTED, MB_OK);
                return FALSE;
            }
        }

        if (!ppidl[i]->ooe.bDesktop)
        {
            // FEATURE: What about desktop components?
            if (SHRestricted2(REST_NoRemovingSubscriptions, URL(&(ppidl[i]->ooe)), 0))
            {
                if (IsWindow(hwnd))
                    SGMessageBox(hwnd, IDS_RESTRICTED, MB_OK);
                return FALSE;
            }
        }
    }

    if (IsWindow(hwnd)) {
        DELETE_CONFIRM_INFO dci = {0};
        dci.cItems = cItems;
        if (cItems == 1)
        {
            dci.pszName = NAME(&(ppidl[0]->ooe));
            dci.pszUrl = URL(&(ppidl[0]->ooe));
            iRet = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_OBJECTDEL_WARNING),
                        hwnd, ConfirmDeleteDlgProc, (LPARAM)&dci);
        }
        else
        {

            TCHAR szFormat[200];
            //  Enough room for format string and int as string
            TCHAR szBuf[ARRAYSIZE(szFormat) + 11];

            MLLoadString(IDS_DEL_MULTIPLE_FMT, szFormat, ARRAYSIZE(szFormat));
            wnsprintf(szBuf, ARRAYSIZE(szBuf), szFormat, cItems);

            MLLoadString(IDS_DELETE_CAPTION, szFormat, ARRAYSIZE(szFormat));

            MSGBOXPARAMS mbp;

            mbp.cbSize = sizeof(MSGBOXPARAMS);
            mbp.hwndOwner = hwnd;
            mbp.hInstance = MLGetHinst();
            mbp.lpszText = szBuf;
            mbp.lpszCaption = szFormat;
            mbp.dwStyle = MB_YESNO | MB_USERICON;
            mbp.lpszIcon = MAKEINTRESOURCE(IDI_OBJECTDELETED);
            iRet = MessageBoxIndirect(&mbp);
        }
        if (iRet == IDYES)
            return TRUE;
        return FALSE;
    } else  {
        return TRUE;
    }
}

BOOL IsHTTPPrefixed(LPCTSTR szURL)
{
    TCHAR szCanonicalURL[MAX_URL];
    DWORD dwSize = MAX_URL;
    URL_COMPONENTS uc;

    memset(&uc, 0, sizeof(URL_COMPONENTS));
    uc.dwStructSize = sizeof(URL_COMPONENTS);

    // Note:  We explicitly check for and allow the "about:home" URL to pass through here.  This allows
    // the Active Desktop "My Current Home Page" component to specify that URL when creating and managing
    // it's subscription which is consistent with it's use of that form in the browser.
    if (!InternetCanonicalizeUrl(szURL, szCanonicalURL, &dwSize, ICU_DECODE) ||
        !InternetCrackUrl(szCanonicalURL, 0, 0, &uc) ||
        ((INTERNET_SCHEME_HTTP != uc.nScheme) && (INTERNET_SCHEME_HTTPS != uc.nScheme) && (0 != StrCmpI(TEXT("about:home"), szURL))))
    {
        return FALSE;
    }
    return TRUE;
}

//   Checks if global state is offline

BOOL IsGlobalOffline(void)
{
    DWORD   dwState = 0, dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;
    HANDLE hModuleHandle = LoadLibraryA("wininet.dll");

    if(!hModuleHandle)
        return FALSE;

    if(InternetQueryOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &dwState,
        &dwSize))
    {
        if(dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
            fRet = TRUE;
    }

    return fRet;
}

void SetGlobalOffline(BOOL fOffline)
{
    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    if(fOffline) {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}


//helper function to create one column in a ListView control, add one item to that column,
//size the column to the width of the control, and color the control like a static...
//basically, like SetWindowText for a ListView.  Because we use a lot of ListViews to display
//urls that would otherwise be truncated... the ListView gives us automatic ellipsis and ToolTip.
void SetListViewToString (HWND hLV, LPCTSTR pszString)
{
    ASSERT(hLV);

    LV_COLUMN   lvc = {0};
    RECT lvRect;
    GetClientRect (hLV, &lvRect);
    lvc.mask = LVCF_WIDTH;
    lvc.cx = lvRect.right - lvRect.left;
    if (-1 == ListView_InsertColumn(hLV, 0, &lvc))   {
        ASSERT(0);
    }

    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_INFOTIP, LVS_EX_INFOTIP);

    LV_ITEM lvi = {0};
    lvi.iSubItem = 0;
    lvi.pszText = (LPTSTR)pszString;
    lvi.mask = LVIF_TEXT;
    ListView_InsertItem(hLV, &lvi);
    ListView_EnsureVisible(hLV, 0, TRUE);

    ListView_SetBkColor(hLV, GetSysColor(COLOR_BTNFACE));
    ListView_SetTextBkColor(hLV, GetSysColor(COLOR_BTNFACE));
}

int WCMessageBox(HWND hwnd, UINT idTextFmt, UINT idCaption, UINT uType, ...)
{
    TCHAR szCaption[256];
    TCHAR szTextFmt[512];
    LPTSTR pszText;
    int result;
    va_list va;

    va_start(va, uType);

    szCaption[0] = 0;

    MLLoadString(idTextFmt, szTextFmt, ARRAYSIZE(szTextFmt));

    if (idCaption <= 0)
    {
        if (NULL != hwnd)
        {
            GetWindowText(hwnd, szCaption, ARRAYSIZE(szCaption));
        }

        //  This handles GetWindowText failure and a NULL hwnd
        if (0 == szCaption[0])
        {
            #if IDS_DEFAULT_MSG_CAPTION < 1
            #error IDS_DEFAULT_MSG_CAPTION is defined incorrectly
            #endif

            idCaption = IDS_DEFAULT_MSG_CAPTION;
        }
    }

    if (idCaption > 0)
    {
        MLLoadString(idCaption, szCaption, ARRAYSIZE(szCaption));
    }

    ASSERT(0 != szCaption[0]);

    if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                                    szTextFmt, 0, 0, (LPTSTR)&pszText, 0, &va))
    {
        result = MessageBox(hwnd, pszText, szCaption, uType);
        LocalFree(pszText);
    }
    else
    {
        //  FormatMessage failed.  Oh well.  Guess we'll just ask the question
        //  with the format string.  Sure it's ugly but it's better than picking a
        //  totally random return value.

        result = MessageBox(hwnd, szTextFmt, szCaption, uType);
    }

    return result;
}


/////////////////////////////////////////////////////////////////////////////
// SGMessageBox
/////////////////////////////////////////////////////////////////////////////
int SGMessageBox
(
    HWND    hwndParent,
    UINT    idStringRes,
    UINT    uType
)
{
    ASSERT(hwndParent != NULL);
    ASSERT(IsWindow(hwndParent));

    TCHAR szError[512];
    if (!MLLoadString(idStringRes, szError, ARRAYSIZE(szError)))
        return 0;

    TCHAR szTitle[128];
    szTitle[0] = 0;

    if (hwndParent != NULL)
        GetWindowText(hwndParent, szTitle, ARRAYSIZE(szTitle));

    return MessageBox(  hwndParent,
                        szError,
                        ((hwndParent != NULL) ? szTitle : NULL),
                        uType);
}

#ifdef DEBUG
/////////////////////////////////////////////////////////////////////////////
// DumpTaskTrigger
/////////////////////////////////////////////////////////////////////////////
void DumpTaskTrigger
(
    TASK_TRIGGER * pTT
)
{
    TraceMsg(TF_DUMPTRIGGER, "----- BEGIN DumpTaskTrigger -----");

    TraceMsg(TF_DUMPTRIGGER, "cbTriggerSize = %d", pTT->cbTriggerSize);
    TraceMsg(TF_DUMPTRIGGER, "Reserved1 = %d", pTT->Reserved1);
    TraceMsg(TF_DUMPTRIGGER, "wBeginYear = %d", pTT->wBeginYear);
    TraceMsg(TF_DUMPTRIGGER, "wBeginMonth = %d", pTT->wBeginMonth);
    TraceMsg(TF_DUMPTRIGGER, "wBeginDay = %d", pTT->wBeginDay);
    TraceMsg(TF_DUMPTRIGGER, "wEndYear = %d", pTT->wEndYear);
    TraceMsg(TF_DUMPTRIGGER, "wEndMonth = %d", pTT->wEndMonth);
    TraceMsg(TF_DUMPTRIGGER, "wEndDay = %d", pTT->wEndDay);
    TraceMsg(TF_DUMPTRIGGER, "wStartHour = %d", pTT->wStartHour);
    TraceMsg(TF_DUMPTRIGGER, "wStartMinute = %d", pTT->wStartMinute);
    TraceMsg(TF_DUMPTRIGGER, "MinutesDuration = %d", pTT->MinutesDuration);
    TraceMsg(TF_DUMPTRIGGER, "MinutesInterval = %d", pTT->MinutesInterval);
    TraceMsg(TF_DUMPTRIGGER, "rgFlags = %d", pTT->rgFlags);
    TraceMsg(TF_DUMPTRIGGER, "Reserved2 = %d", pTT->Reserved2);
    TraceMsg(TF_DUMPTRIGGER, "wRandomMinutesInterval = %d", pTT->wRandomMinutesInterval);

    switch (pTT->TriggerType)
    {
        case TASK_TIME_TRIGGER_DAILY:
        {
            TraceMsg(TF_DUMPTRIGGER, "DAILY");
            TraceMsg(TF_DUMPTRIGGER, "DaysInterval = %d", pTT->Type.Daily.DaysInterval);
            break;
        }

        case TASK_TIME_TRIGGER_WEEKLY:
        {
            TraceMsg(TF_DUMPTRIGGER, "WEEKLY");
            TraceMsg(TF_DUMPTRIGGER, "WeeksInterval = %d", pTT->Type.Weekly.WeeksInterval);
            TraceMsg(TF_DUMPTRIGGER, "rgfDaysOfTheWeek = %d", pTT->Type.Weekly.rgfDaysOfTheWeek);
            break;
        }

        case TASK_TIME_TRIGGER_MONTHLYDATE:
        {
            TraceMsg(TF_DUMPTRIGGER, "MONTHLY DATE");
            TraceMsg(TF_DUMPTRIGGER, "rgfDays = %d", pTT->Type.MonthlyDate.rgfDays);
            TraceMsg(TF_DUMPTRIGGER, "rgfMonths = %d", pTT->Type.MonthlyDate.rgfMonths);
            break;
        }

        case TASK_TIME_TRIGGER_MONTHLYDOW:
        {
            TraceMsg(TF_DUMPTRIGGER, "MONTHLY DOW");
            TraceMsg(TF_DUMPTRIGGER, "wWhichWeek = %d", pTT->Type.MonthlyDOW.wWhichWeek);
            TraceMsg(TF_DUMPTRIGGER, "rgfDaysOfTheWeek = %d", pTT->Type.MonthlyDOW.rgfDaysOfTheWeek);
            TraceMsg(TF_DUMPTRIGGER, "rgfMonths = %d", pTT->Type.MonthlyDOW.rgfMonths);
            break;
        }

        default:
        {
            ASSERT(FALSE);
            break;
        }
    }

    TraceMsg(TF_DUMPTRIGGER, "-----  END DumpTaskTrigger  -----");
}
#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\webcrawl.cpp ===
// TODO: Allow trident to download frames (and process new html)
// nuke urlmon code (use trident always)

#include "private.h"
#include "shui.h"
#include "downld.h"
#include "subsmgrp.h"
#include <ocidl.h>

#include <initguid.h>

#include <mluisupp.h>

extern HICON g_webCrawlerIcon;
extern HICON g_channelIcon;
extern HICON g_desktopIcon;

void LoadDefaultIcons();

#undef TF_THISMODULE
#define TF_THISMODULE   TF_WEBCRAWL

#define _ERROR_REPROCESSING -1

// DWORD field of the m_pPages string list
const DWORD DATA_RECURSEMASK = 0x000000FF;  // Levels of recursion from this page
const DWORD DATA_DLSTARTED =   0x80000000;  // Have we started downloading
const DWORD DATA_DLFINISHED =  0x40000000;  // Have we finished this page
const DWORD DATA_DLERROR =     0x20000000;  // An error during download
const DWORD DATA_CODEBASE =    0x10000000;  // Is codebase
const DWORD DATA_LINK =        0x08000000;  // Is link from page (not dependency)

// DWORD field of m_pPendingLinks string list
const DWORD DATA_ROBOTSTXTMASK=0x00000FFF;  // index into m_pRobotsTxt list

// used internally; not actually stored in string list field
const DWORD DATA_ROBOTSTXT =   0x01000000;  // Is robots.txt

// m_pDependencyLinks uses m_pPages values

// DWORD field of m_pRobotsTxt is NULL or (CWCDwordStringList *)

// DWORD field of m_pRobotsTxt referenced string list
const DWORD DATA_ALLOW =        0x80000000;
const DWORD DATA_DISALLOW =     0x40000000;

const WCHAR c_wszRobotsMetaName[] = L"Robots\n";
const int c_iRobotsMetaNameLen = 7;        // string len without nullterm

const WCHAR c_wszRobotsNoFollow[] = L"NoFollow";
const int c_iRobotsNoFollow = 8;

const WCHAR c_wszRobotsTxtURL[] = L"/robots.txt";

const DWORD MAX_ROBOTS_SIZE = 8192;         // Max size of robots.txt file

// tokens for parsing of robots.txt
const CHAR  c_szRobots_UserAgent[] = "User-Agent:";
const CHAR  c_szRobots_OurUserAgent[] = "MSIECrawler";
const CHAR  c_szRobots_Allow[] = "Allow:";
const CHAR  c_szRobots_Disallow[] = "Disallow:";

// This GUID comes from Trident and is a hack for getting PARAM values for APPLET tags.
DEFINE_GUID(CGID_JavaParambagCompatHack, 0x3050F405, 0x98B5, 0x11CF, 0xBB, 0x82, 0x00, 0xAA, 0x00, 0xBD, 0xCE, 0x0B);

// This GUID is helpfully not defined elsewhere.
DEFINE_GUID(CLSID_JavaVM, 0x08B0E5C0, 0x4FCB, 0x11CF, 0xAA, 0xA5, 0x00, 0x40, 0x1C, 0x60, 0x85, 0x01);

// Get host channel agent's subscription item, if any.
inline HRESULT CWebCrawler::GetChannelItem(ISubscriptionItem **ppChannelItem)
{
    IServiceProvider *pSP;
    HRESULT hr = E_NOINTERFACE;

    if (ppChannelItem)
        *ppChannelItem = NULL;

    if (SUCCEEDED(m_pAgentEvents->QueryInterface(IID_IServiceProvider, (void **)&pSP)) && pSP)
    {
        ISubscriptionItem *pTempChannelItem = NULL;
        pSP->QueryService(CLSID_ChannelAgent, IID_ISubscriptionItem, (void **)&pTempChannelItem);
        pSP->Release();

        if(pTempChannelItem) 
            hr = S_OK;
            
        if(ppChannelItem)
            *ppChannelItem = pTempChannelItem;
        else
        {
            if(pTempChannelItem)
                pTempChannelItem->Release();    
        }
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Helper functions - copied over from urlmon\download\helpers.cxx - Is there
// an equivalent routine or better place for this, webcrawl.cpp?
//
//////////////////////////////////////////////////////////////////////////

// ---------------------------------------------------------------------------
// %%Function: GetVersionFromString
//
//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
// ---------------------------------------------------------------------------
HRESULT
GetVersionFromString(const char *szBuf, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    const char *pch = szBuf;
    char ch;

    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (StrCmpA(pch, "-1,-1,-1,-1") == 0) {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
    }

    USHORT n = 0;

    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;


    for (ch = *pch++;;ch = *pch++) {

        if ((ch == ',') || (ch == '\0')) {

            switch (have) {

            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                return E_INVALIDARG; // invalid arg
            }

            if (ch == '\0') {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        } else if ( (ch < '0') || (ch > '9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - '0');


    } /* end forever */

    // NEVERREACHED
}

/////////////////////////////////////////////////////////////////////////////////////////
// CombineBaseAndRelativeURLs -
//         Three URLs are combined by following rules (this is used for finding the URL
//         to load Applet CABs from.)  Three inputs, the Base URL, the Code Base URL
//         and the file name URL.
//
//         If file name URL is absolute return it.
//         Otherwise if CodeBase URL is absolute combine it with filename and return.
//         Otherwise if Base URL is absolute, combine CodeBase and fileName URL, then
//            combine with Base URL and return it.
////////////////////////////////////////////////////////////////////////////////////////

HRESULT CombineBaseAndRelativeURLs(LPCWSTR szBaseURL, LPCWSTR szRelative1, LPWSTR *szRelative2)
{

    WCHAR wszTemp[INTERNET_MAX_URL_LENGTH];
    DWORD dwLen = ARRAYSIZE(wszTemp);

    ASSERT(szRelative2);                // should never happen.
    if (szRelative2 == NULL)
        return E_FAIL;

    if (IsValidURL(NULL, *szRelative2, 0) == S_OK)
        return S_OK;

    if (szRelative1 && (IsValidURL(NULL, szRelative1, 0) == S_OK))
    {

        if (SUCCEEDED(UrlCombineW((LPCWSTR)szRelative1, (LPCWSTR)*szRelative2, (LPWSTR)wszTemp, &dwLen, 0)))
        {
            BSTR bstrNew = SysAllocString(wszTemp);
            if (bstrNew)
            {
                SAFEFREEBSTR(*szRelative2);
                *szRelative2 = bstrNew;
                return S_OK;
            }
        }
    }

    if (szBaseURL && (IsValidURL(NULL, szBaseURL, 0) == S_OK))
    {
        LPWSTR szNewRel = NULL;
        WCHAR wszCombined[INTERNET_MAX_URL_LENGTH];

        if (szRelative1)
        {
            // NOTE: lstr[cpy|cat]W are macroed to work on Win95.
            DWORD dwLen2 = lstrlenW(*szRelative2);
            StrCpyNW(wszTemp, szRelative1, ARRAYSIZE(wszTemp) - 1); //paranoia
            DWORD dwTempLen = lstrlenW(wszTemp);
            if ((dwLen2 > 0) && ((*szRelative2)[dwLen2-1] == (unsigned short)L'\\') ||
                                ((*szRelative2)[dwLen2-1] == (unsigned short) L'/'))
            {
                StrNCatW(wszTemp, *szRelative2, ARRAYSIZE(wszTemp) - dwTempLen);
            }
            else
            {
                StrNCatW(wszTemp, L"/", ARRAYSIZE(wszTemp) - dwTempLen);
                StrNCatW(wszTemp, *szRelative2, ARRAYSIZE(wszTemp) - dwTempLen - 1);
            }

            szNewRel = wszTemp;
        }
        else
        {
            szNewRel = *szRelative2;
        }

        dwLen = INTERNET_MAX_URL_LENGTH;
        if (SUCCEEDED(UrlCombineW((LPCWSTR)szBaseURL, (LPCWSTR)szNewRel, (LPWSTR)wszCombined, &dwLen, 0)))
        {
            BSTR bstrNew = SysAllocString(wszCombined);
            if (bstrNew)
            {
                SAFEFREEBSTR(*szRelative2);
                *szRelative2 = bstrNew;
                return S_OK;
            }
        }
    }

    // In all likelyhood one of the URL's in bad and nothing good can be done.
    return E_FAIL;
}

//////////////////////////////////////////////////////////////////////////
//
// CWebCrawler implementation
//
//////////////////////////////////////////////////////////////////////////

//
// CWebCrawler Helpers
//

HRESULT CWebCrawler::CreateInstance(IUnknown *punkOuter, IUnknown **ppunk)
{
    HRESULT hr;

    ASSERT(NULL == punkOuter);
    ASSERT(NULL != ppunk);
    
    CWebCrawler *pwc = new CWebCrawler;

    if (NULL != pwc)
    {
        hr = pwc->Initialize();

        if (FAILED(hr))
        {
            pwc->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
    {
        *ppunk = (ISubscriptionAgentControl *)pwc;
    }

    return hr;
}

HRESULT CWebCrawler::Initialize()
{
    m_hrCritDependencies = InitializeCriticalSectionAndSpinCount(&m_critDependencies, 0) ? S_OK : E_OUTOFMEMORY;

    return m_hrCritDependencies;
}

CWebCrawler::CWebCrawler()
{
    DBG("Creating CWebCrawler object");
}

CWebCrawler::~CWebCrawler()
{
    _CleanUp();

    if (SUCCEEDED(m_hrCritDependencies))
    {
        DeleteCriticalSection(&m_critDependencies);
    }
    DBG("Destroyed CWebCrawler object");
}

void CWebCrawler::CleanUp()
{
    _CleanUp();
    CDeliveryAgent::CleanUp();
}

void CWebCrawler::_CleanUp()
{
    if (m_pCurDownload)
    {
        m_pCurDownload->DoneDownloading();
        m_pCurDownload->Release();
        m_pCurDownload = NULL;
    }

    CRunDeliveryAgent::SafeRelease(m_pRunAgent);

    SAFEFREEBSTR(m_bstrHostName);
    SAFEFREEBSTR(m_bstrBaseURL);
    SAFELOCALFREE(m_pszLocalDest);
    SAFELOCALFREE(m_pBuf);

    EnterCriticalSection(&m_critDependencies);
    SAFEDELETE(m_pDependencies);
    LeaveCriticalSection(&m_critDependencies);
    if (m_pDownloadNotify)
    {
        m_pDownloadNotify->LeaveMeAlone();
        m_pDownloadNotify->Release();
        m_pDownloadNotify=NULL;
    }

    SAFEDELETE(m_pPages);
    SAFEDELETE(m_pPendingLinks);
    SAFEDELETE(m_pDependencyLinks);
    SAFERELEASE(m_pUrlIconHelper);

    FreeRobotsTxt();
    FreeCodeBaseList();
}

// Format of m_pRobotsTxt:
// Array of hostnames for which we have attempted to get Robots.txt
// DWORD for each hostname contains pointer to CDwordStringList of Robots.txt data,
//  or 0 if we couldn't find robots.txt for that host name
// Robots.txt data stored in form: url, flag = allow or disallow
void CWebCrawler::FreeRobotsTxt()
{
    if (m_pRobotsTxt)
    {
        DWORD_PTR dwPtr;
        int iLen = m_pRobotsTxt->NumStrings();
        for (int i=0; i<iLen; i++)
        {
            dwPtr = m_pRobotsTxt->GetStringData(i);
            if (dwPtr)
            {
                delete ((CWCStringList *)dwPtr);
                m_pRobotsTxt->SetStringData(i, 0);
            }
        }

        delete m_pRobotsTxt;
        m_pRobotsTxt = NULL;
    }
}

void CWebCrawler::FreeCodeBaseList()
{
    if (m_pCodeBaseList) {
        CCodeBaseHold *pcbh;
        int iLen = m_pCodeBaseList->NumStrings();
        for (int i=0; i<iLen; i++)
        {
            pcbh = (CCodeBaseHold *)m_pCodeBaseList->GetStringData(i);
            if (pcbh != NULL)
            {
                SAFEFREEBSTR(pcbh->szDistUnit);
                SAFEDELETE(pcbh);
                m_pCodeBaseList->SetStringData(i, 0);
            }
        }

        SAFEDELETE(m_pCodeBaseList);
    }
}

HRESULT CWebCrawler::StartOperation()
{
    ISubscriptionItem *pItem = m_pSubscriptionItem;

    DWORD           dwTemp;

    ASSERT(pItem);

    DBG("CWebCrawler in StartOperation");

    if (m_pCurDownload || GetBusy())
    {
        DBG_WARN("Webcrawl busy, returning failure");
        return E_FAIL;
    }

    SAFEFREEBSTR(m_bstrBaseURL);
    if (FAILED(
        ReadBSTR(pItem, c_szPropURL, &m_bstrBaseURL)) ||
        !m_bstrBaseURL ||
        !CUrlDownload::IsValidURL(m_bstrBaseURL))
    {
        DBG_WARN("Couldn't get valid URL, aborting");
        SetEndStatus(E_INVALIDARG);
        SendUpdateNone();
        return E_INVALIDARG;
    }

    if (SHRestricted2W(REST_NoSubscriptionContent, NULL, 0))
        SetAgentFlag(FLAG_CHANGESONLY);

    if (IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        m_dwRecurseLevels = 0;
        m_dwRecurseFlags = WEBCRAWL_DONT_MAKE_STICKY;
        DBG("Webcrawler is in 'changes only' mode.");
    }
    else
    {
/*
        BSTR bstrLocalDest=NULL;
        SAFELOCALFREE(m_pszLocalDest);
        ReadBSTR(c_szPropCrawlLocalDest, &bstrLocalDest);
        if (bstrLocalDest && bstrLocalDest[0])
        {
            int iLen = SysStringByteLen(bstrLocalDest)+1;
            m_pszLocalDest = (LPTSTR) MemAlloc(LMEM_FIXED, iLen);
            if (m_pszLocalDest)
            {
                MyOleStrToStrN(m_pszLocalDest, iLen, bstrLocalDest);
            }
        }
        SAFEFREEBSTR(bstrLocalDest);
*/

        m_dwRecurseLevels=0;
        ReadDWORD(pItem, c_szPropCrawlLevels, &m_dwRecurseLevels);

        if (!IsAgentFlagSet(DELIVERY_AGENT_FLAG_NO_RESTRICTIONS))
        {
            // Note: MaxWebcrawlLevels is stored as N+1 because 0
            // disables the restriction
            dwTemp = SHRestricted2W(REST_MaxWebcrawlLevels, NULL, 0);
            if (dwTemp && m_dwRecurseLevels >= dwTemp)
                m_dwRecurseLevels = dwTemp - 1;
        }

        m_dwRecurseFlags=0;
        ReadDWORD(pItem, c_szPropCrawlFlags, &m_dwRecurseFlags);

        // Read max size in cache in KB
        m_dwMaxSize=0;
        ReadDWORD(pItem, c_szPropCrawlMaxSize, &m_dwMaxSize);
        if (!IsAgentFlagSet(DELIVERY_AGENT_FLAG_NO_RESTRICTIONS))
        {
            dwTemp = SHRestricted2W(REST_MaxSubscriptionSize, NULL, 0);
            if (dwTemp && (!m_dwMaxSize || m_dwMaxSize > dwTemp))
                m_dwMaxSize = dwTemp;
        }

        if (IsRecurseFlagSet(WEBCRAWL_DONT_MAKE_STICKY))
            dwTemp = 0;

        // Read old group ID
        ReadLONGLONG(pItem, c_szPropCrawlGroupID, &m_llOldCacheGroupID);

        // Read new ID if present
        m_llCacheGroupID = 0;
        ReadLONGLONG(pItem, c_szPropCrawlNewGroupID, &m_llCacheGroupID);
        if (m_llCacheGroupID)
        {
            DBG("Adding to existing cache group");
        }
    } // !ChangesOnly

    // finish initializing new operation
    m_iDownloadErrors = 0;
    m_dwCurSize = 0;
    m_lMaxNumUrls = (m_dwRecurseLevels) ? -1 : 1;
    SAFEFREEBSTR(m_bstrHostName);

    m_dwCurSize = NULL;
    m_pPages = NULL;
    m_pDependencies = NULL;

    // After calling this, we'll reenter either in "StartDownload" (connection successful)
    //  or in "AbortUpdate" with GetEndStatus() == INET_E_AGENT_CONNECTION_FAILED
    return CDeliveryAgent::StartOperation();
}

HRESULT CWebCrawler::AgentPause(DWORD dwFlags)
{
    DBG("CWebCrawler::AgentPause");

    // Abort our current url
    if (m_pRunAgent)
    {
        m_pRunAgent->AgentPause(dwFlags);
    }

    if (m_pCurDownload)
    {
        m_pCurDownload->AbortDownload();
        m_pCurDownload->DestroyBrowser();
    }

    return CDeliveryAgent::AgentPause(dwFlags);
}

HRESULT CWebCrawler::AgentResume(DWORD dwFlags)
{
    DBG("CWebCrawler::AgentResume");

    if (m_pRunAgent)
    {
        m_pRunAgent->AgentResume(dwFlags);
    }
    else
    {
        // If we just increased our cache size, reprocess same url
        if (SUBSCRIPTION_AGENT_RESUME_INCREASED_CACHE & dwFlags)
        {
            DBG("CWebCrawler reprocessing same url after cache size increase");
            OnDownloadComplete(0, _ERROR_REPROCESSING);
        }
        else
        {
            // If we're not still downloading, restart our same url
            if (0 == m_iNumPagesDownloading)
            {
                if (FAILED(ActuallyStartDownload(m_pCurDownloadStringList, m_iCurDownloadStringIndex, TRUE)))
                {
                    ASSERT_MSG(0, "CWebCrawler::AgentResume"); // this should never happen
                    SetEndStatus(E_FAIL);
                    CleanUp();
                }
            }
        }
    }

    return CDeliveryAgent::AgentResume(dwFlags);
}

// Forcibly abort current operation
HRESULT CWebCrawler::AgentAbort(DWORD dwFlags)
{
    DBG("CWebCrawler::AgentAbort");

    if (m_pCurDownload)
    {
        m_pCurDownload->DoneDownloading();
    }

    if (m_pRunAgent)
    {
        m_pRunAgent->AgentAbort(dwFlags);
    }

    return CDeliveryAgent::AgentAbort(dwFlags);
}

//---------------------------------------------------------------
//

HRESULT CWebCrawler::StartDownload()
{
    ASSERT(!m_pCurDownload);

    m_iPagesStarted = 0;
    m_iRobotsStarted = 0;
    m_iDependencyStarted = 0;
    m_iDependenciesProcessed = 0;
    m_iTotalStarted = 0;
    m_iCodeBaseStarted = 0;
    m_iNumPagesDownloading = 0;

    // Create new cache group
    if (IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        m_llCacheGroupID = 0;
    }
    else
    {
        if (!m_llCacheGroupID)
        {
            m_llCacheGroupID = CreateUrlCacheGroup(
                (IsRecurseFlagSet(WEBCRAWL_DONT_MAKE_STICKY) ? 0 : CACHEGROUP_FLAG_NONPURGEABLE), 0);

            ASSERT_MSG(m_llCacheGroupID != 0, "Create cache group failed");
        }
    }

    // Create string lists
    m_pPages = new CWCDwordStringList;
    if (m_pPages)
        m_pPages->Init(m_dwRecurseLevels ? -1 : 512);
    else
        SetEndStatus(E_FAIL);

    if (m_dwRecurseLevels && !IsRecurseFlagSet(WEBCRAWL_IGNORE_ROBOTSTXT))
    {
        m_pRobotsTxt = new CWCDwordStringList;
        if (m_pRobotsTxt)
            m_pRobotsTxt->Init(512);
        else
            SetEndStatus(E_FAIL);
    }

    // FEATURE : Shouldn't allocate this memory in changes only mode
    m_pCodeBaseList = new CWCDwordStringList;
    if (m_pCodeBaseList)
        m_pCodeBaseList->Init(512);
    else
        SetEndStatus(E_FAIL);

    // Avoid duplicate processing of dependencies
    if (!IsAgentFlagSet(FLAG_CHANGESONLY))
    {
        m_pDependencies = new CWCDwordStringList;
        if (m_pDependencies)
            m_pDependencies->Init();
        else
            SetEndStatus(E_FAIL);
    }

    if (GetEndStatus() == E_FAIL)
        return E_FAIL;

    m_pCurDownload = new CUrlDownload(this, 0);
    if (!m_pCurDownload)
        return E_OUTOFMEMORY;

    // Add first URL to string list, then start it
    if ((CWCStringList::STRLST_ADDED == m_pPages->AddString(m_bstrBaseURL, m_dwRecurseLevels)) &&
        m_pPages->NumStrings() == 1)
    {
        return StartNextDownload();
    }

    SetEndStatus(E_FAIL);
    return E_FAIL;
}

// Attempts to begin the next download
HRESULT CWebCrawler::StartNextDownload()
{
    if (!m_pPages || m_iNumPagesDownloading)
        return E_FAIL;

    CWCStringList *pslUrls = NULL;
    int iIndex = 0;

    // See if we have any more URLs to download.
    // Check dependency links first
    if (m_pDependencyLinks)
    {
        ProcessDependencyLinks(&pslUrls, &iIndex);
#ifdef DEBUG
        if (pslUrls) DBG("Downloading dependency link (frame):");
#endif
    }

    if (!pslUrls)
    {
        // Check robots.txt
        if (m_pRobotsTxt && (m_iRobotsStarted < m_pRobotsTxt->NumStrings()))
        {
            pslUrls = m_pRobotsTxt;
            iIndex = m_iRobotsStarted ++;
        }
        else if (m_pPendingLinks)   // add pending links to pages list
        {
            // Pending links to process and we've retrieved all robots.txt
            // Process pending links (validate & add to download list)
            ProcessPendingLinks();
        }

        if (!pslUrls && (m_iPagesStarted < m_pPages->NumStrings()))
        {
            DWORD_PTR dwTmp;
            ASSERT(!m_pDependencyLinks);// should be downloaded already
            ASSERT(!m_pPendingLinks);   // should be validated already
            // Skip any pages we've started
            while (m_iPagesStarted < m_pPages->NumStrings())
            {
                dwTmp = m_pPages->GetStringData(m_iPagesStarted);
                if (IsFlagSet(dwTmp, DATA_DLSTARTED))
                    m_iPagesStarted++;
                else
                    break;
            }
            if (m_iPagesStarted < m_pPages->NumStrings())
            {
                pslUrls = m_pPages;
                iIndex = m_iPagesStarted ++;
            }
        }

        if (!pslUrls && (m_iCodeBaseStarted < m_pCodeBaseList->NumStrings()))
        {
            // Nothing else pull, do code bases last.

            while (m_iCodeBaseStarted < m_pCodeBaseList->NumStrings())
            {
                CCodeBaseHold *pcbh = (CCodeBaseHold *)
                                    m_pCodeBaseList->GetStringData(m_iCodeBaseStarted);
                if (IsFlagSet(pcbh->dwFlags, DATA_DLSTARTED))
                    m_iCodeBaseStarted++;
                else
                    break;
            }
            while (m_iCodeBaseStarted < m_pCodeBaseList->NumStrings())
            {
                // We have some codebases to download.
                // We return if the download is async and simply
                // start the next one if it finishes synchronously
                iIndex = m_iCodeBaseStarted;
                m_iCodeBaseStarted++; // increment so that next download is not repeated

                // Init the cur download infor for resume if paused
                m_iCurDownloadStringIndex = iIndex;
                m_pCurDownloadStringList = m_pCodeBaseList;
                
               if(ActuallyDownloadCodeBase(m_pCodeBaseList, iIndex, FALSE) == E_PENDING)
                    return S_OK; // We break out of the while and try next download in OnAgentEnd()

            }
        }
    }

    if (pslUrls)
    {
        m_iCurDownloadStringIndex = iIndex;
        m_pCurDownloadStringList = pslUrls;

        return ActuallyStartDownload(pslUrls, iIndex);
    }

    DBG("WebCrawler: StartNextDownload failing, nothing more to download.");
    return E_FAIL;
}

HRESULT CWebCrawler::ActuallyStartDownload(CWCStringList *pslUrls, int iIndex, BOOL fReStart /* = FALSE */)
{
    // We have urls to download. Do it.
    DWORD_PTR dwData;
    LPCWSTR pwszURL;
    DWORD   dwBrowseFlags;
    BDUMethod method;
    BDUOptions options;

    if(pslUrls == m_pCodeBaseList)
    {
        ASSERT(fReStart); // Should happen only with resume
        HRESULT hr = ActuallyDownloadCodeBase(m_pCodeBaseList, iIndex, fReStart);
        if(E_PENDING == hr)
            return S_OK;
        return E_FAIL; // hackhack - since we don't handle synchronous downloads well - we hang if 
                       // resumed download is synchronous
    }

    if (pslUrls != m_pRobotsTxt)
    {
        dwData = pslUrls->GetStringData(iIndex);
#ifdef DEBUG
        if (fReStart)
            if (~(dwData & DATA_DLSTARTED)) DBG_WARN("WebCrawler: Trying to restart one we haven't started yet!");
        else
            if ((dwData & DATA_DLSTARTED)) DBG_WARN("WebCrawler: Trying to download one we've already started?");
#endif
        pslUrls->SetStringData(iIndex, DATA_DLSTARTED | dwData);
    }
    else
        dwData = DATA_ROBOTSTXT;

    pwszURL = pslUrls->GetString(iIndex);

    ASSERT(iIndex < pslUrls->NumStrings());

#ifdef DEBUG
    int iMax = m_lMaxNumUrls;
    if (iMax<0)
        iMax = m_pPages->NumStrings() + ((m_pRobotsTxt) ? m_pRobotsTxt->NumStrings() : 0);
    TraceMsgA(TF_THISMODULE, "WebCrawler GET_URL (%d of %c%d) Recurse %d : %ws",
        m_iTotalStarted+1, ((m_lMaxNumUrls>0) ? ' ' : '?'), iMax,
        pslUrls->GetStringData(iIndex) & DATA_RECURSEMASK, pwszURL);
#endif

    dwBrowseFlags = DLCTL_DOWNLOADONLY |
        DLCTL_NO_FRAMEDOWNLOAD | DLCTL_NO_SCRIPTS | DLCTL_NO_JAVA |
        DLCTL_NO_RUNACTIVEXCTLS;

    if (IsRecurseFlagSet(WEBCRAWL_GET_IMAGES))      dwBrowseFlags |= DLCTL_DLIMAGES;
    if (IsRecurseFlagSet(WEBCRAWL_GET_VIDEOS))      dwBrowseFlags |= DLCTL_VIDEOS;
    if (IsRecurseFlagSet(WEBCRAWL_GET_BGSOUNDS))    dwBrowseFlags |= DLCTL_BGSOUNDS;
    if (!IsRecurseFlagSet(WEBCRAWL_GET_CONTROLS))   dwBrowseFlags |= DLCTL_NO_DLACTIVEXCTLS;
    if (IsRecurseFlagSet(WEBCRAWL_PRIV_OFFLINE_MODE))
    {
        dwBrowseFlags |= DLCTL_FORCEOFFLINE;
        dwBrowseFlags &= ~(DLCTL_DLIMAGES | DLCTL_VIDEOS | DLCTL_BGSOUNDS);
        DBG("GET is OFFLINE");
    }

    m_pCurDownload->SetDLCTL(dwBrowseFlags);

#ifdef DEBUG
    if (fReStart)
    {
        ASSERT(m_iCurDownloadStringIndex == iIndex);
        ASSERT(m_pCurDownloadStringList == pslUrls);
    }
#endif

    if (!fReStart)
    {
        // Get the info for change detection, unless we already know it's changed
        if (!IsAgentFlagSet(FLAG_CRAWLCHANGED) && !(dwData & DATA_ROBOTSTXT))
        {
            TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];

            m_varChange.vt = VT_EMPTY;

            if (IsAgentFlagSet(FLAG_CHANGESONLY))
            {
                // "Changes Only" mode, we have persisted a change detection code
                ASSERT(m_iTotalStarted == 0);
                LPCWSTR pPropChange = c_szPropChangeCode;
                m_pSubscriptionItem->ReadProperties(1, &pPropChange, &m_varChange);
            }

            BOOL fMustGET = TRUE;

            MyOleStrToStrN(szUrl, INTERNET_MAX_URL_LENGTH, pwszURL);
            PreCheckUrlForChange(szUrl, &m_varChange, &fMustGET);

            if (IsAgentFlagSet(FLAG_CHANGESONLY) && !fMustGET)
                SetAgentFlag(FLAG_HEADONLY);
        }

        m_iTotalStarted ++;
    }

    if (IsPaused())
    {
        DBG("WebCrawler paused, not starting another download");
        if (m_pCurDownload)
            m_pCurDownload->DestroyBrowser(); // free browser until resumed
        return E_PENDING;
    }

    m_iNumPagesDownloading ++;

    // Send our update progress with the url we're about to download
    SendUpdateProgress(pwszURL, m_iTotalStarted, m_lMaxNumUrls, (m_dwCurSize >> 10));

    if (IsAgentFlagSet(FLAG_HEADONLY))
    {
        ASSERT(m_iTotalStarted == 1);
        method = BDU2_HEADONLY;                 // Only get HEAD info with Urlmon
    }
    else if (IsAgentFlagSet(FLAG_CHANGESONLY)   // Only want HTML, or
        || m_pszLocalDest                       // We're going to move this one file, or
        || (dwData & DATA_ROBOTSTXT))           // This is a robots.txt, so
    {
        method = BDU2_URLMON;                   // Get with Urlmon
    }
    else if (m_iTotalStarted == 1)              // First file, we need status code, so
    {
        ISubscriptionItem *pCDFItem;
        method = BDU2_SNIFF;                    // Get with Urlmon then MSHTML (if HTML)

        // Find out if we're hosted by channel agent
        if (SUCCEEDED(GetChannelItem(&pCDFItem)))
        {
            // If we're hosted by channel agent, use its original hostname
            BSTR bstrBaseUrl;
            if (SUCCEEDED(ReadBSTR(pCDFItem, c_szPropURL, &bstrBaseUrl)))
            {
                GetHostName(bstrBaseUrl, &m_bstrHostName);
                SysFreeString(bstrBaseUrl);
            }
#ifdef DEBUG
            if (m_bstrHostName)
                TraceMsg(TF_THISMODULE, "Got host name from channel agent: %ws", m_bstrHostName);
#endif
            pCDFItem->Release();

            DBG("Using 'smart' mode for first url in webcrawl; spawned from channel crawl");
            method = BDU2_SMART;                // Use 'smart' mode for first url if channel crawl
            SetAgentFlag(FLAG_HOSTED);
        }
    }
    else
        method = BDU2_SMART;                    // Get with Urlmon or MSHTML as appropriate

    if (dwData & DATA_ROBOTSTXT)
        options = BDU2_NEEDSTREAM;              // Need IStream to parse robots.txt
    else
        options = BDU2_NONE;

    options |= BDU2_DOWNLOADNOTIFY_REQUIRED;    // Always get download notify callbacks

    if (IsRecurseFlagSet(WEBCRAWL_ONLY_LINKS_TO_HTML) && (dwData & DATA_LINK))
    {
        // Don't follow any links unless they are to html pages.
        options |= BDU2_FAIL_IF_NOT_HTML;
    }

    if (FAILED(m_pCurDownload->BeginDownloadURL2(pwszURL,
            method, options, m_pszLocalDest, 
            m_dwMaxSize ? (m_dwMaxSize<<10)-m_dwCurSize : 0)))
    {
        DBG("BeginDownloadURL2 failed (ignoring & waiting for OnDownloadComplete call)");
    }

    return S_OK;
}

HRESULT CWebCrawler::ActuallyDownloadCodeBase(CWCStringList *pslUrls, int iIndex, BOOL fReStart)
{
    CCodeBaseHold *pcbh;
    LPCWSTR pwszURL;
    HRESULT hr = S_OK;

    if (pslUrls != m_pCodeBaseList)
    {
        ASSERT(0);
        DBG_WARN("WebCrawler: Wrong URLs being processed as CodeBase.");
        hr = E_FAIL;
        goto Exit;
    }

    pcbh = (CCodeBaseHold *)pslUrls->GetStringData(iIndex);

#ifdef DEBUG
    if (fReStart)
        if (~(pcbh->dwFlags & DATA_DLSTARTED)) DBG_WARN("WebCrawler: Trying to restart CodeBase D/L we haven't started yet!");
    else
        if ((pcbh->dwFlags & DATA_DLSTARTED)) DBG_WARN("WebCrawler: Trying to download CodeBase D/L we've already started?");
#endif
    pcbh->dwFlags |= DATA_DLSTARTED;

    pwszURL = pslUrls->GetString(iIndex);

    ASSERT(iIndex < pslUrls->NumStrings());

    if (!fReStart)
        m_iTotalStarted ++;

    if (IsPaused())
    {
        DBG("WebCrawler paused, not starting another download");
        if (m_pCurDownload)
            m_pCurDownload->DestroyBrowser(); // free browser until resumed
        return S_FALSE;
    }

    m_iNumPagesDownloading ++;

    // Send our update progress with the CODEBASE we're about to download
    SendUpdateProgress(pwszURL, m_iTotalStarted, m_lMaxNumUrls);

    if (m_pRunAgent)
    {
        ASSERT(0);
        DBG_WARN("WebCrawler: Attempting to download next CODEBASE when not done last one.");
        hr = E_FAIL;
        goto Exit;
    }
    else
    {
        // create subscription item for CDL agent.

        ISubscriptionItem *pItem = NULL;

        if (m_dwMaxSize && ((m_dwCurSize>>10) >= m_dwMaxSize))
        {
            // We've exceeded our maximum download KB limit and can't continue.
            DBG_WARN("WebCrawler: Exceeded Maximum KB download limit with CodeBase download.");
            SetEndStatus(hr = INET_E_AGENT_MAX_SIZE_EXCEEDED);
            goto Exit;
        }

        if (!m_pSubscriptionItem ||
            FAILED(hr = DoCloneSubscriptionItem(m_pSubscriptionItem, NULL, &pItem)))
        {
            goto Exit;
        }
        ASSERT(pItem != NULL);

        WriteOLESTR(pItem, c_szPropURL, pwszURL);
        WriteOLESTR(pItem, L"DistUnit", pcbh->szDistUnit);
        WriteDWORD(pItem, L"VersionMS", pcbh->dwVersionMS);
        WriteDWORD(pItem, L"VersionLS", pcbh->dwVersionLS);
        if (m_dwMaxSize)
            WriteDWORD(pItem, c_szPropCrawlMaxSize, m_dwMaxSize - (m_dwCurSize>>10));    // KB limit for us to pull.

        m_pRunAgent = new CRunDeliveryAgent();
        if (m_pRunAgent)
            hr = m_pRunAgent->Init((CRunDeliveryAgentSink *)this, pItem, CLSID_CDLAgent);
        pItem->Release();

        if (m_pRunAgent && SUCCEEDED(hr))
        {
            hr = m_pRunAgent->StartAgent();
            //if (hr == E_PENDING)
            //{
                //hr = S_OK;
            //}
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

Exit:
    return hr;

}

HRESULT CWebCrawler::ProcessDependencyLinks(CWCStringList **ppslUrls, int *piStarted)
{
    ASSERT(ppslUrls && !*ppslUrls && piStarted);

    int iIndex;
    DWORD_PTR dwData;

    if (!m_pDependencyLinks)
        return S_FALSE;

    // See if we have any more dependency links to download
    while (m_iDependencyStarted < m_pDependencyLinks->NumStrings())
    {
        if (!m_pPages->FindString(m_pDependencyLinks->GetString(m_iDependencyStarted),
                               m_pDependencyLinks->GetStringLen(m_iDependencyStarted), &iIndex))
        {
            ASSERT(0);  // find string failed?!? We added it above!
            return E_FAIL;
        }

        ASSERT(iIndex>=0 && iIndex<m_pPages->NumStrings());

        m_iDependencyStarted ++;

        // See if we've downloaded this yet.
        dwData = m_pPages->GetStringData(iIndex);
        if (!(dwData & DATA_DLSTARTED))
        {
            // Nope. Start download.
            *ppslUrls = m_pPages;
            *piStarted = iIndex;
            return S_OK;
        }

        // We have already downloaded this page. Go to next dependency link.
    }

    // Done processing. Clear for next page.
    SAFEDELETE(m_pDependencyLinks);

    return S_FALSE;
}

HRESULT CWebCrawler::ProcessPendingLinks()
{
    int         iNumLinks, iAddCode, i, iAddIndex, iRobotsIndex;
    LPCWSTR     pwszUrl;
    BOOL        fAllow;

    if (!m_pPendingLinks)
        return S_FALSE;

    ASSERT(m_lMaxNumUrls<0);
    ASSERT(0 == (m_dwPendingRecurseLevel & ~DATA_RECURSEMASK));

    iNumLinks = m_pPendingLinks->NumStrings();

    TraceMsg(TF_THISMODULE, "Processing %d pending links from %ws",
        iNumLinks, m_pPages->GetString(m_iPagesStarted-1));

    // Add the links to our global page list
    for (i=0; i<iNumLinks; i++)
    {
        // Validate with robots.txt if appropriate
        pwszUrl = m_pPendingLinks->GetString(i);
        iRobotsIndex = (int)(m_pPendingLinks->GetStringData(i) & DATA_ROBOTSTXTMASK);
        ValidateWithRobotsTxt(pwszUrl, iRobotsIndex, &fAllow);

        if (fAllow)
        {
/*
As long as we retrieve pages in decreasing-recursion order (top to bottom), we don't
have to worry about bumping pages to a higher recurse level (except for frames).
*/
            iAddCode = m_pPages->AddString(pwszUrl,
                        DATA_LINK | m_dwPendingRecurseLevel,
                        &iAddIndex);
            if (iAddCode == CWCStringList::STRLST_FAIL)
                break;
        }
    }
    SAFEDELETE(m_pPendingLinks);

    return S_OK;
}


// Combine with our base url to get full url
// We use this for frames, but also for <Link> tags, since the processing is identical
HRESULT CWebCrawler::CheckFrame(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwBaseUrl, DWORD *pdwStringData)
{
    WCHAR   wszCombined[INTERNET_MAX_URL_LENGTH];
    DWORD   dwLen = ARRAYSIZE(wszCombined);

    ASSERT(pbstrItem && *pbstrItem && punkItem && dwBaseUrl);
    if (!pbstrItem || !*pbstrItem || !punkItem || !dwBaseUrl)
        return E_FAIL;      // bogus

    if (SUCCEEDED(UrlCombineW((LPCWSTR)dwBaseUrl, *pbstrItem, wszCombined, &dwLen, 0)))
    {
        BSTR bstrNew = SysAllocString(wszCombined);

        if (bstrNew)
        {
            SysFreeString(*pbstrItem);
            *pbstrItem = bstrNew;
            return S_OK;
        }
    }

    TraceMsg(TF_WARNING, "CWebCrawler::CheckFrame failing. Not getting frame or <link> url=%ws.", *pbstrItem);
    return E_FAIL;  // Couldn't combine url; don't add
}

// See if we should follow this link. Clears pbstrItem if not.
// Accepts either pLink or pArea
HRESULT CWebCrawler::CheckLink(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwThis, DWORD *pdwStringData)
{
    HRESULT         hrRet = S_OK;
    CWebCrawler    *pThis = (CWebCrawler *)dwThis;

    ASSERT(pbstrItem && *pbstrItem && punkItem && dwThis);
    if (!pbstrItem || !*pbstrItem || !punkItem || !dwThis)
        return E_FAIL;      // bogus

    // First see if it's 'valid'
    // We only add the link if it's HTTP (or https)
    // (we don't want to get mailto: links, for example)
    if (CUrlDownload::IsValidURL(*pbstrItem))
    {
        // Strip off any anchor
        CUrlDownload::StripAnchor(*pbstrItem);
    }
    else
    {
        // Skip this link
        SysFreeString(*pbstrItem);
        *pbstrItem = NULL;
        return S_FALSE;
    }

    if (pThis->IsRecurseFlagSet(WEBCRAWL_ONLY_LINKS_TO_HTML))
    {
        // See if we can tell that this is not an HTML link
        if (CUrlDownload::IsNonHtmlUrl(*pbstrItem))
        {
            // Skip this link
            SysFreeString(*pbstrItem);
            *pbstrItem = NULL;
            return S_FALSE;
        }
    }

    if (!(pThis->IsRecurseFlagSet(WEBCRAWL_LINKS_ELSEWHERE)))
    {
        BSTR bstrHost=NULL;
        IHTMLAnchorElement *pLink=NULL;
        IHTMLAreaElement *pArea=NULL;

        // Check to see if the host names match
        punkItem->QueryInterface(IID_IHTMLAnchorElement, (void **)&pLink);

        if (pLink)
        {
            pLink->get_hostname(&bstrHost);
            pLink->Release();
        }
        else
        {
            punkItem->QueryInterface(IID_IHTMLAreaElement, (void **)&pArea);

            if (pArea)
            {
                pArea->get_hostname(&bstrHost);
                pArea->Release();
            }
            else
            {
                DBG_WARN("CWebCrawler::CheckLink Unable to get Area or Anchor interface!");
                return E_FAIL;      // Bad element
            }
        }

        if (!bstrHost || !*bstrHost)
        {
            DBG_WARN("CWebCrawler::CheckLink : (pLink|pArea)->get_hostname() failed");
            hrRet = S_OK;      // always accept if get_hostname fails
        }
        else
        {
            if (pThis->m_bstrHostName && MyAsciiCmpW(bstrHost, pThis->m_bstrHostName))
            {
                // Skip url; different host name.
                SAFEFREEBSTR(*pbstrItem);
                hrRet = S_FALSE;
            }
        }

        SAFEFREEBSTR(bstrHost);
    }

    if (*pbstrItem && pdwStringData)
    {
        pThis->GetRobotsTxtIndex(*pbstrItem, TRUE, pdwStringData);
        *pdwStringData &= DATA_ROBOTSTXTMASK;
    }
    else if (pdwStringData)
        *pdwStringData = 0;

    return hrRet;
}

// S_OK    : Already retrieved this robots.txt info
// S_FALSE : Haven't yet retrieved this robots.txt info
// E_*     : Bad
HRESULT CWebCrawler::GetRobotsTxtIndex(LPCWSTR pwszUrl, BOOL fAddToList, DWORD *pdwRobotsTxtIndex)
{
    HRESULT hr=S_OK;
    int    iIndex=-1;

    if (m_pRobotsTxt)
    {
        // See which robots.txt file we should use to validate this link
        // If not yet available, add it to the list to be downloaded
        DWORD  dwBufLen = lstrlenW(pwszUrl) + ARRAYSIZE(c_wszRobotsTxtURL); //This get's us a terminating NULL
        LPWSTR pwszRobots = (LPWSTR)MemAlloc(LMEM_FIXED, dwBufLen * sizeof(WCHAR));
        int    iAddCode;

        if (pwszRobots)
        {
            // PERF: do the internetcombine in startnextdownload
            if (SUCCEEDED(UrlCombineW(pwszUrl, c_wszRobotsTxtURL, pwszRobots, &dwBufLen, 0))
                && !memcmp(pwszRobots, L"http", 4 * sizeof(WCHAR)))
            {
                if (fAddToList)
                {
                    iAddCode = m_pRobotsTxt->AddString(pwszRobots, 0, &iIndex);
                }
                else
                {
                    if (m_pRobotsTxt->FindString(pwszRobots, -1, &iIndex))
                    {
                        iAddCode = CWCStringList::STRLST_DUPLICATE;
                    }
                    else
                    {
                        iIndex=-1;
                        iAddCode = CWCStringList::STRLST_FAIL;
                    }
                }

                if (CWCStringList::STRLST_FAIL == iAddCode)
                    hr = E_FAIL;    // bad news
                else if (CWCStringList::STRLST_ADDED == iAddCode)
                    hr = S_FALSE;   // haven't gotten it yet
                else
                    hr = S_OK;      // already got it
            }
            MemFree(pwszRobots);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = E_FAIL;    // too many robots.txt files???
    }

    *pdwRobotsTxtIndex = iIndex;

    return hr;
}

// iRobotsIndex : Index into robots.txt, -1 if unavailable
HRESULT CWebCrawler::ValidateWithRobotsTxt(LPCWSTR pwszUrl, int iRobotsIndex, BOOL *pfAllow)
{
    int iNumDirectives, i;
    CWCStringList *pslThisRobotsTxt=NULL;

    *pfAllow = TRUE;

    if (!m_pRobotsTxt)
        return S_OK;

    if (iRobotsIndex == -1)
    {
        DWORD dwIndex;

        if (S_OK != GetRobotsTxtIndex(pwszUrl, FALSE, &dwIndex))
            return E_FAIL;

        iRobotsIndex = (int)dwIndex;
    }

    if ((iRobotsIndex >= 0) && iRobotsIndex<m_pRobotsTxt->NumStrings())
    {
        pslThisRobotsTxt = (CWCStringList *)(m_pRobotsTxt->GetStringData(iRobotsIndex));

        if (pslThisRobotsTxt)
        {
            iNumDirectives = pslThisRobotsTxt->NumStrings();

            for (i=0; i<iNumDirectives; i++)
            {
                // See if this url starts with the same thing as the directive
                if (!MyAsciiCmpNIW(pwszUrl, pslThisRobotsTxt->GetString(i), pslThisRobotsTxt->GetStringLen(i)))
                {
                    // hit! see if this is "allow" or "disallow"
                    if (!(pslThisRobotsTxt->GetStringData(i) & DATA_ALLOW))
                    {
                        TraceMsg(TF_THISMODULE, "ValidateWithRobotsTxt disallowing: (%ws) (%ws)",
                            pslThisRobotsTxt->GetString(i), pwszUrl);
                        *pfAllow = FALSE;
                        m_iSkippedByRobotsTxt ++;
                    }
                    break;
                }
            }
        }
        return S_OK;
    }

    return E_FAIL;
}

typedef struct
{
    LPCWSTR         pwszThisUrl;
    CWCStringList   *pslGlobal;
    BOOL            fDiskFull;
    DWORD           dwSize;
    GROUPID         llGroupID;
}
ENUMDEPENDENCIES;

// Doesn't process it if we already have it in the global dependency list
HRESULT CWebCrawler::CheckImageOrLink(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwEnumDep, DWORD *pdwStringData)
{
    if (!dwEnumDep)
        return E_FAIL;

    ENUMDEPENDENCIES *pEnumDep = (ENUMDEPENDENCIES *) dwEnumDep;

    WCHAR   wszCombinedUrl[INTERNET_MAX_URL_LENGTH];
    DWORD   dwLen = ARRAYSIZE(wszCombinedUrl);

    HRESULT hr;

    if (pEnumDep->fDiskFull)
        return E_ABORT;     // Abort enumeration

    if (SUCCEEDED(UrlCombineW(pEnumDep->pwszThisUrl, *pbstrItem, wszCombinedUrl, &dwLen, 0)))
    {
        TCHAR   szCombinedUrl[INTERNET_MAX_URL_LENGTH];
        BYTE    chBuf[MY_MAX_CACHE_ENTRY_INFO];

        if (pEnumDep->pslGlobal != NULL)
        {
            int iCode = pEnumDep->pslGlobal->AddString(*pbstrItem, 0);

            if (CWCStringList::STRLST_ADDED != iCode)
            {
                // The string already existed (or Add failed). Don't process this.
                return S_OK;
            }
        }

        // Process this url.
        MyOleStrToStrN(szCombinedUrl, INTERNET_MAX_URL_LENGTH, wszCombinedUrl);

        hr = GetUrlInfoAndMakeSticky(NULL, szCombinedUrl,
                (LPINTERNET_CACHE_ENTRY_INFO)chBuf, sizeof(chBuf),
                pEnumDep->llGroupID);

        if (E_OUTOFMEMORY == hr)
        {
            pEnumDep->fDiskFull = TRUE;
            return E_ABORT;     // Skip rest of enumeration
        }

        if (SUCCEEDED(hr))
            pEnumDep->dwSize += ((LPINTERNET_CACHE_ENTRY_INFO)chBuf)->dwSizeLow;
    }

    return S_OK;
}

HRESULT CWebCrawler::MatchNames(BSTR bstrName, BOOL fPassword)
{
    static const WCHAR c_szPassword1[] = L"password";
    static const WCHAR c_szUsername1[] = L"user";
    static const WCHAR c_szUsername2[] = L"username";

    HRESULT hr = E_FAIL;
    LPCTSTR pszKey = c_szRegKeyPasswords;

    // See if the name matches our preset options.
    // Should these be localized?  I don't think so or subscribing to
    // US sites will fail in international versions of the browser.
    if (fPassword)
    {
        if (StrCmpIW(bstrName, c_szPassword1) == 0)
        {
            hr = S_OK;
        }
    }
    else
    {
        if ((StrCmpIW(bstrName, c_szUsername1) == 0) ||
            (StrCmpIW(bstrName, c_szUsername2) == 0))
        {
            hr = S_OK;
        }
        else
        {
            pszKey = c_szRegKeyUsernames;
        }
    }

    // Try the registry for custom form names if the presets didn't match.
    if (FAILED(hr))
    {
        LONG lRes;
        HKEY hKey;
        DWORD cValues;
        DWORD i;
        lRes = RegOpenKeyEx(HKEY_CURRENT_USER, pszKey, 0, KEY_READ, &hKey);
        if (ERROR_SUCCESS == lRes)
        {
            lRes = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, NULL, NULL, &cValues, NULL, NULL, NULL, NULL);
            if (ERROR_SUCCESS == lRes)
            {
                for (i = 0; i < cValues; i++)
                {
                    TCHAR szValueName[MAX_PATH];
                    DWORD cchValueName = ARRAYSIZE(szValueName);

                    lRes = SHEnumValue(hKey, i, szValueName, &cchValueName, NULL, NULL, NULL);
                    if (ERROR_SUCCESS == lRes)
                    {
                        WCHAR wszValueName[MAX_PATH];
                        MyStrToOleStrN(wszValueName, ARRAYSIZE(wszValueName), szValueName);
                        if (StrCmpIW(bstrName, wszValueName) == 0)
                        {
                            hr = S_OK;
                            break;
                        }
                    }
                }
            }
            lRes = RegCloseKey(hKey);
            ASSERT(ERROR_SUCCESS == lRes);
        }
    }

    return hr;
}

HRESULT CWebCrawler::FindAndSubmitForm(void)
{
    // FindAndSubmitForm - If there is a user name and password in
    // the start item, this will attempt to fill in and submit
    // a form.  It should only be called on the top level page of a
    // webcrawl. We still need to check the host name in case we were
    // spawned from a channel crawl.
    //
    // return values: S_OK      successfully found and submitted a form -> restart webcrawl
    //                S_FALSE   no username, no form, or unrecognized form ->continue webcrawl
    //                E_FAIL    submit failed -> abort webcrawl
    //
    HRESULT hrReturn = S_FALSE;
    HRESULT hr = S_OK;
    BSTR bstrUsername = NULL;
    BSTR bstrPassword = NULL;
    BSTR bstrInputType= NULL;

    static const WCHAR c_szInputTextType[]=L"text";

    // If our host name doesn't match the root host name, don't return auth
    // information.
    if (m_bstrHostName)
    {
        LPWSTR pwszUrl, bstrHostName=NULL;

        m_pCurDownload->GetRealURL(&pwszUrl);   // may re-enter Trident

        if (pwszUrl)
        {
            GetHostName(pwszUrl, &bstrHostName);
            LocalFree(pwszUrl);
        }

        if (bstrHostName)
        {
            if (MyAsciiCmpW(bstrHostName, m_bstrHostName))
            {
                hr = E_FAIL;
            }
            SysFreeString(bstrHostName);
        }
    }

    if (SUCCEEDED(hr))
        hr = ReadBSTR(m_pSubscriptionItem, c_szPropCrawlUsername, &bstrUsername);

    if (SUCCEEDED(hr) && bstrUsername && bstrUsername[0])
    {
        // NOTE: We don't allow NULL passwords.
        hr = ReadPassword(m_pSubscriptionItem, &bstrPassword);
        if (SUCCEEDED(hr) && bstrPassword && bstrPassword[0])
        {
            IHTMLDocument2 *pDoc = NULL;
            hr = m_pCurDownload->GetDocument(&pDoc);
            if (SUCCEEDED(hr) && pDoc)
            {
                IHTMLElementCollection *pFormsCollection = NULL;
                hr = pDoc->get_forms(&pFormsCollection);
                if (SUCCEEDED(hr) && pFormsCollection)
                {
                    long length;
                    hr = pFormsCollection->get_length(&length);
                    TraceMsg(TF_THISMODULE, "**** FOUND USER NAME, PASSWORD, & %d FORMS ****", (int)length);
                    if (SUCCEEDED(hr) && length > 0)
                    {
                        // We only check the first form for a user name and password.
                        // Why do we pass an index to IHTMLElementCollection when
                        // the interface prototype says it takes a name?
                        IDispatch *pDispForm = NULL;
                        VARIANT vIndex, vEmpty;
                        VariantInit(&vIndex);
                        VariantInit(&vEmpty);
                        vIndex.vt = VT_I4;
                        vIndex.lVal = 0;
                        hr = pFormsCollection->item(vIndex, vEmpty, &pDispForm);
                        if (SUCCEEDED(hr) && pDispForm)
                        {
                            IHTMLFormElement *pForm = NULL;
                            hr = pDispForm->QueryInterface(IID_IHTMLFormElement, (void **)&pForm);
                            if (SUCCEEDED(hr) && pForm)
                            {
                                // Enum form elements looking for the input types we care about.
                                // Would it be faster to use tags()?
                                hr = pForm->get_length(&length);
                                if (SUCCEEDED(hr) && length >= 2)
                                {
                                    // TraceMsg(TF_THISMODULE, "**** FORM ELEMENTS (%d) ****", (int)length);
                                    BOOL fUsernameSet = FALSE;
                                    BOOL fPasswordSet = FALSE;
                                    IDispatch *pDispItem = NULL;
                                    long i;
                                    for (i = 0; i < length; i++)
                                    {
                                        vIndex.lVal = i;    // re-use vIndex above
                                        hr = pForm->item(vIndex, vEmpty, &pDispItem);
                                        if (SUCCEEDED(hr) && pDispItem)
                                        {
                                            IHTMLInputTextElement *pInput = NULL;
                                            // QI was the easiest way to tell them apart...
                                            // InputText is derived from InputPassword
                                            hr = pDispItem->QueryInterface(IID_IHTMLInputTextElement, (void **)&pInput);
                                            SAFERELEASE(pDispItem);
                                            if (SUCCEEDED(hr) && pInput)
                                            {
                                                hr = pInput->get_type(&bstrInputType);
                                                ASSERT(SUCCEEDED(hr) && bstrInputType);
                                                BSTR bstrName = NULL;
                                                if (StrCmpIW(bstrInputType, c_szInputTextType) == 0)
                                                {
                                                    // We found an INPUT element with attribute TYPE="text".
                                                    // Set it if the NAME attribute matches.
                                                    // Only setting the first matching input.
                                                    // Do we care about max length or does put_value handle it?
                                                    // TraceMsg(TF_THISMODULE, "**** FORM ELEMENT INPUT (%d) ****", (int)i);
                                                    if (!fUsernameSet)
                                                    {
                                                        hr = pInput->get_name(&bstrName);
                                                        ASSERT(SUCCEEDED(hr) && bstrName);
                                                        if (SUCCEEDED(hr) && bstrName && SUCCEEDED(MatchNames(bstrName, FALSE)))
                                                        {
                                                            hr = pInput->put_value(bstrUsername);
                                                            if (SUCCEEDED(hr))
                                                                fUsernameSet = TRUE;
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    // We found an INPUT element with attribute TYPE="password"
                                                    // Set it if the name attribute matches.
                                                    // Only setting the first matching input.
                                                    // Do we care about max length or does put_value handle it?
                                                    // TraceMsg(TF_THISMODULE, "**** FORM ELEMENT PASSWORD (%d) ****", (int)i);
                                                    if (!fPasswordSet)
                                                    {
                                                        hr = pInput->get_name(&bstrName);
                                                        ASSERT(SUCCEEDED(hr) && bstrName);
                                                        if (SUCCEEDED(hr) && bstrName  && SUCCEEDED(MatchNames(bstrName, TRUE)))
                                                        {
                                                            hr = pInput->put_value(bstrPassword);
                                                            if (SUCCEEDED(hr))
                                                                fPasswordSet = TRUE;
                                                        }
                                                    }
                                                }
                                                SAFEFREEBSTR(bstrName);
                                                SAFERELEASE(pInput);
                                            }
                                        }
                                    }
                                    // Submit the form is everything was set.
                                    if (fUsernameSet && fPasswordSet)
                                    {
                                        ASSERT(!m_pCurDownload->GetFormSubmitted());
                                        m_pCurDownload->SetFormSubmitted(TRUE);
                                        hr = pForm->submit();
                                        if (SUCCEEDED(hr))
                                        {
                                            m_iNumPagesDownloading ++;
                                            TraceMsg(TF_THISMODULE, "**** FORM SUBMIT WORKED ****");
                                            hrReturn = S_OK;
                                        }
                                        else
                                        {
                                            TraceMsg(TF_THISMODULE, "**** FORM SUBMIT FAILED ****");
                                            hrReturn = E_FAIL;
                                        }
                                    }
                                }
                                SAFERELEASE(pForm);
                            }
                            SAFERELEASE(pDispForm);
                        }
                        // only length
                    }
                    SAFERELEASE(pFormsCollection);
                }
                SAFERELEASE(pDoc);
            }
            // free bstr below because we check for empty bstrs
        }
        SAFEFREEBSTR(bstrPassword);
    }
    SAFEFREEBSTR(bstrUsername);
    return hrReturn;
}

// Make page and dependencies sticky and get total size
HRESULT CWebCrawler::MakePageStickyAndGetSize(LPCWSTR pwszURL, DWORD *pdwSize, BOOL *pfDiskFull)
{
    ASSERT(m_pDependencies || IsRecurseFlagSet(WEBCRAWL_DONT_MAKE_STICKY));

    HRESULT hr;
    TCHAR   szThisUrl[INTERNET_MAX_URL_LENGTH]; // use ansi internally
    BYTE    chBuf[MY_MAX_CACHE_ENTRY_INFO];

    LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

    DWORD   dwBufSize = sizeof(chBuf);

    *pdwSize = 0;

    // First we make our base url sticky and check it for changes

    MyOleStrToStrN(szThisUrl, INTERNET_MAX_URL_LENGTH, pwszURL);

    hr = GetUrlInfoAndMakeSticky(NULL, szThisUrl, lpInfo, dwBufSize, m_llCacheGroupID);

    if (E_OUTOFMEMORY != hr)
    {
        if (SUCCEEDED(hr))
            *pdwSize += lpInfo->dwSizeLow;

        if (!IsAgentFlagSet(FLAG_CRAWLCHANGED) && SUCCEEDED(hr))
        {
            hr = PostCheckUrlForChange(&m_varChange, lpInfo, lpInfo->LastModifiedTime);
            // If we FAILED, we mark it as changed.
            if (hr == S_OK || FAILED(hr))
            {
                SetAgentFlag(FLAG_CRAWLCHANGED);
                DBG("URL has changed; will flag webcrawl as changed");
            }

            // "Changes Only" mode, persist change detection code
            if (IsAgentFlagSet(FLAG_CHANGESONLY))
            {
                ASSERT(m_iTotalStarted == 1);
                WriteVariant(m_pSubscriptionItem, c_szPropChangeCode, &m_varChange);
                return S_OK;    // We know there are no dependencies
            }

            hr = S_OK;
        }
    }
    else
    {
        *pfDiskFull = TRUE;
    }

    // Now we make all the new dependencies we downloaded for this page sticky
    if (!*pfDiskFull && m_pDependencies)
    {
        EnterCriticalSection(&m_critDependencies);

        for (; m_iDependenciesProcessed < m_pDependencies->NumStrings(); m_iDependenciesProcessed ++)
        {
            MyOleStrToStrN(szThisUrl, INTERNET_MAX_URL_LENGTH, m_pDependencies->GetString(m_iDependenciesProcessed));

            hr = GetUrlInfoAndMakeSticky(NULL, szThisUrl, lpInfo, dwBufSize, m_llCacheGroupID);

            if (E_OUTOFMEMORY == hr)
            {
                *pfDiskFull = TRUE;
                break;
            }

            if (SUCCEEDED(hr))
                *pdwSize += lpInfo->dwSizeLow;
        }

        LeaveCriticalSection(&m_critDependencies);
    }

    if (*pfDiskFull)
    {
        DBG_WARN("Webcrawler: UrlCache full trying to make sticky");
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

// true if found token & made null-term
LPSTR GetToken(LPSTR pszBuf, /*inout*/int *piBufPtr, /*out*/int *piLen)
{
static const CHAR szWhitespace[] = " \t\n\r";

    int iPtr = *piBufPtr;
    int iLen;

    while (1)
    {
        // skip leading whitespace
        iPtr += StrSpnA(pszBuf+iPtr, szWhitespace);

        if (!pszBuf[iPtr])
            return NULL;

        if (pszBuf[iPtr] == '#')
        {
            // comment; skip line
            while (pszBuf[iPtr] && pszBuf[iPtr]!='\r' && pszBuf[iPtr]!='\n') iPtr++;

            if (!pszBuf[iPtr])
                return NULL;

            continue;
        }

        // skip to next whitespace
        iLen = StrCSpnA(pszBuf+iPtr, szWhitespace);

        if (iLen == 0)
            return NULL;        // shoudln't happen

        *piBufPtr = iLen + iPtr;

        if (piLen)
            *piLen = iLen;

        if (pszBuf[iLen+iPtr])
        {
            pszBuf[iLen+iPtr] = NULL;
            ++ *piBufPtr;
        }

        break;
    }

//  TraceMsgA(TF_THISMODULE, "GetToken returning \"%s\"", (LPSTR)(pszBuf+iPtr));
    return pszBuf + iPtr;
}


// === Support functions for OnDownloadComplete

// ParseRobotsTxt gets the stream from CUrlDownload, parses it, and fills in parsed
//  info to *ppslRet
HRESULT CWebCrawler::ParseRobotsTxt(LPCWSTR pwszRobotsTxtURL, CWCStringList **ppslRet)
{
    // Given a robots.txt file (from CUrlDownload), it
    //  parses the file and fills in a string list with appropriate
    //  info.
    *ppslRet = FALSE;

    CHAR    szRobotsTxt[MAX_ROBOTS_SIZE];
    HRESULT hr=S_OK;
    LPSTR   pszToken;
    IStream *pstm=NULL;
    DWORD_PTR dwData;

    hr = m_pCurDownload->GetStream(&pstm);

    if (SUCCEEDED(hr))
    {
        STATSTG st;
        DWORD   dwSize;

        DBG("CWebCrawler parsing robots.txt file");

        pstm->Stat(&st, STATFLAG_NONAME);

        dwSize = st.cbSize.LowPart;

        if (st.cbSize.HighPart || dwSize >= MAX_ROBOTS_SIZE)
        {
            szRobotsTxt[0] = 0;
            DBG("CWebCrawler: Robots.Txt too big; ignoring");
            hr = E_FAIL;
        }
        else
        {
            hr = pstm->Read(szRobotsTxt, dwSize, NULL);
            szRobotsTxt[dwSize] = 0;
        }

        pstm->Release();
        pstm=NULL;

        if ((szRobotsTxt[0] == 0xff) && (szRobotsTxt[1] == 0xfe))
        {
            DBG_WARN("Unicode robots.txt! Ignoring ...");
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
        return hr;

    int iPtr = 0;
    WCHAR wchBuf2[256];
    WCHAR wchBuf[INTERNET_MAX_URL_LENGTH];
    DWORD dwBufSize;

    // Find the first "user-agent" which matches
    while ((pszToken = GetToken(szRobotsTxt, &iPtr, NULL)) != NULL)
    {
        if (lstrcmpiA(pszToken, c_szRobots_UserAgent))
            continue;

        pszToken = GetToken(szRobotsTxt, &iPtr, NULL);
        if (!pszToken)
            break;

        if ((*pszToken == '*') ||
            (!lstrcmpiA(pszToken, c_szRobots_OurUserAgent)))
        {
            TraceMsgA(TF_THISMODULE, "Using user agent segment: \"%s\"", pszToken);
            break;
        }
    }

    if (!pszToken)
        return E_FAIL;

    CWCStringList *psl = new CWCDwordStringList;
    if (psl)
    {
        psl->Init(2048);

        // Look for Allow: or Disallow: sections
        while ((pszToken = GetToken(szRobotsTxt, &iPtr, NULL)) != NULL)
        {
            if (!lstrcmpiA(pszToken, c_szRobots_UserAgent))
                break;  // end of our 'user-agent' section

            dwData = 0;

            if (!lstrcmpiA(pszToken, c_szRobots_Allow))     dwData = DATA_ALLOW;
            if (!lstrcmpiA(pszToken, c_szRobots_Disallow))  dwData = DATA_DISALLOW;

            if (!dwData)
                continue;   // look for next token

            pszToken = GetToken(szRobotsTxt, &iPtr, NULL);
            if (!pszToken)
                break;

            // Ensure that they don't have blank entries; we'll abort if so
            if (!lstrcmpiA(pszToken, c_szRobots_UserAgent) ||
                !lstrcmpiA(pszToken, c_szRobots_Allow) ||
                !lstrcmpiA(pszToken, c_szRobots_Disallow))
            {
                break;
            }

            // Combine this url with the base for this site.
            dwBufSize = ARRAYSIZE(wchBuf);
            if (SHAnsiToUnicode(pszToken, wchBuf2, ARRAYSIZE(wchBuf2)) &&
                SUCCEEDED(UrlCombineW(pwszRobotsTxtURL, wchBuf2, wchBuf, &dwBufSize, 0)))
            {
                TraceMsgA(TF_THISMODULE, "Robots.txt will %s urls with %s (%ws)",
                    ((dwData==DATA_ALLOW) ? c_szRobots_Allow : c_szRobots_Disallow),
                    pszToken, wchBuf);

                // if this is a duplicate url we effectively ignore this directive
                //  thanks to CWCStringList removing duplicates for us

                psl->AddString(wchBuf, dwData);
            }
        }
    }

    if (psl && (psl->NumStrings() > 0))
    {
        *ppslRet = psl;
        return S_OK;
    }

    if (psl)
        delete psl;

    return E_FAIL;
}

HRESULT CWebCrawler::GetRealUrl(int iPageIndex, LPWSTR *ppwszThisUrl)
{
    m_pCurDownload->GetRealURL(ppwszThisUrl);

    if (*ppwszThisUrl)
    {
        return S_OK;
    }

    DBG_WARN("m_pCurDownload->GetRealURL failed!!!");

    // Get url from string list
    LPCWSTR pwszUrl=NULL;

    pwszUrl = m_pPages->GetString(iPageIndex);

    if (pwszUrl)
    {
        *ppwszThisUrl = StrDupW(pwszUrl);
    }

    return (*ppwszThisUrl) ? S_OK : E_OUTOFMEMORY;
}

// Allocates BSTR for host name.
HRESULT CWebCrawler::GetHostName(LPCWSTR pwszThisUrl, BSTR *pbstrHostName)
{
    if (pwszThisUrl)
    {
        URL_COMPONENTSA comp;
        LPSTR           pszUrl;
        int             iLen;

//      InternetCrackUrlW(pszUrl, 0, 0, &comp)  // this is even slower than converting it ourselves...

        // convert to ansi
        iLen = lstrlenW(pwszThisUrl) + 1;
        pszUrl = (LPSTR)MemAlloc(LMEM_FIXED, iLen);
        if (pszUrl)
        {
            SHUnicodeToAnsi(pwszThisUrl, pszUrl, iLen);

            // crack out the host name
            ZeroMemory(&comp, sizeof(comp));
            comp.dwStructSize = sizeof(comp);
            comp.dwHostNameLength = 1;  // indicate that we want the host name

            if (InternetCrackUrlA(pszUrl, 0, 0, &comp))
            {
                *pbstrHostName = SysAllocStringLen(NULL, comp.dwHostNameLength);
                if (*pbstrHostName)
                {
                    comp.lpszHostName[comp.dwHostNameLength] = 0; // avoid debug rip
                    SHAnsiToUnicode(comp.lpszHostName, *pbstrHostName, comp.dwHostNameLength + 1);
                    ASSERT((*pbstrHostName)[comp.dwHostNameLength] == 0);
                }
            }

            MemFree((HLOCAL)pszUrl);
        }
    }

    return S_OK;
}

// Gets partly validated (CUrlDownload::IsValidUrl and hostname validation)
//  string lists and leaves in m_pPendingLinks
// Remaining validation is robots.txt if any
HRESULT CWebCrawler::GetLinksFromPage()
{
    // Get links from this page that we want to follow.
    CWCStringList *pslLinks=NULL, slMeta;

    IHTMLDocument2  *pDoc;
    BOOL            fFollowLinks = TRUE;
    int             i;

    slMeta.Init(2048);

    m_pCurDownload->GetDocument(&pDoc);
    if (pDoc)
    {
        // See if there is a META tag telling us not to follow
        CHelperOM::GetCollection(pDoc, &slMeta, CHelperOM::CTYPE_META, NULL, 0);
        for (i=0; i<slMeta.NumStrings(); i++)
        {
            if (!StrCmpNIW(slMeta.GetString(i), c_wszRobotsMetaName, c_iRobotsMetaNameLen))
            {
                LPCWSTR pwszContent = slMeta.GetString(i) + c_iRobotsMetaNameLen;
                TraceMsg(TF_THISMODULE, "Found 'robots' meta tag; content=%ws", pwszContent);

                while (pwszContent && *pwszContent)
                {
                    if (!StrCmpNIW(pwszContent, c_wszRobotsNoFollow, c_iRobotsNoFollow))
                    {
                        DBG("Not following links from this page.");
                        fFollowLinks = FALSE;
                        break;
                    }
                    pwszContent = StrChrW(pwszContent+1, L',');
                    if (pwszContent && *pwszContent)
                        pwszContent ++;
                }
                break;
            }
        }
        if (fFollowLinks)
        {
            if (m_pPendingLinks)
                pslLinks = m_pPendingLinks;
            else
            {
                pslLinks = new CWCDwordStringList;
                if (pslLinks)
                    pslLinks->Init();
                else
                    return E_OUTOFMEMORY;
            }

            CHelperOM::GetCollection(pDoc, pslLinks, CHelperOM::CTYPE_LINKS, &CheckLink, (DWORD_PTR)this);
            CHelperOM::GetCollection(pDoc, pslLinks, CHelperOM::CTYPE_MAPS, &CheckLink, (DWORD_PTR)this);
        }
        pDoc->Release();
        pDoc=NULL;
    }

    m_pPendingLinks = pslLinks;

    return S_OK;
}

// Gets 'dependency links' such as frames from a page
HRESULT CWebCrawler::GetDependencyLinksFromPage(LPCWSTR pwszThisUrl, DWORD dwRecurse)
{
    CWCStringList *psl=NULL;
    IHTMLDocument2 *pDoc;
    int i, iAdd, iIndex, iOldMax;
    DWORD_PTR dwData;

    if (m_pDependencyLinks)
        psl = m_pDependencyLinks;
    else
    {
        m_iDependencyStarted = 0;
        psl = new CWCStringList;
        if (psl)
            psl->Init(2048);
        else
            return E_OUTOFMEMORY;
    }

    iOldMax = psl->NumStrings();

    m_pCurDownload->GetDocument(&pDoc);
    if (pDoc)
    {
        // Add Frames ("Frame" and "IFrame" tags) if present
        CHelperOM::GetCollection(pDoc, psl, CHelperOM::CTYPE_FRAMES, CheckFrame, (DWORD_PTR)pwszThisUrl);
    }

    SAFERELEASE(pDoc);

    m_pDependencyLinks = psl;

    // Add the new urls to the main page list
    for (i = iOldMax; i<psl->NumStrings(); i++)
    {
        iAdd = m_pPages->AddString(m_pDependencyLinks->GetString(i),
                        dwRecurse,
                        &iIndex);

        if (m_lMaxNumUrls > 0 && iAdd==CWCStringList::STRLST_ADDED)
            m_lMaxNumUrls ++;

        if (iAdd == CWCStringList::STRLST_FAIL)
            return E_OUTOFMEMORY;

        if (iAdd == CWCStringList::STRLST_DUPLICATE)
        {
            // bump up recursion level of old page if necessary
            // See if we've downloaded this yet.
            dwData = m_pPages->GetStringData(iIndex);
            if (!(dwData & DATA_DLSTARTED))
            {
                // Haven't downloaded it yet.
                // Update the recurse levels if necessary.
                if ((dwData & DATA_RECURSEMASK) < dwRecurse)
                {
                    dwData = (dwData & ~DATA_RECURSEMASK) | dwRecurse;
                }

                // Turn off the "link" bit
                dwData &= ~DATA_LINK;

                m_pPages->SetStringData(iIndex, dwData);
            }
#ifdef DEBUG
            // Shouldn't happen; this frame already dl'd with lower recurse level
            else
                ASSERT((dwData & DATA_RECURSEMASK) >= dwRecurse);
#endif
        }
    }

    return S_OK;
}

//-------------------------------------
// OnDownloadComplete
//
// Called when a url is finished downloading, it processes the url
//  and kicks off the next download
//
HRESULT CWebCrawler::OnDownloadComplete(UINT iID, int iError)
{
    int         iPageIndex = m_iCurDownloadStringIndex;
    BOOL        fOperationComplete = FALSE;
    BOOL        fDiskFull = FALSE;
    BSTR        bstrCDFURL = NULL; //  CDF URL if there is one
    LPWSTR      pwszThisUrl=NULL;

    HRESULT     hr;

    TraceMsg(TF_THISMODULE, "WebCrawler: OnDownloadComplete(%d)", iError);
    ASSERT(m_pPages);
    ASSERT(iPageIndex < m_pCurDownloadStringList->NumStrings());

    if (_ERROR_REPROCESSING != iError)
    {
        m_iNumPagesDownloading --;
        ASSERT(m_iNumPagesDownloading == 0);
    }

    if (m_pCurDownloadStringList == m_pRobotsTxt)
    {
        CWCStringList *pslNew=NULL;

        // Process robots.txt file
        if (SUCCEEDED(ParseRobotsTxt(m_pRobotsTxt->GetString(iPageIndex), &pslNew)))
        {
            m_pRobotsTxt->SetStringData(iPageIndex, (DWORD_PTR)(pslNew));
        }
    }
    else
    {
        // Process normal file
        ASSERT(m_pCurDownloadStringList == m_pPages);

        DWORD dwData, dwRecurseLevelsFromThisPage;

        dwData = (DWORD)m_pPages->GetStringData(iPageIndex);
        dwRecurseLevelsFromThisPage = dwData & DATA_RECURSEMASK;

        dwData |= DATA_DLFINISHED;
        if (iError > 0)
            dwData |= DATA_DLERROR;

        // mark as downloaded
        m_pCurDownloadStringList->SetStringData(iPageIndex, dwData);

        // Is this the first page?
        if (m_iTotalStarted == 1)
        {
            // Check the HTTP response code
            DWORD dwResponseCode;

            hr = m_pCurDownload->GetResponseCode(&dwResponseCode);

            if (SUCCEEDED(hr))
            {
                hr = CheckResponseCode(dwResponseCode);
                if (FAILED(hr))
                    fOperationComplete = TRUE;
            }
            else
                DBG("CWebCrawler failed to GetResponseCode");

            // Get the Charset
            BSTR bstrCharSet=NULL;
            IHTMLDocument2 *pDoc=NULL;


            // -> Bharats --------
            // Find a link tag and store it away the cdf by copying it (if it points to a cdf.)
            // do url combine of this cdf 
            if (SUCCEEDED(m_pCurDownload->GetDocument(&pDoc)) && pDoc &&
                SUCCEEDED(pDoc->get_charset(&bstrCharSet)) && bstrCharSet)
            {
                WriteOLESTR(m_pSubscriptionItem, c_szPropCharSet, bstrCharSet);
                TraceMsg(TF_THISMODULE, "Charset = \"%ws\"", bstrCharSet);
                SysFreeString(bstrCharSet);        
            }
            else
                WriteEMPTY(m_pSubscriptionItem, c_szPropCharSet);

            if(pDoc)
            {
                if(FAILED(GetChannelItem(NULL)))   // A Doc exists and this download is not from a channel itself
                {
                    IHTMLLinkElement *pLink = NULL;
                    hr = SearchForElementInHead(pDoc, OLESTR("REL"), OLESTR("OFFLINE"), 
                                            IID_IHTMLLinkElement, (IUnknown **)&pLink);
                    if(S_OK == hr)
                    {
                        hr = pLink->get_href(&bstrCDFURL);
                        pLink->Release();
                    }
                }   
                pDoc->Release();
                pDoc = NULL;
            }
        }

        if ((iError != _ERROR_REPROCESSING) && (iError != BDU2_ERROR_NONE))
        {
            if (iError != BDU2_ERROR_NOT_HTML)
                m_iDownloadErrors ++;

            if (iError == BDU2_ERROR_MAXSIZE)
            {
                SetEndStatus(INET_E_AGENT_MAX_SIZE_EXCEEDED);
                fOperationComplete = TRUE;
            }
        }
        else
        {
            // Don't process this url if we already have set fOperationComplete
            if (!fOperationComplete)
            {
                // Did we get *just* the HEAD info?
                if (IsAgentFlagSet(FLAG_HEADONLY))
                {
                    SYSTEMTIME stLastModified;
                    FILETIME   ftLastModified;

                    if (SUCCEEDED(m_pCurDownload->GetLastModified(&stLastModified)) &&
                                  SystemTimeToFileTime(&stLastModified, &ftLastModified))
                    {
                        DBG("Retrieved 'HEAD' info; change detection based on Last Modified");

                        hr = PostCheckUrlForChange(&m_varChange, NULL, ftLastModified);
                        // If we FAILED, we mark it as changed.
                        if (hr == S_OK || FAILED(hr))
                        {
                            SetAgentFlag(FLAG_CRAWLCHANGED);
                            DBG("URL has changed; will flag webcrawl as changed");
                        }

                        // "Changes Only" mode, persist change detection code
                        ASSERT(IsAgentFlagSet(FLAG_CHANGESONLY));
                        ASSERT(m_iTotalStarted == 1);
                        WriteVariant(m_pSubscriptionItem, c_szPropChangeCode, &m_varChange);
                    }
                }
                else
                {
                    // Get real URL in case we were redirected
                    if (FAILED(GetRealUrl(iPageIndex, &pwszThisUrl)))
                    {
                        fOperationComplete = TRUE;        // bad
                    }
                    else
                    {
                        ASSERT(pwszThisUrl);

                        // Get host name from first page if necessary
                        if ((iPageIndex==0) &&
                            (m_dwRecurseLevels>0) &&
                            !IsRecurseFlagSet(WEBCRAWL_LINKS_ELSEWHERE) &&
                            !m_bstrHostName)
                        {
                            GetHostName(pwszThisUrl, &m_bstrHostName);
#ifdef DEBUG
                            if (m_bstrHostName)
                                TraceMsg(TF_THISMODULE, "Just got first host name: %ws", m_bstrHostName);
                            else
                                DBG_WARN("Get first host name failed!!!");
#endif
                        }

                        DWORD dwCurSize = 0, dwRepeat = 0;

                        HRESULT hr1;

                        do
                        {
                            hr1 = S_OK;

                            // Make page and dependencies sticky and get their total size
                            fDiskFull = FALSE;
                            MakePageStickyAndGetSize(pwszThisUrl, &dwCurSize, &fDiskFull);

                            if (fDiskFull && (dwRepeat < 2))
                            {
                                // If we couldn't make stuff sticky, ask host to make cache bigger
                                hr1 = m_pAgentEvents->ReportError(&m_SubscriptionCookie,
                                            INET_E_AGENT_EXCEEDING_CACHE_SIZE, NULL);

                                if (hr1 == E_PENDING)
                                {
                                    // Host is going to ask the user to increase the cache size.
                                    // Host should either abort or resume us later.
                                    SetAgentFlag(FLAG_WAITING_FOR_INCREASED_CACHE);
                                    goto done;
                                }
                                else if (hr1 == INET_S_AGENT_INCREASED_CACHE_SIZE)
                                {
                                    // Host just increased the cache size. Try it again.
                                }
                                else
                                {
                                    // Not gonna do it. Abort.
                                }
                            }
                        }
                        while ((hr1 == INET_S_AGENT_INCREASED_CACHE_SIZE) && (++dwRepeat <= 2));

                        m_dwCurSize += dwCurSize;

                        // Is there form based authentication that we need to handle
                        // on the top page of this subscription?
                        if (!fDiskFull && (0 == iPageIndex) && !m_pCurDownload->GetFormSubmitted())
                        {
                            hr = FindAndSubmitForm();
                            if (S_OK == hr)
                            {
                                // Successfully submitted form.  Bail and wait for the next OnDownloadComplete() call.
                                // FEATURE: Should we make the form URL and dependencies sticky?
                                return S_OK;
                            }
                            else if (FAILED(hr))
                            {
                                // We failed trying to submit the form.  Bail.
                                // FEATURE: Should we set a better error string?
                                SetEndStatus(E_FAIL);
                                CleanUp();
                                return S_OK;
                            }
                            // else no form - fall through
                        }

                        TraceMsg(TF_THISMODULE, "WebCrawler up to %d kb", (int)(m_dwCurSize>>10));

                        if ((m_lMaxNumUrls < 0) &&
                            !dwRecurseLevelsFromThisPage &&
                            !(dwData & DATA_CODEBASE))
                        {
                            m_lMaxNumUrls = m_pPages->NumStrings() + ((m_pRobotsTxt) ? m_pRobotsTxt->NumStrings() : 0);
                        }
                    }  // SUCCEEDED(GetRealUrl)
                }  // !FLAG_HEADONLY
            } // !fOperationComplete

            // If we're in "Changes Only" mode, we're done.
            if (IsAgentFlagSet(FLAG_CHANGESONLY))
                fOperationComplete = TRUE;

            // Check to see if we're past our max size
            if (!fOperationComplete && fDiskFull || (m_dwMaxSize && (m_dwCurSize >= (m_dwMaxSize<<10))))
            {
        #ifdef DEBUG
                if (fDiskFull)
                    DBG_WARN("Disk/cache full; aborting.");
                else
                    TraceMsg(TF_WARNING, "Past maximum size; aborting. (%d kb of %d kb)", (int)(m_dwCurSize>>10), (int)m_dwMaxSize);
        #endif
                // abort operation
                fOperationComplete = TRUE;

                if (fDiskFull)
                {
                    SetEndStatus(INET_E_AGENT_CACHE_SIZE_EXCEEDED);
                }
                else
                {
                    SetEndStatus(INET_E_AGENT_MAX_SIZE_EXCEEDED);
                }
            }

            if (!fOperationComplete)
            {
                // Get any links from page
                // Get "dependency links" from page - frames, etc.

                // we do this even if a CDF file is specified
                // Essentially, since the user has no clue about the CDF
                // file - we do not want to confuse the user
                GetDependencyLinksFromPage(pwszThisUrl, dwRecurseLevelsFromThisPage);

                if (dwRecurseLevelsFromThisPage)
                {
                    // Get links from this page that we want to follow.
                    GetLinksFromPage();

                    if (m_pPendingLinks)
                        TraceMsg(TF_THISMODULE,
                            "Total of %d unique valid links found", m_pPendingLinks->NumStrings());

                    m_dwPendingRecurseLevel = dwRecurseLevelsFromThisPage - 1;
                }

            }
        }   // !iError
    } // !robots.txt

    if(!fOperationComplete)
        StartCDFDownload(bstrCDFURL, pwszThisUrl);
        
    if(!m_fCDFDownloadInProgress)
    {
        // Don't try code downloads or any of the rest until you're done with
        // the cdf download
        // See if we have any more URLs to download.
        if (!fOperationComplete && FAILED(StartNextDownload()))
            fOperationComplete = TRUE;  // No, we're done!
    }

    CheckOperationComplete(fOperationComplete);

done:
    if (pwszThisUrl)
        MemFree(pwszThisUrl);

    SAFEFREEBSTR(bstrCDFURL);
            

    return S_OK;
}



HRESULT CWebCrawler::StartCDFDownload(WCHAR *pwszCDFURL, WCHAR *pwszBaseUrl)
{
    HRESULT hr = E_FAIL;
    m_fCDFDownloadInProgress = FALSE;
    if(pwszCDFURL)
    {
        // We have a CDF File - begin download of it
    
        if (m_pRunAgent)
        {
            ASSERT(0);
            DBG_WARN("WebCrawler: Attempting to download next CDF when nother CDF exists.");
            hr = E_FAIL;
            goto Exit;
        }
        else
        {
             // create subscription item for CDL agent.

            ISubscriptionItem *pItem = NULL;
            
            
            if (m_dwMaxSize && ((m_dwCurSize>>10) >= m_dwMaxSize))
            {
                // We've exceeded our maximum download KB limit and can't continue.
                DBG_WARN("WebCrawler: Exceeded Maximum KB download limit with CodeBase download.");
                SetEndStatus(hr = INET_E_AGENT_MAX_SIZE_EXCEEDED);
                goto Exit;
            }

            if (!m_pSubscriptionItem ||
                FAILED(hr = DoCloneSubscriptionItem(m_pSubscriptionItem, NULL, &pItem)))
            {
                goto Exit;
            }
            ASSERT(pItem != NULL);
            ASSERT(pwszCDFURL != NULL);
            WCHAR   wszCombined[INTERNET_MAX_URL_LENGTH];
            DWORD dwBufSize = ARRAYSIZE(wszCombined);
            
            if (SUCCEEDED(UrlCombineW(pwszBaseUrl, pwszCDFURL, wszCombined, &dwBufSize, 0)))
            {
            
                WriteOLESTR(pItem, c_szPropURL, wszCombined);
            
                WriteEMPTY(pItem, c_szPropCrawlGroupID); // clear the old cache group id - don't want 
                                                         // children to know of it 
                // The crawler already has a cache group id that we simply use as the new ID
                WriteLONGLONG(pItem, c_szPropCrawlNewGroupID, m_llCacheGroupID);
                WriteDWORD(pItem, c_szPropChannelFlags, CHANNEL_AGENT_PRECACHE_ALL);
                // Finally - since we know that this is for offline use, we just set the flags to precache all
            
                m_pRunAgent = new CRunDeliveryAgent();
                if (m_pRunAgent)
                    hr = m_pRunAgent->Init((CRunDeliveryAgentSink *)this, pItem, CLSID_ChannelAgent);
                pItem->Release();

                if (m_pRunAgent && SUCCEEDED(hr))
                {
                    hr = m_pRunAgent->StartAgent(); 
                    if (hr == E_PENDING)
                    {
                        hr = S_OK;
                        m_fCDFDownloadInProgress = TRUE;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
    }
Exit:
    if((S_OK != hr) && m_pRunAgent)
    {
        CRunDeliveryAgent::SafeRelease(m_pRunAgent);
    }
    return hr;

}

// CRunDeliveryAgentSink call back method to signal the end of a codebase download.

HRESULT CWebCrawler::OnAgentEnd(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
                               long lSizeDownloaded, HRESULT hrResult, LPCWSTR wszResult,
                               BOOL fSynchronous)
{
    ASSERT(m_pRunAgent != NULL);
    BOOL        fOperationComplete = FALSE;
    CRunDeliveryAgent::SafeRelease(m_pRunAgent);



    if(m_fCDFDownloadInProgress)
    {
        m_fCDFDownloadInProgress = FALSE; 
    }
    else
    {
        int         iPageIndex = m_iCurDownloadStringIndex;
        BOOL        fDiskFull = FALSE;
        CCodeBaseHold *pcbh = NULL;
        BOOL        fError;
        LPCWSTR     pwszThisURL=NULL;

        TraceMsg(TF_THISMODULE, "WebCrawler: OnAgentEnd of CRunDeliveryAgentSink");
        ASSERT(m_pCodeBaseList);
        ASSERT(iPageIndex < m_pCurDownloadStringList->NumStrings());
        ASSERT(m_pCurDownloadStringList == m_pCodeBaseList);

        m_iNumPagesDownloading --;
        ASSERT(m_iNumPagesDownloading == 0);

        pcbh = (CCodeBaseHold *)m_pCodeBaseList->GetStringData(iPageIndex);
        pwszThisURL = m_pCodeBaseList->GetString(iPageIndex);
        ASSERT(pwszThisURL);

        pcbh->dwFlags |= DATA_DLFINISHED;

        fError = FAILED(hrResult);
        if (fSynchronous)
        {
            fError = TRUE;
            ASSERT(FAILED(hrResult));       // we can't succeed synchronously...
        }

        //NOTE: The CDL agent will abort if it finds the file exceeds the MaxSizeKB.  In this case the file is not
        //      counted and there may be other smaller CAB's that can be downloaded, so we continue to proceed.

        if (fError)
        {
            pcbh->dwFlags |= DATA_DLERROR;
            m_iDownloadErrors ++;
            SetEndStatus(hrResult);
        }
        else
        {
            BYTE chBuf[MY_MAX_CACHE_ENTRY_INFO];
            LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;
            TCHAR   szUrl[INTERNET_MAX_URL_LENGTH];

            MyOleStrToStrN(szUrl, INTERNET_MAX_URL_LENGTH, pwszThisURL);

            if (FAILED(GetUrlInfoAndMakeSticky(NULL, szUrl,
                                 lpInfo, sizeof(chBuf), m_llCacheGroupID)))
            {
                //REVIEW: Do something here?  Unlikely to occur in practice.
                fOperationComplete = TRUE;
                ASSERT(0);
            }
            else
            {
                m_dwCurSize += lpInfo->dwSizeLow;
            }

            TraceMsg(TF_THISMODULE, "WebCrawler up to %d kb", (int)(m_dwCurSize>>10));

            if (m_dwMaxSize && ((m_dwCurSize>>10)>m_dwMaxSize))
            {

                // abort operation
                fOperationComplete = TRUE;
                if (fDiskFull)
                    SetEndStatus(INET_E_AGENT_CACHE_SIZE_EXCEEDED);
                else
                    SetEndStatus(INET_E_AGENT_MAX_SIZE_EXCEEDED);
            }

        } // !fError
    }
    // See if we have any more URLs to download.
    if (!fOperationComplete && FAILED(StartNextDownload()))
        fOperationComplete = TRUE;  // No, we're done!

    if(!fSynchronous)
        CheckOperationComplete(fOperationComplete);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////
//
// CheckCompleteOperation :: If parameter is TRUE, then all downloads are
//                           complete, the appropriate STATUS_CODE is set
//                           and clean up initiated.
//
//////////////////////////////////////////////////////////////////////////
void CWebCrawler::CheckOperationComplete(BOOL fOperationComplete)
{
    if (fOperationComplete)
    {
        DBG("WebCrawler complete. Shutting down.");
        if (INET_S_AGENT_BASIC_SUCCESS == GetEndStatus())
        {
            // Set end status appropriately
            if (m_iDownloadErrors)
            {
                if (m_iPagesStarted<=1)
                {
                    DBG("Webcrawl failed - first URL failed.");
                    SetEndStatus(E_INVALIDARG);
                }
                else
                {
                    DBG("Webcrawl succeeded - some URLs failed.");
                    SetEndStatus(INET_S_AGENT_PART_FAIL);
                }
            }
            else
            {
                DBG("Webcrawl succeeded");
                if (!IsAgentFlagSet(FLAG_CRAWLCHANGED))
                {
                    SetEndStatus(S_FALSE);
                    DBG("No changes were detected");
                }
                else
                {
                    DBG("Webcrawl succeeded");
                    SetEndStatus(S_OK);
                }
            }
        }

        if (m_llOldCacheGroupID)
        {
            DBG("Nuking old cache group.");
            if (!DeleteUrlCacheGroup(m_llOldCacheGroupID, 0, 0))
            {
                DBG_WARN("Failed to delete old cache group!");
            }
        }

        WriteLONGLONG(m_pSubscriptionItem, c_szPropCrawlGroupID, m_llCacheGroupID);

        m_lSizeDownloadedKB = ((m_dwCurSize+511)>>10);

        WriteDWORD(m_pSubscriptionItem, c_szPropCrawlActualSize, m_lSizeDownloadedKB);

        if (m_lMaxNumUrls >= 0)
        {
            WriteDWORD(m_pSubscriptionItem, c_szPropActualProgressMax, m_lMaxNumUrls);
        }

        // Send a robots.txt warning to the user if we ended up not downloading stuff
        //  because of the server's robots.txt file
        if (m_iSkippedByRobotsTxt != 0)
        {
            HRESULT hr = S_OK;      // Make it an "information" message
            WCHAR wszMessage[200];

            if (m_iPagesStarted==1)
            {
                hr = INET_E_AGENT_WARNING;  // Unless we're missing almost everything
            }

            if (MLLoadStringW(IDS_CRAWL_ROBOTS_TXT_WARNING, wszMessage, ARRAYSIZE(wszMessage)))
            {
                m_pAgentEvents->ReportError(&m_SubscriptionCookie, hr, wszMessage);
            }
        }

        // Will call "UpdateEnd"
        CleanUp();
    }
}

HRESULT CWebCrawler::ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes)
{
    // Customize our end status string
    switch (GetEndStatus())
    {
        case INET_E_AGENT_MAX_SIZE_EXCEEDED :
                              *puiRes = IDS_AGNT_STATUS_SIZELIMIT; break;
        case INET_E_AGENT_CACHE_SIZE_EXCEEDED :
                              *puiRes = IDS_AGNT_STATUS_CACHELIMIT; break;
        case E_FAIL         : *puiRes = IDS_CRAWL_STATUS_NOT_OK; break;
        case S_OK           :
            if (!IsAgentFlagSet(FLAG_CHANGESONLY))
                *puiRes = IDS_CRAWL_STATUS_OK;
            else
                *puiRes = IDS_URL_STATUS_OK;
            break;
        case S_FALSE        :
            if (!IsAgentFlagSet(FLAG_CHANGESONLY))
                *puiRes = IDS_CRAWL_STATUS_UNCHANGED;
            else
                *puiRes = IDS_URL_STATUS_UNCHANGED;
            break;
        case INET_S_AGENT_PART_FAIL : *puiRes = IDS_CRAWL_STATUS_MOSTLYOK; break;
    }

    return CDeliveryAgent::ModifyUpdateEnd(pEndItem, puiRes);
}

HRESULT CWebCrawler::DownloadStart(LPCWSTR pchUrl, DWORD dwDownloadId, DWORD dwType, DWORD dwReserved)
{
    HRESULT hr = S_OK, hr2;

    // free threaded
    EnterCriticalSection(&m_critDependencies);

    if (NULL == pchUrl)
    {
        DBG_WARN("CWebCrawler::DownloadStart pchUrl=NULL");
    }
    else
    {
        // Check to see if this is already in our dependencies list and abort if so
        if (CWCStringList::STRLST_ADDED != m_pDependencies->AddString(pchUrl, 0))
        {
            hr = E_ABORT;       // Don't download this thing.
            TraceMsg(TF_THISMODULE, "Aborting mshtml url (already added): %ws", pchUrl);
        }

        if (SUCCEEDED(hr))
        {
            // Check to see if this fails the robots.txt and abort if so
            // Note, this will only work if we happen to have already gotten this robots.txt
            // Need to abort here if we haven't gotten it, then get it, then get just this dep. Yuck.
            // Also shouldn't do the check if this is the first page downloaded
            DWORD dwIndex;
            hr2 = GetRobotsTxtIndex(pchUrl, FALSE, &dwIndex);
            if (SUCCEEDED(hr2))
            {
                BOOL fAllow;
                if (SUCCEEDED(ValidateWithRobotsTxt(pchUrl, dwIndex, &fAllow)))
                {
                    if (!fAllow)
                        hr = E_ABORT;   // ooh, failed the test.
                }
            }
        }
    }

    LeaveCriticalSection(&m_critDependencies);

    return hr;
}

HRESULT CWebCrawler::DownloadComplete(DWORD dwDownloadId, HRESULT hrNotify, DWORD dwReserved)
{
    // free threaded
    // Do nothing. We may wish to post message to make sticky here. We may wish to
    //  mark as downloaded in string list here.
//  EnterCriticalSection(&m_critDependencies);
//  LeaveCriticalSection(&m_critDependencies);
    return S_OK;
}


/* 41927 (IE5 4491)
HRESULT CWebCrawler::OnGetReferer(LPCWSTR *ppwszReferer)
{
    if (m_iPagesStarted <= 1)
    {
        *ppwszReferer = NULL;
        return S_FALSE;
    }

    if (m_pCurDownloadStringList == m_pRobotsTxt)
    {
        // Referer is last page from main list to be downloaded
        *ppwszReferer = m_pPages->GetString(m_iPagesStarted-1);
        return S_OK;
    }

    if (m_pCurDownloadStringList == m_pPages)
    {
        // Referer is stored in string list data
        *ppwszReferer = m_pPages->GetString(
            ((m_pPages->GetStringData(m_iCurDownloadStringIndex) & DATA_REFERERMASK) >> DATA_REFERERSHIFT));
        return S_OK;
    }

    // We don't return a referer for code bases
    ASSERT(m_pCurDownloadStringList == m_pCodeBaseList);

    return S_FALSE;
}
*/

HRESULT CWebCrawler::OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword)
{
    HRESULT hr, hrRet=E_FAIL;
    ASSERT(phwnd && ppszUsername && ppszPassword);
    ASSERT((HWND)-1 == *phwnd && NULL == *ppszUsername && NULL == *ppszPassword);

    // If our host name doesn't match the root host name, don't return auth
    // information.

    LPWSTR pwszUrl, bstrHostName=NULL;

    m_pCurDownload->GetRealURL(&pwszUrl);   // may re-enter Trident

    if (pwszUrl)
    {
        GetHostName(pwszUrl, &bstrHostName);
        LocalFree(pwszUrl);
    }

    if (bstrHostName)
    {
        if (!m_bstrHostName || !MyAsciiCmpW(bstrHostName, m_bstrHostName))
        {
            // Host names match. Return auth information.
            // If we're hosted by channel agent, use its auth information
            ISubscriptionItem *pChannel=NULL;
            ISubscriptionItem *pItem=m_pSubscriptionItem;
            
            if (SUCCEEDED(GetChannelItem(&pChannel)))
            {
                pItem = pChannel;
            }
            
            hr = ReadOLESTR(pItem, c_szPropCrawlUsername, ppszUsername);
            if (SUCCEEDED(hr))
            {
                BSTR bstrPassword = NULL;
                hr = ReadPassword(pItem, &bstrPassword);
                if (SUCCEEDED(hr))
                {
                    int len = (lstrlenW(bstrPassword) + 1) * sizeof(WCHAR);
                    *ppszPassword = (LPWSTR) CoTaskMemAlloc(len);
                    if (*ppszPassword)
                    {
                        CopyMemory(*ppszPassword, bstrPassword, len);
                    }
                    SAFEFREEBSTR(bstrPassword);
                    if (*ppszPassword)
                    {
                        hrRet = S_OK;
                    }
                }
            }

            if (FAILED(hrRet))
            {
                SAFEFREEOLESTR(*ppszUsername);
                SAFEFREEOLESTR(*ppszPassword);
            }

            SAFERELEASE(pChannel);
        }

        SysFreeString(bstrHostName);
    }
    return hrRet;
}

HRESULT CWebCrawler::OnClientPull(UINT iID, LPCWSTR pwszOldURL, LPCWSTR pwszNewURL)
{
    // CUrlDownload is informing us it's about to do a client pull.

    // Let's send out a progress report for the new url
    SendUpdateProgress(pwszNewURL, m_iTotalStarted, m_lMaxNumUrls);

    // Now we need to process the current url: make it and dependencies sticky
    DWORD dwCurSize=0;
    BOOL fDiskFull=FALSE;
    MakePageStickyAndGetSize(pwszOldURL, &dwCurSize, &fDiskFull);
    m_dwCurSize += dwCurSize;
    TraceMsg(TF_THISMODULE, "WebCrawler processed page prior to client pull - now up to %d kb", (int)(m_dwCurSize>>10));

    // Tell CUrlDownload to go ahead and download the new url
    return S_OK;
}

HRESULT CWebCrawler::OnOleCommandTargetExec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                                VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;
    IPropertyBag2 *pPropBag = NULL;
    int i;

    //REVIEW: CLSID for this not yet defined.
    if (    pguidCmdGroup 
        && (*pguidCmdGroup == CGID_JavaParambagCompatHack) 
        && (nCmdID == 0) 
        && (nCmdexecopt == MSOCMDEXECOPT_DONTPROMPTUSER))
    {
        if (!IsRecurseFlagSet(WEBCRAWL_GET_CONTROLS))
        {
            goto Exit;
        }

        uCLSSPEC ucs;
        QUERYCONTEXT qc = { 0 };

        ucs.tyspec = TYSPEC_CLSID;
        ucs.tagged_union.clsid = CLSID_JavaVM;

        // Check to see if Java VM is installed. Don't try to get applets if not.
        if (!SUCCEEDED(FaultInIEFeature(NULL, &ucs, &qc, FIEF_FLAG_PEEK)))
        {
            goto Exit;
        }

        ULONG enIndex;
        const DWORD enMax = 7, enMin = 0;
        PROPBAG2 pb[enMax];
        VARIANT vaProps[enMax];
        HRESULT hrResult[enMax];
        enum { enCodeBase = 0, enCabBase, enCabinets, enArchive, enUsesLib, enLibrary, enUsesVer };
        LPWSTR pwszThisURL = NULL;
        int chLen;

        //REVIEW: This will need to be reviewed later when matching trident code is available
        //        and details worked out.

        if ((pvarargIn->vt != VT_UNKNOWN) || 
            (FAILED(pvarargIn->punkVal->QueryInterface(IID_IPropertyBag2, (void **)&pPropBag))))
        {
             goto Exit;
        }

        if (FAILED(GetRealUrl(m_iCurDownloadStringIndex, &pwszThisURL)))
        {
            pwszThisURL = StrDupW(L"");
        }

        // PROPBAG2 structure for data retrieval
        for (i=enMin; i<enMax; i++)
        {
            pb[i].dwType = PROPBAG2_TYPE_DATA;
            pb[i].vt = VT_BSTR;
            pb[i].cfType = NULL;                   // CLIPFORMAT
            pb[i].dwHint = 0;                      // ????
            pb[i].pstrName = NULL;
            pb[i].clsid = CLSID_NULL;              // ????
            vaProps[i].vt = VT_EMPTY;
            vaProps[i].bstrVal = NULL;
            hrResult[i] = E_FAIL;
        }

        if (((pb[enCodeBase].pstrName = SysAllocString(L"CODEBASE")) != NULL) &&
            ((pb[enCabBase].pstrName = SysAllocString(L"CABBASE")) != NULL) &&
            ((pb[enCabinets].pstrName = SysAllocString(L"CABINETS")) != NULL) &&
            ((pb[enArchive].pstrName = SysAllocString(L"ARCHIVE")) != NULL) &&
            ((pb[enUsesLib].pstrName = SysAllocString(L"USESLIBRARY")) != NULL) &&
            ((pb[enLibrary].pstrName = SysAllocString(L"USESLIBRARYCODEBASE")) != NULL) &&
            ((pb[enUsesVer].pstrName = SysAllocString(L"USESLIBRARYVERSION")) != NULL))
        {

            //Read returns E_FAIL even if it read some of the properties.
            //Since we check hrResult's below this isn't a big deal.

            hr = pPropBag->Read(enMax, &pb[0], NULL, &vaProps[0], &hrResult[0]);

            {
                BSTR bstrCodeBase = NULL;

                // check for CODEBASE
                if (SUCCEEDED(hrResult[enCodeBase]) && (vaProps[enCodeBase].vt == VT_BSTR))
                {
                    bstrCodeBase = vaProps[enCodeBase].bstrVal;
                }

                // add a trailing slash if not already present
                chLen = lstrlenW(bstrCodeBase);
                if (chLen && bstrCodeBase[chLen-1] != '/')
                {
                    LPWSTR szNewCodeBase = 0;
                    int nLen = chLen + 2;
                    szNewCodeBase = (LPWSTR) LocalAlloc(0,sizeof(WCHAR)*nLen);
                    if (szNewCodeBase)
                    {
                        StrCpyNW(szNewCodeBase, bstrCodeBase, nLen);
                        StrCatBuffW(szNewCodeBase, L"/", nLen);
                        SAFEFREEBSTR(bstrCodeBase);
                        bstrCodeBase = vaProps[enCodeBase].bstrVal = SysAllocString(szNewCodeBase);
                        LocalFree(szNewCodeBase);     
                    }
                }

                // check for CABBASE
                if (SUCCEEDED(hrResult[enCabBase]) && (vaProps[enCabBase].vt == VT_BSTR))
                {
                    BSTR szCabBase = vaProps[enCabBase].bstrVal;

                    // Add CABBASE URL to list of CABs to pull.
                    if (SUCCEEDED(CombineBaseAndRelativeURLs(pwszThisURL, bstrCodeBase, &szCabBase)))
                    {
                        m_pPages->AddString(szCabBase, 0);
                    }
                }

                // check for CABINETS
                for (enIndex = enCabinets; enIndex<(enArchive+1); enIndex++)
                {
                    if (SUCCEEDED(hrResult[enIndex]) && (vaProps[enIndex].vt == VT_BSTR))
                    {
                        BSTR szCur = vaProps[enIndex].bstrVal, szPrev = NULL;
                        while (szCur)
                        {
                            WCHAR wcCur = *szCur;

                            if ((wcCur == L'+') || (wcCur == L',') || (wcCur == L'\0'))
                            {
                                BSTR szLast = szPrev, szCabBase = NULL;
                                BOOL bLastFile = FALSE;
                                if (!szPrev)
                                {
                                    szLast = vaProps[enIndex].bstrVal;
                                }
                                szPrev = szCur; szPrev++;

                                if (*szCur == L'\0')
                                {
                                    bLastFile = TRUE;
                                }
                                *szCur = (unsigned short)L'\0';

                                // szLast points to current CabBase.
                                szCabBase = SysAllocString(szLast);
                                if (SUCCEEDED(CombineBaseAndRelativeURLs(pwszThisURL, bstrCodeBase, &szCabBase)))
                                {
                                    int iAdd=m_pPages->AddString(szCabBase, DATA_CODEBASE);
                                    if (m_lMaxNumUrls > 0 && iAdd==CWCStringList::STRLST_ADDED)
                                        m_lMaxNumUrls ++;
                                }
                                SAFEFREEBSTR(szCabBase);

                                if (bLastFile)
                                {
                                    szCur = NULL;
                                    break;
                                }
                            }
                            szCur++;
                        }  // while (szCur)
                    }  // cabinets
                }

                // check for USESLIBRARY* parameters.
                CCodeBaseHold *pcbh = NULL;
                if (SUCCEEDED(hrResult[enUsesLib]) && (vaProps[enUsesLib].vt == VT_BSTR) &&
                    SUCCEEDED(hrResult[enLibrary]) && (vaProps[enLibrary].vt == VT_BSTR))
                {
                    BSTR szThisLibCAB = NULL;
                    pcbh = new CCodeBaseHold();
                    if (pcbh)
                    {
                        pcbh->szDistUnit = SysAllocString(vaProps[enUsesLib].bstrVal);
                        pcbh->dwVersionMS = pcbh->dwVersionLS = -1;
                        pcbh->dwFlags = 0;
                        szThisLibCAB = SysAllocString(vaProps[enLibrary].bstrVal);
                        if (FAILED(CombineBaseAndRelativeURLs(pwszThisURL, bstrCodeBase, &szThisLibCAB)) ||
                            m_pCodeBaseList->AddString(szThisLibCAB, (DWORD_PTR)pcbh) != CWCStringList::STRLST_ADDED)
                        {
                            SAFEFREEBSTR(pcbh->szDistUnit);
                            SAFEDELETE(pcbh);
                        }
                        SAFEFREEBSTR(szThisLibCAB);
                    }
                }

                // Check for USESLIBRARYVERSION (optional)
                if (pcbh && SUCCEEDED(hrResult[enUsesVer]) && (vaProps[enUsesVer].vt == VT_BSTR))
                {
                    int iLen = SysStringByteLen(vaProps[enUsesVer].bstrVal)+1;
                    CHAR *szVerStr = (LPSTR)MemAlloc(LMEM_FIXED, iLen);

                    if (szVerStr)
                    {
                        SHUnicodeToAnsi(vaProps[enUsesVer].bstrVal, szVerStr, iLen);

                        if (FAILED(GetVersionFromString(szVerStr,
                                     &pcbh->dwVersionMS, &pcbh->dwVersionLS)))
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            MemFree(szVerStr);
                            SAFEFREEBSTR(pcbh->szDistUnit);
                            SAFEDELETE(pcbh);
                        }
                        MemFree(szVerStr);
                    }
                }
            }
        } // Read properties

        for (i=enMin; i<enMax; i++)
        {
            SAFEFREEBSTR(pb[i].pstrName);
        }

        if (pwszThisURL)
            LocalFree(pwszThisURL);

        hr = S_OK;
    }

Exit:
    SAFERELEASE(pPropBag);
    return hr;
}

HRESULT CWebCrawler::GetDownloadNotify(IDownloadNotify **ppOut)
{
    HRESULT hr=S_OK;

    if (m_pDownloadNotify)
    {
        m_pDownloadNotify->LeaveMeAlone();
        m_pDownloadNotify->Release();
        m_pDownloadNotify=NULL;
    }

    CDownloadNotify *pdn = new CDownloadNotify(this);

    if (pdn)
    {
        hr = pdn->Initialize();
        
        if (SUCCEEDED(hr))
        {
            m_pDownloadNotify = pdn;
            *ppOut = m_pDownloadNotify;
            m_pDownloadNotify->AddRef();
        }
        else
        {
            pdn->Release();
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppOut = NULL;
    }

    return hr;
}

//---------------------------------------------------------------
// CWebCrawler::CDownloadNotify class
//---------------------------------------------------------------
CWebCrawler::CDownloadNotify::CDownloadNotify(CWebCrawler *pParent)
{
    ASSERT(pParent);

    m_cRef = 1;

    m_pParent = pParent;
    pParent->AddRef();
}

HRESULT CWebCrawler::CDownloadNotify::Initialize()
{
    m_hrCritParent = InitializeCriticalSectionAndSpinCount(&m_critParent, 0) ? S_OK : E_OUTOFMEMORY;

    return m_hrCritParent;
}

CWebCrawler::CDownloadNotify::~CDownloadNotify()
{
    DBG("Destroying CWebCrawler::CDownloadNotify");

    ASSERT(!m_pParent);
    SAFERELEASE(m_pParent);

    if (SUCCEEDED(m_hrCritParent))
    {
        DeleteCriticalSection(&m_critParent);
    }
}

void CWebCrawler::CDownloadNotify::LeaveMeAlone()
{
    if (m_pParent)
    {
        EnterCriticalSection(&m_critParent);
        SAFERELEASE(m_pParent);
        LeaveCriticalSection(&m_critParent);
    }
}

// IUnknown members
HRESULT CWebCrawler::CDownloadNotify::QueryInterface(REFIID riid, void **ppv)
{
    if ((IID_IUnknown == riid) ||
        (IID_IDownloadNotify == riid))
    {
        *ppv = (IDownloadNotify *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((LPUNKNOWN)*ppv)->AddRef();

    return S_OK;
}

ULONG CWebCrawler::CDownloadNotify::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CWebCrawler::CDownloadNotify::Release(void)
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IDownloadNotify
HRESULT CWebCrawler::CDownloadNotify::DownloadStart(LPCWSTR pchUrl, DWORD dwDownloadId, DWORD dwType, DWORD dwReserved)
{
    HRESULT hr = E_ABORT;   // abort it if we have nobody listening

    TraceMsg(TF_THISMODULE, "DownloadStart id=%d url=%ws", dwDownloadId, pchUrl ? pchUrl : L"(null)");

    EnterCriticalSection(&m_critParent);
    if (m_pParent)
        hr = m_pParent->DownloadStart(pchUrl, dwDownloadId, dwType, dwReserved);
    LeaveCriticalSection(&m_critParent);

    return hr;
}

HRESULT CWebCrawler::CDownloadNotify::DownloadComplete(DWORD dwDownloadId, HRESULT hrNotify, DWORD dwReserved)
{
    HRESULT hr = S_OK;

//  TraceMsg(TF_THISMODULE, "DownloadComplete id=%d hr=%x", dwDownloadId, hrNotify);

    EnterCriticalSection(&m_critParent);
    if (m_pParent)
        hr = m_pParent->DownloadComplete(dwDownloadId, hrNotify, dwReserved);
    LeaveCriticalSection(&m_critParent);

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// Other functions
//
//////////////////////////////////////////////////////////////////////////
// Make a single absolute or relative url sticky and get size
HRESULT GetUrlInfoAndMakeSticky(
            LPCTSTR                     pszBaseUrl,
            LPCTSTR                     pszThisUrl,
            LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo,
            DWORD                       dwBufSize,
            GROUPID                     llCacheGroupID)
{
    DWORD   dwSize;
    TCHAR   szCombined[INTERNET_MAX_URL_LENGTH];

    ASSERT(lpCacheEntryInfo);

    // Combine urls if necessary
    if (pszBaseUrl)
    {
        dwSize = ARRAYSIZE(szCombined);
        if (SUCCEEDED(UrlCombine(pszBaseUrl, pszThisUrl,
                szCombined, &dwSize, 0)))
        {
            pszThisUrl = szCombined;
        }
        else
            DBG_WARN("UrlCombine failed!");
    }

    // Add the size of this URL
    lpCacheEntryInfo->dwStructSize = dwBufSize;
    if (!GetUrlCacheEntryInfo(pszThisUrl, lpCacheEntryInfo, &dwBufSize))
    {
#ifdef DEBUG
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            DBG_WARN("Failed GetUrlCacheEntryInfo, insufficient buffer");
        else
            TraceMsgA(llCacheGroupID ? TF_WARNING : TF_THISMODULE,
                "Failed GetUrlCacheEntryInfo (not in cache) URL=%ws", pszThisUrl);
#endif
        return E_FAIL;
    }

    // Add to new group
    if (llCacheGroupID != 0)
    {
        if (!SetUrlCacheEntryGroup(pszThisUrl, INTERNET_CACHE_GROUP_ADD,
            llCacheGroupID, NULL, 0, NULL))
        {
            switch (GetLastError())
            {
                case ERROR_FILE_NOT_FOUND:  //  Huh? Must not have been able to add the index entry?
                case ERROR_DISK_FULL:
                    return E_OUTOFMEMORY;

                case ERROR_NOT_ENOUGH_QUOTA:
                    return S_OK;            //  We do our own quota handling.

                default:
                    TraceMsgA(TF_WARNING | TF_THISMODULE, "GetUrlInfoAndMakeSticky: Got unexpected error from SetUrlCacheEntryGroup() - GLE = 0x%08x", GetLastError());
                    return E_FAIL;
            }
        }
    }

    return S_OK;
}

// GenerateCode will generate a DWORD code from a file.

#define ELEMENT_PER_READ        256
#define ELEMENT_SIZE            sizeof(DWORD)

HRESULT GenerateCode(LPCTSTR lpszLocalFileName, DWORD *pdwRet)
{
    DWORD dwCode=0;
    DWORD dwData[ELEMENT_PER_READ], i, dwRead;
    HRESULT hr = S_OK;
    HANDLE  hFile;

    hFile = CreateFile(lpszLocalFileName, GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
            0, NULL);

    if (INVALID_HANDLE_VALUE != hFile)
    {
        do
        {
            dwRead = 0;
            if (ReadFile(hFile, dwData, ELEMENT_PER_READ * ELEMENT_SIZE, &dwRead, NULL))
            {
                for (i=0; i<dwRead / ELEMENT_SIZE; i++)
                {
                    dwCode = (dwCode << 31) | (dwCode >> 1) + dwData[i];
//                  dwCode += dwData[i];
                }
            }   
        }
        while (ELEMENT_PER_READ * ELEMENT_SIZE == dwRead);

        CloseHandle(hFile);
    }
    else
    {
        hr = E_FAIL;
        TraceMsg(TF_THISMODULE|TF_WARNING,"GenerateCode: Unable to open cache file, Error=%x", GetLastError());
    }

    *pdwRet = dwCode;

    return hr;
}

// S_OK : We retrieved a good last modified or content code to use
// S_FALSE : We fell back to using the one passed into pvarChange
// E_FAIL : We failed miserably.
// E_INVALIDARG : Get a clue
// *pfGetContent : TRUE if we need a GET for PostCheckUrlForChange to work right
HRESULT PreCheckUrlForChange(LPCTSTR lpURL, VARIANT *pvarChange, BOOL *pfGetContent)
{
    BYTE    chBuf[MY_MAX_CACHE_ENTRY_INFO];

    LPINTERNET_CACHE_ENTRY_INFO lpInfo = (LPINTERNET_CACHE_ENTRY_INFO) chBuf;

    if (pvarChange->vt != VT_EMPTY && pvarChange->vt != VT_I4 && pvarChange->vt != VT_CY)
        return E_INVALIDARG;

    if (SUCCEEDED(GetUrlInfoAndMakeSticky(NULL, lpURL, lpInfo, sizeof(chBuf), 0)))
    {
        FILETIME ftOldLastModified = *((FILETIME *) &pvarChange->cyVal);

        if (lpInfo->LastModifiedTime.dwHighDateTime || lpInfo->LastModifiedTime.dwLowDateTime)
        {
            // We have a last modified time. Use it or the persisted one.

            if (pfGetContent)
                *pfGetContent = FALSE;

            if ((pvarChange->vt != VT_CY)
             || (lpInfo->LastModifiedTime.dwHighDateTime > ftOldLastModified.dwHighDateTime)
             || ((lpInfo->LastModifiedTime.dwHighDateTime == ftOldLastModified.dwHighDateTime)
                && (lpInfo->LastModifiedTime.dwLowDateTime > ftOldLastModified.dwLowDateTime)))
            {
                // Cache Last Modified is newer than saved Last Modified. Use cache's.
                pvarChange->vt = VT_CY;
                pvarChange->cyVal = *((CY *)&(lpInfo->LastModifiedTime));

                return S_OK;
            }

            ASSERT(pvarChange->vt == VT_CY);

            // Persisted Last Modified time is most recent. Use it.
            return S_OK;
        }

        DWORD dwCode;

        if (SUCCEEDED(GenerateCode(lpInfo->lpszLocalFileName, &dwCode)))
        {
            pvarChange->vt = VT_I4;
            pvarChange->lVal = (LONG) dwCode;

            if (pfGetContent)
                *pfGetContent = TRUE;

            return S_OK;
        }

        // Failed GenerateCode. Weird. Fall through.
    }

    if (pvarChange->vt != VT_EMPTY)
    {
        if (pfGetContent)
            *pfGetContent = (pvarChange->vt == VT_I4);

        return S_FALSE;
    }

    // We don't have old change detection, we don't have cache content, better GET
    if (pfGetContent)
        *pfGetContent = TRUE;

    return E_FAIL;  // Couldn't get anything. pvarChange->vt==VT_EMPTY
}

// S_FALSE : no change
// S_OK    : changed
// E_      : failure of some sort

// pvarChange from PreCheckUrlForChange. We return a new one.
// lpInfo  : must be valid if *pfGetContent was TRUE
// ftNewLastModified : must be filled in if *pfGetContent was FALSE
HRESULT PostCheckUrlForChange(VARIANT                    *pvarChange,
                              LPINTERNET_CACHE_ENTRY_INFO lpInfo,
                              FILETIME                    ftNewLastModified)
{
    HRESULT hr = S_FALSE;
    VARIANT varChangeNew;

    DWORD   dwNewCode = 0;

    if (!pvarChange || (pvarChange->vt != VT_I4 && pvarChange->vt != VT_CY && pvarChange->vt != VT_EMPTY))
        return E_INVALIDARG;

    varChangeNew.vt = VT_EMPTY;

    if (ftNewLastModified.dwHighDateTime || ftNewLastModified.dwLowDateTime)
    {
        varChangeNew.vt = VT_CY;
        varChangeNew.cyVal = *((CY *) &ftNewLastModified);
    }
    else
    {
        if (lpInfo &&
            SUCCEEDED(GenerateCode(lpInfo->lpszLocalFileName, &dwNewCode)))
        {
            varChangeNew.vt = VT_I4;
            varChangeNew.lVal = dwNewCode;
        }
    }

    if (pvarChange->vt == VT_CY)
    {
        // We have an old last modified time. Use that to determine change.
        FILETIME ftOldLastModified = *((FILETIME *) &(pvarChange->cyVal));

        if ((!ftNewLastModified.dwHighDateTime && !ftNewLastModified.dwLowDateTime)
            || (ftNewLastModified.dwHighDateTime > ftOldLastModified.dwHighDateTime)
            || ((ftNewLastModified.dwHighDateTime == ftOldLastModified.dwHighDateTime)
                && (ftNewLastModified.dwLowDateTime > ftOldLastModified.dwLowDateTime)))
        {
            // NewLastModified > OldLastModified (or we don't have a NewLastModified)
            DBG("PostCheckUrlForChange change detected via Last Modified");
            hr = S_OK;      // We have changed
        }
    }
    else if (pvarChange->vt == VT_I4)
    {
        // We have an old code. Use that to determine change.
        DWORD dwOldCode = (DWORD) (pvarChange->lVal);

        if ((dwOldCode != dwNewCode) ||
            !dwNewCode)
        {
            DBG("PostCheckUrlForChange change detected via content code");
            hr = S_OK;  // We have changed
        }
    }
    else
        hr = E_FAIL;    // No old code.

    *pvarChange = varChangeNew;

    return hr;
}

//////////////////////////////////////////////////////////////////////////
//
// CHelperOM implementation
//
//////////////////////////////////////////////////////////////////////////

CHelperOM::CHelperOM(IHTMLDocument2 *pDoc)
{
    ASSERT(pDoc);
    m_pDoc = pDoc;
    if (pDoc)
        pDoc->AddRef();
}

CHelperOM::~CHelperOM()
{
    SAFERELEASE(m_pDoc);
}

HRESULT CHelperOM::GetTagCollection(
                        IHTMLDocument2          *pDoc,
                        LPCWSTR                  wszTagName,
                        IHTMLElementCollection **ppCollection)
{
    IHTMLElementCollection *pAll=NULL;
    IDispatch              *pDisp=NULL;
    VARIANT                 TagName;
    HRESULT                 hr;

    // We have to get "all", then sub-collection
    hr = pDoc->get_all(&pAll);
    if (pAll)
    {
        TagName.vt = VT_BSTR;
        TagName.bstrVal = SysAllocString(wszTagName);
        if (NULL == TagName.bstrVal)
            hr = E_OUTOFMEMORY;
        else
        {
            hr = pAll->tags(TagName, &pDisp);
            SysFreeString(TagName.bstrVal);
        }
        pAll->Release();
    }
    if (pDisp)
    {
        hr = pDisp->QueryInterface(IID_IHTMLElementCollection,
                                        (void **)ppCollection);
        pDisp->Release();
    }
    if (FAILED(hr)) DBG("GetSubCollection failed");

    return hr;
}


// Collections we get:
//
// IHTMLWindow2->get_document
//  IHTMLDocument2  ->get_links
//  IHTMLElementCollection->item
//                          ->get_hostname
//                          ->get_href
//                  ->get_all
//                      ->tags("map")
//  IHTMLElementCollection  ->item
//                              ->get_areas
//  IHTMLElementCollection          ->item
//  IHTMLAreaElement                    ->get_href
//                  ->get_all
//                      ->tags("meta")
//  IHTMLElementCollection  ->item
//                  ->get_all
//                      ->tags("frame")
//  IHTMLElementCollection  ->item
//                  ->get_all
//                      ->tags("iframe")
//  IHTMLElementCollection  ->item

// We recurse EnumCollection to get the maps (since
//      it's a collection of collections)


// hideous hack: IHTMLElementCollection can actually be IHTMLAreasCollection
//  the interface used to be derived from the other. It still has identical
//  methods. We typecast just in case that changes. Hopefully they will fix
//  so that Areas is derived from Element again.
HRESULT CHelperOM::EnumCollection(
            IHTMLElementCollection *pCollection,
            CWCStringList          *pStringList,
            CollectionType          Type,
            PFN_CB                  pfnCB,
            DWORD_PTR               dwCBData)
{
    IHTMLAnchorElement *pLink;
    IHTMLMapElement  *pMap;
    IHTMLAreaElement *pArea;
    IHTMLMetaElement *pMeta;
    IHTMLElement     *pEle;
    IDispatch        *pDispItem = NULL;

    HRESULT hr;
    BSTR    bstrItem=NULL;
    long    l, lCount;
    VARIANT vIndex, vEmpty, vData;
    BSTR    bstrTmp1, bstrTmp2;
    DWORD   dwStringData;

    VariantInit(&vEmpty);
    VariantInit(&vIndex);
    VariantInit(&vData);

    if (Type==CTYPE_MAP)
        hr = ((IHTMLAreasCollection *)pCollection)->get_length(&lCount);
    else
        hr = pCollection->get_length(&lCount);

    if (FAILED(hr))
        lCount = 0;

#ifdef DEBUG
    LPSTR lpDSTR[]={"Links","Maps","Areas (links) In Map", "Meta", "Frames"};
    TraceMsgA(TF_THISMODULE, "CWebCrawler::GetCollection, %d %s found", lCount, lpDSTR[(int)Type]);
#endif

    for (l=0; l<lCount; l++)
    {
        vIndex.vt = VT_I4;
        vIndex.lVal = l;
        dwStringData = 0;

        if (Type==CTYPE_MAP)
            hr = ((IHTMLAreasCollection *)pCollection)->item(vIndex, vEmpty, &pDispItem);
        else
            hr = pCollection->item(vIndex, vEmpty, &pDispItem);

        if (SUCCEEDED(hr))
        {
            ASSERT(vData.vt == VT_EMPTY);
            ASSERT(!bstrItem);

            if (pDispItem)
            {
                // Get the URL from the IDispatch
                switch(Type)
                {
                    case CTYPE_LINKS:       // get href from <a>
                        hr = pDispItem->QueryInterface(IID_IHTMLAnchorElement, (void **)&pLink);

                        if (SUCCEEDED(hr) && pLink)
                        {
                            hr = pLink->get_href(&bstrItem);
                            pLink->Release();
                        }
                        break;

                    case CTYPE_MAPS:    // enumeration areas for this map
                        hr = pDispItem->QueryInterface(IID_IHTMLMapElement, (void **)&pMap);

                        if (SUCCEEDED(hr) && pMap)
                        {
                            IHTMLAreasCollection *pNewCollection=NULL;
                            // This gives us another collection. Enumerate it
                            //  for the strings.
                            hr = pMap->get_areas(&pNewCollection);
                            if (pNewCollection)
                            {
                                hr = EnumCollection((IHTMLElementCollection *)pNewCollection, pStringList, CTYPE_MAP, pfnCB, dwCBData);
                                pNewCollection->Release();
                            }
                            pMap->Release();
                        }
                        break;

                    case CTYPE_MAP:     // get href for this area
                        hr = pDispItem->QueryInterface(IID_IHTMLAreaElement, (void **)&pArea);

                        if (SUCCEEDED(hr) && pArea)
                        {
                            hr = pArea->get_href(&bstrItem);
                            pArea->Release();
                        }
                        break;

                    case CTYPE_META:    // get meta name and content as single string
                        hr = pDispItem->QueryInterface(IID_IHTMLMetaElement, (void **)&pMeta);

                        if (SUCCEEDED(hr) && pMeta)
                        {
                            pMeta->get_name(&bstrTmp1);
                            pMeta->get_content(&bstrTmp2);
                            if (bstrTmp1 && bstrTmp2 && *bstrTmp1 && *bstrTmp2)
                            {
                                int nLen = lstrlenW(bstrTmp1) + lstrlenW(bstrTmp2) + 2;
                                bstrItem = SysAllocStringLen(NULL, nLen);

                                StrCpyNW(bstrItem, bstrTmp1, nLen);
                                StrCatBuffW(bstrItem, L"\n", nLen);
                                StrCatBuffW(bstrItem, bstrTmp2, nLen);
                            }
                            SysFreeString(bstrTmp1);
                            SysFreeString(bstrTmp2);
                            pMeta->Release();
                        }
                        break;

                    case CTYPE_FRAMES:      // get "src" attribute
                        hr = pDispItem->QueryInterface(IID_IHTMLElement, (void **)&pEle);

                        if (SUCCEEDED(hr) && pEle)
                        {
                            bstrTmp1 = SysAllocString(L"SRC");

                            if (bstrTmp1)
                            {
                                hr = pEle->getAttribute(bstrTmp1, VARIANT_FALSE, &vData);
                                if (SUCCEEDED(hr) && vData.vt == VT_BSTR)
                                {
                                    bstrItem = vData.bstrVal;
                                    vData.vt = VT_EMPTY;
                                }
                                else
                                    VariantClear(&vData);

                                SysFreeString(bstrTmp1);
                            }
                            else
                            {
                                hr = E_FAIL;
                            }

                            pEle->Release();
                        }
                        break;

                    default:
                        ASSERT(0);
                        // bug in calling code
                }

                if (SUCCEEDED(hr) && bstrItem)
                {
                    // Verify we want to add this item to string list & get data
                    if (pfnCB)
                        hr = pfnCB(pDispItem, &bstrItem, dwCBData, &dwStringData);

                    if (SUCCEEDED(hr) && bstrItem && pStringList)
                        pStringList->AddString(bstrItem, dwStringData);
                }
                SAFERELEASE(pDispItem);
                SAFEFREEBSTR(bstrItem);
            }
        }
        if (E_ABORT == hr)
        {
            DBG_WARN("Aborting enumeration in CHelperOM::EnumCollection at callback's request.");
            break;
        }
    }

    return hr;
}


// Gets all urls from a collection, recursing through frames
HRESULT CHelperOM::GetCollection(
    IHTMLDocument2 *pDoc,
    CWCStringList  *pStringList,
    CollectionType  Type,
    PFN_CB          pfnCB,
    DWORD_PTR       dwCBData)
{
    HRESULT         hr;

    // Get the collection from the document
    ASSERT(pDoc);
    ASSERT(pStringList || pfnCB);

    hr = _GetCollection(pDoc, pStringList, Type, pfnCB, dwCBData);

    return hr;
}

// get all urls from a collection
HRESULT CHelperOM::_GetCollection(
    IHTMLDocument2 *pDoc,
    CWCStringList  *pStringList,
    CollectionType  Type,
    PFN_CB          pfnCB,
    DWORD_PTR       dwCBData)
{
    HRESULT         hr;
    IHTMLElementCollection *pCollection=NULL;

    // From IHTMLDocument2 we get IHTMLElementCollection, then enumerate for the urls

    // Get appropriate collection from document
    switch (Type)
    {
        case CTYPE_LINKS:
            hr = pDoc->get_links(&pCollection);
            break;
        case CTYPE_MAPS:
            hr = GetTagCollection(pDoc, L"map", &pCollection);
            break;
        case CTYPE_META:
            hr = GetTagCollection(pDoc, L"meta", &pCollection);
            break;
        case CTYPE_FRAMES:
            hr = GetTagCollection(pDoc, L"frame", &pCollection);
            break;

        default:
            hr = E_FAIL;
    }
    if (!pCollection) hr=E_NOINTERFACE;
#ifdef DEBUG
    if (FAILED(hr)) DBG_WARN("CWebCrawler::_GetCollection:  get_collection failed");
#endif

    if (SUCCEEDED(hr))
    {
        hr = EnumCollection(pCollection, pStringList, Type, pfnCB, dwCBData);

        // If we're getting frames, we need to enum "iframe" tags separately
        if (SUCCEEDED(hr) && (Type == CTYPE_FRAMES))
        {
            SAFERELEASE(pCollection);
            hr = GetTagCollection(pDoc, L"iframe", &pCollection);

            if (SUCCEEDED(hr) && pCollection)
            {
                hr = EnumCollection(pCollection, pStringList, Type, pfnCB, dwCBData);
            }
        }
    }

    if (pCollection)
        pCollection->Release();

    return hr;
}

extern HRESULT LoadWithCookie(LPCTSTR, POOEBuf, DWORD *, SUBSCRIPTIONCOOKIE *);

// IExtractIcon members
STDMETHODIMP CWebCrawler::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags)
{
    IUniformResourceLocator* pUrl = NULL;
    IExtractIcon* pUrlIcon = NULL;
    HRESULT hr = S_OK;
    BOOL bCalledCoInit = FALSE;

    if (!szIconFile || !piIndex || !pwFlags)
        return E_INVALIDARG;
    //zero out return values in case one of the COM calls fails...
    *szIconFile = 0;
    *piIndex = -1;

    if (!m_pBuf)    {
        m_pBuf = (POOEBuf)MemAlloc(LPTR, sizeof(OOEBuf));
        if (!m_pBuf)
            return E_OUTOFMEMORY;

        DWORD   dwSize;
        hr = LoadWithCookie(NULL, m_pBuf, &dwSize, &m_SubscriptionCookie);
        RETURN_ON_FAILURE(hr);
    }


    if (m_pBuf->bDesktop)
    {
        StrCpyN(szIconFile, TEXT(":desktop:"), cchMax);
    }
    else
    {
        if (m_pUrlIconHelper)
        {
            hr = m_pUrlIconHelper->GetIconLocation (uFlags, szIconFile, cchMax, piIndex, pwFlags);
        }
        else
        {
            hr = CoCreateInstance (CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUniformResourceLocator, (void**)&pUrl);
            if ((CO_E_NOTINITIALIZED == hr || REGDB_E_IIDNOTREG == hr) &&
                SUCCEEDED (CoInitialize(NULL)))
            {
                bCalledCoInit = TRUE;
                hr = CoCreateInstance (CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER, IID_IUniformResourceLocator, (void**)&pUrl);
            }

            if (SUCCEEDED (hr))
            {
                hr = pUrl->SetURL (m_pBuf->m_URL, 1);
                if (SUCCEEDED (hr))
                {
                    hr = pUrl->QueryInterface (IID_IExtractIcon, (void**)&pUrlIcon);
                    if (SUCCEEDED (hr))
                    {
                        hr = pUrlIcon->GetIconLocation (uFlags, szIconFile, cchMax, piIndex, pwFlags);

                        //pUrlIcon->Release();  //released in destructor
                        ASSERT (m_pUrlIconHelper == NULL);
                        m_pUrlIconHelper = pUrlIcon;
                    }
                }
                pUrl->Release();
            }

            //balance CoInit with CoUnit
            //(we still have a pointer to the CLSID_InternetShortcut object, m_pUrlIconHelper,
            //but since that code is in shdocvw there's no danger of it getting unloaded and
            //invalidating our pointer, sez cdturner.)
            if (bCalledCoInit)
                CoUninitialize();
        }
    }

    return hr;
}

STDMETHODIMP CWebCrawler::Extract(LPCTSTR szIconFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize)
{
    HRESULT hr = S_OK;

    if (!phiconLarge || !phiconSmall)
        return E_INVALIDARG;

    //zero out return values in case one of the COM calls fails...
    *phiconLarge = NULL;
    *phiconSmall = NULL;

    if ((NULL != m_pBuf) && (m_pBuf->bDesktop))
    {
        LoadDefaultIcons();
        *phiconLarge = *phiconSmall = g_desktopIcon;
    }
    else
    {
        if (!m_pUrlIconHelper)
            return E_FAIL;

        hr = m_pUrlIconHelper->Extract (szIconFile, nIconIndex, phiconLarge, phiconSmall, nIconSize);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\throttle.h ===
#ifndef _throttle_h
#define _throttle_h

#include "factory.h"

#define MAX_RUNNING_ITEMS           3

#define STATE_USER_IDLE_BEGIN       1
#define STATE_USER_IDLE_END         2

#define WC_INTERNAL_S_PAUSED        (MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xF000))
#define WC_INTERNAL_S_RESUMING      (MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xF001))
#define WC_INTERNAL_S_PENDING       (MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0xF002))


void IdleBegin(HWND hwnd);
void IdleEnd(void);

class COfflineSync;
struct CSyncMgrNode;
struct CUpdateItem;

#define THROTTLER_WNDCLASS  TEXT("WCThrottlerClass")

class CThrottler : public ISubscriptionAgentEvents,
                   public ISubscriptionThrottler
{
public:
    // IUnknown members
    STDMETHODIMP         QueryInterface(REFIID riid, void **punk);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // ISubscriptionAgentEvents members
    STDMETHODIMP UpdateBegin(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie);

    STDMETHODIMP UpdateProgress(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        long lProgressCurrent,
        long lProgressMax,
        HRESULT hrStatus,
        LPCWSTR wszStatus);

    STDMETHODIMP UpdateEnd(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        HRESULT hrResult,
        LPCWSTR wszResult);

    STDMETHODIMP ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError);

    STDMETHODIMP GetSubscriptionRunState( 
        /* [in] */ DWORD dwNumCookies,
        /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies,
        /* [size_is][out] */ DWORD *pdwRunState);
    
    STDMETHODIMP AbortItems( 
        /* [in] */ DWORD dwNumCookies,
        /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies);
    
    STDMETHODIMP AbortAll();

    static HRESULT GetThrottler(CThrottler **ppThrottler);

    HRESULT RunCookies(
        DWORD dwNumCookies,
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookies, 
        DWORD dwSyncFlags);

    HRESULT Advise(COfflineSync *pOfflineSync);
    HRESULT Unadvise(COfflineSync *pOfflineSync);

    ULONG ExternalAddRef();
    ULONG ExternalRelease();

    static LRESULT ThrottlerWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    static void OnIdleStateChange(DWORD dwState);

private:

    enum { WM_THROTTLER_ABORTALL =WM_USER+99,
           WM_THROTTLER_ABORTITEM=WM_USER+100,
           WM_THROTTLER_AUTOCACHESIZE_ASK=WM_USER+101};

    DWORD               m_dwRegister;
#ifdef DEBUG
    DWORD               m_dwThreadId;
#endif    

    static CThrottler   *s_pThrottler;
    const static CFactoryData s_ThrottlerFactoryData;
  
    static HRESULT CreateInstance(IUnknown *punkOuter, IUnknown **ppunk);

    HRESULT RevokeClassObject();
    inline void ReportThrottlerError(const SUBSCRIPTIONCOOKIE *pCookie, HRESULT hrError, 
                                     LPCWSTR pwszErrMsg)
    {
        ReportError(pCookie, hrError, pwszErrMsg);
    }
    
    HRESULT AutoCacheSizeRequest(const SUBSCRIPTIONCOOKIE *pCookie);
    HRESULT AutoCacheSizeAskUser(DWORD dwCacheSizeKB);
    HRESULT IncreaseCacheSize(DWORD *pdwNewCacheSizeKB);

    CThrottler();
    ~CThrottler();

    ULONG           m_cRef;
    ULONG           m_cExternalRef;

    CSyncMgrNode    *m_pSyncMgrs;
    CUpdateItem     *m_pItemsHead;
    CUpdateItem     *m_pItemsTail;
    CUpdateItem     *m_updateQueue[MAX_RUNNING_ITEMS];
    int             m_nUpdating;
    HWND            m_hwndThrottler;
    HWND            m_hwndParent;

    BOOL            m_fAbortingAll:1;
    BOOL            m_fUserIsIdle:1;
    BOOL            m_fFillingTheQueue:1;
    BOOL            m_fForcedGlobalOnline:1;
    BOOL            m_fAutoDialed:1;
    BOOL            m_fAutoCacheSizePending:1;

    DWORD           m_dwMaxAutoCacheSize;
    DWORD           m_dwAutoCacheSizeIncrease;
    int             m_nAutoCacheSizeTimesAsked;

    typedef enum {NH_UPDATEBEGIN, NH_UPDATEPROGRESS, NH_UPDATEEND, NH_REPORTERROR};

    HRESULT AddItemToListTail(CUpdateItem *pAddItem);
    HRESULT RemoveItemFromList(CUpdateItem *pRemoveItem, BOOL fDelete);

    void OnIdleBegin();
    void OnIdleEnd();

    BOOL IsQueueSlotFree() { return m_nUpdating < ARRAYSIZE(m_updateQueue); }
    int GetFreeQueueSlot();
    int GetCookieIndexInQueue(const SUBSCRIPTIONCOOKIE *pCookie);
    void FillTheQueue();
    
    void FailedUpdate(HRESULT hr, const SUBSCRIPTIONCOOKIE *pCookie);
    void RunItem(int queueSlot, CUpdateItem *pUpdateItem);
    HRESULT CanScheduledItemRun(ISubscriptionItem *pSubsItem);

    STDMETHODIMP ActuallyAbortItems(DWORD dwNumCookies, const SUBSCRIPTIONCOOKIE *pCookies);
    STDMETHODIMP ActuallyAbortAll();

    HRESULT DoAbortItem(CUpdateItem *pUpdateItem);

    HRESULT CreateThrottlerWnd();

    HRESULT NotifyHandlers(int idCmd, const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, ...);
    HRESULT FindCookie(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        CUpdateItem **ppUpdateItem);
};

#include "offsync.h"

struct CSyncMgrNode
{
    CSyncMgrNode(COfflineSync *pOfflineSync, CSyncMgrNode *pNext) :
        m_pOfflineSync(pOfflineSync), 
        m_pNext(pNext) 
    {
        ASSERT(NULL != m_pOfflineSync);
    }

    ~CSyncMgrNode()
    {
        SAFERELEASE(m_pOfflineSync);
    }

    COfflineSync        *m_pOfflineSync;
    CSyncMgrNode        *m_pNext;
};

struct CUpdateItem
{
    CUpdateItem(const SUBSCRIPTIONCOOKIE& cookie,
                DWORD dwRunState) :
        m_cookie(cookie),
        m_dwRunState(dwRunState)
    {
        ASSERT(NULL == m_pNext);
        ASSERT(NULL == m_pSubsAgentCtl);
        ASSERT(CLSID_NULL != m_cookie);
        m_nMax = 128;
    }

    ~CUpdateItem()
    {
        SAFERELEASE(m_pSubsAgentCtl);
    }

    ISubscriptionAgentControl   *m_pSubsAgentCtl;
    SUBSCRIPTIONCOOKIE          m_cookie;
    DWORD                       m_dwRunState;
    CUpdateItem                 *m_pNext;
    LONG                        m_nMax;
};

#endif _throttle_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\throttle.cpp ===
#include "private.h"
#include "throttle.h"
#include "subsmgrp.h"

#include <mluisupp.h>

#define TF_THISMODULE TF_THROTTLER

const int MAX_AUTOCACHESIZE_ASK = 2;
const int MIN_CACHE_INCREASE = 1024; // in KB

// Strings for cache restrictions
const TCHAR c_szKeyRestrict[] = TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel");
const TCHAR c_szCache[] = TEXT("Cache");         

CThrottler  *CThrottler::s_pThrottler = NULL;

const CFactoryData CThrottler::s_ThrottlerFactoryData = 
{
    &CLSID_SubscriptionThrottler, CreateInstance, 0
};

#ifdef DEBUG
void DUMPITEM(CHAR *pszMsg, const SUBSCRIPTIONCOOKIE *pCookie)
{
    ISubscriptionItem *psi;
    
    if (SUCCEEDED(SubscriptionItemFromCookie(FALSE, pCookie, &psi)))
    {
        BSTR bstrName;
        if (SUCCEEDED(ReadBSTR(psi, c_szPropName, &bstrName)))
        {
            TraceMsgA(TF_THISMODULE, "%s: %S", pszMsg, bstrName);
            SysFreeString(bstrName);
        }
        psi->Release();
    }
}

#else

#define DUMPITEM(pszMsg, pCookie)

#endif

// dwSyncFlags has 8 bits of enum (EVENTMASK) and the rest is flags
inline BOOL IsSyncEvent(DWORD dwSyncFlags, DWORD dwSyncEvent)
{
    return (dwSyncFlags & SYNCMGRFLAG_EVENTMASK) == dwSyncEvent;
}

inline BOOL IsSyncEventFlag(DWORD dwSyncFlags, DWORD dwSyncEvent)
{
    return (dwSyncFlags & dwSyncEvent) != 0;
}

inline BOOL IsIgnoreIdleSyncEvent(DWORD dwSyncFlags)
{
    return !IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_IDLE);
/*
    return IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_CONNECT) ||
           IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_PENDINGDISCONNECT) ||
           IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_MANUAL) ||
           IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_INVOKE);
*/
}

inline BOOL IsScheduleSyncEvent(DWORD dwSyncFlags)
{
    return IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_SCHEDULED) ||
           IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_IDLE);
}

class CThrottlerProxy : public ISubscriptionThrottler
{
  
public:
    CThrottlerProxy(CThrottler *pThrottler)
    {
        m_cRef = 1;
        m_pThrottler = pThrottler;

        m_pThrottler->ExternalAddRef();
    }

    STDMETHODIMP QueryInterface(REFIID riid, void **punk)
    {
        if ((riid == IID_IUnknown) || (riid == IID_ISubscriptionThrottler))
        {
            *punk = (ISubscriptionThrottler *)this;
            AddRef();
            return S_OK;
        }
        else
        {
            *punk = NULL;
            return E_NOINTERFACE;
        }
    }
    
    STDMETHODIMP_(ULONG) AddRef()
    { 
        return ++m_cRef;
    }
    
    STDMETHODIMP_(ULONG) Release()
    {
        if (--m_cRef == 0)
        {
            delete this;
            return 0;
        }

        return m_cRef;
    }

    STDMETHODIMP GetSubscriptionRunState( 
        /* [in] */ DWORD dwNumCookies,
        /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies,
        /* [size_is][out] */ DWORD *pdwRunState)
    {
        return m_pThrottler->GetSubscriptionRunState(dwNumCookies, pCookies, pdwRunState);
    }
    
    STDMETHODIMP AbortItems( 
        /* [in] */ DWORD dwNumCookies,
        /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
    {
        return m_pThrottler->AbortItems(dwNumCookies, pCookies);
    }
    
    STDMETHODIMP AbortAll()
    {
        return m_pThrottler->AbortAll();
    }

private:
    ULONG       m_cRef;
    CThrottler  *m_pThrottler;
    
    ~CThrottlerProxy()
    {
        m_pThrottler->ExternalRelease();
    }

};

HRESULT CThrottler::CreateInstance(IUnknown *punkOuter, IUnknown **ppunk)
{
    HRESULT hr;

    ASSERT(NULL == punkOuter);
    ASSERT(NULL != ppunk);

    if (NULL != CThrottler::s_pThrottler)
    {
        *ppunk = new CThrottlerProxy(CThrottler::s_pThrottler);

        if (NULL != *ppunk) 
        {
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        TraceMsg(TF_ALWAYS, "UNEXPECTED ERROR: Failed to attached to throttler in CreateInstance");
        hr = E_UNEXPECTED;
    }

    return hr;
}

CThrottler::CThrottler()
{
    ASSERT(NULL == s_pThrottler);

    ASSERT(NULL == m_pItemsHead);
    ASSERT(NULL == m_pItemsTail);
    ASSERT(NULL == m_updateQueue[0]);

    //  APPCOMPAT - this is only until msidle is multi-client aware.
    IdleEnd();
    //m_fUserIsIdle = TRUE; //  TODO: need to determine this better
    IdleBegin(NULL);

    m_cRef = 1;
}

CThrottler::~CThrottler()
{
    DBG("Destroying Throttler");

    ASSERT(GetCurrentThreadId() == m_dwThreadId);

    IdleEnd();

    // Destroy window
    if (m_hwndThrottler)
    {
        SetWindowLongPtr(m_hwndThrottler, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndThrottler);
        m_hwndThrottler = NULL;
    }

    s_pThrottler = NULL;

    RevokeClassObject();
}

HRESULT CThrottler::RevokeClassObject()
{
    HRESULT hr;
    
    if (m_dwRegister)
    {
        hr = CoRevokeClassObject(m_dwRegister);
        m_dwRegister = 0;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT /* static */ CThrottler::GetThrottler(CThrottler **ppThrottler)
{
    HRESULT hr = S_OK;
    
    ASSERT(NULL != ppThrottler);

    if (NULL != ppThrottler)
    {
        *ppThrottler = NULL;

        //  If there is no throttler create a new one
        if (NULL == s_pThrottler)
        {
            DBG("Creating new throttler in GetThrottler");

            s_pThrottler = new CThrottler;
            if (NULL != s_pThrottler)
            {
                IClassFactory *pcf = new CClassFactory(&s_ThrottlerFactoryData);
                if (NULL != pcf)
                {
                    HRESULT hrRegister = CoRegisterClassObject(CLSID_SubscriptionThrottler, 
                                                               pcf, 
                                                               CLSCTX_LOCAL_SERVER, 
                                                               REGCLS_MULTIPLEUSE, 
                                                               &s_pThrottler->m_dwRegister);
                    if (FAILED(hrRegister))
                    {
                        TraceMsg(TF_ALWAYS, "CoRegisterClassObject failed - other processes can't talk to us!");
                    }
                    pcf->Release();
                }
                *ppThrottler = s_pThrottler;
#ifdef DEBUG
                s_pThrottler->m_dwThreadId = GetCurrentThreadId();
#endif
            }
            else
            {
                DBG("Failed to create Throttler class factory");
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            //  Attach to existing throttler
            ASSERT(GetCurrentThreadId() == s_pThrottler->m_dwThreadId);
            s_pThrottler->AddRef();
            *ppThrottler = s_pThrottler;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

void CThrottler::OnIdleStateChange(DWORD dwState)
{
    if (NULL != s_pThrottler)
    {
        switch(dwState)
        {
            case STATE_USER_IDLE_BEGIN:
                DBG("OnIdleStateChange: Idle Begin");
            #ifdef DEBUG
                LogEvent(TEXT("Idle state begins"));
            #endif

                s_pThrottler->OnIdleBegin();
                break;

            case STATE_USER_IDLE_END:
                DBG("OnIdleStateChange: Idle End");
            #ifdef DEBUG
                LogEvent(TEXT("Idle state ends"));
            #endif

                s_pThrottler->OnIdleEnd();
                break;
        }
    }
}

void CThrottler::OnIdleBegin()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    m_fUserIsIdle = TRUE;
    FillTheQueue();
}

void CThrottler::OnIdleEnd()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    m_fUserIsIdle = FALSE;

    for (int i = 0; i < ARRAYSIZE(m_updateQueue); i++)
    {
        if ((NULL != m_updateQueue[i]) && 
            (m_updateQueue[i]->m_dwRunState & RS_SUSPENDONIDLE))
        {
            DUMPITEM("Suspending in CThrottler::OnIdleEnd", &m_updateQueue[i]->m_cookie);

            ISubscriptionAgentControl *pSubsAgentCtl;
            CUpdateItem *pUpdateItem = m_updateQueue[i];
           
            pSubsAgentCtl = m_updateQueue[i]->m_pSubsAgentCtl;

            m_updateQueue[i]->m_dwRunState &= ~RS_UPDATING;
            m_updateQueue[i]->m_dwRunState |= RS_SUSPENDED;

            m_updateQueue[i] = NULL;

            ASSERT(NULL != pSubsAgentCtl);

            if (SUCCEEDED(pSubsAgentCtl->PauseUpdate(0)))
            {
                WCHAR wszMsg[256];

                MLLoadStringW(IDS_UPDATE_PAUSED, wszMsg, ARRAYSIZE(wszMsg));
                NotifyHandlers(NH_UPDATEPROGRESS, &pUpdateItem->m_cookie, -1,
                               -1, -1, WC_INTERNAL_S_PAUSED, wszMsg);
            }
        }
    }

    FillTheQueue();
}

STDMETHODIMP CThrottler::QueryInterface(REFIID riid, void **ppv)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if (NULL == ppv)
    {
        return E_INVALIDARG;
    }

    if ((IID_IUnknown == riid) || (IID_ISubscriptionAgentEvents == riid))
    {
        *ppv = (ISubscriptionAgentEvents *)this;
    }
    else if (IID_ISubscriptionThrottler == riid)
    {
        *ppv = (ISubscriptionThrottler *)this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    
    return S_OK;
}


ULONG CThrottler::ExternalAddRef()
{
    AddRef();
    
    return ++m_cExternalRef;
}

ULONG CThrottler::ExternalRelease()
{
    ULONG cRef = --m_cExternalRef;

    Release();

    return cRef;
}

STDMETHODIMP_(ULONG) CThrottler::AddRef()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CThrottler::Release()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if (--m_cRef == 0)
    {
        delete this;
        return 0;
    }

    return m_cRef;
}

HRESULT CThrottler::NotifyHandlers(int idCmd, const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, ...)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    va_list va;
    long lSizeDownloaded = -1;
    long lProgressCurrent = -1;
    long lProgressMax = -1;
    HRESULT hrParam = E_UNEXPECTED;
    LPCWSTR wszParam = NULL;

    va_start(va, pSubscriptionCookie);

    //  First extract args
    switch (idCmd)
    {
        case NH_UPDATEBEGIN:
            //  Nothing to do for now
            break;

        case NH_UPDATEPROGRESS:
            lSizeDownloaded = va_arg(va, long);
            lProgressCurrent = va_arg(va, long);
            lProgressMax = va_arg(va, long);
            hrParam = va_arg(va, HRESULT);
            wszParam = va_arg(va, LPCWSTR);
            break;

        case NH_UPDATEEND:
            lSizeDownloaded = va_arg(va, long);
            hrParam = va_arg(va, HRESULT);
            wszParam = va_arg(va, LPCWSTR);
            break;

        case NH_REPORTERROR:
            hrParam = va_arg(va, HRESULT);
            wszParam = va_arg(va, LPCWSTR);
            break;

        default:
            ASSERT(0);  //  Don't know what to do
            hr = E_UNEXPECTED;
            break;
    }

    //  Now loop
    HRESULT hrTemp = S_OK;
    CSyncMgrNode *pSyncMgrNode = m_pSyncMgrs;

    while (pSyncMgrNode)
    {
        COfflineSync *pOfflineSync = pSyncMgrNode->m_pOfflineSync;
        pSyncMgrNode = pSyncMgrNode->m_pNext;

        switch (idCmd)
        {
            case NH_UPDATEBEGIN:
                hrTemp = pOfflineSync->UpdateBegin(pSubscriptionCookie);
                break;

            case NH_UPDATEPROGRESS:
                hrTemp = pOfflineSync->UpdateProgress(pSubscriptionCookie, 
                                                      lSizeDownloaded, 
                                                      lProgressCurrent, 
                                                      lProgressMax, 
                                                      hrParam, 
                                                      wszParam);

                break;

            case NH_UPDATEEND:
                hrTemp = pOfflineSync->UpdateEnd(pSubscriptionCookie, 
                                                 lSizeDownloaded, 
                                                 hrParam, 
                                                 wszParam);
                break;

            case NH_REPORTERROR:
                hrTemp = pOfflineSync->ReportError(pSubscriptionCookie, 
                                                hrParam, 
                                                wszParam);
                break;
        }

        if (FAILED(hrTemp))
        {
            hr = hrTemp;
        }
    }

    va_end(va);

    return hr;
}

// ISubscriptionAgentEvents members
STDMETHODIMP CThrottler::UpdateBegin(const SUBSCRIPTIONCOOKIE *pSubscriptionCookie)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;
    CUpdateItem *pUpdateItem;

    hr = FindCookie(pSubscriptionCookie, &pUpdateItem);

    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        DUMPITEM("CThrottler::UpdateBegin", pSubscriptionCookie);
        pUpdateItem->m_dwRunState &= ~(RS_READY | RS_SUSPENDED);
        pUpdateItem->m_dwRunState |= RS_UPDATING;

        hr = NotifyHandlers(NH_UPDATEBEGIN, pSubscriptionCookie);
    }

    return hr;
}

STDMETHODIMP CThrottler::UpdateProgress(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        long lProgressCurrent,
        long lProgressMax,
        HRESULT hrStatus,
        LPCWSTR wszStatus)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    CUpdateItem *pUpdateItem;

    //  TODO:
    //  Adjust the max to fool syncmgr
    if (SUCCEEDED(FindCookie(pSubscriptionCookie, &pUpdateItem)))
    {
        if ((lProgressMax < 0) || (lProgressMax <= lProgressCurrent))
        {
            if (pUpdateItem->m_nMax <= lProgressCurrent)
            {
                pUpdateItem->m_nMax = (lProgressCurrent * 3) / 2;
            }

            lProgressMax = pUpdateItem->m_nMax;
        }
    }

    hr = NotifyHandlers(NH_UPDATEPROGRESS, pSubscriptionCookie, lSizeDownloaded,
                            lProgressCurrent, lProgressMax, hrStatus, wszStatus);
    return hr;
}

STDMETHODIMP CThrottler::UpdateEnd(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie,
        long lSizeDownloaded,
        HRESULT hrResult,
        LPCWSTR wszResult)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;
    CUpdateItem *pUpdateItem;
    SUBSCRIPTIONCOOKIE cookie = *pSubscriptionCookie;

    hr = FindCookie(pSubscriptionCookie, &pUpdateItem);

    if (SUCCEEDED(hr))
    {
        DUMPITEM("CThrottler::UpdateEnd", pSubscriptionCookie);

        pUpdateItem->m_dwRunState &= ~(RS_READY | RS_SUSPENDED | RS_UPDATING | RS_SUSPENDONIDLE);
        pUpdateItem->m_dwRunState |= RS_COMPLETED;

        RemoveItemFromList(pUpdateItem, TRUE);

        //  ************************************************************************
        //  Don't use anything that could have come from pUpdateItem after this 
        //  including the pSubscriptionCookie above which came from an agent which
        //  probably no longer exists!
        //  (actually, the agent keeps itself alive until this call returns)
        //  ************************************************************************

    }

    hr = NotifyHandlers(NH_UPDATEEND, &cookie,
                        lSizeDownloaded, hrResult, wszResult);

    FireSubscriptionEvent(SUBSNOTF_SYNC_STOP, &cookie);

    FillTheQueue();

    return hr;
}

STDMETHODIMP CThrottler::ReportError(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
        HRESULT hrError, 
        LPCWSTR wszError)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    if (INET_E_AGENT_EXCEEDING_CACHE_SIZE == hrError)
    {
        // Agent is notifying us that they're about to exceed the cache size.
        hr = AutoCacheSizeRequest(pSubscriptionCookie);
    }
    else
        hr = NotifyHandlers(NH_REPORTERROR, pSubscriptionCookie, hrError, wszError);

    return hr;
}

STDMETHODIMP CThrottler::GetSubscriptionRunState( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies,
    /* [size_is][out] */ DWORD *pdwRunState)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
  
    if ((0 == dwNumCookies) ||
        (NULL == pCookies) ||
        (NULL == pdwRunState))
    {
        return E_INVALIDARG;
    }

    for (DWORD i = 0; i < dwNumCookies; i++, pCookies++, pdwRunState++)
    {
        CUpdateItem *pUpdateItem;

        if (SUCCEEDED(FindCookie(pCookies, &pUpdateItem)))
        {
            *pdwRunState = pUpdateItem->m_dwRunState;
        }
        else
        {
            *pdwRunState = 0;
        }
    }

    return S_OK;
}

// DoAbortItem will cause the CThrottler to get released if the last running
//  agent is aborted (Agent notifies it's done, SyncMgr releases throttler,
//   then agent releases throttler)
HRESULT CThrottler::DoAbortItem(CUpdateItem *pUpdateItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    ASSERT(((pUpdateItem->m_dwRunState & (RS_UPDATING | RS_SUSPENDED)) && 
            (NULL != pUpdateItem->m_pSubsAgentCtl))
           ||
           (NULL == pUpdateItem->m_pSubsAgentCtl));

    if ((pUpdateItem->m_dwRunState & (RS_UPDATING | RS_SUSPENDED)) &&
        (NULL != pUpdateItem->m_pSubsAgentCtl))
    {
        DUMPITEM("CThrottler::DoAbortItem with existing Agent", &pUpdateItem->m_cookie);
        hr = pUpdateItem->m_pSubsAgentCtl->AbortUpdate(0);
    }
    else
    {
        WCHAR wszMsg[256];

        MLLoadStringW(IDS_STATUS_ABORTED, wszMsg, ARRAYSIZE(wszMsg));

        DUMPITEM("CThrottler::DoAbortItem with no Agent", &pUpdateItem->m_cookie);
        
        ReportThrottlerError(&pUpdateItem->m_cookie, E_ABORT, wszMsg);
        hr = UpdateEnd(&pUpdateItem->m_cookie, 0, E_ABORT, wszMsg);
    }

    return hr;
}

STDMETHODIMP CThrottler::AbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    if ((0 == dwNumCookies) ||
        (NULL == pCookies))
    {
        return E_INVALIDARG;
    }

    if (FAILED(CreateThrottlerWnd()))
        return E_FAIL;

    hr = S_OK;

    void *pItem = MemAlloc(LMEM_FIXED, dwNumCookies * sizeof(SUBSCRIPTIONCOOKIE));
    if (pItem)
    {

#ifdef DEBUG
        for (DWORD i = 0; i < dwNumCookies; i++)
        {
            DUMPITEM("Aborting in CThrottler::AbortItems", &pCookies[i]);
        }
#endif

        memcpy(pItem, pCookies, dwNumCookies * sizeof(SUBSCRIPTIONCOOKIE));
        PostMessage(m_hwndThrottler, WM_THROTTLER_ABORTITEM, (WPARAM)dwNumCookies, (LPARAM)pItem);
    }
    else
    {
        DBG_WARN("Memory alloc failed in CThrottler::AbortItems");
        hr = S_FALSE;
    }
    return hr;
}
        
STDMETHODIMP CThrottler::ActuallyAbortItems( 
    /* [in] */ DWORD dwNumCookies,
    /* [size_is][in] */ const SUBSCRIPTIONCOOKIE *pCookies)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;

    if ((0 == dwNumCookies) ||
        (NULL == pCookies))
    {
        return E_INVALIDARG;
    }

    hr = S_OK;

    // DoAbortItem will cause the CThrottler to get released if the last
    //  running agent is aborted. Protect against that.
    AddRef();

    for (DWORD i = 0; i < dwNumCookies; i++, pCookies++)
    {
        HRESULT hrItem;
        CUpdateItem *pUpdateItem;

        hrItem = FindCookie(pCookies, &pUpdateItem);
        if (SUCCEEDED(hrItem))
        {
            hrItem = DoAbortItem(pUpdateItem);

            //  ************************************************************************
            //  pUpdateItem is no longer valid!
            //  ************************************************************************
        }

        if (FAILED(hrItem))
        {
            hr = S_FALSE;
        }
    }

    Release();

    return hr;
}

HRESULT CThrottler::CreateThrottlerWnd()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if (!m_hwndThrottler)
    {
        WNDCLASS wc;

        wc.style = 0;
        wc.lpfnWndProc = CThrottler::ThrottlerWndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = g_hInst;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH)NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = THROTTLER_WNDCLASS;

        RegisterClass(&wc);

        m_hwndThrottler = CreateWindow(THROTTLER_WNDCLASS, TEXT("YO"), WS_OVERLAPPED,
                    CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                    NULL, NULL, g_hInst, (LPVOID)this);

        if (NULL == m_hwndThrottler)
        {
            DBG_WARN("CThrottler CreateWindow failed");
            return E_FAIL;
        }
    }

    return S_OK;
}

LRESULT CThrottler::ThrottlerWndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    CThrottler *pThis = (CThrottler*) GetWindowLongPtr(hWnd, GWLP_USERDATA);

    // Validate pThis
#ifdef DEBUG
    if (pThis && IsBadWritePtr(pThis, sizeof(*pThis)))
    {
        TraceMsg(TF_THISMODULE|TF_WARNING,
            "Invalid 'this' in ThrottlerWndProc (0x%08x) - already destroyed?", pThis);
    }
    if (pThis)
    {
        ASSERT(GetCurrentThreadId() == pThis->m_dwThreadId);
        ASSERT(GetCurrentThreadId() == GetWindowThreadProcessId(hWnd, NULL));
    }
#endif

    switch (Msg)
    {
        case WM_CREATE :
        {
            LPCREATESTRUCT pcs = (LPCREATESTRUCT)lParam;

            if (!pcs || !(pcs->lpCreateParams))
            {
                DBG_WARN("Invalid param ThrottlerWndProc Create");
                return -1;
            }
            SetWindowLongPtr(hWnd, GWLP_USERDATA, (LONG_PTR) pcs->lpCreateParams);
            return 0;
        }

        case WM_THROTTLER_ABORTALL:
            if (pThis)
                pThis->ActuallyAbortAll();
            break;

        case WM_THROTTLER_ABORTITEM:
            if (pThis)
                pThis->ActuallyAbortItems((ULONG) wParam, (SUBSCRIPTIONCOOKIE*) lParam);
            MemFree((HLOCAL)lParam);
            break;

        case WM_THROTTLER_AUTOCACHESIZE_ASK:
            if (pThis)
                pThis->AutoCacheSizeAskUser((DWORD)lParam);
            break;

        default:
            return DefWindowProc(hWnd, Msg, wParam, lParam);
    }

    return 0;
}

STDMETHODIMP CThrottler::AbortAll()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if (FAILED(CreateThrottlerWnd()))
        return E_FAIL;

    DBG("Aborting all items");

    PostMessage(m_hwndThrottler, WM_THROTTLER_ABORTALL, 0, 0);

    return S_OK;
}

STDMETHODIMP CThrottler::ActuallyAbortAll()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    CUpdateItem *pItem = m_pItemsHead;

    if (FALSE == m_fAbortingAll)
    {
        m_fAbortingAll = TRUE;

        while (pItem)
        {
            CUpdateItem *pUpdateItem = pItem;

            //  Move forward now since this item should get yanked!
            pItem = pItem->m_pNext;

            if (FAILED(DoAbortItem(pUpdateItem)))
            {
                hr = S_FALSE;
            }
        }
        m_fAbortingAll = FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CThrottler::Advise(COfflineSync *pOfflineSync)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr;
    CSyncMgrNode *pSyncMgrNode;

    ASSERT(NULL != pOfflineSync);

#ifdef DEBUG
    pSyncMgrNode = m_pSyncMgrs;

    while (pSyncMgrNode)
    {
        if (pSyncMgrNode->m_pOfflineSync == pOfflineSync)
        {
            ASSERT(0);      //  Shouldn't advise more than once!
        }
        pSyncMgrNode = pSyncMgrNode->m_pNext;
    }
 #endif

    ASSERT(!m_hwndParent || (m_hwndParent == pOfflineSync->GetParentWindow()));

    m_hwndParent = pOfflineSync->GetParentWindow();

    pSyncMgrNode = new CSyncMgrNode(pOfflineSync, m_pSyncMgrs);

    if (NULL != pSyncMgrNode)
    {
        pOfflineSync->AddRef();
        m_pSyncMgrs = pSyncMgrNode;
        hr = S_OK;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CThrottler::Unadvise(COfflineSync *pOfflineSync)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = E_FAIL;
    CSyncMgrNode *pSyncMgrNode;
    CSyncMgrNode **ppSyncMgrPrev;

    ASSERT(NULL != pOfflineSync);

    pSyncMgrNode = m_pSyncMgrs;
    ppSyncMgrPrev = &m_pSyncMgrs;

    while (pSyncMgrNode)
    {
        if (pSyncMgrNode->m_pOfflineSync == pOfflineSync)
        {
            *ppSyncMgrPrev = pSyncMgrNode->m_pNext;
            delete pSyncMgrNode;
            hr = S_OK;
            break;
        }
        ppSyncMgrPrev = &pSyncMgrNode->m_pNext;
        pSyncMgrNode = pSyncMgrNode->m_pNext;
    }

    ASSERT(SUCCEEDED(hr));  //  This is internal goo so should not fail!

    if (NULL == m_pSyncMgrs)
    {
        //  Everyone has lost interest in us...
        RevokeClassObject();
        s_pThrottler = NULL;

        while (m_cExternalRef > 0)
        {
            TraceMsg(TF_WARNING, "CThrottle::Unadvise m_cExternalRef = %d", m_cExternalRef);
            MSG msg;
            
            if (PeekMessage(&msg, NULL, 0, 0, TRUE))
            {
                DispatchMessage(&msg);
            }
        }
    }
    
    return hr;
}

int CThrottler::GetCookieIndexInQueue(const SUBSCRIPTIONCOOKIE *pCookie)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    int index = -1;
    
    for (int i = 0; i < ARRAYSIZE(m_updateQueue); i++)
    {
        if ((NULL != m_updateQueue[i]) && (m_updateQueue[i]->m_cookie == *pCookie))
        {   
            index = i;
            break;
        }
    }

    return index;
}

void CThrottler::FailedUpdate(HRESULT hr, const SUBSCRIPTIONCOOKIE *pCookie)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    WCHAR wszMsg[256];
    int resID;

    switch (hr)
    {
        case INET_E_SCHEDULED_UPDATES_DISABLED:
            resID = IDS_SCHEDULED_UPDATES_DISABLED;
            break;
            
        case INET_E_SCHEDULED_UPDATES_RESTRICTED:
            resID = IDS_SCHEDULED_UPDATES_RESTRICTED;
            break;
            
        case INET_E_SCHEDULED_UPDATE_INTERVAL:
            resID = IDS_SCHEDULED_UPDATE_INTERVAL;
            break;
            
        case INET_E_SCHEDULED_EXCLUDE_RANGE:
            resID = IDS_SCHEDULED_EXCLUDE_RANGE;
            break;
            
        default:
            resID = IDS_CRAWL_STATUS_NOT_OK;
            break;
    }

    MLLoadStringW(resID, wszMsg, ARRAYSIZE(wszMsg));
    ReportThrottlerError(pCookie, hr, wszMsg);
    UpdateEnd(pCookie, 0, hr, wszMsg);
}

void CThrottler::RunItem(int queueSlot, CUpdateItem *pUpdateItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr; 

    ASSERT(NULL == m_updateQueue[queueSlot]);

    m_updateQueue[queueSlot] = pUpdateItem;

    if (pUpdateItem->m_dwRunState & RS_SUSPENDED)
    {
        DUMPITEM("Resuming suspended item in CThrottler::RunItem", &pUpdateItem->m_cookie);
        ASSERT(NULL != pUpdateItem->m_pSubsAgentCtl);

        pUpdateItem->m_dwRunState |= RS_UPDATING;
        pUpdateItem->m_dwRunState &= ~RS_SUSPENDED;
        hr = pUpdateItem->m_pSubsAgentCtl->ResumeUpdate(0);

        if (SUCCEEDED(hr))
        {
            WCHAR wszMsg[256];

            MLLoadStringW(IDS_UPDATE_RESUMING, wszMsg, ARRAYSIZE(wszMsg));
            NotifyHandlers(NH_UPDATEPROGRESS, &pUpdateItem->m_cookie, -1,
                           -1, -1, WC_INTERNAL_S_RESUMING, wszMsg);
        }
    }
    else
    {
        ISubscriptionItem *psi;

        hr = SubscriptionItemFromCookie(FALSE, &pUpdateItem->m_cookie, &psi);


        if (SUCCEEDED(hr))
        {
            SUBSCRIPTIONITEMINFO sii;
            
            sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);
            hr = psi->GetSubscriptionItemInfo(&sii);
            if (SUCCEEDED(hr))
            {
                hr = CoCreateInstance(sii.clsidAgent, 
                                      NULL, 
                                      CLSCTX_INPROC_SERVER, 
                                      IID_ISubscriptionAgentControl, 
                                      (void**)&pUpdateItem->m_pSubsAgentCtl);

                if (SUCCEEDED(hr))
                {
                    DUMPITEM("Running item in CThrottler::RunItem", &pUpdateItem->m_cookie);
                    hr = pUpdateItem->m_pSubsAgentCtl->StartUpdate(psi, 
                                (ISubscriptionAgentEvents *)this);

                    FireSubscriptionEvent(SUBSNOTF_SYNC_START, &pUpdateItem->m_cookie);

                }
                else
                {
                    DBG_WARN("CoCreate Agent FAILED in CThrottler::RunItem");
                }
            }
            psi->Release();
        }
        else
        {
            DBG_WARN("SubscriptionItemFromCookie FAILED in CThrottler::RunItem");
        }
    }

    if (FAILED(hr))
    {
        FailedUpdate(hr, &pUpdateItem->m_cookie);
    }
}

int CThrottler::GetFreeQueueSlot()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    int index = -1;
    
    for (int i = 0; i < ARRAYSIZE(m_updateQueue); i++)
    {
        if (NULL == m_updateQueue[i])
        {   
            index = i;
            break;
        }
    }

    return index;
}

void CThrottler::FillTheQueue()
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    if ((FALSE == m_fFillingTheQueue) &&        // avoid re-entrancy
        (FALSE == m_fAbortingAll) &&            // avoid re-entrancy
        (FALSE == m_fAutoCacheSizePending))     // we have a dialog up for the user
    {
        m_fFillingTheQueue = TRUE;

        CUpdateItem *pNextItem = m_pItemsHead;
        CUpdateItem *pItem;

        while (NULL != pNextItem)
        {
            pItem = pNextItem;

            //  Move ahead since this item may not be here 
            //  if we run it and it fails

            pNextItem = pNextItem->m_pNext;

            if (!(pItem->m_dwRunState & (RS_COMPLETED | RS_UPDATING)))
            {
                int freeSlot = GetFreeQueueSlot();

                if ((freeSlot >= 0) &&
                    (m_fUserIsIdle || (!(pItem->m_dwRunState & RS_SUSPENDONIDLE))))
                {
                    RunItem(freeSlot, pItem);
                }
                else 
                {
                    //  If we didn't run it then let's make sure the UI reflects the current
                    //  state properly

                    HRESULT hrStatus;
                    WCHAR wszMsg[256];

                    if ((pItem->m_dwRunState & RS_SUSPENDONIDLE) && (!m_fUserIsIdle))
                    {
                        MLLoadStringW(IDS_UPDATE_PAUSED, wszMsg, ARRAYSIZE(wszMsg));
                        hrStatus = WC_INTERNAL_S_PAUSED;
                    }
                    else
                    {
                        StrCpyNW(wszMsg, L" ", ARRAYSIZE(wszMsg));  //  Don't say it, I know what you're thinking...
                                                                    //  ...if we don't do this, then the status
                                                                    //  text won't change.
                        hrStatus = WC_INTERNAL_S_PENDING;
                    }

                    NotifyHandlers(NH_UPDATEPROGRESS, &pItem->m_cookie, -1,
                                   -1, -1, hrStatus, wszMsg);
                }
            }
        }

        m_fFillingTheQueue = FALSE;
    }
}

HRESULT CThrottler::AddItemToListTail(CUpdateItem *pAddItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    
    ASSERT(NULL != pAddItem);

    if (NULL != pAddItem)
    {
        if (NULL == m_pItemsTail)
        {
            //  Nothing in the list
            ASSERT(NULL == m_pItemsHead);
            m_pItemsHead = pAddItem;
        }
        else
        {
            m_pItemsTail->m_pNext = pAddItem;
        }
        m_pItemsTail = pAddItem;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    ASSERT(NULL != m_pItemsHead);
    ASSERT(NULL != m_pItemsTail);
    ASSERT(NULL == m_pItemsTail->m_pNext);

    ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT CThrottler::RemoveItemFromList(CUpdateItem *pRemoveItem, BOOL fDelete)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = E_UNEXPECTED;
    CUpdateItem *pItem = m_pItemsHead;
    CUpdateItem *pPrevItem = NULL;

    ASSERT(NULL != pRemoveItem);
    ASSERT(NULL != m_pItemsHead);
    ASSERT(NULL != m_pItemsTail);

    if (NULL != pRemoveItem)
    {
        int queueIndex = GetCookieIndexInQueue(&pRemoveItem->m_cookie);

        if (queueIndex >= 0)
        {
            m_updateQueue[queueIndex] = NULL;
        }
        
        while (pItem)
        {
            if (pItem == pRemoveItem)
            {
                if (NULL != pPrevItem)
                {
                    //  Removing beyond the head
                    pPrevItem->m_pNext = pItem->m_pNext;
                }
                else
                {
                    //  Removing the head
                    m_pItemsHead = pItem->m_pNext;
                }

                //  Now fix the tail
                if (m_pItemsTail == pRemoveItem)
                {
                    m_pItemsTail = pPrevItem;
                }
                hr = S_OK;
                break;
            }
            pPrevItem = pItem;
            pItem = pItem->m_pNext;
        }
        if (fDelete)
        {
            delete pRemoveItem;
        }
    }

    ASSERT(((NULL != m_pItemsHead) && (NULL != m_pItemsTail) && (NULL == m_pItemsTail->m_pNext)) ||
           ((NULL == m_pItemsHead) && (NULL == m_pItemsTail)));
    ASSERT(SUCCEEDED(hr));

    // If we have just removed our last item from the list, check to see if we forced
    //  global online mode or autodialed and fix up if so.
    if ((NULL == m_pItemsHead) && (m_fForcedGlobalOnline || m_fAutoDialed))
    {
        if (m_fForcedGlobalOnline)
        {
            SetGlobalOffline(TRUE);
            m_fForcedGlobalOnline = FALSE;
            m_fAutoDialed = FALSE;
        }
        else
        {
            ASSERT(m_fAutoDialed);
            InternetAutodialHangup(0);
            m_fAutoDialed=FALSE;
        }
    }

    return hr;
}

HRESULT CThrottler::CanScheduledItemRun(ISubscriptionItem *pSubsItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    //  If this item is running as a result of a schedule invocation, then
    //  we need to check time/range restrictions.
    HRESULT hr = S_OK;
    const TCHAR c_szNoScheduledUpdates[] = TEXT("NoScheduledUpdates");
    DWORD dwData;
    DWORD cbData = sizeof(dwData);

    //  First check if the user has disabled scheduled updates in inetcpl.
    if ((ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szRegKey, 
        c_szNoScheduledUpdates, NULL, &dwData, &cbData))
        && dwData)
    {
        hr = INET_E_SCHEDULED_UPDATES_DISABLED;
    }

    if (SUCCEEDED(hr))
    {
        //  Check if admin has disabled scheduled updates altogether
        if (SHRestricted2W(REST_NoScheduledUpdates, NULL, 0))
        {
            hr = INET_E_SCHEDULED_UPDATES_RESTRICTED;
        }
    }

    if (SUCCEEDED(hr))
    {
        //  Check if admin has set a minimum update interval.
        DWORD dwMinUpdateInterval = SHRestricted2W(REST_MinUpdateInterval, NULL, 0);

        if (dwMinUpdateInterval > 0)
        {
            DATE dt;

            if (SUCCEEDED(ReadDATE(pSubsItem, c_szPropCompletionTime, &dt)))
            {
                SYSTEMTIME st;
                GetLocalTime(&st);

                CFileTime lastUpdate;
                CFileTime currentTime;

                VariantTimeToFileTime(dt, lastUpdate);
                SystemTimeToFileTime(&st, &currentTime);

                if ((currentTime - lastUpdate) < 
                    ((__int64)dwMinUpdateInterval * ONE_MINUTE_IN_FILETIME))
                {
                    hr = INET_E_SCHEDULED_UPDATE_INTERVAL;
                }
            }
        }
    }
    
    if (SUCCEEDED(hr))
    {
        DWORD dwBegin = SHRestricted2W(REST_UpdateExcludeBegin, NULL, 0);
        DWORD dwEnd = SHRestricted2W(REST_UpdateExcludeEnd, NULL, 0);

        //  Check if admin has specified a blackout time for scheduled updates.
        if (dwBegin && dwEnd)
        {
            SYSTEMTIME st;
            CFileTime ftNow,
                      ftBegin,
                      ftEnd;
            
            GetLocalTime(&st);

            SystemTimeToFileTime(&st, &ftNow);
            
            st.wSecond = 0;
            st.wMilliseconds = 0;
            
            st.wHour   = (WORD)dwBegin / 60;
            st.wMinute = (WORD)dwBegin % 60;
            SystemTimeToFileTime(&st, &ftBegin);
            
            st.wHour   = (WORD)dwEnd / 60;
            st.wMinute = (WORD)dwEnd % 60;
            SystemTimeToFileTime(&st, &ftEnd);

            //  if these values are normalized (ie. begin comes before end)
            if (ftBegin <= ftEnd)
            {
                //  Then just check to see if time now is between begin 
                //  and end.  (ie.  ftEnd >= ftNow >= ftBegin)
                if ((ftNow >= ftBegin) && (ftNow <= ftEnd))
                {
                    hr = INET_E_SCHEDULED_EXCLUDE_RANGE;
                }
            }
            else
            {
                //  Begin and end are not normalized.  So we check to see if
                //  now is before end or now is after begin.

                //  For example:
                //  Assuming begin is 6pm and end is 6am.  If now is 5 pm, the
                //  item should run.  If now is 10pm or 4am, it should not run.

                if ((ftNow <= ftEnd) || (ftNow >= ftBegin))
                {
                    hr = INET_E_SCHEDULED_EXCLUDE_RANGE;
                }
            }

        }
    }

    return hr;
}

HRESULT CThrottler::RunCookies(DWORD dwNumCookies, 
                               const SUBSCRIPTIONCOOKIE *pSubscriptionCookies, 
                               DWORD dwSyncFlags)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    DWORD i;
    CUpdateItem *pUpdateItem;
    DWORD nValidCookies;

    ASSERT(NULL != m_pSyncMgrs);

    ASSERT(0 != dwNumCookies);
    ASSERT(NULL != pSubscriptionCookies);

    if ((0 == dwNumCookies) || 
        (NULL == pSubscriptionCookies))
    {
        return E_INVALIDARG;
    }

    // Check for global offline mode.
    if (!m_fForcedGlobalOnline && IsGlobalOffline())
    {
        // Force global online mode so that our update will succeed.
        DBG("CThrottler::RunCookies; forcing global online mode");
        SetGlobalOffline(FALSE);
        m_fForcedGlobalOnline = TRUE;
    }

    if (IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_MANUAL) ||
        IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_INVOKE))
    {
        if (!InternetGetConnectedStateEx(NULL, NULL, 0, 0))
        {
            if (!InternetAutodial(INTERNET_AUTODIAL_FORCE_ONLINE, 0))
            {
                // REARCHITECT clean up this extra addref/release/return stuff
                AddRef();

                DBG("CThrottler::RunCookies autodial failed");

                // Uh-oh. The user cancelled the dial after starting a
                //  manual update. Clean up and return.
                if (m_fForcedGlobalOnline)
                {
                    SetGlobalOffline(TRUE);
                    m_fForcedGlobalOnline=FALSE;
                }

                WCHAR wszMsg[256];

                MLLoadStringW(IDS_STATUS_ABORTED, wszMsg, ARRAYSIZE(wszMsg));
        
                for (i=0; i<dwNumCookies; i++)
                {
                    ReportThrottlerError(&pSubscriptionCookies[i], E_ABORT, wszMsg);
                    UpdateEnd(&pSubscriptionCookies[i], 0, E_ABORT, wszMsg);
                }

                Release();

                return S_FALSE; // E_ABORT;
            }

            // Autodial succeeded
            m_fAutoDialed = TRUE;
        }
    }

    SUBSCRIPTIONCOOKIE *pCookies = new SUBSCRIPTIONCOOKIE[dwNumCookies];

    if (NULL != pCookies)
    {
        SUBSCRIPTIONCOOKIE *pCookie = pCookies;

        memcpy(pCookies, pSubscriptionCookies, dwNumCookies * sizeof(SUBSCRIPTIONCOOKIE));
    
        //  ************************************************************************
        //  Don't add any return statements in the loop!  We keep a ref on ourselves
        //  during this call in case we are Released by all of the sync handlers.
        //  ************************************************************************

        AddRef();

        nValidCookies = 0;

        for (i = 0; i < dwNumCookies; i++, pCookie++)
        {
            if (*pCookie == GUID_NULL)
            {
                continue;
            }

            nValidCookies++;

            if (IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_IDLE))
            {
                m_fUserIsIdle = TRUE;
            }

            if (SUCCEEDED(FindCookie(pCookie, &pUpdateItem)))
            {
                if (IsIgnoreIdleSyncEvent(dwSyncFlags))
                {
                    DUMPITEM("Removing RS_SUSPENDONIDLE in CThrottler::RunCookies", pCookie);
                    
                    //  Items updated manually are no longer subject to idle detection.
                    pUpdateItem->m_dwRunState &= ~RS_SUSPENDONIDLE;
                }

                if (IsSyncEventFlag(dwSyncFlags, SYNCMGRFLAG_MAYBOTHERUSER))
                {
                    // We may now bother user for this item
                    pUpdateItem->m_dwRunState |= RS_MAYBOTHERUSER;
                }
            }
            else
            {
                ISubscriptionItem *psi;
                HRESULT hrItem = SubscriptionItemFromCookie(FALSE, pCookie, &psi);

                if (SUCCEEDED(hrItem))
                {
                    SUBSCRIPTIONITEMINFO sii;

                    sii.cbSize = sizeof(SUBSCRIPTIONITEMINFO);

                    hrItem = psi->GetSubscriptionItemInfo(&sii);

                    if (SUCCEEDED(hrItem))
                    {
                        DWORD dwRunState = RS_READY;

                        if (IsSyncEvent(dwSyncFlags, SYNCMGRFLAG_IDLE))
                        {
                            dwRunState |= RS_SUSPENDONIDLE;
                        }

                        if (IsSyncEventFlag(dwSyncFlags, SYNCMGRFLAG_MAYBOTHERUSER))
                        {
                            dwRunState |= RS_MAYBOTHERUSER;
                        }

                        if (IsScheduleSyncEvent(dwSyncFlags))
                        {
                            hrItem = CanScheduledItemRun(psi);
                        }

                        if (SUCCEEDED(hrItem))
                        {
                        
                            pUpdateItem = new CUpdateItem(*pCookie, dwRunState);

                            if (NULL != pUpdateItem)
                            {
                                AddItemToListTail(pUpdateItem);
                            }
                            else
                            {
                                hrItem = E_OUTOFMEMORY;
                            }
                        }
                    }
                    psi->Release();
                }

                if (FAILED(hrItem))
                {
                    //  If we fail on an item, we will continue to try others, but
                    //  we need to indicate failure for this one.
                    FailedUpdate(hrItem, pCookie);
                    hr = S_FALSE;
                }
            }

            if (NULL == m_pSyncMgrs)
            {
                //  We have been unadvised!
                break;
            }
        }

        //  No point in trying to update if nobody wants to listen
        if (NULL != m_pSyncMgrs)
        {
            FillTheQueue();
        }

        Release();

        delete [] pCookies;

        if (0 == nValidCookies)
        {
            hr = E_FAIL;
        }

        //  ************************************************************************
        //  No member variable access after this since we could be dead!!!!
        //  ************************************************************************
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


HRESULT CThrottler::FindCookie(
    const SUBSCRIPTIONCOOKIE *pSubscriptionCookie, 
    CUpdateItem **ppUpdateItem)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = E_FAIL;
    CUpdateItem *pItem = m_pItemsHead;
    
    ASSERT(NULL != ppUpdateItem);

    *ppUpdateItem = NULL;

    while (pItem)
    {
        if (pItem->m_cookie == *pSubscriptionCookie)
        {
            *ppUpdateItem = pItem;
            hr = S_OK;
            break;
        }
        pItem = pItem->m_pNext;
    }

    return hr;
}


//==============================================================================
//
// Auto cache size increase
//
//==============================================================================
// We can return:
//  E_PENDING - agent will pause and wait to be resumed or aborted
//  INET_S_AGENT_INCREASED_CACHE_SIZE - agent will try making stuff sticky again
//  anything else - agent will abort with INET_E_AGENT_CACHE_SIZE_EXCEEDED
HRESULT CThrottler::AutoCacheSizeRequest(
        const SUBSCRIPTIONCOOKIE *pSubscriptionCookie)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    HRESULT hr = S_OK;
    DWORD dwCacheSizeKB;
    int queueIndex;

    DWORD dwValue, dwSize = sizeof(dwValue);
    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, c_szKeyRestrict, c_szCache, NULL, &dwValue, &dwSize)
        && (dwValue != 0))
    {
        // Not allowed to change the cache size.
        hr = E_FAIL;
    }

    queueIndex = GetCookieIndexInQueue(pSubscriptionCookie);

    if (queueIndex >= 0)
    {
        if (!(m_updateQueue[queueIndex]->m_dwRunState & RS_MAYBOTHERUSER))
        {
            // We're not allowed to bother user. Fail.
            hr = E_FAIL;
        }
    }
    else
    {
        DBG_WARN("CThrottler::AutoCacheSizeRequest couldn't find cookie in run queue.");
        hr = E_FAIL;        // Couldn't find this cookie in our queue?!
    }

    if (SUCCEEDED(hr) && m_fAutoCacheSizePending)
    {
        // We're already asking the user to increase the cache size.
        hr = E_PENDING;
    }

    if (SUCCEEDED(hr))
    {
        // Let's try to increase the cache.
        if (SUCCEEDED(IncreaseCacheSize(&dwCacheSizeKB)))
        {
            hr = INET_S_AGENT_INCREASED_CACHE_SIZE;
        }
        else
        {
            // We need to ask the user.
            if ((++ m_nAutoCacheSizeTimesAsked) > MAX_AUTOCACHESIZE_ASK)
            {
                hr = E_ABORT;       // Already bothered them enough.
            }
            else
            {
                // Let's ask the user. We need unwind our call stack now, however.
                // Tell the throttler to ask the user
                if (SUCCEEDED(CreateThrottlerWnd()))
                {
                    PostMessage(m_hwndThrottler, WM_THROTTLER_AUTOCACHESIZE_ASK, 0, dwCacheSizeKB);
                    m_fAutoCacheSizePending = TRUE;
                    hr = E_PENDING;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
    } // !m_fAutoCacheSizePending

    if (hr == E_PENDING)
    {
        // Mark this agent as paused.
        int queueIndex = GetCookieIndexInQueue(pSubscriptionCookie);

        ASSERT(queueIndex >= 0);

        if (queueIndex >= 0)
        {
            m_updateQueue[queueIndex]->m_dwRunState &= ~RS_UPDATING;
            m_updateQueue[queueIndex]->m_dwRunState |= RS_SUSPENDED;
            m_updateQueue[queueIndex] = NULL;
        }
    }

    return hr;
}

HRESULT CThrottler::AutoCacheSizeAskUser(DWORD dwCacheSizeKB)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    ASSERT(m_fAutoCacheSizePending);
    ASSERT(dwCacheSizeKB);
    ASSERT(m_hwndParent);

    HRESULT hr = E_FAIL;

    // Keep-Alive
    AddRef();

    if (IDOK == ShellMessageBox(MLGetHinst(),
                    m_hwndParent,
                    MAKEINTRESOURCE(IDS_CACHELIMIT_MESSAGE), 
                    MAKEINTRESOURCE(IDS_CACHELIMIT_TITLE),
                    MB_OKCANCEL | MB_SETFOREGROUND | MB_ICONQUESTION))
    {
        // Come up with a good cache size increase and resume agents
        m_dwAutoCacheSizeIncrease = dwCacheSizeKB / 4;

        if (m_dwAutoCacheSizeIncrease < MIN_CACHE_INCREASE)
        {
            m_dwAutoCacheSizeIncrease = MIN_CACHE_INCREASE;
        }

        m_dwMaxAutoCacheSize = dwCacheSizeKB + (2 * m_dwAutoCacheSizeIncrease);

        if (SUCCEEDED(IncreaseCacheSize(NULL)))
        {
            hr = S_OK;
        }
    }
    else
    {
        // Abort agents
    }

    m_fAutoCacheSizePending = FALSE;

    if (FAILED(hr))
    {
        // User said no (or we couldn't increase the cache).
        ActuallyAbortAll();
    }
    else
    {
        FillTheQueue();
    }

    Release();

    return hr;
}

// Auto-increase cache size if user previously ok'd it
HRESULT CThrottler::IncreaseCacheSize(DWORD *pdwNewCacheSizeKB)
{
    ASSERT(GetCurrentThreadId() == m_dwThreadId);
    LPINTERNET_CACHE_CONFIG_INFOA pCCI=NULL;
    DWORD  dwSizeInKB=0, dwPercent;
    DWORD  dwNewSizeInKB=0;
    HRESULT hr = E_FAIL;

    if (SUCCEEDED(GetCacheInfo(&pCCI, &dwSizeInKB, &dwPercent)))
    {
        if (dwSizeInKB < m_dwMaxAutoCacheSize)
        {
            ASSERT(m_dwAutoCacheSizeIncrease > 1023);   // At least 1 meg
            if (m_dwAutoCacheSizeIncrease)
            {
                // We still have room to increase cache without asking the user. Use it.
                dwNewSizeInKB = dwSizeInKB + m_dwAutoCacheSizeIncrease;

                if (dwNewSizeInKB > m_dwMaxAutoCacheSize)
                {
                    dwNewSizeInKB = m_dwMaxAutoCacheSize;
                }

                if (SUCCEEDED(SetCacheSize(pCCI, dwNewSizeInKB)))
                {
                    hr = S_OK;
                    dwSizeInKB = dwNewSizeInKB;
                    DBG("Throttler just increased TIF cache size");
                }
            }
        }

        MemFree(pCCI);
    }

    if (pdwNewCacheSizeKB)
    {
        *pdwNewCacheSizeKB = dwSizeInKB;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\utils.h ===
#ifndef UTILS_H
#define UTILS_H

#include <htmlhelp.h>

#ifdef __cplusplus
extern "C" {
#endif

HRESULT IExtractIcon_GetIconLocationThunk(IExtractIconW *peiw, UINT uFlags, LPSTR szIconFile, UINT cchMax, int * piIndex, UINT * pwFlags);
HRESULT IExtractIcon_ExtractThunk(IExtractIconW *peiw, LPCSTR pszFile, UINT nIconIndex, HICON * phiconLarge, HICON * phiconSmall, UINT nIconSize);

void FireSubscriptionEvent(int nCmdID, const SUBSCRIPTIONCOOKIE UNALIGNED *pCookie);

int WCMessageBox(HWND hwnd, UINT idTextFmt, UINT idCaption, UINT uType, ...);

HRESULT GetCacheInfo(LPINTERNET_CACHE_CONFIG_INFOA *, DWORD *, DWORD *);
HRESULT SetCacheSize(LPINTERNET_CACHE_CONFIG_INFOA, DWORD);

HRESULT _CreatePropSheet(HWND, POOEBuf);
int     _GetCmdID(LPCSTR);
int     _CompareShortName(LPMYPIDL, LPMYPIDL);
int     _CompareURL(LPMYPIDL, LPMYPIDL);
int     _CompareNextUpdate(LPMYPIDL, LPMYPIDL);
int     _CompareLastUpdate(LPMYPIDL, LPMYPIDL);
int     _CompareIdentities(LPMYPIDL, LPMYPIDL);
int     _CompareGroup(LPMYPIDL, LPMYPIDL);
int     _CompareStatus(LPMYPIDL, LPMYPIDL);
int     _ComparePriority(LPMYPIDL, LPMYPIDL);
void    _GenerateEvent(LONG, LPITEMIDLIST, LPITEMIDLIST, BOOL bRefresh = TRUE);
int     _LaunchApp(HWND, LPCTSTR);
BOOL    _ValidateIDListArray(UINT cidl, LPCITEMIDLIST *ppidl);
UINT    BufferSize(POOEBuf);
VOID    CannotSaveProperty(HWND);
BOOL    ConfirmDelete(HWND, UINT, LPMYPIDL *);
void    CopyToMyPooe(POOEBuf, POOEntry);
void    CopyToOOEBuf(POOEntry, POOEBuf);
HRESULT CreateBSTRFromTSTR(BSTR *, LPCTSTR);
BOOL    DATE2DateTimeString(CFileTime&, LPTSTR, int);
void    VariantTimeToFileTime(double dt, FILETIME& ft);

void SetListViewToString (HWND hLV, LPCTSTR pszString);

void GlobalAutoDial_Enable (BOOL bEnable);
BOOL GlobalAutoDial_IsEnabled (void);
BOOL GlobalAutoDial_ShouldEnable (HWND hParentWnd);

BOOL FailsWin95SecurityCheck (HWND hParentWnd);

BOOL    IsHTTPPrefixed(LPCTSTR szURL);
HRESULT LoadOOEntryInfo(POOEBuf pooeBuf, SUBSCRIPTIONCOOKIE *pCookie, DWORD *pdwSize);
HRESULT LoadSubscription(LPCTSTR, LPMYPIDL *);
UINT    MergeMenuHierarchy(HMENU, HMENU, UINT, UINT, BOOL);
UINT    MergePopupMenu(HMENU *phMenu, UINT idResource, UINT uSubOffset, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast);
HRESULT MergeOOEBuf(OOEBuf *pBuf1, OOEBuf *pBuf2, DWORD fMask);
HRESULT SendUpdateRequests(HWND hwnd, CLSID *, UINT count);

HRESULT PersistUpdate(POOEntry, BOOL bCreate);
HRESULT SaveBufferChange(POOEBuf newBuf, BOOL bCreate);
HRESULT LoadGroupCookie(NOTIFICATIONCOOKIE *, SUBSCRIPTIONSCHEDULE subGroup);

DWORD Random(DWORD nMax);
void CreateCookie(GUID UNALIGNED *pCookie);


BOOL _InitComCtl32();

//REVIEW Do we need the indirect versions?
#undef CreateDialogParam
#undef CreateDialog
#undef DialogBoxParam
#undef DialogBox
#undef PropertySheet

inline HWND CreateDialogParam(HINSTANCE  hInstance, LPCTSTR lpTemplateName,
                              HWND  hWndParent, DLGPROC lpDialogFunc,
                              LPARAM dwInitParam)
{
    _InitComCtl32();
    return CreateDialogParamW(hInstance, lpTemplateName, hWndParent, 
                              lpDialogFunc, dwInitParam);
}

inline HWND CreateDialog(HINSTANCE  hInstance, LPCTSTR lpTemplateName,
                         HWND  hWndParent, DLGPROC lpDialogFunc)
{
    return CreateDialogParam(hInstance, lpTemplateName, hWndParent, lpDialogFunc, 0L);
}

inline INT_PTR DialogBoxParam(HINSTANCE hInstance, LPCTSTR lpTemplateName, HWND hWndParent,
                          DLGPROC lpDialogFunc, LPARAM dwInitParam)
{
    _InitComCtl32();
    return DialogBoxParamW(hInstance, lpTemplateName, hWndParent, 
                           lpDialogFunc, dwInitParam);
}

inline INT_PTR DialogBox(HINSTANCE hInstance, LPCTSTR lpTemplate, HWND hWndParent,
                     DLGPROC lpDialogFunc)
{
    return DialogBoxParam(hInstance, lpTemplate, hWndParent, lpDialogFunc, 0L);
}

inline INT_PTR PropertySheet(LPCPROPSHEETHEADER lppsph)
{
    _InitComCtl32();

    return PropertySheetW(lppsph);
}

#ifdef __cplusplus
};
#endif

#endif  UTILS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\trkcache.cpp ===
// 
// Pei-Hwa Lin (peiwhal), Feb 3, 1997
//
//  Notes:
//   Compile switch : NO_FILE_WHEN_CREATE can turn on when wininet cache
//                    would create url cache entry if attached file is empty.
//                    LOG_CACHE_PATH will create log cache at the same level as
//                    content cache.
#include "private.h"

#undef TF_THISMODULE
#define TF_THISMODULE    TF_TRACKCACHE


#define MY_CACHE_FILE_ENTRY_SIZE     2048

const TCHAR c_szExt[] = TEXT("log");

//used for creating tracking container (registry)
const TCHAR c_szLogContainer[] = TEXT("Log");        // if you modify this, modify iedev\inc\inetreg.h REGSTR_PATH_TRACKING too.
const TCHAR c_szLogPrefix[] = TEXT("Log:");

const char  c_szLogContainerA[] = "Log";

// helper function
inline BOOL IsNumber(WCHAR x) { return (x >= L'0' && x <= L'9'); }

/*=============================================================================
 FILEFROMPATH returns the filename of given filename which may include path.
=============================================================================*/
LPTSTR FileFromPath( LPCTSTR lpsz )
{
   LPTSTR lpch;

   /* Strip path/drive specification from name if there is one */
   lpch = CharPrev( lpsz, lpsz + lstrlen(lpsz) );

   // special case for "http://server/domain/channel.cdf/"
   if (*lpch == '/') lpch = CharPrev( lpsz, lpch);

   while (lpch > lpsz)
   {
      if (*lpch == '/') {
         lpch = CharNext(lpch);
         break;
      }
      lpch = CharPrev( lpsz, lpch);
   }
   return(lpch);

} /* end FileFromPath */

// CDF updates, create new group and deal with previous posting information
void
CUrlTrackingCache :: Init(LPCWSTR pwszURL)
{
    DWORD   dwRetry;
    BSTR    bstrEncoding = NULL;

    _groupId = 0;
    _pwszPostUrl = NULL;
    _pszChannelUrlSite = NULL;
    _pszPostUrlSite = NULL;
    _pwszEncodingMethod = NULL;
    
    _groupId = CreateUrlCacheGroup(CACHEGROUP_FLAG_GIDONLY, NULL);

    WriteLONGLONG(_pCDFStartItem, c_szTrackingCookie, _groupId);

    // #54653: remove previous tracking information, if any
    if (SUCCEEDED(ReadBSTR(_pCDFStartItem, c_szPostHeader, &bstrEncoding)))
    {
        WriteEMPTY(_pCDFStartItem, c_szPostHeader);
        SAFEFREEBSTR(bstrEncoding);
    }

    if (SUCCEEDED(ReadDWORD(_pCDFStartItem, c_szPostingRetry, &dwRetry)))
        WriteEMPTY(_pCDFStartItem, c_szPostingRetry);

    DoBaseURL(pwszURL);
    return;
}

void
CUrlTrackingCache :: DoBaseURL(LPCWSTR pwszURL)
{
    DWORD  cbLen;    
    DWORD  useSecurity = 1;

    ASSERT(!_pszChannelUrlSite)

    cbLen = (lstrlenW(pwszURL)+1) * sizeof(WCHAR);
    _pszChannelUrlSite = (LPTSTR)MemAlloc( LPTR, cbLen);


#ifdef DEBUG

    HKEY hkey;

    // provide security switch for debugging
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        MY_WEBCHECK_POST_REG,
                                        0,
                                        KEY_READ,
                                        &hkey))
    {
        DWORD cbsize = sizeof(useSecurity);
        
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, 
                                        TEXT("PostSecurity"), 
                                        NULL, 
                                        NULL, 
                                        (LPBYTE)&useSecurity, 
                                        &cbsize))
        {
            if ((useSecurity == 0) && (NULL != _pszChannelUrlSite))
                StrCpyN(_pszChannelUrlSite, TEXT("http://"), cbLen / sizeof(WCHAR));
        }
    }

#endif
    
    if ((useSecurity == 1) && (NULL != _pszChannelUrlSite))
    {
        MyOleStrToStrN(_pszChannelUrlSite, cbLen, pwszURL);
        *(FileFromPath( _pszChannelUrlSite )) = 0;
    }
    return;
}

// only track URLs come from the same server of Channel CDF or LogTarget URL
//
BOOL
CUrlTrackingCache :: IsValidURL(LPCTSTR lpszURL)
{
    BOOL    bret;

    if (!_pszChannelUrlSite || !_pszPostUrlSite)
        return FALSE;
       
    if (!StrCmpNI(lpszURL, _pszChannelUrlSite, lstrlen(_pszChannelUrlSite)))
        bret = TRUE;
    else if (!StrCmpNI(lpszURL, _pszPostUrlSite, lstrlen(_pszPostUrlSite)))
        bret = TRUE;
    else
        bret = FALSE;

    return bret;
}

#define LOG_CACHE_PATH
#ifdef LOG_CACHE_PATH
            
LPSTR PathPreviousBackslashA(LPSTR psz)
{
    LPSTR lpch = CharPrevA(psz, psz + lstrlenA(psz));
    for (; *lpch && *lpch != '\\'; lpch=CharPrevA(psz,lpch));
        
    return lpch;
}

//------------------------------------------------------------------------------
// GetCacheLocation
//
// Purpose:     Return the location of the logging cache
//    *****     GetUrlCacheConfigInfoW is yet implemented in wininet
//------------------------------------------------------------------------------
//
HRESULT GetCacheLocation
(
    LPTSTR  pszCacheLocation,
    DWORD   dwSize          // no. of chars in pszCacheLocation
)
{
    HRESULT hr = S_OK;
    DWORD dwLastErr;
    LPINTERNET_CACHE_CONFIG_INFOA lpCCI = NULL;
    DWORD dwCCISize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    BOOL fOnceErrored = FALSE;

    while (TRUE)
    {
        if ((lpCCI = (LPINTERNET_CACHE_CONFIG_INFOA)MemAlloc(LPTR,
                                                        dwCCISize)) == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        if (!GetUrlCacheConfigInfoA(lpCCI, &dwCCISize,
                                            CACHE_CONFIG_CONTENT_PATHS_FC))
        {
            if ((dwLastErr = GetLastError()) != ERROR_INSUFFICIENT_BUFFER  ||
                fOnceErrored)
            {
                hr = HRESULT_FROM_WIN32(dwLastErr);
                goto cleanup;
            }

            //
            // We have insufficient buffer size; reallocate a buffer with the
            //      new dwCCISize set by GetUrlCacheConfigInfo
            // Set fOnceErrored to TRUE so that we don't loop indefinitely
            //
            fOnceErrored = TRUE;
        }
        else
        {
            // 
            LPSTR pszPath = lpCCI->CachePaths[0].CachePath;
            INT iLen;

            PathRemoveBackslashA(pszPath);
            *(PathPreviousBackslashA(pszPath)) = 0;
            iLen = lstrlenA(pszPath) + sizeof(CHAR);        // + 1 is for the null char

            if ((((DWORD) iLen + ARRAYSIZE(c_szLogContainer) + 1) * sizeof(TCHAR)) < dwSize)
            {
                TCHAR szPathT[MAX_PATH];

                SHAnsiToTChar(pszPath, szPathT, ARRAYSIZE(szPathT));
                wnsprintf(pszCacheLocation, dwSize, TEXT("%s\\%s"), szPathT, c_szLogContainer);
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            }

            break;
        }

        SAFELOCALFREE(lpCCI);
        lpCCI = NULL;
    }

cleanup:
    if (lpCCI != NULL)
    {
        LocalFree(lpCCI);
    }

    return hr;
}
#endif
//-----------------------------------------------------------------------------
//
// ReadTrackingPrefix
//
// will create tracking container if current profile doesn't have one
// **** FindFirstUrlCacheContainerW is yet implemented in wininet
// **** FindNextUrlCacheContainerW is yet implemented either
//-----------------------------------------------------------------------------
LPTSTR
ReadTrackingPrefix(void)
{
    LPTSTR  lpPfx = NULL;

    DWORD   cbPfx = 0;
    struct {
        INTERNET_CACHE_CONTAINER_INFOA cInfo;
        CHAR  szBuffer[MAX_PATH+INTERNET_MAX_URL_LENGTH+1];
    } ContainerInfo;
    DWORD   dwModified, dwContainer;
    HANDLE  hEnum;
  
    dwContainer = sizeof(ContainerInfo);
    hEnum = FindFirstUrlCacheContainerA(&dwModified,
                                       &ContainerInfo.cInfo,
                                       &dwContainer,
                                       0);

    if (hEnum)
    {

        for (;;)
        {
            if (!StrCmpIA(ContainerInfo.cInfo.lpszName, c_szLogContainerA))
            {
                ASSERT(ContainerInfo.cInfo.lpszCachePrefix[0]);

                CHAR    szPfx[MAX_PATH];
                DWORD   cch = ARRAYSIZE(ContainerInfo.cInfo.lpszCachePrefix)+sizeof(CHAR);
                StrCpyNA(szPfx, ContainerInfo.cInfo.lpszCachePrefix, cch);

                cch *= sizeof(TCHAR);
                lpPfx = (LPTSTR)MemAlloc(LPTR, cch);
                if (!lpPfx)
                    SetLastError(ERROR_OUTOFMEMORY);

                SHAnsiToTChar(szPfx, lpPfx, cch);
                break;
            }

            dwContainer = sizeof(ContainerInfo);
            if (!FindNextUrlCacheContainerA(hEnum, &ContainerInfo.cInfo, &dwContainer))
            {
                //  This code used to check GetLastError() for ERROR_NO_MORE_ITEMS before
                //  it would break.  Well, that could put us in an infinite loop if the
                //  reason for failure were something else (like insufficient buffer) because
                //  wininet would not move forward in it's enumeration and we would not
                //  have done anything to address the error.
                break;
            }

        }

        FindCloseUrlCache(hEnum);
    }

    if (!lpPfx)
    {
        LPTSTR pszCachePath = NULL;
#ifdef LOG_CACHE_PATH
        TCHAR szCachePath[MAX_PATH];

        pszCachePath = (SUCCEEDED(GetCacheLocation(szCachePath, MAX_PATH))) ?
                                  szCachePath : NULL;
#endif

        if (CreateUrlCacheContainer(c_szLogContainer, 
                  c_szLogPrefix, 
                  pszCachePath, // wininet bug:if NULL, will create under ..\History\Log //
                  8192,       // dwCacheLimit,
                  INTERNET_CACHE_CONTAINER_NOSUBDIRS,          // dwContainerType,
                  0,          // dwOptions,
                  NULL,       // pvBuffer,
                  0           // cbBuffer
                    ))
        {
            return ReadTrackingPrefix();
        }
        // unable to create Log container, stop.
    }
     
    return lpPfx;
}

//-----------------------------------------------------------------------------
//
// ConvertToPrefixedUrl
//
// caller must release lplpPrefixedUrl
//-----------------------------------------------------------------------------
BOOL
CUrlTrackingCache :: ConvertToPrefixedUrl
(
    IN LPCTSTR lpUrl, 
    IN LPTSTR* lplpPrefixedUrl
)
{
    BOOL    bret = FALSE;

    ASSERT(lpUrl);
    if (!_lpPfx)
        _lpPfx = ReadTrackingPrefix();

    if (_lpPfx)
    {
        int len = lstrlen(lpUrl) + lstrlen(_lpPfx) + 1;
        
        *lplpPrefixedUrl = NULL;
        
        *lplpPrefixedUrl = (LPTSTR)MemAlloc(LPTR, len * sizeof(TCHAR));
        if (*lplpPrefixedUrl)
        {
            wnsprintf(*lplpPrefixedUrl, len, TEXT("%s%s"), _lpPfx, lpUrl);
            bret = TRUE;
        }
        else
            bret = FALSE;
    }

    return bret;
}

//-----------------------------------------------------------------------------
//
// RetrieveUrlCacheEntry
//
// caller must release lpCE
//-----------------------------------------------------------------------------
LPINTERNET_CACHE_ENTRY_INFO 
CUrlTrackingCache :: RetrieveUrlCacheEntry
(
    IN  LPCTSTR     lpUrl
)
{
    LPINTERNET_CACHE_ENTRY_INFO   lpCE = NULL;
    DWORD          cbSize;
    BOOL           bret = FALSE;

    lpCE = (LPINTERNET_CACHE_ENTRY_INFO)MemAlloc(LPTR, MY_MAX_CACHE_ENTRY_INFO);
    if (lpCE)
    {
        cbSize = MY_MAX_CACHE_ENTRY_INFO;
        while ((bret = GetUrlCacheEntryInfo(lpUrl, lpCE, &cbSize)) != TRUE)
        {
            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
            {
                SAFELOCALFREE(lpCE);

                lpCE = (LPINTERNET_CACHE_ENTRY_INFO)MemAlloc(LPTR, cbSize);
                if (!lpCE)
                   break;
            }
            else
                break;
        }
    }

    if (!bret && lpCE)
    {
        SAFELOCALFREE(lpCE);
        SetLastError(ERROR_FILE_NOT_FOUND);
    }

    return lpCE;
}

#define FILETIME_SEC   100000000
#define SECS_PER_DAY   (60 * 60 * 24)

DWORD WCTOI(LPCWSTR pwstr)
{
    DWORD   dw;
    int     len = lstrlenW(pwstr);

    dw = 0;
    for (int i = 0; i<len; i++)
    {
        if (!IsNumber(pwstr[i]))
            break;

        dw = dw * 10 + (pwstr[i] - L'0');
    }

    if (dw == 0) dw = 24;
    return dw;
}

//-----------------------------------------------------------------------------
//
// CreatePrefixedCacheEntry
//
// Create cache entry in Tracking cache bucket
//-----------------------------------------------------------------------------
HRESULT CreateLogCacheEntry
(
    LPCTSTR  lpPfxUrl, 
    FILETIME ftExpire, 
    FILETIME ftModified,
    DWORD    CacheEntryType
)
{
    TCHAR   lpFile[MAX_PATH];
    HRESULT hr = E_FAIL;
    DWORD      cbSize;

    if (CreateUrlCacheEntry(lpPfxUrl, MY_CACHE_FILE_ENTRY_SIZE, c_szExt, lpFile, 0))
    {
        HANDLE hFile = CreateFile(lpFile,
                                    GENERIC_READ|GENERIC_WRITE,
                                    FILE_SHARE_READ,
                                    NULL,
                                    CREATE_ALWAYS,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);
        if (hFile == INVALID_HANDLE_VALUE)
            return hr;
              
        // note: wininet will not create the entry if file size equals to zero
//            WriteFile(hFile, c_szLogFields, g_ccLogFields, &cbSize, NULL);

        WriteFile(hFile, c_szEmptyLog, c_ccEmptyLog, &cbSize, NULL);
        CloseHandle(hFile);

        return (CommitUrlCacheEntry(lpPfxUrl, 
                                   lpFile, 
                                   ftExpire, 
                                   ftModified, 
                                   CacheEntryType,
                                   NULL,
                                   0,
                                   NULL,
                                   0)) ? S_OK : E_FAIL;
    }

    return hr;
}

HRESULT
CUrlTrackingCache :: CreatePrefixedCacheEntry
(
    IN LPCTSTR lpPfxUrl
)
{
    HRESULT     hr = E_FAIL;
    LPINTERNET_CACHE_ENTRY_INFO    lpCE = NULL;
    FILETIME    ftModified;

    // IE50: due to change to wininet cache group enumeration, now we save our filter
    // information _groupId along with each cache entry itself.  the wininet url cache
    // no longer maintain this for us
    ftModified.dwHighDateTime = (DWORD)(_groupId >> 32);
    ftModified.dwLowDateTime = (DWORD)(0x00000000ffffffff & _groupId);

    lpCE = RetrieveUrlCacheEntry(lpPfxUrl);
    if (lpCE ) 
    {
        // exist in Tracking bucket, set tracking flag
        // IE50: save _groupId info in LastModifiedTime
        lpCE->CacheEntryType |= _ConnectionScope;
        lpCE->LastModifiedTime.dwHighDateTime = ftModified.dwHighDateTime;
        lpCE->LastModifiedTime.dwLowDateTime = ftModified.dwLowDateTime;

        ASSERT(SetUrlCacheEntryInfo(lpCE->lpszSourceUrlName, lpCE, 
                             CACHE_ENTRY_ATTRIBUTE_FC | CACHE_ENTRY_MODTIME_FC) == TRUE);
        hr = S_OK;
    }
    else
    //FILE_NOT_FOUND, create it.
    {
        LONGLONG llExpireHorizon;     
        SYSTEMTIME  st;
        FILETIME ftMod, ftExpire;

        llExpireHorizon = (LONGLONG)(SECS_PER_DAY * _dwPurgeTime / 24);

        GetLocalTime(&st);
        SystemTimeToFileTime(&st, &ftMod);

        llExpireHorizon *= FILETIME_SEC;
        ftExpire.dwLowDateTime = ftMod.dwLowDateTime + (DWORD)(llExpireHorizon % 0xFFFFFFFF);
        ftExpire.dwHighDateTime = ftMod.dwHighDateTime + (DWORD)(llExpireHorizon / 0xFFFFFFFF);

        hr = CreateLogCacheEntry(lpPfxUrl, ftExpire, ftModified, _ConnectionScope);

    }
        
    SAFELOCALFREE(lpCE);

    return hr;
}

HRESULT
CUrlTrackingCache :: AddToTrackingCacheEntry
(
    IN LPCWSTR  pwszUrl
)
{
    HRESULT     hr = E_OUTOFMEMORY;
    TCHAR       szCanonicalUrl[MAX_URL];
    DWORD       dwSize = MAX_URL;
    LPTSTR      lpUrl = NULL;
    LPTSTR      lpPfxUrl = NULL;
    DWORD       cbSize;
    PROPVARIANT vProp = {0};

    if (pwszUrl == NULL)
        return E_INVALIDARG;

    cbSize = lstrlenW(pwszUrl) + 1;
    lpUrl = (LPTSTR)MemAlloc(LPTR, cbSize * sizeof(TCHAR));
    if (!lpUrl)
        return hr;

    SHUnicodeToTChar(pwszUrl, lpUrl, cbSize);
    if (!IsValidURL(lpUrl))
    {
        MemFree(lpUrl);
        return E_INVALIDARG;
    }        

    // canonicalize URL
    InternetCanonicalizeUrl(lpUrl, szCanonicalUrl, &dwSize, ICU_DECODE);
    SAFELOCALFREE(lpUrl);
    ConvertToPrefixedUrl(szCanonicalUrl, &lpPfxUrl);
    if (!lpPfxUrl)
    {
        return hr;
    }

    hr = CreatePrefixedCacheEntry(lpPfxUrl);
    if (SUCCEEDED(hr))
    {
        // exist in Tracking bucket, set tracking flag.
        vProp.vt = VT_UI4;
        vProp.ulVal = _ConnectionScope;
        hr = IntSiteHelper(szCanonicalUrl, &c_rgPropRead[PROP_TRACKING], &vProp, 1, TRUE);
        PropVariantClear( &vProp );        
    }

    SAFELOCALFREE(lpPfxUrl);
    return hr;
}

//-----------------------------------------------------------------------------
//
// Process log related tags
//
//-----------------------------------------------------------------------------
//
// <LOGTARGET href="http://foo.htm" SCOPE="ALL"/>
//  <HTTP-EQUIV name="Encoding-type" value="gzip" />
//  <PurgeTime HOUR="12" />
// </Logtarget>
//
HRESULT
CUrlTrackingCache :: ProcessTrackingInLog
(
    IXMLElement     *pTracking
)
{

    HRESULT hr;
    LPWSTR  pwszScope = NULL;
    
    if (_pwszPostUrl)
        return S_OK;        // there are more than 1 logtarget, take whatever first was read

    hr = ReadAttribute(pTracking, L"HREF", &_pwszPostUrl);       // must exist to enalbe logging
    if (FAILED(hr))
        return hr;

    // fill it in item for post agent
    WriteOLESTR(_pCDFStartItem, c_szTrackingPostURL, _pwszPostUrl);

    // #41460: add 2nd domain allowing tracking to
    DWORD   cbLen = (lstrlenW(_pwszPostUrl)+1) * sizeof(WCHAR);
    _pszPostUrlSite = (LPTSTR)MemAlloc( LPTR, cbLen);
    MyOleStrToStrN(_pszPostUrlSite, cbLen, _pwszPostUrl);
    *(FileFromPath( _pszPostUrlSite )) = 0;


    _ConnectionScope = TRACK_ONLINE_CACHE_ENTRY | TRACK_OFFLINE_CACHE_ENTRY;
    hr = ReadAttribute(pTracking, L"SCOPE", &pwszScope);
    if (SUCCEEDED(hr))
    {     
        if (!StrCmpIW(pwszScope, L"OFFLINE"))
            _ConnectionScope = TRACK_OFFLINE_CACHE_ENTRY;            
        else if (!StrCmpIW(pwszScope, L"ONLINE"))                    
            _ConnectionScope = TRACK_ONLINE_CACHE_ENTRY;

        SAFELOCALFREE(pwszScope);
    }

    RunChildElement(pTracking);

    // #42687: save purgetime to item and used later by post agent
    if (_pwszPurgeTime)     // if not specify, default is 24 hours
    {
        _dwPurgeTime = WCTOI(_pwszPurgeTime);
    }

    DATE        dt = 0.0;
    SYSTEMTIME  st;

    GetLocalTime(&st);
    SystemTimeToVariantTime(&st, &dt);
    dt += ((DATE)_dwPurgeTime/24);
#ifdef DEBUG
    VariantTimeToSystemTime(dt, &st);
#endif
    WriteDATE(_pCDFStartItem, c_szPostPurgeTime, &dt);

    return S_OK;    
}

//-----------------------------------------------------------------------------
//
// ProcessTrackingItems
//  <Item href="http://foo">
//    <Log value="document:view"/>
//  </Item>
// or <Item>
//    <A href="http://foo" />
//  </Item>
//  This routine will setup tracking cache entries for all URLs which are
//  specified in CDF file to track.  All URLs entries belong to same channel 
//  are created in same cache group
//-----------------------------------------------------------------------------
HRESULT
CUrlTrackingCache :: ProcessTrackingInItem
(
    IXMLElement     *pItem,                 //point to <Item> tag
    LPCWSTR         pwszUrl,                //absolute URL for item
    BOOL            fForceLog               //global log flag
)
{
    HRESULT hr = S_OK;

    _bTrackIt = fForceLog;

    if (!_bTrackIt)
        hr = RunChildElement(pItem);

    if (SUCCEEDED(hr) && _bTrackIt)
        hr = AddToTrackingCacheEntry(pwszUrl);
    
    return (_bTrackIt) ? S_OK : E_FAIL;        // #42604: global logging, report if this item needs logged
}

HRESULT
CUrlTrackingCache :: RunChildElement
(
    IXMLElement* pElement
)
{
    IXMLElementCollection *pCollection;
    long        lIndex = 0;
    long        lMax;
    VARIANT     vIndex, vEmpty;
    IDispatch   *pDisp;
    IXMLElement *pItem;
    BSTR        bstrTagName;
    HRESULT     hr = E_FAIL;

    if (SUCCEEDED(pElement->get_children(&pCollection)) && pCollection)
    {
        if (SUCCEEDED(pCollection->get_length(&lMax)))
        {
            vEmpty.vt = VT_EMPTY;

            for (; lIndex < lMax; lIndex++)
            {
                vIndex.vt = VT_UI4;
                vIndex.lVal = lIndex;

                if (SUCCEEDED(pCollection->item(vIndex, vEmpty, &pDisp)))
                {
                    if (SUCCEEDED(pDisp->QueryInterface(IID_IXMLElement, (void **)&pItem)))
                    {
                        if (SUCCEEDED(pItem->get_tagName(&bstrTagName)) && bstrTagName)
                        {
                            hr = ProcessItemInEnum(bstrTagName, pItem);
                            SysFreeString(bstrTagName);
                        }
                        pItem->Release();
                    }
                    pDisp->Release();
                }
            }

        }
        pCollection->Release();
    }

    return hr;
}

HRESULT
CUrlTrackingCache :: ProcessItemInEnum
(
    LPCWSTR pwszTagName, 
    IXMLElement *pItem
)
{
    HRESULT hr;
    LPWSTR  pwszName = NULL;

    if (!StrCmpIW(pwszTagName, L"HTTP-EQUIV"))
    {
        DBG("CUrlTrackingCache processing HTTP-EQUIV");
        
        hr = ReadAttribute(pItem, L"NAME", &pwszName);
        if (SUCCEEDED(hr) && !StrCmpIW(pwszName, L"ENCODING-TYPE"))
        {
            hr = ReadAttribute(pItem, L"VALUE", &_pwszEncodingMethod);
            if (SUCCEEDED(hr) && *_pwszEncodingMethod)
                WriteOLESTR(_pCDFStartItem, c_szPostHeader, _pwszEncodingMethod);
        }        
        
        SAFELOCALFREE(pwszName);
    }
    else if (!StrCmpIW(pwszTagName, L"PURGETIME"))
    {
        DBG("CUrlTrackingCache processing PurgeTime");

        return ReadAttribute(pItem, L"HOUR", &_pwszPurgeTime);
    }
    else if (!StrCmpIW(pwszTagName, L"LOG"))
    {
        DBG("CUrlTrackingCache processing Log");
        
        hr = ReadAttribute(pItem, L"VALUE", &pwszName);
        if (SUCCEEDED(hr))
            _bTrackIt = (!StrCmpIW(pwszName, L"document:view")) ? TRUE : FALSE;

        SAFELOCALFREE(pwszName);
    }

    return S_OK;
}

HRESULT
CUrlTrackingCache :: ReadAttribute
(
    IN  IXMLElement* pItem,
    IN  LPCWSTR      pwszAttributeName,
    OUT LPWSTR*      pwszAttributeValue
)
{
    VARIANT vProp;
    BSTR    bstrName = NULL;
    HRESULT hr = E_FAIL;
    DWORD   dwLen;

    vProp.vt = VT_EMPTY;
    
    bstrName = SysAllocString(pwszAttributeName);

    if (bstrName && SUCCEEDED(pItem->getAttribute(bstrName, &vProp)))
    {
        if (vProp.vt == VT_BSTR)
        {
            dwLen = sizeof(WCHAR) * (lstrlenW(vProp.bstrVal) + 1);
            *pwszAttributeValue = (LPWSTR)MemAlloc(LPTR, dwLen);
            if (*pwszAttributeValue)
            {
                StrCpyNW(*pwszAttributeValue, vProp.bstrVal, dwLen / sizeof(WCHAR));
                hr = S_OK;
            }

            VariantClear(&vProp);
        }
    }

    SysFreeString(bstrName);

    return hr;
}


//--------------------------------------------------------------------------
//
// CUrlTrackingCache
//
//--------------------------------------------------------------------------
CUrlTrackingCache::CUrlTrackingCache
(
    ISubscriptionItem *pCDFItem,
    LPCWSTR pwszURL
)
{
    _lpPfx = NULL;
    _dwPurgeTime = 24;
    _pCDFStartItem = pCDFItem;

    ASSERT(_pCDFStartItem);
    _pCDFStartItem->AddRef();

    Init(pwszURL);
        
}

CUrlTrackingCache::~CUrlTrackingCache()
{

    SAFEFREEOLESTR(_pwszPostUrl);
    SAFEFREEOLESTR(_pwszEncodingMethod);
    SAFEFREEOLESTR(_pwszPurgeTime);

    SAFELOCALFREE(_pszChannelUrlSite);
    SAFELOCALFREE(_pszPostUrlSite);
    SAFELOCALFREE(_lpPfx);
         
    SAFERELEASE(_pCDFStartItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\webcheck.cpp ===
#include "private.h"
#include "subsmgrp.h"
#include "offsync.h"
#include "offl_cpp.h"
#include "factory.h"
#include "notfcvt.h"
#define TF_THISMODULE TF_WEBCHECKCORE

#include "resource.h"

#define INITGUIDS
#include <shlguid.h>

#define MLUI_INIT
#include <mluisupp.h>

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;



//  We're going to use our own new and delete so that we can 
//  use shdocvw's leak detection code
//

//
// Subscription property names
//
// Agent Start
extern const WCHAR  c_szPropURL[] = L"URL";
extern const WCHAR  c_szPropName[] = L"Name";
extern const WCHAR  c_szPropAgentFlags[] = L"AgentFlags";
extern const WCHAR  c_szPropCrawlLevels[] = L"RecurseLevels";
extern const WCHAR  c_szPropCrawlFlags[] = L"RecurseFlags";
extern const WCHAR  c_szPropCrawlMaxSize[] = L"MaxSizeKB";
extern const WCHAR  c_szPropCrawlChangesOnly[] = L"CheckChangesOnly";
extern const WCHAR  c_szPropChangeCode[] = L"ChangeCode";
extern const WCHAR  c_szPropCrawlUsername[] = L"Username";
extern const WCHAR  c_szPropEmailNotf[] = L"EmailNotification";
extern const WCHAR  c_szPropCrawlLocalDest[] = L"LocalDest";
extern const WCHAR  c_szPropCrawlGroupID[] = L"GroupID";
extern const WCHAR  c_szPropCrawlNewGroupID[] = L"NewGroupID";
extern const WCHAR  c_szPropActualProgressMax[] = L"ActualProgressMax";
extern const WCHAR  c_szPropCrawlActualSize[] = L"ActualSizeKB";
extern const WCHAR  c_szPropEnableShortcutGleam[] = L"EnableShortcutGleam";
extern const WCHAR  c_szPropChannelFlags[] = L"ChannelFlags";
extern const WCHAR  c_szPropChannel[] = L"Channel";
extern const WCHAR  c_szPropDesktopComponent[] = L"DesktopComponent";
extern const WCHAR  c_szPropStatusCode[] = L"StatusCode";
extern const WCHAR  c_szPropStatusString[] = L"StatusString";
extern const WCHAR  c_szPropCompletionTime[] = L"CompletionTime";
extern const WCHAR  c_szPropPassword[] = L"Password";
// End Report
extern const WCHAR  c_szPropEmailURL[] = L"EmailURL";
extern const WCHAR  c_szPropEmailFlags[] = L"EmailFlags";
extern const WCHAR  c_szPropEmailTitle[] = L"EmailTitle";
extern const WCHAR  c_szPropEmailAbstract[] = L"EmailAbstract";
extern const WCHAR  c_szPropCharSet[] = L"CharSet";

// Tray Agent Properties
extern const WCHAR  c_szPropGuidsArr[] = L"Guids Array";

// Tracking Properties
extern const WCHAR  c_szTrackingCookie[] = L"LogGroupID";
extern const WCHAR  c_szTrackingPostURL[] = L"PostURL";
extern const WCHAR  c_szPostingRetry[] = L"PostFailureRetry";
extern const WCHAR  c_szPostHeader[] = L"PostHeader";
extern const WCHAR  c_szPostPurgeTime[] = L"PostPurgeTime";

// Delivery Agent Properties
extern const WCHAR  c_szStartCookie[] = L"StartCookie";

// Initial cookie in AGENT_INIT
extern const WCHAR  c_szInitCookie[] = L"InitCookie";

STDAPI OfflineFolderRegisterServer();
STDAPI OfflineFolderUnregisterServer();

// Count number of objects and number of locks.
ULONG       g_cObj=0;
ULONG       g_cLock=0;

// DLL Instance handle
HINSTANCE   g_hInst=0;

// other globals
BOOL        g_fIsWinNT;    // Are we on WinNT? Always initialized.
BOOL        g_fIsWinNT5;   // Is it NT5?
BOOL        g_fIsMillennium = FALSE;

// logging globals
BOOL        g_fCheckedForLog = FALSE;       // have we checked registry?
TCHAR *     g_pszLoggingFile = NULL;        // file to write log to

TCHAR szInternetSettings[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings");
TCHAR szProxyEnable[] = TEXT("ProxyEnable");
const TCHAR c_szRegKey[] = WEBCHECK_REGKEY;
const TCHAR c_szRegKeyUsernames[] = WEBCHECK_REGKEY TEXT("\\UserFormFieldNames");
const TCHAR c_szRegKeyPasswords[] = WEBCHECK_REGKEY TEXT("\\PasswordFormFieldNames");
const TCHAR c_szRegKeyStore[] = WEBCHECK_REGKEY_STORE;

// Pstore related variables.
static PST_PROVIDERID s_provID = GUID_NULL;

// {14D96C20-255B-11d1-898F-00C04FB6BFC4}
static const GUID GUID_PStoreType = { 0x14d96c20, 0x255b, 0x11d1, { 0x89, 0x8f, 0x0, 0xc0, 0x4f, 0xb6, 0xbf, 0xc4 } };

static PST_KEY s_Key = PST_KEY_CURRENT_USER;
static WCHAR c_szInfoDel[] = L"InfoDelivery";
static WCHAR c_szSubscriptions[] = L"Subscriptions";

void SetupDelayloadErrorHandler()
{
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress(GetModuleHandleA("shlwapi.dll"), "DelayLoadFailureHook");
}

//////////////////////////////////////////////////////////////////////////
//
// DLL entry point
//
//////////////////////////////////////////////////////////////////////////
EXTERN_C BOOL WINAPI DllMain(HINSTANCE hInstance, ULONG ulReason, LPVOID pvReserved)
{

    switch (ulReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            SHFusionInitializeFromModule((HMODULE)hInstance);
            OSVERSIONINFOA vi;

            DisableThreadLibraryCalls(hInstance);
            g_hInst = hInstance;
            SetupDelayloadErrorHandler();

            MLLoadResources(g_hInst, TEXT("webchklc.dll"));

            vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA(&vi);
            if(vi.dwPlatformId == VER_PLATFORM_WIN32_NT) {
                g_fIsWinNT = TRUE;
                if(vi.dwMajorVersion > 4)
                    g_fIsWinNT5 = TRUE;
                else
                    g_fIsWinNT5 = FALSE;
            } else {
                g_fIsWinNT = FALSE;
                g_fIsWinNT5 = FALSE;

                g_fIsMillennium = IsOS(OS_MILLENNIUM);
            }

#ifdef DEBUG
            g_qwTraceFlags = TF_NEVER;    // Default if not overridden from INI
            CcshellGetDebugFlags();
#endif
        }
        break;

        case DLL_PROCESS_DETACH:
        {
            MLFreeResources(g_hInst);
            SHFusionUninitialize();
        }
        break;
    }


    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
//
// Standard OLE entry points
//
//////////////////////////////////////////////////////////////////////////

//  Class factory -
//  For classes with no special needs these macros should take care of it.
//  If your class needs some special stuff just to get the ball rolling,
//  implement your own CreateInstance method.

#define DEFINE_CREATEINSTANCE(cls, iface) \
HRESULT cls##_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk) \
{ \
    ASSERT(NULL == punkOuter); \
    ASSERT(NULL != ppunk); \
    *ppunk = (iface *)new cls; \
    return (NULL != *ppunk) ? S_OK : E_OUTOFMEMORY; \
}

#define DEFINE_AGGREGATED_CREATEINSTANCE(cls, iface) \
HRESULT cls##_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk) \
{ \
    ASSERT(NULL != punkOuter); \
    ASSERT(NULL != ppunk); \
    *ppunk = (iface *)new cls(punkOuter); \
    return (NULL != *ppunk) ? S_OK : E_OUTOFMEMORY; \
}

DEFINE_CREATEINSTANCE(CWebCheck, IOleCommandTarget)
DEFINE_CREATEINSTANCE(CChannelAgent, ISubscriptionAgentControl)
DEFINE_CREATEINSTANCE(COfflineFolder, IShellFolder)
DEFINE_CREATEINSTANCE(CSubscriptionMgr, ISubscriptionMgr2);
DEFINE_CREATEINSTANCE(CWCPostAgent, ISubscriptionAgentControl)
DEFINE_CREATEINSTANCE(CCDLAgent, ISubscriptionAgentControl)
DEFINE_CREATEINSTANCE(COfflineSync, ISyncMgrSynchronize)

const CFactoryData g_FactoryData[] = 
{
 {   &CLSID_WebCheck,             CWebCheck_CreateInstance,           0 }
,{   &CLSID_WebCrawlerAgent,      CWebCrawler::CreateInstance,        0 }
,{   &CLSID_ChannelAgent,         CChannelAgent_CreateInstance,       0 }
,{   &CLSID_OfflineFolder,        COfflineFolder_CreateInstance,      0 }
,{   &CLSID_SubscriptionMgr,      CSubscriptionMgr_CreateInstance,    0 }
,{   &CLSID_PostAgent,            CWCPostAgent_CreateInstance,        0 }
,{   &CLSID_CDLAgent,             CCDLAgent_CreateInstance,           0 }
,{   &CLSID_WebCheckOfflineSync,  COfflineSync_CreateInstance,        0 }
};

HRESULT APIENTRY DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    IUnknown *punk = NULL;

    *ppv = NULL;
    
    // Validate request
    for (int i = 0; i < ARRAYSIZE(g_FactoryData); i++)
    {
        if (rclsid == *g_FactoryData[i].m_pClsid)
        {
            punk = new CClassFactory(&g_FactoryData[i]);
            break;
        }
    }

    if (ARRAYSIZE(g_FactoryData) <= i)
    {
        ASSERT(NULL == punk);
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }
    else if (NULL == punk)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = punk->QueryInterface(riid, ppv);
        punk->Release();
    } 

    ASSERT((SUCCEEDED(hr) && (NULL != *ppv)) ||
           (FAILED(hr) && (NULL == *ppv)));

    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    // check objects and locks
    return (0L == DllGetRef() && 0L == DllGetLock()) ? S_OK : S_FALSE;
}

//////////////////////////////////////////////////////////////////////////
//
// helper functions
//
//////////////////////////////////////////////////////////////////////////
int MyOleStrToStrN(LPTSTR psz, int cchMultiByte, LPCOLESTR pwsz)
{
    StrCpyN(psz, pwsz, cchMultiByte);

    return cchMultiByte;
}

int MyStrToOleStrN(LPOLESTR pwsz, int cchWideChar, LPCTSTR psz)
{
    StrCpyN(pwsz, psz, cchWideChar);

    return cchWideChar;
}

// Convert upper to lower for ASCII wide characters
inline WCHAR MyToLower(WCHAR wch)
{
    return (wch >= 'A' && wch <= 'Z') ? (wch - 'A'+ 'a') : wch;
}

// Optimized for the knowledge that urls are 7-bit characters.
int MyAsciiCmpNIW(LPCWSTR pwsz1, LPCWSTR pwsz2, int iLen)
{
    while (iLen-- && *pwsz1 && *pwsz2)
    {
        ASSERT(*pwsz1 || *pwsz2);

        if (MyToLower(*pwsz1++) != MyToLower(*pwsz2++))
            return 1;
    }

    return 0;
}

int MyAsciiCmpW(LPCWSTR pwsz1, LPCWSTR pwsz2)
{
    while (*pwsz1)
    {
        if (*pwsz1++ != *pwsz2++)
        {
            return 1;
        }
    }

    if (*pwsz2)
        return 1;

    return 0;
}


#ifdef DEBUG
void DumpIID(LPCSTR psz, REFIID riid)
{
    // Convert the GUID to an ANSI string
    TCHAR pszGUID[GUIDSTR_MAX];
    WCHAR pwszGUID[GUIDSTR_MAX];
    int len = StringFromGUID2(riid, pwszGUID, ARRAYSIZE(pwszGUID));
    ASSERT(GUIDSTR_MAX == len);
    ASSERT(0 == pwszGUID[GUIDSTR_MAX - 1]);
    len = MyOleStrToStrN(pszGUID, GUIDSTR_MAX, pwszGUID);
    ASSERT(GUIDSTR_MAX == len);
    ASSERT(0 == pszGUID[GUIDSTR_MAX - 1]);

    // See if the IID has a string in the registry
    TCHAR pszKey[MAX_PATH];
    TCHAR pszIIDName[MAX_PATH];
    wnsprintf(pszKey, ARRAYSIZE(pszKey), TEXT("Interface\\%s"), pszGUID);
    BOOL fRet;
    fRet = ReadRegValue(HKEY_CLASSES_ROOT, pszKey, NULL, pszIIDName, sizeof(pszIIDName));

    // Print all the strings
    if (fRet)
        TraceMsg(TF_THISMODULE, "%s - %s %s", psz, pszIIDName, pszGUID);
    else
        TraceMsg(TF_THISMODULE, "%s - %s", psz, pszGUID);
}
#endif // DEBUG

//////////////////////////////////////////////////////////////////////////
//
// Autoregistration entry points
//
//////////////////////////////////////////////////////////////////////////

HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, achREGINSTALL);

        if (pfnri)
        {
            hr = pfnri(g_hInst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}

STDAPI DllRegisterServer(void)
{
    // Delete any old registration entries, then add the new ones.
    // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
//  CallRegInstall("UnReg");
    CallRegInstall("Reg");
    if (hinstAdvPack)
    {
        FreeLibrary(hinstAdvPack);
    }

    // OfflineFolder registers.
    OfflineFolderRegisterServer();

    // do external setup stuff on non-NT5 platforms
    if(FALSE == g_fIsWinNT5)
    {
        // register LCE
        HINSTANCE hLCE = LoadLibrary(TEXT("estier2.dll"));
        if (hLCE)
        {
            LCEREGISTER regfunc;
            regfunc = (LCEREGISTER)GetProcAddress(hLCE, "LCERegisterServer");
            if (regfunc)
                if (FAILED(regfunc(NULL)))
                    DBG_WARN("LCE register server failed!");

            FreeLibrary(hLCE);
        }

        // create reg key that SENS needs
        DWORD dwValue = 0;
        WriteRegValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Mobile\\Sens"),
                      TEXT("Configured"), &dwValue, sizeof(DWORD), REG_DWORD);

        // if we're on NT4, call SENS configuration api
        if (g_fIsWinNT)
        {
            HINSTANCE hSENS = LoadLibrary(TEXT("senscfg.dll"));

            if(hSENS)
            {
                SENSREGISTER regfunc;
                regfunc = (SENSREGISTER)GetProcAddress(hSENS, "SensRegister");
                if(regfunc)
                    if (FAILED(regfunc()))
                        DBG_WARN("SENS register server failed!");

                FreeLibrary(hSENS);
            }
        }
    }

    return NOERROR;
}

STDAPI
DllUnregisterServer(void)
{
    HRESULT hr;

    hr = OfflineFolderUnregisterServer();
    hr = CallRegInstall("UnReg");

    // do external unregister stuff on non-NT5 platforms
    if(FALSE == g_fIsWinNT5) {

        // unregister SENS on NT4
        if(g_fIsWinNT){
            HINSTANCE hSENS = LoadLibrary(TEXT("senscfg.dll"));
            if(hSENS) {
                SENSREGISTER regfunc;
                regfunc = (SENSREGISTER)GetProcAddress(hSENS, "SensUnregister");
                if(regfunc)
                    regfunc();
                FreeLibrary(hSENS);
            }
        }

        // unregister LCE
        HINSTANCE hLCE = LoadLibrary(TEXT("estier2.dll"));
        if(hLCE) {
            LCEUNREGISTER unregfunc;
            unregfunc = (LCEUNREGISTER)GetProcAddress(hLCE, "LCEUnregisterServer");
            if(unregfunc)
                unregfunc(NULL);
            FreeLibrary(hLCE);
        }

        // Remove Sens key
        SHDeleteKey( HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Mobile\\Sens") );
    }

    return hr;
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = S_OK;
    typedef enum { InstallNone, InstallPolicies, InstallPerUser } InstallType;
    
    InstallType installType = InstallNone;
    
    if (pszCmdLine && *pszCmdLine)
    {
        //
        // Setup will call DllInstall by running 'regsvr32 /n /i:Policy webcheck.dll'.
        // This tells webcheck to process the Infodelivery Admin Policies.
        //
        if (0 == StrCmpIW(pszCmdLine, TEXTW("policy")))
        {
            installType = InstallPolicies;
        }
        else if (0 == StrCmpIW(pszCmdLine, TEXTW("U")))
        {
            installType = InstallPerUser;
        }
    }

    if (bInstall && (installType != InstallNone))
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            switch (installType)
            {
                case InstallPolicies:
                    hr = ProcessInfodeliveryPolicies();
                    break;

                case InstallPerUser:
                    hr = ConvertIE4Subscriptions();
                    DBGASSERT(SUCCEEDED(hr), "webcheck DllInstall - Failed to convert notification manager subscriptions");
                    break;
            }
        }

        CoUninitialize();
    }

    return SUCCEEDED(hr) ? S_OK : hr;    
}    


//////////////////////////////////////////////////////////////////////////
//
// Helper functions for Subscription Store
//
//////////////////////////////////////////////////////////////////////////
// Can return S_OK with NULL bstr
HRESULT ReadBSTR(ISubscriptionItem *pItem, LPCWSTR szName, BSTR *bstrRet)
{
    ASSERT(pItem && bstrRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_BSTR))
    {
        *bstrRet = Val.bstrVal;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        *bstrRet = NULL;
        return E_INVALIDARG;
    }
}

// Cannot return S_OK with emptry string
HRESULT ReadOLESTR(ISubscriptionItem *pItem, LPCWSTR szName, LPWSTR *ppszRet)
{
    HRESULT hr;
    BSTR bstrRet = NULL;
    *ppszRet = NULL;
    hr = ReadBSTR(pItem, szName, &bstrRet);
    if (SUCCEEDED(hr) && bstrRet && bstrRet[0])
    {
        int len = (lstrlenW(bstrRet) + 1) * sizeof(WCHAR);
        *ppszRet = (LPWSTR) CoTaskMemAlloc(len);
        if (*ppszRet)
        {
            CopyMemory(*ppszRet, bstrRet, len);
        }
    }
    
    SAFEFREEBSTR(bstrRet);
    if (*ppszRet)
        return S_OK;
    else
        return E_FAIL;
}

HRESULT ReadAnsiSTR(ISubscriptionItem *pItem, LPCWSTR szName, LPSTR *ppszRet)
{
    HRESULT hr;
    BSTR bstrRet = NULL;
    *ppszRet = NULL;
    hr = ReadBSTR(pItem, szName, &bstrRet);
    if (SUCCEEDED(hr) && bstrRet && bstrRet[0])
    {
        // Don't forget to allocate a long string for DBCS.
        int len = (lstrlenW(bstrRet) + 1) * sizeof(CHAR) * 2;
        *ppszRet = (LPSTR) MemAlloc(LMEM_FIXED, len);
        if (*ppszRet)
        {
            SHUnicodeToAnsi(bstrRet, *ppszRet, len);
        }
    }
    
    SAFEFREEBSTR(bstrRet);
    if (*ppszRet)
        return S_OK;
    else
        return E_FAIL;
}

HRESULT ReadBool(ISubscriptionItem *pItem, LPCWSTR szName, VARIANT_BOOL *pBoolRet)
{
    ASSERT(pItem && pBoolRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    // accept VT_I4 or VT_BOOL
    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_BOOL || Val.vt==VT_I4))
    {
        if (Val.vt==VT_I4)
        {
            if (Val.lVal)
                *pBoolRet = VARIANT_TRUE;
            else
                *pBoolRet = VARIANT_FALSE;
        }
        else
            *pBoolRet = Val.boolVal;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

HRESULT ReadSCODE(ISubscriptionItem *pItem, LPCWSTR szName, SCODE *pscRet)
{
    ASSERT(pItem && pscRet);

    VARIANT Val;

    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) && Val.vt == VT_ERROR)
    {
        *pscRet = Val.scode;
        return S_OK;
    }
    else
    {
        VariantClear(&Val);
        return E_INVALIDARG;
    }
}

HRESULT WriteEMPTY(ISubscriptionItem *pItem, LPCWSTR szName)
{
    ASSERT(pItem);

    VARIANT Val;

    Val.vt = VT_EMPTY;
    return pItem->WriteProperties(1, &szName, &Val);
}

HRESULT WriteSCODE(ISubscriptionItem *pItem, LPCWSTR szName, SCODE scVal)
{
    ASSERT(pItem);

    VARIANT Val;

    Val.vt = VT_ERROR;
    Val.scode = scVal;

    return pItem->WriteProperties(1, &szName, &Val);
}
    
HRESULT ReadDWORD(ISubscriptionItem *pItem, LPCWSTR szName, DWORD *pdwRet)
{
    ASSERT(pItem && pdwRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_I4 || Val.vt==VT_I2))
    {
        if (Val.vt==VT_I4)
            *pdwRet = (DWORD) Val.lVal;
        else
            *pdwRet = (DWORD) Val.iVal;

        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

HRESULT ReadLONGLONG(ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG *pllRet)
{
    ASSERT(pItem && pllRet);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) &&
            (Val.vt==VT_CY))
    {
        *pllRet = *((LONGLONG *) &(Val.cyVal));

        return S_OK;
    }
    else
    {
        *pllRet = 0;
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}
    
HRESULT ReadGUID(ISubscriptionItem *pItem, LPCWSTR szName, GUID *pGuid)
{
    ASSERT(pItem && pGuid);

    BSTR    bstrGUID = NULL;
    HRESULT hr = E_INVALIDARG;
    
    if (SUCCEEDED(ReadBSTR(pItem, szName, &bstrGUID)) &&
        SUCCEEDED(CLSIDFromString(bstrGUID, pGuid)))
    {
        hr = NOERROR;
    }
    SAFEFREEBSTR(bstrGUID);

    return hr;
}

HRESULT WriteGUID(ISubscriptionItem *pItem, LPCWSTR szName, GUID *pGuid)
{
    ASSERT(pItem && pGuid);
    
    WCHAR   wszCookie[GUIDSTR_MAX];

#ifdef DEBUG
    int len = 
#endif
    StringFromGUID2(*pGuid, wszCookie, ARRAYSIZE(wszCookie));
    ASSERT(GUIDSTR_MAX == len);
    return WriteOLESTR(pItem, szName, wszCookie);
}

HRESULT WriteLONGLONG(ISubscriptionItem *pItem, LPCWSTR szName, LONGLONG llVal)
{
    VARIANT Val;

    Val.vt = VT_CY;
    Val.cyVal = *((CY *) &llVal);

    return pItem->WriteProperties(1, &szName, &Val);
}

HRESULT WriteDWORD(ISubscriptionItem *pItem, LPCWSTR szName, DWORD dwVal)
{
    VARIANT Val;

    Val.vt = VT_I4;
    Val.lVal = dwVal;

    return pItem->WriteProperties(1, &szName, &Val);
}

HRESULT ReadDATE(ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal)
{
    ASSERT(pItem && dtVal);

    VARIANT     Val;
    
    Val.vt = VT_EMPTY;

    if (SUCCEEDED(pItem->ReadProperties(1, &szName, &Val)) && (Val.vt==VT_DATE))
    {
        *dtVal = Val.date;
        return S_OK;
    }
    else
    {
        VariantClear(&Val); // free any return value of wrong type
        return E_INVALIDARG;
    }
}

HRESULT WriteDATE(ISubscriptionItem *pItem, LPCWSTR szName, DATE *dtVal)
{
    VARIANT Val;

    Val.vt = VT_DATE;
    Val.date= *dtVal;

    return pItem->WriteProperties(1, &szName, &Val);
}

HRESULT ReadVariant     (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarRet)
{
    ASSERT(pvarRet->vt == VT_EMPTY);
    return pItem->ReadProperties(1, &szName, pvarRet);
}

HRESULT WriteVariant    (ISubscriptionItem *pItem, LPCWSTR szName, VARIANT *pvarVal)
{
    return pItem->WriteProperties(1, &szName, pvarVal);
}

HRESULT WriteOLESTR(ISubscriptionItem *pItem, LPCWSTR szName, LPCWSTR szVal)
{
    VARIANT Val;

    Val.vt = VT_BSTR;
    Val.bstrVal = SysAllocString(szVal);

    HRESULT hr = pItem->WriteProperties(1, &szName, &Val);

    SysFreeString(Val.bstrVal);

    return hr;
}

HRESULT WriteAnsiSTR(ISubscriptionItem *pItem, LPCWSTR szName, LPCSTR szVal)
{
    VARIANT Val;
    BSTR    bstrVal;
    HRESULT hr;

    bstrVal = SysAllocStringByteLen(szVal, lstrlenA(szVal));
    if (bstrVal)
    {
        Val.vt = VT_BSTR;
        Val.bstrVal = bstrVal;

        hr = pItem->WriteProperties(1, &szName, &Val);

        SysFreeString(bstrVal);
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT WriteResSTR(ISubscriptionItem *pItem, LPCWSTR szName, UINT uID)
{
    TCHAR szString[MAX_RES_STRING_LEN];

    if (MLLoadString(uID, szString, ARRAYSIZE(szString)))
    {
        return WriteTSTR(pItem, szName, szString);
    }

    return E_INVALIDARG;
}


DWORD LogEvent(LPTSTR pszFormat, ...)
{

    // check registry if necessary
    if(FALSE == g_fCheckedForLog) {

        TCHAR   pszFilePath[MAX_PATH];

        if(ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, TEXT("LoggingFile"),
                pszFilePath, sizeof(pszFilePath))) {

            int nLen = lstrlen(pszFilePath) + 1;
            g_pszLoggingFile = new TCHAR[nLen];
            if(g_pszLoggingFile) {
                StrCpyN(g_pszLoggingFile, pszFilePath, nLen);
            }
        }

        g_fCheckedForLog = TRUE;
    }

    if(g_pszLoggingFile) {

        TCHAR       pszString[MAX_PATH+INTERNET_MAX_URL_LENGTH];
        SYSTEMTIME  st;
        HANDLE      hLog;
        DWORD       dwWritten;
        va_list     va;

        hLog = CreateFile(g_pszLoggingFile, GENERIC_WRITE, 0, NULL,
                OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        if(INVALID_HANDLE_VALUE == hLog)
            return GetLastError();

        // seek to end of file
        SetFilePointer(hLog, 0, 0, FILE_END);

        // dump time
        GetLocalTime(&st);
        wnsprintf(pszString, ARRAYSIZE(pszString), TEXT("\r\n%02d:%02d:%02d - "), st.wHour, st.wMinute, st.wSecond);
        WriteFile(hLog, pszString, lstrlen(pszString), &dwWritten, NULL);

        // dump passed in string
        va_start(va, pszFormat);
        wvnsprintf(pszString, ARRAYSIZE(pszString), pszFormat, va);
        va_end(va);
        WriteFile(hLog, pszString, lstrlen(pszString), &dwWritten, NULL);

        // clean up
        CloseHandle(hLog);
    }

    return 0;
}

// Functions related to saving and restoring user passwords from the pstore.


// We have wrappers around Create and Release to allow for future caching of the pstore
// instance within webcheck. 

STDAPI CreatePStore(IPStore **ppIPStore)
{
    HRESULT hr;

    hr = PStoreCreateInstance ( ppIPStore,
                                IsEqualGUID(s_provID, GUID_NULL) ? NULL : &s_provID,
                                NULL,
                                0);
    return hr;
}


STDAPI ReleasePStore(IPStore *pIPStore)
{
    HRESULT hr;

    if (pIPStore)
    {
        pIPStore->Release();
        hr = S_OK;
    }
    else
    {
        hr = E_POINTER;
    }

    return hr;
}

// Given a field name this figures out the type and sub-type in the pstore
// that should be queried. Currently these are hard-coded.
STDAPI GetPStoreTypes(LPCWSTR /* wszField */, GUID * pguidType, GUID * pguidSubType)
{
    *pguidType = GUID_PStoreType;
    *pguidSubType = GUID_NULL;

    return S_OK;
}


STDAPI  ReadNotificationPassword(LPCWSTR wszUrl, BSTR *pbstrPassword)
{
    GUID             itemType = GUID_NULL;
    GUID             itemSubtype = GUID_NULL;
    PST_PROMPTINFO   promptInfo = {0};
    IPStore*         pStore = NULL;
    HRESULT          hr ;
     
    if (wszUrl == NULL || pbstrPassword == NULL)
        return E_POINTER;

    // Will return NULL if there is no password entry or we 
    // fail for some reason. 
    *pbstrPassword = NULL;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.szPrompt = NULL;
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = NULL;
    
    hr = CreatePStore(&pStore);    

    if (SUCCEEDED(hr))
    {
        ASSERT(pStore != NULL);
        hr = GetPStoreTypes(wszUrl, &itemType, &itemSubtype);

        if (SUCCEEDED(hr))
        {
            DWORD   cbData;
            BYTE *  pbData = NULL;

            hr = pStore->ReadItem(
                            s_Key,
                            &itemType,
                            &itemSubtype,
                            wszUrl,
                            &cbData,
                            &pbData,
                            &promptInfo,
                            0);

            if (SUCCEEDED(hr))
            {
                *pbstrPassword = SysAllocString((OLECHAR *)pbData);
                CoTaskMemFree(pbData);
                hr = S_OK;
            }
        }

        ReleasePStore(pStore);
    }

    return hr;
}

STDAPI WriteNotificationPassword(LPCWSTR wszUrl, BSTR bstrPassword)
{
    HRESULT         hr;
    PST_TYPEINFO    typeInfo;
    PST_PROMPTINFO  promptInfo;
    IPStore *       pStore;

    if (wszUrl == NULL)
        return E_POINTER;

    typeInfo.cbSize = sizeof(typeInfo);


    typeInfo.szDisplayName = c_szInfoDel;

    promptInfo.cbSize = sizeof(promptInfo);
    promptInfo.dwPromptFlags = 0;
    promptInfo.hwndApp = NULL;
    promptInfo.szPrompt = NULL;

    hr = CreatePStore(&pStore);

    if (SUCCEEDED(hr))
    {
        GUID itemType = GUID_NULL;
        GUID itemSubtype = GUID_NULL;

        ASSERT(pStore != NULL);

        hr = GetPStoreTypes(wszUrl, &itemType, &itemSubtype);
                
        if (SUCCEEDED(hr))
        {
            hr = pStore->CreateType(s_Key, &itemType, &typeInfo, 0);

            // PST_E_TYPE_EXISTS implies type already exists which is just fine
            // by us.
            if (SUCCEEDED(hr) || hr == PST_E_TYPE_EXISTS)
            {
                typeInfo.szDisplayName = c_szSubscriptions;

                hr = pStore->CreateSubtype(
                                        s_Key,
                                        &itemType,
                                        &itemSubtype,
                                        &typeInfo,
                                        NULL,
                                        0);

                if (SUCCEEDED(hr) || hr == PST_E_TYPE_EXISTS)
                {
                    if (bstrPassword != NULL)
                    {
                        hr = pStore->WriteItem(
                                            s_Key,
                                            &itemType,
                                            &itemSubtype,
                                            wszUrl,
                                            ((lstrlenW(bstrPassword)+1) * sizeof(WCHAR)),
                                            (BYTE *)bstrPassword,
                                            &promptInfo,
                                            PST_CF_NONE,
                                            0);
                    }
                    else
                    {
                        hr = pStore->DeleteItem(
                                            s_Key,
                                            &itemType,
                                            &itemSubtype,
                                            wszUrl,
                                            &promptInfo,
                                            0);
                    }
                }
            }
        }
        
        ReleasePStore(pStore);
    }
    
    return hr;
}                                                                       


HRESULT WritePassword(ISubscriptionItem *pItem, BSTR bstrPassword)
{
    BSTR    bstrURL = NULL;
    HRESULT hr = E_FAIL;

    hr = ReadBSTR(pItem, c_szPropURL, &bstrURL);
    RETURN_ON_FAILURE(hr);

    hr = WriteNotificationPassword(bstrURL, bstrPassword);
    SAFEFREEBSTR(bstrURL);
    return hr;
}

HRESULT ReadPassword(ISubscriptionItem *pItem, BSTR * pBstrPassword)
{
    BSTR    bstrURL = NULL;
    HRESULT hr = E_FAIL;

    hr = ReadBSTR(pItem, c_szPropURL, &bstrURL);
    RETURN_ON_FAILURE(hr);

    ASSERT(pBstrPassword);
    hr = ReadNotificationPassword(bstrURL, pBstrPassword);
    SAFEFREEBSTR(bstrURL);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\atlwraps.h ===
//-------------------------------------------------------------------------//
// atlwraps.h : API Wrap decls
//-------------------------------------------------------------------------//

#ifndef __ATLWRAPS_H__
#define __ATLWRAPS_H__

#define wsprintfW           wsprintfWrapW
#define GetClassInfoExW     GetClassInfoExWrapW

#endif __ATLWRAPS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\dll\makefile.inc ===
..\webcheck.rc : $(SDK_LIB_PATH)\webcheck.tlb $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\wizards.h ===
#ifndef __wizards_h
#define __wizards_h

HRESULT CreateWizard(HWND hwndParent, SUBSCRIPTIONTYPE subType, POOEBuf pOOE);


#endif //__wizards_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\webcrawl.h ===
#ifndef _WEBCRAWL_H
#define _WEBCRAWL_H

#include "strlist.h"

//////////////////////////////////////////////////////////////////////////
//
// Webcrawler object
//
//////////////////////////////////////////////////////////////////////////
class CCodeBaseHold 
{
public:
    LPWSTR          szDistUnit;
    DWORD           dwVersionMS;
    DWORD           dwVersionLS;
    DWORD           dwFlags;
};

class CWebCrawler : public CDeliveryAgent,
                    public CUrlDownloadSink,
                    public CRunDeliveryAgentSink
{
protected:
    class  CDownloadNotify;

public:
    // internal flag used to run in offline mode
    enum { WEBCRAWL_PRIV_OFFLINE_MODE = 0x80000000 };
protected:
// properties
    BSTR            m_bstrBaseURL;
    DWORD           m_dwRecurseFlags;
    DWORD           m_dwRecurseLevels;
    DWORD           m_dwMaxSize;            
    LPTSTR          m_pszLocalDest;         // local destination (instead of cache)

// other data
    CWCStringList  *m_pPages;          // always valid during update.
    CWCStringList  *m_pRobotsTxt;      // array of robots.txt arrays, may be NULL
    CWCStringList  *m_pPendingLinks;   // Links from last page to be added to m_pPages
    CWCStringList  *m_pDependencyLinks;// Links from last page to be downloaded now
    CWCStringList  *m_pCodeBaseList;   // List of CodeBase URL's to Crawl
                                       // Dword is ptr to CCodeBaseHold

    CRITICAL_SECTION m_critDependencies;
    HRESULT         m_hrCritDependencies;
    CWCStringList  *m_pDependencies;   // all dependencies downloaded
    int             m_iDependenciesProcessed;

    DWORD           m_dwPendingRecurseLevel;   // # to recurse from pending links

    DWORD           m_dwCurSize;    // currently downloaded in BYTES

    GROUPID         m_llCacheGroupID;
    GROUPID         m_llOldCacheGroupID;

    IExtractIcon*   m_pUrlIconHelper;

    int             m_iPagesStarted;    // # m_pPages started
    int             m_iRobotsStarted;   // # m_pRobotsTxt started
    int             m_iDependencyStarted;// # m_pDependencyLinks started
    int             m_iTotalStarted;    // # any toplevel url started
    int             m_iCodeBaseStarted; // # of codebases started

    BSTR            m_bstrHostName;     // host name from first url

    long            m_lMaxNumUrls;      // is -1 until we know total # pages

    int             m_iDownloadErrors;  // have we had any download failures?
    int             m_iSkippedByRobotsTxt; // how many skipped by robots.txt?

    CUrlDownload   *m_pCurDownload;     // current download
    CDownloadNotify     *m_pDownloadNotify; // to get urls downloaded on a page

    int             m_iCurDownloadStringIndex;
    CWCStringList  *m_pCurDownloadStringList;   // can be: m_pRobotsTxt, Pages, CodeBaseList

    int             m_iNumPagesDownloading; // 0 or 1

    BOOL            m_fHasInitCookie;   // One time deal, don't try again.

    // For change detection
    VARIANT         m_varChange;

    CRunDeliveryAgent *m_pRunAgent;      // host CDL/Channel agent
    BOOL            m_fCDFDownloadInProgress;

    // other flags
    enum {
        FLAG_CRAWLCHANGED = 0x80000000, // have we found a change in the crawl?
        FLAG_HEADONLY     = 0x40000000, // should we only get the HEAD data?
    };

// private member functions
    BOOL        IsRecurseFlagSet(DWORD dwFlag) { return dwFlag & m_dwRecurseFlags; }

static HRESULT CheckLink(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwThis, DWORD *pdwStringData);
static HRESULT CheckFrame(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwBaseUrl, DWORD *pdwStringData);
static HRESULT CheckImageOrLink(IUnknown *punkItem, BSTR *pbstrItem, DWORD_PTR dwEnumDep, DWORD *pdwStringData);

    HRESULT     MatchNames(BSTR bstrName, BOOL fPassword);
    HRESULT     FindAndSubmitForm(void);

    void        CheckOperationComplete(BOOL fOperationComplete);

    void        FreeRobotsTxt();
    void        FreeCodeBaseList();

private:
    ~CWebCrawler(void);
    CWebCrawler(void);
    HRESULT Initialize();

public:
    static HRESULT CreateInstance(IUnknown *punkOuter, IUnknown **ppunk);
   
    // CUrlDownloadSink
    HRESULT     OnDownloadComplete(UINT iID, int iError);
    HRESULT     OnClientPull(UINT iID, LPCWSTR pwszOldURL, LPCWSTR pwszNewURL);
    HRESULT     OnAuthenticate(HWND *phwnd, LPWSTR *ppszUsername, LPWSTR *ppszPassword);
    HRESULT     OnOleCommandTargetExec(const GUID *pguidCmdGroup, DWORD nCmdID,
                                DWORD nCmdexecopt, VARIANTARG *pvarargIn, 
                                VARIANTARG *pvarargOut);
    HRESULT     GetDownloadNotify(IDownloadNotify **ppOut);

    // virtual functions overriding CDeliveryAgent
    HRESULT     AgentPause(DWORD dwFlags);
    HRESULT     AgentResume(DWORD dwFlags);
    HRESULT     AgentAbort(DWORD dwFlags);
    STDMETHODIMP GetIconLocation(UINT, LPTSTR, UINT, int *, UINT *);
    STDMETHODIMP Extract(LPCTSTR, UINT, HICON *, HICON *, UINT);

    // CRunDeliveryAgentSink
    HRESULT     OnAgentEnd(const SUBSCRIPTIONCOOKIE *, long, HRESULT, LPCWSTR, BOOL);

protected:
    // CDeliveryAgent overrides
    HRESULT     ModifyUpdateEnd(ISubscriptionItem *pEndItem, UINT *puiRes);
    HRESULT     StartOperation();
    HRESULT     StartDownload();
    void        CleanUp();

    void        _CleanUp();

    // members used during download
    HRESULT     GetRealUrl(int iPageIndex, LPWSTR *ppwszThisUrl);
    HRESULT     MakePageStickyAndGetSize(LPCWSTR pwszURL, DWORD *pdwSize, BOOL *pfDiskFull);
    HRESULT     GetLinksFromPage();
    HRESULT     GetDependencyLinksFromPage(LPCWSTR pwszThisUrl, DWORD dwRecurse);
    HRESULT     ProcessDependencyLinks(CWCStringList **ppslUrls, int *piStarted);
    HRESULT     ProcessPendingLinks();
    HRESULT     ParseRobotsTxt(LPCWSTR pwszRobotsTxtURL, CWCStringList **ppslRet);
    HRESULT     GetRobotsTxtIndex(LPCWSTR pwszUrl, BOOL fAddToList, DWORD *pdwRobotsTxtIndex);
    HRESULT     ValidateWithRobotsTxt(LPCWSTR pwszUrl, int iRobotsIndex, BOOL *pfAllow);


    HRESULT     StartNextDownload();
    HRESULT     StartCDFDownload(WCHAR *pwszCDFURL, WCHAR *pwszBaseUrl);
    HRESULT     ActuallyStartDownload(CWCStringList *pslUrls, int iIndex, BOOL fReStart=FALSE);
    HRESULT     ActuallyDownloadCodeBase(CWCStringList *pslUrls, int iIndex, BOOL fReStart=FALSE);

static HRESULT  GetHostName(LPCWSTR pwszThisUrl, BSTR *pbstrHostName);

    inline HRESULT GetChannelItem(ISubscriptionItem **ppChannelItem);

public:
    // Callbacks from CDownloadNotify (free threaded)
    HRESULT DownloadStart(LPCWSTR pchUrl, DWORD dwDownloadId, DWORD dwType, DWORD dwReserved);
    HRESULT DownloadComplete(DWORD dwDownloadId, HRESULT hrNotify, DWORD dwReserved);

protected:
    class CDownloadNotify : public IDownloadNotify
    {
    public:
        CDownloadNotify(CWebCrawler *pParent);
        ~CDownloadNotify();
        HRESULT Initialize();

        void LeaveMeAlone();

    protected:
        long             m_cRef;
        CWebCrawler     *m_pParent; // we keep a reference
        CRITICAL_SECTION m_critParent;
        HRESULT          m_hrCritParent;

    public:
        // IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, void **ppunk);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        // IDownloadNotify
        STDMETHODIMP         DownloadStart(LPCWSTR pchUrl, DWORD dwDownloadId, DWORD dwType, DWORD dwReserved);
        STDMETHODIMP         DownloadComplete(DWORD dwDownloadId, HRESULT hrNotify, DWORD dwReserved);
    };
};

//////////////////////////////////////////////////////////////////////////
//
//  CHelperOM
//
// Helps with MSHTML object model
//////////////////////////////////////////////////////////////////////////

class CHelperOM
{
    IHTMLDocument2  *m_pDoc;

public:
    typedef enum {
        CTYPE_LINKS,    // Get all links (<a href>) on a page
        CTYPE_MAPS,     // Get all maps on page
        CTYPE_MAP,      // Get all links within a map
        CTYPE_META,     // Get meta tags (name\ncontent)
        CTYPE_FRAMES,   // Get all frame urls on a page
    } CollectionType;

    typedef HRESULT (*PFNHELPERCALLBACK)(IUnknown *punkItem, /*inout*/BSTR *pbstrURL, DWORD_PTR dwCBData, DWORD *pdwStringData);
    typedef PFNHELPERCALLBACK PFN_CB;

public:
    CHelperOM(IHTMLDocument2 *pDoc);
    ~CHelperOM();

    static HRESULT GetTagCollection(
                        IHTMLDocument2          *pDoc,
                        LPCWSTR                  wszTagName,
                        IHTMLElementCollection **ppCollection);

//  static HRESULT WinFromDoc(IHTMLDocument2 *pDoc, IHTMLWindow2 **ppWin);

    static HRESULT GetCollection (IHTMLDocument2 *pDoc, CWCStringList *psl, CollectionType Type, PFN_CB pfnCB, DWORD_PTR dwData);
    static HRESULT EnumCollection(IHTMLElementCollection *pCollection,
                                  CWCStringList *pStringList, CollectionType Type, PFN_CB pfnCB, DWORD_PTR dwData);

    HRESULT GetTagCollection(LPCWSTR wszTagName, IHTMLElementCollection **ppCollection)
    { return GetTagCollection(m_pDoc, wszTagName, ppCollection); }
    HRESULT	GetCollection(CWCStringList *psl, CollectionType Type, PFN_CB pfnCB, DWORD_PTR dwData)
    { return GetCollection(m_pDoc, psl, Type, pfnCB, dwData); }

protected:
    static HRESULT _GetCollection(IHTMLDocument2 *pDoc, CWCStringList *psl, CollectionType Type, PFN_CB pfnCB, DWORD_PTR dwData);
};

#endif _WEBCRAWL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webcheck\wizards.cpp ===
#include "private.h"
#include "offl_cpp.h"
#include "helper.h"

#include <mluisupp.h>
#include "apithk.h"

//  REARCHITECT: (tnoonan) This whole file needs some cleanup - starting with a base dialog class.

const TCHAR  c_szStrEmpty[] = TEXT("");

const TCHAR  c_szStrBoot[] = TEXT("boot");
const TCHAR  c_szStrScrnSave[] = TEXT("scrnsave.exe");
const TCHAR  c_szStrSystemIni[] = TEXT("system.ini");
const TCHAR  c_szShowWelcome[] = TEXT("ShowWelcome");

extern BOOL CALLBACK MailOptionDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
extern void ReadDefaultEmail(LPTSTR, UINT);
extern BOOL CALLBACK LoginOptionDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
extern void ReadDefaultEmail(LPTSTR szBuf, UINT cch);
extern void ReadDefaultSMTPServer(LPTSTR szBuf, UINT cch);

INT_PTR CALLBACK WelcomeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK DownloadDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK PickScheduleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK NewScheduleWizDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LoginDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

#define WIZPAGE_NOINTRO         0x0001
#define WIZPAGE_NODOWNLOAD      0x0002
#define WIZPAGE_NOLOGIN         0x0004

struct WizInfo 
{
    SUBSCRIPTIONTYPE    subType;
    POOEBuf             pOOE;
    DWORD               dwExceptFlags;
    BOOL                bShowWelcome;
    BOOL                bIsNewSchedule;
    NOTIFICATIONCOOKIE  newCookie;
};

struct WizPage
{
    int     nResourceID;
    DLGPROC dlgProc;
    DWORD   dwExceptFlags;
};

const WizPage WizPages[] =
{
    { IDD_WIZARD0, WelcomeDlgProc,          WIZPAGE_NOINTRO         },   
    { IDD_WIZARD1, DownloadDlgProc,         WIZPAGE_NODOWNLOAD      },
    { IDD_WIZARD2, PickScheduleDlgProc,     0                       },
    { IDD_WIZARD3, NewScheduleWizDlgProc,   0                       },
    { IDD_WIZARD4, LoginDlgProc,            WIZPAGE_NOLOGIN         }
};

//  Helper functions

inline BOOL IsDesktop(SUBSCRIPTIONTYPE subType)
{
    return (subType == SUBSTYPE_DESKTOPURL) || (subType == SUBSTYPE_DESKTOPCHANNEL);
}

inline BOOL IsChannel(SUBSCRIPTIONTYPE subType)
{
    return (subType == SUBSTYPE_CHANNEL) || (subType == SUBSTYPE_DESKTOPCHANNEL);
}

inline DWORD GetShowWelcomeScreen()
{
    DWORD dwShowWelcome = TRUE;
    
    ReadRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szShowWelcome, &dwShowWelcome, sizeof(dwShowWelcome));

    return dwShowWelcome;
}

inline void SetShowWelcomeScreen(DWORD dwShowWelcome)
{
    WriteRegValue(HKEY_CURRENT_USER, c_szRegKey, c_szShowWelcome, &dwShowWelcome, sizeof(DWORD), REG_DWORD);
}

//
//  Explanation of logic for the back/next/finish button
//
//  Wiz0 - welcome
//  Wiz1 - download
//  Wiz2 - pick schedule
//  Wiz3 - create schedule
//  Wiz4 - login
//
// A state machine can be derived to determine the different possibilities.
// The resulting state table is as follows:
//
// Wiz0:    Always has next button
//
// Wiz1:    Show back if Wiz0 was shown
//          Always has next button
//
// Wiz2:    Show back if Wiz0 or Wiz1 was shown
//          Show next if create new schedule or show login, otherwise show finish
//
// Wiz3:    Always has back button
//          Show next if show login, otherwise show finish
//
// Wiz4:    Always has back button
//          Always has finish button
//

void SetWizButtons(HWND hDlg, INT_PTR resID, WizInfo *pwi)
{
    DWORD dwButtons;

    switch (resID)
    {
        case IDD_WIZARD0:
            dwButtons = PSWIZB_NEXT;
            break;
            
        case IDD_WIZARD1:
            dwButtons = PSWIZB_NEXT;
            if (pwi && !(pwi->dwExceptFlags & WIZPAGE_NOINTRO))
            {
                dwButtons |= PSWIZB_BACK;
            }
            break;

        case IDD_WIZARD2:
            if (pwi && ((!(pwi->dwExceptFlags & WIZPAGE_NODOWNLOAD)) ||
                       (!(pwi->dwExceptFlags & WIZPAGE_NOINTRO))))
            {
                dwButtons = PSWIZB_BACK;
            }
            else
            {
                dwButtons = 0;
            }

            dwButtons |= (pwi && (pwi->bIsNewSchedule || (!(pwi->dwExceptFlags & WIZPAGE_NOLOGIN))))
                         ? PSWIZB_NEXT : PSWIZB_FINISH;
            break;

        case IDD_WIZARD3:
            dwButtons = PSWIZB_BACK | 
                        ((pwi && (!(pwi->dwExceptFlags & WIZPAGE_NOLOGIN))) ? PSWIZB_NEXT : PSWIZB_FINISH);
            break;

        case IDD_WIZARD4:
            dwButtons = PSWIZB_BACK | PSWIZB_FINISH;
            break;

        default:
            dwButtons = 0;
            ASSERT(FALSE);
            break;
    }
    
    PropSheet_SetWizButtons(GetParent(hDlg), dwButtons);
}

HRESULT CreateAndAddPage(PROPSHEETHEADER& psh, PROPSHEETPAGE& psp, int nPageIndex, DWORD dwExceptFlags)
{
    HRESULT hr = S_OK;
    
    if (!(WizPages[nPageIndex].dwExceptFlags & dwExceptFlags))
    {
        psp.pszTemplate = MAKEINTRESOURCE(WizPages[nPageIndex].nResourceID);
        psp.pfnDlgProc = WizPages[nPageIndex].dlgProc;

        HPROPSHEETPAGE hpage = Whistler_CreatePropertySheetPageW(&psp);

        if (NULL != hpage)
        {
            psh.phpage[psh.nPages++] = hpage;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CreateWizard(HWND hwndParent, SUBSCRIPTIONTYPE subType, POOEBuf pOOE)
{
    HRESULT hr = S_OK;
    UINT i;
    HPROPSHEETPAGE hPropPage[ARRAYSIZE(WizPages)];
    PROPSHEETPAGE psp = { 0 };
    PROPSHEETHEADER psh = { 0 };
    WizInfo wi;

    ASSERT(NULL != pOOE);
    ASSERT((subType >= SUBSTYPE_URL) && (subType <= SUBSTYPE_DESKTOPCHANNEL));

    wi.subType = subType;
    wi.pOOE = pOOE;
    wi.dwExceptFlags = 0;
    wi.bShowWelcome = GetShowWelcomeScreen();
    wi.bIsNewSchedule = FALSE;

    if (FALSE == wi.bShowWelcome)
    {
        wi.dwExceptFlags |= WIZPAGE_NOINTRO;
    }

    if (IsDesktop(subType))
    {
        wi.dwExceptFlags |= WIZPAGE_NODOWNLOAD;
    }

    if ((pOOE->bChannel && (!pOOE->bNeedPassword)) || 
        SHRestricted2W(REST_NoSubscriptionPasswords, NULL, 0))
    {
        wi.dwExceptFlags |= WIZPAGE_NOLOGIN;
    }

    // initialize propsheet header.
    psh.dwSize      = sizeof(PROPSHEETHEADER);
    psh.dwFlags     = PSH_WIZARD;
    psh.hwndParent  = hwndParent;
    psh.pszCaption  = NULL;
    psh.hInstance   = MLGetHinst();
    psh.nPages      = 0;
    psh.nStartPage  = 0;
    psh.phpage      = hPropPage;

    // initialize propsheet page.
    psp.dwSize          = sizeof(PROPSHEETPAGE);
    psp.dwFlags         = PSP_DEFAULT;
    psp.hInstance       = MLGetHinst();
    psp.pszIcon         = NULL;
    psp.pszTitle        = NULL;
    psp.lParam          = (LPARAM)&wi;

    for (i = 0; (i < ARRAYSIZE(WizPages)) && (SUCCEEDED(hr)); i++)
    {
        hr = CreateAndAddPage(psh, psp, i, wi.dwExceptFlags);
    }

    if (SUCCEEDED(hr))
    {
        // invoke the property sheet
        INT_PTR nResult = PropertySheet(&psh);

        if (nResult > 0)
        {
            SetShowWelcomeScreen(wi.bShowWelcome);
            hr = S_OK;
        }
        else if (nResult == 0)
        {
            hr = E_ABORT;
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        for (i = 0; i < psh.nPages; i++)
        {
            DestroyPropertySheetPage(hPropPage[i]);
        }
    }

    return hr;
}

//--------------------------------------------------------------------
// Dialog Procs

INT_PTR CALLBACK WelcomeDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    NMHDR FAR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            result = TRUE;
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    
                    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    result = TRUE;
                    break;
                    
                case PSN_KILLACTIVE:

                    if (pWiz)
                    {
                        pWiz->bShowWelcome = !IsDlgButtonChecked(hDlg, IDC_WIZ_DONT_SHOW_INTRO);
                        result = TRUE;
                    }
                    break;
            }
            break;
            
    }

    return result;
}

void EnableLevelsDeep(HWND hwndDlg, BOOL fEnable)
{

    ASSERT(hwndDlg != NULL);

    EnableWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_STATIC1), fEnable);
    EnableWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_STATIC2), fEnable);
    EnableWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_EDIT), fEnable);
    EnableWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_SPIN), fEnable);

    return;

}

//
// shows or hides the UI for specifying the number "levels deep" to recurse
//
void ShowLevelsDeep(HWND hwndDlg, BOOL fShow)
{
    INT nCmdShow = fShow ? SW_SHOW: SW_HIDE;
    ASSERT(hwndDlg != NULL);

    ShowWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_STATIC1), nCmdShow);
    ShowWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_STATIC2), nCmdShow);
    ShowWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_EDIT), nCmdShow);
    ShowWindow(GetDlgItem(hwndDlg,IDC_WIZ_LINKSDEEP_SPIN), nCmdShow);
}

//
// enables or disables the UI for specifying the number "levels deep" to recurse
//
INT_PTR CALLBACK DownloadDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE) GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    POOEBuf  pBuf = pWiz ? pWiz->pOOE : NULL;
    NMHDR FAR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            TCHAR szBuf[256];
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            pWiz = (WizInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
            pBuf = pWiz ? pWiz->pOOE : NULL;
            
            SetListViewToString(GetDlgItem (hDlg, IDC_NAME), pBuf->m_Name);
            SetListViewToString(GetDlgItem (hDlg, IDC_URL), pBuf->m_URL);

            MLLoadString(
                (pWiz && IsChannel(pWiz->subType)) ? IDS_WIZ_GET_LINKS_CHANNEL : IDS_WIZ_GET_LINKS_URL,
                szBuf, ARRAYSIZE(szBuf));

            SetDlgItemText(hDlg, IDC_WIZ_GET_LINKS_TEXT, szBuf);

            int checked;

            if ((pBuf->bChannel && (pBuf->fChannelFlags & CHANNEL_AGENT_PRECACHE_ALL)) ||
                (!pBuf->bChannel && ((pBuf->m_RecurseLevels) > 0)))
            {
                checked = IDC_WIZ_LINKS_YES;
            }
            else
            {
                checked = IDC_WIZ_LINKS_NO;
            }
            
            CheckRadioButton(hDlg, IDC_WIZ_LINKS_YES, IDC_WIZ_LINKS_NO, checked);

            //
            // Initialize the spin control for "levels deep" UI
            //
            HWND hwndLevelsSpin = GetDlgItem(hDlg,IDC_WIZ_LINKSDEEP_SPIN);
            SendMessage(hwndLevelsSpin, UDM_SETRANGE, 0, MAKELONG(MAX_WEBCRAWL_LEVELS, 1));
            SendMessage(hwndLevelsSpin, UDM_SETPOS, 0, pBuf->m_RecurseLevels);
            ShowLevelsDeep(hDlg,!pBuf->bChannel);
            EnableLevelsDeep(hDlg,!pBuf->bChannel && IDC_WIZ_LINKS_YES==checked);

            result = TRUE;
            break;
        }

        case WM_COMMAND:

            switch (HIWORD(wParam))
            {

            case BN_CLICKED:
                
                if (!pBuf->bChannel)
                    switch (LOWORD(wParam))
                    {

                    case IDC_WIZ_LINKS_YES:
                        EnableLevelsDeep(hDlg,TRUE);
                        break;

                    case IDC_WIZ_LINKS_NO:
                        EnableLevelsDeep(hDlg,FALSE);
                        break;

                    }
                break;

            case EN_KILLFOCUS:

                //
                // This code checks for bogus values in the "levels deep"
                // edit control and replaces them with something valid
                //
                if (LOWORD(wParam)==IDC_WIZ_LINKSDEEP_EDIT)
                {
                    BOOL fTranslated = FALSE;
                    UINT cLevels = GetDlgItemInt(hDlg,IDC_WIZ_LINKSDEEP_EDIT,&fTranslated,FALSE);

                    if (!fTranslated || cLevels < 1)
                    {
                        SetDlgItemInt(hDlg,IDC_WIZ_LINKSDEEP_EDIT,1,FALSE);
                    }
                    else if (cLevels > MAX_WEBCRAWL_LEVELS)
                    {
                        SetDlgItemInt(hDlg,IDC_WIZ_LINKSDEEP_EDIT,MAX_WEBCRAWL_LEVELS,FALSE);
                    }

                }

                break;

            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    
                    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    result = TRUE;
                    break;

                case PSN_KILLACTIVE:

                    ASSERT(NULL != pBuf);

                    if (IsDlgButtonChecked(hDlg, IDC_WIZ_LINKS_YES))
                    {
                        if (pWiz && IsChannel(pWiz->subType))
                        {
                            pBuf->fChannelFlags |= CHANNEL_AGENT_PRECACHE_ALL;
                        }
                        else
                        {
                            DWORD dwPos = (DWORD)SendDlgItemMessage(hDlg,IDC_WIZ_LINKSDEEP_SPIN,UDM_GETPOS,0,0);

                            //
                            // Set the m_RecurseLevels field to the given by the
                            // spin control.  HIWORD(dwPos) indicated errror.
                            //
                            if (HIWORD(dwPos))
                                pBuf->m_RecurseLevels = 1;
                            else
                                pBuf->m_RecurseLevels = LOWORD(dwPos);

                            pBuf->m_RecurseFlags |= WEBCRAWL_LINKS_ELSEWHERE;
                        }
                    }
                    else
                    {
                        if (pWiz && IsChannel(pWiz->subType))
                        {
                            pBuf->fChannelFlags &= ~CHANNEL_AGENT_PRECACHE_ALL;
                            pBuf->fChannelFlags |= CHANNEL_AGENT_PRECACHE_SOME;
                        }
                        else
                        {
                            pBuf->m_RecurseLevels = 0;
                            pBuf->m_RecurseFlags &= ~WEBCRAWL_LINKS_ELSEWHERE;
                        }
                    }
                    break;

            }
            break;
            
    }

    return result;
}

void HandleScheduleButtons(HWND hDlg, LPPROPSHEETPAGE lpPropSheet, WizInfo *pWiz)
{
    ASSERT(NULL != lpPropSheet);
    ASSERT(NULL != pWiz);
    
    EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST),
        IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_EXISTING));

    pWiz->bIsNewSchedule = IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_NEW);

    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
}

struct PICKSCHED_LIST_DATA
{
    SYNCSCHEDULECOOKIE SchedCookie;
};

struct PICKSCHED_ENUM_DATA
{
    HWND hwndSchedList;
    POOEBuf pBuf;
    SYNCSCHEDULECOOKIE defSchedule;
    SYNCSCHEDULECOOKIE customSchedule;
    int *pnDefaultSelection;
    BOOL bHasAtLeastOneSchedule:1;
    BOOL bFoundCustomSchedule:1;
};

BOOL PickSched_EnumCallback(ISyncSchedule *pSyncSchedule, 
                            SYNCSCHEDULECOOKIE *pSchedCookie,
                            LPARAM lParam)
{
    BOOL bAdded = FALSE;
    PICKSCHED_ENUM_DATA *psed = (PICKSCHED_ENUM_DATA *)lParam;
    DWORD dwSyncScheduleFlags;
    PICKSCHED_LIST_DATA *psld = NULL;

    ASSERT(NULL != pSyncSchedule);  

    if (SUCCEEDED(pSyncSchedule->GetFlags(&dwSyncScheduleFlags)))
    {
        //  This checks to make sure we only add a publisher's schedule to the
        //  list if it belongs to this item.
        if ((!(dwSyncScheduleFlags & SYNCSCHEDINFO_FLAGS_READONLY)) ||
            (*pSchedCookie == psed->customSchedule))
        {
            psld = new PICKSCHED_LIST_DATA;

            if (NULL != psld)
            {
                WCHAR wszName[MAX_PATH];
                DWORD cchName = ARRAYSIZE(wszName);

                if (SUCCEEDED(pSyncSchedule->GetScheduleName(&cchName, wszName)))
                {
                    TCHAR szName[MAX_PATH];

                    MyOleStrToStrN(szName, ARRAYSIZE(szName), wszName);

                    psed->bHasAtLeastOneSchedule = TRUE;

                    psld->SchedCookie = *pSchedCookie;

                    int index;
                    if (*pSchedCookie == psed->customSchedule)
                    {
                        index = ComboBox_InsertString(psed->hwndSchedList, 0, szName);
                        if ((index >= 0) && (psed->defSchedule == GUID_NULL))
                        {
                            //  Do this always for custom schedules if there
                            //  is no defSchedule set
                            *psed->pnDefaultSelection = index;
                            psed->bFoundCustomSchedule = TRUE;
                        }
                    }
                    else
                    {
                        index = ComboBox_AddString(psed->hwndSchedList, szName);
                    }

                    if (index >= 0)
                    {
                        bAdded = (ComboBox_SetItemData(psed->hwndSchedList, index, psld) != CB_ERR);

                        if ((psed->defSchedule == *pSchedCookie)
                            ||
                            ((-1 == *psed->pnDefaultSelection) &&
                                IsCookieOnSchedule(pSyncSchedule, &psed->pBuf->m_Cookie)))
                        {
                            *psed->pnDefaultSelection = index;
                        }
                    }
                }
            }
        }
    }

    if (!bAdded)
    {
        SAFEDELETE(psld);
    }
    
    return TRUE;

}

BOOL PickSched_FillSchedList(HWND hDlg, POOEBuf pBuf, int *pnDefaultSelection)
{
    PICKSCHED_ENUM_DATA sed;

    sed.hwndSchedList = GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST);
    sed.pBuf = pBuf;
    sed.customSchedule = GUID_NULL;
    sed.pnDefaultSelection = pnDefaultSelection;
    sed.bHasAtLeastOneSchedule = FALSE;
    sed.bFoundCustomSchedule = FALSE;
    sed.defSchedule = pBuf->groupCookie;    //  usually GUID_NULL, but if the user hits
                                            //  customize multiple times, he/she would
                                            //  expect it to be highlighted

    EnumSchedules(PickSched_EnumCallback, (LPARAM)&sed);

    if (!sed.bFoundCustomSchedule && pBuf->bChannel && 
        (sizeof(TASK_TRIGGER) == pBuf->m_Trigger.cbTriggerSize))
    {
        //  This item has a custom schedule but it isn't an existing
        //  schedule (actually, this is the normal case).  We now
        //  have to add a fake entry.
       
        PICKSCHED_LIST_DATA *psld = new PICKSCHED_LIST_DATA;

        if (NULL != psld)
        {
            TCHAR szSchedName[MAX_PATH];
            BOOL bAdded = FALSE;

            CreatePublisherScheduleName(szSchedName, ARRAYSIZE(szSchedName), 
                                        pBuf->m_Name, NULL);

            int index = ComboBox_InsertString(sed.hwndSchedList, 0, szSchedName);

            if (index >= 0)
            {
                bAdded = (ComboBox_SetItemData(sed.hwndSchedList, index, psld) != CB_ERR);
                sed.bHasAtLeastOneSchedule = TRUE;
                *pnDefaultSelection = index;
            }

            if (!bAdded)
            {
                delete psld;
            }
        }
    }

    return sed.bHasAtLeastOneSchedule;    
}

PICKSCHED_LIST_DATA *PickSchedList_GetData(HWND hwndSchedList, int index)
{
    PICKSCHED_LIST_DATA *psld = NULL;

    if (index < 0)
    {
        index = ComboBox_GetCurSel(hwndSchedList);
    }

    if (index >= 0)
    {
        psld = (PICKSCHED_LIST_DATA *)ComboBox_GetItemData(hwndSchedList, index);
        if (psld == (PICKSCHED_LIST_DATA *)CB_ERR)
        {
            psld = NULL;
        }
    }

    return psld;
}

void PickSchedList_FreeAllData(HWND hwndSchedList)
{
    int count = ComboBox_GetCount(hwndSchedList);

    for (int i = 0; i < count; i++)
    {
        PICKSCHED_LIST_DATA *psld = PickSchedList_GetData(hwndSchedList, i);
        if (NULL != psld)
        {
            delete psld;
        }
    }
}

INT_PTR CALLBACK PickScheduleDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    POOEBuf  pBuf = pWiz ? pWiz->pOOE : NULL;
    NMHDR FAR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            lpPropSheet = (LPPROPSHEETPAGE)lParam;
            pWiz = (WizInfo *)lpPropSheet->lParam;

            int nDefaultSelection = -1;
            BOOL bHaveSchedules = PickSched_FillSchedList(hDlg, pWiz->pOOE, 
                                                          &nDefaultSelection);
            BOOL bNoScheduledUpdates = SHRestricted2W(REST_NoScheduledUpdates, NULL, 0);
            int defID = IDC_WIZ_SCHEDULE_NONE;

            if (!bHaveSchedules)
            {
                ShowWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_EXISTING), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST), SW_HIDE);
            }
            else if (!bNoScheduledUpdates)
            {
                if (-1 == nDefaultSelection)
                {
                    //  This item isn't on any schedule yet
                    nDefaultSelection = 0;
                }
                else
                {
                    //  This item is on at least one schedule
                    defID = IDC_WIZ_SCHEDULE_EXISTING;
                }
                
                ComboBox_SetCurSel(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST), 
                                   nDefaultSelection);
            }
            CheckRadioButton(hDlg, IDC_WIZ_SCHEDULE_NONE, IDC_WIZ_SCHEDULE_EXISTING, 
                             defID);

            ASSERT(NULL != lpPropSheet);
            ASSERT(NULL != pWiz);

            if (bNoScheduledUpdates)
            {
                EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_NEW), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_EXISTING), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST), FALSE);
            }
            else if (SHRestricted2(REST_NoEditingScheduleGroups, NULL, 0))
            {
                EnableWindow(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_NEW), FALSE);
            }

            HandleScheduleButtons(hDlg, lpPropSheet, pWiz);
            result = TRUE;
            break;
        }

        case WM_DESTROY:
            PickSchedList_FreeAllData(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST));
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_WIZ_SCHEDULE_EXISTING:
                case IDC_WIZ_SCHEDULE_NEW:
                case IDC_WIZ_SCHEDULE_NONE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);

                    HandleScheduleButtons(hDlg, lpPropSheet, pWiz);
                    result = TRUE;
                    break;
            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    
                    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    result = TRUE;
                    break;

                case PSN_WIZNEXT:
                case PSN_WIZFINISH:
                    if (IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_NONE) && NULL != pBuf)
                    {
                        pBuf->groupCookie = NOTFCOOKIE_SCHEDULE_GROUP_MANUAL;
                    }
                    else if (IsDlgButtonChecked(hDlg, IDC_WIZ_SCHEDULE_EXISTING))
                    {
                        PICKSCHED_LIST_DATA *psld = 
                            PickSchedList_GetData(GetDlgItem(hDlg, IDC_WIZ_SCHEDULE_LIST), -1);

                        if (NULL != psld && NULL != pBuf)
                        {
                            pBuf->groupCookie = psld->SchedCookie;
                        }
                    }
                    result = TRUE;
                    break;
                    
            }
            break;
            
    }

    return result;
}

BOOL NewSchedWiz_ResolveNameConflict(HWND hDlg, POOEBuf pBuf)
{
    BOOL bResult = TRUE;

    if (!(pBuf->m_dwPropSheetFlags & PSF_NO_CHECK_SCHED_CONFLICT))
    {
        bResult = NewSched_ResolveNameConflictHelper(hDlg, &pBuf->m_Trigger, 
                                                     &pBuf->groupCookie);
    }

    if (bResult)
    {
        pBuf->m_dwPropSheetFlags |= PSF_NO_CHECK_SCHED_CONFLICT;
    }

    return bResult;
}

inline void NewSchedWiz_CreateSchedule(HWND hDlg, POOEBuf pBuf)
{
    ASSERT(pBuf->m_dwPropSheetFlags & PSF_NO_CHECK_SCHED_CONFLICT);

    NewSched_CreateScheduleHelper(hDlg, &pBuf->m_Trigger,
                                  &pBuf->groupCookie);
}

INT_PTR CALLBACK NewScheduleWizDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    POOEBuf  pBuf = pWiz ? pWiz->pOOE : NULL;
    NMHDR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);
            NewSched_OnInitDialogHelper(hDlg);

            pWiz = (WizInfo *)((LPPROPSHEETPAGE)lParam)->lParam;
            pBuf = pWiz->pOOE;

            pBuf->hwndNewSchedDlg = hDlg;

            result = TRUE;
            break;
        }

        case WM_COMMAND:
            if (NULL != pBuf)
            {
                switch (LOWORD(wParam))
                {
                    case IDC_SCHEDULE_DAYS:
                        if (HIWORD(wParam) == EN_UPDATE)
                        {
                            if (LOWORD(wParam) == IDC_SCHEDULE_DAYS)
                            {
                                KeepSpinNumberInRange(hDlg, IDC_SCHEDULE_DAYS, 
                                                      IDC_SCHEDULE_DAYS_SPIN, 1, 99);

                                pBuf->m_dwPropSheetFlags &= ~PSF_NO_CHECK_SCHED_CONFLICT;

                                result = TRUE;
                            }
                        }

                        break;

                    case IDC_SCHEDULE_NAME:
                        if (HIWORD(wParam) == EN_CHANGE)
                        {
                            pBuf->m_dwPropSheetFlags &= ~PSF_NO_CHECK_SCHED_CONFLICT;
                            result = TRUE;
                        }
                        break;
                }
            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    if (!pWiz->bIsNewSchedule)
                    {
                        //  If the user didn't pick a new schedule, move on
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, -1);
                    }
                    else
                    {                    
                        SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    }
                    result = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    result = TRUE;
                    break;

                case PSN_WIZNEXT:
                    if (!NewSchedWiz_ResolveNameConflict(hDlg, pBuf))
                    {
                        //  Don't proceed
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                    }
                    result = TRUE;
                    break;
                    
                case PSN_WIZFINISH:
                    if (NewSchedWiz_ResolveNameConflict(hDlg, pBuf))
                    {
                        NewSchedWiz_CreateSchedule(hDlg, pBuf);
                    }
                    else
                    {
                        //  Don't proceed
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                    }
                    result = TRUE;
                    break;
            }
            break;            
    }

    return result;
}

void Login_EnableControls(HWND hDlg, BOOL bEnable)
{
    int IDs[] = { 
        IDC_USERNAME_LABEL, 
        IDC_USERNAME,
        IDC_PASSWORD_LABEL,
        IDC_PASSWORD,
        IDC_PASSWORDCONFIRM_LABEL,
        IDC_PASSWORDCONFIRM
    };

    for (int i = 0; i < ARRAYSIZE(IDs); i++)
    {
        EnableWindow(GetDlgItem(hDlg, IDs[i]), bEnable);
    }
}

INT_PTR CALLBACK LoginDlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    LPPROPSHEETPAGE lpPropSheet =(LPPROPSHEETPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    WizInfo *pWiz = lpPropSheet ? (WizInfo *)lpPropSheet->lParam : NULL;
    POOEBuf  pBuf = pWiz ? pWiz->pOOE : NULL;
    NMHDR FAR *lpnm;
    BOOL result = FALSE;

    switch (message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            lpPropSheet = (LPPROPSHEETPAGE)lParam;
            pWiz = (WizInfo *)lpPropSheet->lParam;
            pBuf = pWiz->pOOE;

            if (pBuf->bChannel)
            {
                ShowWindow(GetDlgItem(hDlg, IDC_PASSWORD_NO), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_PASSWORD_YES), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_LOGIN_PROMPT_URL), SW_HIDE);
            }
            else
            {
                CheckRadioButton(hDlg, IDC_PASSWORD_NO, IDC_PASSWORD_YES,
                    (((pBuf->username[0] == 0) && (pBuf->password[0] == 0)) ?
                        IDC_PASSWORD_NO : IDC_PASSWORD_YES));

                ShowWindow(GetDlgItem(hDlg, IDC_LOGIN_PROMPT), SW_HIDE);
                ShowWindow(GetDlgItem(hDlg, IDC_LOGIN_PROMPT_CHANNEL), SW_HIDE);
            }
                       
            Edit_LimitText(GetDlgItem(hDlg, IDC_USERNAME), ARRAYSIZE(pBuf->username) - 1);
            SetDlgItemText(hDlg, IDC_USERNAME, pBuf->username);

            Edit_LimitText(GetDlgItem(hDlg, IDC_PASSWORD), ARRAYSIZE(pBuf->password) - 1);
            SetDlgItemText(hDlg, IDC_PASSWORD, pBuf->password);

            Edit_LimitText(GetDlgItem(hDlg, IDC_PASSWORDCONFIRM), ARRAYSIZE(pBuf->password) - 1);
            SetDlgItemText(hDlg, IDC_PASSWORDCONFIRM, pBuf->password);

            Login_EnableControls(hDlg, (IsDlgButtonChecked(hDlg, IDC_PASSWORD_YES) || pBuf->bChannel));

            result = TRUE;
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_PASSWORD_YES:
                case IDC_PASSWORD_NO:
                    if (BN_CLICKED == HIWORD(wParam))
                    {
                        Login_EnableControls(hDlg, IsDlgButtonChecked(hDlg, IDC_PASSWORD_YES));
                        result = TRUE;
                    }
                    break;
            }
            break;

        case WM_NOTIFY:
            lpnm = (NMHDR FAR *)lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:

                    ASSERT(NULL != lpPropSheet);
                    ASSERT(NULL != pWiz);
                    
                    SetWizButtons(hDlg, (INT_PTR) lpPropSheet->pszTemplate, pWiz);
                    result = TRUE;
                    break;

                case PSN_WIZFINISH:
                {
                    BOOL bFinishOK = TRUE;
                    
                    if (pBuf)
                    {
                        if (pBuf->bChannel || IsDlgButtonChecked(hDlg, IDC_PASSWORD_YES))
                        {
                            TCHAR szUsername[ARRAYSIZE(pBuf->username) + 1];
                            TCHAR szPassword[ARRAYSIZE(pBuf->password) + 1];
                            TCHAR szPasswordConfirm[ARRAYSIZE(pBuf->password) + 1];

                            GetDlgItemText(hDlg, IDC_USERNAME, szUsername, ARRAYSIZE(szUsername));
                            GetDlgItemText(hDlg, IDC_PASSWORD, szPassword, ARRAYSIZE(szPassword));
                            GetDlgItemText(hDlg, IDC_PASSWORDCONFIRM, szPasswordConfirm, ARRAYSIZE(szPasswordConfirm));

                            if (!szUsername[0] && (szPassword[0] || szPasswordConfirm[0]))
                            {
                                SGMessageBox(hDlg, 
                                            (pBuf->bChannel ? IDS_NEEDCHANNELUSERNAME : IDS_NEEDUSERNAME), 
                                            MB_ICONWARNING);
                                bFinishOK = FALSE;
                            }
                            else if (szUsername[0] && !szPassword[0])
                            {
                                SGMessageBox(hDlg, 
                                            (pBuf->bChannel ? IDS_NEEDCHANNELPASSWORD : IDS_NEEDPASSWORD), 
                                            MB_ICONWARNING);
                                bFinishOK = FALSE;
                            }
                            else if (StrCmp(szPassword, szPasswordConfirm) != 0)
                            {
                                SGMessageBox(hDlg, IDS_MISMATCHED_PASSWORDS, MB_ICONWARNING);
                                bFinishOK = FALSE;
                            }
                            else
                            {
                                StrCpyN(pBuf->username, szUsername, ARRAYSIZE(pBuf->username));
                                StrCpyN(pBuf->password, szPassword, ARRAYSIZE(pBuf->password));
                                pBuf->dwFlags |= (PROP_WEBCRAWL_UNAME | PROP_WEBCRAWL_PSWD);
                            }

                        }
                        if (!bFinishOK)
                        {
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                        }
                        else if (pWiz->bIsNewSchedule)
                        {
                            NewSchedWiz_CreateSchedule(pBuf->hwndNewSchedDlg, pBuf);
                        }

                        result = TRUE;
                    }
                    break;
                }
            }        
    }
    
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\color.cpp ===
// color.cpp : Implementation of color.h
#include "priv.h"

#include <shlwapi.h>
#include <exdispid.h>
#include <shguidp.h>
#include <hlink.h>
#include <color.h>

COLORREF ColorRefFromHTMLColorStrA(LPCSTR pszColor)
{
    WCHAR wzColor[MAX_COLOR_STR];

    SHAnsiToUnicode(pszColor, wzColor, ARRAYSIZE(wzColor));

    if (wzColor[0] == '#')
        return HashStrToColorRefW(wzColor);

    return ColorRefFromHTMLColorStrW(wzColor);
}

COLORREF ColorRefFromHTMLColorStrW(LPCWSTR pwzColor)    
{
    int min, max, i, cmp;

    if (pwzColor[0] == '#')
        return HashStrToColorRefW(pwzColor);

    // Look for in regular colors
    min = 0;
    max = NUM_HTML_COLORS-1;

    while (min <= max)
    {
        i = (min + max) / 2;
        cmp = StrCmpW(pwzColor, ColorNames[i].pwzColorName);
        if (cmp < 0)
            max = i-1;
        else if (cmp > 0)
            min = i+1;
        else return ColorNames[i].colorRef;
    }

    // Look for in system colors
    min = 0;
    max = NUM_SYS_COLORS-1;

    while (min <= max)
    {
        i = (min + max) / 2;
        cmp = StrCmpW(pwzColor, SysColorNames[i].pwzColorName);
        if (cmp < 0)
            max = i-1;
        else if (cmp > 0)
            min = i+1;
        else return GetSysColor(SysColorNames[i].colorIndex);
    }

    return 0xffffff;        // return white as default color
}

COLORREF HashStrToColorRefW(LPCWSTR pwzHashStr)
{   
    DWORD retColor = 0;
    int   numBytes = lstrlenW(pwzHashStr);
    DWORD thisByte;

    // don't look at the first character because you know its a #

    for (int i=0 ; i < numBytes-1 ; i++)
    {
        thisByte = HexCharToDWORDW(pwzHashStr[numBytes-i-1]);
        retColor |= thisByte << (i*4);
    }
    return (COLORREF)retColor;
}

COLORREF HashStrToColorRefA(LPCSTR pszHashStr)
{
    WCHAR wzHashStr[MAX_COLOR_STR];

    SHAnsiToUnicode(pszHashStr, wzHashStr, ARRAYSIZE(wzHashStr));

    return HashStrToColorRefW(wzHashStr);
}

DWORD HexCharToDWORDW(WCHAR wcHexNum)
{
    if ((wcHexNum >= '0') && (wcHexNum <= '9'))
        return (wcHexNum - '0');

    if ((wcHexNum >= 'a') && (wcHexNum <= 'f'))
        return (wcHexNum - 'a' + 10);

    if ((wcHexNum >= 'A') && (wcHexNum <= 'F'))
        return (wcHexNum - 'A' + 10);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\debug.cpp ===
// debug.cpp: declares debug info
#include "priv.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "webvw"
#define SZ_MODULE           "WEBVW"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\dllload.cpp ===
#include "priv.h"

EXTERN_C {

#include "..\inc\dllload.c"

// --------- NETPLWIZ.DLL ---------------

HINSTANCE g_hinstNETPLWIZ = NULL;

DELAY_LOAD_HRESULT(g_hinstNETPLWIZ, NETPLWIZ.DLL, PubWizard,
            (HWND hwnd, BOOL bTutorial, IDataObject *pDataObject),
            (hwnd, bTutorial, pDataObject));

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\color.h ===
// color.h: declaration of functions to deal with HTML color

#ifndef __COLOR_H_
#define COLOR_H_

#define MAX_COLOR_STR       30
#define NUM_HTML_COLORS     140 
#define NUM_SYS_COLORS      28
#define MAX_BINARY_STR      40    

struct ColorPair_S {
    WCHAR       *pwzColorName;
    COLORREF    colorRef;
};

struct ColorPair2_S {
    WCHAR       *pwzColorName;
    int         colorIndex;
};

const ColorPair_S ColorNames[] =
{
    { L"aliceblue",             0xfff8f0 },
    { L"antiquewhite",          0xd7ebfa },
    { L"aqua",                  0xffff00 },
    { L"aquamarine",            0xd4ff7f },
    { L"azure",                 0xfffff0 },
    { L"beige",                 0xdcf5f5 },
    { L"bisque",                0xc4e4ff },
    { L"black",                 0x000000 },
    { L"blanchedalmond",        0xcdebff },
    { L"blue",                  0xff0000 },
    { L"blueviolet",            0xe22b8a },
    { L"brown",                 0x2a2aa5 },
    { L"burlywood",             0x87b8de },
    { L"cadetblue",             0xa09e5f },
    { L"chartreuse",            0x00ff7f },
    { L"chocolate",             0x1e69d2 },
    { L"coral",                 0x507fff },
    { L"cornflowerblue",        0xed9564 },
    { L"cornsilk",              0xdcf8ff },
    { L"crimson",               0x3c14dc },
    { L"cyan",                  0xffff00 },
    { L"darkblue",              0x8b0000 },
    { L"darkcyan",              0x8b8b00 },
    { L"darkgoldenrod",         0x0b86b8 },
    { L"darkgray",              0xa9a9a9 },
    { L"darkgreen",             0x006400 },
    { L"darkkhaki",             0x6bb7bd },
    { L"darkmagenta",           0x8b008b },
    { L"darkolivegreen",        0x2f6b55 },
    { L"darkorange",            0x008cff },
    { L"darkorchid",            0xcc3299 },
    { L"darkred",               0x00008b },
    { L"darksalmon",            0x7a96e9 },
    { L"darkseagreen",          0x8fbc8f },
    { L"darkslateblue",         0x8b3d48 },
    { L"darkslategray",         0x4f4f2f },
    { L"darkturquoise",         0xd1ce00 },
    { L"darkviolet",            0xd30094 },
    { L"deeppink",              0x9314ff },
    { L"deepskyblue",           0xffbf00 },
    { L"dimgray",               0x696969 },
    { L"dodgerblue",            0xff901e },
    { L"firebrick",             0x2222b2 },
    { L"floralwhite",           0xf0faff },
    { L"forestgreen",           0x228b22 },
    { L"fuchsia",               0xff00ff },
    { L"gainsboro",             0xdcdcdc },
    { L"ghostwhite",            0xfff8f8 },
    { L"gold",                  0x00d7ff },
    { L"goldenrod",             0x20a5da },
    { L"gray",                  0x808080 },
    { L"green",                 0x008000 },
    { L"greenyellow",           0x2fffad },
    { L"honeydew",              0xf0fff0 },
    { L"hotpink",               0xb469ff },
    { L"indianred",             0x5c5ccd },
    { L"indigo",                0x82004b },
    { L"ivory",                 0xf0ffff },
    { L"khaki",                 0x8ce6f0 },
    { L"lavender",              0xfae6e6 },
    { L"lavenderblush",         0xf5f0ff },
    { L"lawngreen",             0x00fc7c },
    { L"lemonchiffn",           0xcdfaff },
    { L"lightblue",             0xe6d8ad },
    { L"lightcoral",            0x8080f0 },
    { L"lightcyan",             0xffffe0 },
    { L"lightgoldenrodyellow",  0xd2fafa },
    { L"lightgreen",            0x90ee90 },
    { L"lightgrey",             0xd3d3d3 },
    { L"lightpink",             0xc1b6ff },
    { L"lightsalmon",           0x7aa0ff },
    { L"lightseagreen",         0xaab220 },
    { L"lightskyblue",          0xface87 },
    { L"lightslategray",        0x998877 },
    { L"lightsteelblue",        0xdec4b0 },
    { L"lightyellow",           0xe0ffff },
    { L"lime",                  0x00ff00 },
    { L"limegreen",             0x32cd32 },
    { L"linen",                 0xe6f0fa },
    { L"magenta",               0xff00ff },
    { L"maroon",                0x000080 },
    { L"mediumaquamarine",      0xaacd66 },
    { L"mediumblue",            0xcd0000 },
    { L"mediumorchid",          0xd355ba },
    { L"mediumpurple",          0xdb7093 },
    { L"mediumseagreen",        0x71b33c },
    { L"mediumslateblue",       0xee687b },
    { L"mediumspringgreen",     0x9afa00 },
    { L"mediumturquoise",       0xccd148 },
    { L"mediumvioletred",       0x8515c7 },
    { L"midnightblue",          0x701919 },
    { L"mintcream",             0xfafff5 },
    { L"mistyrose",             0xe1e4ff },
    { L"moccasin",              0xb5e4ff },
    { L"navajowhite",           0xaddeff },
    { L"navy",                  0x800000 },
    { L"oldlace",               0xe6f5fd },
    { L"olive",                 0x008080 },
    { L"olivedrab",             0x238e6b },
    { L"orange",                0x00a5ff },
    { L"orangered",             0x0045ff },
    { L"orchid",                0xd670da },
    { L"palegoldenrod",         0xaae8ee },
    { L"palegreen",             0x98fb98 },
    { L"paleturquoise",         0xeeeeaf },
    { L"palevioletred",         0x9370db },
    { L"papayawhip",            0xd5efff },
    { L"peachpuff",             0xb9daff },
    { L"peru",                  0x3f85cd },
    { L"pink",                  0xcbc0ff },
    { L"plum",                  0xdda0dd },
    { L"powderblue",            0xe6e0b0 },
    { L"purple",                0x800080 },
    { L"red",                   0x0000ff },
    { L"rosybrown",             0x8f8fbc },
    { L"royalblue",             0xe16941 },
    { L"saddlebrown",           0x13458b },
    { L"salmon",                0x7280fa },
    { L"sandybrown",            0x60a4f4 },
    { L"seagreen",              0x578b2e },
    { L"seashell",              0xeef5ff },
    { L"sienna",                0x2d52a0 },
    { L"silver",                0xc0c0c0 },
    { L"skyblue",               0xebce87 },
    { L"slateblue",             0xcd5a6a },
    { L"slategray",             0x908070 },
    { L"snow",                  0xfafaff },
    { L"springgreen",           0x7fff00 },
    { L"steelblue",             0xb48246 },
    { L"tan",                   0x8cb4d2 },
    { L"teal",                  0x808000 },
    { L"thistle",               0xd8bfd8 },
    { L"tomato",                0x4763ff },
    { L"turquoise",             0xd0e040 },
    { L"violet",                0xee82ee },
    { L"wheat",                 0xb3def5 },
    { L"white",                 0xffffff },
    { L"whitesmoke",            0xf5f5f5 },
    { L"yellow",                0x00ffff },
    { L"yellowgreen",           0x32cd9a }
};

const ColorPair2_S SysColorNames[] =
{    
    { L"activeborder",          COLOR_ACTIVEBORDER},    // Active window border.
    { L"activecaption",         COLOR_ACTIVECAPTION},   // Active window caption.
    { L"appworkspace",          COLOR_APPWORKSPACE},    // Background color of multiple document interface (MDI) applications.
    { L"background",            COLOR_BACKGROUND},      // Desktop background.
    { L"buttonface",            COLOR_BTNFACE},         // Face color for three-dimensional display elements.
    { L"buttonhighlight",       COLOR_BTNHIGHLIGHT},    // Dark shadow for three-dimensional display elements.
    { L"buttonshadow",          COLOR_BTNSHADOW},       // Shadow color for three-dimensional display elements (for edges facing away from the light source).
    { L"buttontext",            COLOR_BTNTEXT},         // Text on push buttons.
    { L"captiontext",           COLOR_CAPTIONTEXT},     // Text in caption, size box, and scroll bar arrow box.
    { L"graytext",              COLOR_GRAYTEXT},        // Grayed (disabled) text. This color is set to 0 if the current display driver does not support a solid gray color.
    { L"highlight",             COLOR_HIGHLIGHT},       // Item(s) selected in a control.
    { L"highlighttext",         COLOR_HIGHLIGHTTEXT},   // Text of item(s) selected in a control.
    { L"inactiveborder",        COLOR_INACTIVEBORDER},  // Inactive window border.
    { L"inactivecaption",       COLOR_INACTIVECAPTION}, // Inactive window caption.
    { L"inactivecaptiontext",   COLOR_INACTIVECAPTIONTEXT}, // Color of text in an inactive caption.
    { L"infobackground",        COLOR_INFOBK},          // Background color for tooltip controls.
    { L"infotext",              COLOR_INFOTEXT},        // Text color for tooltip controls.
    { L"menu",                  COLOR_MENU},            // Menu background.
    { L"menutext",              COLOR_MENUTEXT},        // Text in menus.
    { L"scrollbar",             COLOR_SCROLLBAR},       // Scroll bar gray area.
    { L"threeddarkshadow",      COLOR_3DDKSHADOW },     // Dark shadow for three-dimensional display elements.
    { L"threedface",            COLOR_3DFACE},
    { L"threedhighlight",       COLOR_3DHIGHLIGHT},     // Highlight color for three-dimensional display elements (for edges facing the light source.)
    { L"threedlightshadow",     COLOR_3DLIGHT},         // Light color for three-dimensional display elements (for edges facing the light source.)
    { L"threedshadow",          COLOR_3DSHADOW},        // Dark shadow for three-dimensional display elements.
    { L"window",                COLOR_WINDOW},          // Window background.
    { L"windowframe",           COLOR_WINDOWFRAME},     // Window frame.
    { L"windowtext",            COLOR_WINDOWTEXT}       // Text in windows.
};

COLORREF ColorRefFromHTMLColorStrA(LPCSTR pszColor);

COLORREF ColorRefFromHTMLColorStrW(LPCWSTR pwzColor); 

COLORREF HashStrToColorRefW(LPCWSTR pwzHashStr); 

COLORREF HashStrToColorRefA(LPCSTR pszHashStr);

DWORD HexCharToDWORDW(WCHAR wcHexNum);

#endif //__COLOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\dllreg.cpp ===
// dllreg.cpp -- autmatic registration and unregistration
//
#include "priv.h"
#include <advpub.h>

/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

Returns: 
Cond:    --
*/
HRESULT CallRegInstall(HINSTANCE hinstWebvw, HINSTANCE hinstAdvPack, LPSTR szSection)
{
    HRESULT hr = E_FAIL;

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            STRENTRY seReg[] = {
                // These two NT-specific entries must be at the end
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg) - 2, seReg };

            hr = pfnri(hinstWebvw, szSection, &stReg);
        }
    }

    return hr;
}


STDAPI RegisterStuff(HINSTANCE hinstWebvw)
{
    HRESULT hr;

    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    hr = CallRegInstall(hinstWebvw, hinstAdvPack, "WebViewInstall");

    if (hinstAdvPack)
        FreeLibrary(hinstAdvPack);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\evtsink.cpp ===
#include "priv.h"
#include "evtsink.h"
#include "mshtml.h"
#include "mshtmdid.h"
#include "dispex.h"

CDispatchEventSink::CDispatchEventSink() : m_cRef(1)
{
}

CDispatchEventSink::~CDispatchEventSink()
{
}

STDMETHODIMP CDispatchEventSink::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown || riid == IID_IDispatch) {
        *ppv = SAFECAST(this, IDispatch*);
    } else {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


STDMETHODIMP_(ULONG) CDispatchEventSink::AddRef(void)
{
    m_cRef += 1;
    
    return m_cRef;
}

STDMETHODIMP_(ULONG) CDispatchEventSink::Release(void)
{
    m_cRef -= 1;

    if (m_cRef != 0) {      
        return m_cRef;
    }

    delete this;
    return 0;
}

STDMETHODIMP CDispatchEventSink::GetTypeInfoCount(UINT *pctInfo)
{
    *pctInfo = 0;
    return NOERROR;
}

STDMETHODIMP CDispatchEventSink::GetTypeInfo(UINT iTInfo, LCID lcid, 
                                            ITypeInfo **pptInfo)
{
    *pptInfo = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CDispatchEventSink::GetIDsOfNames(REFIID riid, LPOLESTR *rgszNames,
                             UINT cNames, LCID lcid, DISPID *rgDispId)
{
    if (riid != IID_NULL) {
        return DISP_E_UNKNOWNINTERFACE;
    }

    return DISP_E_UNKNOWNNAME;
}

/////////////////////////////////////////////////////////////////////////////
// Window event sink helpers

HRESULT ConnectHtmlEvents(IDispatch *pdispSink, CComPtr<IOleClientSite> &spClientSite, IDispatch **ppdispWindow,
                          DWORD *pdwCookie) 
{
    HRESULT                      hr;
    CComPtr<IOleContainer>       spContainer;
    CComPtr<IHTMLDocument2>      spHTMLDoc;
    CComPtr<IHTMLWindow2>        spWindow;

    *ppdispWindow = NULL;
    
    //
    // Get the browser window object
    //

    IfFailRet(spClientSite->GetContainer(&spContainer));
    IfFailRet(spContainer->QueryInterface(IID_IHTMLDocument2, (void **)&spHTMLDoc));
    
    IfFailRet(spHTMLDoc->get_parentWindow(&spWindow));

    
    IfFailRet(spWindow->QueryInterface(IID_IDispatch, (void **)ppdispWindow));

    //
    // Connect the event sink
    //

    if (FAILED(AtlAdvise(*ppdispWindow, pdispSink, IID_IDispatch, 
                         pdwCookie)))
       ATOMICRELEASE(*ppdispWindow);

    return S_OK;
}

HRESULT DisconnectHtmlEvents(IDispatch * pdispWindow, DWORD dwCookie) 
{
    HRESULT  hr;
    //
    // Get the browser window object
    //
    if (pdispWindow == NULL) {
        return S_OK; // Nothing to cleanup
    }
    
    //
    // Disconnect the event sink
    //
    hr = AtlUnadvise(pdispWindow, IID_IDispatch, dwCookie);

    //
    // Release the HTML window dispatch
    //
    ATOMICRELEASE(pdispWindow);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\fldricon.cpp ===
// fldricon.cpp : Implementation of CWebViewFolderIcon
#include "priv.h"

#include <shsemip.h>
#include <shellp.h>
#include <mshtml.h>
#include <mshtmdid.h>
#include <fldricon.h>
#include <exdispid.h>
#include <shguidp.h>
#include <hlink.h>
#include <shlwapi.h>
#include <windowsx.h>
#include <wchar.h>
#include <shdocvw.h>  // for IEParseDisplayNameW() & IEGetNameAndFlags()
#include <wingdi.h>

#include <varutil.h>

#define UNINITIALIZE_BOOL   5

const CLSID CLSID_WebViewFolderIconOld = {0xe5df9d10,0x3b52,0x11d1,{0x83,0xe8,0x00,0xa0,0xc9,0x0d,0xc8,0x49}}; // retired from service, so made private


//  PERF: Shell allocator, inserted here because SHRealloc 
//  isn't imported into webvw, this module's hosting executable.
//  If we get SHRealloc, the following block can be removed:
#define _EXPL_SHELL_ALLOCATOR_

#ifdef  _EXPL_SHELL_ALLOCATOR_

#define SHRealloc(pv, cb)     shrealloc(pv, cb)

void* shrealloc(void* pv,  size_t cb)
{
    void *pvRet = NULL;
    IMalloc* pMalloc;
    if (SUCCEEDED(SHGetMalloc(&pMalloc)))  
    {
        pvRet = pMalloc->Realloc(pv, cb);
        pMalloc->Release();
    }
    return pvRet;
}

#endif _EXPL_SHELL_ALLOCATOR_

// For registering the window class
const TCHAR * const g_szWindowClassName = TEXT("WebViewFolderIcon view messaging");

DWORD IntSqrt(DWORD dwNum)
{
    // This code came from "drawpie.c"
    DWORD dwSqrt = 0;
    DWORD dwRemain = 0;
    DWORD dwTry = 0;

    for (int i=0; i<16; ++i) 
    {
        dwRemain = (dwRemain<<2) | (dwNum>>30);
        dwSqrt <<= 1;
        dwTry = dwSqrt*2 + 1;

        if (dwRemain >= dwTry) 
        {
            dwRemain -= dwTry;
            dwSqrt |= 0x01;
        }
        dwNum <<= 2;
    }
    return dwSqrt;
}   

// Make sure you don't begin a drag with random clicking
BOOL CheckForDragBegin(HWND hwnd, int x, int y)
{
    RECT rc;
    int dxClickRect = GetSystemMetrics(SM_CXDRAG);
    int dyClickRect = GetSystemMetrics(SM_CYDRAG);

    ASSERT((dxClickRect > 1) && (dyClickRect > 1));

    // See if the user moves a certain number of pixels in any direction
    SetRect(&rc, x - dxClickRect, y - dyClickRect, x + dxClickRect, y + dyClickRect);

    MapWindowRect(hwnd, NULL, &rc);

    SetCapture(hwnd);

    do 
    {
        MSG msg;

        if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
            // See if the application wants to process the message...
            if (CallMsgFilter(&msg, MSGF_COMMCTRL_BEGINDRAG) != 0)
                continue;

            switch (msg.message) 
            {
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
                PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
                ReleaseCapture();
                return FALSE;

            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                ReleaseCapture();
                return FALSE;

            case WM_MOUSEMOVE:
                if (!PtInRect(&rc, msg.pt)) 
                {
                    ReleaseCapture();
                    return TRUE;
                }
                break;

            default:
                if (GetCapture() != hwnd)
                    ReleaseCapture();
                
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                break;
            }
        }
        else WaitMessage();         /* Don't chew 100% CPU */

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
    } while (GetCapture() == hwnd);

    return FALSE;
}

///////////////////////////////////
//
//  CWebViewFolderIcon functions
//
///////////////////////////////////

CWebViewFolderIcon::CWebViewFolderIcon() :
    m_pccpDV(NULL),
    m_hIcon(0),
    m_iIconIndex(-1),
    m_hbm(NULL),
    m_pthumb(NULL),
    m_pidl(NULL),
    m_msgHwnd(NULL),
    m_pdispWindow(NULL),
    m_dwThumbnailID(0),
    m_bHilite(FALSE)
{
    m_percentScale = 100;
    m_lImageWidth = 0; 
    m_lImageHeight = 0;
    m_sizLabel.cx = m_sizLabel.cy = 0;
    m_pszDisplayName = NULL;

    m_bHasRect = FALSE;
    m_ViewUser = VIEW_LARGEICON;
    m_ViewCurrent = VIEW_LARGEICON;
    m_clickStyle = 2;                   // Default is double-click
    m_fUseSystemColors = TRUE;
    m_bAdvPropsOn = VARIANT_TRUE;
    m_bRegWndClass = FALSE;
    m_ullFreeSpace = 0;
    m_ullUsedSpace = 0;
    m_ullTotalSpace = 0;
    m_highestIndexSlice = 0;
    m_fTabRecieved = FALSE;
    m_pcm3 = NULL;
    m_pDropTargetCache = NULL;
    m_fIsHostWebView = UNINITIALIZE_BOOL;

    m_hdc = NULL;
    m_fRectAdjusted = 0;
    m_hbmDrag = NULL;

    m_hdsaSlices = DSA_Create(sizeof(PieSlice_S), SLICE_NUM_GROW);

    /*
     *  Listview puts a SM_CXEDGE between the icon and the label,
     *  so we will default to that value.  (Clients can adjust with
     *  labelGap property.)
     */
    m_cxLabelGap = GetSystemMetrics(SM_CXEDGE);

    m_pfont = NULL;
    m_hfAmbient = NULL;

}

CWebViewFolderIcon::~CWebViewFolderIcon()
{
    _ClearLabel();
    _ClearAmbientFont();

    if (m_hIcon) 
    {
        DestroyIcon(m_hIcon);
        m_hIcon = NULL;
    }
    
    if (m_hdc)
    {
        DeleteDC(m_hdc);
        m_hdc = NULL;
    }

    if (m_hbmDrag)
    {
        DeleteObject(m_hbmDrag);
        m_hbmDrag = NULL;
    }
    
    ILFree(m_pidl);

    if (m_hbm)
    {
        DeleteObject(m_hbm);
        m_hbm = NULL;
    }

    if (m_hfAmbient)
    {
        DeleteObject(m_hfAmbient);
        m_hfAmbient = NULL;
    }

    ATOMICRELEASE(m_pDropTargetCache);
    ATOMICRELEASE(m_pthumb);

    DSA_Destroy(m_hdsaSlices);

    if (m_msgHwnd)
        ::DestroyWindow(m_msgHwnd);

    if (m_bRegWndClass)
    {
        UnregisterClass(g_szWindowClassName, _Module.GetModuleInstance());
    }
}

HRESULT CWebViewFolderIcon::_SetupWindow(void)
{
    // On the first time register the messaging window
    if (!m_bRegWndClass)
    {
        // Create Window Class for messaging
        m_msgWc.style = 0;
        m_msgWc.lpfnWndProc = CWebViewFolderIcon::WndProc;
        m_msgWc.cbClsExtra = 0;
        m_msgWc.cbWndExtra = 0;
        m_msgWc.hInstance = _Module.GetModuleInstance();
        m_msgWc.hIcon = NULL;
        m_msgWc.hCursor = NULL;
        m_msgWc.hbrBackground = NULL;
        m_msgWc.lpszMenuName = NULL;
        m_msgWc.lpszClassName = g_szWindowClassName;

        m_bRegWndClass = RegisterClass(&m_msgWc);
    }

    if (!m_msgHwnd)
    {
        m_msgHwnd = CreateWindow(g_szWindowClassName, NULL, WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, 
                             CW_USEDEFAULT, NULL, NULL, _Module.GetModuleInstance(), this);
    }

    return m_msgHwnd ? S_OK : E_FAIL;
}

// Must be called before using the IThumbnail.  Also sets up the thumbnail message window
HRESULT CWebViewFolderIcon::SetupIThumbnail(void)
{
    HRESULT hr = _SetupWindow();
    if (SUCCEEDED(hr))
    {
        if (m_pthumb)
            hr = S_OK;
        else
        {
            hr = CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThumbnail2, &m_pthumb));
            if (SUCCEEDED(hr))
                hr = m_pthumb->Init(m_msgHwnd, WM_HTML_BITMAP);
        }
    }
    return hr;
}

// General functions
HRESULT CWebViewFolderIcon::_InvokeOnThumbnailReady()
{
    // Fire off "OnThumbnailReady" event to our connection points to indicate that
    // either a thumbnail has been computed or we have no thumbnail for this file.
    DISPPARAMS dp = {0, NULL, 0, NULL};     // no parameters

    //Lock();
    for (IUnknown** pp = m_vec.begin(); pp < m_vec.end(); pp++)
    {
        if (pp)
        {
            IDispatch* pDispatch = SAFECAST(*pp, IDispatch*);
            pDispatch->Invoke(DISPID_WEBVIEWFOLDERICON_ONTHUMBNAILREADY, IID_NULL,
                    LOCALE_USER_DEFAULT, DISPATCH_METHOD, &dp, NULL, NULL, NULL);
        }
    }
    //Unlock();

    FireViewChange();

    return S_OK;
}

// The S_FALSE return value indicates that this function has succeeded, but the out pidl is still NULL
HRESULT CWebViewFolderIcon::_GetFullPidl(LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    HRESULT hr;
    if (m_pidl)
    {
        hr = SHILClone(m_pidl, ppidl);  // dupe our copy
    }
    else
    {
        // This used to be an EVAL, but it can legitimately fail if the script did not
        // specify a valid path
        // This will fail if we are hosted in a web page instead of the HTML WebView frame in DefView.
        IUnknown *punk;
        hr = IUnknown_QueryService(m_spClientSite, SID_SFolderView, IID_PPV_ARG(IUnknown, &punk));
        if (SUCCEEDED(hr))
        {   
            if (S_OK == SHGetIDListFromUnk(punk, ppidl))
            {
                Pidl_Set(&m_pidl, *ppidl);  // cache a copy of this
            }
            punk->Release();
        }
    }
    return hr;                       
}


HRESULT _GetPidlAndShellFolderFromPidl(LPITEMIDLIST pidl, LPITEMIDLIST *ppidlLast, IShellFolder** ppsfParent)
{
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, ppsfParent), &pidlLast);
    if (SUCCEEDED(hr))
    {
        *ppidlLast = ILClone(pidlLast);
    }
    return hr;
}

// RETURN VALUES:
//      SUCCEEDED() means *ppidlLast and/or *ppsfParent can be NULL.
//      FAILED() means a *ppidlLast *ppsfParent are going to be returned NULL.
HRESULT CWebViewFolderIcon::_GetPidlAndShellFolder(LPITEMIDLIST *ppidlLast, IShellFolder** ppsfParent)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _GetFullPidl(&pidl);
    if (hr == S_OK)
    {
        hr = _GetPidlAndShellFolderFromPidl(pidl, ppidlLast, ppsfParent);
        ILFree(pidl);
    }
    else
    {
        *ppidlLast = NULL;
        *ppsfParent = NULL;
    }

    return hr;
}

// Get Trident's HWND
HRESULT CWebViewFolderIcon::_GetHwnd(HWND* phwnd)
{
    HRESULT hr;

    if (m_spInPlaceSite)
    {
        hr = m_spInPlaceSite->GetWindow(phwnd);
    }
    else
    {
        IOleInPlaceSiteWindowless * poipsw;
        hr = m_spClientSite->QueryInterface(IID_PPV_ARG(IOleInPlaceSiteWindowless, &poipsw));
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = poipsw->GetWindow(phwnd);
            poipsw->Release();
        }
    }
    return hr;
}

HRESULT CWebViewFolderIcon::_GetChildUIObjectOf(REFIID riid, void **ppvObj)
{
    LPITEMIDLIST pidlLast;
    IShellFolder *psfParent;
    HRESULT hr = _GetPidlAndShellFolder(&pidlLast, &psfParent);
    if (hr == S_OK)
    {
        HWND hwnd;
        
        _GetHwnd(&hwnd);
        hr = psfParent->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST *)&pidlLast, riid, NULL, ppvObj);
        psfParent->Release();
        ILFree(pidlLast);
    }
    else
        hr = E_FAIL;

    return hr;
}

//  Center point of focus rectangle
HRESULT CWebViewFolderIcon::_GetCenterPoint(POINT *pt)
{
    pt->y = ((m_rcPos.top + m_rcPos.bottom)/2);
    pt->x = ((m_rcPos.left + m_rcPos.right)/2);

    return S_OK;
}

HRESULT CWebViewFolderIcon::_IsSafe()
{
    HRESULT hr;

    if (0==m_dwCurrentSafety)
    {
        hr = S_OK;
    }
    else
    {
        if (_IsPubWizHosted())
            hr = S_OK;
        else
            hr = IsSafePage(m_spClientSite);
    }

    return hr;
}


BOOL CWebViewFolderIcon::IsSafeToDefaultVerb(void)
{
    return S_OK == _IsSafe();
}

//  If the focus rectangle is not in the specified RectState (on or off) change it and reset m_bHasRect
void CWebViewFolderIcon::_FlipFocusRect(BOOL RectState)
{
    if (m_bHasRect != RectState)    // needs flipping
    {
        m_bHasRect = RectState;
        ForceRedraw();
    }
    return;
}

// Extract a ULONGLONG from two VARIANT's
ULONGLONG CWebViewFolderIcon::GetUllMemFromVars(VARIANT *pvarHi, VARIANT *pvarLo)
{
    ULARGE_INTEGER uli;

    uli.HighPart = pvarHi->ulVal;
    uli.LowPart = pvarLo->ulVal;

    return uli.QuadPart;
}

// Returns the integer percent from the string percent.  Returns -1 if the string is invalid;
int CWebViewFolderIcon::GetPercentFromStrW(LPCWSTR pwzPercent)
{
    int percent = -1;
    int numchar = lstrlenW(pwzPercent);
    ASSERT(numchar>0);

    if (pwzPercent[numchar-1] == '%')
    {
        LPWSTR pwzTempPct = SysAllocString(pwzPercent);

        if (pwzTempPct)
        {
            pwzTempPct[numchar-1] = '\0';

            for (int i=0 ; i < (numchar-2) ; i++)
            {
                if (!((pwzTempPct[i] >= '0') && (pwzTempPct[i] <= '9')))
                {
                    percent = 100;  // 100% is the default to use in error conditions
                    break;
                }
            }

            if ((-1 == percent) && !StrToIntExW(pwzTempPct, STIF_DEFAULT, &percent))
            {
                percent = -1;
            }

            SysFreeString(pwzTempPct);
        }
    }

    return percent;
}

BOOL CWebViewFolderIcon::_WebViewOpen(void)
{
    BOOL Processed = FALSE;

    if (IsSafeToDefaultVerb())
    {   
        Processed = TRUE;
        //
        // if the context menu option does not work, we try a shell execute on the pidl
        //
        if (FAILED(_DoContextMenuCmd(TRUE, 0, 0)))
        {   
            if (m_pidl)
            {
                SHELLEXECUTEINFO sei = { 0 };

                sei.cbSize     = sizeof(sei);
                sei.fMask      = SEE_MASK_INVOKEIDLIST;
                sei.nShow      = SW_SHOWNORMAL;
                sei.lpIDList   = m_pidl;

                if (!ShellExecuteEx(&sei))
                {
                    Processed = FALSE;
                }
            }
        }
    }
    return Processed;
}


void CWebViewFolderIcon::_ClearLabel(void)
{
    if (m_pszDisplayName)
    {
        CoTaskMemFree(m_pszDisplayName);
        m_pszDisplayName = NULL;
        m_sizLabel.cx = m_sizLabel.cy = 0;
    }
}

void  CWebViewFolderIcon::_GetLabel(IShellFolder *psf, LPCITEMIDLIST pidlItem)
{
    if ((m_ViewUser & VIEW_WITHLABEL) && psf)
    {
        STRRET str;
        if (SUCCEEDED(psf->GetDisplayNameOf(pidlItem, SHGDN_INFOLDER, &str)))
        {
            AssertMsg(m_pszDisplayName == NULL, TEXT("CWebViewFolderIcon::_GetLabel - leaking m_pszDisplayName!"));
            StrRetToStr(&str, pidlItem, &m_pszDisplayName);
        }
    }
}

void CWebViewFolderIcon::_ClearAmbientFont(void)
{
    if (m_pfont)            // Font came from container
    {
        if (m_hfAmbient)
            m_pfont->ReleaseHfont(m_hfAmbient);
        m_pfont->Release();
        m_pfont = NULL;

    }
    else                    // Font was created by us
    {
        if (m_hfAmbient)
            DeleteObject(m_hfAmbient);
    }
    m_hfAmbient = NULL;

}

void CWebViewFolderIcon::_GetAmbientFont(void)
{
    if (!m_hfAmbient)
    {
        // Try to get the ambient font from our container
        if (SUCCEEDED(GetAmbientFont(&m_pfont)))
        {
            if (SUCCEEDED(m_pfont->get_hFont(&m_hfAmbient)))
            {
                // Yay, everybody is happy
                m_pfont->AddRefHfont(m_hfAmbient);
            }
            else
            {
                // Darn, couldn't get the font from container
                // Clean up and use the fallback
                _ClearAmbientFont();
                goto fallback;
            }
        }
        else
        {
    fallback:
            // No ambient font -- use the icon title font
            LOGFONT lf;
            SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
            m_hfAmbient = CreateFontIndirect(&lf);
        }
    }
}


HRESULT CWebViewFolderIcon::InitImage(void)
{
    HRESULT hr = E_FAIL;

    // Cancel pending bitmap request if you had a functioning IThumbnail
    // but didn't receive the bitmap
    if (m_pthumb && (m_hbm == NULL))
    {
        m_pthumb->GetBitmap(NULL, 0, 0, 0);
    }

    m_dwThumbnailID++;

    // Initialize the image
    switch (_ViewType(m_ViewUser))
    {
    case VIEW_THUMBVIEW:
        hr = InitThumbnail();
        if (hr != S_OK)
        {   // Default to icon view, but return the previous hr
            InitIcon();
        }
        break;

    case VIEW_PIECHART:
        hr = InitPieGraph();
        if (hr != S_OK)
        {   // Default to icon view, but return the previous hr
            InitIcon();
        }
        break;

    default:
        hr = InitIcon();
        break;
    }

    if (SUCCEEDED(hr))          //  Force a Redraw
        UpdateSize();

    return hr;    
}

HRESULT CWebViewFolderIcon::_GetPathW(LPWSTR psz)
{
    *psz = 0;
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidl;
    if (S_OK == _GetFullPidl(&pidl))
    {
        if (SHGetPathFromIDListW(pidl, psz))
            hr = S_OK;
        ILFree(pidl);
    }
    return hr;
}


HRESULT CWebViewFolderIcon::InitPieGraph(void)
{
    HRESULT hr = S_FALSE;
    
    WCHAR wzPath[MAX_PATH];
    if (SUCCEEDED(_GetPathW(wzPath)))
    {
        //  Check to see if it is a root
        if (PathIsRootW(wzPath))
        {
            if (SUCCEEDED(ComputeFreeSpace(wzPath)))
            {
                m_ViewCurrent = VIEW_PIECHART;
                m_lImageHeight = PIEVIEW_DEFAULT;
                m_lImageWidth = PIEVIEW_DEFAULT;
                hr = S_OK;
            }
        }
        else        // not the root, change view to large icon
            m_ViewCurrent = VIEW_LARGEICON;
    }
    return hr;
}

HRESULT CWebViewFolderIcon::InitThumbnail(void)
{
    m_lImageHeight = THUMBVIEW_DEFAULT;
    m_lImageWidth = THUMBVIEW_DEFAULT;

    //  Get thumbnail bitmap from the path
    HRESULT hr = S_FALSE;
    LPITEMIDLIST pidl;
    if (S_OK == _GetFullPidl(&pidl))
    {
        hr = SetupIThumbnail();
        if (SUCCEEDED(hr))
        {
            LONG lWidth = _GetScaledImageWidth();
            LONG lHeight = _GetScaledImageHeight();

            // Sends the WM_HTML_BITMAP message
            hr = m_pthumb->GetBitmapFromIDList(pidl, m_dwThumbnailID, lWidth, lHeight);
            if (SUCCEEDED(hr))
                m_ViewCurrent = VIEW_THUMBVIEW;
            else
                hr = S_FALSE;
        }
        ILFree(pidl);
    }
    return hr;
}

HRESULT CWebViewFolderIcon::_MakeRoomForLabel()
{
    /*
     *  If we got a label, then make room for it.
     */
    if (m_pszDisplayName)
    {
        GETDCSTATE dcs;
        HDC hdc = IUnknown_GetDC(m_spClientSite, &m_rcPos, &dcs);
        _GetAmbientFont();

        HFONT hfPrev = SelectFont(hdc, m_hfAmbient);

        m_sizLabel.cx = m_sizLabel.cy = 0;
        GetTextExtentPoint(hdc, m_pszDisplayName, lstrlen(m_pszDisplayName), &m_sizLabel);
        SelectFont(hdc, hfPrev);

        IUnknown_ReleaseDC(hdc, &dcs);
    }
    return S_OK;
}

HRESULT CWebViewFolderIcon::InitIcon(void)
{
    LPITEMIDLIST            pidlLast;
    CComPtr<IShellFolder>   spsfParent;
    INT                     iIconIndex = II_DESKTOP;  

    _ClearLabel();

    //  Get icon index
    HRESULT hr = _GetPidlAndShellFolder(&pidlLast, &spsfParent);
    if (SUCCEEDED(hr))
    {
        if (m_ViewUser & VIEW_WITHLABEL)
        {
            _GetLabel(spsfParent, pidlLast);
        }

        //  _GetPidlAndShellFolder() may succeed and spsfParent and pidlLast can be NULL.
        //  In this case the icon will default to II_FOLDER

        //  Is it the default folder case?
        if (hr == S_FALSE)
        {
            //  Yes, so just use the default folder icon.
            iIconIndex = II_FOLDER;   
        }
        else if (spsfParent && pidlLast)
        {
            iIconIndex = SHMapPIDLToSystemImageListIndex(spsfParent, pidlLast, NULL);
            if (iIconIndex <= 0)
            {
                iIconIndex = II_FOLDER;
            }
        }
        //  else it defaults to the desktop
        
        //  Extract icon
        hr = E_FAIL;     //  We haven't gotten it yet
       
        if (m_hIcon)
        {
            // If the indexes match, we can use the previous value as a cache, otherwise,
            // we need to free it.  We also need to free the bitmap in this case.
            if (iIconIndex != m_iIconIndex)
            {
                DestroyIcon(m_hIcon);
                m_hIcon = 0;
            }
            else
            {
                hr = S_OK;      //  Use the one we have already
            }
        }

        // We also need to check and free the bitmap
        if (m_hbm)
        {
            DeleteObject(m_hbm);
            m_hbm = 0;
        }

        if (FAILED(hr))         //  Different icon
        {
            HIMAGELIST  himlSysLarge;
            HIMAGELIST  himlSysSmall;
            
            if ((iIconIndex > 0) && Shell_GetImageLists(&himlSysLarge, &himlSysSmall))
            {
                switch (_ViewType(m_ViewUser))  
                {
                case VIEW_SMALLICON:
                    m_hIcon = ImageList_GetIcon(himlSysSmall, iIconIndex, 0);
                    m_ViewCurrent = m_ViewUser;
                    break;

                case VIEW_LARGEICON:
                    m_hIcon = ImageList_GetIcon(himlSysLarge, iIconIndex, 0);     
                    m_ViewCurrent = m_ViewUser;
                    break;

                default:  // Falls here for large icon and default
                    m_hIcon = ImageList_GetIcon(himlSysLarge, iIconIndex, 0);     
                    m_ViewCurrent = VIEW_LARGEICON;
                    break;
                }  // switch
                
                if (m_hIcon)
                {
                    ICONINFO    iconinfo;
                    
                    //  Get icon size
                    if (GetIconInfo(m_hIcon, &iconinfo))
                    {
                        BITMAP  bm;
                        
                        if (GetObject(iconinfo.hbmColor, sizeof(bm), &bm))
                        {
                            m_lImageWidth = bm.bmWidth;
                            m_lImageHeight = bm.bmHeight;

                            // Hold on to the color hbm for use as a drag image.
                            m_hbm = iconinfo.hbmColor;
                            hr = S_OK;
                        }
                        else
                        {
                            DeleteObject(iconinfo.hbmColor);
                        }

                        DeleteObject(iconinfo.hbmMask);
                    }
                }
            }
        }
        
        ILFree(pidlLast);

        _MakeRoomForLabel();
    }

    if (FAILED(hr))
    {
        //  Couldn't get the icon so set the size to something resonable so that the rest
        //  of the page looks normal

        m_lImageWidth =  LARGE_ICON_DEFAULT;
        m_lImageHeight = LARGE_ICON_DEFAULT;
        UpdateSize();       //  Force an update
    }

    return hr;
} 

HRESULT CWebViewFolderIcon::UpdateSize(void)
{
    HRESULT                   hr = E_FAIL;
      
    // Get the IHtmlStyle
    if (m_spClientSite) 
    {
        CComPtr<IOleControlSite>  spControlSite;

        hr = m_spClientSite->QueryInterface(IID_PPV_ARG(IOleControlSite, &spControlSite));
        if (EVAL(SUCCEEDED(hr)))
        {
            CComPtr<IDispatch> spdisp;

            hr = spControlSite->GetExtendedControl(&spdisp);
            if (EVAL(SUCCEEDED(hr)))
            {
                CComPtr<IHTMLElement> spElement;

                hr = spdisp->QueryInterface(IID_PPV_ARG(IHTMLElement, &spElement));
                if (EVAL(SUCCEEDED(hr)))
                {
                    CComPtr<IHTMLStyle> spStyle;
                    
                    hr = spElement->get_style(&spStyle);
                    if (EVAL(SUCCEEDED(hr)))
                    {
                        CComVariant vWidth(_GetControlWidth(), VT_I4);
                        CComVariant vHeight(_GetControlHeight(), VT_I4);
                        
                        // Set the height and width
                        spStyle->put_width(vWidth);
                        spStyle->put_height(vHeight);
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT CWebViewFolderIcon::ForceRedraw(void)
{
    IOleInPlaceSiteEx *pins;
   
    // Get the IHtmlStyle
    if (m_spClientSite) 
    {
        if (SUCCEEDED(m_spClientSite->QueryInterface(IID_PPV_ARG(IOleInPlaceSiteEx, &pins)))) 
        {
            HWND hwnd;
            if (SUCCEEDED(pins->GetWindow(&hwnd))) 
            {
                ::InvalidateRgn(hwnd, NULL, TRUE);
            }
            pins->Release();
        }
    }

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObject

STDMETHODIMP CWebViewFolderIcon::UIDeactivate(void)
{
    if (m_bAdvPropsOn)
        _FlipFocusRect(FALSE);

    return IOleInPlaceObject_UIDeactivate();
}

// *** IOleInPlaceActiveObject ***
HRESULT CWebViewFolderIcon::TranslateAccelerator(LPMSG pMsg)
{
    HRESULT hr = S_OK;
    if (!m_fTabRecieved)
    {
        hr = IOleInPlaceActiveObjectImpl<CWebViewFolderIcon>::TranslateAccelerator(pMsg);

        // If we did not handle this and if it is a tab (and we are not getting it in a cycle), forward it to trident, if present.
        if (hr != S_OK && pMsg && (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6) && m_spClientSite)
        {
            HWND hwnd;
            if (SUCCEEDED(_GetHwnd(&hwnd)) && (GetFocus() != hwnd))
            {
                ::SetFocus(hwnd);
                hr = S_OK;
            }
            else
            {
                IOleControlSite* pocs = NULL;
                if (SUCCEEDED(m_spClientSite->QueryInterface(IID_PPV_ARG(IOleControlSite, &pocs))))
                {
                    DWORD grfModifiers = 0;
                    if (GetKeyState(VK_SHIFT) & 0x8000)
                    {
                        grfModifiers |= 0x1;    //KEYMOD_SHIFT
                    }
                    if (GetKeyState(VK_CONTROL) & 0x8000)
                    {
                        grfModifiers |= 0x2;    //KEYMOD_CONTROL;
                    }
                    if (GetKeyState(VK_MENU) & 0x8000)
                    {
                        grfModifiers |= 0x4;    //KEYMOD_ALT;
                    }
                    m_fTabRecieved = TRUE;
                    hr = pocs->TranslateAccelerator(pMsg, grfModifiers);
                    m_fTabRecieved = FALSE;
                }
            }
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// ATL

HRESULT CWebViewFolderIcon::DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent)
{
    if (m_bAdvPropsOn)
        _FlipFocusRect(TRUE);

    return IOleObjectImpl<CWebViewFolderIcon>::DoVerbUIActivate(prcPosRect, hwndParent);
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch 

STDMETHODIMP CWebViewFolderIcon::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr)
{
    HRESULT hr;

    //
    // We are overloading this dispatch implementation to be an html window event
    // sink and implement the scale property.  This is safe since the dispid ranges
    // don't overlap.
    // Likewise we overload now for notifications that come from the browser object...
    //

    if (dispidMember == DISPID_HTMLWINDOWEVENTS_ONLOAD) 
    {
        hr = OnWindowLoad();
    } 
    else if (dispidMember == DISPID_HTMLWINDOWEVENTS_ONUNLOAD) 
    {
        hr = OnWindowUnLoad();    
    }
    else
    {
        hr = IDispatchImpl<IWebViewFolderIcon3, &IID_IWebViewFolderIcon3, &LIBID_WEBVWLib>::Invoke(
              dispidMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
    }

    return hr;  
}


/////////////////////////////////////////////////////////////////////////////
// IViewObjectEx

STDMETHODIMP CWebViewFolderIcon::GetViewStatus(DWORD* pdwStatus)
{
    *pdwStatus = VIEWSTATUS_DVASPECTTRANSPARENT;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IPointerInactive

STDMETHODIMP CWebViewFolderIcon::GetActivationPolicy(DWORD* pdwPolicy)
{
    if (!m_bAdvPropsOn)
        return S_OK;

    *pdwPolicy = POINTERINACTIVE_ACTIVATEONDRAG;
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
// IOleInPlaceObjectWindowless

// To implement Windowless DropTarget
STDMETHODIMP CWebViewFolderIcon::GetDropTarget(IDropTarget **ppDropTarget)
{
    HRESULT hr = S_OK;

    if (ppDropTarget)
        *ppDropTarget = NULL;

    if (m_bAdvPropsOn)
    {
        // Do we need to populate m_pDropTargetCache?
        if (!m_pDropTargetCache)
        {
            // Yes, so try to get it now.
            hr = _GetChildUIObjectOf(IID_PPV_ARG(IDropTarget, &m_pDropTargetCache));
        }

        if (m_pDropTargetCache)
            hr = m_pDropTargetCache->QueryInterface(IID_PPV_ARG(IDropTarget, ppDropTarget));
        else
            hr = E_FAIL;
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// IOleObject

STDMETHODIMP CWebViewFolderIcon::SetClientSite(IOleClientSite *pClientSite)
{
    HRESULT hr;

    // Deal with the old client site
    if (pClientSite == NULL && m_spClientSite)
    {
        // We need to unadvise from the defview object now...
        if (m_pccpDV) 
        {
            m_pccpDV->Unadvise(m_dwCookieDV);
            m_pccpDV->Release();
            m_pccpDV = NULL;
        }
        DisconnectHtmlEvents(m_pdispWindow, m_dwHtmlWindowAdviseCookie);
        m_dwHtmlWindowAdviseCookie = 0;
    }

    hr = IOleObjectImpl<CWebViewFolderIcon>::SetClientSite(pClientSite);

    if ((pClientSite != NULL) && SUCCEEDED(hr))
    { 
        ConnectHtmlEvents(this, m_spClientSite, &m_pdispWindow, &m_dwHtmlWindowAdviseCookie);

        // OK now lets register ourself with the Defview to get any events that they may generate...
        IServiceProvider *pspTLB;
        hr = IUnknown_QueryService(m_spClientSite, SID_STopLevelBrowser, IID_PPV_ARG(IServiceProvider, &pspTLB));
        if (SUCCEEDED(hr)) 
        {
            IExpDispSupport *peds;
            hr = pspTLB->QueryService(IID_IExpDispSupport, IID_PPV_ARG(IExpDispSupport, &peds));
            if (SUCCEEDED(hr)) 
            {
                hr = peds->FindCIE4ConnectionPoint(DIID_DWebBrowserEvents2, &m_pccpDV);
                if (SUCCEEDED(hr)) 
                {
                    hr = m_pccpDV->Advise(SAFECAST(this, IDispatch*), &m_dwCookieDV);
                }
                peds->Release();
            }
            pspTLB->Release();
        }
    }

    return hr;
}


UINT g_cfPreferedEffect = 0;

HRESULT _SetPreferedDropEffect(IDataObject *pdtobj, DWORD dwEffect)
{
    if (g_cfPreferedEffect == 0)
        g_cfPreferedEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);

    HRESULT hr = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    if (pdw)
    {
        STGMEDIUM medium;
        FORMATETC fmte = {(CLIPFORMAT)g_cfPreferedEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        *pdw = dwEffect;

        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hr = pdtobj->SetData(&fmte, &medium, TRUE);

        if (FAILED(hr))
            GlobalFree((HGLOBAL)pdw);
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Event Handlers

HRESULT CWebViewFolderIcon::DragDrop(int iClickXPos, int iClickYPos)
{
    if (!m_bAdvPropsOn)
        return S_OK;

    LPITEMIDLIST pidlLast;
    IShellFolder *psfParent;
    HRESULT hr = _GetPidlAndShellFolder(&pidlLast, &psfParent);

    if (hr == S_OK)
    {
        IDataObject *pdtobj;

        hr = psfParent->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*) &pidlLast, 
                                      IID_PPV_ARG_NULL(IDataObject, &pdtobj));
        if (SUCCEEDED(hr))
        {
            DWORD dwEffect = DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;

            psfParent->GetAttributesOf(1, (LPCITEMIDLIST*) &pidlLast, &dwEffect);
            dwEffect &= DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK;
            
            if (dwEffect)
            {
                HRESULT hrOleInit = SHCoInitialize();
                HWND hwnd;
                
                hr = _GetHwnd(&hwnd);
                
                if (SUCCEEDED(hr))
                {
                    DWORD dwEffectOut;
                    
                    _SetPreferedDropEffect(pdtobj, DROPEFFECT_LINK);  
                    
                    // Set the drag image and effect; we don't care if 
                    // it fails, we'll just use the default.
                    _SetDragImage(iClickXPos, iClickYPos, pdtobj);


                    hr = SHDoDragDrop(hwnd, pdtobj, NULL, dwEffect, &dwEffectOut);
                }
                SHCoUninitialize(hrOleInit);
            }
            
            pdtobj->Release();
        }
        psfParent->Release();
        ILFree(pidlLast);
    }

    return hr;
}

// SetDragImage
//
// Sets the drag image to be identical to the icon
HRESULT CWebViewFolderIcon::_SetDragImage(int iClickXPos, int iClickYPos, IDataObject *pdtobj)
{
    // Check things that need to be valid for us to work
    AssertMsg(m_hdc != NULL , TEXT("CWebViewFolderIcon:_SetDragImage() m_hdc is null"));
    AssertMsg(m_hbmDrag != NULL, TEXT("CWebViewFolderIcon:_SetDragImage m_hbmDrag is null"));

    // If the image is a pie chart, it isn't loaded into m_hbm, so we need
    // to do that first
    if (m_ViewCurrent == VIEW_PIECHART)
    {
        _GetPieChartIntoBitmap();
    }

    // Get a dragdrop helper to set our image
    IDragSourceHelper *pdsh;
    HRESULT hr = CoCreateInstance(CLSID_DragDropHelper, NULL, CLSCTX_INPROC_SERVER, 
        IID_PPV_ARG(IDragSourceHelper, &pdsh));
    if (SUCCEEDED(hr))
    {
        BITMAPINFOHEADER bmi = {0};
        BITMAP           bm = {0};
        UINT uBufferOffset = 0;
        
        // This is a screwy procedure to use GetDIBits.  
        // See knowledge base Q80080

        GetObject(m_hbm, sizeof(BITMAP), &bm);

        bmi.biSize          = sizeof(BITMAPINFOHEADER);
        bmi.biWidth         = bm.bmWidth;
        bmi.biHeight        = bm.bmHeight;
        bmi.biPlanes        = 1;
        bmi.biBitCount      = bm.bmPlanes * bm.bmBitsPixel;
        
        // This needs to be one of these 4 values
        if (bmi.biBitCount <= 1)
            bmi.biBitCount = 1;
        else if (bmi.biBitCount <= 4)
            bmi.biBitCount = 4;
        else if (bmi.biBitCount <= 8)
            bmi.biBitCount = 8;
        else
            bmi.biBitCount = 24;
        
        bmi.biCompression   = BI_RGB;

        // Total size of buffer for info struct and color table
        uBufferOffset = sizeof(BITMAPINFOHEADER) + 
            ((bmi.biBitCount == 24) ? 0 : ((1 << bmi.biBitCount) * sizeof(RGBQUAD)));
        
        // Buffer for bitmap bits, so we can copy them.
        BYTE * psBits = (BYTE *) SHAlloc(uBufferOffset);

        if (psBits)
        {
            // Put bmi into the memory block
            CopyMemory(psBits, &bmi, sizeof(BITMAPINFOHEADER));

            // Get the size of the buffer needed for bitmap bits
            if (GetDIBits(m_hdc, m_hbm, 0, 0, NULL, (BITMAPINFO *) psBits, DIB_RGB_COLORS))
            {
                // Realloc our buffer to be big enough
                psBits = (BYTE *) SHRealloc(psBits, uBufferOffset + ((BITMAPINFOHEADER *) psBits)->biSizeImage);

                if (psBits)
                {
                    // Fill the buffer
                    if (GetDIBits(m_hdc, m_hbm, 0, bmi.biHeight, 
                        (void *)(psBits + uBufferOffset), (BITMAPINFO *)psBits, 
                        DIB_RGB_COLORS))
                    {
                        SHDRAGIMAGE shdi;  // Drag images struct
                        
                        shdi.hbmpDragImage = CreateBitmapIndirect(&bm);
                        
                        if (shdi.hbmpDragImage)
                        {
                            // Set the drag image bitmap
                            if (SetDIBits(m_hdc, shdi.hbmpDragImage, 0, m_lImageHeight, 
                                (void *)(psBits + uBufferOffset), (BITMAPINFO *)psBits, 
                                DIB_RGB_COLORS))
                            {
                                // Populate the drag image structure
                                shdi.sizeDragImage.cx = m_lImageWidth;
                                shdi.sizeDragImage.cy = m_lImageHeight;
                                
                                shdi.ptOffset.x = iClickXPos - m_rcPos.left;
                                shdi.ptOffset.y = iClickYPos - m_rcPos.top;
                                
                                shdi.crColorKey = 0;
                                
                                // Set the drag image
                                hr = pdsh->InitializeFromBitmap(&shdi, pdtobj); 
                            }
                            else
                            {
                                hr = E_FAIL;  // Can't SetDIBits
                            }
                        }
                        else
                        {
                            hr = E_OUTOFMEMORY;  // Can't alloc hbmpDragImage
                        }
                    }
                    else
                    {
                        hr = E_FAIL;  // Can't fill psBits
                    }
                    // Free psBits below...
                }
                else
                {
                    hr = E_OUTOFMEMORY;  // Can't realloc psBits
                    
                    // Free psbits here; it still has the old contents
                    SHFree(psBits);
                    psBits = NULL;
                }
            }
            else
            {
                hr = E_FAIL;  // Can't get image size
            }
            if (psBits)
                SHFree(psBits);
        }
        else
        {
            hr = E_OUTOFMEMORY;  // Can't alloc psBits
        }        
        pdsh->Release();
    }
    
    return hr;
}

HRESULT CWebViewFolderIcon::_GetPieChartIntoBitmap()
{
    BITMAP bm;
    
    // It is possible for m_hbm to be alloced, so check for it.
    if (m_hbm)
    {
        DeleteObject(m_hbm);
    }
    
    // Notice that because we want to draw into a new DC starting
    // from the origin, but our rect contains the coords for the
    // original DC, it is neccessary to adjust the coords so that
    // the rect starts at 0, 0 but still has the same proportions.  
    // Since OnDraw() resets the rect each time, we don't have to
    // preserve it and do have to do this each time.  Finally, since
    // Draw3dPie adjusts the rect dimensions for itself, we only want
    // to fix this once.
    if (!m_fRectAdjusted)
    {
        m_rect.right -= m_rect.left;
        m_rect.left = 0;
        m_rect.bottom -= m_rect.top;
        m_rect.top = 0;
        m_fRectAdjusted = 1;
    }
    
    // Get the bitmap
    GetObject(m_hbmDrag, sizeof(BITMAP), &bm);
    m_hbm = CreateBitmapIndirect(&bm);
    
    if (m_hbm)
    {
        // Select into the new DC, and draw our pie
        HBITMAP hbmOld = (HBITMAP) SelectObject(m_hdc, m_hbm);
        DWORD dwPercent1000 = 0;
        
        if (EVAL((m_ullTotalSpace > 0) && (m_ullFreeSpace <= m_ullTotalSpace)))
        {
            ComputeSlicePct(m_ullUsedSpace, &dwPercent1000);
        }
        
        Draw3dPie(m_hdc, &m_rect, dwPercent1000, m_ChartColors);
        
        SelectObject(m_hdc, hbmOld);
    }
    
    return S_OK;
}


LRESULT CWebViewFolderIcon::OnInitPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (m_pcm3)
        m_pcm3->HandleMenuMsg(uMsg, wParam, lParam);

    return 0;
}


LRESULT CWebViewFolderIcon::OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (!m_bAdvPropsOn)
        return TRUE;

    if ((int)wParam != VK_RETURN && (int) wParam != VK_SPACE)
    {
        return FALSE;
    }
    else
        return _WebViewOpen();
}


LRESULT CWebViewFolderIcon::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (m_bAdvPropsOn)
    {
        _DisplayContextMenu(-1, -1);
    }

    return TRUE;
}


// NOTE: our drag drop code captures the mouse and has to do funky stuff to
// make sure we get this button up message. if you have problems with this check
// the code in CheckForDragBegin()

LRESULT CWebViewFolderIcon::OnButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    BOOL Processed = FALSE;
    
    if (!m_bAdvPropsOn)
        return TRUE; 

    HWND hwnd;
    if (EVAL(SUCCEEDED(_GetHwnd(&hwnd))))
    {
        if (CheckForDragBegin(hwnd, GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)))
        {
            IUnknown *punk;
            if (EVAL(SUCCEEDED(IUnknown_QueryService(m_spClientSite, SID_STopLevelBrowser, IID_PPV_ARG(IUnknown, &punk)))))
            {
                if (SUCCEEDED(DragDrop(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam))))
                {
                    Processed = TRUE;
                }
            }
        }
    }

    /*
     *  In single-click mode, open on single left click.
     */
    if (!Processed && uMsg == WM_LBUTTONDOWN && m_clickStyle == 1)
        return _WebViewOpen();

    return Processed;
}

//  Only valid for the HTML window case
LRESULT CWebViewFolderIcon::OnLButtonDoubleClick(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (!m_bAdvPropsOn || m_clickStyle != 2)
        return TRUE;

    return _WebViewOpen();
}


LRESULT CWebViewFolderIcon::OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (!m_bAdvPropsOn)
        return TRUE;

    //
    // the first time we get a WM_MOUSEMOVE event, we set m_bHilite to be TRUE and ignore 
    // subsequent WM_MOUSEMOVEs. OnMouseLeave() sets m_bHilite to FALSE in response to 
    // a WM_MOUSELEAVE msg.
    //
    if (!m_bHilite)
    {   
        m_bHilite = TRUE;
        return SUCCEEDED(ForceRedraw());
    }
    else
    {
        return TRUE;
    }
}

LRESULT CWebViewFolderIcon::OnMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    if (!m_bAdvPropsOn)
        return TRUE;

    m_bHilite = FALSE;
    return SUCCEEDED(ForceRedraw());
}

// The Right Mouse button came up so we want to

LRESULT CWebViewFolderIcon::OnRButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled)
{
    LRESULT lResult = FALSE;

    if (!m_bAdvPropsOn)
        return TRUE;

    HRESULT hr = _IsSafe();
    if (S_OK == hr)
    {
        hr = _DisplayContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
        if (SUCCEEDED(hr))
        {
            lResult = TRUE;
        }
    }

    return lResult;
}


BOOL CWebViewFolderIcon::_IsHostWebView(void)
{
    if (UNINITIALIZE_BOOL == m_fIsHostWebView)
    {
        CComPtr<IDefViewID> spDefView;

        m_fIsHostWebView = FALSE;
        // This will fail if we are hosted in a web page instead of the HTML WebView frame in DefView.
        if (SUCCEEDED(IUnknown_QueryService(m_spClientSite, SID_SFolderView, IID_PPV_ARG(IDefViewID, &spDefView))))
        {
            m_fIsHostWebView = TRUE;
        }
    }

    return m_fIsHostWebView;
}


BOOL CWebViewFolderIcon::_IsPubWizHosted(void)
{
    IPropertyBag *ppb;
    HRESULT hr = IUnknown_QueryService(m_spClientSite, SID_WebWizardHost, IID_PPV_ARG(IPropertyBag, &ppb));
    if (SUCCEEDED(hr))
    {
        ppb->Release();
    }
    return SUCCEEDED(hr);
}


/****************************************************\
    DESCRIPTION:
        We need a little special
    work on the Context Menu since it points to the
    same folder we are in.  So the "Send To" menu
    needs massaging and the "Open" verb needs to
    be removed.

    TODO: I think we should also do this:
    case WM_MENUCHAR:
        _pcm->HandleMenuMsg2(uMsg, wParam, lParam, &lres);
        break;
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        _pcm->HandleMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_INITMENUPOPUP:
        _pcm->HandleMenuMsg(WM_INITMENUPOPUP, (WPARAM)hmenuPopup, (LPARAM)MAKELONG(nIndex, fSystemMenu)
        break;
\****************************************************/
HRESULT CWebViewFolderIcon::_DisplayContextMenu(long nXCord, long nYCord)
{    
    if (!m_bAdvPropsOn)
    {
        return S_OK;
    }
    
    // respect system policies
    if (SHRestricted(REST_NOVIEWCONTEXTMENU)) 
    {
        return E_FAIL;
    }        
    return _DoContextMenuCmd(FALSE, nXCord, nYCord);
}


//
// bDefault == TRUE  > Function executes the default context menu verb, ignores the coords
// bDefault == FALSE > Function pops up a menu at the given coords and executes the desired verb
//
HRESULT CWebViewFolderIcon::_DoContextMenuCmd(BOOL bDefault, long nXCord, long nYCord)
{
    IContextMenu *pcm;
    HRESULT hr = _GetChildUIObjectOf(IID_PPV_ARG(IContextMenu, &pcm));
    if (SUCCEEDED(hr))
    {
        HMENU hpopup = CreatePopupMenu();            
        if (hpopup)
        {
            // SetSite required if you want in place navigation
            IUnknown_SetSite(pcm, m_spClientSite);
            hr = pcm->QueryContextMenu(hpopup, 0, ID_FIRST, ID_LAST, CMF_NORMAL);
            if (SUCCEEDED(hr))
            {
                HWND hwnd;
                hr = _GetHwnd(&hwnd);
                if (SUCCEEDED(hr))
                {
                    UINT idCmd = -1;
                    if (bDefault) // invoke the default verb
                    {
                        idCmd = GetMenuDefaultItem(hpopup, FALSE, GMDI_GOINTOPOPUPS);
                    }
                    else
                    {
                        //
                        // popup the menu and get the command to be executed
                        //
                        POINT point = {nXCord, nYCord};

                        // NTRAID#106655 05-02-2000 arisha
                        // We need to add support to be able to modify the context menu from script.
                        // Below, we make sure we do not remove the "open" verb from the context
                        // menu if we are displaying it in the VIEW_LARGEICONLABEL mode.
                        if (_IsHostWebView() && (m_ViewCurrent != VIEW_LARGEICONLABEL))
                        {
                            hr = ContextMenu_DeleteCommandByName(pcm, hpopup, ID_FIRST, TEXT("open"));
                        }
                        if ((point.x == -1) && (point.y == -1))
                        {
                            _GetCenterPoint(&point);
                        }
                        ::ClientToScreen(hwnd, &point);

                        pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &m_pcm3));
                        
                        if (SUCCEEDED(_SetupWindow()))
                        {
                            idCmd = TrackPopupMenu(hpopup, TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN, 
                                                       (int)point.x, (int)point.y,
                                                       0, m_msgHwnd, NULL);
                        }
                        if (!IsSafeToDefaultVerb() || 0 == idCmd) // 0 implies user cancelled selection
                        {
                            idCmd = -1;
                        }
                        
                        ATOMICRELEASE(m_pcm3);
                    }    
                    if (idCmd != -1)
                    {
                        CMINVOKECOMMANDINFO cmdInfo = 
                        {
                            sizeof(cmdInfo),
                            0,
                            hwnd,
                            (LPSTR)MAKEINTRESOURCE(idCmd),
                            NULL,
                            NULL,
                            SW_NORMAL
                        };
                        hr = pcm->InvokeCommand(&cmdInfo);                        
                    }
                }                
            }
            IUnknown_SetSite(pcm, NULL);                                
            DestroyMenu(hpopup);            
        }
        pcm->Release();
    }
    return hr;
}


HRESULT CWebViewFolderIcon::OnAmbientPropertyChange(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_UNKNOWN:
    case DISPID_AMBIENT_FONT:

        // changing the font means we need to recompute our label
        if (m_pszDisplayName)
        {
            CComPtr<IFont> spFont;
            if (SUCCEEDED(GetAmbientFont(&spFont)))
            {
                if (spFont->IsEqual(m_pfont) != S_OK)
                {
                    _ClearAmbientFont();
                    _MakeRoomForLabel();
                }
            }
        }
        // FALL THROUGH

    case DISPID_AMBIENT_BACKCOLOR:
    case DISPID_AMBIENT_FORECOLOR:
        ForceRedraw();
        break;
    }

    return S_OK;
}

COLORREF _TranslateColor(OLE_COLOR oclr)
{
    COLORREF clr;
    if (FAILED(OleTranslateColor(oclr, NULL, &clr)))
        clr = oclr;
    return clr;
}


HRESULT CWebViewFolderIcon::OnDraw(ATL_DRAWINFO& di)
{
    RECT& rc = *(RECT*)di.prcBounds;
    LONG  lImageWidth = _GetScaledImageWidth();
    LONG  lImageHeight = _GetScaledImageHeight();

    // Grab our hdc and rect to be used in _SetDragImage
    if (m_hdc)
    {
        DeleteDC(m_hdc);
    }

    m_hdc = CreateCompatibleDC(di.hdcDraw);

    if (m_hbmDrag)
    {
        DeleteObject(m_hbmDrag);
    }

    m_hbmDrag = CreateCompatibleBitmap(di.hdcDraw, m_lImageWidth, m_lImageHeight);
    m_rect = rc;
    m_fRectAdjusted = 0;

    
    //
    // Draw the folder icon
    //
    if ((m_ViewCurrent == VIEW_THUMBVIEW) || (m_ViewCurrent == VIEW_PIECHART))
    {
        HDC hdc =   di.hdcDraw; 
        HDC         hdcBitmap;
        BITMAP      bm;
        HPALETTE    hpal = NULL;

        ASSERT(hdc);

        // Create pallete appropriate for this HDC
        if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            hpal = SHCreateShellPalette(hdc);
            HPALETTE hpalOld = SelectPalette(hdc, hpal, TRUE);
            RealizePalette(hdc);

            // Old one needs to be selected back in
            SelectPalette(hdc, hpalOld, TRUE);
        }

        hdcBitmap = CreateCompatibleDC(hdc); 

        if (hdcBitmap)
        {
            //  Draw pie chart
            if (m_ViewCurrent == VIEW_PIECHART)
            {
                DWORD dwPercent1000 = 0;

                if (1) // m_fUseSystemColors.  When do we want this off?
                {
                    // system colors can change!
                    m_ChartColors[PIE_USEDCOLOR] = GetSysColor(COLOR_3DFACE);
                    m_ChartColors[PIE_FREECOLOR] = GetSysColor(COLOR_3DHILIGHT);
                    m_ChartColors[PIE_USEDSHADOW] = GetSysColor(COLOR_3DSHADOW);
                    m_ChartColors[PIE_FREESHADOW] = GetSysColor(COLOR_3DFACE);
                }
                else if (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
                {
                    // Call GetNearestColor on the colors to make sure they're on the palette
                    // Of course, system colors ARE on the palette (I think)
                    DWORD dw = 0;       // index
                    for (dw = 0; dw < PIE_NUM; dw++)
                    {
                        m_ChartColors[dw] = GetNearestColor(hdc, m_ChartColors[dw]);
                    }
                }

                if (EVAL((m_ullTotalSpace > 0) && (m_ullFreeSpace <= m_ullTotalSpace)))
                {
                    ComputeSlicePct(m_ullUsedSpace, &dwPercent1000);
                }

                Draw3dPie(hdc, &rc, dwPercent1000, m_ChartColors);
            }
            else    // Draw the Bitmap
            {
                SelectObject(hdcBitmap, m_hbm);
                GetObject(m_hbm, sizeof(bm), &bm);

                //  Bitmap exactly fits the rectangle
                if (bm.bmWidth == rc.right - rc.left && bm.bmHeight == rc.bottom - rc.top)
                {
                    BitBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top, hdcBitmap, 0, 0, SRCCOPY);
                }
                //  Stretch Bitmap to fit the rectangle
                else
                {
                    SetStretchBltMode(hdc, COLORONCOLOR);
                    StretchBlt(hdc, rc.left, rc.top, lImageWidth, lImageHeight, hdcBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
                }
            }

            DeleteDC(hdcBitmap);
        }
    }
    else if (m_hIcon) 
    {
        DrawIconEx(di.hdcDraw, rc.left, rc.top, m_hIcon, lImageWidth, lImageHeight, 0, 0, DI_NORMAL);
    }

    // Draw the label (if any)
    if (m_pszDisplayName)
    {
        TEXTMETRIC tm;
        TCHAR szFace[32];
        HFONT hFontHilite = NULL;

        //
        // first get the current font properties, there seems to be no straightforward way
        // to just obtain the LOGFONT structure from an HFONT object, so we have to select it
        // to a DC, then obtain the text metrics and use them to create a new font with or
        // without the underline based on m_bHilite value.
        //
        HFONT hfPrev = SelectFont(di.hdcDraw, m_hfAmbient);
        GetTextFace(di.hdcDraw,ARRAYSIZE(szFace), szFace);        
        if (szFace[0] && GetTextMetrics(di.hdcDraw,&tm))
        {
            hFontHilite = CreateFont(tm.tmHeight,
                                              tm.tmAveCharWidth,
                                              0, //Escapement,
                                              0, //Orientation,
                                              tm.tmWeight,
                                              (DWORD) tm.tmItalic,
                                              (DWORD) m_bHilite, // Hilite is by underlining
                                              tm.tmStruckOut,
                                              tm.tmCharSet,
                                              OUT_DEFAULT_PRECIS,
                                              CLIP_DEFAULT_PRECIS,
                                              DEFAULT_QUALITY,
                                              tm.tmPitchAndFamily,
                                              szFace);
            if (hFontHilite)
            {
                SelectFont(di.hdcDraw, hFontHilite);                                  
            }
        }
        
        OLE_COLOR oclrTxt, oclrBk;
        COLORREF clrTxtPrev, clrBkPrev;
        HRESULT hrTxt, hrBk;

        hrTxt = GetAmbientForeColor(oclrTxt);
        if (SUCCEEDED(hrTxt))
            clrTxtPrev = SetTextColor(di.hdcDraw, _TranslateColor(oclrTxt));

        hrBk = GetAmbientBackColor(oclrBk);
        if (SUCCEEDED(hrBk))
            clrBkPrev = SetBkColor(di.hdcDraw, _TranslateColor(oclrBk));

        TextOut(di.hdcDraw, rc.left + lImageWidth + m_cxLabelGap, rc.top + lImageHeight/2 - m_sizLabel.cy/2,
                m_pszDisplayName, lstrlen(m_pszDisplayName));

        if (m_bHasRect)
        {
            RECT rcFocus;
            rcFocus.top = rc.top + lImageHeight/2 - m_sizLabel.cy/2;
            rcFocus.bottom = rcFocus.top + m_sizLabel.cy;
            rcFocus.left = rc.left + lImageWidth + m_cxLabelGap - 1;
            rcFocus.right = rcFocus.left + m_sizLabel.cx + 1;
            DrawFocusRect(di.hdcDraw, &rcFocus);
        }

        if (SUCCEEDED(hrTxt))
            SetTextColor(di.hdcDraw, clrTxtPrev);

        if (SUCCEEDED(hrBk))
            SetBkColor(di.hdcDraw, clrBkPrev);

        SelectFont(di.hdcDraw, hfPrev);

        if (hFontHilite)
        {
            DeleteObject(hFontHilite);
            hFontHilite = NULL;
        }
    }

    return S_OK;
}

HRESULT CWebViewFolderIcon::OnWindowLoad() 
{
    return InitImage();
}

HRESULT CWebViewFolderIcon::OnImageChanged() 
{
    HRESULT hr = InitImage();

    if (SUCCEEDED(hr))
        ForceRedraw();

    return hr;
}

HRESULT CWebViewFolderIcon::OnWindowUnLoad() 
{
    // nothing here now...
    return S_OK;
}

STDMETHODIMP CWebViewFolderIcon::get_scale(BSTR *pbstrScale)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        WCHAR wzScale[MAX_SCALE_STR];

        wnsprintfW(wzScale, ARRAYSIZE(wzScale), L"%d", m_percentScale);

        *pbstrScale = SysAllocString(wzScale);

        return S_OK;
    }
}

STDMETHODIMP CWebViewFolderIcon::put_scale(BSTR bstrScale)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        int numchar = lstrlenW(bstrScale);
        int tempScale = 0;

        if (numchar && bstrScale[numchar-1] == '%')
        {
            tempScale = GetPercentFromStrW(bstrScale);
        }
        else 
        {
            // valid number
            for (int i=0 ; i < (numchar-2) ; i++)
            {
                if (!((bstrScale[i] >= '0') && (bstrScale[i] <= '9')))
                {
                    tempScale = -1;
                    break;
                }
            }

            if ((tempScale != -1) && !StrToIntExW(bstrScale, STIF_DEFAULT, &tempScale))
            {
                tempScale = -1;
            }
        }

        if (tempScale > 0)
        {
            if (m_percentScale != tempScale)
            {
                m_percentScale = tempScale;
                return UpdateSize();
            }
            else
                return S_OK;
        }

        return S_FALSE;
    }
}

STDMETHODIMP CWebViewFolderIcon::get_advproperty(VARIANT_BOOL *pvarbAdvProp)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        *pvarbAdvProp = (VARIANT_BOOL)m_bAdvPropsOn;
    
        return S_OK;
    }

}
    
STDMETHODIMP CWebViewFolderIcon::put_advproperty(VARIANT_BOOL varbAdvProp)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        if (varbAdvProp != m_bAdvPropsOn)
        {
            m_bAdvPropsOn = varbAdvProp;
            return OnImageChanged();
        }

        return S_OK;
    }
}

STDMETHODIMP CWebViewFolderIcon::get_view(BSTR *pbstrView)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        HRESULT hr = S_FALSE;  
        LPCWSTR  pwzTempView;

        switch (m_ViewCurrent)   
        {
            case VIEW_THUMBVIEW:
                {
                    pwzTempView = SZ_THUMB_VIEW;
                    break;
                }
            case VIEW_PIECHART:
                {
                    pwzTempView = SZ_PIE_VIEW;
                    break;
                }
            case VIEW_SMALLICON:
                {
                    pwzTempView = SZ_SMALL_ICON;
                    break;
                }

            case VIEW_SMALLICONLABEL:
                {
                    pwzTempView = SZ_SMALL_ICON_LABEL;
                    break;
                }

            case VIEW_LARGEICONLABEL:
                {
                    pwzTempView = SZ_LARGE_ICON_LABEL;
                    break;
                }

            default:        // default and large icon
                {
                    pwzTempView = SZ_LARGE_ICON;
                    break;
                }
        }

        *pbstrView = SysAllocString(pwzTempView);
        if (*pbstrView)
            hr = S_OK;

        return hr;
    }
}

STDMETHODIMP CWebViewFolderIcon::put_view(BSTR bstrView)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        HRESULT hr = S_OK;
        VIEWS View = VIEW_LARGEICON;

        if (StrCmpIW(bstrView, SZ_LARGE_ICON) == 0)
        {
            View = VIEW_LARGEICON;
        }
        else if (StrCmpIW(bstrView, SZ_SMALL_ICON) == 0)
        {
            View = VIEW_SMALLICON;
        }
        else if (StrCmpIW(bstrView, SZ_SMALL_ICON_LABEL) == 0)
        {
            View = VIEW_SMALLICONLABEL;
        }
        else if (StrCmpIW(bstrView, SZ_LARGE_ICON_LABEL) == 0)
        {
            View = VIEW_LARGEICONLABEL;
        }
        else if (StrCmpIW(bstrView, SZ_THUMB_VIEW) == 0)
        {
            View = VIEW_THUMBVIEW;
        }
        else if (StrCmpIW(bstrView, SZ_PIE_VIEW) == 0)
        {
            View = VIEW_PIECHART;
        }
        else
            hr = S_FALSE;
        
        if ((S_OK == hr) && (m_ViewUser != View))
        {
            m_ViewUser = View;

            hr = OnImageChanged();
        }

        return hr;
    }
}


/**************************************************************\
    DESCRIPTION:
        The caller is getting the path of our control.

    SECURITY:
        We only trust callers from safe pages.  This method
    secifically worries about untrusted callers using us to
    find out what paths on the file system exists or don't exist.  
\**************************************************************/
STDMETHODIMP CWebViewFolderIcon::get_path(BSTR *pbstrPath)
{
    AssertMsg((NULL != m_spClientSite.p), TEXT("CWebViewFolderIcon::get_path() We need m_spClientSite for our security test and it's NULL. BAD, BAD, BAD!"));
    HRESULT hr;

    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        hr = E_ACCESSDENIED;
    }
    else
    {
        LPITEMIDLIST pidlFull;

        hr = S_FALSE;
        *pbstrPath = NULL;
        if (S_OK == _GetFullPidl(&pidlFull))
        {
            WCHAR wzPath[INTERNET_MAX_URL_LENGTH];

            if (S_OK == SHGetNameAndFlagsW(pidlFull, SHGDN_FORPARSING, wzPath, ARRAYSIZE(wzPath), NULL))
            {
                *pbstrPath = SysAllocString(wzPath);  
                if (*pbstrPath)
                    hr = S_OK;
            }

            ILFree(pidlFull);
        }
    }
    
    return hr;
}


/**************************************************************\
    DESCRIPTION:
        The caller is setting the path of our control.  Our
    control will render a view of this item, which is often and
    icon.  

    SECURITY:
        We only trust callers from safe pages.  This method
    secifically worries about untrusted callers using us to
    find out what paths on the file system exists or don't exist.  
\**************************************************************/
STDMETHODIMP CWebViewFolderIcon::put_path(BSTR bstrPath)
{
    AssertMsg((NULL != m_spClientSite.p), TEXT("CWebViewFolderIcon::put_path() We need m_spClientSite for our security test and it's NULL. BAD, BAD, BAD!"));
    HRESULT hr;

    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = S_FALSE;
        LPITEMIDLIST pidlNew;
    
        hr = IEParseDisplayNameW(CP_ACP, bstrPath, &pidlNew);
        if (SUCCEEDED(hr))
        {
            ATOMICRELEASE(m_pDropTargetCache);      // We will want another IDropTarget for this new pidl.
            ILFree(m_pidl);
            m_pidl = pidlNew;

            hr = OnImageChanged();
            AssertMsg(SUCCEEDED(hr), TEXT("CWebViewFolderIcon::put_path() failed to create the image so the image will be incorrect.  Please find out why."));

            hr = S_OK;
        }
    }
    
    return hr;
}


// Automation methods to get/put FolderItem objects from FolderIcon
STDMETHODIMP CWebViewFolderIcon::get_item(FolderItem ** ppFolderItem)
{   
    HRESULT hr;
    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        hr = E_ACCESSDENIED;
    }
    else
    {
        LPITEMIDLIST pidlFull;

        *ppFolderItem = NULL;
        hr = _GetFullPidl(&pidlFull);
        if ((hr == S_OK) && pidlFull)
        {
            IShellDispatch * psd;

            hr = CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellDispatch, &psd));
            if (SUCCEEDED(hr))
            {
                IObjectSafety * pos;

                hr = psd->QueryInterface(IID_PPV_ARG(IObjectSafety, &pos));
                if (SUCCEEDED(hr))
                {
                    // Simulate what trident does.
                    hr = pos->SetInterfaceSafetyOptions(IID_IDispatch, INTERFACESAFE_FOR_UNTRUSTED_CALLER, INTERFACESAFE_FOR_UNTRUSTED_CALLER);

                    if (SUCCEEDED(hr))
                    {
                        VARIANT varDir;

                        hr = InitVariantFromIDList(&varDir, pidlFull);
                        if (SUCCEEDED(hr))
                        {
                            IObjectWithSite * pows;

                            hr = psd->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));
                            if (SUCCEEDED(hr))
                            {
                                Folder *psdf;
                            
                                // If we call ::SetSite(), they will display UI to ask the user if they want to allow this.
                                // This is annoying because Trident will always call our get_item() when they load our object
                                // tag.
                                pows->SetSite(m_spClientSite);
                                hr = psd->NameSpace(varDir, &psdf);
                                if (S_OK == hr)
                                {
                                    Folder2 *psdf2;

                                    hr = psdf->QueryInterface(IID_PPV_ARG(Folder2, &psdf2));
                                    if (S_OK == hr)
                                    {
                                        hr = psdf2->get_Self(ppFolderItem);
                                        psdf2->Release();
                                    }

                                    psdf->Release();
                                }

                                pows->SetSite(NULL);
                                pows->Release();
                            }

                            VariantClear(&varDir);
                        }
                    }
                    pos->Release();
                }

                psd->Release();
            }

            ILFree(pidlFull);
        }
        
        // Automation method can't fail or hard script error.  We do want a hard
        // script error on access denied, however.
        if (FAILED(hr) && (hr != E_ACCESSDENIED))
        {
            hr = S_FALSE;
        }
    }
    return hr;
}


STDMETHODIMP CWebViewFolderIcon::put_item(FolderItem * pFolderItem)
{
    HRESULT hr;
    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        hr = E_ACCESSDENIED;
    }
    else
    {
        hr = S_FALSE;
        
        LPITEMIDLIST pidlNew;
        if (S_OK == SHGetIDListFromUnk(pFolderItem, &pidlNew))
        {
            ATOMICRELEASE(m_pDropTargetCache);      // We will want another IDropTarget for this new pidl.
            ILFree(m_pidl);
            m_pidl = pidlNew;

            hr = OnImageChanged();
            if (FAILED(hr))
            {
                hr = S_FALSE;
            }
        }
    }
    return hr;
}

STDMETHODIMP CWebViewFolderIcon::get_clickStyle(LONG *plClickStyle)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        *plClickStyle = m_clickStyle;
        return S_OK;
    }
}

STDMETHODIMP CWebViewFolderIcon::put_clickStyle(LONG lClickStyle)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        switch (lClickStyle)
        {
        case 1:         /* oneclick - weblike */
        case 2:         /* twoclick - explorer-like */
            m_clickStyle = lClickStyle;
            break;

        default:        /* Ignore invalid arguments to keep script happy */
            break;

        }

        return S_OK;
    }
}

STDMETHODIMP CWebViewFolderIcon::get_labelGap(LONG *plLabelGap)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        *plLabelGap = m_cxLabelGap;
        return S_OK;
    }
}

STDMETHODIMP CWebViewFolderIcon::put_labelGap(LONG lLabelGap)
{
    if (S_OK != _IsSafe())
    {
        return E_ACCESSDENIED;
    }
    else
    {
        if (m_cxLabelGap != lLabelGap)
        {
            m_cxLabelGap = lLabelGap;
            UpdateSize();
        }
        return S_OK;
    }
}


STDMETHODIMP CWebViewFolderIcon::setSlice(int index, VARIANT varHiBytes, VARIANT varLoBytes, VARIANT varColorref)
{
    HRESULT     hr = S_FALSE;
    PieSlice_S  pieSlice;

    if ((varHiBytes.vt == VT_I4) && (varLoBytes.vt == VT_I4))
        pieSlice.MemSize = GetUllMemFromVars(&varHiBytes, &varLoBytes);
 
    // Passed a COLORREF
    if (varColorref.vt == VT_I4) 
    {
        pieSlice.Color = (COLORREF)varColorref.lVal;
    }
    // Passed a string
    else if (varColorref.vt == VT_BSTR)
        pieSlice.Color = ColorRefFromHTMLColorStrW(varColorref.bstrVal);
    else
        return hr;

    if (DSA_SetItem(m_hdsaSlices, index, &pieSlice))
    {
        if (index > (m_highestIndexSlice - 1))
            m_highestIndexSlice = (index + 1);
        hr = OnImageChanged();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// IObjectSafetyImpl overrides

STDMETHODIMP CWebViewFolderIcon::SetInterfaceSafetyOptions(REFIID riid, 
                                                           DWORD dwOptionSetMask, 
                                                           DWORD dwEnabledOptions)
{
    // If we're being asked to set our safe for scripting option then oblige
    if (riid == IID_IDispatch || riid == IID_IPersistPropertyBag)
    {
        // Store our current safety level to return in GetInterfaceSafetyOptions
        m_dwCurrentSafety = dwEnabledOptions & dwOptionSetMask;
        return S_OK;
    }
    return E_NOINTERFACE;
}


// Handle Window messages for the thumbnail bitmap
LRESULT CALLBACK CWebViewFolderIcon::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CWebViewFolderIcon *ptc = (CWebViewFolderIcon *)::GetWindowLongPtr(hwnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_CREATE:
        {
            ptc = (CWebViewFolderIcon *)((CREATESTRUCT *)lParam)->lpCreateParams;
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, (LPARAM)ptc);
        }
        break;

    // NOTE: do not need to check to see that the bitmap coming through is the one you want since each control has its own
    // message wnd.
    case WM_HTML_BITMAP:
        // check that ptc is still alive and that you have an HBITMAP
        if (ptc && (ptc->m_dwThumbnailID == wParam))
        {
            if (ptc->m_hbm != NULL)
            {
                DeleteObject(ptc->m_hbm);
            }

            ptc->m_hbm = (HBITMAP)lParam;
            ptc->_InvokeOnThumbnailReady();
            ptc->ForceRedraw();
        }
        else if (lParam)
        {
            DeleteObject((HBITMAP)lParam);
        }
        break;

    case WM_MEASUREITEM:
    case WM_DRAWITEM:
    case WM_INITMENUPOPUP:
        if (ptc && ptc->m_pcm3)
            ptc->m_pcm3->HandleMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_DESTROY:
        // ignore late messages
        if (ptc)
        {
            MSG msg;

            while(PeekMessage(&msg, hwnd, WM_HTML_BITMAP, WM_HTML_BITMAP, PM_REMOVE))
            {
                if (msg.lParam)
                {
                    DeleteObject((HBITMAP)msg.lParam);
                }
            }
            ::SetWindowLongPtr(hwnd, GWLP_USERDATA, NULL);
        }
        break;
     
    default:
        return ::DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


//  Pie chart functions

HRESULT CWebViewFolderIcon::ComputeFreeSpace(LPCWSTR pszFileName)
{
    return _ComputeFreeSpace(pszFileName, m_ullFreeSpace,
        m_ullUsedSpace, m_ullTotalSpace);
}

// Draw3dPie draws the pie chart with the used slice and the additional slices in m_hdsaSlices
// Look in drawpie.c for the majority of the code (including member functions called within this one)
HRESULT CWebViewFolderIcon::Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPercent1000, const COLORREF *pColors)
{
    LONG ShadowDepth;

    ASSERT(lprc != NULL && pColors != NULL);

    const LONG c_ShadowScale = 6;       // ratio of shadow depth to height
    const LONG c_AspectRatio = 2;      // ratio of width : height of ellipse

    ScalePieRect(c_ShadowScale, c_AspectRatio, lprc);

    // Compute a shadow depth based on height of the image
    ShadowDepth = (lprc->bottom - lprc->top) / c_ShadowScale;

    // Check dwPercent1000 to ensure within bounds.  Shouldn't be but check anyway.
    // dwPercent1000 is the percentage of used space based out of 1000.
    if (dwPercent1000 > 1000)
        dwPercent1000 = 1000;

    // Now the drawing portion

    RECT rcItem;
    int     cx, cy;             // Center of the pie
    int     rx, ry;             // Center of the rectangle
    int     x, y;               // Radial intersection of the slices
    int     FirstQuadPercent1000;

    // Set up the pie rectangle
    rcItem = *lprc;
    rcItem.left = lprc->left;
    rcItem.top = lprc->top;
    rcItem.right = lprc->right - rcItem.left;
    rcItem.bottom = lprc->bottom - rcItem.top - ShadowDepth;

    SetUpPiePts(&cx, &cy, &rx, &ry, rcItem);

    if ((rx <= 10) || (ry <= 10))
    {
        return S_FALSE;
    }

    // Make the rectangle a little more accurate
    rcItem.right = (2 * rx) + rcItem.left;
    rcItem.bottom = (2 * ry) + rcItem.top;

    // Translate the used percentage to first quadrant
    FirstQuadPercent1000 = (dwPercent1000 % 500) - 250;

    if (FirstQuadPercent1000 < 0)
    {
        FirstQuadPercent1000 = -FirstQuadPercent1000;
    }    

    // Find the slice intersection for the used slice
    CalcSlicePoint(&x, &y, rx, ry, cx, cy, FirstQuadPercent1000, dwPercent1000);

    DrawEllipse(hdc, rcItem, x, y, cx, cy, dwPercent1000, pColors);

    // Used pie slice.
    DrawSlice(hdc, rcItem, dwPercent1000, rx, ry, cx, cy, pColors[COLOR_UP]);

    // Iterate through and draw the slices in m_hdsaSlices.
    PieSlice_S  pieSlice;          
    ULONGLONG   ullMemTotal = 0;    // Keep track of memory in the m_hdsaSlices slices        
    DWORD       dwPercentTotal;     // 1000 Percentage of memory in slices
    for (int i=0; i < m_highestIndexSlice; i++)
    {
        if (DSA_GetItemPtr(m_hdsaSlices, i) != NULL)
        {
            DSA_GetItem(m_hdsaSlices, i, &pieSlice);
            ullMemTotal += pieSlice.MemSize;
        }
    }

    ComputeSlicePct(ullMemTotal, &dwPercentTotal);

    if (m_highestIndexSlice)
    {
        for (i = (m_highestIndexSlice - 1); i >= 0; i--)
        {
            if (DSA_GetItemPtr(m_hdsaSlices, i))
            {
                DSA_GetItem(m_hdsaSlices, i, &pieSlice);
                DrawSlice(hdc, rcItem, dwPercentTotal, rx, ry, cx, cy, pieSlice.Color); 
                ullMemTotal -= pieSlice.MemSize;
                ComputeSlicePct(ullMemTotal, &dwPercentTotal);
            }
        }
    }

    DrawShadowRegions(hdc, rcItem, lprc, x, cy, ShadowDepth, dwPercent1000, pColors);

    DrawPieDepth(hdc, rcItem, x, y, cy, dwPercent1000, ShadowDepth);

    // Redraw the bottom line of the pie because it has been painted over
    Arc(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
        rcItem.left, cy, rcItem.right, cy);

    return S_OK;    // Everything worked fine
} 


void CWebViewFolderIcon::ScalePieRect(LONG ShadowScale, LONG AspectRatio, LPRECT lprc)
{
    LONG rectHeight;
    LONG rectWidth;
    LONG TargetHeight;
    LONG TargetWidth;

    // We make sure that the aspect ratio of the pie-chart is always preserved 
    // regardless of the shape of the given rectangle

    // Stabilize the aspect ratio
    rectHeight = lprc->bottom - lprc->top;
    rectWidth = lprc->right - lprc->left;
   
    if ((rectHeight * AspectRatio) <= rectWidth)
        TargetHeight = rectHeight;
    else
        TargetHeight = rectWidth / AspectRatio;
    
    TargetWidth = TargetHeight * AspectRatio;

    // Shrink the rectangle to the correct size
    lprc->top += (rectHeight - TargetHeight) / 2;
    lprc->bottom = lprc->top + TargetHeight;
    lprc->left += (rectWidth - TargetWidth) / 2;
    lprc->right = lprc->left + TargetWidth;
}

// Calculate center of rectangle and center of pie points
void CWebViewFolderIcon::SetUpPiePts(int *pcx, int *pcy, int *prx, int *pry, RECT rect)
{
    *prx = rect.right / 2;
    *pcx = rect.left + *prx - 1;
    *pry = rect.bottom / 2;
    *pcy = rect.top + *pry - 1;
}

void CWebViewFolderIcon::DrawShadowRegions(HDC hdc, RECT rect, LPRECT lprc, int UsedArc_x, int center_y,  
                                           LONG ShadowDepth, DWORD dwPercent1000, const COLORREF *pColors) 
{
    HBRUSH  hBrush;

    HRGN hEllipticRgn = CreateEllipticRgnIndirect(&rect);
    HRGN hEllRect = CreateRectRgn(rect.left, center_y, rect.right, center_y + ShadowDepth);
    HRGN hRectRgn = CreateRectRgn(0, 0, 0, 0);

    //  Move the ellipse up so it doesn't run into the shadow
    OffsetRgn(hEllipticRgn, 0, ShadowDepth);

    // Union the Ellipse and the Ellipse rect together into hRectRegn
    CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
    OffsetRgn(hEllipticRgn, 0, -(int)ShadowDepth);
    CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

    // Always draw the whole area in the free shadow
    hBrush = CreateSolidBrush(pColors[COLOR_DNSHADOW]);
    if (hBrush)
    {
        FillRgn(hdc, hEllRect, hBrush);
        DeleteObject(hBrush);
    }

    // Draw a shadow for the used section only if the disk is at least half used
    hBrush = CreateSolidBrush(pColors[COLOR_UPSHADOW]);
    if ((dwPercent1000 > 500) && hBrush)
    {
        DeleteObject(hRectRgn);
        hRectRgn = CreateRectRgn(UsedArc_x, center_y, rect.right, lprc->bottom);
        CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
        FillRgn(hdc, hEllipticRgn, hBrush);
        DeleteObject(hBrush);
    }

    DeleteObject(hRectRgn);
    DeleteObject(hEllipticRgn);
    DeleteObject(hEllRect);
}

void CWebViewFolderIcon::CalcSlicePoint(int *x, int *y, int rx, int ry, int cx, int cy, int FirstQuadPercent1000, DWORD dwPercent1000)
{
    // Use a triangle area approximation based on the ellipse's rect to calculate the point since
    // an exact calculation of the area of the slice and percentage of the pie would be costly and
    // a hassle.

    // The approximation is better this way if FirstQuadPercent1000 is in the first half of the quadrant.  Use 120 as the
    // halfway point (instead of 125) because it looks better that way on an ellipse. 

    if (FirstQuadPercent1000 < 120)
    {
        *x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)FirstQuadPercent1000*(DWORD)FirstQuadPercent1000)
            /((DWORD)FirstQuadPercent1000*(DWORD)FirstQuadPercent1000+(250L-(DWORD)FirstQuadPercent1000)
            *(250L-(DWORD)FirstQuadPercent1000)));

        *y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)(*x)*(DWORD)(*x))*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
    }
    else
    {
        *y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)FirstQuadPercent1000)*(250L-(DWORD)FirstQuadPercent1000)
            /((DWORD)FirstQuadPercent1000*(DWORD)FirstQuadPercent1000+(250L-(DWORD)FirstQuadPercent1000)
            *(250L-(DWORD)FirstQuadPercent1000)));

        *x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)(*y)*(DWORD)(*y))*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
    }

    // Adjust for the actual quadrant (These aren't quadrants like in the real Cartesian coordinate system.
    switch (dwPercent1000 / 250)
    {
    case 1:         // First Quadrant
        *y = -(*y); 
        break;

    case 2:         // Second Quadrant 
        break;

    case 3:         // Third Quadrant
        *x = -(*x);
        break;

    default:        // Fourth Quadrant
        *x = -(*x);
        *y = -(*y);
        break;
    }

    // Now adjust for the center.
    *x += cx;
    *y += cy;
}

void CWebViewFolderIcon::ComputeSlicePct(ULONGLONG ullMemSize, DWORD *pdwPercent1000)
{
    // some special cases require interesting treatment
    if ((ullMemSize == 0) || (m_ullFreeSpace == m_ullTotalSpace))
    {
        *pdwPercent1000 = 0;
    }
    else if (ullMemSize == 0)
    {
        *pdwPercent1000 = 1000;
    }
    else
    {
        // not completely full or empty
        *pdwPercent1000 = (DWORD)(ullMemSize * 1000 / m_ullTotalSpace);

        // if pdwPercent1000 is especially big or small and rounds incorrectly, you still want
        // to see a little slice.
        if (*pdwPercent1000 == 0)
        {
            *pdwPercent1000 = 1;
        }
        else if (*pdwPercent1000 == 1000)
        {
            *pdwPercent1000 = 999;
        }
    }
}

void CWebViewFolderIcon::DrawPieDepth(HDC hdc, RECT rect, int x, int y, int cy, DWORD dwPercent1000, LONG ShadowDepth)
{
    HPEN hPen, hOldPen;

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    Arc(hdc, rect.left, rect.top + ShadowDepth, rect.right, rect.bottom + ShadowDepth,
        rect.left, cy + ShadowDepth, rect.right, cy + ShadowDepth - 1);
    MoveToEx(hdc, rect.left, cy, NULL);
    LineTo(hdc, rect.left, cy + ShadowDepth);
    MoveToEx(hdc, rect.right - 1, cy, NULL);
    LineTo(hdc, rect.right - 1, cy + ShadowDepth);

    if ((dwPercent1000 > 500) && (dwPercent1000 < 1000))
    {
        MoveToEx(hdc, x, y, NULL);
        LineTo(hdc, x, y + ShadowDepth);
    }

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
}

// Draw a pie slice.  One side is always from the middle of the pie horizontally to the left.  The other
// slice is defined by x and y.
void CWebViewFolderIcon::DrawSlice(HDC hdc, RECT rect, DWORD dwPercent1000, int rx, int ry, int cx, int cy, /*int *px, int *py,*/
                                   COLORREF Color)
{
    HBRUSH  hBrush, hOldBrush;
    HPEN    hPen, hOldPen;
    int     FirstQuadPercent1000;   // slice percentage based out of 1000 in the first quadrant
    int     x, y;                   // intersection with the ellipse

    // Translate to first quadrant
    FirstQuadPercent1000 = (dwPercent1000 % 500) - 250;

    if (FirstQuadPercent1000 < 0)
    {
        FirstQuadPercent1000 = -FirstQuadPercent1000;
    }
    
    CalcSlicePoint(&x, &y, rx, ry, cx, cy, FirstQuadPercent1000, dwPercent1000);

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    if ((dwPercent1000 != 0) && (dwPercent1000 != 1000))
    {
        // display small sub-section of ellipse for smaller part
        hBrush = CreateSolidBrush(Color);
        hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

        //  Make sure it colors correctly
        if (cy == y)
        {
            if (dwPercent1000 < 500)
                y--;
            else
                y++;
        }

        Pie(hdc, rect.left, rect.top, rect.right, rect.bottom,
            x, y, rect.left, cy);
        SelectObject(hdc, hOldBrush);
        DeleteObject(hBrush);
    }

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
}

void CWebViewFolderIcon::DrawEllipse(HDC hdc, RECT rect, int x, int y, int cx, int cy, DWORD dwPercent1000, const COLORREF *pColors)
{
    HBRUSH  hBrush, hOldBrush;

    HPEN hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    HPEN hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    // In this case the slice is miniscule
    if ((dwPercent1000 < 500) && (y == cy) && (x < cx))
    {
        hBrush = CreateSolidBrush(pColors[COLOR_UP]);
    }
    else
    {
        hBrush = CreateSolidBrush(pColors[COLOR_DN]);
    }

    hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

    Ellipse(hdc, rect.left, rect.top, rect.right, rect.bottom);

    SelectObject(hdc, hOldBrush);
    DeleteObject(hBrush);

    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\dxmplay.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.02.0235 */
/* at Tue May 18 20:11:22 1999
 */
/* Compiler settings for dxmplay.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dxmplay_h__
#define __dxmplay_h__

/* Forward Declarations */ 

#ifndef __IDSPlayerEx_FWD_DEFINED__
#define __IDSPlayerEx_FWD_DEFINED__
typedef interface IDSPlayerEx IDSPlayerEx;
#endif 	/* __IDSPlayerEx_FWD_DEFINED__ */


#ifndef __IMediaPlayer_FWD_DEFINED__
#define __IMediaPlayer_FWD_DEFINED__
typedef interface IMediaPlayer IMediaPlayer;
#endif 	/* __IMediaPlayer_FWD_DEFINED__ */


#ifndef __IMediaPlayer2_FWD_DEFINED__
#define __IMediaPlayer2_FWD_DEFINED__
typedef interface IMediaPlayer2 IMediaPlayer2;
#endif 	/* __IMediaPlayer2_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"
//#include "enums.h"
//#include "mpdvd.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_dxmplay_0000 */
/* [local] */ 


#pragma once

typedef /* [public][uuid] */  DECLSPEC_UUID("66504301-BE0F-101A-8BBB-00AA00300CAB") DWORD VB_OLE_COLOR;

typedef /* [public][helpstring] */ 
enum MPDisplayModeConstants
    {	mpTime	= 0,
	mpFrames	= mpTime + 1
    }	MPDisplayModeConstants;

typedef /* [public][helpstring] */ 
enum MPPlayStateConstants
    {	mpStopped	= 0,
	mpPaused	= mpStopped + 1,
	mpPlaying	= mpPaused + 1,
	mpWaiting	= mpPlaying + 1,
	mpScanForward	= mpWaiting + 1,
	mpScanReverse	= mpScanForward + 1,
	mpClosed	= mpScanReverse + 1
    }	MPPlayStateConstants;

typedef /* [public][helpstring] */ 
enum MPfDialogAvailability
    {	mpfFilePropertiesDlg	= 1,
	mpfGotoDlg	= 2
    }	MPfDialogAvailability;

typedef /* [public][helpstring] */ 
enum MPMoreInfoType
    {	mpShowURL	= 0,
	mpClipURL	= mpShowURL + 1,
	mpBannerURL	= mpClipURL + 1
    }	MPMoreInfoType;

typedef /* [public][helpstring] */ 
enum MPMediaInfoType
    {	mpShowFilename	= 0,
	mpShowTitle	= mpShowFilename + 1,
	mpShowAuthor	= mpShowTitle + 1,
	mpShowCopyright	= mpShowAuthor + 1,
	mpShowRating	= mpShowCopyright + 1,
	mpShowDescription	= mpShowRating + 1,
	mpShowLogoIcon	= mpShowDescription + 1,
	mpClipFilename	= mpShowLogoIcon + 1,
	mpClipTitle	= mpClipFilename + 1,
	mpClipAuthor	= mpClipTitle + 1,
	mpClipCopyright	= mpClipAuthor + 1,
	mpClipRating	= mpClipCopyright + 1,
	mpClipDescription	= mpClipRating + 1,
	mpClipLogoIcon	= mpClipDescription + 1,
	mpBannerImage	= mpClipLogoIcon + 1,
	mpBannerMoreInfo	= mpBannerImage + 1,
	mpWatermark	= mpBannerMoreInfo + 1
    }	MPMediaInfoType;

typedef /* [public][helpstring] */ 
enum MPDisplaySizeConstants
    {	mpDefaultSize	= 0,
	mpHalfSize	= mpDefaultSize + 1,
	mpDoubleSize	= mpHalfSize + 1,
	mpFullScreen	= mpDoubleSize + 1,
	mpFitToSize	= mpFullScreen + 1,
	mpOneSixteenthScreen	= mpFitToSize + 1,
	mpOneFourthScreen	= mpOneSixteenthScreen + 1,
	mpOneHalfScreen	= mpOneFourthScreen + 1
    }	MPDisplaySizeConstants;

typedef /* [public][helpstring] */ 
enum MPReadyStateConstants
    {	mpReadyStateUninitialized	= 0,
	mpReadyStateLoading	= mpReadyStateUninitialized + 1,
	mpReadyStateInteractive	= 3,
	mpReadyStateComplete	= mpReadyStateInteractive + 1
    }	MPReadyStateConstants;

typedef /* [public][helpstring] */ 
enum MPShowDialogConstants
    {	mpShowDialogHelp	= 0,
	mpShowDialogStatistics	= mpShowDialogHelp + 1,
	mpShowDialogOptions	= mpShowDialogStatistics + 1,
	mpShowDialogContextMenu	= mpShowDialogOptions + 1
    }	MPShowDialogConstants;

/* [hidden] */ 
enum PlayerCompatibilityType
    {	cmDefault	= 0,
	cmActiveMovie	= cmDefault + 1,
	cmNetShow	= cmActiveMovie + 1
    };


extern RPC_IF_HANDLE __MIDL_itf_dxmplay_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dxmplay_0000_v0_0_s_ifspec;

#ifndef __IDSPlayerEx_INTERFACE_DEFINED__
#define __IDSPlayerEx_INTERFACE_DEFINED__

/* interface IDSPlayerEx */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDSPlayerEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("920F0DE0-91C5-11d1-828F-00C04FC99D4C")
    IDSPlayerEx : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DoContextMenu( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DownloadImage( 
            /* [in] */ BSTR pbstrURL,
            /* [out] */ LONG_PTR __RPC_FAR *phBitmap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutStatusTextEx( 
            /* [in] */ BSTR wszText,
            /* [in] */ BOOL fOverwrite,
            /* [out][in] */ DWORD __RPC_FAR *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FlushStatusBar( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NavigateBrowserToURL( 
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrFrame) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE get_Document( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *__MIDL_0011) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilePropertiesDialog( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StatisticsDialog( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GotoDialog( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Preview( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RestartPlaylist( 
            /* [in] */ BOOL fPlay) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutPreviewModeHelper( 
            VARIANT_BOOL PreviewMode,
            BOOL fPlayWhenFinished) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateVisual( 
            /* [in] */ BOOL fUpdateVisual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterEmbeddedObjects( 
            DWORD dwClsContext) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RevokeEmbeddedObjects( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetNativeFrameFlag( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ResetNativeFrameFlag( void) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_UserInteraction( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AddToolTip( 
            /* [in] */ RECT __RPC_FAR *prc,
            /* [in] */ LPTSTR lptsr,
            /* [out] */ int __RPC_FAR *pID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveToolTip( 
            /* [in] */ int ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateToolTipRect( 
            /* [in] */ RECT __RPC_FAR *prc,
            /* [in] */ int ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UpdateToolTipText( 
            /* [in] */ LPTSTR lptsr,
            /* [in] */ int ID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveAs( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CanSave( void) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CurrentPositionInternal( 
            /* [retval][out] */ double __RPC_FAR *pCurrentPosition) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OpenCloseCounter( 
            /* [retval][out] */ long __RPC_FAR *pOpenCloseCounter) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CompatibilityMode( 
            /* [in] */ long lCompatibilityMode) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CompatibilityMode( 
            /* [retval][out] */ long __RPC_FAR *plCompatibilityMode) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_OnOpenOverride( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OnOpenOverride( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_OnOpenAutoSize( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OnOpenAutoSize( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_OnOpenDisplaySize( 
            /* [in] */ long lOnOpenDisplaySize) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_OnOpenDisplaySize( 
            /* [retval][out] */ long __RPC_FAR *plOnOpenDisplaySize) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_AutoSizeAudioWidth( 
            /* [in] */ long lAutoSizeAudioWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_MinimumWidth( 
            /* [retval][out] */ long __RPC_FAR *plMinimumWidth) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_EffectiveDisplaySize( 
            /* [retval][out] */ long __RPC_FAR *plEffectiveDisplaySize) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_DisplaySizeInternal( 
            /* [in] */ long lDisplaySizeInternal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DisplaySizeInternal( 
            /* [retval][out] */ long __RPC_FAR *plDisplaySizeInternal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_DurationInternal( 
            /* [retval][out] */ double __RPC_FAR *pDuration) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_SegmentSeek( 
            /* [retval][out] */ long __RPC_FAR *plSegmentSeek) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_CanSkip( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_IEVersion( 
            /* [retval][out] */ LPTSTR __RPC_FAR *ppszVersion) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_BrowserIsIE4( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_URL( 
            /* [in] */ BSTR pbstrURL) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_FilterGraph( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppFilterGraph) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_InShow( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_InChannel( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_UpdateVisualCounter( 
            /* [retval][out] */ LONG __RPC_FAR *plVal) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DialogAvailability( 
            /* [retval][out] */ long __RPC_FAR *pDialogAvailability) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StopInternal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsBannerFixed( 
            BOOL __RPC_FAR *fFixed) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartAnimation( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LaunchURLInAnyBrowser( 
            HWND hwnd,
            TCHAR __RPC_FAR *pszPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GoFullScreen( 
            BOOL bFullScreen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompleteClipFilename( 
            BSTR __RPC_FAR *pbstr) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDSPlayerExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDSPlayerEx __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DoContextMenu )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DownloadImage )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BSTR pbstrURL,
            /* [out] */ LONG_PTR __RPC_FAR *phBitmap);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutStatusTextEx )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BSTR wszText,
            /* [in] */ BOOL fOverwrite,
            /* [out][in] */ DWORD __RPC_FAR *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FlushStatusBar )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NavigateBrowserToURL )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BSTR bstrURL,
            /* [in] */ BSTR bstrFrame);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Document )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *__MIDL_0011);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilePropertiesDialog )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StatisticsDialog )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GotoDialog )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Preview )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RestartPlaylist )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BOOL fPlay);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutPreviewModeHelper )( 
            IDSPlayerEx __RPC_FAR * This,
            VARIANT_BOOL PreviewMode,
            BOOL fPlayWhenFinished);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateVisual )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BOOL fUpdateVisual);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterEmbeddedObjects )( 
            IDSPlayerEx __RPC_FAR * This,
            DWORD dwClsContext);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RevokeEmbeddedObjects )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNativeFrameFlag )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ResetNativeFrameFlag )( 
            IDSPlayerEx __RPC_FAR * This);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_UserInteraction )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddToolTip )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ RECT __RPC_FAR *prc,
            /* [in] */ LPTSTR lptsr,
            /* [out] */ int __RPC_FAR *pID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveToolTip )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ int ID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateToolTipRect )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ RECT __RPC_FAR *prc,
            /* [in] */ int ID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateToolTipText )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ LPTSTR lptsr,
            /* [in] */ int ID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveAs )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanSave )( 
            IDSPlayerEx __RPC_FAR * This);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentPositionInternal )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pCurrentPosition);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OpenCloseCounter )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pOpenCloseCounter);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CompatibilityMode )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ long lCompatibilityMode);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CompatibilityMode )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plCompatibilityMode);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OnOpenOverride )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OnOpenOverride )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OnOpenAutoSize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OnOpenAutoSize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_OnOpenDisplaySize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ long lOnOpenDisplaySize);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OnOpenDisplaySize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plOnOpenDisplaySize);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoSizeAudioWidth )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ long lAutoSizeAudioWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MinimumWidth )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plMinimumWidth);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EffectiveDisplaySize )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plEffectiveDisplaySize);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplaySizeInternal )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ long lDisplaySizeInternal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplaySizeInternal )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plDisplaySizeInternal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DurationInternal )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pDuration);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SegmentSeek )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plSegmentSeek);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanSkip )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IEVersion )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ LPTSTR __RPC_FAR *ppszVersion);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BrowserIsIE4 )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_URL )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [in] */ BSTR pbstrURL);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FilterGraph )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppFilterGraph);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InShow )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InChannel )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_UpdateVisualCounter )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *plVal);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DialogAvailability )( 
            IDSPlayerEx __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pDialogAvailability);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StopInternal )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsBannerFixed )( 
            IDSPlayerEx __RPC_FAR * This,
            BOOL __RPC_FAR *fFixed);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartAnimation )( 
            IDSPlayerEx __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LaunchURLInAnyBrowser )( 
            IDSPlayerEx __RPC_FAR * This,
            HWND hwnd,
            TCHAR __RPC_FAR *pszPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GoFullScreen )( 
            IDSPlayerEx __RPC_FAR * This,
            BOOL bFullScreen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompleteClipFilename )( 
            IDSPlayerEx __RPC_FAR * This,
            BSTR __RPC_FAR *pbstr);
        
        END_INTERFACE
    } IDSPlayerExVtbl;

    interface IDSPlayerEx
    {
        CONST_VTBL struct IDSPlayerExVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDSPlayerEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDSPlayerEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDSPlayerEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDSPlayerEx_DoContextMenu(This)	\
    (This)->lpVtbl -> DoContextMenu(This)

#define IDSPlayerEx_DownloadImage(This,pbstrURL,phBitmap)	\
    (This)->lpVtbl -> DownloadImage(This,pbstrURL,phBitmap)

#define IDSPlayerEx_PutStatusTextEx(This,wszText,fOverwrite,pdwCookie)	\
    (This)->lpVtbl -> PutStatusTextEx(This,wszText,fOverwrite,pdwCookie)

#define IDSPlayerEx_FlushStatusBar(This)	\
    (This)->lpVtbl -> FlushStatusBar(This)

#define IDSPlayerEx_NavigateBrowserToURL(This,bstrURL,bstrFrame)	\
    (This)->lpVtbl -> NavigateBrowserToURL(This,bstrURL,bstrFrame)

#define IDSPlayerEx_get_Document(This,__MIDL_0011)	\
    (This)->lpVtbl -> get_Document(This,__MIDL_0011)

#define IDSPlayerEx_FilePropertiesDialog(This)	\
    (This)->lpVtbl -> FilePropertiesDialog(This)

#define IDSPlayerEx_StatisticsDialog(This)	\
    (This)->lpVtbl -> StatisticsDialog(This)

#define IDSPlayerEx_GotoDialog(This)	\
    (This)->lpVtbl -> GotoDialog(This)

#define IDSPlayerEx_Preview(This)	\
    (This)->lpVtbl -> Preview(This)

#define IDSPlayerEx_RestartPlaylist(This,fPlay)	\
    (This)->lpVtbl -> RestartPlaylist(This,fPlay)

#define IDSPlayerEx_PutPreviewModeHelper(This,PreviewMode,fPlayWhenFinished)	\
    (This)->lpVtbl -> PutPreviewModeHelper(This,PreviewMode,fPlayWhenFinished)

#define IDSPlayerEx_UpdateVisual(This,fUpdateVisual)	\
    (This)->lpVtbl -> UpdateVisual(This,fUpdateVisual)

#define IDSPlayerEx_RegisterEmbeddedObjects(This,dwClsContext)	\
    (This)->lpVtbl -> RegisterEmbeddedObjects(This,dwClsContext)

#define IDSPlayerEx_RevokeEmbeddedObjects(This)	\
    (This)->lpVtbl -> RevokeEmbeddedObjects(This)

#define IDSPlayerEx_SetNativeFrameFlag(This)	\
    (This)->lpVtbl -> SetNativeFrameFlag(This)

#define IDSPlayerEx_ResetNativeFrameFlag(This)	\
    (This)->lpVtbl -> ResetNativeFrameFlag(This)

#define IDSPlayerEx_put_UserInteraction(This,bVal)	\
    (This)->lpVtbl -> put_UserInteraction(This,bVal)

#define IDSPlayerEx_AddToolTip(This,prc,lptsr,pID)	\
    (This)->lpVtbl -> AddToolTip(This,prc,lptsr,pID)

#define IDSPlayerEx_RemoveToolTip(This,ID)	\
    (This)->lpVtbl -> RemoveToolTip(This,ID)

#define IDSPlayerEx_UpdateToolTipRect(This,prc,ID)	\
    (This)->lpVtbl -> UpdateToolTipRect(This,prc,ID)

#define IDSPlayerEx_UpdateToolTipText(This,lptsr,ID)	\
    (This)->lpVtbl -> UpdateToolTipText(This,lptsr,ID)

#define IDSPlayerEx_SaveAs(This)	\
    (This)->lpVtbl -> SaveAs(This)

#define IDSPlayerEx_CanSave(This)	\
    (This)->lpVtbl -> CanSave(This)

#define IDSPlayerEx_get_CurrentPositionInternal(This,pCurrentPosition)	\
    (This)->lpVtbl -> get_CurrentPositionInternal(This,pCurrentPosition)

#define IDSPlayerEx_get_OpenCloseCounter(This,pOpenCloseCounter)	\
    (This)->lpVtbl -> get_OpenCloseCounter(This,pOpenCloseCounter)

#define IDSPlayerEx_put_CompatibilityMode(This,lCompatibilityMode)	\
    (This)->lpVtbl -> put_CompatibilityMode(This,lCompatibilityMode)

#define IDSPlayerEx_get_CompatibilityMode(This,plCompatibilityMode)	\
    (This)->lpVtbl -> get_CompatibilityMode(This,plCompatibilityMode)

#define IDSPlayerEx_put_OnOpenOverride(This,bVal)	\
    (This)->lpVtbl -> put_OnOpenOverride(This,bVal)

#define IDSPlayerEx_get_OnOpenOverride(This,pbVal)	\
    (This)->lpVtbl -> get_OnOpenOverride(This,pbVal)

#define IDSPlayerEx_put_OnOpenAutoSize(This,bVal)	\
    (This)->lpVtbl -> put_OnOpenAutoSize(This,bVal)

#define IDSPlayerEx_get_OnOpenAutoSize(This,pbVal)	\
    (This)->lpVtbl -> get_OnOpenAutoSize(This,pbVal)

#define IDSPlayerEx_put_OnOpenDisplaySize(This,lOnOpenDisplaySize)	\
    (This)->lpVtbl -> put_OnOpenDisplaySize(This,lOnOpenDisplaySize)

#define IDSPlayerEx_get_OnOpenDisplaySize(This,plOnOpenDisplaySize)	\
    (This)->lpVtbl -> get_OnOpenDisplaySize(This,plOnOpenDisplaySize)

#define IDSPlayerEx_put_AutoSizeAudioWidth(This,lAutoSizeAudioWidth)	\
    (This)->lpVtbl -> put_AutoSizeAudioWidth(This,lAutoSizeAudioWidth)

#define IDSPlayerEx_get_MinimumWidth(This,plMinimumWidth)	\
    (This)->lpVtbl -> get_MinimumWidth(This,plMinimumWidth)

#define IDSPlayerEx_get_EffectiveDisplaySize(This,plEffectiveDisplaySize)	\
    (This)->lpVtbl -> get_EffectiveDisplaySize(This,plEffectiveDisplaySize)

#define IDSPlayerEx_put_DisplaySizeInternal(This,lDisplaySizeInternal)	\
    (This)->lpVtbl -> put_DisplaySizeInternal(This,lDisplaySizeInternal)

#define IDSPlayerEx_get_DisplaySizeInternal(This,plDisplaySizeInternal)	\
    (This)->lpVtbl -> get_DisplaySizeInternal(This,plDisplaySizeInternal)

#define IDSPlayerEx_get_DurationInternal(This,pDuration)	\
    (This)->lpVtbl -> get_DurationInternal(This,pDuration)

#define IDSPlayerEx_get_SegmentSeek(This,plSegmentSeek)	\
    (This)->lpVtbl -> get_SegmentSeek(This,plSegmentSeek)

#define IDSPlayerEx_get_CanSkip(This,pbCanSkip)	\
    (This)->lpVtbl -> get_CanSkip(This,pbCanSkip)

#define IDSPlayerEx_get_IEVersion(This,ppszVersion)	\
    (This)->lpVtbl -> get_IEVersion(This,ppszVersion)

#define IDSPlayerEx_get_BrowserIsIE4(This,pbCanSkip)	\
    (This)->lpVtbl -> get_BrowserIsIE4(This,pbCanSkip)

#define IDSPlayerEx_put_URL(This,pbstrURL)	\
    (This)->lpVtbl -> put_URL(This,pbstrURL)

#define IDSPlayerEx_get_FilterGraph(This,ppFilterGraph)	\
    (This)->lpVtbl -> get_FilterGraph(This,ppFilterGraph)

#define IDSPlayerEx_get_InShow(This,pbVal)	\
    (This)->lpVtbl -> get_InShow(This,pbVal)

#define IDSPlayerEx_get_InChannel(This,pbVal)	\
    (This)->lpVtbl -> get_InChannel(This,pbVal)

#define IDSPlayerEx_get_UpdateVisualCounter(This,plVal)	\
    (This)->lpVtbl -> get_UpdateVisualCounter(This,plVal)

#define IDSPlayerEx_get_DialogAvailability(This,pDialogAvailability)	\
    (This)->lpVtbl -> get_DialogAvailability(This,pDialogAvailability)

#define IDSPlayerEx_StopInternal(This)	\
    (This)->lpVtbl -> StopInternal(This)

#define IDSPlayerEx_IsBannerFixed(This,fFixed)	\
    (This)->lpVtbl -> IsBannerFixed(This,fFixed)

#define IDSPlayerEx_StartAnimation(This)	\
    (This)->lpVtbl -> StartAnimation(This)

#define IDSPlayerEx_LaunchURLInAnyBrowser(This,hwnd,pszPath)	\
    (This)->lpVtbl -> LaunchURLInAnyBrowser(This,hwnd,pszPath)

#define IDSPlayerEx_GoFullScreen(This,bFullScreen)	\
    (This)->lpVtbl -> GoFullScreen(This,bFullScreen)

#define IDSPlayerEx_GetCompleteClipFilename(This,pbstr)	\
    (This)->lpVtbl -> GetCompleteClipFilename(This,pbstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDSPlayerEx_DoContextMenu_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_DoContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_DownloadImage_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BSTR pbstrURL,
    /* [out] */ LONG_PTR __RPC_FAR *phBitmap);


void __RPC_STUB IDSPlayerEx_DownloadImage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_PutStatusTextEx_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BSTR wszText,
    /* [in] */ BOOL fOverwrite,
    /* [out][in] */ DWORD __RPC_FAR *pdwCookie);


void __RPC_STUB IDSPlayerEx_PutStatusTextEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_FlushStatusBar_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_FlushStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_NavigateBrowserToURL_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BSTR bstrURL,
    /* [in] */ BSTR bstrFrame);


void __RPC_STUB IDSPlayerEx_NavigateBrowserToURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_Document_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *__MIDL_0011);


void __RPC_STUB IDSPlayerEx_get_Document_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_FilePropertiesDialog_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_FilePropertiesDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_StatisticsDialog_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_StatisticsDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_GotoDialog_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_GotoDialog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_Preview_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_Preview_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_RestartPlaylist_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BOOL fPlay);


void __RPC_STUB IDSPlayerEx_RestartPlaylist_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_PutPreviewModeHelper_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    VARIANT_BOOL PreviewMode,
    BOOL fPlayWhenFinished);


void __RPC_STUB IDSPlayerEx_PutPreviewModeHelper_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_UpdateVisual_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BOOL fUpdateVisual);


void __RPC_STUB IDSPlayerEx_UpdateVisual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_RegisterEmbeddedObjects_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    DWORD dwClsContext);


void __RPC_STUB IDSPlayerEx_RegisterEmbeddedObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_RevokeEmbeddedObjects_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_RevokeEmbeddedObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_SetNativeFrameFlag_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_SetNativeFrameFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_ResetNativeFrameFlag_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_ResetNativeFrameFlag_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_UserInteraction_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IDSPlayerEx_put_UserInteraction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_AddToolTip_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ RECT __RPC_FAR *prc,
    /* [in] */ LPTSTR lptsr,
    /* [out] */ int __RPC_FAR *pID);


void __RPC_STUB IDSPlayerEx_AddToolTip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_RemoveToolTip_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ int ID);


void __RPC_STUB IDSPlayerEx_RemoveToolTip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_UpdateToolTipRect_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ RECT __RPC_FAR *prc,
    /* [in] */ int ID);


void __RPC_STUB IDSPlayerEx_UpdateToolTipRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_UpdateToolTipText_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ LPTSTR lptsr,
    /* [in] */ int ID);


void __RPC_STUB IDSPlayerEx_UpdateToolTipText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_SaveAs_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_SaveAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_CanSave_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_CanSave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_CurrentPositionInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pCurrentPosition);


void __RPC_STUB IDSPlayerEx_get_CurrentPositionInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_OpenCloseCounter_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pOpenCloseCounter);


void __RPC_STUB IDSPlayerEx_get_OpenCloseCounter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_CompatibilityMode_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ long lCompatibilityMode);


void __RPC_STUB IDSPlayerEx_put_CompatibilityMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_CompatibilityMode_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plCompatibilityMode);


void __RPC_STUB IDSPlayerEx_get_CompatibilityMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_OnOpenOverride_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IDSPlayerEx_put_OnOpenOverride_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_OnOpenOverride_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IDSPlayerEx_get_OnOpenOverride_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_OnOpenAutoSize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IDSPlayerEx_put_OnOpenAutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_OnOpenAutoSize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IDSPlayerEx_get_OnOpenAutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_OnOpenDisplaySize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ long lOnOpenDisplaySize);


void __RPC_STUB IDSPlayerEx_put_OnOpenDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_OnOpenDisplaySize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plOnOpenDisplaySize);


void __RPC_STUB IDSPlayerEx_get_OnOpenDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_AutoSizeAudioWidth_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ long lAutoSizeAudioWidth);


void __RPC_STUB IDSPlayerEx_put_AutoSizeAudioWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_MinimumWidth_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plMinimumWidth);


void __RPC_STUB IDSPlayerEx_get_MinimumWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_EffectiveDisplaySize_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plEffectiveDisplaySize);


void __RPC_STUB IDSPlayerEx_get_EffectiveDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_DisplaySizeInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ long lDisplaySizeInternal);


void __RPC_STUB IDSPlayerEx_put_DisplaySizeInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_DisplaySizeInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plDisplaySizeInternal);


void __RPC_STUB IDSPlayerEx_get_DisplaySizeInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_DurationInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pDuration);


void __RPC_STUB IDSPlayerEx_get_DurationInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_SegmentSeek_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plSegmentSeek);


void __RPC_STUB IDSPlayerEx_get_SegmentSeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_CanSkip_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip);


void __RPC_STUB IDSPlayerEx_get_CanSkip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_IEVersion_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ LPTSTR __RPC_FAR *ppszVersion);


void __RPC_STUB IDSPlayerEx_get_IEVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_BrowserIsIE4_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbCanSkip);


void __RPC_STUB IDSPlayerEx_get_BrowserIsIE4_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_put_URL_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [in] */ BSTR pbstrURL);


void __RPC_STUB IDSPlayerEx_put_URL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_FilterGraph_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppFilterGraph);


void __RPC_STUB IDSPlayerEx_get_FilterGraph_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_InShow_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IDSPlayerEx_get_InShow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_InChannel_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IDSPlayerEx_get_InChannel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_UpdateVisualCounter_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *plVal);


void __RPC_STUB IDSPlayerEx_get_UpdateVisualCounter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IDSPlayerEx_get_DialogAvailability_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pDialogAvailability);


void __RPC_STUB IDSPlayerEx_get_DialogAvailability_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_StopInternal_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_StopInternal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_IsBannerFixed_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    BOOL __RPC_FAR *fFixed);


void __RPC_STUB IDSPlayerEx_IsBannerFixed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_StartAnimation_Proxy( 
    IDSPlayerEx __RPC_FAR * This);


void __RPC_STUB IDSPlayerEx_StartAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_LaunchURLInAnyBrowser_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    HWND hwnd,
    TCHAR __RPC_FAR *pszPath);


void __RPC_STUB IDSPlayerEx_LaunchURLInAnyBrowser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_GoFullScreen_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    BOOL bFullScreen);


void __RPC_STUB IDSPlayerEx_GoFullScreen_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDSPlayerEx_GetCompleteClipFilename_Proxy( 
    IDSPlayerEx __RPC_FAR * This,
    BSTR __RPC_FAR *pbstr);


void __RPC_STUB IDSPlayerEx_GetCompleteClipFilename_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDSPlayerEx_INTERFACE_DEFINED__ */


#ifndef __IMediaPlayer_INTERFACE_DEFINED__
#define __IMediaPlayer_INTERFACE_DEFINED__

/* interface IMediaPlayer */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IMediaPlayer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("22D6F311-B0F6-11D0-94AB-0080C74C7E95")
    IMediaPlayer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentPosition( 
            /* [retval][out] */ double __RPC_FAR *pCurrentPosition) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentPosition( 
            /* [in] */ double CurrentPosition) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Duration( 
            /* [retval][out] */ double __RPC_FAR *pDuration) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceWidth( 
            /* [retval][out] */ long __RPC_FAR *pWidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ImageSourceHeight( 
            /* [retval][out] */ long __RPC_FAR *pHeight) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_MarkerCount( 
            /* [retval][out] */ long __RPC_FAR *pMarkerCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanScan( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanScan) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanSeek( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeek) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanSeekToMarkers( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeekToMarkers) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CurrentMarker( 
            /* [retval][out] */ long __RPC_FAR *pCurrentMarker) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CurrentMarker( 
            /* [in] */ long CurrentMarker) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_FileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_FileName( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceLink( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceLink) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CreationDate( 
            /* [retval][out] */ DATE __RPC_FAR *pCreationDate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorCorrection( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorCorrection) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Bandwidth( 
            /* [retval][out] */ long __RPC_FAR *pBandwidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SourceProtocol( 
            /* [retval][out] */ long __RPC_FAR *pSourceProtocol) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceivedPackets( 
            /* [retval][out] */ long __RPC_FAR *pReceivedPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_RecoveredPackets( 
            /* [retval][out] */ long __RPC_FAR *pRecoveredPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_LostPackets( 
            /* [retval][out] */ long __RPC_FAR *pLostPackets) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReceptionQuality( 
            /* [retval][out] */ long __RPC_FAR *pReceptionQuality) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingCount( 
            /* [retval][out] */ long __RPC_FAR *pBufferingCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsBroadcast( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsBroadcast) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingProgress( 
            /* [retval][out] */ long __RPC_FAR *pBufferingProgress) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelDescription( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelDescription) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ChannelURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelURL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactAddress( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactAddress) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactPhone( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactPhone) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ContactEmail( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactEmail) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BufferingTime( 
            /* [retval][out] */ double __RPC_FAR *pBufferingTime) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BufferingTime( 
            /* [in] */ double BufferingTime) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoStart( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoStart( 
            /* [in] */ VARIANT_BOOL AutoStart) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoRewind( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoRewind) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoRewind( 
            /* [in] */ VARIANT_BOOL AutoRewind) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Rate( 
            /* [retval][out] */ double __RPC_FAR *pRate) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Rate( 
            /* [in] */ double Rate) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendKeyboardEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendKeyboardEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendKeyboardEvents( 
            /* [in] */ VARIANT_BOOL SendKeyboardEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendMouseClickEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseClickEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendMouseClickEvents( 
            /* [in] */ VARIANT_BOOL SendMouseClickEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendMouseMoveEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseMoveEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendMouseMoveEvents( 
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayCount( 
            /* [retval][out] */ long __RPC_FAR *pPlayCount) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PlayCount( 
            /* [in] */ long PlayCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClickToPlay( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pClickToPlay) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ClickToPlay( 
            /* [in] */ VARIANT_BOOL ClickToPlay) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowScan( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowScan) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowScan( 
            /* [in] */ VARIANT_BOOL AllowScan) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableContextMenu( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnableContextMenu) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableContextMenu( 
            /* [in] */ VARIANT_BOOL EnableContextMenu) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CursorType( 
            /* [retval][out] */ long __RPC_FAR *pCursorType) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CursorType( 
            /* [in] */ long CursorType) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CodecCount( 
            /* [retval][out] */ long __RPC_FAR *pCodecCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AllowChangeDisplaySize( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowChangeDisplaySize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AllowChangeDisplaySize( 
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_IsDurationValid( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDurationValid) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_OpenState( 
            /* [retval][out] */ long __RPC_FAR *pOpenState) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendOpenStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendOpenStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendOpenStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendWarningEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendWarningEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendWarningEvents( 
            /* [in] */ VARIANT_BOOL SendWarningEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendErrorEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendErrorEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendErrorEvents( 
            /* [in] */ VARIANT_BOOL SendErrorEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PlayState( 
            /* [retval][out] */ MPPlayStateConstants __RPC_FAR *pPlayState) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SendPlayStateChangeEvents( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendPlayStateChangeEvents) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SendPlayStateChangeEvents( 
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplaySize( 
            /* [retval][out] */ MPDisplaySizeConstants __RPC_FAR *pDisplaySize) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplaySize( 
            /* [in] */ MPDisplaySizeConstants DisplaySize) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_InvokeURLs( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pInvokeURLs) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_InvokeURLs( 
            /* [in] */ VARIANT_BOOL InvokeURLs) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_BaseURL( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_BaseURL( 
            /* [in] */ BSTR bstrBaseURL) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DefaultFrame( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DefaultFrame( 
            /* [in] */ BSTR bstrDefaultFrame) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HasError( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasError) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorDescription( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorDescription) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ErrorCode( 
            /* [retval][out] */ long __RPC_FAR *pErrorCode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AnimationAtStart( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAnimationAtStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AnimationAtStart( 
            /* [in] */ VARIANT_BOOL AnimationAtStart) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_TransparentAtStart( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pTransparentAtStart) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_TransparentAtStart( 
            /* [in] */ VARIANT_BOOL TransparentAtStart) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Volume( 
            /* [retval][out] */ long __RPC_FAR *pVolume) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Volume( 
            /* [in] */ long Volume) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Balance( 
            /* [retval][out] */ long __RPC_FAR *pBalance) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Balance( 
            /* [in] */ long Balance) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ReadyState( 
            /* [retval][out] */ MPReadyStateConstants __RPC_FAR *pValue) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionStart( 
            /* [retval][out] */ double __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectionStart( 
            /* [in] */ double Value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SelectionEnd( 
            /* [retval][out] */ double __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SelectionEnd( 
            /* [in] */ double Value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowDisplay( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowDisplay( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowPositionControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowPositionControls( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowTracker( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowTracker( 
            /* [in] */ VARIANT_BOOL Show) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnablePositionControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnablePositionControls( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableTracker( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableTracker( 
            /* [in] */ VARIANT_BOOL Enable) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Enabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Enabled( 
            /* [in] */ VARIANT_BOOL Enabled) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayForeColor( 
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *ForeColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayForeColor( 
            /* [in] */ VB_OLE_COLOR ForeColor) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayBackColor( 
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *BackColor) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayBackColor( 
            /* [in] */ VB_OLE_COLOR BackColor) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_DisplayMode( 
            /* [retval][out] */ MPDisplayModeConstants __RPC_FAR *pValue) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_DisplayMode( 
            /* [in] */ MPDisplayModeConstants Value) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorder3D( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorder3D( 
            /* [in] */ VARIANT_BOOL VideoBorderWidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorderWidth( 
            /* [retval][out] */ long __RPC_FAR *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorderWidth( 
            /* [in] */ long VideoBorderWidth) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_VideoBorderColor( 
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *pVideoBorderWidth) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_VideoBorderColor( 
            /* [in] */ VB_OLE_COLOR VideoBorderColor) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowGotoBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowGotoBar( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowStatusBar( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowStatusBar( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowCaptioning( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowCaptioning( 
            /* [in] */ VARIANT_BOOL pbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ShowAudioControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_ShowAudioControls( 
            /* [in] */ VARIANT_BOOL bBool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CaptioningID( 
            /* [retval][out] */ BSTR __RPC_FAR *pstrText) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_CaptioningID( 
            /* [in] */ BSTR strText) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Mute( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Mute( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_CanPreview( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanPreview) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_PreviewMode( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pPreviewMode) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_PreviewMode( 
            /* [in] */ VARIANT_BOOL PreviewMode) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_HasMultipleItems( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasMuliItems) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_Language( 
            /* [retval][out] */ long __RPC_FAR *pLanguage) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Language( 
            /* [in] */ long Language) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AudioStream( 
            /* [retval][out] */ long __RPC_FAR *pStream) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AudioStream( 
            /* [in] */ long Stream) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMIStyle( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStyle) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMIStyle( 
            /* [in] */ BSTR bstrStyle) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMILang( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLang) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMILang( 
            /* [in] */ BSTR bstrLang) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_SAMIFileName( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_SAMIFileName( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_StreamCount( 
            /* [retval][out] */ long __RPC_FAR *pStreamCount) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ClientId( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrClientId) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_ConnectionSpeed( 
            /* [retval][out] */ long __RPC_FAR *plConnectionSpeed) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_AutoSize( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_AutoSize( 
            /* [in] */ VARIANT_BOOL vbool) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_EnableFullScreenControls( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_EnableFullScreenControls( 
            /* [in] */ VARIANT_BOOL bVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_ActiveMovie( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_NSPlay( 
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch) = 0;
        
        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE get_WindowlessVideo( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_WindowlessVideo( 
            /* [in] */ VARIANT_BOOL boolVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Play( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Stop( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Pause( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMarkerTime( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double __RPC_FAR *pMarkerTime) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMarkerName( 
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AboutBox( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCodecInstalled( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCodecInstalled) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCodecDescription( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecDescription) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCodecURL( 
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMoreInfoURL( 
            /* [in] */ MPMoreInfoType MoreInfoType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMoreInfoURL) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetMediaInfoString( 
            /* [in] */ MPMediaInfoType MediaInfoType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMediaInfo) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Cancel( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ BSTR bstrFileName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IsSoundCardEnabled( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSoundCard) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Next( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Previous( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE StreamSelect( 
            /* [in] */ long StreamNum) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FastForward( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE FastReverse( void) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStreamName( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStreamName) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStreamGroup( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ long __RPC_FAR *pStreamGroup) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStreamSelected( 
            /* [in] */ long StreamNum,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStreamSelected) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMediaPlayerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMediaPlayer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMediaPlayer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentPosition )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pCurrentPosition);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CurrentPosition )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double CurrentPosition);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Duration )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pDuration);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageSourceWidth )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pWidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ImageSourceHeight )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pHeight);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_MarkerCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMarkerCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanScan )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanScan);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanSeek )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeek);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanSeekToMarkers )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeekToMarkers);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CurrentMarker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCurrentMarker);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CurrentMarker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CurrentMarker);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_FileName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_FileName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceLink )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceLink);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CreationDate )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ DATE __RPC_FAR *pCreationDate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorCorrection )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorCorrection);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Bandwidth )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pBandwidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SourceProtocol )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pSourceProtocol);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReceivedPackets )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pReceivedPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_RecoveredPackets )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pRecoveredPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LostPackets )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pLostPackets);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReceptionQuality )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pReceptionQuality);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BufferingCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pBufferingCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsBroadcast )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsBroadcast);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BufferingProgress )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pBufferingProgress);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ChannelName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ChannelDescription )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelDescription);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ChannelURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContactAddress )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactAddress);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContactPhone )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactPhone);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContactEmail )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContactEmail);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BufferingTime )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pBufferingTime);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BufferingTime )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double BufferingTime);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AutoStart);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoRewind )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoRewind);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoRewind )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AutoRewind);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Rate )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pRate);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Rate )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double Rate);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendKeyboardEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendKeyboardEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendKeyboardEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendKeyboardEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendMouseClickEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseClickEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendMouseClickEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendMouseClickEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendMouseMoveEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseMoveEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendMouseMoveEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendMouseMoveEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PlayCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pPlayCount);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PlayCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long PlayCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClickToPlay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pClickToPlay);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ClickToPlay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL ClickToPlay);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowScan )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowScan);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowScan )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AllowScan);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableContextMenu )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnableContextMenu);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableContextMenu )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL EnableContextMenu);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CursorType )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCursorType);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CursorType )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CursorType);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodecCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCodecCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AllowChangeDisplaySize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowChangeDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AllowChangeDisplaySize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AllowChangeDisplaySize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_IsDurationValid )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDurationValid);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_OpenState )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pOpenState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendOpenStateChangeEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendOpenStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendOpenStateChangeEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendWarningEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendWarningEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendWarningEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendWarningEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendErrorEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendErrorEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendErrorEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendErrorEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PlayState )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ MPPlayStateConstants __RPC_FAR *pPlayState);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SendPlayStateChangeEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendPlayStateChangeEvents);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SendPlayStateChangeEvents )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplaySize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ MPDisplaySizeConstants __RPC_FAR *pDisplaySize);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplaySize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ MPDisplaySizeConstants DisplaySize);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_InvokeURLs )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pInvokeURLs);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_InvokeURLs )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL InvokeURLs);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_BaseURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_BaseURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrBaseURL);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DefaultFrame )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DefaultFrame )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrDefaultFrame);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasError )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasError);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorDescription )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorDescription);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ErrorCode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pErrorCode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AnimationAtStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAnimationAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AnimationAtStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL AnimationAtStart);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TransparentAtStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pTransparentAtStart);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_TransparentAtStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL TransparentAtStart);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Volume )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVolume);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Volume )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long Volume);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Balance )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pBalance);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Balance )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long Balance);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ReadyState )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ MPReadyStateConstants __RPC_FAR *pValue);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SelectionStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SelectionStart )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double Value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SelectionEnd )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ double __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SelectionEnd )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ double Value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowDisplay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowDisplay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowPositionControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowPositionControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowTracker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowTracker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Show);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnablePositionControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnablePositionControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableTracker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableTracker )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Enable);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Enabled )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Enabled )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL Enabled);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayForeColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *ForeColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayForeColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VB_OLE_COLOR ForeColor);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayBackColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *BackColor);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayBackColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VB_OLE_COLOR BackColor);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_DisplayMode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ MPDisplayModeConstants __RPC_FAR *pValue);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_DisplayMode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ MPDisplayModeConstants Value);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VideoBorder3D )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VideoBorder3D )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL VideoBorderWidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VideoBorderWidth )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VideoBorderWidth )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long VideoBorderWidth);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_VideoBorderColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *pVideoBorderWidth);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_VideoBorderColor )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VB_OLE_COLOR VideoBorderColor);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowGotoBar )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowGotoBar )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowStatusBar )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowStatusBar )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowCaptioning )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowCaptioning )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL pbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ShowAudioControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ShowAudioControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bBool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CaptioningID )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstrText);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CaptioningID )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR strText);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Mute )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Mute )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CanPreview )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanPreview);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_PreviewMode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pPreviewMode);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_PreviewMode )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL PreviewMode);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasMultipleItems )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasMuliItems);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Language )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pLanguage);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Language )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long Language);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AudioStream )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pStream);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AudioStream )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long Stream);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMIStyle )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStyle);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMIStyle )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrStyle);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMILang )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrLang);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMILang )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrLang);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SAMIFileName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_SAMIFileName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StreamCount )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pStreamCount);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientId )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrClientId);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ConnectionSpeed )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plConnectionSpeed);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_AutoSize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_AutoSize )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL vbool);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_EnableFullScreenControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_EnableFullScreenControls )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL bVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ActiveMovie )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_NSPlay )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch);
        
        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_WindowlessVideo )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_WindowlessVideo )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL boolVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Play )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Stop )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pause )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerTime )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ double __RPC_FAR *pMarkerTime);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMarkerName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long MarkerNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AboutBox )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecInstalled )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCodecInstalled);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecDescription )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecDescription);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodecURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long CodecNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMoreInfoURL )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ MPMoreInfoType MoreInfoType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMoreInfoURL);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetMediaInfoString )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ MPMediaInfoType MediaInfoType,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrMediaInfo);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cancel )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ BSTR bstrFileName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsSoundCardEnabled )( 
            IMediaPlayer __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSoundCard);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Previous )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StreamSelect )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long StreamNum);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FastForward )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FastReverse )( 
            IMediaPlayer __RPC_FAR * This);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamName )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStreamName);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamGroup )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ long __RPC_FAR *pStreamGroup);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStreamSelected )( 
            IMediaPlayer __RPC_FAR * This,
            /* [in] */ long StreamNum,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStreamSelected);
        
        END_INTERFACE
    } IMediaPlayerVtbl;

    interface IMediaPlayer
    {
        CONST_VTBL struct IMediaPlayerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMediaPlayer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMediaPlayer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMediaPlayer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMediaPlayer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IMediaPlayer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IMediaPlayer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IMediaPlayer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IMediaPlayer_get_CurrentPosition(This,pCurrentPosition)	\
    (This)->lpVtbl -> get_CurrentPosition(This,pCurrentPosition)

#define IMediaPlayer_put_CurrentPosition(This,CurrentPosition)	\
    (This)->lpVtbl -> put_CurrentPosition(This,CurrentPosition)

#define IMediaPlayer_get_Duration(This,pDuration)	\
    (This)->lpVtbl -> get_Duration(This,pDuration)

#define IMediaPlayer_get_ImageSourceWidth(This,pWidth)	\
    (This)->lpVtbl -> get_ImageSourceWidth(This,pWidth)

#define IMediaPlayer_get_ImageSourceHeight(This,pHeight)	\
    (This)->lpVtbl -> get_ImageSourceHeight(This,pHeight)

#define IMediaPlayer_get_MarkerCount(This,pMarkerCount)	\
    (This)->lpVtbl -> get_MarkerCount(This,pMarkerCount)

#define IMediaPlayer_get_CanScan(This,pCanScan)	\
    (This)->lpVtbl -> get_CanScan(This,pCanScan)

#define IMediaPlayer_get_CanSeek(This,pCanSeek)	\
    (This)->lpVtbl -> get_CanSeek(This,pCanSeek)

#define IMediaPlayer_get_CanSeekToMarkers(This,pCanSeekToMarkers)	\
    (This)->lpVtbl -> get_CanSeekToMarkers(This,pCanSeekToMarkers)

#define IMediaPlayer_get_CurrentMarker(This,pCurrentMarker)	\
    (This)->lpVtbl -> get_CurrentMarker(This,pCurrentMarker)

#define IMediaPlayer_put_CurrentMarker(This,CurrentMarker)	\
    (This)->lpVtbl -> put_CurrentMarker(This,CurrentMarker)

#define IMediaPlayer_get_FileName(This,pbstrFileName)	\
    (This)->lpVtbl -> get_FileName(This,pbstrFileName)

#define IMediaPlayer_put_FileName(This,bstrFileName)	\
    (This)->lpVtbl -> put_FileName(This,bstrFileName)

#define IMediaPlayer_get_SourceLink(This,pbstrSourceLink)	\
    (This)->lpVtbl -> get_SourceLink(This,pbstrSourceLink)

#define IMediaPlayer_get_CreationDate(This,pCreationDate)	\
    (This)->lpVtbl -> get_CreationDate(This,pCreationDate)

#define IMediaPlayer_get_ErrorCorrection(This,pbstrErrorCorrection)	\
    (This)->lpVtbl -> get_ErrorCorrection(This,pbstrErrorCorrection)

#define IMediaPlayer_get_Bandwidth(This,pBandwidth)	\
    (This)->lpVtbl -> get_Bandwidth(This,pBandwidth)

#define IMediaPlayer_get_SourceProtocol(This,pSourceProtocol)	\
    (This)->lpVtbl -> get_SourceProtocol(This,pSourceProtocol)

#define IMediaPlayer_get_ReceivedPackets(This,pReceivedPackets)	\
    (This)->lpVtbl -> get_ReceivedPackets(This,pReceivedPackets)

#define IMediaPlayer_get_RecoveredPackets(This,pRecoveredPackets)	\
    (This)->lpVtbl -> get_RecoveredPackets(This,pRecoveredPackets)

#define IMediaPlayer_get_LostPackets(This,pLostPackets)	\
    (This)->lpVtbl -> get_LostPackets(This,pLostPackets)

#define IMediaPlayer_get_ReceptionQuality(This,pReceptionQuality)	\
    (This)->lpVtbl -> get_ReceptionQuality(This,pReceptionQuality)

#define IMediaPlayer_get_BufferingCount(This,pBufferingCount)	\
    (This)->lpVtbl -> get_BufferingCount(This,pBufferingCount)

#define IMediaPlayer_get_IsBroadcast(This,pIsBroadcast)	\
    (This)->lpVtbl -> get_IsBroadcast(This,pIsBroadcast)

#define IMediaPlayer_get_BufferingProgress(This,pBufferingProgress)	\
    (This)->lpVtbl -> get_BufferingProgress(This,pBufferingProgress)

#define IMediaPlayer_get_ChannelName(This,pbstrChannelName)	\
    (This)->lpVtbl -> get_ChannelName(This,pbstrChannelName)

#define IMediaPlayer_get_ChannelDescription(This,pbstrChannelDescription)	\
    (This)->lpVtbl -> get_ChannelDescription(This,pbstrChannelDescription)

#define IMediaPlayer_get_ChannelURL(This,pbstrChannelURL)	\
    (This)->lpVtbl -> get_ChannelURL(This,pbstrChannelURL)

#define IMediaPlayer_get_ContactAddress(This,pbstrContactAddress)	\
    (This)->lpVtbl -> get_ContactAddress(This,pbstrContactAddress)

#define IMediaPlayer_get_ContactPhone(This,pbstrContactPhone)	\
    (This)->lpVtbl -> get_ContactPhone(This,pbstrContactPhone)

#define IMediaPlayer_get_ContactEmail(This,pbstrContactEmail)	\
    (This)->lpVtbl -> get_ContactEmail(This,pbstrContactEmail)

#define IMediaPlayer_get_BufferingTime(This,pBufferingTime)	\
    (This)->lpVtbl -> get_BufferingTime(This,pBufferingTime)

#define IMediaPlayer_put_BufferingTime(This,BufferingTime)	\
    (This)->lpVtbl -> put_BufferingTime(This,BufferingTime)

#define IMediaPlayer_get_AutoStart(This,pAutoStart)	\
    (This)->lpVtbl -> get_AutoStart(This,pAutoStart)

#define IMediaPlayer_put_AutoStart(This,AutoStart)	\
    (This)->lpVtbl -> put_AutoStart(This,AutoStart)

#define IMediaPlayer_get_AutoRewind(This,pAutoRewind)	\
    (This)->lpVtbl -> get_AutoRewind(This,pAutoRewind)

#define IMediaPlayer_put_AutoRewind(This,AutoRewind)	\
    (This)->lpVtbl -> put_AutoRewind(This,AutoRewind)

#define IMediaPlayer_get_Rate(This,pRate)	\
    (This)->lpVtbl -> get_Rate(This,pRate)

#define IMediaPlayer_put_Rate(This,Rate)	\
    (This)->lpVtbl -> put_Rate(This,Rate)

#define IMediaPlayer_get_SendKeyboardEvents(This,pSendKeyboardEvents)	\
    (This)->lpVtbl -> get_SendKeyboardEvents(This,pSendKeyboardEvents)

#define IMediaPlayer_put_SendKeyboardEvents(This,SendKeyboardEvents)	\
    (This)->lpVtbl -> put_SendKeyboardEvents(This,SendKeyboardEvents)

#define IMediaPlayer_get_SendMouseClickEvents(This,pSendMouseClickEvents)	\
    (This)->lpVtbl -> get_SendMouseClickEvents(This,pSendMouseClickEvents)

#define IMediaPlayer_put_SendMouseClickEvents(This,SendMouseClickEvents)	\
    (This)->lpVtbl -> put_SendMouseClickEvents(This,SendMouseClickEvents)

#define IMediaPlayer_get_SendMouseMoveEvents(This,pSendMouseMoveEvents)	\
    (This)->lpVtbl -> get_SendMouseMoveEvents(This,pSendMouseMoveEvents)

#define IMediaPlayer_put_SendMouseMoveEvents(This,SendMouseMoveEvents)	\
    (This)->lpVtbl -> put_SendMouseMoveEvents(This,SendMouseMoveEvents)

#define IMediaPlayer_get_PlayCount(This,pPlayCount)	\
    (This)->lpVtbl -> get_PlayCount(This,pPlayCount)

#define IMediaPlayer_put_PlayCount(This,PlayCount)	\
    (This)->lpVtbl -> put_PlayCount(This,PlayCount)

#define IMediaPlayer_get_ClickToPlay(This,pClickToPlay)	\
    (This)->lpVtbl -> get_ClickToPlay(This,pClickToPlay)

#define IMediaPlayer_put_ClickToPlay(This,ClickToPlay)	\
    (This)->lpVtbl -> put_ClickToPlay(This,ClickToPlay)

#define IMediaPlayer_get_AllowScan(This,pAllowScan)	\
    (This)->lpVtbl -> get_AllowScan(This,pAllowScan)

#define IMediaPlayer_put_AllowScan(This,AllowScan)	\
    (This)->lpVtbl -> put_AllowScan(This,AllowScan)

#define IMediaPlayer_get_EnableContextMenu(This,pEnableContextMenu)	\
    (This)->lpVtbl -> get_EnableContextMenu(This,pEnableContextMenu)

#define IMediaPlayer_put_EnableContextMenu(This,EnableContextMenu)	\
    (This)->lpVtbl -> put_EnableContextMenu(This,EnableContextMenu)

#define IMediaPlayer_get_CursorType(This,pCursorType)	\
    (This)->lpVtbl -> get_CursorType(This,pCursorType)

#define IMediaPlayer_put_CursorType(This,CursorType)	\
    (This)->lpVtbl -> put_CursorType(This,CursorType)

#define IMediaPlayer_get_CodecCount(This,pCodecCount)	\
    (This)->lpVtbl -> get_CodecCount(This,pCodecCount)

#define IMediaPlayer_get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize)	\
    (This)->lpVtbl -> get_AllowChangeDisplaySize(This,pAllowChangeDisplaySize)

#define IMediaPlayer_put_AllowChangeDisplaySize(This,AllowChangeDisplaySize)	\
    (This)->lpVtbl -> put_AllowChangeDisplaySize(This,AllowChangeDisplaySize)

#define IMediaPlayer_get_IsDurationValid(This,pIsDurationValid)	\
    (This)->lpVtbl -> get_IsDurationValid(This,pIsDurationValid)

#define IMediaPlayer_get_OpenState(This,pOpenState)	\
    (This)->lpVtbl -> get_OpenState(This,pOpenState)

#define IMediaPlayer_get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents)	\
    (This)->lpVtbl -> get_SendOpenStateChangeEvents(This,pSendOpenStateChangeEvents)

#define IMediaPlayer_put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents)	\
    (This)->lpVtbl -> put_SendOpenStateChangeEvents(This,SendOpenStateChangeEvents)

#define IMediaPlayer_get_SendWarningEvents(This,pSendWarningEvents)	\
    (This)->lpVtbl -> get_SendWarningEvents(This,pSendWarningEvents)

#define IMediaPlayer_put_SendWarningEvents(This,SendWarningEvents)	\
    (This)->lpVtbl -> put_SendWarningEvents(This,SendWarningEvents)

#define IMediaPlayer_get_SendErrorEvents(This,pSendErrorEvents)	\
    (This)->lpVtbl -> get_SendErrorEvents(This,pSendErrorEvents)

#define IMediaPlayer_put_SendErrorEvents(This,SendErrorEvents)	\
    (This)->lpVtbl -> put_SendErrorEvents(This,SendErrorEvents)

#define IMediaPlayer_get_PlayState(This,pPlayState)	\
    (This)->lpVtbl -> get_PlayState(This,pPlayState)

#define IMediaPlayer_get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents)	\
    (This)->lpVtbl -> get_SendPlayStateChangeEvents(This,pSendPlayStateChangeEvents)

#define IMediaPlayer_put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents)	\
    (This)->lpVtbl -> put_SendPlayStateChangeEvents(This,SendPlayStateChangeEvents)

#define IMediaPlayer_get_DisplaySize(This,pDisplaySize)	\
    (This)->lpVtbl -> get_DisplaySize(This,pDisplaySize)

#define IMediaPlayer_put_DisplaySize(This,DisplaySize)	\
    (This)->lpVtbl -> put_DisplaySize(This,DisplaySize)

#define IMediaPlayer_get_InvokeURLs(This,pInvokeURLs)	\
    (This)->lpVtbl -> get_InvokeURLs(This,pInvokeURLs)

#define IMediaPlayer_put_InvokeURLs(This,InvokeURLs)	\
    (This)->lpVtbl -> put_InvokeURLs(This,InvokeURLs)

#define IMediaPlayer_get_BaseURL(This,pbstrBaseURL)	\
    (This)->lpVtbl -> get_BaseURL(This,pbstrBaseURL)

#define IMediaPlayer_put_BaseURL(This,bstrBaseURL)	\
    (This)->lpVtbl -> put_BaseURL(This,bstrBaseURL)

#define IMediaPlayer_get_DefaultFrame(This,pbstrDefaultFrame)	\
    (This)->lpVtbl -> get_DefaultFrame(This,pbstrDefaultFrame)

#define IMediaPlayer_put_DefaultFrame(This,bstrDefaultFrame)	\
    (This)->lpVtbl -> put_DefaultFrame(This,bstrDefaultFrame)

#define IMediaPlayer_get_HasError(This,pHasError)	\
    (This)->lpVtbl -> get_HasError(This,pHasError)

#define IMediaPlayer_get_ErrorDescription(This,pbstrErrorDescription)	\
    (This)->lpVtbl -> get_ErrorDescription(This,pbstrErrorDescription)

#define IMediaPlayer_get_ErrorCode(This,pErrorCode)	\
    (This)->lpVtbl -> get_ErrorCode(This,pErrorCode)

#define IMediaPlayer_get_AnimationAtStart(This,pAnimationAtStart)	\
    (This)->lpVtbl -> get_AnimationAtStart(This,pAnimationAtStart)

#define IMediaPlayer_put_AnimationAtStart(This,AnimationAtStart)	\
    (This)->lpVtbl -> put_AnimationAtStart(This,AnimationAtStart)

#define IMediaPlayer_get_TransparentAtStart(This,pTransparentAtStart)	\
    (This)->lpVtbl -> get_TransparentAtStart(This,pTransparentAtStart)

#define IMediaPlayer_put_TransparentAtStart(This,TransparentAtStart)	\
    (This)->lpVtbl -> put_TransparentAtStart(This,TransparentAtStart)

#define IMediaPlayer_get_Volume(This,pVolume)	\
    (This)->lpVtbl -> get_Volume(This,pVolume)

#define IMediaPlayer_put_Volume(This,Volume)	\
    (This)->lpVtbl -> put_Volume(This,Volume)

#define IMediaPlayer_get_Balance(This,pBalance)	\
    (This)->lpVtbl -> get_Balance(This,pBalance)

#define IMediaPlayer_put_Balance(This,Balance)	\
    (This)->lpVtbl -> put_Balance(This,Balance)

#define IMediaPlayer_get_ReadyState(This,pValue)	\
    (This)->lpVtbl -> get_ReadyState(This,pValue)

#define IMediaPlayer_get_SelectionStart(This,pValue)	\
    (This)->lpVtbl -> get_SelectionStart(This,pValue)

#define IMediaPlayer_put_SelectionStart(This,Value)	\
    (This)->lpVtbl -> put_SelectionStart(This,Value)

#define IMediaPlayer_get_SelectionEnd(This,pValue)	\
    (This)->lpVtbl -> get_SelectionEnd(This,pValue)

#define IMediaPlayer_put_SelectionEnd(This,Value)	\
    (This)->lpVtbl -> put_SelectionEnd(This,Value)

#define IMediaPlayer_get_ShowDisplay(This,Show)	\
    (This)->lpVtbl -> get_ShowDisplay(This,Show)

#define IMediaPlayer_put_ShowDisplay(This,Show)	\
    (This)->lpVtbl -> put_ShowDisplay(This,Show)

#define IMediaPlayer_get_ShowControls(This,Show)	\
    (This)->lpVtbl -> get_ShowControls(This,Show)

#define IMediaPlayer_put_ShowControls(This,Show)	\
    (This)->lpVtbl -> put_ShowControls(This,Show)

#define IMediaPlayer_get_ShowPositionControls(This,Show)	\
    (This)->lpVtbl -> get_ShowPositionControls(This,Show)

#define IMediaPlayer_put_ShowPositionControls(This,Show)	\
    (This)->lpVtbl -> put_ShowPositionControls(This,Show)

#define IMediaPlayer_get_ShowTracker(This,Show)	\
    (This)->lpVtbl -> get_ShowTracker(This,Show)

#define IMediaPlayer_put_ShowTracker(This,Show)	\
    (This)->lpVtbl -> put_ShowTracker(This,Show)

#define IMediaPlayer_get_EnablePositionControls(This,Enable)	\
    (This)->lpVtbl -> get_EnablePositionControls(This,Enable)

#define IMediaPlayer_put_EnablePositionControls(This,Enable)	\
    (This)->lpVtbl -> put_EnablePositionControls(This,Enable)

#define IMediaPlayer_get_EnableTracker(This,Enable)	\
    (This)->lpVtbl -> get_EnableTracker(This,Enable)

#define IMediaPlayer_put_EnableTracker(This,Enable)	\
    (This)->lpVtbl -> put_EnableTracker(This,Enable)

#define IMediaPlayer_get_Enabled(This,pEnabled)	\
    (This)->lpVtbl -> get_Enabled(This,pEnabled)

#define IMediaPlayer_put_Enabled(This,Enabled)	\
    (This)->lpVtbl -> put_Enabled(This,Enabled)

#define IMediaPlayer_get_DisplayForeColor(This,ForeColor)	\
    (This)->lpVtbl -> get_DisplayForeColor(This,ForeColor)

#define IMediaPlayer_put_DisplayForeColor(This,ForeColor)	\
    (This)->lpVtbl -> put_DisplayForeColor(This,ForeColor)

#define IMediaPlayer_get_DisplayBackColor(This,BackColor)	\
    (This)->lpVtbl -> get_DisplayBackColor(This,BackColor)

#define IMediaPlayer_put_DisplayBackColor(This,BackColor)	\
    (This)->lpVtbl -> put_DisplayBackColor(This,BackColor)

#define IMediaPlayer_get_DisplayMode(This,pValue)	\
    (This)->lpVtbl -> get_DisplayMode(This,pValue)

#define IMediaPlayer_put_DisplayMode(This,Value)	\
    (This)->lpVtbl -> put_DisplayMode(This,Value)

#define IMediaPlayer_get_VideoBorder3D(This,pVideoBorderWidth)	\
    (This)->lpVtbl -> get_VideoBorder3D(This,pVideoBorderWidth)

#define IMediaPlayer_put_VideoBorder3D(This,VideoBorderWidth)	\
    (This)->lpVtbl -> put_VideoBorder3D(This,VideoBorderWidth)

#define IMediaPlayer_get_VideoBorderWidth(This,pVideoBorderWidth)	\
    (This)->lpVtbl -> get_VideoBorderWidth(This,pVideoBorderWidth)

#define IMediaPlayer_put_VideoBorderWidth(This,VideoBorderWidth)	\
    (This)->lpVtbl -> put_VideoBorderWidth(This,VideoBorderWidth)

#define IMediaPlayer_get_VideoBorderColor(This,pVideoBorderWidth)	\
    (This)->lpVtbl -> get_VideoBorderColor(This,pVideoBorderWidth)

#define IMediaPlayer_put_VideoBorderColor(This,VideoBorderColor)	\
    (This)->lpVtbl -> put_VideoBorderColor(This,VideoBorderColor)

#define IMediaPlayer_get_ShowGotoBar(This,pbool)	\
    (This)->lpVtbl -> get_ShowGotoBar(This,pbool)

#define IMediaPlayer_put_ShowGotoBar(This,vbool)	\
    (This)->lpVtbl -> put_ShowGotoBar(This,vbool)

#define IMediaPlayer_get_ShowStatusBar(This,pbool)	\
    (This)->lpVtbl -> get_ShowStatusBar(This,pbool)

#define IMediaPlayer_put_ShowStatusBar(This,vbool)	\
    (This)->lpVtbl -> put_ShowStatusBar(This,vbool)

#define IMediaPlayer_get_ShowCaptioning(This,pbool)	\
    (This)->lpVtbl -> get_ShowCaptioning(This,pbool)

#define IMediaPlayer_put_ShowCaptioning(This,pbool)	\
    (This)->lpVtbl -> put_ShowCaptioning(This,pbool)

#define IMediaPlayer_get_ShowAudioControls(This,pbool)	\
    (This)->lpVtbl -> get_ShowAudioControls(This,pbool)

#define IMediaPlayer_put_ShowAudioControls(This,bBool)	\
    (This)->lpVtbl -> put_ShowAudioControls(This,bBool)

#define IMediaPlayer_get_CaptioningID(This,pstrText)	\
    (This)->lpVtbl -> get_CaptioningID(This,pstrText)

#define IMediaPlayer_put_CaptioningID(This,strText)	\
    (This)->lpVtbl -> put_CaptioningID(This,strText)

#define IMediaPlayer_get_Mute(This,vbool)	\
    (This)->lpVtbl -> get_Mute(This,vbool)

#define IMediaPlayer_put_Mute(This,vbool)	\
    (This)->lpVtbl -> put_Mute(This,vbool)

#define IMediaPlayer_get_CanPreview(This,pCanPreview)	\
    (This)->lpVtbl -> get_CanPreview(This,pCanPreview)

#define IMediaPlayer_get_PreviewMode(This,pPreviewMode)	\
    (This)->lpVtbl -> get_PreviewMode(This,pPreviewMode)

#define IMediaPlayer_put_PreviewMode(This,PreviewMode)	\
    (This)->lpVtbl -> put_PreviewMode(This,PreviewMode)

#define IMediaPlayer_get_HasMultipleItems(This,pHasMuliItems)	\
    (This)->lpVtbl -> get_HasMultipleItems(This,pHasMuliItems)

#define IMediaPlayer_get_Language(This,pLanguage)	\
    (This)->lpVtbl -> get_Language(This,pLanguage)

#define IMediaPlayer_put_Language(This,Language)	\
    (This)->lpVtbl -> put_Language(This,Language)

#define IMediaPlayer_get_AudioStream(This,pStream)	\
    (This)->lpVtbl -> get_AudioStream(This,pStream)

#define IMediaPlayer_put_AudioStream(This,Stream)	\
    (This)->lpVtbl -> put_AudioStream(This,Stream)

#define IMediaPlayer_get_SAMIStyle(This,pbstrStyle)	\
    (This)->lpVtbl -> get_SAMIStyle(This,pbstrStyle)

#define IMediaPlayer_put_SAMIStyle(This,bstrStyle)	\
    (This)->lpVtbl -> put_SAMIStyle(This,bstrStyle)

#define IMediaPlayer_get_SAMILang(This,pbstrLang)	\
    (This)->lpVtbl -> get_SAMILang(This,pbstrLang)

#define IMediaPlayer_put_SAMILang(This,bstrLang)	\
    (This)->lpVtbl -> put_SAMILang(This,bstrLang)

#define IMediaPlayer_get_SAMIFileName(This,pbstrFileName)	\
    (This)->lpVtbl -> get_SAMIFileName(This,pbstrFileName)

#define IMediaPlayer_put_SAMIFileName(This,bstrFileName)	\
    (This)->lpVtbl -> put_SAMIFileName(This,bstrFileName)

#define IMediaPlayer_get_StreamCount(This,pStreamCount)	\
    (This)->lpVtbl -> get_StreamCount(This,pStreamCount)

#define IMediaPlayer_get_ClientId(This,pbstrClientId)	\
    (This)->lpVtbl -> get_ClientId(This,pbstrClientId)

#define IMediaPlayer_get_ConnectionSpeed(This,plConnectionSpeed)	\
    (This)->lpVtbl -> get_ConnectionSpeed(This,plConnectionSpeed)

#define IMediaPlayer_get_AutoSize(This,pbool)	\
    (This)->lpVtbl -> get_AutoSize(This,pbool)

#define IMediaPlayer_put_AutoSize(This,vbool)	\
    (This)->lpVtbl -> put_AutoSize(This,vbool)

#define IMediaPlayer_get_EnableFullScreenControls(This,pbVal)	\
    (This)->lpVtbl -> get_EnableFullScreenControls(This,pbVal)

#define IMediaPlayer_put_EnableFullScreenControls(This,bVal)	\
    (This)->lpVtbl -> put_EnableFullScreenControls(This,bVal)

#define IMediaPlayer_get_ActiveMovie(This,ppdispatch)	\
    (This)->lpVtbl -> get_ActiveMovie(This,ppdispatch)

#define IMediaPlayer_get_NSPlay(This,ppdispatch)	\
    (This)->lpVtbl -> get_NSPlay(This,ppdispatch)

#define IMediaPlayer_get_WindowlessVideo(This,pbool)	\
    (This)->lpVtbl -> get_WindowlessVideo(This,pbool)

#define IMediaPlayer_put_WindowlessVideo(This,boolVal)	\
    (This)->lpVtbl -> put_WindowlessVideo(This,boolVal)

#define IMediaPlayer_Play(This)	\
    (This)->lpVtbl -> Play(This)

#define IMediaPlayer_Stop(This)	\
    (This)->lpVtbl -> Stop(This)

#define IMediaPlayer_Pause(This)	\
    (This)->lpVtbl -> Pause(This)

#define IMediaPlayer_GetMarkerTime(This,MarkerNum,pMarkerTime)	\
    (This)->lpVtbl -> GetMarkerTime(This,MarkerNum,pMarkerTime)

#define IMediaPlayer_GetMarkerName(This,MarkerNum,pbstrMarkerName)	\
    (This)->lpVtbl -> GetMarkerName(This,MarkerNum,pbstrMarkerName)

#define IMediaPlayer_AboutBox(This)	\
    (This)->lpVtbl -> AboutBox(This)

#define IMediaPlayer_GetCodecInstalled(This,CodecNum,pCodecInstalled)	\
    (This)->lpVtbl -> GetCodecInstalled(This,CodecNum,pCodecInstalled)

#define IMediaPlayer_GetCodecDescription(This,CodecNum,pbstrCodecDescription)	\
    (This)->lpVtbl -> GetCodecDescription(This,CodecNum,pbstrCodecDescription)

#define IMediaPlayer_GetCodecURL(This,CodecNum,pbstrCodecURL)	\
    (This)->lpVtbl -> GetCodecURL(This,CodecNum,pbstrCodecURL)

#define IMediaPlayer_GetMoreInfoURL(This,MoreInfoType,pbstrMoreInfoURL)	\
    (This)->lpVtbl -> GetMoreInfoURL(This,MoreInfoType,pbstrMoreInfoURL)

#define IMediaPlayer_GetMediaInfoString(This,MediaInfoType,pbstrMediaInfo)	\
    (This)->lpVtbl -> GetMediaInfoString(This,MediaInfoType,pbstrMediaInfo)

#define IMediaPlayer_Cancel(This)	\
    (This)->lpVtbl -> Cancel(This)

#define IMediaPlayer_Open(This,bstrFileName)	\
    (This)->lpVtbl -> Open(This,bstrFileName)

#define IMediaPlayer_IsSoundCardEnabled(This,pbSoundCard)	\
    (This)->lpVtbl -> IsSoundCardEnabled(This,pbSoundCard)

#define IMediaPlayer_Next(This)	\
    (This)->lpVtbl -> Next(This)

#define IMediaPlayer_Previous(This)	\
    (This)->lpVtbl -> Previous(This)

#define IMediaPlayer_StreamSelect(This,StreamNum)	\
    (This)->lpVtbl -> StreamSelect(This,StreamNum)

#define IMediaPlayer_FastForward(This)	\
    (This)->lpVtbl -> FastForward(This)

#define IMediaPlayer_FastReverse(This)	\
    (This)->lpVtbl -> FastReverse(This)

#define IMediaPlayer_GetStreamName(This,StreamNum,pbstrStreamName)	\
    (This)->lpVtbl -> GetStreamName(This,StreamNum,pbstrStreamName)

#define IMediaPlayer_GetStreamGroup(This,StreamNum,pStreamGroup)	\
    (This)->lpVtbl -> GetStreamGroup(This,StreamNum,pStreamGroup)

#define IMediaPlayer_GetStreamSelected(This,StreamNum,pStreamSelected)	\
    (This)->lpVtbl -> GetStreamSelected(This,StreamNum,pStreamSelected)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CurrentPosition_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pCurrentPosition);


void __RPC_STUB IMediaPlayer_get_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CurrentPosition_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double CurrentPosition);


void __RPC_STUB IMediaPlayer_put_CurrentPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Duration_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pDuration);


void __RPC_STUB IMediaPlayer_get_Duration_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ImageSourceWidth_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pWidth);


void __RPC_STUB IMediaPlayer_get_ImageSourceWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ImageSourceHeight_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pHeight);


void __RPC_STUB IMediaPlayer_get_ImageSourceHeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_MarkerCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pMarkerCount);


void __RPC_STUB IMediaPlayer_get_MarkerCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanScan_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanScan);


void __RPC_STUB IMediaPlayer_get_CanScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanSeek_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeek);


void __RPC_STUB IMediaPlayer_get_CanSeek_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanSeekToMarkers_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanSeekToMarkers);


void __RPC_STUB IMediaPlayer_get_CanSeekToMarkers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CurrentMarker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCurrentMarker);


void __RPC_STUB IMediaPlayer_get_CurrentMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CurrentMarker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CurrentMarker);


void __RPC_STUB IMediaPlayer_put_CurrentMarker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_FileName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);


void __RPC_STUB IMediaPlayer_get_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_FileName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IMediaPlayer_put_FileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SourceLink_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrSourceLink);


void __RPC_STUB IMediaPlayer_get_SourceLink_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CreationDate_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ DATE __RPC_FAR *pCreationDate);


void __RPC_STUB IMediaPlayer_get_CreationDate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ErrorCorrection_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorCorrection);


void __RPC_STUB IMediaPlayer_get_ErrorCorrection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Bandwidth_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pBandwidth);


void __RPC_STUB IMediaPlayer_get_Bandwidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SourceProtocol_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pSourceProtocol);


void __RPC_STUB IMediaPlayer_get_SourceProtocol_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ReceivedPackets_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pReceivedPackets);


void __RPC_STUB IMediaPlayer_get_ReceivedPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_RecoveredPackets_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pRecoveredPackets);


void __RPC_STUB IMediaPlayer_get_RecoveredPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_LostPackets_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pLostPackets);


void __RPC_STUB IMediaPlayer_get_LostPackets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ReceptionQuality_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pReceptionQuality);


void __RPC_STUB IMediaPlayer_get_ReceptionQuality_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_BufferingCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pBufferingCount);


void __RPC_STUB IMediaPlayer_get_BufferingCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_IsBroadcast_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsBroadcast);


void __RPC_STUB IMediaPlayer_get_IsBroadcast_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_BufferingProgress_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pBufferingProgress);


void __RPC_STUB IMediaPlayer_get_BufferingProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ChannelName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelName);


void __RPC_STUB IMediaPlayer_get_ChannelName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ChannelDescription_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelDescription);


void __RPC_STUB IMediaPlayer_get_ChannelDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ChannelURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrChannelURL);


void __RPC_STUB IMediaPlayer_get_ChannelURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ContactAddress_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContactAddress);


void __RPC_STUB IMediaPlayer_get_ContactAddress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ContactPhone_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContactPhone);


void __RPC_STUB IMediaPlayer_get_ContactPhone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ContactEmail_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContactEmail);


void __RPC_STUB IMediaPlayer_get_ContactEmail_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_BufferingTime_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pBufferingTime);


void __RPC_STUB IMediaPlayer_get_BufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_BufferingTime_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double BufferingTime);


void __RPC_STUB IMediaPlayer_put_BufferingTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AutoStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoStart);


void __RPC_STUB IMediaPlayer_get_AutoStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AutoStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AutoStart);


void __RPC_STUB IMediaPlayer_put_AutoStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AutoRewind_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAutoRewind);


void __RPC_STUB IMediaPlayer_get_AutoRewind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AutoRewind_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AutoRewind);


void __RPC_STUB IMediaPlayer_put_AutoRewind_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Rate_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pRate);


void __RPC_STUB IMediaPlayer_get_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Rate_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double Rate);


void __RPC_STUB IMediaPlayer_put_Rate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendKeyboardEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendKeyboardEvents);


void __RPC_STUB IMediaPlayer_get_SendKeyboardEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendKeyboardEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendKeyboardEvents);


void __RPC_STUB IMediaPlayer_put_SendKeyboardEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendMouseClickEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseClickEvents);


void __RPC_STUB IMediaPlayer_get_SendMouseClickEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendMouseClickEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendMouseClickEvents);


void __RPC_STUB IMediaPlayer_put_SendMouseClickEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendMouseMoveEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendMouseMoveEvents);


void __RPC_STUB IMediaPlayer_get_SendMouseMoveEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendMouseMoveEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendMouseMoveEvents);


void __RPC_STUB IMediaPlayer_put_SendMouseMoveEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_PlayCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pPlayCount);


void __RPC_STUB IMediaPlayer_get_PlayCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_PlayCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long PlayCount);


void __RPC_STUB IMediaPlayer_put_PlayCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ClickToPlay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pClickToPlay);


void __RPC_STUB IMediaPlayer_get_ClickToPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ClickToPlay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL ClickToPlay);


void __RPC_STUB IMediaPlayer_put_ClickToPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AllowScan_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowScan);


void __RPC_STUB IMediaPlayer_get_AllowScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AllowScan_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AllowScan);


void __RPC_STUB IMediaPlayer_put_AllowScan_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnableContextMenu_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnableContextMenu);


void __RPC_STUB IMediaPlayer_get_EnableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnableContextMenu_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL EnableContextMenu);


void __RPC_STUB IMediaPlayer_put_EnableContextMenu_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CursorType_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCursorType);


void __RPC_STUB IMediaPlayer_get_CursorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CursorType_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CursorType);


void __RPC_STUB IMediaPlayer_put_CursorType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CodecCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCodecCount);


void __RPC_STUB IMediaPlayer_get_CodecCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AllowChangeDisplaySize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAllowChangeDisplaySize);


void __RPC_STUB IMediaPlayer_get_AllowChangeDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AllowChangeDisplaySize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AllowChangeDisplaySize);


void __RPC_STUB IMediaPlayer_put_AllowChangeDisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_IsDurationValid_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pIsDurationValid);


void __RPC_STUB IMediaPlayer_get_IsDurationValid_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_OpenState_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pOpenState);


void __RPC_STUB IMediaPlayer_get_OpenState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendOpenStateChangeEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendOpenStateChangeEvents);


void __RPC_STUB IMediaPlayer_get_SendOpenStateChangeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendOpenStateChangeEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendOpenStateChangeEvents);


void __RPC_STUB IMediaPlayer_put_SendOpenStateChangeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendWarningEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendWarningEvents);


void __RPC_STUB IMediaPlayer_get_SendWarningEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendWarningEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendWarningEvents);


void __RPC_STUB IMediaPlayer_put_SendWarningEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendErrorEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendErrorEvents);


void __RPC_STUB IMediaPlayer_get_SendErrorEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendErrorEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendErrorEvents);


void __RPC_STUB IMediaPlayer_put_SendErrorEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_PlayState_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ MPPlayStateConstants __RPC_FAR *pPlayState);


void __RPC_STUB IMediaPlayer_get_PlayState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SendPlayStateChangeEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pSendPlayStateChangeEvents);


void __RPC_STUB IMediaPlayer_get_SendPlayStateChangeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SendPlayStateChangeEvents_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL SendPlayStateChangeEvents);


void __RPC_STUB IMediaPlayer_put_SendPlayStateChangeEvents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DisplaySize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ MPDisplaySizeConstants __RPC_FAR *pDisplaySize);


void __RPC_STUB IMediaPlayer_get_DisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DisplaySize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ MPDisplaySizeConstants DisplaySize);


void __RPC_STUB IMediaPlayer_put_DisplaySize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_InvokeURLs_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pInvokeURLs);


void __RPC_STUB IMediaPlayer_get_InvokeURLs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_InvokeURLs_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL InvokeURLs);


void __RPC_STUB IMediaPlayer_put_InvokeURLs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_BaseURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrBaseURL);


void __RPC_STUB IMediaPlayer_get_BaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_BaseURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrBaseURL);


void __RPC_STUB IMediaPlayer_put_BaseURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DefaultFrame_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrDefaultFrame);


void __RPC_STUB IMediaPlayer_get_DefaultFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DefaultFrame_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrDefaultFrame);


void __RPC_STUB IMediaPlayer_put_DefaultFrame_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_HasError_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasError);


void __RPC_STUB IMediaPlayer_get_HasError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ErrorDescription_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrErrorDescription);


void __RPC_STUB IMediaPlayer_get_ErrorDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ErrorCode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pErrorCode);


void __RPC_STUB IMediaPlayer_get_ErrorCode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AnimationAtStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pAnimationAtStart);


void __RPC_STUB IMediaPlayer_get_AnimationAtStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AnimationAtStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL AnimationAtStart);


void __RPC_STUB IMediaPlayer_put_AnimationAtStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_TransparentAtStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pTransparentAtStart);


void __RPC_STUB IMediaPlayer_get_TransparentAtStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_TransparentAtStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL TransparentAtStart);


void __RPC_STUB IMediaPlayer_put_TransparentAtStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Volume_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVolume);


void __RPC_STUB IMediaPlayer_get_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Volume_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long Volume);


void __RPC_STUB IMediaPlayer_put_Volume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Balance_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pBalance);


void __RPC_STUB IMediaPlayer_get_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Balance_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long Balance);


void __RPC_STUB IMediaPlayer_put_Balance_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ReadyState_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ MPReadyStateConstants __RPC_FAR *pValue);


void __RPC_STUB IMediaPlayer_get_ReadyState_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SelectionStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pValue);


void __RPC_STUB IMediaPlayer_get_SelectionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SelectionStart_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double Value);


void __RPC_STUB IMediaPlayer_put_SelectionStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SelectionEnd_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ double __RPC_FAR *pValue);


void __RPC_STUB IMediaPlayer_get_SelectionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SelectionEnd_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ double Value);


void __RPC_STUB IMediaPlayer_put_SelectionEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowDisplay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);


void __RPC_STUB IMediaPlayer_get_ShowDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowDisplay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Show);


void __RPC_STUB IMediaPlayer_put_ShowDisplay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);


void __RPC_STUB IMediaPlayer_get_ShowControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Show);


void __RPC_STUB IMediaPlayer_put_ShowControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowPositionControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);


void __RPC_STUB IMediaPlayer_get_ShowPositionControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowPositionControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Show);


void __RPC_STUB IMediaPlayer_put_ShowPositionControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowTracker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Show);


void __RPC_STUB IMediaPlayer_get_ShowTracker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowTracker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Show);


void __RPC_STUB IMediaPlayer_put_ShowTracker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnablePositionControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable);


void __RPC_STUB IMediaPlayer_get_EnablePositionControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnablePositionControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Enable);


void __RPC_STUB IMediaPlayer_put_EnablePositionControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnableTracker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *Enable);


void __RPC_STUB IMediaPlayer_get_EnableTracker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnableTracker_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Enable);


void __RPC_STUB IMediaPlayer_put_EnableTracker_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Enabled_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pEnabled);


void __RPC_STUB IMediaPlayer_get_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Enabled_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL Enabled);


void __RPC_STUB IMediaPlayer_put_Enabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DisplayForeColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *ForeColor);


void __RPC_STUB IMediaPlayer_get_DisplayForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DisplayForeColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VB_OLE_COLOR ForeColor);


void __RPC_STUB IMediaPlayer_put_DisplayForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DisplayBackColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *BackColor);


void __RPC_STUB IMediaPlayer_get_DisplayBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DisplayBackColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VB_OLE_COLOR BackColor);


void __RPC_STUB IMediaPlayer_put_DisplayBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_DisplayMode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ MPDisplayModeConstants __RPC_FAR *pValue);


void __RPC_STUB IMediaPlayer_get_DisplayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_DisplayMode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ MPDisplayModeConstants Value);


void __RPC_STUB IMediaPlayer_put_DisplayMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_VideoBorder3D_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pVideoBorderWidth);


void __RPC_STUB IMediaPlayer_get_VideoBorder3D_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_VideoBorder3D_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL VideoBorderWidth);


void __RPC_STUB IMediaPlayer_put_VideoBorder3D_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_VideoBorderWidth_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pVideoBorderWidth);


void __RPC_STUB IMediaPlayer_get_VideoBorderWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_VideoBorderWidth_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long VideoBorderWidth);


void __RPC_STUB IMediaPlayer_put_VideoBorderWidth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_VideoBorderColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VB_OLE_COLOR __RPC_FAR *pVideoBorderWidth);


void __RPC_STUB IMediaPlayer_get_VideoBorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_VideoBorderColor_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VB_OLE_COLOR VideoBorderColor);


void __RPC_STUB IMediaPlayer_put_VideoBorderColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowGotoBar_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_ShowGotoBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowGotoBar_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_ShowGotoBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowStatusBar_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_ShowStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowStatusBar_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_ShowStatusBar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowCaptioning_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_ShowCaptioning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowCaptioning_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL pbool);


void __RPC_STUB IMediaPlayer_put_ShowCaptioning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ShowAudioControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_ShowAudioControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_ShowAudioControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bBool);


void __RPC_STUB IMediaPlayer_put_ShowAudioControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CaptioningID_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstrText);


void __RPC_STUB IMediaPlayer_get_CaptioningID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_CaptioningID_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR strText);


void __RPC_STUB IMediaPlayer_put_CaptioningID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Mute_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *vbool);


void __RPC_STUB IMediaPlayer_get_Mute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Mute_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_Mute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_CanPreview_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCanPreview);


void __RPC_STUB IMediaPlayer_get_CanPreview_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_PreviewMode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pPreviewMode);


void __RPC_STUB IMediaPlayer_get_PreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_PreviewMode_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL PreviewMode);


void __RPC_STUB IMediaPlayer_put_PreviewMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_HasMultipleItems_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pHasMuliItems);


void __RPC_STUB IMediaPlayer_get_HasMultipleItems_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_Language_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pLanguage);


void __RPC_STUB IMediaPlayer_get_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_Language_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long Language);


void __RPC_STUB IMediaPlayer_put_Language_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AudioStream_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pStream);


void __RPC_STUB IMediaPlayer_get_AudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AudioStream_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long Stream);


void __RPC_STUB IMediaPlayer_put_AudioStream_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMIStyle_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStyle);


void __RPC_STUB IMediaPlayer_get_SAMIStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMIStyle_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrStyle);


void __RPC_STUB IMediaPlayer_put_SAMIStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMILang_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrLang);


void __RPC_STUB IMediaPlayer_get_SAMILang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMILang_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrLang);


void __RPC_STUB IMediaPlayer_put_SAMILang_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_SAMIFileName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrFileName);


void __RPC_STUB IMediaPlayer_get_SAMIFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_SAMIFileName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IMediaPlayer_put_SAMIFileName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_StreamCount_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pStreamCount);


void __RPC_STUB IMediaPlayer_get_StreamCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ClientId_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrClientId);


void __RPC_STUB IMediaPlayer_get_ClientId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ConnectionSpeed_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plConnectionSpeed);


void __RPC_STUB IMediaPlayer_get_ConnectionSpeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_AutoSize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_AutoSize_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL vbool);


void __RPC_STUB IMediaPlayer_put_AutoSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_EnableFullScreenControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbVal);


void __RPC_STUB IMediaPlayer_get_EnableFullScreenControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_EnableFullScreenControls_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL bVal);


void __RPC_STUB IMediaPlayer_put_EnableFullScreenControls_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_ActiveMovie_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch);


void __RPC_STUB IMediaPlayer_get_ActiveMovie_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_NSPlay_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdispatch);


void __RPC_STUB IMediaPlayer_get_NSPlay_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_get_WindowlessVideo_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbool);


void __RPC_STUB IMediaPlayer_get_WindowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_put_WindowlessVideo_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL boolVal);


void __RPC_STUB IMediaPlayer_put_WindowlessVideo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Play_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Play_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Stop_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Stop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Pause_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMarkerTime_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long MarkerNum,
    /* [retval][out] */ double __RPC_FAR *pMarkerTime);


void __RPC_STUB IMediaPlayer_GetMarkerTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMarkerName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long MarkerNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMarkerName);


void __RPC_STUB IMediaPlayer_GetMarkerName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_AboutBox_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_AboutBox_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecInstalled_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pCodecInstalled);


void __RPC_STUB IMediaPlayer_GetCodecInstalled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecDescription_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecDescription);


void __RPC_STUB IMediaPlayer_GetCodecDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetCodecURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long CodecNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCodecURL);


void __RPC_STUB IMediaPlayer_GetCodecURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMoreInfoURL_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ MPMoreInfoType MoreInfoType,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMoreInfoURL);


void __RPC_STUB IMediaPlayer_GetMoreInfoURL_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetMediaInfoString_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ MPMediaInfoType MediaInfoType,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrMediaInfo);


void __RPC_STUB IMediaPlayer_GetMediaInfoString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Cancel_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Cancel_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Open_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ BSTR bstrFileName);


void __RPC_STUB IMediaPlayer_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_IsSoundCardEnabled_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pbSoundCard);


void __RPC_STUB IMediaPlayer_IsSoundCardEnabled_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Next_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_Previous_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_StreamSelect_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long StreamNum);


void __RPC_STUB IMediaPlayer_StreamSelect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_FastForward_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_FastForward_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_FastReverse_Proxy( 
    IMediaPlayer __RPC_FAR * This);


void __RPC_STUB IMediaPlayer_FastReverse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamName_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStreamName);


void __RPC_STUB IMediaPlayer_GetStreamName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamGroup_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ long __RPC_FAR *pStreamGroup);


void __RPC_STUB IMediaPlayer_GetStreamGroup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMediaPlayer_GetStreamSelected_Proxy( 
    IMediaPlayer __RPC_FAR * This,
    /* [in] */ long StreamNum,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pStreamSelected);


void __RPC_STUB IMediaPlayer_GetStreamSelected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMediaPlayer_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * ); 
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\fldricon.h ===
#ifndef __FLDRICON_H_
#define __FLDRICON_H_

#include <evtsink.h>
#include <shellp.h>
#include <windef.h>
#include <webvwid.h>
#include <color.h>
#include <cnctnpt.h>

EXTERN_C const CLSID CLSID_WebViewFolderIconOld;  // retired from service

#define ID_FIRST            0               // Context Menu ID's
#define ID_LAST             0x7fff

#define MAX_SCALE_STR       10
#define MAX_VIEW_STR        50

#define LARGE_ICON_DEFAULT  32
#define THUMBVIEW_DEFAULT   120
#define PIEVIEW_DEFAULT     THUMBVIEW_DEFAULT

#define SLICE_NUM_GROW      2

#define SZ_LARGE_ICON           L"Large Icon"
#define SZ_SMALL_ICON           L"Small Icon"
#define SZ_SMALL_ICON_LABEL     L"Small Icon with Label"
#define SZ_LARGE_ICON_LABEL     L"Large Icon with Label"
#define SZ_THUMB_VIEW           L"Thumbview"
#define SZ_PIE_VIEW             L"Pie Graph"

struct PieSlice_S {
    ULONGLONG   MemSize;
    COLORREF    Color;
};

/////////////////////////////////////////////////////////////////////////////
// CWebViewFolderIcon
class ATL_NO_VTABLE CWebViewFolderIcon : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWebViewFolderIcon, &CLSID_WebViewFolderIcon>,
    public CComControl<CWebViewFolderIcon>,
    public IDispatchImpl<IWebViewFolderIcon3, &IID_IWebViewFolderIcon3, &LIBID_WEBVWLib>,
    public IObjectSafetyImpl<CWebViewFolderIcon, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IQuickActivateImpl<CWebViewFolderIcon>,
    public IOleControlImpl<CWebViewFolderIcon>,
    public IOleObjectImpl<CWebViewFolderIcon>,
    public IOleInPlaceActiveObjectImpl<CWebViewFolderIcon>,
    public IViewObjectExImpl<CWebViewFolderIcon>,
    public IOleInPlaceObjectWindowlessImpl<CWebViewFolderIcon>,
    public IPersistPropertyBagImpl<CWebViewFolderIcon>,
    public IPointerInactiveImpl<CWebViewFolderIcon>,
    public IConnectionPointImpl<CWebViewFolderIcon, &DIID_DWebViewFolderIconEvents>,
    public IConnectionPointContainerImpl<CWebViewFolderIcon>,
    public IProvideClassInfo2Impl<&CLSID_WebViewFolderIcon,
            &DIID_DWebViewFolderIconEvents, &LIBID_WEBVWLib>
{
public:

// Drawing function
    HRESULT OnDraw(ATL_DRAWINFO& di);

DECLARE_REGISTRY_RESOURCEID(IDR_WEBVIEWFOLDERICON)

BEGIN_COM_MAP(CWebViewFolderIcon)
    COM_INTERFACE_ENTRY(IWebViewFolderIcon3)
    COM_INTERFACE_ENTRY_IID(IID_IWebViewFolderIcon, IWebViewFolderIcon3)
    COM_INTERFACE_ENTRY_IID(IID_IWebViewFolderIcon2, IWebViewFolderIcon3)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistPropertyBag)
    COM_INTERFACE_ENTRY(IPointerInactive)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
END_COM_MAP()

BEGIN_MSG_MAP(CWebViewFolderIcon)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_RBUTTONDOWN, OnButtonDown)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnButtonDown)
    MESSAGE_HANDLER(WM_RBUTTONUP, OnRButtonUp)
    MESSAGE_HANDLER(WM_LBUTTONDBLCLK, OnLButtonDoubleClick)
    MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    MESSAGE_HANDLER(WM_KEYDOWN, OnKeyDown)
    MESSAGE_HANDLER(WM_INITMENUPOPUP, OnInitPopup)
    MESSAGE_HANDLER(WM_MOUSELEAVE, OnMouseLeave)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)    
END_MSG_MAP()

BEGIN_PROPERTY_MAP(CWebViewFolderIcon)
    PROP_ENTRY("scale",       DISPID_PROP_WVFOLDERICON_SCALE,       CLSID_WebViewFolderIcon)
    PROP_ENTRY("path",        DISPID_PROP_WVFOLDERICON_PATH,        CLSID_WebViewFolderIcon)
    PROP_ENTRY("view",        DISPID_PROP_WVFOLDERICON_VIEW,        CLSID_WebViewFolderIcon)
    PROP_ENTRY("advproperty", DISPID_PROP_WVFOLDERICON_ADVPROPERTY, CLSID_WebViewFolderIcon)
    PROP_ENTRY("clickStyle",  DISPID_PROP_WVFOLDERICON_CLICKSTYLE,  CLSID_WebViewFolderIcon)
    PROP_ENTRY("labelGap",    DISPID_PROP_WVFOLDERICON_LABELGAP,    CLSID_WebViewFolderIcon)

    // WARNING!  "item" must be last because it can fail (due to security)
    // and ATL stops loading once any property returns failure.
    PROP_ENTRY("item",        DISPID_PROP_WVFOLDERICON_ITEM,        CLSID_WebViewFolderIcon)
END_PROPERTY_MAP()

BEGIN_CONNECTION_POINT_MAP(CWebViewFolderIcon)
    CONNECTION_POINT_ENTRY(DIID_DWebViewFolderIconEvents)
END_CONNECTION_POINT_MAP()

    // *** IOleWindow ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) {return IOleInPlaceActiveObjectImpl<CWebViewFolderIcon>::GetWindow(lphwnd);};
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return IOleInPlaceActiveObjectImpl<CWebViewFolderIcon>::ContextSensitiveHelp(fEnterMode); };

    // *** IOleInPlaceObject ***
    virtual STDMETHODIMP InPlaceDeactivate(void) {return IOleInPlaceObject_InPlaceDeactivate();};
    virtual STDMETHODIMP SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect) {return IOleInPlaceObject_SetObjectRects(lprcPosRect, lprcClipRect);};
    virtual STDMETHODIMP ReactivateAndUndo(void)  { return E_NOTIMPL; };
    virtual STDMETHODIMP UIDeactivate(void);

    // *** IOleInPlaceActiveObject ***
    virtual STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

// IDispatch overrides
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr);

// IViewObjectEx overrides
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus);

// IObjectWithSite overrides
    STDMETHOD(SetClientSite)(IOleClientSite *pClientSite);

// IObjectSafety overrides
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, 
                                         DWORD dwEnabledOptions);

// IOleInPlaceObjectWindowless Overrides
    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

// IPointerInactive Overrides
    STDMETHOD(GetActivationPolicy)(DWORD* pdwPolicy);
    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways) {return S_FALSE;};   // Ask for default behavior.

// IOleControl overrides
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);

// ATL overrides
    HRESULT DoVerbUIActivate(LPCRECT prcPosRect, HWND hwndParent);

// Event Handlers
    STDMETHOD(OnWindowLoad)(VOID);    
    STDMETHOD(OnWindowUnLoad)(VOID);
    STDMETHOD(OnImageChanged)(VOID);

//  Advanced Properties - Context Menu, Default Open, Drag and Drop
    LRESULT OnRButtonUp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnButtonDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnLButtonDoubleClick(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnKeyDown(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnInitPopup(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnMouseLeave(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    LRESULT OnMouseMove(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL & bHandled);
    
    // *** IWebViewFolderIcon ***
    STDMETHOD(get_scale)(BSTR *pbstrScale); 
    STDMETHOD(put_scale)(BSTR bstrScale);   

    STDMETHOD(get_path)(BSTR *pbstrPath); 
    STDMETHOD(put_path)(BSTR bstrPath);   

    STDMETHOD(get_view)(BSTR *pView); 
    STDMETHOD(put_view)(BSTR view);

    STDMETHOD(get_advproperty)(VARIANT_BOOL *pvarbAdvProp); 
    STDMETHOD(put_advproperty)(VARIANT_BOOL varbAdvProp);

    // *** IWebViewFolderIcon2 ***
    STDMETHOD(setSlice)(INT index, VARIANT varHiBytes, VARIANT varLoBytes, VARIANT varColorref);

    // *** IWebViewFolderIcon3 ***
    STDMETHOD(get_item)(FolderItem ** ppFolderItem);
    STDMETHOD(put_item)(FolderItem * pFolderItem);
    STDMETHOD(get_clickStyle)(/* retval, out */ LONG *plClickStyle);
    STDMETHOD(put_clickStyle)(/* in */ LONG lClickStyle);
    STDMETHOD(get_labelGap)(/* retval, out */ LONG *plLabelGap);
    STDMETHOD(put_labelGap)(/* in */ LONG lLabelGap);

public:
    CWebViewFolderIcon(void);
    ~CWebViewFolderIcon(void);
           
private:
    // Private helpers

    HRESULT     InitImage(void);
    HRESULT     InitIcon(void);
    HRESULT     InitThumbnail(void);
    HRESULT     InitPieGraph(void);
    HRESULT     SetupIThumbnail(void);

    HRESULT     _InvokeOnThumbnailReady();
    
    HRESULT     UpdateSize(void);
    HRESULT     ForceRedraw(void);

    HRESULT     _GetFullPidl(LPITEMIDLIST *ppidl);
    HRESULT     _GetPathW(LPWSTR psz);
    HRESULT     _GetPidlAndShellFolder(LPITEMIDLIST *ppidlLast, IShellFolder** ppsfParent);
    HRESULT     _GetHwnd(HWND* phwnd);
    HRESULT     _GetCenterPoint(POINT *pt);
    HRESULT     _GetChildUIObjectOf(REFIID riid, void ** ppvObj);

    BOOL        _WebViewOpen(void);
    HRESULT     _ZoneCheck(DWORD dwFlags);
    HRESULT     _IsSafe();
    BOOL        IsSafeToDefaultVerb(void);
    void        _FlipFocusRect(BOOL RectState);
    ULONGLONG   GetUllMemFromVars(VARIANT *pvarHi, VARIANT *pvarLo);
    int         GetPercentFromStrW(LPCWSTR pwzPercent);
    HRESULT     DragDrop(int iClickXPos, int iClickYPos);
    HRESULT     _DisplayContextMenu(long nXCord, long nYCord);
    HRESULT     _DoContextMenuCmd(BOOL bDefault, long nXCord, long nYCord);
    BOOL        _IsHostWebView(void);
    BOOL        _IsPubWizHosted(void);

    HRESULT     _SetDragImage(int iClickXPos, int iClickYPos, IDataObject * pdtobj);

    //  3dPie functions
    HRESULT     Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPercent1000, const COLORREF *lpColors);
    HRESULT     ComputeFreeSpace(LPCWSTR pszFileName);
    void        ScalePieRect(LONG ShadowScale, LONG AspectRatio, LPRECT lprc);
    void        ComputeSlicePct(ULONGLONG ullMemSize, DWORD *pdwPercent1000);
    void        CalcSlicePoint(int *x, int *y, int rx, int ry, int cx, int cy, int FirstQuadPercent1000, DWORD dwPercent1000);
    void        SetUpPiePts(int *pcx, int *pcy, int *prx, int *pry, RECT rect);
    void        DrawPieDepth(HDC hdc, RECT rect, int x, int y, int cy, DWORD dwPercent1000, LONG ShadowDepth);
    void        DrawSlice(HDC hdc, RECT rect, DWORD dwPercent1000, int rx, int ry, int cx, int cy, /*int *px, int *py,*/
                          COLORREF Color);
    void        DrawEllipse(HDC hdc, RECT rect, int x, int y, int cx, int cy, DWORD dwPercent1000, const COLORREF *lpColors);
    void        DrawShadowRegions(HDC hdc, RECT rect, LPRECT lprc, int UsedArc_x, int center_y, LONG ShadowDepth, 
                                  DWORD dwPercent1000, COLORREF const *lpColors); 
    HRESULT     _GetPieChartIntoBitmap();

    HRESULT     _SetupWindow(void);
    HRESULT     _MakeRoomForLabel();

    // Window Procedure for catching and storing bitmap
    static LRESULT CALLBACK WndProc(HWND, UINT uMsg, WPARAM, LPARAM);

    // Managing the bitmap/icon

    LONG        _GetScaledImageWidth(void) { return (m_lImageWidth * m_percentScale)/100; }
    LONG        _GetScaledImageHeight(void) { return (m_lImageHeight * m_percentScale)/100; }

    // Managing the label
    void        _ClearLabel(void);
    void        _GetLabel(IShellFolder *psf, LPCITEMIDLIST pidlItem);

    LONG        _GetControlWidth(void)
                { return _GetScaledImageWidth() +
                          (m_sizLabel.cx ? m_cxLabelGap + m_sizLabel.cx : 0); }
    LONG        _GetControlHeight(void) { return max(_GetScaledImageHeight(), m_sizLabel.cy); }

    void        _GetAmbientFont(void);
    void        _ClearAmbientFont(void);

private:

    // Private message handlers
    HWND                m_msgHwnd;
    WNDCLASS            m_msgWc;
    BOOL                m_bRegWndClass;
    IContextMenu3 *     m_pcm3;             // For Context Menu events
    IDropTarget *       m_pDropTargetCache; // Cache the IDropTarget because MSHTML should but doesn't.
    IDispatch *         m_pdispWindow;      // Cache the HTML window object that we receive events from
    
    // Image information
    HICON                m_hIcon;   
    INT                  m_iIconIndex;

    // Size information
    INT                  m_percentScale;    // image scaling
    UINT                 m_lImageWidth;     // unscaled size of bitmap/icon
    UINT                 m_lImageHeight;
    LONG                 m_cxLabelGap;

    SIZE                 m_sizLabel;        // size of label

    IThumbnail2         *m_pthumb;
    HBITMAP              m_hbm;
    BOOL                 m_fTabRecieved;
    BOOL                 m_fIsHostWebView;  // Are we hosted in WebView?

    HDC                  m_hdc;             // Saved for _SetDragImage()
    RECT                 m_rect;            // Rectangle into which we draw
    BOOL                 m_fRectAdjusted;   // Flag says if we need to modify
                                            // rect for drag image.
    BOOL                 m_fLoaded;                                            
    HBITMAP              m_hbmDrag;
    // Piechart
    enum
    {
        PIE_USEDCOLOR = 0,
        PIE_FREECOLOR,
        PIE_USEDSHADOW,
        PIE_FREESHADOW,
        PIE_NUM     // keep track of number of PIE_ values
    };

    enum
    {
        COLOR_UP = 0,
        COLOR_DN,
        COLOR_UPSHADOW,
        COLOR_DNSHADOW,
        COLOR_NUM       // #of entries
    };

    enum VIEWS
    {
        VIEW_SMALLICON = 0,
        VIEW_LARGEICON,
        VIEW_THUMBVIEW,
        VIEW_PIECHART,

        // Extra flags for views
        VIEW_WITHLABEL = 0x00010000,

        VIEW_SMALLICONLABEL = VIEW_SMALLICON | VIEW_WITHLABEL,
        VIEW_LARGEICONLABEL = VIEW_LARGEICON | VIEW_WITHLABEL,
    };

    // Putzing with the view
    inline static UINT _ViewType(VIEWS vw) { return LOWORD(vw); }

    COLORREF             m_ChartColors[PIE_NUM];
    ULONGLONG            m_ullFreeSpace;
    ULONGLONG            m_ullUsedSpace;
    ULONGLONG            m_ullTotalSpace;

    BOOL                 m_fUseSystemColors;
    HDSA                 m_hdsaSlices;              // added slices to the Used area
    int                  m_highestIndexSlice;        

    // Advise Cookie
    DWORD                m_dwHtmlWindowAdviseCookie;
    DWORD                m_dwCookieDV;
    CIE4ConnectionPoint  *m_pccpDV;

    // path property
    LPITEMIDLIST        m_pidl;

    // view property
    VIEWS               m_ViewUser;         // What user wants.
    VIEWS               m_ViewCurrent;      // What user gets.

    // clickStyle property
    LONG                m_clickStyle;       // 1 = oneclick, 2 = twoclick

    // Activation rectangle flag
    BOOL                m_bHasRect;

    // Advanced properties setting
    // When it is turned off, Context Menu, Drag and Drop, fucus rectangle, and security checking support 
    // (anything to do with mouse clicking or tabbing) is turned off.
    BOOL                m_bAdvPropsOn;

    // Should we also show the display name of the target?
    LPTSTR              m_pszDisplayName;

    // What font should we show the display name in?
    HFONT               m_hfAmbient;
    IFont *             m_pfont;            // Who owns the font?
                                            // (if NULL, then we do)

    // Show hilite effects- underline text, dropshadow for icon etc..
    BOOL                m_bHilite;
    
    DWORD               m_dwThumbnailID;    // ID to identify which bitmap we received
};  

#endif //__WVFOLDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\evtsink.h ===
// wvcoord.h : Declaration of the CWebViewCoord

#ifndef __EVTSINK_H_
#define __EVTSINK_H_

/////////////////////////////////////////////////////////////////////////////
// CDispatchEventSink

class CDispatchEventSink : public IDispatch {
  public:
    //
    // IUnknown methods
    //

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    //
    // IDispatch methods
    //

    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo);
    STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo **ppTInfo);
    STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR __RPC_FAR *rgszNames,
                             UINT cNames, LCID lcid, DISPID *rgDispId);
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr) PURE;

protected:
    virtual ~CDispatchEventSink();
    CDispatchEventSink();

private:
    UINT      m_cRef;                          // IUnknown reference count
};

/////////////////////////////////////////////////////////////////////////////
// WindowEventSink Helpers

HRESULT ConnectHtmlEvents(IDispatch *pdispSink, CComPtr<IOleClientSite> &spClientSite, IDispatch ** ppdispWindow, DWORD *pdwCookie);
HRESULT DisconnectHtmlEvents(IDispatch *pdispWindow, DWORD dwCookie);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\filewrap.cpp ===
// wvcoord.cpp : Implementation of CWebViewCoord

#include "priv.h"
#include "wvcoord.h"
#include "shdispid.h"

/////////////////////////////////////////////////////////////////////////////
// String Constants
/////////////////////////////////////////////////////////////////////////////
#define CSC_PLUSCOLD        L"<img id=CSCBmp align=middle src=pluscold.gif>"
#define CSC_PLUSHOT         L"<img id=CSCBmp align=middle src=plushot.gif>"
#define CSC_MINUSCOLD       L"<img id=CSCBmp align=middle src=mincold.gif>"
#define CSC_MINUSHOT        L"<img id=CSCBmp align=middle src=minhot.gif>"
#define WV_LINKNAME         L"WVLink"

/////////////////////////////////////////////////////////////////////////////
// CFileListWrapper
/////////////////////////////////////////////////////////////////////////////

CFileListWrapper::CFileListWrapper() 
{
    m_pThumbNailWrapper = NULL;
    m_bCSCDisplayed = FALSE;
    m_bExpanded = FALSE;
    m_bHotTracked = FALSE;
    m_dwDateFlags = FDTF_DEFAULT;    // default
    m_bRTLDocument = FALSE;      // default
}

#define MYDOCS_CLSID    L"{450d8fba-ad25-11d0-98a8-0800361b1103}"   // CLSID_MyDocuments

HRESULT GetFolderIDList(int nFolder, LPITEMIDLIST* ppidlFolder)
{
    HRESULT hr = E_FAIL;

    if (nFolder == CSIDL_PERSONAL)
    {
        hr = SHILCreateFromPath(L"::" MYDOCS_CLSID, ppidlFolder, NULL);
    }
    else
    {
        hr = SHGetSpecialFolderLocation(NULL, nFolder, ppidlFolder);
    }
    return hr;
}

HRESULT CFileListWrapper::IsItThisFolder(int nFolder, BOOL& bResult, LPWSTR pwszDisplayName, DWORD cchDisplayName, LPWSTR pwszUrlPath, DWORD cchUrlPath)
{
    HRESULT hr = E_FAIL;
    LPITEMIDLIST pidlFolder = NULL, pidlLast = NULL;
    CComPtr<IShellFolder> psfParent;
    STRRET strret;
    CComBSTR bstrTemp;
    WCHAR wszPath[MAX_PATH];

    if (SUCCEEDED(GetFolderIDList(nFolder, &pidlFolder))
            && SUCCEEDED(SHBindToIDListParent(pidlFolder, IID_IShellFolder, (void**)&psfParent, (LPCITEMIDLIST*)&pidlLast))
            && SUCCEEDED(psfParent->GetDisplayNameOf(pidlLast, SHGDN_NORMAL, &strret))
            && SUCCEEDED(StrRetToBufW(&strret, pidlFolder, pwszDisplayName, cchDisplayName))
            && SUCCEEDED(psfParent->GetDisplayNameOf(pidlLast, SHGDN_FORPARSING, &strret))
            && SUCCEEDED(StrRetToBufW(&strret, pidlFolder, wszPath, ARRAYSIZE(wszPath)))
            && SUCCEEDED(m_spFolderItem->get_Path(&bstrTemp)) && (bstrTemp.Length() > 0))
    {
        hr = S_OK;
        bResult = (StrCmpIW(bstrTemp, wszPath) == 0);
        if (CSIDL_PERSONAL == nFolder)
        {
            // Change the URL for mydocs (after comparing with the path) so that it
            // is a CLSID URL instead of the file system path
            StrCpyNW(wszPath, L"::" MYDOCS_CLSID, ARRAYSIZE(wszPath));
        }
        UrlCreateFromPathW(wszPath, pwszUrlPath, &cchUrlPath, 0);
    }
    if (pidlFolder)
    {
        ILFree(pidlFolder);
    }
    return hr;
}

HRESULT CFileListWrapper::GetIMediaPlayer(CComPtr<IMediaPlayer>& spIMediaPlayer)
{
// The MediaPlayer objects has too many bugs. So, let's disable it.
#if 0
    if (!m_spIMediaPlayer)
    {
        if (m_spMediaPlayerSpan)
        {
            m_spMediaPlayerSpan->put_innerHTML(OLESTR("<object ID=MediaPlayer classid=\"clsid:22D6F312-B0F6-11D0-94AB-0080C74C7E95\" style=\"display:none; position:absolute; width:176px\"> <param name=\"ShowDisplay\" value=false> <param name=\"AutoPlay\" value=false> </object><br>"));
        }
        
        CComPtr<IHTMLElementCollection> spDocAll;
        CComVariant                     vEmpty;
        CComPtr<IDispatch>              spdispItem;
        if (SUCCEEDED(m_spDocument->get_all(&spDocAll)) && SUCCEEDED(spDocAll->item(CComVariant(OLESTR("MediaPlayer")), vEmpty, &spdispItem)) && spdispItem)
        {
            if (FAILED(FindObjectStyle(spdispItem, m_spMediaPlayerStyle)))
            {
                m_spMediaPlayerStyle = NULL;
            }
            if (FAILED(spdispItem->QueryInterface(IID_IMediaPlayer, (void **)&m_spIMediaPlayer)))
            {
                m_spIMediaPlayer = NULL;
            }
            else
            {
                m_spIMediaPlayer->put_EnableContextMenu(VARIANT_FALSE);
            }
            spdispItem = NULL;
        }
        spDocAll = NULL;
    }
#endif
    spIMediaPlayer = m_spIMediaPlayer;
    return spIMediaPlayer ? S_OK : E_FAIL;
}

HRESULT CFileListWrapper::FormatCrossLink(LPCWSTR pwszDisplayName, LPCWSTR pwszUrlPath, UINT uIDToolTip)
{
    m_bstrCrossLinksHTML += OLESTR("<p class=Half><a href=\"");
    m_bstrCrossLinksHTML += pwszUrlPath;
    m_bstrCrossLinksHTML += OLESTR("\"");

    WCHAR wszToolTip[MAX_PATH];
    wszToolTip[0] = L'\0';
    if (LoadStringW(_Module.GetResourceInstance(), uIDToolTip, wszToolTip, ARRAYSIZE(wszToolTip)) > 0)
    {
        m_bstrCrossLinksHTML += OLESTR(" title=\"");
        m_bstrCrossLinksHTML += wszToolTip;
        m_bstrCrossLinksHTML += OLESTR("\"");
    }
    m_bstrCrossLinksHTML += OLESTR(" name=\"");
    m_bstrCrossLinksHTML += WV_LINKNAME;
    m_bstrCrossLinksHTML += OLESTR("\"");
    m_bstrCrossLinksHTML += OLESTR(">");
    m_bstrCrossLinksHTML += pwszDisplayName;
    m_bstrCrossLinksHTML += OLESTR("</a>");
    return S_OK;
}

HRESULT CFileListWrapper::GetCrossLink(int nFolder, UINT uIDToolTip)
{
    HRESULT hres = E_FAIL;  // Assume error
    // Get the links.
    WCHAR wszDisplayName[MAX_PATH], wszUrlPath[MAX_PATH];
    BOOL bThisFolder;
    if (SUCCEEDED(IsItThisFolder(nFolder, bThisFolder, wszDisplayName, ARRAYSIZE(wszDisplayName), wszUrlPath, ARRAYSIZE(wszUrlPath)))
            && !bThisFolder)
    {
        hres = FormatCrossLink(wszDisplayName, wszUrlPath, uIDToolTip);
    }
    return hres;
}

HRESULT CFileListWrapper::GetCrossLinks()
{
    WCHAR wszSeeAlso[MAX_PATH];
    m_bstrCrossLinksHTML += OLESTR("<p>");
    LoadStringW(_Module.GetResourceInstance(), IDS_SEEALSO, wszSeeAlso, ARRAYSIZE(wszSeeAlso));
    m_bstrCrossLinksHTML += wszSeeAlso;

    GetCrossLink(CSIDL_PERSONAL, IDS_MYDOCSTEXT);
    if (!SHRestricted(REST_NONETHOOD))
    {
        GetCrossLink(CSIDL_NETWORK, IDS_MYNETPLACESTEXT);
    }
    if (FAILED(GetCrossLink(CSIDL_DRIVES, IDS_MYCOMPTEXT)) && !SHRestricted(REST_NONETHOOD))
    {
        // This is the My Computer folder - Add a link to Network and Dial-up Connections folder
        WCHAR wszNDC[MAX_PATH];
        wszNDC[0] = L'\0';
        LoadStringW(_Module.GetResourceInstance(), IDS_NDC, wszNDC, ARRAYSIZE(wszNDC));

        FormatCrossLink(wszNDC, L"shell:ConnectionsFolder", IDS_NDCTEXT);
    }
    
    return S_OK;
}

// The Media Player folks haven't published the IMediaPlayer interface, so I define it here.
// Should strip it out when their declaration makes it to the public headers.
const IID IID_IMediaPlayer = {0x22D6F311,0xB0F6,0x11D0,{0x94,0xAB,0x00,0x80,0xC7,0x4C,0x7E,0x95}};

HRESULT CFileListWrapper::Init(
                    CComPtr<IShellFolderViewDual>  spFileList,
                    CComPtr<IHTMLElement>          spInfo,
                    CComPtr<IHTMLElement>          spLinks,
                    CComPtr<IHTMLStyle>            spPanelStyle,
                    CComPtr<IHTMLElement>          spMediaPlayerSpan,
                    CComPtr<IHTMLElement>          spCSCPlusMin,
                    CComPtr<IHTMLElement>          spCSCText,
                    CComPtr<IHTMLElement>          spCSCDetail,
                    CComPtr<IHTMLElement>          spCSCButton,
                    CComPtr<IHTMLStyle>            spCSCStyle,
                    CComPtr<IHTMLStyle>            spCSCDetailStyle,
                    CComPtr<IHTMLStyle>            spCSCButtonStyle,
                    CComPtr<IHTMLDocument2>        spDocument,
                    CComPtr<IHTMLWindow2>          spWindow,
                    CThumbNailWrapper              *pThumbNailWrapper)
{
    m_spFileList = spFileList;
    m_spInfo = spInfo;
    m_spLinks = spLinks;
    m_spPanelStyle = spPanelStyle;
    m_spMediaPlayerSpan = spMediaPlayerSpan;
    m_spMediaPlayerStyle = NULL;
    m_spIMediaPlayer = NULL;
    m_spCSCPlusMin = spCSCPlusMin;
    m_spCSCText = spCSCText;
    m_spCSCDetail = spCSCDetail;
    m_spCSCButton = spCSCButton;
    m_spCSCStyle = spCSCStyle;
    m_spCSCDetailStyle = spCSCDetailStyle;
    m_spCSCButtonStyle = spCSCButtonStyle;
    m_spDocument = spDocument;
    m_spWindow = spWindow;
    m_pThumbNailWrapper = pThumbNailWrapper;
    if (m_pThumbNailWrapper)
    {
        m_pThumbNailWrapper->AddRef();
    }
    m_bNeverGotPanelInfo = TRUE;

    // Find out if the reading order is from right to left
    m_dwDateFlags = FDTF_DEFAULT;    // default

    m_bRTLDocument = IsRTLDocument(m_spDocument);      // default

    // Get the date format reading order
    LCID locale = GetUserDefaultLCID();
    if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) || 
        (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))
    {
        
            if (m_bRTLDocument)
                m_dwDateFlags |= FDTF_RTLDATE;
            else
                m_dwDateFlags |= FDTF_LTRDATE;
    }

    m_bPathIsSlow = FALSE;  // default

    // Make sure that the path is not slow
    CComPtr<Folder>      spFolder;
    CComPtr<Folder2>     spFolder2;
    CComPtr<FolderItem>  spFolderItem;
    CComBSTR bstrPath;
    
    if (m_spFileList && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
                && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2))
                && SUCCEEDED(spFolder2->get_Self(&spFolderItem))
                && SUCCEEDED(spFolderItem->get_Path(&bstrPath)))
    {
        m_bPathIsSlow = PathIsSlowW(bstrPath, -1);
    }

    return S_OK;
}

CFileListWrapper::~CFileListWrapper()
{
    // Release any objects we are holding references to
    m_spFileList = NULL;
    m_spInfo    = NULL;
    m_spLinks    = NULL;
    m_spPanelStyle = NULL;
    m_spIMediaPlayer = NULL;
    m_spMediaPlayerSpan = NULL;
    m_spMediaPlayerStyle = NULL;
    m_spIMediaPlayer = NULL;
    m_spCSCPlusMin = NULL;
    m_spCSCText = NULL;
    m_spCSCDetail = NULL;
    m_spCSCButton = NULL;
    m_spCSCStyle = NULL;
    m_spCSCDetailStyle = NULL;
    m_spCSCButtonStyle = NULL;
    m_spDocument = NULL;
    m_spWindow = NULL;

    // Release thumbnail wrapper
    if (m_pThumbNailWrapper)
    {
        m_pThumbNailWrapper->Release();
    }
}


STDMETHODIMP CFileListWrapper::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr) 
{
    HRESULT hr = S_OK;

    if (riid != IID_NULL)
    {
        hr = DISP_E_UNKNOWNINTERFACE;
    }
    else if (dispIdMember == DISPID_SELECTIONCHANGED)
    {
        hr = OnSelectionChanged();
    }
    else if (dispIdMember == DISPID_FILELISTENUMDONE)
    {
        hr = SetDefaultPanelDisplay();
    }
    else if (dispIdMember == DISPID_VERBINVOKED ||
             dispIdMember == DISPID_BEGINDRAG)
    {
        hr = StopMediaPlayer();
    }
    else if (dispIdMember == DISPID_HTMLELEMENTEVENTS_ONMOUSEOVER)
    {
        hr = OnWebviewLinkEvent( TRUE );
    }
    else if (dispIdMember == DISPID_HTMLELEMENTEVENTS_ONMOUSEOUT)
    {
        hr = OnWebviewLinkEvent( FALSE );
    }
    else if (dispIdMember == DISPID_HTMLELEMENTEVENTS_ONFOCUS)
    {
        hr = OnWebviewLinkEvent( TRUE );
    }
    else if (dispIdMember == DISPID_HTMLELEMENTEVENTS_ONBLUR)
    {
        hr = OnWebviewLinkEvent( FALSE );
    }
    
    
    return hr;
}

HRESULT CFileListWrapper::ClearThumbNail()
{
    if (m_pThumbNailWrapper)
    {
        m_pThumbNailWrapper->ClearThumbNail();
    }
    return S_OK;
}

HRESULT CFileListWrapper::StopMediaPlayer()
{
    if (m_spIMediaPlayer)
    {
        m_spIMediaPlayer->Stop();
    }
    return S_OK;
}

HRESULT CFileListWrapper::ClearMediaPlayer()
{
    StopMediaPlayer();
    if (m_spMediaPlayerStyle)
    {
        m_spMediaPlayerStyle->put_display(OLESTR("none"));
    }
    return S_OK;
}

HRESULT CFileListWrapper::OnSelectionChanged() 
{
    HRESULT hr = S_OK;

    if (m_spFileList)
    {
        // Erase any visible thumbnail since the selection changed
        ClearThumbNail();
        // Kill any preview
        ClearMediaPlayer();

        long cSelection = 0;
        CComPtr<FolderItems> spFolderItems;
        CComPtr<Folder>      spFolder;
        CComPtr<Folder2>     spFolder2;

        if (SUCCEEDED(m_spFileList->SelectedItems(&spFolderItems))
                && SUCCEEDED(spFolderItems->get_Count(&cSelection))
                && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
                && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2)))
        {
            m_spFolderItems = spFolderItems;
            m_spFolder2 = spFolder2;

            m_bstrInfoHTML = OLESTR("");
            m_bstrCrossLinksHTML = OLESTR("");

            if (cSelection == 0)
            {
                m_spFolderItems = NULL;
                if (SUCCEEDED(m_spFolder2->Items(&m_spFolderItems)))
                {
                    // Nothing is selected
                    hr = NoneSelected();
                }
            }
            else if (cSelection > 1)
            {
                // More than one item is selected
                hr = MultipleSelected(cSelection);
            }
            else
            {
                CComPtr<FolderItem>  spFolderItem;
                if (SUCCEEDED(m_spFolderItems->Item(CComVariant(0), &spFolderItem)))
                {
                    m_spFolderItem = spFolderItem;
                    m_spFolderItem->QueryInterface(IID_FolderItem2, (void **)&m_spFolderItem2);

                    // A single item has been selected
                    hr = OneSelected();

                    m_spFolderItem2 = NULL;
                    m_spFolderItem = NULL;
                }
            }

            DisplayInfoHTML();
            DisplayCrossLinksHTML();

            m_spFolder2 = NULL;
            m_spFolderItems = NULL;
        }
    }
    return hr;
}

HRESULT CFileListWrapper::SetDefaultPanelDisplay()
{
    CComPtr<Folder>      spFolder;
    CComPtr<Folder2>     spFolder2;
    CComPtr<FolderItems> spFolderItems;

    if (m_spFileList && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
            && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2))
            && SUCCEEDED(spFolder2->Items(&spFolderItems)))
    {
        m_bstrInfoHTML = OLESTR("");
        m_bstrCrossLinksHTML = OLESTR("");

        m_spFolderItems = spFolderItems;
        m_spFolder2 = spFolder2;

        NoneSelected();
        DisplayInfoHTML();
        DisplayCrossLinksHTML();

        m_spFolder2 = NULL;
        m_spFolderItems = NULL;
    }
    return S_OK;
}

HRESULT CFileListWrapper::DisplayInfoHTML()
{
    HRESULT hr = S_FALSE;
    if (m_spInfo)
    {
        // Replace Info.innerHTML with the new text
        hr = m_spInfo->put_innerHTML(m_bstrInfoHTML);
    }
    return hr;
}

HRESULT CFileListWrapper::DisplayCrossLinksHTML()
{
    HRESULT hr = S_FALSE;
    if (m_spLinks)
    {
        // Break old connections
        AdviseWebviewLinks( FALSE );
        
        // Replace Links.innerHTML with the new text
        hr = m_spLinks->put_innerHTML(m_bstrCrossLinksHTML);

        // Make new connections
        AdviseWebviewLinks( TRUE );
    }
    return hr;
}

BOOL IsExtensionOneOf(LPCWSTR pwszFileName, const LPCWSTR pwszExtList[], int cExtList)
{
    BOOL fRet = FALSE;
    LPCWSTR pwszExt = PathFindExtensionW(pwszFileName);

    if (pwszExt && *pwszExt)
    {
        for (int i = 0; i < cExtList; i++)
        {
            if (StrCmpICW(pwszExtList[i], pwszExt + 1) == 0) // Get pwszExt past "."
            {
                fRet = TRUE;
                break;
            }
        }
    }
    return fRet;
}

const LPCWSTR c_pwszMovieFileExt[] = {L"asf",L"avi",L"wmv",L"wvx",L"m1v",L"mov",L"mp2",L"mpa",L"mpe",L"mpeg",L"mpg",L"mpv2",L"qt",L"asx"};
BOOL IsMovieFile(LPCWSTR pwszFileName)
{
    return IsExtensionOneOf(pwszFileName, c_pwszMovieFileExt, ARRAYSIZE(c_pwszMovieFileExt));
}

const LPCWSTR c_pwszSoundFileExt[] = {L"aif",L"aiff",L"au",L"mid",L"midi",L"rmi",L"snd",L"wav",L"mp3",L"m3u",L"wma"};
BOOL IsSoundFile(LPCWSTR pwszFileName)
{
    return IsExtensionOneOf(pwszFileName, c_pwszSoundFileExt, ARRAYSIZE(c_pwszSoundFileExt));
}

HRESULT CFileListWrapper::DealWithDriveInfo()
{
    CComBSTR bstrPath;
    // Update ThumbNail
    if (m_pThumbNailWrapper && m_spFolderItem && SUCCEEDED(m_spFolderItem->get_Path(&bstrPath)) && (bstrPath.Length() > 0))
    {
        BOOL bRootFolder = PathIsRootW(bstrPath);
        BOOL bHaveThumbnail = FALSE;
        if (!bRootFolder || !PathIsUNCW(bstrPath))
        {
            bHaveThumbnail = m_pThumbNailWrapper->UpdateThumbNail(m_spFolderItem);
        }
        if (bHaveThumbnail)
        {
            if (bRootFolder)
            {
                WCHAR wszTemp[MAX_PATH];
                CComBSTR bstrSpace;

                if (SUCCEEDED(m_pThumbNailWrapper->TotalSpace(bstrSpace)))
                {
                    m_bstrInfoHTML += OLESTR("<p><br>");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_TOTALSIZE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += bstrSpace;
                    bstrSpace.Empty();
                    m_bstrInfoHTML += OLESTR("<p>");
                }
                if (SUCCEEDED(m_pThumbNailWrapper->UsedSpace(bstrSpace)))
                {
                    m_bstrInfoHTML += OLESTR("<p><table class=Legend width=12 height=12 border=1 align=");
                    if (m_bRTLDocument)
                    {
                        m_bstrInfoHTML += OLESTR("right ");
                    }
                    else
                    {
                        m_bstrInfoHTML += OLESTR("left ");
                    }
                    m_bstrInfoHTML += OLESTR("bgcolor=threedface bordercolordark=black bordercolorlight=black>");
                    m_bstrInfoHTML += OLESTR("<tr><td title=\'");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_USEDSPACE_DESC, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += OLESTR("\'></td></tr></table>&nbsp;");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_USEDSPACE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += bstrSpace;
                    bstrSpace.Empty();
                }
                if (SUCCEEDED(m_pThumbNailWrapper->FreeSpace(bstrSpace)))
                {
                    m_bstrInfoHTML += OLESTR("<p><table class=Legend width=12 height=12 border=1 align=");
                    if (m_bRTLDocument)
                    {
                        m_bstrInfoHTML += OLESTR("right ");
                    }
                    else
                    {
                        m_bstrInfoHTML += OLESTR("left ");
                    }
                    m_bstrInfoHTML += OLESTR("bgcolor=threedhighlight bordercolordark=black bordercolorlight=black>");
                    m_bstrInfoHTML += OLESTR("<tr><td title=\'");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_FREESPACE_DESC, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += OLESTR("\'></td></tr></table>&nbsp;");
                    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_FREESPACE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                    m_bstrInfoHTML += wszTemp;
                    m_bstrInfoHTML += bstrSpace;
                }
                m_pThumbNailWrapper->SetDisplay(CComBSTR(""));
            }
        }
        else if (!bRootFolder)
        {
            BOOL bDisplayFlag = FALSE;
            BOOL bMovieFile = IsMovieFile(bstrPath);

            if (bMovieFile || IsSoundFile(bstrPath))
            {
                CComPtr<IMediaPlayer> spIMediaPlayer;

                if (SUCCEEDED(GetIMediaPlayer(spIMediaPlayer)))
                {
                    spIMediaPlayer->Open(bstrPath);
                    bDisplayFlag = TRUE;
                }
                spIMediaPlayer = NULL;
            }

            if (m_spMediaPlayerStyle && bDisplayFlag)
            {
                if (bMovieFile)
                {
                    m_spMediaPlayerStyle->put_height(CComVariant(136));
                }
                else
                {
                    m_spMediaPlayerStyle->put_height(CComVariant(46));
                }
                m_spMediaPlayerStyle->put_display(OLESTR(""));
            }
        }
    }
    return S_OK;;
}

HRESULT MakeLink(LPCWSTR pwszLink, LPCWSTR pwszText, CComBSTR& bstrText)
{
    HRESULT hr = E_FAIL;
    if (pwszLink)
    {
        bstrText += OLESTR("<A HREF=\"");
        bstrText += pwszLink;
        bstrText += OLESTR("\">");
        if (pwszText && pwszText[0])
        {
            bstrText += pwszText;
        }
        else    // If pwszText is NULL, use pwszLink itself as text.
        {
            bstrText += pwszLink;
        }
        bstrText += OLESTR("</A>");
        hr = S_OK;
    }
    return hr;
}

HRESULT CFileListWrapper::GetItemNameForDisplay()
{
    HRESULT hr = E_FAIL;
    CComBSTR bstrIgnore, bstrName;

    // Get the name of the item
    if (SUCCEEDED(GetItemInfo(IDS_NAME_COL, L"Name", bstrIgnore, bstrName)) && (bstrName.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<b>");   // Begin bold tag
        m_bstrInfoHTML += bstrName;     // Add the name
        m_bstrInfoHTML += OLESTR("</b>"); // End bold tag
        hr = S_OK;
    }
    return hr;
}

HRESULT CFileListWrapper::GetItemType()
{
    CComBSTR bstrIgnore, bstrType;
    HRESULT  hr = GetItemInfo(IDS_TYPE_COL, L"Type", bstrIgnore, bstrType);

    if (SUCCEEDED(hr) && (bstrType.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<br>");
        m_bstrInfoHTML += bstrType;
    } 
    return hr;
}

HRESULT CFileListWrapper::GetItemDateTime()
{
    CComBSTR bstrDesc, bstrDateTime;
    HRESULT  hr = GetItemInfo(IDS_MODIFIED_COL, L"Modified", bstrDesc, bstrDateTime);

    if (SUCCEEDED(hr) && (bstrDateTime.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<p>");
        m_bstrInfoHTML += bstrDesc;
        m_bstrInfoHTML += OLESTR(": ");
        m_bstrInfoHTML += bstrDateTime;
    } 
    return hr;
}

HRESULT CFileListWrapper::GetItemSize()
{
    WCHAR   wszTemp[MAX_PATH];
    long    lSize = 0;
    HRESULT hr = m_spFolderItem->get_Size(&lSize);

    if (SUCCEEDED(hr))
    {
        if (lSize > 0L)
        {
            m_bstrInfoHTML += OLESTR("<p>");
            IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_SIZE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
            m_bstrInfoHTML += wszTemp;
            StrFormatByteSizeW(lSize, wszTemp, ARRAYSIZE(wszTemp));
            m_bstrInfoHTML += wszTemp;
        }
    }
    else
    {
        CComBSTR bstrDesc, bstrSize;
        hr = GetItemInfo(IDS_SIZE_COL, L"Size", bstrDesc, bstrSize);
        if (SUCCEEDED(hr) && (bstrSize.Length() > 0))
        {
            m_bstrInfoHTML += OLESTR("<p>");
            m_bstrInfoHTML += bstrDesc;
            m_bstrInfoHTML += OLESTR(": ");
            m_bstrInfoHTML += bstrSize;
        }
    }
    return hr;
}

const WCHAR c_wszAttributeCodes[] = {L"RHSCE"};
const int c_iaAttribStringIDs[] = {IDS_READONLY, IDS_HIDDEN, IDS_SYSTEM,    //IDS_ARCHIVE,
                                   IDS_COMPRESSED, IDS_ENCRYPTED};
HRESULT FormatAttributes(CComBSTR& bstrDetails, CComBSTR& bstrText)
{
    HRESULT hr = S_OK;
    BOOL    bFlag = FALSE;
    WCHAR   wszDelimiter[10], wszTemp[MAX_PATH];

    IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_DELIMITER, wszDelimiter, ARRAYSIZE(wszDelimiter)), E_FAIL);
    for (int i = 0; i < (int)bstrDetails.Length(); i++)
    {
        WCHAR* pwCh;
        if ((pwCh = StrChrIW(c_wszAttributeCodes, bstrDetails[i])))    // Is the value, one of "RHSCE"?
        {
            if (bFlag)
            {
                bstrText += wszDelimiter;
                bstrText += OLESTR(" ");
            }
            else
            {
                bFlag = TRUE;
            }
            int iPos = (int)(pwCh - c_wszAttributeCodes);
            ASSERT((iPos >= 0) && (iPos < ARRAYSIZE(c_iaAttribStringIDs)));
            IfFalseRet(LoadStringW(_Module.GetResourceInstance(), c_iaAttribStringIDs[iPos], wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
            bstrText += wszTemp;
        }
    }
    if (!bFlag)
    {
        IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_NOATTRIBUTES, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
        bstrText += wszTemp;
    }
    return hr;
}

HRESULT CFileListWrapper::GetItemAttributes()
{
    VARIANT_BOOL fIsFolder;
    HRESULT hr = m_spFolderItem->get_IsFolder(&fIsFolder);
    if (SUCCEEDED(hr) && (fIsFolder == VARIANT_FALSE))
    {
        VARIANT_BOOL fIsFileSystem;
        hr = m_spFolderItem->get_IsFileSystem(&fIsFileSystem);
        if (SUCCEEDED(hr) && (fIsFileSystem == VARIANT_TRUE))
        {
            CComBSTR bstrDesc, bstrAttributes;
            hr = GetItemInfo(IDS_ATTRIBUTES_COL, L"Attributes", bstrDesc, bstrAttributes);
            if (SUCCEEDED(hr))  // Go ahead evenif  (bstrAttributes.Length() > 0)
            {
                m_bstrInfoHTML += OLESTR("<p>");
                m_bstrInfoHTML += bstrDesc;
                m_bstrInfoHTML += OLESTR(": ");
                FormatAttributes(bstrAttributes, m_bstrInfoHTML);
            }
        }
    }
    return hr;
}

HRESULT MakeMailLink(LPCWSTR pwszMailee, CComBSTR& bstrText)
{
    HRESULT hr = S_OK;

    bstrText += OLESTR("<A HREF=\'mailto:");
    bstrText += pwszMailee;
    bstrText += OLESTR("\'>");
    bstrText += pwszMailee;
    bstrText += OLESTR("</a>");
    return hr;
}

HRESULT CFileListWrapper::GetItemAuthor()
{
    CComBSTR bstrDesc, bstrAuthor;
    HRESULT  hr = GetItemInfo(IDS_AUTHOR_COL, L"Author", bstrDesc, bstrAuthor);

    if (SUCCEEDED(hr) && (bstrAuthor.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<p>");
        m_bstrInfoHTML += bstrDesc;
        m_bstrInfoHTML += OLESTR(": ");
        if (StrChrW(bstrAuthor, L'@'))  // This is most likely to be an e-mail address
        {
            MakeMailLink(bstrAuthor, m_bstrInfoHTML);
        }
        else
        {
            m_bstrInfoHTML += bstrAuthor;
        }
        m_bFoundAuthor = TRUE;
    } 
    return hr;
}

HRESULT MakeLinksHyper(LPCWSTR pwszStr, CComBSTR& bstrText)
{
    HRESULT hr = S_OK;
    LPWSTR pwszBegin;

    if ((pwszBegin = StrStrIW(pwszStr, L"http://"))
            || (pwszBegin = StrStrIW(pwszStr, L"file://")))
    {
        WCHAR wszTemp[INTERNET_MAX_URL_LENGTH];
        int i;

        for (i = 0; &pwszStr[i] != pwszBegin; i++)
        {
            wszTemp[i] = pwszStr[i];
        }
        wszTemp[i] = L'\0';
        bstrText += wszTemp;
        WCHAR* pwChEnd = StrStrW(pwszBegin, L" ");
        if (!pwChEnd)
        {
            pwChEnd = &pwszBegin[lstrlenW(pwszBegin)];
        }
        for (i = 0; &pwszBegin[i] != pwChEnd; i++)  // Seperate out the http://... or file://... string
        {
            wszTemp[i] = pwszBegin[i];
        }
        wszTemp[i] = L'\0';
        MakeLink(wszTemp, wszTemp, bstrText);
        for (i = 0; pwChEnd[i]; i++)    // Copy out the rest, till the end
        {
            wszTemp[i] = pwChEnd[i];
        }
        wszTemp[i] = L'\0';
        bstrText += wszTemp;
    }
    else
    {
        bstrText += pwszStr;
    }
    return hr;
}

HRESULT FormatDetails(LPCWSTR pwszDesc, LPCWSTR pwszDetails, CComBSTR& bstrText)
{
    HRESULT hr = S_OK;

    bstrText += OLESTR("<p>");
    bstrText += pwszDesc;
    bstrText += OLESTR(":");
    if ((lstrlenW(pwszDesc) + lstrlenW(pwszDetails)) > 32)
    {
        bstrText += OLESTR("<br>");
    }
    else
    {
        bstrText += OLESTR(" ");
    }
    MakeLinksHyper(pwszDetails, bstrText);
    return hr;
}

HRESULT CFileListWrapper::GetItemComment()
{
    CComBSTR bstrDesc, bstrComment;
    HRESULT  hr = GetItemInfo(IDS_COMMENT_COL, L"Comment", bstrDesc, bstrComment);

    if (SUCCEEDED(hr) && (bstrComment.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<p><div class = Message>");
        m_bstrInfoHTML += bstrComment;
        m_bstrInfoHTML += OLESTR("</div>");
        m_bFoundComment = TRUE;
    } 
    return hr;
}

HRESULT CFileListWrapper::GetItemHTMLInfoTip()
{
    CComBSTR bstrDesc, bstrHTMLInfoTipFile;
    HRESULT  hr = GetItemInfo(0, L"HTMLInfoTipFile", bstrDesc, bstrHTMLInfoTipFile);

    if (SUCCEEDED(hr) && (bstrHTMLInfoTipFile.Length() > 0))
    {
        m_bstrInfoHTML += OLESTR("<br><p><iframe FRAMEBORDER=0 class=Message src=\"");
        m_bstrInfoHTML += bstrHTMLInfoTipFile;
        m_bstrInfoHTML += OLESTR("\"></iframe>");
    }
    return hr;
}

HRESULT CFileListWrapper::GetItemInfo(long lResId, LPWSTR wszInfoDescCanonical, CComBSTR& bstrInfoDesc, CComBSTR& bstrInfo)
{
    HRESULT hr = E_FAIL;
    WCHAR wszInfoDesc[MAX_PATH];

    LoadStringW(_Module.GetResourceInstance(), lResId, wszInfoDesc, ARRAYSIZE(wszInfoDesc));
    bstrInfoDesc = wszInfoDesc;

    if (m_spFolderItem2)
    {
        CComBSTR bstrInfoDescCanonical = wszInfoDescCanonical;
        CComVariant var;
        hr = m_spFolderItem2->ExtendedProperty(bstrInfoDescCanonical, &var);
        if (SUCCEEDED(hr))
        {
            WCHAR wszTemp[80];
            
            if (var.vt == VT_BSTR)
            {
                // Of the three types of data we care about one is dangerous.  The BSTR data that
                // we read from the file could contain HTML code which we would render in WebView.
                // This could cause potential security problems.  To get around this we sanatize
                // the BSTR before we return it.  We need to do the following replacements:
                //
                //  original    replace with
                //      <           &lt;
                //      >           &gt;
                //      "           &quot;      <= this would be paranoid and isn't 100% critical
                //      '           &lsquo;     <= this would be paranoid and isn't 100% critical

                LPWSTR psz = var.bstrVal;
                LPWSTR pszBad;

                if (psz == NULL)
                {
                    // we probably cant depend on hr and the out param matching (since this is 
                    // scriptable and therefore must return success)
                    psz = L"";
                }

                while (pszBad = StrPBrkW(psz, L"<>"))
                {
                    // store the bad character
                    WCHAR chBadChar = *pszBad;

                    // null the string
                    *pszBad = NULL;

                    // add the good part of the string, if there is any
                    if ( *psz )
                        bstrInfo += psz;

                    // based on which bad character we found add the correct HTLM special character code
                    switch ( chBadChar )
                    {
                    case L'<':
                        bstrInfo += L"&lt;";
                        break;

                    case L'>':
                        bstrInfo += L"&gt;";
                        break;
                    }

                    // Advance the psz pointer.  Note it might be an empty string after this.
                    psz = pszBad+1;
                }

                // Add the remaining portion of the good string, even if it's an empty string.
                // bstrInfo is passed in uninitialized so we need to set it to something even
                // if that something is an empty string.
                bstrInfo += psz;
            }
            else if (var.vt == VT_DATE)
            {
                SYSTEMTIME  st;
                FILETIME    ft;

                if (VariantTimeToSystemTime(var.date, &st)
                        && SystemTimeToFileTime(&st, &ft)
                        && SHFormatDateTimeW(&ft, &m_dwDateFlags, wszTemp, ARRAYSIZE(wszTemp)))
                {
                    bstrInfo += wszTemp;
                }
                else
                {
                    hr = E_FAIL;
                }
            }
            else if (var.vt == VT_UI8 && StrCmpIW(wszInfoDescCanonical, L"size") == 0)
            {
                StrFormatByteSize64(var.ullVal, wszTemp, ARRAYSIZE(wszTemp));
                bstrInfo += wszTemp;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

HRESULT CFileListWrapper::NoneSelected()
{
    WCHAR               wszIntro[MAX_PATH];
    CComPtr<FolderItem> spFolderItem;

    if (!m_bCSCDisplayed)
    {
        CSCShowStatusInfo();
        m_bCSCDisplayed = TRUE;
    }
    if (m_spFolderItems->Item(CComVariant(0), &spFolderItem) == S_OK)
    {   // This filelist has atleast one item.
        IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_PROMPT, wszIntro, ARRAYSIZE(wszIntro)), E_FAIL);
    }
    else
    {
        IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_EMPTY, wszIntro, ARRAYSIZE(wszIntro)), E_FAIL);
    }
    m_bstrInfoHTML += wszIntro;
    spFolderItem = NULL;

    if (SUCCEEDED(m_spFolder2->get_Self(&spFolderItem)))
    {
        m_spFolderItem = spFolderItem;
        m_spFolderItem->QueryInterface(IID_FolderItem2, (void **)&m_spFolderItem2);
        m_bFoundAuthor = FALSE;
        m_bFoundComment = FALSE;

        // Get the comment for the item
        GetItemComment();
        GetItemHTMLInfoTip();

        DealWithDriveInfo();

        GetCrossLinks();

        m_spFolderItem2 = NULL;
        m_spFolderItem = NULL;
    }
    return S_OK;
}

#define MAX_SELECTEDFILES_FOR_COMPUTING_SIZE     100
#define MAX_SELECTEDFILES_FOR_DISPLAYING_NAMES   16

HRESULT CFileListWrapper::MultipleSelected(long cSelection)
{
    HRESULT hr = S_FALSE;

    if (cSelection > 1)
    {
        WCHAR    wszTemp[MAX_PATH];

        wnsprintfW(wszTemp, ARRAYSIZE(wszTemp), L"%ld", cSelection);
        m_bstrInfoHTML += wszTemp;
        IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_MULTIPLE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
        m_bstrInfoHTML += wszTemp;
        if (cSelection <= MAX_SELECTEDFILES_FOR_COMPUTING_SIZE)
        {
            m_bstrInfoHTML += OLESTR("<p>");

            CComPtr<FolderItem> spFolderItem;  
            long lSize = 0;

            for (int i = 0; i < cSelection; i++)
            {
                long lTempSize;
                if (SUCCEEDED(m_spFolderItems->Item(CComVariant(i), &spFolderItem)))
                {
                    if (SUCCEEDED(spFolderItem->get_Size(&lTempSize)))
                    {
                        lSize += lTempSize;
                    }
                    spFolderItem = NULL;
                }
            }
            if (lSize > 0L)
            {
                IfFalseRet(LoadStringW(_Module.GetResourceInstance(), IDS_FILESIZE, wszTemp, ARRAYSIZE(wszTemp)), E_FAIL);
                m_bstrInfoHTML += wszTemp;
                StrFormatByteSizeW(lSize, wszTemp, ARRAYSIZE(wszTemp));
                m_bstrInfoHTML += wszTemp;
                m_bstrInfoHTML += OLESTR("<p>");
            }
            if (cSelection <= MAX_SELECTEDFILES_FOR_DISPLAYING_NAMES)
            {
                CComBSTR bstrTemp;
                for (int i = 0; i < cSelection; i++)
                {
                    if (SUCCEEDED(m_spFolderItems->Item(CComVariant(i), &spFolderItem)))
                    {
                        if (SUCCEEDED(spFolderItem->get_Name(&bstrTemp)))
                        {
                            m_bstrInfoHTML += "<br>";
                            m_bstrInfoHTML += bstrTemp;
                            bstrTemp.Empty();
                        }
                        spFolderItem = NULL;
                    }
                }
            }
        }
        hr = S_OK;
    }
    return hr;
}

HRESULT CFileListWrapper::OneSelected()
{
    HRESULT hr = E_FAIL;

    m_bFoundAuthor = FALSE;
    m_bFoundComment = FALSE;

    // Get the name of the item, making it a hyper-link if appropriate.
    GetItemNameForDisplay();

    // Get the type of the item
    GetItemType();

    if (!m_bPathIsSlow)
    {
        // Get the comment for the item
        GetItemComment();

        // Get the HTMLInfoTip
        GetItemHTMLInfoTip();

        // Get the date/time stamp on the item
        GetItemDateTime();

        // Get the size of the item
        GetItemSize();

        // Get the attributes (hidden, RO etc.) of the item
        GetItemAttributes();

        // Get the author of the document
        GetItemAuthor();

        DealWithDriveInfo();
    }
    hr = S_OK;
    return hr;
}

HRESULT CFileListWrapper::OnCSCClick()
{
    HRESULT hres = E_FAIL;
    CComPtr<Folder> spFolder;
    CComPtr<Folder2> spFolder2;

    if (m_spFileList && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
            && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2)))
    {
        m_spFolder2 = spFolder2;
        hres = CSCShowStatus_FoldExpand_Toggle();
        m_spFolder2 = NULL;
    }
    return S_OK;
}

HRESULT CFileListWrapper::OnCSCMouseOnOff(BOOL fOn)
{
    CComPtr<IHTMLStyle> psPlusMin;
    CComPtr<IHTMLStyle> psText;
    HRESULT hres = E_FAIL;

    // If we're already in this state don't do anything
    if (m_bHotTracked == fOn)
        return S_OK;

    // If we receive a 'mouse on' but the element is not one we want to track or if we receive a 'mouse off' but
    // the mouse is over one of our other elements that we want to hot track then don't do anything.
    if (m_spWindow)
    {
        CComPtr<IHTMLEventObj> phtmlevent;
        CComPtr<IHTMLElement> phtmlelement;
        CComBSTR bstrId;

        if (SUCCEEDED(m_spWindow->get_event(&phtmlevent)) && phtmlevent)
        {
            HRESULT hres;

            if (!fOn)
                hres = phtmlevent->get_toElement(&phtmlelement);
            else
                hres = phtmlevent->get_srcElement(&phtmlelement);

            if (SUCCEEDED(hres) && phtmlelement && SUCCEEDED(phtmlelement->get_id(&bstrId)) && (bstrId.Length() > 0))
            {
                BOOL bContainsCSC;
    
                bContainsCSC = (StrStrIW(bstrId, L"CSC") != NULL);
    
                if (bContainsCSC != fOn)
                    return S_OK;
            }
        }
    }

    if (m_spCSCPlusMin && m_spCSCText && SUCCEEDED(hres = m_spCSCPlusMin->get_style(&psPlusMin)) && SUCCEEDED(hres = m_spCSCText->get_style(&psText)))
    {
        CComVariant vcolorBlack (OLESTR("black"));
        CComBSTR bstrCSCPlusMin;
        LPOLESTR pstrCursor = (fOn ? OLESTR("hand") : OLESTR("auto"));
        CComVariant vcolorLink;

        m_bHotTracked = fOn;

        m_spDocument->get_linkColor(&vcolorLink);

        if (m_bExpanded)
            bstrCSCPlusMin = fOn ? CSC_MINUSHOT : CSC_MINUSCOLD;
        else
            bstrCSCPlusMin = fOn ? CSC_PLUSHOT : CSC_PLUSCOLD;
        m_spCSCPlusMin->put_innerHTML(bstrCSCPlusMin);

        psPlusMin->put_cursor(pstrCursor);
        psText->put_color(fOn ? vcolorLink : vcolorBlack);
        psText->put_cursor(pstrCursor);
    }
    return hres;
}

HRESULT CFileListWrapper::CSCSynchronize()
{
    HRESULT hres = E_FAIL;
    CComPtr<Folder> spFolder;
    CComPtr<Folder2> spFolder2;

    if (m_spFileList && SUCCEEDED(m_spFileList->get_Folder(&spFolder))
            && SUCCEEDED(spFolder->QueryInterface(IID_Folder2, (void **)&spFolder2)))
    {
        hres = spFolder2->Synchronize();
    }
    return hres;
}

const UINT c_ids_uiCSCText[] =
        {IDS_CSC_ONLINE, IDS_CSC_OFFLINE, IDS_CSC_SERVERAVAILABLE, IDS_CSC_DIRTYCACHE};
        
HRESULT CFileListWrapper::CSCGetStatusText(LONG lStatus, CComBSTR& bstrCSCText)
{
    WCHAR wszTemp[MAX_PATH];
    if ((lStatus >= 0) && (lStatus < ARRAYSIZE(c_ids_uiCSCText))
            && LoadStringW(_Module.GetResourceInstance(), c_ids_uiCSCText[(int)lStatus], wszTemp, ARRAYSIZE(wszTemp)))
    {
        bstrCSCText += wszTemp;
    }
    return S_OK;
}

const UINT c_ids_uiCSCDetail[] =
        {IDS_CSC_DETAIL_ONLINE, IDS_CSC_DETAIL_OFFLINE, IDS_CSC_DETAIL_SERVERAVAILABLE, IDS_CSC_DETAIL_DIRTYCACHE};

HRESULT CFileListWrapper::CSCGetStatusDetail(LONG lStatus, CComBSTR& bstrCSCDetail)
{
    WCHAR wszTemp[MAX_PATH];
    if ((lStatus >= 0) && (lStatus < ARRAYSIZE(c_ids_uiCSCDetail))
            && LoadStringW(_Module.GetResourceInstance(), c_ids_uiCSCDetail[(int)lStatus], wszTemp, ARRAYSIZE(wszTemp)))
    {
        bstrCSCDetail += wszTemp;
    }
    return S_OK;
}

#define CSC_STATUS_ONLINE           0
#define CSC_STATUS_OFFLINE          1
#define CSC_STATUS_SERVERAVAILABLE  2
#define CSC_STATUS_DIRTYCACHE       3

HRESULT CFileListWrapper::CSCGetStatusButton(LONG lStatus, CComBSTR& bstrCSCButton)
{
    if ((lStatus == CSC_STATUS_SERVERAVAILABLE) || (lStatus == CSC_STATUS_DIRTYCACHE))
    {
        bstrCSCButton += OLESTR("<p class=Button><button onclick=\'WVCoord.CSCSynchronize()\'>");
        WCHAR wszTemp[MAX_PATH];
        LoadStringW(_Module.GetResourceInstance(), IDS_CSC_SYNCHRONIZE, wszTemp, ARRAYSIZE(wszTemp));
        bstrCSCButton += wszTemp;
        bstrCSCButton += OLESTR("</button>");
    }
    return S_OK;
}

HRESULT CFileListWrapper::GetCSCFolderStatus(LONG* plStatus)
{
    return m_spFolder2 ? m_spFolder2->get_OfflineStatus(plStatus) : E_FAIL;
}

HRESULT CFileListWrapper::CSCShowStatusInfo()
{
    LONG lStatus;

    if (m_spCSCText && m_spCSCPlusMin && m_spCSCDetail && m_spCSCButton && m_spCSCStyle
            && m_spCSCDetailStyle && m_spCSCButtonStyle)
    {
        CComBSTR bstrCSC_Display;
        if (SUCCEEDED(GetCSCFolderStatus(&lStatus)) && (lStatus >= 0))
        {
            CComBSTR bstrCSCText;
            CSCGetStatusText(lStatus, bstrCSCText);
            bstrCSCText += OLESTR("<br>");
            
            CComBSTR bstrCSCPlusMin;
            CComBSTR bstrCSCDetail;
            CComBSTR bstrCSCDetail_Display;

            if (m_bExpanded)
            {
                bstrCSCPlusMin = m_bHotTracked ? CSC_MINUSHOT : CSC_MINUSCOLD;
                bstrCSCText += OLESTR("<br>");
                
                CSCGetStatusDetail(lStatus, bstrCSCDetail);
                bstrCSCDetail += OLESTR("<br>");

                bstrCSCDetail_Display = OLESTR("");

                if (m_bRTLDocument)
                {
                    // [msadek]; Life would be easier if the object model has exposed
                    // right offset through get_offsetRight().
                    
                    CComPtr<IHTMLControlElement> spDocBody = NULL;
                    long lOffsetLeft, lOffsetWidth, lClientWidth, lOffsetRight = 0;
                    
                    if (SUCCEEDED(m_spCSCText->QueryInterface(IID_IHTMLControlElement, (void **)&spDocBody))
                        && SUCCEEDED(m_spCSCText->get_offsetLeft(&lOffsetLeft))
                        && SUCCEEDED(m_spCSCText->get_offsetWidth(&lOffsetWidth))
                        && SUCCEEDED(spDocBody->get_clientWidth(&lClientWidth)))
                    {
                        lOffsetRight = lClientWidth - (lOffsetLeft + lOffsetWidth);
                    }
                    m_spCSCDetailStyle->put_marginRight(CComVariant(lOffsetRight - 10L));
                }
                else
                {
                    long lOffsetLeft;
                    if (FAILED(m_spCSCText->get_offsetLeft(&lOffsetLeft)))
                    {
                        lOffsetLeft = 0;
                    }
                    m_spCSCDetailStyle->put_marginLeft(CComVariant(lOffsetLeft - 10L));
                }
            }
            else
            {
                bstrCSCPlusMin = m_bHotTracked ? CSC_PLUSHOT : CSC_PLUSCOLD;
                bstrCSCDetail += OLESTR("");
                bstrCSCDetail_Display = OLESTR("none");
            }
            m_spCSCPlusMin->put_innerHTML(bstrCSCPlusMin);
            m_spCSCText->put_innerHTML(bstrCSCText);
            m_spCSCDetail->put_innerHTML(bstrCSCDetail);
            m_spCSCDetailStyle->put_display(bstrCSCDetail_Display);

            CComBSTR bstrCSCButton_Display;
            CComBSTR bstrCSCButton;
            if (SUCCEEDED(CSCGetStatusButton(lStatus, bstrCSCButton)) && (bstrCSCButton.Length() > 0))
            {
                bstrCSCButton_Display = OLESTR("");
            }
            else
            {
                bstrCSCButton = OLESTR("");
                bstrCSCButton_Display = OLESTR("none");
            }
            m_spCSCButton->put_innerHTML(bstrCSCButton);
            m_spCSCButtonStyle->put_display(bstrCSCButton_Display);
            bstrCSC_Display = OLESTR("");
        }
        else
        {
            bstrCSC_Display = OLESTR("none");
        }
        m_spCSCStyle->put_display(bstrCSC_Display);
    }
    return S_OK;
}

HRESULT CFileListWrapper::CSCShowStatus_FoldExpand_Toggle()
{
    m_bExpanded = !m_bExpanded;
    return  (CSCShowStatusInfo());
}

// fEnter true for mouseover, focus; false for mouseout, blur
HRESULT CFileListWrapper::OnWebviewLinkEvent( BOOL fEnter )
{
    CComPtr<IHTMLEventObj>      spEvent;
    CComPtr<IHTMLElement>       spAnchor;
    HRESULT                     hr;

    // NT# 354743, IHTMLEventObj::get_event() can return S_OK and
    // not set the out param, so we need to protect against that.
    spEvent = NULL;
    hr = m_spWindow->get_event(&spEvent);
    
    // Automation interfaces sometimes return S_FALSE on failures to prevent scripting errors
    if (S_OK == hr)
    {
        // Sometimes Trident will not set the out parameter when it returns S_OK, so
        // we need to make sure it's not NULL.
        if (spEvent)
        {
            hr = GetEventAnchorElement(spEvent, &spAnchor);
        }
        else
            hr = E_FAIL;

        if (S_OK == hr)
        {
            if (fEnter)
            {
                CComBSTR    bstrTitle;
                
                hr = spAnchor->get_title(&bstrTitle);
                if(SUCCEEDED(hr))
                {
                    m_spWindow->put_status(bstrTitle);
                }
                
                spEvent->put_returnValue(CComVariant(true));
            }
            else
            {
                hr = m_spWindow->put_status(OLESTR(""));
            }
        }
    }
    
    return S_OK;
}


// Walks up the component chain from the event source, looking for
// an anchor element. Returns S_OK if successful, some error otherwise.
// On failure *ppElt will be set to null. Note that this gives back
// the IHTMLElement that corresponds to the anchor, not the
// IHTMLAnchorElement, as only IHTMLElement has get_title
HRESULT CFileListWrapper::GetEventAnchorElement( IHTMLEventObj *pEvent,
                                                 IHTMLElement **ppElt )
{
    CComPtr<IHTMLElement>   spElement;

    *ppElt = NULL;
    
    if( SUCCEEDED( pEvent->get_srcElement( &spElement )))
    {
        BOOL    fContinue = TRUE;
        while( fContinue && spElement )
        {
            CComPtr<IHTMLAnchorElement> spAnchor;
            
            if( SUCCEEDED( spElement->QueryInterface( IID_IHTMLAnchorElement,
                                                      reinterpret_cast<void**>( &spAnchor ))))
            {
                fContinue = false;
                *ppElt = spElement;
                reinterpret_cast<IUnknown*>( *ppElt )->AddRef();
            }
            else
            {
                IHTMLElement    *pIElt = NULL;

                if( SUCCEEDED( spElement->get_parentElement( &pIElt )))
                {
                    spElement = pIElt;
                    if (pIElt)
                    {
                        pIElt->Release();
                    }
                }
                else
                {
                    spElement.Release();
                }
            }
        }
    }

    return ( *ppElt ? S_OK : E_FAIL );
}

// Bind to the connection points for each of the link elements
// contained within m_spLinks. The advise cookie for each link
// is stored as an attribute within the link, so we don't need
// to maintain a mapping between links and elements.
// fAdvise -- true to make connections, false to break
HRESULT CFileListWrapper::AdviseWebviewLinks( BOOL fAdvise)
{
    CComPtr<IDispatch>                  spDisp;
    CComPtr<IHTMLElement>               spElement;
    CComPtr<IHTMLElementCollection>     spCollection;
    CComVariant                         vtEmpty;
    CComBSTR                            bstrAttr = WV_LINKNAME;
    long                                cLinks;
    DWORD                               dwCookie;
    HRESULT                             hr;

    IfFailRet( GetWVLinksCollection( &spCollection, &cLinks ));

    for( long i = 0; i < cLinks; i++ )
    {
        hr = spCollection->item( CComVariant( i ), vtEmpty, &spDisp );
        if (!spDisp)
        {
            hr = E_FAIL;
        }

        if( SUCCEEDED( hr ))
        {
            hr = spDisp->QueryInterface( IID_IHTMLElement,
                                         reinterpret_cast<void**>( &spElement ));
            spDisp.Release();
        }

        if( SUCCEEDED( hr ))
        {
            if( fAdvise )
            {
                hr = AtlAdvise( spElement, this, IID_IDispatch, &dwCookie );
                if( SUCCEEDED( hr ))
                {
                    hr = spElement->setAttribute( bstrAttr,
                                                  CComVariant( static_cast<long>( dwCookie )),
                                                  VARIANT_FALSE );

                    if( FAILED( hr ))
                    {
                        AtlUnadvise( spElement, IID_IDispatch, dwCookie );
                    }
                }
            }
            else
            {
                CComVariant vtCookie;
                
                hr = spElement->getAttribute( bstrAttr, FALSE, &vtCookie );
                if( SUCCEEDED( hr ))
                {
                    dwCookie = static_cast<DWORD>( vtCookie.lVal );
                    AtlUnadvise( spElement, IID_IDispatch, dwCookie );
                }                
            }

            spElement.Release();
        }
    }
    
    return S_OK;
}

// Get the IHTMLElementCollection that holds the named links
HRESULT CFileListWrapper::GetWVLinksCollection( IHTMLElementCollection **ppCollection,
                                                long *pcLinks )
{
    CComPtr<IDispatch>                  spDisp;
    CComPtr<IHTMLElementCollection>     spCollection;
    CComVariant                         vtEmpty;
    HRESULT                             hr;

    ASSERT( ppCollection );
    ASSERT( pcLinks );

    *ppCollection = NULL;
    *pcLinks = 0;

    if (!m_spLinks) return E_FAIL;

    // Get the initial element collection from m_spLinks
    IfFailRet( m_spLinks->get_all( &spDisp ));
    IfFailRet( spDisp->QueryInterface( IID_IHTMLElementCollection,
                                       reinterpret_cast<void**>( &spCollection )));
    spDisp.Release();

    // Get the collection of elements with our linkname. If nothing exists, spDisp
    // will be null and item returns S_OK.
    IfFailRet( spCollection->item( CComVariant( WV_LINKNAME ), vtEmpty, &spDisp ));
    if( !spDisp ) return E_FAIL;

    IfFailRet( spDisp->QueryInterface( IID_IHTMLElementCollection,
                                       reinterpret_cast<void**>( ppCollection )));

    return reinterpret_cast<IHTMLElementCollection*>( *ppCollection )->get_length( pcLinks );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\install.cpp ===
#include "priv.h"


HRESULT RegisterActiveDesktopTemplates()
{
    HRESULT hr = E_FAIL;
    TCHAR szPath[MAX_PATH];

    if (GetWindowsDirectory(szPath, ARRAYSIZE(szPath)) &&
        PathAppend(szPath, TEXT("web")))
    {
        // we still register safemode.htt and deskmovr.htt for Active Desktop.

        if (PathAppend(szPath, TEXT("safemode.htt")))
        {
            hr = SHRegisterValidateTemplate(szPath, SHRVT_REGISTER);
        }
        else
        {
            hr = ResultFromLastError();
        }

        if (SUCCEEDED(hr))
        {
            if (PathRemoveFileSpec(szPath) && PathAppend(szPath, TEXT("deskmovr.htt")))
            {
                hr = SHRegisterValidateTemplate(szPath, SHRVT_REGISTER);
            }
            else
            {
                hr = ResultFromLastError();
            }
        }
    }

    return hr;
}


HRESULT FixMyDocsDesktopIni()
{
    HRESULT hr = E_FAIL;
    TCHAR szMyDocsIni[MAX_PATH];

    if ((SHGetFolderPath(NULL, CSIDL_MYPICTURES, NULL, SHGFP_TYPE_CURRENT, szMyDocsIni) == S_OK) &&
        PathAppend(szMyDocsIni, TEXT("desktop.ini")))
    {
        // The default PersistMoniker is automatically determined by the shell.
        // So, lets clear the old settings.
        WritePrivateProfileString(TEXT("{5984FFE0-28D4-11CF-AE66-08002B2E1262}"),
                                  TEXT("WebViewTemplate.NT5"),
                                  NULL,
                                  szMyDocsIni);
        WritePrivateProfileString(TEXT("{5984FFE0-28D4-11CF-AE66-08002B2E1262}"),
                                  TEXT("PersistMoniker"),
                                  NULL,
                                  szMyDocsIni);
        WritePrivateProfileString(TEXT("ExtShellFolderViews"),
                                  TEXT("Default"),
                                  NULL,
                                  szMyDocsIni);
        hr = S_OK;
    }

    return hr;
}


HRESULT SetFileAndFolderAttribs(HINSTANCE hInstResource)
{
    TCHAR szWinPath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH];
    int i;

    const LPCTSTR rgSuperHiddenFiles[] = 
    { 
        TEXT("winnt.bmp"),
        TEXT("winnt256.bmp"),
        TEXT("lanmannt.bmp"),
        TEXT("lanma256.bmp"),
        TEXT("Web"),
        TEXT("Web\\Wallpaper")
    };

    GetWindowsDirectory(szWinPath, ARRAYSIZE(szWinPath));

    // Change the attributes on "Winnt.bmp", "Winnt256.bmp", "lanmannt.bmp", "lanma256.bmp"
    // to super hidden sothat they do not showup in the wallpaper list.
    for (i = 0; i < ARRAYSIZE(rgSuperHiddenFiles); i++)
    {
        lstrcpyn(szDestPath, szWinPath, ARRAYSIZE(szDestPath));
        PathAppend(szDestPath, rgSuperHiddenFiles[i]);
        if (PathIsDirectory(szDestPath))
        {
            PathMakeSystemFolder(szDestPath);
        }
        else
        {
            SetFileAttributes(szDestPath, FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN);
        }
    }

    const int rgSysetemFolders[]  =
    {
       CSIDL_PROGRAM_FILES,
#ifdef _WIN64
       CSIDL_PROGRAM_FILESX86
#endif
    };

    // make the "Program Files" and "Program Files (x86)" system folders
    for (i = 0; i < ARRAYSIZE(rgSysetemFolders); i++)
    {
        if (SHGetFolderPath(NULL, rgSysetemFolders[i], NULL, 0, szDestPath) == S_OK)
        {
            PathMakeSystemFolder(szDestPath);
        }
    }
    
    // Fix up desktop.ini for My Pictures until we completely stop reading from it
    FixMyDocsDesktopIni();

    // register the last two .htt files that Active Desktop still uses
    RegisterActiveDesktopTemplates();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\stdafx.h ===
// stdafx.h : (ATL) include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED_)
#define AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#define _ATL_APARTMENT_THREADED


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CB5C1617_EC46_11D0_A1E0_00A0C9034800__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\stdafx.cpp ===
// stdafx.cpp : (ATL) source file that includes just the standard includes
#include "priv.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\priv.h ===
// priv.h: declarations used throughout webvw
#ifndef __PRIV_H
#define __PRIV_H

#include <shlobj.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shfusion.h>

#include "stdafx.h"
// Keep the above in the same order. Add anything you want to, below this.

#include <wininet.h>
#include <debug.h>
#include <ccstock.h>
#include <ieguidp.h>

#include "resource.h"
#include "wvmacros.h"
#include "webvwid.h"
#include "webvw.h"
#include "util.h"
#include "ThumbCtl.h"

#endif // __PRIV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\thumbwrap.cpp ===
#include "priv.h"
#include "wvcoord.h"

/////////////////////////////////////////////////////////////////////////////
// CThumbNailWrapper
/////////////////////////////////////////////////////////////////////////////

CThumbNailWrapper::CThumbNailWrapper()
{
    // Do nothing for now
}

CThumbNailWrapper::~CThumbNailWrapper()
{
    m_spThumbNailCtl = NULL;
    m_spThumbNailStyle = NULL;
    m_spThumbnailLabel = NULL;
}

HRESULT CThumbNailWrapper::Init(CComPtr<IThumbCtl> spThumbNailCtl,
        CComPtr<IHTMLElement> spThumbnailLabel)

{   
    m_spThumbNailCtl = spThumbNailCtl;
    m_spThumbnailLabel = spThumbnailLabel;
    HRESULT hr = FindObjectStyle((IThumbCtl *)spThumbNailCtl, m_spThumbNailStyle);
    if (SUCCEEDED(hr))
    {
        m_spThumbNailStyle->put_display(OLESTR("none"));    // Hide the thumbctl initially when nothing is displayed.
    }
    return hr;
}

STDMETHODIMP CThumbNailWrapper::Invoke(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr)
{
    HRESULT hr;

    if (riid != IID_NULL) {
        return DISP_E_UNKNOWNINTERFACE;
    }

    hr = S_OK;

    if (dispIdMember == DISPID_ONTHUMBNAILREADY) {
        hr = OnThumbNailReady();
    }

    return hr;
}

HRESULT CThumbNailWrapper::OnThumbNailReady(VOID) 
{
    HRESULT hr = S_OK;

    if (m_spThumbNailCtl)
    {
        VARIANT_BOOL bHaveThumbnail;

        if (SUCCEEDED(m_spThumbNailCtl->haveThumbnail(&bHaveThumbnail)) && bHaveThumbnail)
        {
            hr = m_spThumbNailStyle->put_display(OLESTR(""));
        }
        else
        {
            ClearThumbNail();
        }
    }
    return hr;
}

HRESULT CThumbNailWrapper::FreeSpace(CComBSTR &bstrFree)
{
    return m_spThumbNailCtl->get_freeSpace(&bstrFree);
}

HRESULT CThumbNailWrapper::TotalSpace(CComBSTR &bstrTotal)
{
    return m_spThumbNailCtl->get_totalSpace(&bstrTotal);
}

HRESULT CThumbNailWrapper::UsedSpace(CComBSTR &bstrUsed)
{
    return m_spThumbNailCtl->get_usedSpace(&bstrUsed);
}

HRESULT CThumbNailWrapper::SetDisplay(CComBSTR &bstrDisplay) 
{
    return m_spThumbNailStyle->put_display(bstrDisplay);
}

HRESULT CThumbNailWrapper::SetHeight(int iHeight)
{
    return m_spThumbNailStyle->put_height(CComVariant(iHeight));
}

HRESULT CThumbNailWrapper::_SetThumbnailLabel(CComBSTR& bstrLabel)
{
    if (m_spThumbnailLabel)
    {
        m_spThumbnailLabel->put_innerText(bstrLabel);
    }
    return S_OK;
}

BOOL CThumbNailWrapper::UpdateThumbNail(CComPtr<FolderItem> spFolderItem) 
{
    BOOL bRet = FALSE;
    VARIANT_BOOL bDisplayed;
    CComBSTR     bstrPath;

    ClearThumbNail();

    if (SUCCEEDED(spFolderItem->get_Path(&bstrPath)) && (bstrPath.Length() > 0)
            && SUCCEEDED(m_spThumbNailCtl->displayFile(bstrPath, &bDisplayed)) && bDisplayed)
    {
        CComBSTR bstrLabel, bstrFolderItemName;
        WCHAR wszTemp[MAX_PATH];
        if (PathIsRootW(bstrPath))
        {
            CComBSTR bstrSpace;
            if (SUCCEEDED(UsedSpace(bstrSpace)))
            {
                LoadStringW(_Module.GetResourceInstance(), IDS_USEDSPACE, wszTemp, ARRAYSIZE(wszTemp));
                bstrLabel = wszTemp;
                bstrLabel += bstrSpace;
            }
            if (SUCCEEDED(FreeSpace(bstrSpace)))
            {
                if (bstrLabel.Length() > 0)
                {
                    LoadStringW(_Module.GetResourceInstance(), IDS_PHRASESEPERATOR, wszTemp, ARRAYSIZE(wszTemp));
                    bstrLabel += wszTemp;
                }
                LoadStringW(_Module.GetResourceInstance(), IDS_FREESPACE, wszTemp, ARRAYSIZE(wszTemp));
                bstrLabel += wszTemp;
                bstrLabel += bstrSpace;
            }
        }
        else if (SUCCEEDED(spFolderItem->get_Name(&bstrFolderItemName)))
        {
            WCHAR wszName[MAX_PATH];
            StrCpyNW(wszName, bstrFolderItemName, ARRAYSIZE(wszName));

            WCHAR wszTemp2[MAX_PATH * 2];
            LoadStringW(_Module.GetResourceInstance(), IDS_THUMBNAIL_LABEL, wszTemp, ARRAYSIZE(wszTemp));
            wnsprintfW(wszTemp2, ARRAYSIZE(wszTemp2), wszTemp, wszName);
            bstrLabel = wszTemp2;
        }
        _SetThumbnailLabel(bstrLabel);
        bRet = TRUE;
    }
    return bRet;
}

HRESULT CThumbNailWrapper::ClearThumbNail() 
{
    CComBSTR bstrLabel;
    // Optimization to prevent loading mshtmled.dll - we only need to clear the label if text is currently there.
    if (m_spThumbnailLabel && SUCCEEDED(m_spThumbnailLabel->get_innerText(&bstrLabel)) && bstrLabel)
        _SetThumbnailLabel(CComBSTR(""));
    return m_spThumbNailStyle->put_display(OLESTR("none"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\util.h ===
//
//  util.cpp
//
typedef struct tagGETDCSTATE {
    IOleInPlaceSiteWindowless *pipsw;   // If we got the DC from an interface
    HWND hwnd;                          // If we got the DC from a window
} GETDCSTATE, *PGETDCSTATE;

STDAPI_(HDC) IUnknown_GetDC(IUnknown *punk, LPCRECT prc, PGETDCSTATE pdcs);
STDAPI_(void) IUnknown_ReleaseDC(HDC hdc, PGETDCSTATE pdcs);

DWORD FormatMessageWrapW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPWSTR pwzBuffer, DWORD cchSize, ...);

EXTERN_C int WINAPIV wsprintfWrapW(
    OUT LPWSTR pwszOut,
    IN LPCWSTR pwszFormat,
    ...);
    
//---------------------------------------------------------------------------
// For manipulating BSTRs without using SysAllocString

template<int n> class STATIC_BSTR {
public:
    ULONG _cb;
    WCHAR _wsz[n];
    // Remove const-ness because VARIANTs don't have "const BSTR"
    operator LPWSTR() { return _wsz; }
    void SetSize() { _cb = lstrlenW(_wsz) * sizeof(WCHAR); }
    int inline const MaxSize() { return n; }
};

#define MAKE_CONST_BSTR(name, str) \
    STATIC_BSTR<sizeof(str)/sizeof(WCHAR)> \
                       name = { sizeof(str) - sizeof(WCHAR), str }

#define DECL_CONST_BSTR(name, str) \
    extern STATIC_BSTR<sizeof(str)/sizeof(WCHAR)> name;

extern HRESULT _ComputeFreeSpace(LPCWSTR pszFileName, ULONGLONG& ullFreeSpace,
        ULONGLONG& ullUsedSpace, ULONGLONG& ullTotalSpace);

STDAPI IsSafePage(IUnknown *punkSite);
DWORD IntSqrt(DWORD dwNum);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by webvw.rc
//

#define IDR_THUMBCTL                    101
#define IDR_WEBVIEWCOORD                102
#define IDR_WEBVIEWFOLDERICON           103

#define IDS_INTRO                       5001
#define IDS_PROMPT                      5001
#define IDS_MULTIPLE                    5002
#define IDS_SIZE                        5003
#define IDS_FILESIZE                    5004
#define IDS_DELIMITER                   5005
#define IDS_CODES                       5008
#define IDS_READONLY                    5009
#define IDS_HIDDEN                      5010
#define IDS_SYSTEM                      5011
#define IDS_ARCHIVE                     5012
#define IDS_COMPRESSED                  5013
#define IDS_ENCRYPTED                   5014
#define IDS_NOATTRIBUTES                5015
#define IDS_EMPTY                       5016
#define IDS_PROPERTIES                  5017
#define IDS_TODAY                       5018
#define IDS_YESTERDAY                   5019
#define IDS_PREVIEW                     5020
#define IDS_TOTALSIZE                   5021
#define IDS_USEDSPACE                   5022
#define IDS_FREESPACE                   5023
#define IDS_COMMENTS                    5028
#define IDS_SEEALSO                     5029
#define IDS_MYDOCSTEXT                  5031
#define IDS_MYCOMPTEXT                  5033
#define IDS_MYNETPLACESTEXT             5035
#define IDS_INFOTIP_COL                 5037
#define IDS_NAME_COL                    5038
#define IDS_SIZE_COL                    5039
#define IDS_TYPE_COL                    5040
#define IDS_MODIFIED_COL                5041
#define IDS_ATTRIBUTES_COL              5042
#define IDS_AUTHOR_COL                  5043
#define IDS_TITLE_COL                   5044
#define IDS_PAGES_COL                   5045
#define IDS_COMMENT_COL                 5046
#define IDS_CSC_SYNCHRONIZE             5047
#define IDS_CSC_ONLINE                  5048
#define IDS_CSC_OFFLINE                 5049
#define IDS_CSC_SERVERAVAILABLE         5050
#define IDS_CSC_DIRTYCACHE              5051
#define IDS_CSC_DETAIL_ONLINE           5052
#define IDS_CSC_DETAIL_OFFLINE          5053
#define IDS_CSC_DETAIL_SERVERAVAILABLE  5054
#define IDS_CSC_DETAIL_DIRTYCACHE       5055
#define IDS_NDC                         5056
#define IDS_NDCTEXT                     5057
#define IDS_USEDSPACE_DESC              5058
#define IDS_FREESPACE_DESC              5059
#define IDS_THUMBNAIL_LABEL             5060
#define IDS_PHRASESEPERATOR             5061
#define IDS_WALLPAPER_LOCNAME           5062
#define IDS_WALLPAPER_LOCNAME_PER       5063
#define IDS_WALLPAPER_LOCNAME_SRV       5064

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        204
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\thumbctl.h ===
// ThumbCtl.h : Declaration of the CThumbCtl
#ifndef __THUMBCTL_H_
#define __THUMBCTL_H_

#define WM_HTML_BITMAP  (WM_USER + 100)

EXTERN_C const CLSID CLSID_ThumbCtlOld;   // retired from service


/////////////////////////////////////////////////////////////////////////////
// CThumbCtl
class ATL_NO_VTABLE CThumbCtl : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CThumbCtl, &CLSID_ThumbCtl>,
    public CComControl<CThumbCtl>,
    public IDispatchImpl<IThumbCtl, &IID_IThumbCtl, &LIBID_WEBVWLib>,
    public IProvideClassInfo2Impl<&CLSID_ThumbCtl, NULL, &LIBID_WEBVWLib>,
    public IPersistStreamInitImpl<CThumbCtl>,
    public IPersistStorageImpl<CThumbCtl>,
    public IQuickActivateImpl<CThumbCtl>,
    public IOleControlImpl<CThumbCtl>,
    public IOleObjectImpl<CThumbCtl>,
    public IOleInPlaceActiveObjectImpl<CThumbCtl>,
    public IViewObjectExImpl<CThumbCtl>,
    public IOleInPlaceObjectWindowlessImpl<CThumbCtl>,
    public IDataObjectImpl<CThumbCtl>,
    public ISupportErrorInfo,
    public ISpecifyPropertyPagesImpl<CThumbCtl>,
    public IObjectSafetyImpl<CThumbCtl, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IConnectionPointImpl<CThumbCtl, &DIID_DThumbCtlEvents>,
    public IConnectionPointContainerImpl<CThumbCtl>
{
public:
    // === INTERFACE ===
    // *** IThumbCtl ***
    STDMETHOD(displayFile)(BSTR bsFileName, VARIANT_BOOL *);
    STDMETHOD(haveThumbnail)(VARIANT_BOOL *);
    STDMETHOD(get_freeSpace)(BSTR *);
    STDMETHOD(get_usedSpace)(BSTR *);
    STDMETHOD(get_totalSpace)(BSTR *);

// ATL Functions
    // Drawing function
    HRESULT OnDraw(ATL_DRAWINFO& di);

DECLARE_REGISTRY_RESOURCEID(IDR_THUMBCTL)

BEGIN_COM_MAP(CThumbCtl)
    COM_INTERFACE_ENTRY(IThumbCtl)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IQuickActivate)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
    COM_INTERFACE_ENTRY_IMPL(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY_IMPL(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_IMPL(IConnectionPointContainer)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CThumbCtl)
    CONNECTION_POINT_ENTRY(DIID_DThumbCtlEvents)
END_CONNECTION_POINT_MAP()

BEGIN_PROPERTY_MAP(CThumbCtl)
END_PROPERTY_MAP()

BEGIN_MSG_MAP(CThumbCtl)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    MESSAGE_HANDLER(WM_KILLFOCUS, OnKillFocus)
END_MSG_MAP()

    // *** IObjectSafety ***
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);

    // *** ISupportsErrorInfo ***
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

    // *** IViewObjectEx ***
    STDMETHOD(GetViewStatus)(DWORD* pdwStatus);

    // *** IOleInPlaceActiveObject ***
    virtual STDMETHODIMP TranslateAccelerator(LPMSG pMsg);

public:
    // === PUBLIC FUNCTIONS ===
    CThumbCtl(void);
    ~CThumbCtl(void);

private:
    // === PRIVATE DATA ===
    BOOL m_fRootDrive;      // Do we have a root drive? (if so, display pie chart)

    BOOL                 m_fTabRecieved;    // To avoid re-entrant calls
    
    // thumbnail
    BOOL m_fInitThumb;      // Have we called the setup IThumbnail yet?
    BOOL m_fHaveIThumbnail;     // success of SetupIThumbnail() (only call it once)
    IThumbnail *m_pthumb;       // File to bitmap convertor interface
    HWND m_hwnd;        // invisible window used to receive WM_HTML_BITMAP message
    HBITMAP m_hbm;      // latest calculated bitmap; NULL if have no bitmap
    DWORD m_dwThumbnailID;      // ID to identify which bitmap we received

    // root drive
    enum
    {
        PIE_USEDCOLOR = 0,
        PIE_FREECOLOR,
        PIE_USEDSHADOW,
        PIE_FREESHADOW,
        PIE_NUM     // keep track of number of PIE_ values
    };
    DWORDLONG m_dwlFreeSpace;
    DWORDLONG m_dwlUsedSpace;
    DWORDLONG m_dwlTotalSpace;
    DWORD m_dwUsedSpacePer1000;     // amount of used space /1000
    COLORREF m_acrChartColors[PIE_NUM];         // color scheme
    BOOL m_fUseSystemColors;        // Use system color scheme?

    // === PRIVATE FUNCTIONS ===
    void InvokeOnThumbnailReady(void);

    // For the pie-chart drawing routines...
    HRESULT ComputeFreeSpace(LPTSTR pszFileName);
    HRESULT get_GeneralSpace(DWORDLONG dwlSpace, BSTR *);
    HRESULT Draw3dPie(HDC, LPRECT, DWORD dwPer1000, const COLORREF *);

    // security
    HRESULT _IsSafe()
    {
        return (0==m_dwCurrentSafety) ? S_OK : IsSafePage(m_spClientSite);
    };


    // sets up the thumbnail interface -- must call before use.
    HRESULT SetupIThumbnail(void);
    
    // Window Procedure for catching and storing bitmap
    static LRESULT CALLBACK WndProc(HWND, UINT uMsg, WPARAM, LPARAM);
};

#endif //__THUMBCTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\thumbctl.cpp ===
// ThumbCtl.cpp : Implementation of CThumbCtl
#include "priv.h"
#include "shdguid.h"
#include "strsafe.h"

const CLSID CLSID_ThumbCtlOld = {0x1d2b4f40,0x1f10,0x11d1,{0x9e,0x88,0x00,0xc0,0x4f,0xdc,0xab,0x92}};  // retired from service, so made private

// global
// for LoadLibrary/GetProcAddress on SHGetDiskFreeSpaceA
typedef BOOL (__stdcall * PFNSHGETDISKFREESPACE)(LPCTSTR pszVolume, ULARGE_INTEGER *pqwFreeCaller, ULARGE_INTEGER *pqwTot, ULARGE_INTEGER *pqwFree);

const TCHAR * const g_szWindowClassName = TEXT("MSIE4.0 Webvw.DLL ThumbCtl");
STDAPI IsSafePage(IUnknown *punkSite)
{
    // Return S_FALSE if we don't have a host site since we have no way of doing a 
    // security check.  This is as far as VB 5.0 apps get.
    if (!punkSite)
        return S_FALSE;

    HRESULT hr = E_ACCESSDENIED;
    CComPtr<IDefViewSafety> spDefViewSafety;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_SFolderView,
            IID_PPV_ARG(IDefViewSafety, &spDefViewSafety))))
    {
        hr = spDefViewSafety->IsSafePage();
    }
    return hr;
}

// === INTERFACE ===
// *** IThumbCtl ***
STDMETHODIMP CThumbCtl::displayFile(BSTR bsFileName, VARIANT_BOOL *pfSuccess)
{
    HRESULT hr = E_FAIL;
    *pfSuccess = VARIANT_FALSE;
    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.

        // return S_FALSE --
        // this is because webvw has a customization feature letting people choose 
        // a intranet htt file as their folder.htt, but for security we generally need
        // to block random intranet web pages from calling this method. This will break
        // a case where the customization is done on a NT machine, but the user tries to 
        // view it using Millennium, it will not show any image and pop up error messages 
        // if we return E_ACCESSDENIED.
        hr = S_FALSE;

    }
    else
    {
        // Cancel pending bitmap request if in thumbnail mode && have a functioning IThumbnail
        // && haven't yet received our bitmap
        if(!m_fRootDrive && m_fHaveIThumbnail && m_hbm == NULL)
        {
            m_pthumb->GetBitmap(NULL, 0, 0, 0);
        }

        // change ID to catch late bitmap computed
        ++m_dwThumbnailID;

        // if already displaying something, refresh
        if(m_fRootDrive || m_hbm)
        {
            if(m_hbm)
            {
                DeleteObject(m_hbm);
                m_hbm = NULL;
            }
            FireViewChange();
        }

        // Now work on new thumbnail
        m_fRootDrive = FALSE;

        // check for non-empty file name
        if(bsFileName && bsFileName[0])
        {
            TCHAR szFileName[INTERNET_MAX_URL_LENGTH];
            SHUnicodeToTChar(bsFileName, szFileName, ARRAYSIZE(szFileName));

            DWORD dwAttrs = GetFileAttributes(szFileName);
            // Pie Chart
            if(PathIsRoot(szFileName))
            {
                if(SUCCEEDED(ComputeFreeSpace(szFileName)))
                {
                    m_fRootDrive = TRUE;
                    *pfSuccess = VARIANT_TRUE;
                }
            }
            // Thumbnail
            else if(!(dwAttrs & FILE_ATTRIBUTE_DIRECTORY) && !PathIsSlow(szFileName, dwAttrs))     // should really be calling this from Shell32 private functions
            {
                if(!m_fInitThumb)
                {
                    m_fHaveIThumbnail = SUCCEEDED(SetupIThumbnail());
                    m_fInitThumb = TRUE;
                }
                if(m_fHaveIThumbnail)
                {
                    SIZE size;
                    AtlHiMetricToPixel(&m_sizeExtent, &size);
                    if(EVAL(size.cx > 0 && size.cy > 0))
                    {
                        if(SUCCEEDED(m_pthumb->GetBitmap(bsFileName, m_dwThumbnailID, size.cx, size.cy)))
                        {
                            *pfSuccess = VARIANT_TRUE;
                        }
                    }
                }
            }
        }

        hr = S_OK;
    }
    return hr;
}       // displayFile

STDMETHODIMP CThumbCtl::haveThumbnail(VARIANT_BOOL *pfRes)
{
    HRESULT hr;
    *pfRes = VARIANT_FALSE;
    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.

        // return S_FALSE --
        // this is because webvw has a customization feature letting people choose 
        // a intranet htt file as their folder.htt, but for security we generally need
        // to block random intranet web pages from calling this method. This will break
        // a case where the customization is done on a NT machine, but the user tries to 
        // view it using Millennium, it will not show any image and pop up error messages 
        // if we return E_ACCESSDENIED.
        hr = S_FALSE;

    }
    else
    {
        *pfRes = (m_fRootDrive || m_hbm) ? VARIANT_TRUE : VARIANT_FALSE;
        hr = S_OK;
    }

    return hr;
}

STDMETHODIMP CThumbCtl::get_freeSpace(BSTR *pbs)
{
    HRESULT hr;
    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        *pbs = SysAllocString(L"");
        hr = (*pbs) ? S_FALSE : E_OUTOFMEMORY;
    }
    else
    {
        get_GeneralSpace(m_dwlFreeSpace, pbs);
        hr = S_OK;
    }
    return hr;
}       // get_freeSpace


STDMETHODIMP CThumbCtl::get_usedSpace(BSTR *pbs)
{
    HRESULT hr;
    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        *pbs = SysAllocString(L"");
        hr = (*pbs) ? S_FALSE : E_OUTOFMEMORY;
    }
    else
    {
        get_GeneralSpace(m_dwlUsedSpace, pbs);
        hr = S_OK;
    }
    return hr;
}       // get_usedSpace

STDMETHODIMP CThumbCtl::get_totalSpace(BSTR *pbs)
{
    HRESULT hr;
    if (S_OK != _IsSafe())
    {
        // We don't trust this host, so we are going to not carry
        // out the action.  We are going to return E_ACCESSDENIED so they can't
        // determine if the path exists or not.
        *pbs = SysAllocString(L"");
        hr = (*pbs) ? S_FALSE : E_OUTOFMEMORY;
    }
    else
    {    
        get_GeneralSpace(m_dwlTotalSpace, pbs);
        hr = S_OK;
    }
    return hr;
}       // get_totalSpace

// *** IObjectSafety ***
STDMETHODIMP CThumbCtl::GetInterfaceSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions,
                                                  DWORD *pdwEnabledOptions)
{
    ATLTRACE(_T("IObjectSafetyImpl::GetInterfaceSafetyOptions\n"));
    if (pdwSupportedOptions == NULL || pdwEnabledOptions == NULL)
        return E_POINTER;
    HRESULT hr = S_OK;
    if (riid == IID_IDispatch)
    {
        *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA;
        *pdwEnabledOptions = m_dwCurrentSafety & (INTERFACESAFE_FOR_UNTRUSTED_CALLER | INTERFACESAFE_FOR_UNTRUSTED_DATA);
    }
    else
    {
        *pdwSupportedOptions = 0;
        *pdwEnabledOptions = 0;
        hr = E_NOINTERFACE;
    }
    return hr;
}

// *** ISupportsErrorInfo ***
STDMETHODIMP CThumbCtl::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IThumbCtl,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

// *** IViewObjectEx ***
STDMETHODIMP CThumbCtl::GetViewStatus(DWORD* pdwStatus)
{
    ATLTRACE(_T("IViewObjectExImpl::GetViewStatus\n"));
    *pdwStatus = VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE;
    return S_OK;
}

// *** IOleInPlaceActiveObject ***
HRESULT CThumbCtl::TranslateAccelerator(LPMSG pMsg)
{
    HRESULT hres = S_OK;
    if (!m_fTabRecieved)
    {
        hres = IOleInPlaceActiveObjectImpl<CThumbCtl>::TranslateAccelerator(pMsg);

        // If we did not handle this and if it is a tab (and we are not getting it in a cycle), forward it to trident, if present.
        if (hres != S_OK && pMsg && (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6) && m_spClientSite)
        {
            if (GetFocus() != m_hwnd)
            {
               ::SetFocus(m_hwnd);
                hres = S_OK;
            }
            else
            {
                IOleControlSite* pocs = NULL;
                if (SUCCEEDED(m_spClientSite->QueryInterface(IID_IOleControlSite, (void **)&pocs)))
                {
                    DWORD grfModifiers = 0;
                    if (GetKeyState(VK_SHIFT) & 0x8000)
                    {
                        grfModifiers |= 0x1;    //KEYMOD_SHIFT
                    }
                    if (GetKeyState(VK_CONTROL) & 0x8000)
                    {
                        grfModifiers |= 0x2;    //KEYMOD_CONTROL;
                    }
                    if (GetKeyState(VK_MENU) & 0x8000)
                    {
                        grfModifiers |= 0x4;    //KEYMOD_ALT;
                    }
                    m_fTabRecieved = TRUE;
                    hres = pocs->TranslateAccelerator(pMsg, grfModifiers);
                    m_fTabRecieved = FALSE;
                }
            }
        }
    }
    return hres;
}

// === PUBLIC FUNCTIONS ===
// CONSTRUCTOR/DESTRUCTOR
CThumbCtl::CThumbCtl(void):
    m_fRootDrive(FALSE),
    m_fInitThumb(FALSE),
    m_fHaveIThumbnail(FALSE),
    m_pthumb(NULL),
    m_hwnd(NULL),
    m_hbm(NULL),
    m_dwThumbnailID(0),
    m_dwlFreeSpace(0),
    m_dwlUsedSpace(0),
    m_dwlTotalSpace(0),
    m_dwUsedSpacePer1000(0),
    m_fUseSystemColors(TRUE)
{
    m_fTabRecieved = FALSE;
}

CThumbCtl::~CThumbCtl(void)
{
    if(m_hbm)
    {
        DeleteObject(m_hbm);
        m_hbm = NULL;
    }
    if(m_pthumb)
    {
        m_pthumb->Release();        // will cancel pending bitmap requests
        m_pthumb = NULL;
    }
    if(m_hwnd)
    {
        EVAL(::DestroyWindow(m_hwnd));
        m_hwnd = NULL;
    }
}

// === PRIVATE FUNCTIONS ===
// Thumbnail drawing functions
HRESULT CThumbCtl::SetupIThumbnail(void)
{
    HRESULT hr = E_FAIL;

    // Create Window Class
    WNDCLASS wc;
    if (!::GetClassInfoWrap(_Module.GetModuleInstance(), g_szWindowClassName, &wc))
    {
        wc.style = 0;
        wc.lpfnWndProc = CThumbCtl::WndProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 0;
        wc.hInstance = _Module.GetModuleInstance();
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName = NULL;
        wc.lpszClassName = g_szWindowClassName;

        RegisterClass(&wc);
    }

    m_hwnd = CreateWindow(g_szWindowClassName, NULL, WS_POPUP, CW_USEDEFAULT, CW_USEDEFAULT,
        CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, _Module.GetModuleInstance(), this);
    if(m_hwnd)
    {
        if(SUCCEEDED(CoCreateInstance(CLSID_Thumbnail, NULL, CLSCTX_INPROC_SERVER, IID_IThumbnail, (void **)&m_pthumb)))
        {
            if(SUCCEEDED(m_pthumb->Init(m_hwnd, WM_HTML_BITMAP)))
            {
                hr = S_OK;
            }
        }
        if(FAILED(hr))
        {
            EVAL(::DestroyWindow(m_hwnd));
            m_hwnd = NULL;
        }
    }
    return hr;
}

LRESULT CALLBACK CThumbCtl::WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CThumbCtl *ptc = (CThumbCtl *)::GetWindowLongPtr(hWnd, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_CREATE:
        {
            ptc = (CThumbCtl *)((CREATESTRUCT *)lParam)->lpCreateParams;
            ::SetWindowLongPtr(hWnd, GWLP_USERDATA, (LPARAM)ptc);
        }
        break;

    case WM_HTML_BITMAP:
        // check that ptc is still alive, bitmap is current using ID
        if(ptc && ptc->m_dwThumbnailID == wParam)
        {
            // ptc->displayFile() should've destroyed old bitmap already, but doesn't hurt to check.
            if(!EVAL(ptc->m_hbm == NULL))
            {
                DeleteObject(ptc->m_hbm);
            }
            ptc->m_hbm = (HBITMAP)lParam;
            ptc->InvokeOnThumbnailReady();
        }
        else if(lParam)
        {
            DeleteObject((HBITMAP)lParam);
        }
        break;

    case WM_DESTROY:
        // ignore late messages
        if(ptc)
        {
            MSG msg;

            while(PeekMessage(&msg, hWnd, WM_HTML_BITMAP, WM_HTML_BITMAP, PM_REMOVE))
            {
                if(msg.lParam)
                {
                    DeleteObject((HBITMAP)msg.lParam);
                }
            }
            ::SetWindowLongPtr(hWnd, GWLP_USERDATA, NULL);
        }
        break;

    default:
        return ::DefWindowProc(hWnd, uMsg, wParam, lParam);
    }

    return 0;
}

// Pie Chart functions
HRESULT CThumbCtl::ComputeFreeSpace(LPTSTR pszFileName)
{
    ULARGE_INTEGER qwFreeCaller;        // use this for free space -- this will take into account disk quotas and such on NT
    ULARGE_INTEGER qwTotal;
    ULARGE_INTEGER qwFree;      // unused
    static PFNSHGETDISKFREESPACE pfnSHGetDiskFreeSpace = NULL;

    if (NULL == pfnSHGetDiskFreeSpace)
    {
        HINSTANCE hinstShell32 = LoadLibrary(TEXT("SHELL32.DLL"));
        if (hinstShell32)
        {
#ifdef UNICODE
            pfnSHGetDiskFreeSpace = (PFNSHGETDISKFREESPACE)GetProcAddress(hinstShell32, "SHGetDiskFreeSpaceExW");
#else
            pfnSHGetDiskFreeSpace = (PFNSHGETDISKFREESPACE)GetProcAddress(hinstShell32, "SHGetDiskFreeSpaceExA");
#endif
        }
    }

    // Compute free & total space and check for valid results
    // if have a fn pointer call SHGetDiskFreeSpaceA
    if( pfnSHGetDiskFreeSpace
        && pfnSHGetDiskFreeSpace(pszFileName, &qwFreeCaller, &qwTotal, &qwFree) )
    {
        m_dwlFreeSpace = qwFreeCaller.QuadPart;
        m_dwlTotalSpace = qwTotal.QuadPart;
        m_dwlUsedSpace = m_dwlTotalSpace - m_dwlFreeSpace;

        if ((m_dwlTotalSpace > 0) && (m_dwlFreeSpace <= m_dwlTotalSpace))
        {
            // some special cases require interesting treatment
            if(m_dwlTotalSpace == 0 || m_dwlFreeSpace == m_dwlTotalSpace)
            {
                m_dwUsedSpacePer1000 = 0;
            }
            else if(m_dwlFreeSpace == 0)
            {
                m_dwUsedSpacePer1000 = 1000;
            }
            else
            {
                // not completely full or empty
                m_dwUsedSpacePer1000 = (DWORD)(m_dwlUsedSpace * 1000 / m_dwlTotalSpace);

                // Trick: if user has extremely little free space, the user expects to still see
                // a tiny free slice -- not a full drive.  Similarly for almost free drive.
                if(m_dwUsedSpacePer1000 == 0)
                {
                    m_dwUsedSpacePer1000 = 1;
                }
                else if(m_dwUsedSpacePer1000 == 1000)
                {
                    m_dwUsedSpacePer1000 = 999;
                }
            }
            return S_OK;
        }
    }
    return E_FAIL;
}

// 32 should be plenty
#define STRLENGTH_SPACE 32

HRESULT CThumbCtl::get_GeneralSpace(DWORDLONG dwlSpace, BSTR *pbs)
{
    ASSERT(pbs != NULL);

    WCHAR wszText[STRLENGTH_SPACE];

    if(m_fRootDrive)
    {
        StrFormatByteSizeW(dwlSpace, wszText, ARRAYSIZE(wszText));
        *pbs = SysAllocString(wszText);
    }
    else
    {
        *pbs = SysAllocString(L"");
    }

    return *pbs? S_OK: E_OUTOFMEMORY;
}

HRESULT CThumbCtl::Draw3dPie(HDC hdc, LPRECT lprc, DWORD dwPer1000, const COLORREF *lpColors)
{
    ASSERT(lprc != NULL && lpColors != NULL);

    enum
    {
        COLOR_UP = 0,
        COLOR_DN,
        COLOR_UPSHADOW,
        COLOR_DNSHADOW,
        COLOR_NUM       // #of entries
    };

    // The majority of this code came from "drawpie.c"
    const LONG c_lShadowScale = 6;       // ratio of shadow depth to height
    const LONG c_lAspectRatio = 2;      // ratio of width : height of ellipse

    // We make sure that the aspect ratio of the pie-chart is always preserved 
    // regardless of the shape of the given rectangle
    // Stabilize the aspect ratio now...
    LONG lHeight = lprc->bottom - lprc->top;
    LONG lWidth = lprc->right - lprc->left;
    LONG lTargetHeight = (lHeight * c_lAspectRatio <= lWidth? lHeight: lWidth / c_lAspectRatio);
    LONG lTargetWidth = lTargetHeight * c_lAspectRatio;     // need to adjust because w/c * c isn't always == w

    // Shrink the rectangle on both sides to the correct size
    lprc->top += (lHeight - lTargetHeight) / 2;
    lprc->bottom = lprc->top + lTargetHeight;
    lprc->left += (lWidth - lTargetWidth) / 2;
    lprc->right = lprc->left + lTargetWidth;

    // Compute a shadow depth based on height of the image
    LONG lShadowDepth = lTargetHeight / c_lShadowScale;

    // check dwPer1000 to ensure within bounds
    if(dwPer1000 > 1000)
        dwPer1000 = 1000;

    // Now the drawing function
    int cx, cy, rx, ry, x, y;
    int uQPctX10;
    RECT rcItem;
    HRGN hEllRect, hEllipticRgn, hRectRgn;
    HBRUSH hBrush, hOldBrush;
    HPEN hPen, hOldPen;

    rcItem = *lprc;
    rcItem.left = lprc->left;
    rcItem.top = lprc->top;
    rcItem.right = lprc->right - rcItem.left;
    rcItem.bottom = lprc->bottom - rcItem.top - lShadowDepth;

    rx = rcItem.right / 2;
    cx = rcItem.left + rx - 1;
    ry = rcItem.bottom / 2;
    cy = rcItem.top + ry - 1;
    if (rx<=10 || ry<=10)
    {
        return S_FALSE;
    }

    rcItem.right = rcItem.left+2*rx;
    rcItem.bottom = rcItem.top+2*ry;

    /* Translate to first quadrant of a Cartesian system
    */
    uQPctX10 = (dwPer1000 % 500) - 250;
    if (uQPctX10 < 0)
    {
        uQPctX10 = -uQPctX10;
    }

    /* Calc x and y.  I am trying to make the area be the right percentage.
    ** I don't know how to calculate the area of a pie slice exactly, so I
    ** approximate it by using the triangle area instead.
    */

    // NOTE-- *** in response to the above comment ***
    // Calculating the area of a pie slice exactly is actually very
    // easy by conceptually rescaling into a circle but the complications
    // introduced by having to work in fixed-point arithmetic makes it
    // unworthwhile to code this-- CemP
    
    if (uQPctX10 < 120)
    {
        x = IntSqrt(((DWORD)rx*(DWORD)rx*(DWORD)uQPctX10*(DWORD)uQPctX10)
            /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

        y = IntSqrt(((DWORD)rx*(DWORD)rx-(DWORD)x*(DWORD)x)*(DWORD)ry*(DWORD)ry/((DWORD)rx*(DWORD)rx));
    }
    else
    {
        y = IntSqrt((DWORD)ry*(DWORD)ry*(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)
            /((DWORD)uQPctX10*(DWORD)uQPctX10+(250L-(DWORD)uQPctX10)*(250L-(DWORD)uQPctX10)));

        x = IntSqrt(((DWORD)ry*(DWORD)ry-(DWORD)y*(DWORD)y)*(DWORD)rx*(DWORD)rx/((DWORD)ry*(DWORD)ry));
    }

    /* Switch on the actual quadrant
    */
    switch (dwPer1000 / 250)
    {
    case 1:
        y = -y;
        break;

    case 2:
        break;

    case 3:
        x = -x;
        break;

    default: // case 0 and case 4
        x = -x;
        y = -y;
        break;
    }

    /* Now adjust for the center.
    */
    x += cx;
    y += cy;

    // Hack to get around bug in NTGDI        
    x = x < 0 ? 0 : x;

    /* Draw the shadows using regions (to reduce flicker).
    */
    hEllipticRgn = CreateEllipticRgnIndirect(&rcItem);
    OffsetRgn(hEllipticRgn, 0, lShadowDepth);
    hEllRect = CreateRectRgn(rcItem.left, cy, rcItem.right, cy+lShadowDepth);
    hRectRgn = CreateRectRgn(0, 0, 0, 0);
    CombineRgn(hRectRgn, hEllipticRgn, hEllRect, RGN_OR);
    OffsetRgn(hEllipticRgn, 0, -(int)lShadowDepth);
    CombineRgn(hEllRect, hRectRgn, hEllipticRgn, RGN_DIFF);

    /* Always draw the whole area in the free shadow/
    */
    hBrush = CreateSolidBrush(lpColors[COLOR_DNSHADOW]);
    if (hBrush)
    {
        FillRgn(hdc, hEllRect, hBrush);
        DeleteObject(hBrush);
    }

    /* Draw the used shadow only if the disk is at least half used.
    */
    if (dwPer1000>500 && (hBrush = CreateSolidBrush(lpColors[COLOR_UPSHADOW]))!=NULL)
    {
        DeleteObject(hRectRgn);
        hRectRgn = CreateRectRgn(x, cy, rcItem.right, lprc->bottom);
        CombineRgn(hEllipticRgn, hEllRect, hRectRgn, RGN_AND);
        FillRgn(hdc, hEllipticRgn, hBrush);
        DeleteObject(hBrush);
    }

    DeleteObject(hRectRgn);
    DeleteObject(hEllipticRgn);
    DeleteObject(hEllRect);

    hPen = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_WINDOWFRAME));
    hOldPen = (HPEN__*) SelectObject(hdc, hPen);

    // if per1000 is 0 or 1000, draw full elipse, otherwise, also draw a pie section.
    // we might have a situation where per1000 isn't 0 or 1000 but y == cy due to approx error,
    // so make sure to draw the ellipse the correct color, and draw a line (with Pie()) to
    // indicate not completely full or empty pie.
    hBrush = CreateSolidBrush(lpColors[dwPer1000 < 500 && y == cy && x < cx? COLOR_DN: COLOR_UP]);
    hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

    Ellipse(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom);
    SelectObject(hdc, hOldBrush);
    DeleteObject(hBrush);

    if(dwPer1000 != 0 && dwPer1000 != 1000)
    {
        // display small sub-section of ellipse for smaller part
        hBrush = CreateSolidBrush(lpColors[COLOR_DN]);
        hOldBrush = (HBRUSH__*) SelectObject(hdc, hBrush);

        // NTRAID#087993-2000/02/16-aidanl: Pie may malfunction when y approaches cy
        // If y == cy (when the disk is almost full)and if x approaches
        // rcItem.left, on win9x, Pie malfunctions. It draws the larger portion
        // of the pie, instead of the smaller portion. We work around it by
        // adding 1 to y.
        Pie(hdc, rcItem.left, rcItem.top, rcItem.right, rcItem.bottom,
            rcItem.left, cy, x, (y == cy) ? (y + 1) : y);
        SelectObject(hdc, hOldBrush);
        DeleteObject(hBrush);
    }

    Arc(hdc, rcItem.left, rcItem.top+lShadowDepth, rcItem.right - 1, rcItem.bottom+lShadowDepth - 1,
        rcItem.left, cy+lShadowDepth, rcItem.right, cy+lShadowDepth-1);
    MoveToEx(hdc, rcItem.left, cy, NULL);
    LineTo(hdc, rcItem.left, cy+lShadowDepth);
    MoveToEx(hdc, rcItem.right-1, cy, NULL);
    LineTo(hdc, rcItem.right-1, cy+lShadowDepth);
    if(dwPer1000 > 500 && dwPer1000 < 1000)
    {
        MoveToEx(hdc, x, y, NULL);
        LineTo(hdc, x, y+lShadowDepth);
    }
    SelectObject(hdc, hOldPen);
    DeleteObject(hPen);

    return S_OK;    // Everything worked fine
}   // Draw3dPie

// General functions
void CThumbCtl::InvokeOnThumbnailReady(void)
{
    // Fire off "OnThumbnailReady" event to our connection points to indicate that
    // either a thumbnail has been computed or we have no thumbnail for this file.
    DISPPARAMS dp = {0, NULL, 0, NULL};     // no parameters
    IUnknown **pp = NULL;       // traverses connection points, where it is interpreted as IDispatch*

    Lock();

    for(pp = m_vec.begin(); pp < m_vec.end(); ++pp)
    {
        if(pp)
        {
            ((IDispatch *)*pp)->Invoke(DISPID_ONTHUMBNAILREADY, IID_NULL, LOCALE_USER_DEFAULT,
                DISPATCH_METHOD, &dp, NULL, NULL, NULL);
        }
    }

    Unlock();

    FireViewChange();
}

HRESULT CThumbCtl::OnDraw(ATL_DRAWINFO& di)
{
    HDC hdc = di.hdcDraw;
    RECT rc = *(LPRECT)di.prcBounds;
    HRESULT hr = S_OK;

    if(m_fRootDrive || m_hbm)
    {
        HPALETTE hpal = NULL;

        // Create pallete appropriate for this HDC
        if(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
        {
            hpal = SHCreateShellPalette(hdc);
            HPALETTE hpalOld = SelectPalette(hdc, hpal, TRUE);
            RealizePalette(hdc);

            // Old one needs to be selected back in
            SelectPalette(hdc, hpalOld, TRUE);
        }

        if(m_fRootDrive)
        {
            // Draw a pie chart
            if(m_fUseSystemColors)
            {
                // system colors can change!
                m_acrChartColors[PIE_USEDCOLOR] = GetSysColor(COLOR_3DFACE);
                m_acrChartColors[PIE_FREECOLOR] = GetSysColor(COLOR_3DHILIGHT);
                m_acrChartColors[PIE_USEDSHADOW] = GetSysColor(COLOR_3DSHADOW);
                m_acrChartColors[PIE_FREESHADOW] = GetSysColor(COLOR_3DFACE);
            }
            else if(GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
            {
                // Call GetNearestColor on the colors to make sure they're on the palette
                // Of course, system colors ARE on the palette (I think)
                DWORD dw = 0;       // index
                for(dw = 0; dw < PIE_NUM; dw++)
                {
                    m_acrChartColors[dw] = GetNearestColor(hdc, m_acrChartColors[dw]);
                }
            }
            hr = Draw3dPie(hdc, &rc, m_dwUsedSpacePer1000, m_acrChartColors);
        }
        else
        {
            // Draw the Thumbnail bitmap
            HDC hdcBitmap = CreateCompatibleDC(hdc);
            if (hdcBitmap)
            {
                BITMAP bm;

                SelectObject(hdcBitmap, m_hbm);
                GetObject(m_hbm, SIZEOF(bm), &bm);

                if(bm.bmWidth == rc.right - rc.left && bm.bmHeight == rc.bottom - rc.top)
                {
                    BitBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                        hdcBitmap, 0, 0, SRCCOPY);
                }
                else
                {
                    SetStretchBltMode(hdc, COLORONCOLOR);
                    StretchBlt(hdc, rc.left, rc.top, rc.right - rc.left, rc.bottom - rc.top,
                        hdcBitmap, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY);
                }
                DeleteDC(hdcBitmap);
            }
        }

        // clean up DC, palette
        if(hpal)
        {
            DeleteObject(hpal);
        }
    }
    else
    {
        SelectObject(hdc, GetStockObject(WHITE_PEN));
        SelectObject(hdc, GetStockObject(WHITE_BRUSH));

        // Just draw a blank rectangle
        Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\util.cpp ===
#include "priv.h"
#include "wvcoord.h"


HRESULT GetObjectFromContainer(IDispatch *pdispContainer, LPOLESTR poleName, IDispatch **ppdisp)
{
    HRESULT hr = E_FAIL;

    *ppdisp = NULL;
    if (pdispContainer && poleName)
    {
        DISPID dispID;
        // Get the object dispid from the container
        if (SUCCEEDED(pdispContainer->GetIDsOfNames(IID_NULL, &poleName, 1, 0, &dispID)))
        {
            DISPPARAMS dp = {0};
            EXCEPINFO ei = {0};

            VARIANTARG va;       
            if (SUCCEEDED((pdispContainer->Invoke(dispID, IID_NULL, 0, DISPATCH_PROPERTYGET, &dp, &va, &ei, NULL))
                    && va.vt == VT_DISPATCH))
            {
                *ppdisp = va.pdispVal;
                hr = S_OK;
            }
        }
    }
    return hr;
}

// Get punkObject.style property
HRESULT FindObjectStyle(IUnknown *punkObject, CComPtr<IHTMLStyle>& spStyle)
{
    HRESULT hr = E_FAIL;

    CComPtr<IDispatch> spdispObject, spdispObjectOuter, spdispObjectStyle;
    if (SUCCEEDED(punkObject->QueryInterface(IID_PPV_ARG(IDispatch, &spdispObject)))
            && SUCCEEDED(spdispObject->QueryInterface(IID_PPV_ARG(IDispatch, &spdispObjectOuter)))
            && SUCCEEDED(GetObjectFromContainer(spdispObjectOuter, OLESTR("style"), &spdispObjectStyle))
            && SUCCEEDED(spdispObjectStyle->QueryInterface(IID_PPV_ARG(IHTMLStyle, &spStyle))))
    {
        hr = S_OK;
    }
    return hr;
}

BOOL IsRTLDocument(CComPtr<IHTMLDocument2>& spHTMLDocument)
{

    BOOL bRet = FALSE;
    CComPtr<IHTMLDocument3> spHTMLDocument3;
    CComBSTR bstrDir;
    if (spHTMLDocument && SUCCEEDED(spHTMLDocument->QueryInterface(IID_IHTMLDocument3, (void **)&spHTMLDocument3))
            && SUCCEEDED(spHTMLDocument3->get_dir(&bstrDir)) && bstrDir && (StrCmpIW(bstrDir, L"RTL") == 0))
    {
        bRet = TRUE;
    }
    return bRet;
}

//
//  How many ways are there to get a DC?
//
//  1.  If the site supports IOleInPlaceSiteWindowless, we can get the DC
//      via IOleInPlaceSiteWindowless::GetDC and give it back with ReleaseDC.
//
//  2.  If the site supports any of the GetWindow interfaces, we get its
//      window and ask USER for the DC.
//
//  3.  If we can't get any of that stuff, then we just get a screen DC
//      (special case where the associated window is NULL).
//
//  Note!  This function tries really really hard to get the DC.  You
//  should use it only for informational purposes, not for drawing.
//

STDAPI_(HDC) IUnknown_GetDC(IUnknown *punk, LPCRECT prc, PGETDCSTATE pdcs)
{
    HRESULT hr = E_FAIL;
    HDC hdc = NULL;
    ZeroMemory(pdcs, sizeof(PGETDCSTATE));

    if (punk &&
        SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IOleInPlaceSiteWindowless, &pdcs->pipsw))))
    {
        hr = pdcs->pipsw->GetDC(prc, OLEDC_NODRAW, &hdc);
        if (FAILED(hr))
        {
            ATOMICRELEASE(pdcs->pipsw);
        }

    }

    if (FAILED(hr))
    {
        // This will null out the hwnd on failure, which is what we want!
        IUnknown_GetWindow(punk, &pdcs->hwnd);
        hdc = GetDC(pdcs->hwnd);
    }

    return hdc;
}

STDAPI_(void) IUnknown_ReleaseDC(HDC hdc, PGETDCSTATE pdcs)
{
    if (pdcs->pipsw)
    {
        pdcs->pipsw->ReleaseDC(hdc);
        ATOMICRELEASE(pdcs->pipsw);
    }
    else
        ReleaseDC(pdcs->hwnd, hdc);
}

DWORD FormatMessageWrapW(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageID, DWORD dwLangID, LPWSTR pwzBuffer, DWORD cchSize, ...)
{
    va_list vaParamList;

    va_start(vaParamList, cchSize);
    DWORD dwResult = FormatMessageW(dwFlags, lpSource, dwMessageID, dwLangID, pwzBuffer, cchSize, &vaParamList);
    va_end(vaParamList);

    return dwResult;
}

// for LoadLibrary/GetProcAddress on SHGetDiskFreeSpaceA
typedef BOOL (__stdcall * PFNSHGETDISKFREESPACEA)(LPCSTR pszVolume, ULARGE_INTEGER *pqwFreeCaller, ULARGE_INTEGER *pqwTot, 
                                                  ULARGE_INTEGER *pqwFree);

HRESULT _ComputeFreeSpace(LPCWSTR pszFileName, ULONGLONG& ullFreeSpace,
        ULONGLONG& ullUsedSpace, ULONGLONG& ullTotalSpace)
{
    ULARGE_INTEGER qwFreeCaller;        // use this for free space -- this will take into account disk quotas and such on NT
    ULARGE_INTEGER qwTotal;
    ULARGE_INTEGER qwFree;      // unused
    CHAR szFileNameA[MAX_PATH];

    static PFNSHGETDISKFREESPACEA pfnSHGetDiskFreeSpaceA = NULL;
    
    SHUnicodeToAnsi(pszFileName, szFileNameA, MAX_PATH);

    // Load the function the first time
    if (pfnSHGetDiskFreeSpaceA == NULL)
    {
        HINSTANCE hinstShell32 = LoadLibrary(TEXT("SHELL32.DLL"));

        if (hinstShell32)
            pfnSHGetDiskFreeSpaceA = (PFNSHGETDISKFREESPACEA)GetProcAddress(hinstShell32, "SHGetDiskFreeSpaceA");
    }

    // Compute free & total space and check for valid results.
    // If you have a function pointer call SHGetDiskFreeSpaceA
    if (pfnSHGetDiskFreeSpaceA && pfnSHGetDiskFreeSpaceA(szFileNameA, &qwFreeCaller, &qwTotal, &qwFree))
    {
        ullFreeSpace = qwFreeCaller.QuadPart;
        ullTotalSpace = qwTotal.QuadPart;
        ullUsedSpace = ullTotalSpace - ullFreeSpace;

        if (EVAL((ullTotalSpace > 0) && (ullFreeSpace <= ullTotalSpace)))
            return S_OK;
    }
    return E_FAIL;
}


//--------------- Win95 Wraps for W versions of functions used by ATL -----// 
//-------------------------------------------------------------------------//
#ifdef wsprintfWrapW
#undef wsprintfWrapW
#endif //wsprintfWrapW
int WINAPIV wsprintfWrapW(OUT LPWSTR pwszOut, IN LPCWSTR pwszFormat, ...)
{
    int     cchRet;
    va_list arglist;
    
    va_start( arglist, pwszFormat );
    cchRet = wvsprintfWrapW( pwszOut, pwszFormat, arglist );
    va_end( arglist );

    return cchRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\webvw.inc ===
CCSHELL_DIR     = $(PROJECT_ROOT)

USE_STATIC_ATL  = 1

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

NO_BROWSER_FILE = 1

C_DEFINES       = $(C_DEFINES) -D_USRDLL

!if $(IA64)
# We are hitting a "error C1076: compiler limit : internal heap limit reached" on
# ia64 builds. Are we really using *that* much heap? Dosen't seem right...
MSC_OPTIMIZATION=/Zm200
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\webvw.cpp ===
// webvw.cpp : Main Web View File
// contains implementation of DLL Exports; debug info, etc.
#include "priv.h"
#include "wvcoord.h"
#include "fldricon.h"
#define DECL_CRTFREE
#include <crtfree.h>

STDAPI RegisterStuff(HINSTANCE hinstWebvw);

// from install.cpp
HRESULT SetFileAndFolderAttribs(HINSTANCE hInstResource);

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_WebView,                 CComObject<CWebViewCoord>) // W2K
    OBJECT_ENTRY(CLSID_WebViewOld,              CComObject<CWebViewCoord>) // W2K
    OBJECT_ENTRY(CLSID_ThumbCtl,                CComObject<CThumbCtl>) // W2K
    OBJECT_ENTRY(CLSID_ThumbCtlOld,             CComObject<CThumbCtl>) // W2K
    OBJECT_ENTRY(CLSID_WebViewFolderIcon,       CComObject<CWebViewFolderIcon>) // W2K
    OBJECT_ENTRY(CLSID_WebViewFolderIconOld,    CComObject<CWebViewFolderIcon>) // W2K
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
#ifdef DEBUG
        CcshellGetDebugFlags();
#endif
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
        SHFusionInitializeFromModule(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

typedef int (* PFNLOADSTRING) (HINSTANCE, UINT, LPTSTR, int);

// This is used so we aren't forced to call MLLoadString
int NonMLLoadString(HINSTANCE hinst, UINT uID, LPTSTR psz, int cch)
{
    static PFNLOADSTRING s_pfn = (PFNLOADSTRING)-1;

    if (s_pfn == (PFNLOADSTRING)-1)
    {
        s_pfn = (PFNLOADSTRING) GetProcAddress(GetModuleHandle(TEXT("USER32.DLL")), "LoadStringW");
    }

    if (s_pfn)
    {
        return s_pfn(hinst, uID, psz, cch);
    }

    return 0;
}

HRESULT ConvertDefaultWallpaper(void)
{
    HRESULT hr;

    if (!IsOS(OS_WOW6432))
    {
        hr = E_OUTOFMEMORY;

        // We convert the default wallpaper (default.jpg) to a .bmp since user can't handle .jpg's and
        // we don't want to force Active Desktop on.
        TCHAR szPathSrc[MAX_PATH];
        TCHAR szPathDest[MAX_PATH];


        if (GetWindowsDirectory(szPathSrc, ARRAYSIZE(szPathSrc)))
        {
            int cchCopied;
            TCHAR szDisplayName[MAX_PATH];
            UINT uID;

            // we have different default wallpaper files for per vs. pro vs. server
            if (IsOS(OS_ANYSERVER))
            {
                uID = IDS_WALLPAPER_LOCNAME_SRV;
            }
            else if (IsOS(OS_PERSONAL))
            {
                uID = IDS_WALLPAPER_LOCNAME_PER;
            }
            else
            {
                // use the professional wallpaper
                uID = IDS_WALLPAPER_LOCNAME;
            }

            // we want to call the non-MUI loadstring function here since the wallpaper is a file on disk that is always localized
            // in the system default local, not whatever the current users local is
            cchCopied = NonMLLoadString(_Module.GetResourceInstance(), uID, szDisplayName, ARRAYSIZE(szDisplayName));

            if (cchCopied)
            {
                PathAppend(szPathSrc, TEXT("Web\\Wallpaper\\"));

                StrCpyN(szPathDest, szPathSrc, ARRAYSIZE(szPathDest));
                PathAppend(szPathSrc, TEXT("default.jpg"));
                PathAppend(szPathDest, szDisplayName);
                StrCatBuff(szPathDest, TEXT(".bmp"), ARRAYSIZE(szPathDest));

                if (PathFileExists(szPathSrc))
                {
                    hr = SHConvertGraphicsFile(szPathSrc, szPathDest, SHCGF_REPLACEFILE);
                    if (SUCCEEDED(hr))
                    {
                        DeleteFile(szPathSrc);
                    }
                }
                else
                {
                    hr = S_OK;
                }
            }

        }
    }
    else
    {
        // don't try to convert the wallpaper if we are wow6432 since the 64 bit guy already
        // did it for us and if we try it will end up deleting it!!
        hr = S_OK;
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // setup attribs on system files/folders
    HRESULT hrRet = SetFileAndFolderAttribs(_Module.GetResourceInstance());

    TCHAR szWinPath[MAX_PATH];
    GetWindowsDirectory(szWinPath, ARRAYSIZE(szWinPath));

    struct _ATL_REGMAP_ENTRY regMap[] =
    {
        {OLESTR("windir"), szWinPath}, // subsitute %windir% for registry
        {0, 0}
    };

    HRESULT hr = RegisterStuff(_Module.GetResourceInstance());
    if (SUCCEEDED(hrRet))
    {
        hrRet = hr;
    }

    ConvertDefaultWallpaper();

    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer(TRUE);

    return SUCCEEDED(hrRet) ? hr : hrRet;
}

STDAPI DllInstall(BOOL fInstall, LPCWSTR pszCmdLine)
{
    HRESULT hr = E_FAIL;    

    if (pszCmdLine)
    {
        ASSERTMSG(StrStrIW(pszCmdLine, L"/RES=") == NULL, "webvw!DllInstall : passed old MUI command (no longer supported)");
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    _Module.UnregisterServer();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\wvcoord.h ===
// wvcoord.h : Declaration of the CWebViewCoord

#ifndef __WEBVIEWCOORD_H_
#define __WEBVIEWCOORD_H_

#include "dxmplay.h"
#include "resource.h"       // main symbols
#include "evtsink.h"
#include "mshtml.h"
#include "mshtmdid.h"

EXTERN_C const CLSID CLSID_WebViewOld;  // retired from service

extern HRESULT FindObjectStyle(IUnknown *punkObject, CComPtr<IHTMLStyle>& spStyle);
extern BOOL IsRTLDocument(CComPtr<IHTMLDocument2>& spHTMLElement);

class CThumbNailWrapper;
class CFileListWrapper;

/////////////////////////////////////////////////////////////////////////////
// CWebViewCoord
class ATL_NO_VTABLE CWebViewCoord :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CWebViewCoord, &CLSID_WebView>,
    public IDispatchImpl<IWebView, &IID_IWebView, &LIBID_WEBVWLib>,
    public IObjectSafetyImpl<CWebViewCoord, INTERFACESAFE_FOR_UNTRUSTED_CALLER>,
    public IObjectWithSiteImpl<CWebViewCoord>
{
public:
    CWebViewCoord();
    ~CWebViewCoord();

DECLARE_REGISTRY_RESOURCEID(IDR_WEBVIEWCOORD)

BEGIN_COM_MAP(CWebViewCoord) 
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IWebView)
    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL(IObjectWithSite)
END_COM_MAP()

    // IObjectWithSite overrides
    STDMETHOD(SetSite)(IUnknown *pClientSite);

private:
    //
    // Initialization helpers (including event sinks)
    //

    HRESULT InitFolderObjects(VOID);

    //
    // CDispatchEventSink overrides
    //

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr);

    // IWebView methods
    STDMETHOD(OnCSCClick)();
    STDMETHOD(CSCSynchronize)();
    STDMETHOD(OnCSCMouseOver)();
    STDMETHOD(OnCSCMouseOut)();

    
    //
    // Event handlers
    //

    STDMETHOD(OnWindowLoad)(VOID);
    STDMETHOD(OnWindowUnLoad)(VOID);
    STDMETHOD(OnFixSize)(VOID);

private:    
    HRESULT ReleaseFolderObjects(VOID);

    // security
    HRESULT _IsSafe()
    {
        return (0==m_dwCurrentSafety) ? S_OK : IsSafePage(m_spClientSite);
    };

    //
    // Objects in web view
    //
    
    CFileListWrapper  *m_pFileListWrapper;
    CThumbNailWrapper *m_pThumbNailWrapper;


    //
    // Host HTML window Dispatch
    //
    IDispatch * m_pdispWindow;
    
    //
    // Some frequently used interfaces
    //

    CComPtr<IHTMLDocument2>             m_spDocument;
    CComPtr<IHTMLElementCollection>     m_spDocAll;
    CComPtr<IHTMLControlElement>        m_spDocBody;
    CComPtr<IHTMLStyle>                 m_spFileListStyle;
    CComPtr<IHTMLStyle>                 m_spPanelStyle;
    CComPtr<IHTMLStyle>                 m_spRuleStyle;
    CComPtr<IHTMLStyle>                 m_spHeadingStyle;
    CComPtr<IHTMLElement>               m_spHeading;
    CComPtr<IOleClientSite>             m_spClientSite;

    //
    // Event sink advise cookies
    //

    DWORD           m_dwFileListAdviseCookie;   
    DWORD           m_dwThumbNailAdviseCookie;
    DWORD           m_dwHtmlWindowAdviseCookie;
    DWORD           m_dwCSCHotTrackCookie;
    BOOL            m_bRTLDocument;

};


/////////////////////////////////////////////////////////////////////////////
// CThumbNailWrapper

class CThumbNailWrapper : public CDispatchEventSink {
  public:       
    CThumbNailWrapper();
    ~CThumbNailWrapper();

    //
    // Initialization
    //

    HRESULT Init(CComPtr<IThumbCtl>         spThumbNailCtl,
                 CComPtr<IHTMLElement>      spThumbnailLabel);

    //
    // CDispatchEventSink overrides
    //

    STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
        LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
        EXCEPINFO* pexcepinfo, UINT* puArgErr);


    //
    // Event Handlers
    //

    HRESULT OnThumbNailReady(VOID);

    //
    // Cover for properties
    //

    HRESULT UsedSpace(CComBSTR &bstrUsed);
    HRESULT TotalSpace(CComBSTR &bstrTotal);
    HRESULT FreeSpace(CComBSTR &bstrFree);

    CComPtr<IThumbCtl> Control(VOID)  {return m_spThumbNailCtl;};

    //
    // Methods
    //
    
    BOOL UpdateThumbNail(CComPtr<FolderItem> spFolderItems);
    HRESULT SetDisplay(CComBSTR &bstrDisplay);
    HRESULT SetHeight(int iHeight);
    HRESULT ClearThumbNail();

private:
    HRESULT _SetThumbnailLabel(CComBSTR& bstrLabel);

    // Pointer to the control + style
    CComPtr<IThumbCtl>      m_spThumbNailCtl;
    CComPtr<IHTMLElement>   m_spThumbnailLabel;
    CComPtr<IHTMLStyle>     m_spThumbNailStyle;
};

/////////////////////////////////////////////////////////////////////////////
// CFileListWrapper

class CFileListWrapper : public CDispatchEventSink {
public:
    CFileListWrapper();
    ~CFileListWrapper();

    // Initialization
    HRESULT Init(CComPtr<IShellFolderViewDual> spFileList,
                 CComPtr<IHTMLElement>         spInfo,
                 CComPtr<IHTMLElement>         spLinks,
                 CComPtr<IHTMLStyle>           spPanelStyle,
                 CComPtr<IHTMLElement>         spMediaPlayerSpan,
                 CComPtr<IHTMLElement>         spCSCPlusMin,
                 CComPtr<IHTMLElement>         spCSCText,
                 CComPtr<IHTMLElement>         spCSCDetail,
                 CComPtr<IHTMLElement>         spCSCButton,
                 CComPtr<IHTMLStyle>           spCSCStyle,
                 CComPtr<IHTMLStyle>           spCSCDetailStyle,
                 CComPtr<IHTMLStyle>           spCSCButtonStyle,
                 CComPtr<IHTMLDocument2>       spDocument,
                 CComPtr<IHTMLWindow2>         spWindow,
                 CThumbNailWrapper             *pThumbNailWrapper);
    
    // CDispatchEventSink overrides
    STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr);

    // Event Handlers
    HRESULT OnSelectionChanged(VOID);

    // Cover function for properties
    CComPtr<IShellFolderViewDual> Control(VOID) {return m_spFileList;};

    HRESULT SetDefaultPanelDisplay();
    HRESULT OnCSCClick();
    HRESULT CSCSynchronize();
    HRESULT OnCSCMouseOnOff(BOOL fOn);

    // Needs to be called by WVCoord, so public
    HRESULT AdviseWebviewLinks( BOOL fAdvise );

private:
    //
    // Object pointers
    //

    CComPtr<IShellFolderViewDual>     m_spFileList;
    CComPtr<IHTMLElement>             m_spInfo;
    CComPtr<IHTMLElement>             m_spLinks;
    CComPtr<IHTMLStyle>               m_spPanelStyle;
    CComPtr<IMediaPlayer>             m_spIMediaPlayer;
    CComPtr<IHTMLElement>             m_spMediaPlayerSpan;
    CComPtr<IHTMLStyle>               m_spMediaPlayerStyle;
    CComPtr<IHTMLElement>             m_spCSCPlusMin;
    CComPtr<IHTMLElement>             m_spCSCText;
    CComPtr<IHTMLElement>             m_spCSCDetail;
    CComPtr<IHTMLElement>             m_spCSCButton;
    CComPtr<IHTMLStyle>               m_spCSCStyle;
    CComPtr<IHTMLStyle>               m_spCSCDetailStyle;
    CComPtr<IHTMLStyle>               m_spCSCButtonStyle;
    CComPtr<IHTMLDocument2>           m_spDocument;
    CComPtr<IHTMLWindow2>             m_spWindow;
    CThumbNailWrapper                 *m_pThumbNailWrapper;
    CComPtr<Folder2>                  m_spFolder2;
    CComPtr<FolderItem>               m_spFolderItem;
    CComPtr<FolderItem2>              m_spFolderItem2;
    CComPtr<FolderItems>              m_spFolderItems;
    CComBSTR                          m_bstrInfoHTML;
    CComBSTR                          m_bstrCrossLinksHTML;
    BOOL                              m_bFoundAuthor;
    BOOL                              m_bFoundComment;
    BOOL                              m_bCSCDisplayed;
    BOOL                              m_bNeverGotPanelInfo;
    BOOL                              m_bExpanded;
    BOOL                              m_bHotTracked;
    DWORD                             m_dwDateFlags;
    BOOL                              m_bRTLDocument;
    BOOL                              m_bPathIsSlow;

    //
    // Helper functions
    //
    HRESULT ClearThumbNail();
    HRESULT StopMediaPlayer();
    HRESULT ClearMediaPlayer();
    HRESULT NoneSelected();
    HRESULT MultipleSelected(long cSelection);
    HRESULT OneSelected();
    HRESULT GetItemNameForDisplay();
    HRESULT GetItemType();
    HRESULT GetItemDateTime();
    HRESULT GetItemSize();
    HRESULT GetItemAttributes();
    HRESULT GetItemAuthor();
    HRESULT GetItemComment();
    HRESULT GetItemHTMLInfoTip();
    HRESULT GetOtherItemDetails();
    HRESULT GetItemInfoTip();
    HRESULT DealWithDriveInfo();
    HRESULT GetCrossLink(int nFolder, UINT uIDToolTip);
    HRESULT GetCrossLinks();
    HRESULT FormatCrossLink(LPCWSTR pwszDisplayName, LPCWSTR pwszUrlPath, UINT uIDToolTip);
    HRESULT DisplayInfoHTML();
    HRESULT DisplayCrossLinksHTML();
    HRESULT GetItemInfo(long lResId, LPWSTR wszInfoDescCanonical, CComBSTR& bstrInfoDesc, CComBSTR& bstrInfo);
    HRESULT IsItThisFolder(int nFolder, BOOL& bResult, LPWSTR pwszDisplayName, DWORD cchDisplayName, LPWSTR pwszPath, DWORD cchPath);
    HRESULT GetIMediaPlayer(CComPtr<IMediaPlayer>& spIMediaPlayer);
    // CSC functions
    HRESULT CSCGetStatusText(LONG lStatus, CComBSTR& bstrCSCText);
    HRESULT CSCGetStatusDetail(LONG lStatus, CComBSTR& bstrCSCDetail);
    HRESULT CSCGetStatusButton(LONG lStatus, CComBSTR& bstrCSCButton);
    HRESULT GetCSCFolderStatus(LONG* plStatus);
    HRESULT CSCShowStatusInfo();
    HRESULT CSCShowStatus_FoldExpand_Toggle();
    // Event handlers for setting status bar text
    HRESULT OnWebviewLinkEvent( BOOL fEnter );
    HRESULT GetEventAnchorElement(IHTMLEventObj *pEvent, IHTMLElement **ppElt);
    HRESULT GetWVLinksCollection( IHTMLElementCollection **ppCollection, long *pcLinks );
};


#endif //__WEBVIEWCOORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\winres.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1997 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINUSER.H and COMMCTRL.H

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, off)
#endif

#define VS_VERSION_INFO     1

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#ifndef WINVER
#define WINVER 0x0400   // default to Windows Version 4.0
#endif

#include <winresrc.h>

#ifdef _MAC
#define DS_WINDOWSUI    0x8000L
#endif

// operation messages sent to DLGINIT
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#ifdef IDC_STATIC
#undef IDC_STATIC
#endif
#define IDC_STATIC      (-1)

#ifdef _AFX_MINREBUILD
#pragma component(minrebuild, on)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\wvcoord.cpp ===
// wvcoord.cpp : Implementation of CWebViewCoord

#include "priv.h"
#include "wvcoord.h"

const CLSID CLSID_WebViewOld = {0x7a707490,0x260a,0x11d1,{0x83,0xdf,0x00,0xa0,0xc9,0x0d,0xc8,0x49}};    // retired from service, so made private

/////////////////////////////////////////////////////////////////////////////
// CWebViewCoord
/////////////////////////////////////////////////////////////////////////////

CWebViewCoord::CWebViewCoord()
{
    m_pFileListWrapper = NULL;
    m_pThumbNailWrapper = NULL;
    m_pdispWindow = NULL;
    
    m_dwFileListAdviseCookie  = 0;
    m_dwThumbNailAdviseCookie = 0;
    m_dwHtmlWindowAdviseCookie = 0;
    m_dwCSCHotTrackCookie = 0;
}

CWebViewCoord::~CWebViewCoord()
{
    ReleaseFolderObjects();
}

STDMETHODIMP CWebViewCoord::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, 
                      WORD wFlags, DISPPARAMS *pDispParams, 
                      VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
                      UINT *puArgErr)
{
    HRESULT hr = S_OK;

    switch (dispidMember)
    {
        case DISPID_HTMLWINDOWEVENTS_ONLOAD:
            hr = OnWindowLoad();
            break;

        case DISPID_HTMLWINDOWEVENTS_ONUNLOAD:
            hr = OnWindowUnLoad();
            break;

        case DISPID_HTMLWINDOWEVENTS_ONRESIZE:
            hr = OnFixSize();
            break;

        case DISPID_EVMETH_ONMOUSEOVER:
            hr = OnCSCMouseOver();
            break;

        case DISPID_EVMETH_ONMOUSEOUT:
            hr = OnCSCMouseOut();
            break;

        case DISPID_EVMETH_ONKEYPRESS:
        case DISPID_EVMETH_ONCLICK:
            hr = OnCSCClick();
            break;

        default:
            hr = IDispatchImpl<IWebView, &IID_IWebView, &LIBID_WEBVWLib>::
                    Invoke(dispidMember, riid, lcid, wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
            break;
    }
    return hr;  
}

STDMETHODIMP CWebViewCoord::OnCSCClick()
{
    HRESULT hres = S_OK;
    
    if (S_OK != _IsSafe())
    {
        hres = E_ACCESSDENIED;
    }
    else
    {
        if (m_pFileListWrapper)
        {
            hres = m_pFileListWrapper->OnCSCClick();
        }
    }
    return hres;
}

STDMETHODIMP CWebViewCoord::OnCSCMouseOver()
{
    HRESULT hres = S_OK;

    if (S_OK != _IsSafe())
    {
        hres = E_ACCESSDENIED;
    }
    else
    {
        if (m_pFileListWrapper)
        {
            hres = m_pFileListWrapper->OnCSCMouseOnOff(TRUE);
        }
    }
    return hres;

}

STDMETHODIMP CWebViewCoord::OnCSCMouseOut()
{
    HRESULT hres = S_OK;

    if (S_OK != _IsSafe())
    {
        hres = E_ACCESSDENIED;
    }
    else
    {
        if (m_pFileListWrapper)
        {
            hres = m_pFileListWrapper->OnCSCMouseOnOff(FALSE);
        }
    }
    return hres;

}

STDMETHODIMP CWebViewCoord::CSCSynchronize()
{
    HRESULT hres = S_OK;

    if (S_OK != _IsSafe())
    {
        hres = E_ACCESSDENIED;
    }
    else
    {
        if (m_pFileListWrapper)
        {
            hres = m_pFileListWrapper->CSCSynchronize();
        }
    }
    return hres;
}

STDMETHODIMP CWebViewCoord::SetSite(IUnknown *punkSite)
{
    HRESULT hr;

    if (punkSite == NULL && m_pdispWindow)
    {
        DisconnectHtmlEvents(m_pdispWindow, m_dwHtmlWindowAdviseCookie); 
        m_dwHtmlWindowAdviseCookie = 0;
    }        

    hr = IObjectWithSiteImpl<CWebViewCoord>::SetSite(punkSite);

    m_spClientSite = NULL; // Release client site pointer
    ReleaseFolderObjects();

    if (punkSite != NULL && SUCCEEDED(hr))
    {
        hr = punkSite->QueryInterface(IID_IOleClientSite, (void **)&m_spClientSite);
        if (SUCCEEDED(hr))
        {
            hr = ConnectHtmlEvents(this, m_spClientSite, &m_pdispWindow, &m_dwHtmlWindowAdviseCookie);
        }
    } 

    return hr;
}

HRESULT CWebViewCoord::InitFolderObjects() 
{
    HRESULT                             hr;
    CComPtr<IOleContainer>              spContainer;
    CComPtr<IDispatch>                  spdispItem;
    CComVariant                         vEmpty;
    CComPtr<IThumbCtl>                  spThumbNail;
    CComPtr<IHTMLElement>               spElement;
    CComPtr<IHTMLElement>               spInfo;
    CComPtr<IHTMLElement>               spLinks;
    CComPtr<IHTMLElement>               spMediaPlayerSpan;
    CComPtr<IShellFolderViewDual>       spFileList;
    CComPtr<IHTMLElement>               spCSCPlusMin;
    CComPtr<IHTMLElement>               spCSCText;
    CComPtr<IHTMLElement>               spCSCDetail;
    CComPtr<IHTMLElement>               spCSCButton;
    CComPtr<IHTMLStyle>                 spCSCStyle;
    CComPtr<IHTMLStyle>                 spCSCDetailStyle;
    CComPtr<IHTMLStyle>                 spCSCButtonStyle;
    CComPtr<IHTMLWindow2>               spWindow;

    // Get some document level objects

    IfFailRet(m_spClientSite->GetContainer(&spContainer));
    IfFailRet(spContainer->QueryInterface(IID_IHTMLDocument2, (void **)&m_spDocument));
    IfFailRet(IUnknown_QueryService(m_spClientSite, SID_SHTMLWindow, IID_IHTMLWindow2, (LPVOID*)&spWindow));
    IfFailRet(m_spDocument->get_all(&m_spDocAll));

    hr = m_spDocument->get_body(&spElement);
    if (SUCCEEDED(hr))
    {
        spElement->QueryInterface(IID_IHTMLControlElement, (void **)&m_spDocBody);
    }

    //
    // Init Info
    //

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("Info")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spInfo);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("Links")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spLinks);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("MediaPlayerSpan")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spMediaPlayerSpan);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("panel")), vEmpty, &spdispItem)) && spdispItem)
    {
        FindObjectStyle(spdispItem, m_spPanelStyle);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSC")), vEmpty, &spdispItem)) && spdispItem)
    {
        FindObjectStyle(spdispItem, spCSCStyle);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCHotTrack")), vEmpty, &spdispItem)) && spdispItem)
    {
        //
        // Set up sink for CSC UI notifications to implement hot tracking and expand/collapse
        //
        AtlAdvise(spdispItem, GetUnknown(), IID_IDispatch, &m_dwCSCHotTrackCookie);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCPlusMin")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spCSCPlusMin);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCText")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spCSCText);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCDetail")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spCSCDetail);
        FindObjectStyle(spdispItem, spCSCDetailStyle);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCButton")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&spCSCButton);
        FindObjectStyle(spdispItem, spCSCButtonStyle);
        spdispItem = NULL;
    }

    //
    // Init the thumbnail wrapper object
    //

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("ThumbNail")), vEmpty, &spdispItem)) && spdispItem)
    {
        if (SUCCEEDED(spdispItem->QueryInterface(IID_IThumbCtl, (void **)&spThumbNail)))
        {
            m_pThumbNailWrapper = new CThumbNailWrapper;

            if (m_pThumbNailWrapper == NULL)
            {
                return E_OUTOFMEMORY;
            }

            CComPtr<IDispatch>      spdispItem2;
            CComPtr<IHTMLElement>   spThumbnailLabel;
            if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("ThumbnailLabel")), vEmpty, &spdispItem2)) && spdispItem2)
            {
                spdispItem2->QueryInterface(IID_IHTMLElement, (void **)&spThumbnailLabel);
                spdispItem2 = NULL;
            }

            m_pThumbNailWrapper->Init(spThumbNail, spThumbnailLabel);

            AtlAdvise(spdispItem, m_pThumbNailWrapper, IID_IDispatch, &m_dwThumbNailAdviseCookie);
        }
        spdispItem = NULL;
    }
    
    //
    // Init the file list object
    //

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("Filelist")), vEmpty, &spdispItem)) && spdispItem)
    {
        if (SUCCEEDED(spdispItem->QueryInterface(IID_IShellFolderViewDual, (void **)&spFileList)))
        {
            m_pFileListWrapper = new CFileListWrapper;

            if (m_pFileListWrapper == NULL)
            {
                AtlUnadvise(spdispItem, IID_IDispatch, m_dwThumbNailAdviseCookie);
                m_dwThumbNailAdviseCookie = 0;
                delete m_pThumbNailWrapper;
                return E_OUTOFMEMORY;
            }
            m_pFileListWrapper->Init(spFileList, spInfo, spLinks, m_spPanelStyle, spMediaPlayerSpan,
                    spCSCPlusMin, spCSCText, spCSCDetail, spCSCButton, spCSCStyle,
                    spCSCDetailStyle, spCSCButtonStyle, m_spDocument, spWindow, m_pThumbNailWrapper);

            AtlAdvise(spdispItem, m_pFileListWrapper, IID_IDispatch, 
                      &m_dwFileListAdviseCookie);
        }
        spdispItem = NULL;
    }

    //
    // Init onsize properties
    //

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("Banner")), vEmpty, &spdispItem)) && spdispItem)
    {
        spdispItem->QueryInterface(IID_IHTMLElement, (void **)&m_spHeading);
        FindObjectStyle(spdispItem, m_spHeadingStyle);
        spdispItem = NULL;
    }

    m_bRTLDocument = IsRTLDocument(m_spDocument);

    if (!m_bRTLDocument && m_spPanelStyle)
    {
        m_spPanelStyle->put_overflow(OLESTR("auto"));
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("FileList")), vEmpty, &spdispItem)) && spdispItem)
    {
        FindObjectStyle(spdispItem, m_spFileListStyle);
        spdispItem = NULL;
    }

    if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("rule")), vEmpty, &spdispItem)) && spdispItem)
    {
        FindObjectStyle(spdispItem, m_spRuleStyle);
        spdispItem = NULL;
    }

    return S_OK;
}

HRESULT CWebViewCoord::ReleaseFolderObjects() 
{
    CComPtr<IDispatch> spdisp;

    //
    // Do the unadvise
    //

    if (m_dwCSCHotTrackCookie)
    {
        CComVariant vEmpty;
        if (SUCCEEDED(m_spDocAll->item(CComVariant(OLESTR("CSCHotTrack")), vEmpty, &spdisp)) && spdisp)
        {
            AtlUnadvise(spdisp, IID_IDispatch, m_dwCSCHotTrackCookie);
            m_dwCSCHotTrackCookie = 0;
            spdisp = NULL;
        }
    }

    if (m_dwFileListAdviseCookie != 0) {
        spdisp = m_pFileListWrapper->Control();
        if (spdisp != NULL) {
            AtlUnadvise(spdisp, IID_IDispatch, m_dwFileListAdviseCookie);
            m_dwFileListAdviseCookie = 0;
            spdisp = NULL;
        }
    }

    if (m_dwThumbNailAdviseCookie != 0) {
        spdisp = (IThumbCtl *)(m_pThumbNailWrapper->Control());
        if (spdisp != NULL) {
            AtlUnadvise(spdisp, IID_IDispatch, m_dwThumbNailAdviseCookie);
            m_dwThumbNailAdviseCookie = 0;
            spdisp = NULL;
        }    
    }

    //
    // Free the file list wrapper
    //

    if (m_pFileListWrapper != NULL) {
        // Need to unadvise from WV links before releasing
        m_pFileListWrapper->AdviseWebviewLinks( FALSE );
        m_pFileListWrapper->Release();
        m_pFileListWrapper = NULL;
    }

    if (m_pThumbNailWrapper != NULL) {
        m_pThumbNailWrapper->Release();
        m_pThumbNailWrapper = NULL;
    }

    //
    // Free any references we may have
    //

    m_spDocAll = NULL;
    m_spDocBody = NULL;
    m_spDocument = NULL;
    m_spFileListStyle = NULL;
    m_spHeading = NULL;
    m_spHeadingStyle = NULL;
    m_spPanelStyle = NULL;
    m_spRuleStyle = NULL;

    return S_OK;
}

HRESULT CWebViewCoord::OnWindowLoad() 
{
    HRESULT hr;

    ReleaseFolderObjects();
    InitFolderObjects();
    hr = OnFixSize();
    return hr;
}

HRESULT CWebViewCoord::OnWindowUnLoad() 
{
    return ReleaseFolderObjects();
}

HRESULT CWebViewCoord::OnFixSize() 
{
    HRESULT hr = S_OK;
    LONG    lClientWidth;

    if (m_spFileListStyle && m_spDocBody && SUCCEEDED(m_spDocBody->get_clientWidth(&lClientWidth)))
    {
        LONG lPanelWidth;
        if (!m_spPanelStyle || FAILED(m_spPanelStyle->get_pixelWidth(&lPanelWidth)))
        {
            lPanelWidth = 0;
        }

        CComBSTR bstrPanelVisibility;
        LONG lFileListLeft, lFileListWidth = -1;
        if (lClientWidth < (lPanelWidth * 2))
        {
            bstrPanelVisibility = OLESTR("hidden");
            lFileListLeft = 0;
        }
        else
        {
            bstrPanelVisibility = OLESTR("visible");
            if (m_bRTLDocument)
            {
                lFileListLeft = 0;
                lFileListWidth = lClientWidth - lPanelWidth;
                if (m_spPanelStyle)
                {
                    m_spPanelStyle->put_pixelLeft(lClientWidth - lPanelWidth);
                }
            }
            else
            {
                lFileListLeft = lPanelWidth;
            }
        }

        if (m_spPanelStyle)
        {
            m_spPanelStyle->put_visibility(bstrPanelVisibility);
        }
        m_spFileListStyle->put_pixelLeft(lFileListLeft);
        m_spFileListStyle->put_pixelWidth((lFileListWidth == -1) ?
                (lClientWidth - lFileListLeft) : lFileListWidth);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\wvguids.h ===
// wvguids.h : Instantiation of GUIDS used by WebView
 
#ifndef __WV_GUIDS_H_
#define __WV_GUIDS_H_

// {7A707490-260A-11D1-83DF-00A0C90DC849}
DEFINE_GUID(CLSID_WebViewCoord, 0x7a707490L, 0x260a, 0x11d1, 0x83, 0xdf, 0x00, 0xa0, 0xc9, 0x0d, 0xc8, 0x49);

#endif // __WV_GUIDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\wvguids.cpp ===
// wvguids.cpp : Instantiation of GUIDS used by WebView

#include "priv.h"

#define INITGUID
#include <initguid.h>

#include "wvguids.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\daytona.inc ===
# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)   \
              -DFLAT         \
              -DWIN32=100    \
              -D_NT1X_=100   \
              -DINC_OLE2     \
              -DNOEXCEPTIONS \
	      -DNASHVILLE    \
              $(TRACELOG)

!IF "$(ALMOSTRETAIL)"!="" && $(FREEBUILD)
C_DEFINES=    \
              $(C_DEFINES)          \
              -DDBGASSERT=1
!ENDIF

USE_MAPSYM=1

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1
# USE_MSVCRT=1
USE_NOLIBS = 1

MSC_WARNING_LEVEL=/W3 /WX

GPCH_BUILD=daytona
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\dll\makefile.inc ===
..\webvw.rc : $(PROJECT_ROOT)\lib\$(O)\webvw.tlb $(SELFREGNAME) $(MISCFILES)

	
!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\ext\webvw\wvmacros.h ===
#ifndef __WV_MACROS_H_
#define __WV_MACROS_H_

#define IfFailRet(hresult) {hr = (hresult); if (FAILED(hr)) return hr;}
#define IfFailGo(hresult) {hr = (hresult); if (FAILED(hr)) goto done;}

#define IfFalseRet(val, hr) {if ((val) == 0) return (hr);}

#endif // __WV_MACROS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\classf.h ===
//=--------------------------------------------------------------------------=
// ClassF.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// header for the ClassFactory Object.  we support IClassFactory and 
// IClassFactory2
//
#ifndef _CLASSF_H_

#include "olectl.h"

class CClassFactory : public IClassFactory2 {

  public:
    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)(void);
    STDMETHOD_(ULONG, Release)(void);

    // IClassFactory methods
    //
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void **ppbObjOut);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
    //
    STDMETHOD(GetLicInfo)(LICINFO *pLicInfo);
    STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR *pbstrKey);
    STDMETHOD(CreateInstanceLic)(IUnknown *pUnkOuter, IUnknown *pUnkReserved, REFIID riid, BSTR bstrKey, void **ppvObjOut);

    CClassFactory(int iIndex);
    ~CClassFactory();

  private:
    ULONG m_cRefs;
    int   m_iIndex;
};


// global variable for Locks on our DLL
//
extern LONG g_cLocks;

#define _CLASSF_H_
#endif // _CLASSF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\classf.cpp ===
//=--------------------------------------------------------------------------=
// ClassF.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the implementation of the ClassFactory object. we support 
// IClassFactory and IClassFactory2
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "ClassF.H"
#include "Globals.H"
#include "Unknown.H"                    // for CREATEFNOFOBJECT

//=--------------------------------------------------------------------------=
// private module level data
//=--------------------------------------------------------------------------=
//

// ASSERT and FAIL require this
//
SZTHISFILE

// private routines for this file
//
HRESULT   CreateOleObjectFromIndex(IUnknown *, int Index, void **, REFIID);

//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    int            - [in] index into our global table of objects for this guy
//
// Notes:
//
CClassFactory::CClassFactory
(
    int iIndex
)
: m_iIndex(iIndex)
{
    m_cRefs = 1;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CClassFactory
//=--------------------------------------------------------------------------=
// "Life levels all men.  Death reveals the eminent."
// - George Bernard Shaw (1856 - 1950)
//
// Notes:
//
CClassFactory::~CClassFactory ()
{
    ASSERT(m_cRefs == 0, "Object being deleted with refs!");
    return;
}

//=--------------------------------------------------------------------------=
// CClassFactory::QueryInterface
//=--------------------------------------------------------------------------=
// the user wants another interface.  we won't give 'em. very many.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CClassFactory::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    void *pv;

    CHECK_POINTER(ppvObjOut);

    // we support IUnknown, and the two CF interfaces
    //
    if (DO_GUIDS_MATCH(riid, IID_IClassFactory)) {
        pv = (void *)(IClassFactory *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IClassFactory2)) {
        pv = (void *)(IClassFactory2 *)this;
    } else if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        pv = (void *)(IUnknown *)this;
    } else {
        *ppvObjOut = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)pv)->AddRef();
    *ppvObjOut = pv;
    return S_OK;
}




//=--------------------------------------------------------------------------=
// CClassFactory::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CClassFactory::AddRef
(
    void
)
{
    return ++m_cRefs;
}

//=--------------------------------------------------------------------------=
// CClassFactory::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CClassFactory::Release
(
    void
)
{
    ASSERT(m_cRefs, "No Refs, and we're being released!");
    if(--m_cRefs)
        return m_cRefs;

    delete this;
    return 0;
}

//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstance
//=--------------------------------------------------------------------------=
// create an instance of some sort of object.
//
// Parameters:
//    IUnknown *        - [in]  controlling IUknonwn for aggregation
//    REFIID            - [in]  interface id for new object
//    void **           - [out] pointer to new interface object.
//
// Output:
//    HRESULT           - S_OK, E_NOINTERFACE, E_UNEXPECTED,
//                        E_OUTOFMEMORY, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstance
(
    IUnknown *pUnkOuter,
    REFIID    riid,
    void    **ppvObjOut
)
{
    // check args
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // check to see if we've done our licensing work.  we do this as late
    // as possible that people calling CreateInstanceLic don't suffer from
    // a performance hit here.
    //
    // crit sect this for apartment threading, since it's global
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fCheckedForLicense) {
        g_fMachineHasLicense = CheckForLicense();
        g_fCheckedForLicense = TRUE;
    }
    LeaveCriticalSection(&g_CriticalSection);

    // check to see if they have the appropriate license to create this stuff
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    // try to create one of the objects that we support
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CClassFactory::LockServer
//=--------------------------------------------------------------------------=
// lock the server so we can't unload
//
// Parameters:
//    BOOL        - [in] TRUE means addref, false means release lock count.
//
// Output:
//    HRESULT     - S_OK, E_FAIL, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP CClassFactory::LockServer
(
    BOOL fLock
)
{
    // update the lock count.  crit sect these in case of another thread.
    //
    if (fLock)  
        InterlockedIncrement(&g_cLocks);
    else {
        ASSERT(g_cLocks, "D'oh! Lock Counting Problem");
        InterlockedDecrement(&g_cLocks);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CClassFactory::GetLicInfo
//=--------------------------------------------------------------------------=
// IClassFactory2 GetLicInfo
//
// Parameters:
//    LICINFO *          - unclear
//
// Output:
//    HRESULT            - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::GetLicInfo
(
    LICINFO *pLicInfo
)
{
    CHECK_POINTER(pLicInfo);

    pLicInfo->cbLicInfo = sizeof(LICINFO);

    // This says whether RequestLicKey will work
    //
    pLicInfo->fRuntimeKeyAvail = g_fMachineHasLicense;

    // This says whether the standard CreateInstance will work
    //
    pLicInfo->fLicVerified = g_fMachineHasLicense;

    return S_OK;
}


//=--------------------------------------------------------------------------=
// CClassFactory::RequestLicKey
//=--------------------------------------------------------------------------=
// IClassFactory2 RequestLicKey
//
// Parameters:
//    DWORD             - [in]  reserved
//    BSTR *            - [out] unclear
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::RequestLicKey
(
    DWORD  dwReserved,
    BSTR  *pbstr
)
{
    // if the machine isn't licensed, then we're not about to give this to them !
    //
    if (!g_fMachineHasLicense)
        return CLASS_E_NOTLICENSED;

    *pbstr = GetLicenseKey();
    return (*pbstr) ? S_OK : E_OUTOFMEMORY;
}


//=--------------------------------------------------------------------------=
// CClassFactory::CreateInstanceLic
//=--------------------------------------------------------------------------=
// create a new instance given a licensing key, etc ...
//
// Parameters:
//    IUnknown *        - [in]  controlling IUnknown for aggregation
//    IUnknown *        - [in]  reserved, must be NULL
//    REFIID            - [in]  IID We're looking for.
//    BSTR              - [in]  license key
//    void **           - [out] where to put the new object.
//
// Output:
//    HRESULT           - unclear
//
// Notes:
//
STDMETHODIMP CClassFactory::CreateInstanceLic
(
    IUnknown *pUnkOuter,
    IUnknown *pUnkReserved,
    REFIID    riid,
    BSTR      bstrKey,
    void    **ppvObjOut
)
{
    *ppvObjOut = NULL;

    // go and see if the key they gave us matches.
    //
    if (!CheckLicenseKey(bstrKey))
        return CLASS_E_NOTLICENSED;

    // if it does, then go and create the object.
    //
    return CreateOleObjectFromIndex(pUnkOuter, m_iIndex, ppvObjOut, riid);
}

//=--------------------------------------------------------------------------=
// CreateOleObjectFromIndex
//=--------------------------------------------------------------------------=
// given an index in our object table, create an object from it.
//
// Parameters:
//    IUnknown *       - [in]  Controlling Unknown, if any, for aggregation
//    int              - [in]  index into our global table
//    void **          - [out] where to put resulting object.
//    REFIID           - [in]  the interface they want resulting object to be.
//
// Output:
//    HRESULT          - S_OK, E_OUTOFMEMORY, E_NOINTERFACE
//
// Notes:
//
HRESULT CreateOleObjectFromIndex
(
    IUnknown *pUnkOuter,
    int       iIndex,
    void    **ppvObjOut,
    REFIID    riid
)
{
    IUnknown *pUnk = NULL;
    HRESULT   hr;

    // go and create the object
    //
    ASSERT(CREATEFNOFOBJECT(iIndex), "All creatable objects must have creation fn!");
    pUnk = CREATEFNOFOBJECT(iIndex)(pUnkOuter);

    // sanity check and make sure the object actually got allocated.
    //
    RETURN_ON_NULLALLOC(pUnk);

    // make sure we support aggregation here properly -- if they gave us
    // a controlling unknown, then they -must- ask for IUnknown, and we'll
    // give them the private unknown the object gave us.
    //
    if (pUnkOuter) {
        if (!DO_GUIDS_MATCH(riid, IID_IUnknown)) {
            pUnk->Release();
            return E_INVALIDARG;
        }

        *ppvObjOut = (void *)pUnk;
        hr = S_OK;
    } else {

        // QI for whatever the user wants.
        //
        hr = pUnk->QueryInterface(riid, ppvObjOut);
        pUnk->Release();
        RETURN_ON_FAILURE(hr);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\autoobj.cpp ===
//=--------------------------------------------------------------------------=
// AutoObj.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown, dispatch and
// error info implementations for them.
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "Globals.H"
#include "Util.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// CAutomationObject::CAutomationObject
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    IUnknown *      - [in] controlling Unknown
//    int             - [in] the object type that we are
//    void *          - [in] the VTable of of the object we really are.
//
// Notes:
//
CAutomationObject::CAutomationObject 
(
    IUnknown *pUnkOuter,
    int   ObjType,
    void *pVTable,
	BOOL fExpandoEnabled
)
: CUnknownObject(pUnkOuter, pVTable), m_ObjectType (ObjType)
{
    m_fLoadedTypeInfo = FALSE;
	m_fExpandoEnabled = (BYTE)fExpandoEnabled;
	m_pexpando = NULL;
}


//=--------------------------------------------------------------------------=
// CAutomationObject::~CAutomationObject
//=--------------------------------------------------------------------------=
// "I have a rendezvous with Death, At some disputed barricade"
// - Alan Seeger (1888-1916)
//
// Notes:
//
CAutomationObject::~CAutomationObject ()
{
    // if we loaded up a type info, release our count on the globally stashed
    // type infos, and release if it becomes zero.
    //
    if (m_fLoadedTypeInfo) {

        // we have to crit sect this since it's possible to have more than
        // one thread partying with this object.
        //
        EnterCriticalSection(&g_CriticalSection);
        ASSERT(CTYPEINFOOFOBJECT(m_ObjectType), "Bogus ref counting on the Type Infos");
        CTYPEINFOOFOBJECT(m_ObjectType)--;

        // if we're the last one, free it!
        //
        if (!CTYPEINFOOFOBJECT(m_ObjectType)) {
            PTYPEINFOOFOBJECT(m_ObjectType)->Release();
            PTYPEINFOOFOBJECT(m_ObjectType) = NULL;
        }
        LeaveCriticalSection(&g_CriticalSection);
    }

	if (m_pexpando)
	{
		delete m_pexpando;
	}
    return;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// the controlling unknown will call this for us in the case where they're
// looking for a specific interface.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CAutomationObject::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    ASSERT(ppvObjOut, "controlling Unknown should be checking this!");

    // start looking for the guids we support, namely IDispatch, and 
    // IDispatchEx

    if (DO_GUIDS_MATCH(riid, IID_IDispatch)) {
		// If expando functionality is enabled, attempt to allocate an
		// expando object and return that for the IDispatch interface.
		// If the allocation fails, we will fall back on using the regular
		// IDispatch from m_pvInterface;
		if (m_fExpandoEnabled)
		{
			if (!m_pexpando)
				m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);  

			if (m_pexpando)
			{
				*ppvObjOut = (void*)(IDispatch*) m_pexpando;
				((IUnknown *)(*ppvObjOut))->AddRef();
				return S_OK;
			}
		}

        *ppvObjOut = (void*) (IDispatch*) m_pvInterface;
        ((IUnknown *)(*ppvObjOut))->AddRef();
        return S_OK;
    }
    else if (DO_GUIDS_MATCH(riid, IID_IDispatchEx) && m_fExpandoEnabled) {
		// Allocate the expando object if it hasn't been allocated already
		if (!m_pexpando)
			m_pexpando = new CExpandoObject(m_pUnkOuter, (IDispatch*) m_pvInterface);  

		// If the allocation succeeded, return the IDispatchEx interface from
		// the expando.  Otherwise fall through to CUnknownObject::InternalQueryInterface,
		// (which will most likely fail)
		if (m_pexpando)
		{
			 *ppvObjOut = (void *)(IDispatchEx *) m_pexpando;
			((IUnknown *)(*ppvObjOut))->AddRef();
			return S_OK;
		}
    }

    // just get our parent class to process it from here on out.
    //
    return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfoCount
//=--------------------------------------------------------------------------=
// returns the number of type information interfaces that the object provides
//
// Parameters:
//    UINT *            - [out] the number of interfaces supported.
//
// Output:
//    HRESULT           - S_OK, E_NOTIMPL, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfoCount
(
    UINT *pctinfo
)
{
    // arg checking
    //
    if (!pctinfo)
        return E_INVALIDARG;

    // we support GetTypeInfo, so we need to return the count here.
    //
    *pctinfo = 1;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetTypeInfo
//=--------------------------------------------------------------------------=
// Retrieves a type information object, which can be used to get the type
// information for an interface.
//
// Parameters:
//    UINT              - [in]  the type information they'll want returned
//    LCID              - [in]  the LCID of the type info we want
//    ITypeInfo **      - [out] the new type info object.
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, etc.
//
// Notes:
//
STDMETHODIMP CAutomationObject::GetTypeInfo
(
    UINT        itinfo,
    LCID        lcid,
    ITypeInfo **ppTypeInfoOut
)
{
    DWORD       dwPathLen;
    char        szDllPath[MAX_PATH];
    HRESULT     hr;
    ITypeLib   *pTypeLib;
    ITypeInfo **ppTypeInfo =NULL;

    // arg checking
    //
    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (!ppTypeInfoOut)
        return E_POINTER;

    *ppTypeInfoOut = NULL;

    // ppTypeInfo will point to our global holder for this particular
    // type info.  if it's null, then we have to load it up. if it's not
    // NULL, then it's already loaded, and we're happy.
    // crit sect this entire nightmare so we're okay with multiple
    // threads trying to use this object.
    //
    EnterCriticalSection(&g_CriticalSection);
    ppTypeInfo = PPTYPEINFOOFOBJECT(m_ObjectType);

    if (*ppTypeInfo == NULL) {

        ITypeInfo *pTypeInfoTmp;
        HREFTYPE   hrefType;

        // we don't have the type info around, so go load it.
        //
        hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                            LANG_NEUTRAL, &pTypeLib);

        // if, for some reason, we failed to load the type library this
        // way, we're going to try and load the type library directly out of
        // our resources.  this has the advantage of going and re-setting all
        // the registry information again for us.
        //
        if (FAILED(hr)) {

            dwPathLen = GetModuleFileName(g_hInstance, szDllPath, MAX_PATH);
            if (!dwPathLen) {
                hr = E_FAIL;
                goto CleanUp;
            }

            MAKE_WIDEPTR_FROMANSI(pwsz, szDllPath);
            hr = LoadTypeLib(pwsz, &pTypeLib);
            CLEANUP_ON_FAILURE(hr);
        }

        // we've got the Type Library now, so get the type info for the interface
        // we're interested in.
        //
        hr = pTypeLib->GetTypeInfoOfGuid((REFIID)INTERFACEOFOBJECT(m_ObjectType), &pTypeInfoTmp);
        pTypeLib->Release();
        CLEANUP_ON_FAILURE(hr);

        // the following couple of lines of code are to dereference the dual
        // interface stuff and take us right to the dispatch portion of the
        // interfaces.
        //
        hr = pTypeInfoTmp->GetRefTypeOfImplType(0xffffffff, &hrefType);
        if (FAILED(hr)) {
            pTypeInfoTmp->Release();
            goto CleanUp;
        }

        hr = pTypeInfoTmp->GetRefTypeInfo(hrefType, ppTypeInfo);
        pTypeInfoTmp->Release();
        CLEANUP_ON_FAILURE(hr);

        // add an extra reference to this object.  if it ever becomes zero, then
        // we need to release it ourselves.  crit sect this since more than
        // one thread can party on this object.
        //
        CTYPEINFOOFOBJECT(m_ObjectType)++;
        m_fLoadedTypeInfo = TRUE;
    }


    // we still have to go and addref the Type info object, however, so that
    // the people using it can release it.
    //
    (*ppTypeInfo)->AddRef();
    *ppTypeInfoOut = *ppTypeInfo;
    hr = S_OK;

  CleanUp:
    LeaveCriticalSection(&g_CriticalSection);
    return hr;
}



//=--------------------------------------------------------------------------=
// CAutomationObject::GetIDsOfNames
//=--------------------------------------------------------------------------=
// Maps a single member and an optional set of argument names to a
// corresponding set of integer DISPIDs
//
// Parameters:
//    REFIID            - [in]  must be IID_NULL
//    OLECHAR **        - [in]  array of names to map.
//    UINT              - [in]  count of names in the array.
//    LCID              - [in]  LCID on which to operate
//    DISPID *          - [in]  place to put the corresponding DISPIDs.
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY, DISP_E_UNKNOWNNAME,
//                        DISP_E_UNKNOWNLCID
//
// Notes:
//    - we're just going to use DispGetIDsOfNames to save us a lot of hassle,
//      and to let this superclass handle it.
//
STDMETHODIMP CAutomationObject::GetIDsOfNames
(
    REFIID    riid,
    OLECHAR **rgszNames,
    UINT      cNames,
    LCID      lcid,
    DISPID   *rgdispid
)
{
    HRESULT     hr;
    ITypeInfo  *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get the type info for this dude!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // use the standard provided routines to do all the work for us.
    //
    hr = pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    pTypeInfo->Release();

    return hr;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::Invoke
//=--------------------------------------------------------------------------=
// provides access to the properties and methods on this object.
//
// Parameters:
//    DISPID            - [in]  identifies the member we're working with.
//    REFIID            - [in]  must be IID_NULL.
//    LCID              - [in]  language we're working under
//    USHORT            - [in]  flags, propput, get, method, etc ...
//    DISPPARAMS *      - [in]  array of arguments.
//    VARIANT *         - [out] where to put result, or NULL if they don't care.
//    EXCEPINFO *       - [out] filled in in case of exception
//    UINT *            - [out] where the first argument with an error is.
//
// Output:
//    HRESULT           - tonnes of them.
//
// Notes:
//    
STDMETHODIMP CAutomationObject::Invoke
(
    DISPID      dispid,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS *pdispparams,
    VARIANT    *pvarResult,
    EXCEPINFO  *pexcepinfo,
    UINT       *puArgErr
)
{
    HRESULT    hr;
    ITypeInfo *pTypeInfo;

    if (!DO_GUIDS_MATCH(riid, IID_NULL))
        return E_INVALIDARG;

    // get our typeinfo first!
    //
    hr = GetTypeInfo(0, lcid, &pTypeInfo);
    RETURN_ON_FAILURE(hr);

    // Clear exceptions
    //
    SetErrorInfo(0L, NULL);

    // This is exactly what DispInvoke does--so skip the overhead.
    //
    hr = pTypeInfo->Invoke(m_pvInterface, dispid, wFlags,
                           pdispparams, pvarResult,
                           pexcepinfo, puArgErr);
    pTypeInfo->Release();

	return hr;

}

//=--------------------------------------------------------------------------=
// CAutomationObject::Exception
//=--------------------------------------------------------------------------=
// fills in the rich error info object so that both our vtable bound interfaces
// and calls through ITypeInfo::Invoke get the right error informaiton.
//
// Parameters:
//    HRESULT          - [in] the SCODE that should be associated with this err
//    WORD             - [in] the RESOURCE ID of the error message.
//    DWORD            - [in] helpcontextid for the error
//
// Output:
//    HRESULT          - the HRESULT that was passed in.
//
// Notes:
//
HRESULT CAutomationObject::Exception
(
    HRESULT hrExcep,
    WORD    idException,
    DWORD   dwHelpContextID
)
{
    ICreateErrorInfo *pCreateErrorInfo;
    IErrorInfo *pErrorInfo;
    WCHAR   wszTmp[256];
    char    szTmp[256];
    HRESULT hr;


    // first get the createerrorinfo object.
    //
    hr = CreateErrorInfo(&pCreateErrorInfo);
    if (FAILED(hr)) return hrExcep;

    MAKE_WIDEPTR_FROMANSI(wszHelpFile, HELPFILEOFOBJECT(m_ObjectType));

    // set up some default information on it.
    //
    pCreateErrorInfo->SetGUID((REFIID)INTERFACEOFOBJECT(m_ObjectType));
    pCreateErrorInfo->SetHelpFile(wszHelpFile);
    pCreateErrorInfo->SetHelpContext(dwHelpContextID);

    // load in the actual error string value.  max of 256.
    //
    LoadString(GetResourceHandle(), idException, szTmp, 256);
    MultiByteToWideChar(CP_ACP, 0, szTmp, -1, wszTmp, 256);
    pCreateErrorInfo->SetDescription(wszTmp);

    // load in the source
    //
    MultiByteToWideChar(CP_ACP, 0, NAMEOFOBJECT(m_ObjectType), -1, wszTmp, 256);
    pCreateErrorInfo->SetSource(wszTmp);

    // now set the Error info up with the system
    //
    hr = pCreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pErrorInfo);
    CLEANUP_ON_FAILURE(hr);

    SetErrorInfo(0, pErrorInfo);
    pErrorInfo->Release();

  CleanUp:
    pCreateErrorInfo->Release();
    return hrExcep;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::InterfaceSupportsErrorInfo
//=--------------------------------------------------------------------------=
// indicates whether or not the given interface supports rich error information
//
// Parameters:
//    REFIID        - [in] the interface we want the answer for.
//
// Output:
//    HRESULT       - S_OK = Yes, S_FALSE = No.
//
// Notes:
//
HRESULT CAutomationObject::InterfaceSupportsErrorInfo
(
    REFIID riid
)
{
    // see if it's the interface for the type of object that we are.
    //
    if (riid == (REFIID)INTERFACEOFOBJECT(m_ObjectType))
        return S_OK;

    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// CAutomationObject::GetResourceHandle    [helper]
//=--------------------------------------------------------------------------=
// virtual routine to get the resource handle.  virtual, so that inheriting
// objects, such as COleControl can use theirs instead, which goes and gets
// the Host's version ...
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CAutomationObject::GetResourceHandle
(
    void
)
{
    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ctlhelp.h ===
//=--------------------------------------------------------------------------=
// CtlHelp.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// routines to help out our implementation of COleControl.
//

#ifndef _CTLHELP_H_

//=--------------------------------------------------------------------------=
// these two tables are used to get information on sizes about data types
// the first is used mostly in persistence, while the second is used for
// events
//
extern const BYTE g_rgcbDataTypeSize [];
extern const BYTE g_rgcbPromotedDataTypeSize [];



//=--------------------------------------------------------------------------=
// misc functions
//
short       _SpecialKeyState(void);
void WINAPI CopyAndAddRefObject(void *, const void *, DWORD);
void WINAPI CopyOleVerb(void *, const void *, DWORD);

HWND        CreateReflectWindow(BOOL fVisible, HWND hwndParent, int, int, SIZEL *);
void        CleanupReflection();

//=--------------------------------------------------------------------------=
// little private guid we'll use to help identify our objects
// {00D97180-FCF7-11ce-A09E-00AA0062BE57}
//
#define Data1_IControlPrv	0xd97180

DEFINE_GUID(IID_IControlPrv, 0xd97180, 0xfcf7, 0x11ce, 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57);

#define _CTLHELP_H_
#endif // _CTLHELP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ctlembed.cpp ===
//=--------------------------------------------------------------------------=
// CtlEmbed.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the interfaces required for inplace activation for
// COleControl
//

#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Globals.H"
#include "StdEnum.H"
#include "Util.H"

// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// all controls support the following in-place verbs at an absolute minimum.
//
#define CINPLACEVERBS 4

const VERBINFO rgInPlaceVerbs [] = {
    { OLEIVERB_SHOW,            0, 0, 0},
    { OLEIVERB_HIDE,            0, 0, 0},
    { OLEIVERB_INPLACEACTIVATE, 0, 0, 0},
    { OLEIVERB_PRIMARY,         0, 0, 0}
};

// NOTE: Resource ID for Properties string must be 1000
//
const VERBINFO ovProperties =
    { CTLIVERB_PROPERTIES, 1000, 0, OLEVERBATTRIB_ONCONTAINERMENU };

const VERBINFO ovUIActivate =
    { OLEIVERB_UIACTIVATE, 0, 0, 0};


//=--------------------------------------------------------------------------=
// COleControl::GetControlInfo    (IOleControl)
//=--------------------------------------------------------------------------=
// returns some information on a control, such as an accelerator table, and
// flags.  really used for keyboard handling and mnemonics
//
// Parameters:
//    CONTROLINFO *        - [in]  where to put said information
//
// Output:
//    HRESULT              - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetControlInfo
(
    CONTROLINFO *pControlInfo
)
{
    CHECK_POINTER(pControlInfo);

    // certain hosts have a bug in which it doesn't initialize the cb in the
    // CONTROLINFO structure, so we can only assert on that here.
    //
    ASSERT(pControlInfo->cb == sizeof(CONTROLINFO), "Host doesn't initialize CONTROLINFO structure");

    // NOTE: control writers should override this routine if they want to
    // return accelerator information in their control.
    //
    pControlInfo->hAccel = NULL;
    pControlInfo->cAccel = NULL;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnMnemonic    [IOleControl]
//=--------------------------------------------------------------------------=
// the container has decided to pass on a key that the end-user has pressed to
// us.  default implementation will be to just activate the control.  people
// looking for more functionality should override this method.
//
// Parameters:
//    LPMSG                - [in] message for this mnemonic
//
// Output:
//    HRESULT              - S_OK, E_POINTER
//
// Notes:
//
STDMETHODIMP COleControl::OnMnemonic
(
    LPMSG pMsg
)
{
    // OVERRIDE: default implementation is to just activate our control.  
    // user can override if they want more interesting behaviour.
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl:OnAmbientPropertyChange    [IOleControl]
//=--------------------------------------------------------------------------=
// a container calls this whenever it changes an ambient property.
//
// Parameters:
//    DISPID            - [in] dispid of the property that changed.
//
// Output:
//    HRESULT           - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnAmbientPropertyChange
(
    DISPID dispid
)
{
    // if we're being told about a change in mode [design/run] then
    // remember that so our stashing of mode will update itself
    // correctly
    //
    if (dispid == DISPID_AMBIENT_USERMODE || dispid == DISPID_UNKNOWN)
        m_fModeFlagValid = FALSE;

    // just pass this on to the derived control and see if they want
    // to do anything with it.
    //
    AmbientPropertyChanged(dispid);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControL::FreezeEvents    [IOleControl]
//=--------------------------------------------------------------------------=
// allows a container to freeze all of a controls events.  when events are
// frozen, a control will not fire any of them.
//
// Parameters:
//    BOOL            - [in] TRUE means FREEZE, FALSE means THAW
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//    - we maintain an internal count of freezes versus thaws.
//
STDMETHODIMP COleControl::FreezeEvents
(
    BOOL fFreeze
)
{
    // OVERRIDE: by default, we don't care.  user can override if they want to.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// informs the embedded object [control] of it's client site [display
// location] within it's container
//
// Parameters:
//    IOleClientSite *        - [in] pointer to client site.
//
// Output:
//    HRESULT                 - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetClientSite
(
    IOleClientSite *pClientSite
)
{
    RELEASE_OBJECT(m_pClientSite);
    RELEASE_OBJECT(m_pControlSite);
    RELEASE_OBJECT(m_pSimpleFrameSite);

    // store away the new client site
    //
    m_pClientSite = pClientSite;

    // if we've actually got one, then get some other interfaces we want to keep
    // around, and keep a handle on it
    //
    if (m_pClientSite) {
        m_pClientSite->AddRef();
        m_pClientSite->QueryInterface(IID_IOleControlSite, (void **)&m_pControlSite);

        if (OLEMISCFLAGSOFCONTROL(m_ObjectType) & OLEMISC_SIMPLEFRAME)
            m_pClientSite->QueryInterface(IID_ISimpleFrameSite, (void **)&m_pSimpleFrameSite);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClientSite    [IOleObject]
//=--------------------------------------------------------------------------=
// obtains a pointer to the controls client site.
//
// Parameters:
//    IOleClientSite **        - [out]
//
// Output:
//    HRESULT                  - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::GetClientSite
(
    IOleClientSite **ppClientSite
)
{
    CHECK_POINTER(ppClientSite);

    *ppClientSite = m_pClientSite;
    ADDREF_OBJECT(*ppClientSite);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetHostNames    [IOleObject]
//=--------------------------------------------------------------------------=
// Provides the control with the name of its container application and the
// compound document in which it is embedded
//
// Parameters:
//    LPCOLESTR        - [in] name of container application
//    LPCOLESTR        - [in] name of container document
//
// Output:
//    HRESULT          - S_OK
//
// Notes:
//    - we don't care about this
//
STDMETHODIMP COleControl::SetHostNames
(
    LPCOLESTR szContainerApp,
    LPCOLESTR szContainerObject
)
{
    // we don't care about these
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Close    [IOleObject]
//=--------------------------------------------------------------------------=
// Changes the control from the running to the loaded state
//
// Parameters:
//    DWORD             - [in] indicates whether to save the object before closing
//
// Output:
//    HRESULT           - S_OK, OLE_E_PROMPTSAVECANCELLED
//
// Notes:
//
STDMETHODIMP COleControl::Close
(
    DWORD dwSaveOption
)
{
    HRESULT hr;

    if (m_fInPlaceActive) {
        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
    }

    // handle the save flag.
    //
    if ((dwSaveOption == OLECLOSE_SAVEIFDIRTY || dwSaveOption == OLECLOSE_PROMPTSAVE) && m_fDirty) {
        if (m_pClientSite) m_pClientSite->SaveObject();
        if (m_pOleAdviseHolder) m_pOleAdviseHolder->SendOnSave();
    }
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Notifies an object of its container's moniker, the object's own moniker
// relative to the container, or the object's full moniker
//
// Parameters:
//    DWORD                - [in] which moniker is being set
//    IMoniker *           - [in] the moniker
//
// Output:
//    HRESULT              - S_OK, E_FAIL
//
// Notes:
//    - we don't support monikers.
//
STDMETHODIMP COleControl::SetMoniker
(
    DWORD     dwWhichMoniker,
    IMoniker *pMoniker
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetMoniker    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a embedded object's moniker, which the caller can use to link to
// the object
//
// Parameters:
//    DWORD            - [in]  how it's assigned
//    DWORD            - [in]  which moniker
//    IMoniker **      - [out] duh.
//
// Output:
//    HRESULT          - E_NOTIMPL
//
// Notes:
//    - we don't support monikers
//
STDMETHODIMP COleControl::GetMoniker
(
    DWORD      dwAssign,
    DWORD      dwWhichMoniker,
    IMoniker **ppMonikerOut
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InitFromData    [IOleObject]
//=--------------------------------------------------------------------------=
// Initializes a newly created object with data from a specified data object,
// which can reside either in the same container or on the Clipboard
//
// Parameters:
//    IDataObject*    - [in] data object with the data
//    BOOL            - [in] how object is created
//    DWORD           - reserved
//
// Output:
//    HRESULT         - S_OK, S_FALSE, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't have data object support
//
STDMETHODIMP COleControl::InitFromData
(
    IDataObject *pDataObject,
    BOOL         fCreation,
    DWORD        dwReserved
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClipboardData    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves a data object containing the current contents of the control.
// Using the pointer to this data object, it is possible to create a new control
// with the same data as the original
//
// Parameters:
//    DWORD          - reserved
//    IDataObject ** - [out] data object for this control
//
// Output:
//    HREUSLT        - S_OK, E_NOTIMPL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::GetClipboardData
(
    DWORD         dwReserved,
    IDataObject **ppDataObject
)
{
    *ppDataObject = NULL;        // be a good neighbour
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::DoVerb    [IOleObject]
//=--------------------------------------------------------------------------=
// Requests an object to perform an action in response to an end-user's
// action.
//
// Parameters:
//    LONG             - [in]  verb to be performed
//    LPMSG            - [in]  event that invoked the verb
//    IOleClientSite * - [in]  the controls active client site
//    LONG             - [in]  reserved
//    HWND             - [in]  handle of window containing the object.
//    LPCRECT          - [in]  pointer to objects's display rectangle
//
// Output:
//    HRESULT          - S_OK, OLE_E_NOTINPLACEACTIVE, OLE_E_CANT_BINDTOSOURCE,
//                       DV_E_LINK, OLEOBJ_S_CANNOT_DOVERB_NOW, OLEOBJ_S_INVALIDHWND,
//                       OLEOBJ_E_NOVERBS, OLEOBJ_S_INVALIDVERB, MK_E_CONNECT,
//                       OLE_CLASSDIFF, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::DoVerb
(
    LONG            lVerb,
    LPMSG           pMsg,
    IOleClientSite *pActiveSite,
    LONG            lIndex,
    HWND            hwndParent,
    LPCRECT         prcPosRect
)
{
    HRESULT hr;

    switch (lVerb) {
      case OLEIVERB_SHOW:
      case OLEIVERB_INPLACEACTIVATE:
      case OLEIVERB_UIACTIVATE:
        hr = InPlaceActivate(lVerb);
        OnVerb(lVerb);
        return (hr);

      case OLEIVERB_HIDE:
        UIDeactivate();
        if (m_fInPlaceVisible) SetInPlaceVisible(FALSE);
        OnVerb(lVerb);
        return S_OK;

      // we used to have OLEIVERB_PRIMARY InPlaceActivate Ourselves, but it
      // turns out that the CDK and certain hosts expect this to show the
      // properties instead.  Users can change what this verb does at will.
      //
      case OLEIVERB_PRIMARY:
      case CTLIVERB_PROPERTIES:
      case OLEIVERB_PROPERTIES:
        {
        // show the frame ourselves if the hose can't.
        //
        if (m_pControlSite) {
            hr = m_pControlSite->ShowPropertyFrame();
            if (hr != E_NOTIMPL)
                return hr;
        }
        IUnknown *pUnk = (IUnknown *)(IOleObject *)this;
        MAKE_WIDEPTR_FROMANSI(pwsz, NAMEOFOBJECT(m_ObjectType));

        ModalDialog(TRUE);
        hr = OleCreatePropertyFrame(GetActiveWindow(),
                            GetSystemMetrics(SM_CXSCREEN) / 2,
                            GetSystemMetrics(SM_CYSCREEN) / 2,
                            pwsz,
                            1,
                            &pUnk,
                            CPROPPAGESOFCONTROL(m_ObjectType),
                            (LPCLSID)*(PPROPPAGESOFCONTROL(m_ObjectType)),
                            g_lcidLocale,
                            NULL, NULL);
        ModalDialog(FALSE);
        return hr;
        }

      default:
        // if it's a derived-control defined verb, pass it on to them
        //
        if (lVerb > 0) {
            hr = DoCustomVerb(lVerb);

            if (hr == OLEOBJ_S_INVALIDVERB) {
                // unrecognised verb -- just do the primary verb and
                // activate it.
                //
                hr = InPlaceActivate(OLEIVERB_PRIMARY);
                return (FAILED(hr)) ? hr : OLEOBJ_S_INVALIDVERB;
            } else
                return hr;
        } else {
            FAIL("Unrecognized Negative verb in DoVerb().  bad.");
            return E_NOTIMPL;
        }
        break;
    }

    // dead code
    FAIL("this should be dead code!");
}

//=--------------------------------------------------------------------------=
// COleControl::EnumVerbs    [IOleObject]
//=--------------------------------------------------------------------------=
// create an enumerator object for the verbs this object supports.
//
// Parameters:
//    IEnumOleVERB **    - [out] new enumerator.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::EnumVerbs
(
    IEnumOLEVERB **ppEnumVerbs
)
{
    int cVerbs;
    OLEVERB *rgVerbs, *pVerb;

    DWORD dw = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    BOOL fCanInPlace = !(dw & OLEMISC_INVISIBLEATRUNTIME) || (dw & OLEMISC_ACTIVATEWHENVISIBLE);
    BOOL fCanUIActivate = !(dw & OLEMISC_NOUIACTIVATE);
    BOOL fHasProperties = (CPROPPAGESOFCONTROL(m_ObjectType) != 0);

    int cVerbExtra = CCUSTOMVERBSOFCONTROL(m_ObjectType);

    // count up all the verbs
    //
    cVerbs = (fCanInPlace ? CINPLACEVERBS : 0) + (fCanUIActivate ? 1 : 0)
             + (fHasProperties ? 1 : 0) + cVerbExtra;

    // if there aren't any, this suddenly gets really easy !
    //
    if (cVerbs == 0)
        return OLEOBJ_E_NOVERBS;

    // HeapAlloc some storage for these dudes so that we can pass them on to
    // the standard enumerator!
    //
    if (! (rgVerbs = (OLEVERB *)HeapAlloc(g_hHeap, 0, cVerbs * sizeof(OLEVERB))))
        return E_OUTOFMEMORY;
  
    // start copying over verbs.  first, the in-place guys
    //
    pVerb = rgVerbs;
    if (fCanInPlace) {
        memcpy(pVerb, rgInPlaceVerbs, CINPLACEVERBS * sizeof(OLEVERB));
        pVerb += CINPLACEVERBS;
      }

    if (fCanUIActivate)
        memcpy(pVerb++, &ovUIActivate, sizeof(OLEVERB));

    // if their control has properties, copy that over now.
    //
    if (fHasProperties) {
        memcpy(pVerb, &ovProperties, sizeof(OLEVERB));
        pVerb++;
    }

    // finally, any custom verbs!
    //
    if (cVerbExtra) {
        memcpy(pVerb, CUSTOMVERBSOFCONTROL(m_ObjectType), sizeof(OLEVERB) * cVerbExtra);
    }

    *ppEnumVerbs = (IEnumOLEVERB *) (IEnumGeneric *) new CStandardEnum(IID_IEnumOLEVERB,
                                     cVerbs, sizeof(OLEVERB), rgVerbs, CopyOleVerb);
    if (!*ppEnumVerbs)
        return E_OUTOFMEMORY;

    // this forces us to go and look for the Localized DLLs.  This is necessary here
    // because the CopyOleVerb will get information from localized resources, but
    // will only use the global GetResourceHandle, which only uses the global value
    // for the LCID.  This turns out to not be a big performance hit, since this
    // function is typically only called in design mode, and we stash this value.
    //
    GetResourceHandle();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::Update    [IOleObject]
//=--------------------------------------------------------------------------=
// Updates an object handler's or link object's data or view caches.
//
// Output:
//    HRESULT            - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::Update
(
    void
)
{
    // nothing to do!!!
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::IsUpToDate    [IOleObject]
//=--------------------------------------------------------------------------=
// Checks recursively whether or not an object is up to date.
//
// Output:
//    HRESULT        - S_OK, S_FALSE, OLE_E_UNVAILABLE
//
// Notes:
//
STDMETHODIMP COleControl::IsUpToDate
(
    void
)
{
    // we're always up to date
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserClassID    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns the controls class identifier, the CLSID corresponding to the
// string identifying the object to an end user.
//
// Parameters:
//    CLSID *      - [in] where to put the CLSID
//
// Output:
//    HRESULT      - S_OK, E_FAIL
//
// Notes:
//
STDMETHODIMP COleControl::GetUserClassID
(
    CLSID *pclsid
)
{
    // this is the same as IPersist::GetClassID
    //
    return GetClassID(pclsid);
}

//=--------------------------------------------------------------------------=
// COleControl::GetUserType    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the user-type name of the control for display in user-interface
// elements such as menus, list boxes, and dialog boxes.
//
// Parameters:
//    DWORD        - [in]  specifies the form of the type name.
//    LPOLESTR *   - [out] where to put user type
//
// Output:
//    HRESULT      - S_OK, OLE_S_USEREG, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::GetUserType
(
    DWORD     dwFormOfType,
    LPOLESTR *ppszUserType
)
{
    *ppszUserType = OLESTRFROMANSI(NAMEOFOBJECT(m_ObjectType));
    return (*ppszUserType) ? S_OK : E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// COleControl::SetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Informs the control of how much display space its container has assigned it.
//
// Parameters:
//    DWORD            - [in] which form or 'aspect'  is to be displayed.
//    SIZEL *          - [in] size limit for the control.
//
// Output:
//    HRESULT          - S_OK, E_FAIL, OLE_E_NOTRUNNING
//
// Notes:
//
STDMETHODIMP COleControl::SetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *psizel
)
{
    SIZEL sl;
    RECT  rect;
    BOOL  f;

    if (dwDrawAspect & DVASPECT_CONTENT) {

        // change the units to pixels, and resize the control.
        //
        HiMetricToPixel(psizel, &sl);

        // first call the user version.  if they return FALSE, they want
        // to keep their current size
        //
        f = OnSetExtent(&sl);
        if (f)
            HiMetricToPixel(psizel, &m_Size);

        // set things up with our HWND if we've got one.
        //
        if (!m_pInPlaceSiteWndless) {
            if (m_fInPlaceActive) {
    
                // theoretically, one should not need to call OnPosRectChange
                // here, but there appear to be a few host related issues that
                // will make us keep it here.  we won't, however, both with
                // windowless ole controls, since they are all new hosts who
                // should know better
                //
                GetWindowRect(m_hwnd, &rect);
                MapWindowPoints(NULL, m_hwndParent, (LPPOINT)&rect, 2);
                rect.right = rect.left + m_Size.cx;
                rect.bottom = rect.top + m_Size.cy;
                m_pInPlaceSite->OnPosRectChange(&rect);
    
                if (m_hwnd) {
                    // just go and resize
                    //
                    if (m_hwndReflect)
                        SetWindowPos(m_hwndReflect, 0, 0, 0, m_Size.cx, m_Size.cy,
                                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
                    SetWindowPos(m_hwnd, 0, 0, 0, m_Size.cx, m_Size.cy,
                                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
                }
            } else if (m_hwnd) {
                SetWindowPos(m_hwnd, NULL, 0, 0, m_Size.cx, m_Size.cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
            } else {
                ViewChanged();
            }
        } else
            if (m_pInPlaceSite) m_pInPlaceSite->OnPosRectChange(&rect);

        // return code depending on whether or not user accepted given
        // size
        //
        return (f) ? S_OK : E_FAIL;

    } else {
        // we don't support any other aspects.
        //
        return DV_E_DVASPECT;
    }

    // dead code
    FAIL("This should be dead code");
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IOleObject]
//=--------------------------------------------------------------------------=
// Retrieves the control's current display size.
//
// Parameters:
//    DWORD            - [in] aspect
//    SIZEL *          - [in] where to put results
//
// Output:
//    S_OK, E_INVALIDARG
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD  dwDrawAspect,
    SIZEL *pSizeLOut
)
{

    if (dwDrawAspect & DVASPECT_CONTENT) {
        PixelToHiMetric((const SIZEL *)&m_Size, pSizeLOut);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::Advise    [IOleObject]
//=--------------------------------------------------------------------------=
// establishes and advisory connection between the control and the container,
// in which the control will notify the container of certain events.
//
// Parameters:
//    IAdviseSink *     - [in]  advise sink of calling object
//    DWORD             - [out] cookie
//
// Output:
//    HRESULT           - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP COleControl::Advise
(
    IAdviseSink *pAdviseSink,
    DWORD       *pdwConnection
)
{
    HRESULT hr;

    // if we haven't yet created a standard advise holder object, do so
    // now
    //
    if (!m_pOleAdviseHolder) {
        hr = CreateOleAdviseHolder(&m_pOleAdviseHolder);
        RETURN_ON_FAILURE(hr);
    }

    // just get it to do the work for us!
    //
    return m_pOleAdviseHolder->Advise(pAdviseSink, pdwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::Unadvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Deletes a previously established advisory connection.
//
// Parameters:
//    DWORD         - [in] connection cookie
//
// Output:
//    HRESULT       - S_OK, E_FAIL, OLE_E_NOCONNECTION
//
// Notes:
//
STDMETHODIMP COleControl::Unadvise
(
    DWORD dwConnection
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody called Unadvise on IOleObject without calling Advise!");
        CONNECT_E_NOCONNECTION;
    }

    return m_pOleAdviseHolder->Unadvise(dwConnection);
}

//=--------------------------------------------------------------------------=
// COleControl::EnumAdvise    [IOleObject]
//=--------------------------------------------------------------------------=
// Enumerates the advisory connections registered for an object, so a container
// can know what to release prior to closing down.
//
// Parameters:
//    IEnumSTATDATA **    - [out] where to put enumerator
//
// Output:
//    HRESULT             - S_OK, E_FAIL, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::EnumAdvise
(
    IEnumSTATDATA **ppEnumOut
)
{
    if (!m_pOleAdviseHolder) {
        FAIL("Somebody Called EnumAdvise without setting up any connections");
        *ppEnumOut = NULL;
        return E_FAIL;
    }

    return m_pOleAdviseHolder->EnumAdvise(ppEnumOut);
}

//=--------------------------------------------------------------------------=
// COleControl::GetMiscStatus    [IOleObject]
//=--------------------------------------------------------------------------=
// Returns a value indicating the status of an object at creation and loading.
//
// Parameters:
//    DWORD         - [in]  aspect desired
//    DWORD *       - [out] where to put the bits.
//
// Output:
//    HRESULT       - S_OK, OLE_S_USEREG, CO_E_CLASSNOTREG, CO_E_READREGDB
//
// Notes:
//
STDMETHODIMP COleControl::GetMiscStatus
(
    DWORD  dwAspect,
    DWORD *pdwStatus
)
{
    CHECK_POINTER(pdwStatus);

    if (dwAspect == DVASPECT_CONTENT) {
        *pdwStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
        return S_OK;
    } else {
        return DV_E_DVASPECT;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetColorScheme    [IOleObject]
//=--------------------------------------------------------------------------=
// Specifies the color palette that the object application should use when it
// edits the specified object.
//
// Parameters:
//    LOGPALETTE *     - [in] new palette
//
// Output:
//    HRESULT          - S_OK, E_NOTIMPL, OLE_E_PALETTE, OLE_E_NOTRUNNING
//
// Notes:
//    - we don't care.
//
STDMETHODIMP COleControl::SetColorScheme
(
    LOGPALETTE *pLogpal
)
{
    // OVERRIDE: control writers can use this if they want to
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetWindow    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Returns the window handle to one of the windows participating in in-place
// activation (frame, document, parent, or in-place object window).
//
// Parameters:
//    HWND *        - [out] where to return window handle.
//
// Output:
//    HRESULT       - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED, E_FAIL
//
// Notes:
//    - this routine has slightly different semantics for windowless controls
//
STDMETHODIMP COleControl::GetWindow
(
    HWND *phwnd
)
{
    // if we're windowles, then we want to return E_FAIL for this so hosts
    // know we're windowless
    //
    if (m_pInPlaceSiteWndless)
        return E_FAIL;

    // otherwise, just return our outer window.
    //
    *phwnd = GetOuterWindow();

    return (*phwnd) ? S_OK : E_UNEXPECTED;
}

//=--------------------------------------------------------------------------=
// COleControl::ContextSensitiveHelp    [IOleWindow/IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Determines whether context-sensitive help mode should be entered during an
// in-place activation session.
//
// Parameters:
//    BOOL            - [in] whether or not to enter help mode.
//
// Output:
//    HRESULT         - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::ContextSensitiveHelp
(
    BOOL fEnterMode
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceActivate
//=--------------------------------------------------------------------------=
// activates the control, and depending on the verb, optionally ui activates
// it as well.
//
// Parameters:
//    LONG         - [in] the verb that caused us to activate
//
// Output:
//    HRESULT
//
// Notes:
//    - this is spaghetti code at it's worst.  effectively, we have to
//      be able to handle three types of site pointers -- IOleInPlaceSIte,
//      IOleInPlaceSiteEx, and IOleInPlaceSiteWindowless.  not terribly
//      pretty.
//
HRESULT COleControl::InPlaceActivate
(
    LONG lVerb
)
{
    BOOL f;
    SIZEL sizel;
    IOleInPlaceSiteEx *pIPSEx = NULL;
    HRESULT hr;
    BOOL    fNoRedraw = FALSE;

    // if we don't have a client site, then there's not much to do.
    //
    if (!m_pClientSite)
        return S_OK;

    // get an InPlace site pointer.
    //
    if (!GetInPlaceSite()) {

        // if they want windowless support, then we want IOleInPlaceSiteWindowless
        //
        if (FCONTROLISWINDOWLESS(m_ObjectType))
            m_pClientSite->QueryInterface(IID_IOleInPlaceSiteWindowless, (void **)&m_pInPlaceSiteWndless);

        // if we're not able to do windowless siting, then we'll just get an
        // IOleInPlaceSite pointer.
        //
        if (!m_pInPlaceSiteWndless) {
            hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
            RETURN_ON_FAILURE(hr);
        }
    }

    // now, we want an IOleInPlaceSiteEx pointer for windowless and flicker free
    // activation.  if we're windowless, we've already got it, else we need to
    // try and get it
    //
    if (m_pInPlaceSiteWndless) {
        pIPSEx = (IOleInPlaceSiteEx *)m_pInPlaceSiteWndless;
        pIPSEx->AddRef();
    } else
        m_pClientSite->QueryInterface(IID_IOleInPlaceSiteEx, (void **)&pIPSEx);

    // if we're not already active, go and do it.
    //
    if (!m_fInPlaceActive) {
        OLEINPLACEFRAMEINFO InPlaceFrameInfo;
        RECT rcPos, rcClip;

        // if we have a windowless site, see if we can go in-place windowless
        // active
        //
        hr = S_FALSE;
        if (m_pInPlaceSiteWndless) {
            hr = m_pInPlaceSiteWndless->CanWindowlessActivate();
            CLEANUP_ON_FAILURE(hr);

            // if they refused windowless, we'll try windowed
            //
            if (S_OK != hr) {
                RELEASE_OBJECT(m_pInPlaceSiteWndless);
                hr = m_pClientSite->QueryInterface(IID_IOleInPlaceSite, (void **)&m_pInPlaceSite);
                CLEANUP_ON_FAILURE(hr);
            }
        }

        // just try regular windowed in-place activation
        //
        if (hr != S_OK) {
            hr = m_pInPlaceSite->CanInPlaceActivate();
            if (hr != S_OK) {
                hr = (FAILED(hr)) ? E_FAIL : hr;
                goto CleanUp;
            }
        }

        // if we are here, then we have permission to go in-place active.
        // now, announce our intentions to actually go ahead and do this.
        //
        hr = (pIPSEx) ? pIPSEx->OnInPlaceActivateEx(&fNoRedraw, (m_pInPlaceSiteWndless) ? ACTIVATE_WINDOWLESS : 0)
                       : m_pInPlaceSite->OnInPlaceActivate();
        CLEANUP_ON_FAILURE(hr);

        // if we're here, we're ready to go in-place active.  we just need
        // to set up some flags, and then create the window [if we have
        // one]
        //
        m_fInPlaceActive = TRUE;

        // we need to get some information about our location in the parent
        // window, as well as some information about the parent
        //
        InPlaceFrameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);
        hr = GetInPlaceSite()->GetWindow(&m_hwndParent);
        if (SUCCEEDED(hr))
            hr = GetInPlaceSite()->GetWindowContext(&m_pInPlaceFrame, &m_pInPlaceUIWindow, &rcPos, &rcClip, &InPlaceFrameInfo);
        CLEANUP_ON_FAILURE(hr);

        // make sure we'll display ourselves in the correct location with the correct size
        //
        sizel.cx = rcPos.right - rcPos.left;
        sizel.cy = rcPos.bottom - rcPos.top;
        f = OnSetExtent(&sizel);
        if (f) m_Size = sizel;
        SetObjectRects(&rcPos, &rcClip);

        // finally, create our window if we have to!
        //
        if (!m_pInPlaceSiteWndless) {
    
            SetInPlaceParent(m_hwndParent);

            // create the window, and display it.  die horribly if we couldnt'
            //
            if (!CreateInPlaceWindow(rcPos.left, rcPos.top, fNoRedraw)) {
                hr = E_FAIL;
                goto CleanUp;
            }
        }
    }

    // don't need this any more
    //
    RELEASE_OBJECT(pIPSEx);

    // if we're not inplace visible yet, do so now.
    //
    if (!m_fInPlaceVisible)
        SetInPlaceVisible(TRUE);

    // if we weren't asked to UIActivate, then we're done.
    //
    if (lVerb != OLEIVERB_PRIMARY && lVerb != OLEIVERB_UIACTIVATE)
        return S_OK;

    // if we're not already UI active, do sow now.
    //
    if (!m_fUIActive) {
        m_fUIActive = TRUE;

        // inform the container of our intent
        //
        GetInPlaceSite()->OnUIActivate();

        // take the focus  [which is what UI Activation is all about !]
        //
        SetFocus(TRUE);

        // set ourselves up in the host.
        //
        m_pInPlaceFrame->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetActiveObject((IOleInPlaceActiveObject *)this, NULL);

        // we have to explicitly say we don't wany any border space.
        //
        m_pInPlaceFrame->SetBorderSpace(NULL);
        if (m_pInPlaceUIWindow)
            m_pInPlaceUIWindow->SetBorderSpace(NULL);
    }

    // be-de-be-de-be-de that's all folks!
    //
    return S_OK;

  CleanUp:
    // something catastrophic happened [or, at least something bad].
    // die a horrible fiery mangled painful death.
    //
    QUICK_RELEASE(pIPSEx);
    m_fInPlaceActive = FALSE;
    return hr;

}

//=--------------------------------------------------------------------------=
// COleControl::InPlaceDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Deactivates an active in-place object and discards the object's undo state.
//
// Output:
//    HRESULT        - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::InPlaceDeactivate
(
    void
)
{
    // if we're not in-place active yet, then this is easy.
    //
    if (!m_fInPlaceActive)
        return S_OK;

    // transition from UIActive back to active
    //
    if (m_fUIActive)
        UIDeactivate();

    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;

    // if we have a window, tell it to go away.
    //
    if (m_hwnd) {
        ASSERT(!m_pInPlaceSiteWndless, "internal state really messed up");

        // so our window proc doesn't crash.
        //
        BeforeDestroyWindow();
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;

        if (m_hwndReflect) {
            SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, 0);
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }
    }

    RELEASE_OBJECT(m_pInPlaceFrame);
    RELEASE_OBJECT(m_pInPlaceUIWindow);
    GetInPlaceSite()->OnInPlaceDeactivate();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::UIDeactivate    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// transitions us from UI Active to merely being active [visible]  for
// a control, this doesn't mean all that much.
//
// Output:
//    HRESULT         - S_OK, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::UIDeactivate
(
    void
)
{
    // if we're not UIActive, not much to do.
    //
    if (!m_fUIActive)
        return S_OK;

    m_fUIActive = FALSE;

    // notify frame windows, if appropriate, that we're no longer ui-active.
    //
    if (m_pInPlaceUIWindow) m_pInPlaceUIWindow->SetActiveObject(NULL, NULL);
    m_pInPlaceFrame->SetActiveObject(NULL, NULL);

    // we don't need to explicitly release the focus here since somebody
    // else grabbing the focus is what is likely to cause us to get lose it
    //
    GetInPlaceSite()->OnUIDeactivate(FALSE);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SetObjectRects    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Indicates how much of the control is visible.
//
// Parameters:
//    LPCRECT        - [in] position of the control.
//    LPCRECT        - [in] clipping rectangle for the control.
//
// Output:
//    HRESULT        - S_OK, E_INVALIDARG, E_OUTOFMEMORY, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::SetObjectRects
(
    LPCRECT prcPos,
    LPCRECT prcClip
)
{
    BOOL fRemoveWindowRgn;

    // move our window to the new location and handle clipping. not applicable
    // for windowless controls, since the container will be responsible for all
    // clipping.
    //
    if (m_hwnd) {
        fRemoveWindowRgn = m_fUsingWindowRgn;
        if (prcClip) {
            // the container wants us to clip, so figure out if we really
            // need to
            //
            RECT rcIXect;
            if ( IntersectRect(&rcIXect, prcPos, prcClip) ) {
                if (!EqualRect(&rcIXect, prcPos)) {
                    OffsetRect(&rcIXect, -(prcPos->left), -(prcPos->top));

                    HRGN tempRgn = CreateRectRgnIndirect(&rcIXect);
                    SetWindowRgn(GetOuterWindow(), tempRgn, TRUE);

                    if (m_hRgn != NULL)
                       DeleteObject(m_hRgn);
                    m_hRgn = tempRgn;

                    m_fUsingWindowRgn = TRUE;
                    fRemoveWindowRgn  = FALSE;
                }
            }
        }

        if (fRemoveWindowRgn) {
            SetWindowRgn(GetOuterWindow(), NULL, TRUE);
            if (m_hRgn != NULL)
            {
               DeleteObject(m_hRgn);
               m_hRgn = NULL;
            }
            m_fUsingWindowRgn = FALSE;
        }

        // set our control's location, but don't change it's size at all
        // [people for whom zooming is important should set that up here]
        //
        DWORD dwFlag;
        OnSetObjectRectsChangingWindowPos(&dwFlag);

        int cx, cy;
        cx = prcPos->right - prcPos->left;
        cy = prcPos->bottom - prcPos->top;
        SetWindowPos(GetOuterWindow(), NULL, prcPos->left, prcPos->top, cx, cy, dwFlag | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    // save out our current location.  windowless controls want this more
    // that windowed ones do, but everybody can have it just in case
    //
    m_rcLocation = *prcPos;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ReactivateAndUndo    [IOleInPlaceObject]
//=--------------------------------------------------------------------------=
// Reactivates a previously deactivated object, undoing the last state of the object.
//
// Output:
//    HRESULT        - S_OK, E_NOTUNDOABLE
//
// Notes:
//
STDMETHODIMP COleControl::ReactivateAndUndo
(
    void
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnWindowMessage    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method lets the container dispatch a message to a windowless OLE
// object.
//
// Parameters:
//    UINT                - [in]  the message
//    WPARAM              - [in]  the messages wparam
//    LPARAM              - [in]  duh.
//    LRESULT *           - [out] the output value
//
// Output:
//    HRESULT             - S_OK
//
// Notes:
//    - people should call m_pInPlaceSiteWndless->OnDefWindowMessage [control
//      writers should just call OcxDefWindowProc(msg, wparam, lparam)];
//
STDMETHODIMP COleControl::OnWindowMessage
(
    UINT     msg,
    WPARAM   wParam,
    LPARAM   lParam,
    LRESULT *plResult
)
{
    // little bit of pre-processing -- we need to handle some cases here
    // before passing the messages on
    //
    switch (msg) {
        // make sure our UI Activation correctly matches the focus
        //
        case WM_KILLFOCUS:
        case WM_SETFOCUS:
            // give the control site focus notification
            //
            if (m_fInPlaceActive && m_pControlSite)
                m_pControlSite->OnFocus(msg == WM_SETFOCUS);
            break;
    }

    // just pass it to the control's window proc.
    //
    *plResult = WindowProc(msg, wParam, lParam);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetDropTarget    [IOleInPlaceObjectWindowless]
//=--------------------------------------------------------------------------=
// this method returns a pointer to the objects IDropTarget interface.  since
// they do not have a window, windowless objects cannot register an IDropTarget
// interface.
//
// Parameters:
//    IDropTarget **        - [out]
//
// Output:
//    HRESULT               - S_OK, E_NOTIMPL
//
// Notes:
//
STDMETHODIMP COleControl::GetDropTarget
(
    IDropTarget **ppDropTarget
)
{
    // OVERRIDE: if you want to do drag and drop and you're windowless,
    // override me.
    //
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::TranslateAccelerator    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Processes menu accelerator-key messages from the container's message queue.
//
// Parameters:
//    LPMSG            - [in] the message that has the special key in it.
//
// Output:
//    HRESULT          - S_OK, S_FALSE, E_UNEXPECTED
//
// Notes:
//
STDMETHODIMP COleControl::TranslateAccelerator
(
    LPMSG    pmsg
)
{
    // see if we want it or not.
    //
    if (OnSpecialKey(pmsg))
        return S_OK;

    // if not, then we want to forward it back to the site for further processing
    //
    if (m_pControlSite)
        return m_pControlSite->TranslateAccelerator(pmsg, _SpecialKeyState());

    // we didn't want it.
    //
    return S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnFrameWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the control when the container's top-level frame window is
// activated or deactivated.
//
// Parameters:
//    BOOL        - [in] state of containers top level window.
//
// Output:
//    HRESULT     - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnFrameWindowActivate
(
    BOOL fActivate
)
{
    // we're supposed to go UI active in this case
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::OnDocWindowActivate    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Notifies the active control when the container's document window is
// activated or deactivated.
//
// Parameters:
//    BOOL            - state of mdi child window.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::OnDocWindowActivate
(
    BOOL fActivate
)
{
    // we're supposed to go UI active in this case
    //
    return InPlaceActivate(OLEIVERB_UIACTIVATE);
}

//=--------------------------------------------------------------------------=
// COleControl::ResizeBorder    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Alerts the control that it needs to resize its border space.
//
// Parameters:
//    LPCRECT               - [in] new outer rectangle for border space
//    IOleInPlaceUIWindow * - [in] the document or frame who's border has changed
//    BOOL                  - [in] true if it was the fram window taht called.
//
// Output:
//    HRESULT               - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::ResizeBorder
(
    LPCRECT              prcBorder,
    IOleInPlaceUIWindow *pInPlaceUIWindow,
    BOOL                 fFrame
)
{
    // this is largely uninteresting to us, since we have no border.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnableModeless    [IOleInPlaceActiveObject]
//=--------------------------------------------------------------------------=
// Enables or disables modeless dialog boxes when the container creates or
// destroys a modal dialog box.
//
// Parameters:
//    BOOL            - [in] enable or disable modeless dialogs.
//
// Output:
//    HRESULT         - S_OK
//
// Notes:
//
STDMETHODIMP COleControl::EnableModeless
(
    BOOL fEnable
)
{
    // phenomenally uninteresting
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassInfo    [IProvideClassInfo]
//=--------------------------------------------------------------------------=
// returns the TypeInfo for the control's coclass.
//
// Parameters:
//    ITypeInfo **        - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassInfo
(
    ITypeInfo **ppTypeInfo
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;

    CHECK_POINTER(ppTypeInfo);
    *ppTypeInfo = NULL;

    // go and get our type library.
    // CONSIDER: - go to the same sorta scheme that we use for TypeInfo caching.
    // CONSIDER: - consider trying to register our typelib if this fails.
    //
    hr = LoadRegTypeLib(*g_pLibid, (USHORT)VERSIONOFOBJECT(m_ObjectType), 0,
                        LANGIDFROMLCID(g_lcidLocale), &pTypeLib);
    RETURN_ON_FAILURE(hr);

    // got the typelib.  get typeinfo for our coclass.
    //
    hr = pTypeLib->GetTypeInfoOfGuid((REFIID)CLSIDOFOBJECT(m_ObjectType), ppTypeInfo);
    pTypeLib->Release();
    RETURN_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::ViewChange    [callable]
//=--------------------------------------------------------------------------=
// called whenever the view of the object has changed.
//
// Notes:
//
void COleControl::ViewChanged
(
    void
)
{
    // send the view change notification to anybody listening.
    //
    if (m_pViewAdviseSink) {
        m_pViewAdviseSink->OnViewChange(DVASPECT_CONTENT, -1);

        // if they only asked to be advised once, kill the connection
        //
        if (m_fViewAdviseOnlyOnce)
            SetAdvise(DVASPECT_CONTENT, 0, NULL);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceVisible    [helper]
//=--------------------------------------------------------------------------=
// controls the visibility of the control window.
//
// Parameters:
//    BOOL        - TRUE shows FALSE hides.
//
// Notes:
//
void COleControl::SetInPlaceVisible
(
    BOOL fShow
)
{
    BOOL fVisible;

    m_fInPlaceVisible = fShow;

    // don't do anything if we don't have a window.  otherwise, set it
    //
    if (m_hwnd) {
        fVisible = ((GetWindowLong(GetOuterWindow(), GWL_STYLE) & WS_VISIBLE) != 0);

        if (fVisible && !fShow)
            ShowWindow(GetOuterWindow(), SW_HIDE);
        else if (!fVisible && fShow)
            ShowWindow(GetOuterWindow(), SW_SHOWNA);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::AmbientPropertyChanged    [overridable]
//=--------------------------------------------------------------------------=
// a method that derived controls can override to do whatever they want.
// we don't particularily care about this event.
//
// Parameters:
//    DISPID            - [in] dispid of prop that changed.
//
// Notes:
//
void COleControl::AmbientPropertyChanged
(
    DISPID dispid
)
{
    // do nothing
}

//=--------------------------------------------------------------------------=
// COleControl::DoCustomVerb    [overridable]
//=--------------------------------------------------------------------------=
// we were asked to execute a verb we don't know about right away.  see if
// it's a verb that the dervied-control defined.
//
// Parameters:
//    LONG            - [in] the verb.
//
// Output:
//    HRESULT         - S_OK, OLEOBJ_S_INVALIDVERB
//
// Notes:
//
HRESULT COleControl::DoCustomVerb
(
    LONG    lVerb
)
{
    return OLEOBJ_S_INVALIDVERB;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetExtent    [overridable]
//=--------------------------------------------------------------------------=
// let the user do something in the resize, if they care.
//
// Parameters:
//    SIZEL *        - [in] new values.
//
// Output:
//    BOOL           - FALSE means keep current size
//
// Notes:
//
BOOL COleControl::OnSetExtent
(
    const SIZEL *pSizeL
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OnSpecialKey    [overridable]
//=--------------------------------------------------------------------------=
// allows controls to handle special keys such as arrows, CTRL+, etc ...
//
// Parameters:
//    LPMSG        - [in] the special key msg.
//
// Output:
//    BOOL         - TRUE we processed it, FALSE we didn't.
//
// Notes:
//
BOOL COleControl::OnSpecialKey
(
    LPMSG pmsg
)
{
    // do nothing.
    //
    return FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::ModalDialog    [callable, utility]
//=--------------------------------------------------------------------------=
// should be called when the control is about to show and hide a modal dialog.
//
// Parameters:
//    BOOL        - [in] true means showing a modal dialog, false means done
//
// Notes:
//
void COleControl::ModalDialog
(
    BOOL fShow
)
{
    // notify the container of our intention to show a modal dialog...
    //
    if (m_pInPlaceFrame)
        m_pInPlaceFrame->EnableModeless(!fShow);
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeDestroyWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we destroy a window.  gives the user the opportunity to
// save information out, especially if they're a subclassed control, and this
// is an interesting thing to do.
//
// Notes:
//
void COleControl::BeforeDestroyWindow
(
    void
)
{
    // fweeee
}

//=--------------------------------------------------------------------------=
// COleControl::OnSetObjectRectsChangingWIndowPos    [overridable]
//=--------------------------------------------------------------------------=
// called just before we perform a SetWindowPos in the SetObjectRects
// function. gives a control the opportunity to change the flags.
//
// Notes:
//
void COleControl::OnSetObjectRectsChangingWindowPos(DWORD *dwFlag)
{
    *dwFlag = 0;
}

void COleControl::OnVerb(LONG lVerb)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ctlhelp.cpp ===
//=--------------------------------------------------------------------------=
// CtlHelp.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// helper routines for our COleControl implementation
//

#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Util.H"
#include <windows.h>

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// this is used by the window reflection code.
//
extern BYTE g_fRegisteredReflect;
extern char g_szReflectClassName [];


// define this here, since it's the only guid we really need to define in the
// framework -- the user control defines all other interesting guids.
//
static const GUID IID_IControlPrv =
{ 0xd97180, 0xfcf7, 0x11ce, { 0xa0, 0x9e, 0x0, 0xaa, 0x0, 0x62, 0xbe, 0x57 } };


// this table is used for copying data around, and persisting properties.
// basically, it contains the size of a given data type
//
const BYTE g_rgcbDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(short),          // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(float),          // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(VARIANT_BOOL),   // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

const BYTE g_rgcbPromotedDataTypeSize[] = {
    0,                      // VT_EMPTY= 0,
    0,                      // VT_NULL= 1,
    sizeof(int ),           // VT_I2= 2,
    sizeof(long),           // VT_I4 = 3,
    sizeof(double),         // VT_R4  = 4,
    sizeof(double),         // VT_R8= 5,
    sizeof(CURRENCY),       // VT_CY= 6,
    sizeof(DATE),           // VT_DATE = 7,
    sizeof(BSTR),           // VT_BSTR = 8,
    sizeof(IDispatch *),    // VT_DISPATCH    = 9,
    sizeof(SCODE),          // VT_ERROR    = 10,
    sizeof(int),            // VT_BOOL    = 11,
    sizeof(VARIANT),        // VT_VARIANT= 12,
    sizeof(IUnknown *),     // VT_UNKNOWN= 13,
};

//=--------------------------------------------------------------------------=
// _SpecialKeyState
//=--------------------------------------------------------------------------=
// returns a short with some information on which of the SHIFT, ALT, and CTRL
// keys are set.
//
// Output:
//    short        - bit 0 is shift, bit 1 is ctrl, bit 2 is ALT.
//
// Notes:
//
short _SpecialKeyState()
{
    // don't appear to be able to reduce number of calls to GetKeyState
    //
    BOOL bShift = (GetKeyState(VK_SHIFT) < 0);
    BOOL bCtrl  = (GetKeyState(VK_CONTROL) < 0);
    BOOL bAlt   = (GetKeyState(VK_MENU) < 0);

    return (short)(bShift + (bCtrl << 1) + (bAlt << 2));
}


//=--------------------------------------------------------------------------=
// CopyAndAddRefObject
//=--------------------------------------------------------------------------=
// copies an object pointer, and then addref's the object.
//
// Parameters:
//    void *        - [in] dest.
//    const void *  - [in] src
//    DWORD         - [in] size, ignored, since it's always 4
//
// Notes:
//
void WINAPI CopyAndAddRefObject
(
    void       *pDest,
    const void *pSource,
    DWORD       dwSize
)
{
    ASSERT(pDest && pSource, "Bogus Pointer(s) passed into CopyAndAddRefObject!!!!");

    *((IUnknown **)pDest) = *((IUnknown **)pSource);
    ADDREF_OBJECT(*((IUnknown **)pDest));

    return;
}

//=--------------------------------------------------------------------------=
// CopyOleVerb    [helper]
//=--------------------------------------------------------------------------=
// copies an OLEVERB structure.  used in CStandardEnum
//
// Parameters:
//    void *        - [out] where to copy to
//    const void *  - [in]  where to copy from
//    DWORD         - [in]  bytes to copy
//
// Notes:
//
void WINAPI CopyOleVerb
(
    void       *pvDest,
    const void *pvSrc,
    DWORD       cbCopy
)
{
    VERBINFO * pVerbDest = (VERBINFO *) pvDest;
    const VERBINFO * pVerbSrc = (const VERBINFO *) pvSrc;

    *pVerbDest = *pVerbSrc;
    ((OLEVERB *)pVerbDest)->lpszVerbName = OLESTRFROMRESID((WORD)((VERBINFO *)pvSrc)->idVerbName);
}

//=--------------------------------------------------------------------------=
// ControlFromUnknown    [helper, callable]
//=--------------------------------------------------------------------------=
// given an unknown, get the COleControl pointer for it.
//
// Parameters:
//    IUnknown *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
COleControl *ControlFromUnknown
(
    IUnknown *pUnk
)
{
    COleControl *pCtl = NULL;

    if (!pUnk) return NULL;
    pUnk->QueryInterface(IID_IControlPrv, (void **)&pCtl);

    return pCtl;
}

//=--------------------------------------------------------------------------=
// CreateReflectWindow    [blech]
//=--------------------------------------------------------------------------=
// unfortunately, in certain cases, we have to create two windows, one of
// which exists strictly to reflect messages on to the control.
// Fortunately, the number of hosts which require this is quite small.
//
// Parameters:
//    BOOL        - [in] should it be created visible?
//    HWND        - [in] parent window
//    int         - [in] x pos
//    int         - [in] y pos
//    SIZEL *     - [in] size
//
// Output:
//    HWND        - reflecting hwnd or NULL if it failed.
//
// Notes:
//
HWND CreateReflectWindow
(
    BOOL   fVisible,
    HWND   hwndParent,
    int    x,
    int    y,
    SIZEL *pSize
)
{
    WNDCLASS wndclass;

    // first thing to do is register the window class.  crit sect this
    // so we don't have to move it into the control
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fRegisteredReflect) {

        memset(&wndclass, 0, sizeof(wndclass));
        wndclass.lpfnWndProc = COleControl::ReflectWindowProc;
        wndclass.hInstance   = g_hInstance;
        wndclass.lpszClassName = g_szReflectClassName;

        if (!RegisterClass(&wndclass)) {
            FAIL("Couldn't Register Parking Window Class!");
            LeaveCriticalSection(&g_CriticalSection);
            return NULL;
        }
        g_fRegisteredReflect = TRUE;
    }

    LeaveCriticalSection(&g_CriticalSection);

    // go and create the window.
    //
    return CreateWindowEx(0, g_szReflectClassName, NULL,
                          WS_CHILD | WS_CLIPSIBLINGS |((fVisible) ? WS_VISIBLE : 0),
                          x, y, pSize->cx, pSize->cy,
                          hwndParent,
                          NULL, g_hInstance, NULL);
}

//=--------------------------------------------------------------------------=
// in case the user doesn't want our default window proc, we support
// letting them specify one themselves. this is defined in their main ipserver
// file.
//
extern WNDPROC g_ParkingWindowProc;

//=--------------------------------------------------------------------------=
// GetParkingWindow
//=--------------------------------------------------------------------------=
// creates the global parking window that we'll use to parent things, or
// returns the already existing one
//
// Output:
//    HWND                - our parking window
//
// Notes:
//
HWND GetParkingWindow
(
    void
)
{
    WNDCLASS wndclass;

    // crit sect this creation for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    if (g_hwndParking)
        goto CleanUp;

    ZeroMemory(&wndclass, sizeof(wndclass));
    wndclass.lpfnWndProc = (g_ParkingWindowProc) ? g_ParkingWindowProc : DefWindowProc;
    wndclass.hInstance   = g_hInstance;
    wndclass.lpszClassName = "CtlFrameWork_Parking";

    if (!RegisterClass(&wndclass)) {
        FAIL("Couldn't Register Parking Window Class!");
        goto CleanUp;
    }

    g_hwndParking = CreateWindow("CtlFrameWork_Parking", NULL, WS_POPUP, 0, 0, 0, 0, NULL, NULL, g_hInstance, NULL);
    if (g_hwndParking != NULL)
       ++g_cLocks;

    ASSERT(g_hwndParking, "Couldn't Create Global parking window!!");


  CleanUp:
    LeaveCriticalSection(&g_CriticalSection);
    return g_hwndParking;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ctlmisc.cpp ===
//=--------------------------------------------------------------------------=
// CtlMisc.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// things that aren't elsewhere, such as property pages, and connection
// points.

#include "IPServer.H"
#include "CtrlObj.H"
#include "CtlHelp.H"
#include "Globals.H"
#include "StdEnum.H"
#include "Util.H"

#include <stdarg.h>

// for ASSERT and FAIL
//
SZTHISFILE

// this is used in our window proc so that we can find out who was last created
//
static COleControl *s_pLastControlCreated;

//=--------------------------------------------------------------------------=
// COleControl::COleControl
//=--------------------------------------------------------------------------=
// constructor
//
// Parameters:
//    IUnknown *          - [in] controlling Unknown
//    int                 - [in] type of primary dispatch interface OBJECT_TYPE_*
//    void *              - [in] pointer to entire object
//	  BOOL                - [in] whether to enable IDispatchEx functionality
//							to allow dynamic adding of properties
// Notes:
//
COleControl::COleControl
(
    IUnknown *pUnkOuter,
    int       iPrimaryDispatch,
    void     *pMainInterface,
	BOOL     fExpandoEnabled
)
: CAutomationObject(pUnkOuter, iPrimaryDispatch, pMainInterface, fExpandoEnabled),
  m_cpEvents(SINK_TYPE_EVENT),
  m_cpPropNotify(SINK_TYPE_PROPNOTIFY)
{
    // initialize all our variables -- we decided against using a memory-zeroing
    // memory allocator, so we sort of have to do this work now ...
    //
    m_nFreezeEvents = 0;

    m_pClientSite = NULL;
    m_pControlSite = NULL;
    m_pInPlaceSite = NULL;
    m_pInPlaceFrame = NULL;
    m_pInPlaceUIWindow = NULL;


    m_pInPlaceSiteWndless = NULL;

    // certain hosts don't like 0,0 as your initial size, so we're going to set
    // our initial size to 100,50 [so it's at least sort of visible on the screen]
    //
    m_Size.cx = 0;
    m_Size.cy = 0;
    memset(&m_rcLocation, 0, sizeof(m_rcLocation));

    m_hRgn = NULL;
    m_hwnd = NULL;
    m_hwndParent = NULL;
    m_hwndReflect = NULL;
    m_fHostReflects = TRUE;
    m_fCheckedReflecting = FALSE;

    m_nFreezeEvents = 0;
    m_pSimpleFrameSite = NULL;
    m_pOleAdviseHolder = NULL;
    m_pViewAdviseSink = NULL;
    m_pDispAmbient = NULL;

    m_fDirty = FALSE;
    m_fModeFlagValid = FALSE;
    m_fInPlaceActive = FALSE;
    m_fInPlaceVisible = FALSE;
    m_fUIActive = FALSE;
    m_fSaveSucceeded = FALSE;
    m_fViewAdvisePrimeFirst = FALSE;
    m_fViewAdviseOnlyOnce = FALSE;
    m_fRunMode = FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::~COleControl
//=--------------------------------------------------------------------------=
// "We are all of us resigned to death; it's life we aren't resigned to."
//    - Graham Greene (1904-91)
//
// Notes:
//
COleControl::~COleControl()
{
    // if we've still got a window, go and kill it now.
    //
    if (m_hwnd) {
        // so our window proc doesn't crash.
        //
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
        DestroyWindow(m_hwnd);
    }

    if (m_hwndReflect) {
        SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, 0);
        DestroyWindow(m_hwndReflect);
    }

    if (m_hRgn != NULL)
    {
       DeleteObject(m_hRgn);
       m_hRgn = NULL;
    }

    // clean up all the pointers we're holding around.
    //
    QUICK_RELEASE(m_pClientSite);
    QUICK_RELEASE(m_pControlSite);
    QUICK_RELEASE(m_pInPlaceSite);
    QUICK_RELEASE(m_pInPlaceFrame);
    QUICK_RELEASE(m_pInPlaceUIWindow);
    QUICK_RELEASE(m_pSimpleFrameSite);
    QUICK_RELEASE(m_pOleAdviseHolder);
    QUICK_RELEASE(m_pViewAdviseSink);
    QUICK_RELEASE(m_pDispAmbient);

    QUICK_RELEASE(m_pInPlaceSiteWndless);
}

#ifndef DEBUG
#pragma optimize("t", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::InternalQueryInterface
//=--------------------------------------------------------------------------=
// derived-controls should delegate back to this when they decide to support
// additional interfaces
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//    - NOTE: this function is speed critical!!!!
//
HRESULT COleControl::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    switch (riid.Data1) {
        // private interface for prop page support
        case Data1_IControlPrv:
          if(DO_GUIDS_MATCH(riid, IID_IControlPrv)) {
            *ppvObjOut = (void *)this;
            ExternalAddRef();
            return S_OK;
          }
          goto NoInterface;
        QI_INHERITS(this, IOleControl);
        QI_INHERITS(this, IPointerInactive);
        QI_INHERITS(this, IQuickActivate);
        QI_INHERITS(this, IOleObject);
        QI_INHERITS((IPersistStorage *)this, IPersist);
        QI_INHERITS(this, IPersistStreamInit);
        QI_INHERITS(this, IOleInPlaceObject);
        QI_INHERITS(this, IOleInPlaceObjectWindowless);
        QI_INHERITS((IOleInPlaceActiveObject *)this, IOleWindow);
        QI_INHERITS(this, IOleInPlaceActiveObject);
        QI_INHERITS(this, IViewObject);
        QI_INHERITS(this, IViewObject2);
        QI_INHERITS(this, IViewObjectEx);
        QI_INHERITS(this, IConnectionPointContainer);
        QI_INHERITS(this, ISpecifyPropertyPages);
        QI_INHERITS(this, IPersistStorage);
        QI_INHERITS(this, IPersistPropertyBag);
        QI_INHERITS(this, IProvideClassInfo);
        default:
            goto NoInterface;
    }

    // we like the interface, so addref and return
    //
    ((IUnknown *)(*ppvObjOut))->AddRef();
    return S_OK;

  NoInterface:
    // delegate to super-class for automation interfaces, etc ...
    //
    return CAutomationObject::InternalQueryInterface(riid, ppvObjOut);
}

#ifndef DEBUG
#pragma optimize("s", on)
#endif // DEBUG

//=--------------------------------------------------------------------------=
// COleControl::FindConnectionPoint    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// given an IID, find a connection point sink for it.
//
// Parameters:
//    REFIID              - [in]  interfaces they want
//    IConnectionPoint ** - [out] where the cp should go
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::FindConnectionPoint
(
    REFIID             riid,
    IConnectionPoint **ppConnectionPoint
)
{
    CHECK_POINTER(ppConnectionPoint);

    // we support the event interface, and IDispatch for it, and we also
    // support IPropertyNotifySink.
    //
    if (DO_GUIDS_MATCH(riid, EVENTIIDOFCONTROL(m_ObjectType)) || DO_GUIDS_MATCH(riid, IID_IDispatch))
        *ppConnectionPoint = &m_cpEvents;
    else if (DO_GUIDS_MATCH(riid, IID_IPropertyNotifySink))
        *ppConnectionPoint = &m_cpPropNotify;
    else
        return E_NOINTERFACE;

    // generic post-processing.
    //
    (*ppConnectionPoint)->AddRef();
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::EnumConnectionPoints    [IConnectionPointContainer]
//=--------------------------------------------------------------------------=
// creates an enumerator for connection points.
//
// Parameters:
//    IEnumConnectionPoints **    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::EnumConnectionPoints
(
    IEnumConnectionPoints **ppEnumConnectionPoints
)
{
    IConnectionPoint **rgConnectionPoints;

    CHECK_POINTER(ppEnumConnectionPoints);

    // HeapAlloc an array of connection points [since our standard enum
    // assumes this and HeapFree's it later ]
    //
    rgConnectionPoints = (IConnectionPoint **)HeapAlloc(g_hHeap, 0, sizeof(IConnectionPoint *) * 2);
    RETURN_ON_NULLALLOC(rgConnectionPoints);

    // we support the event interface for this dude as well as IPropertyNotifySink
    //
    rgConnectionPoints[0] = &m_cpEvents;
    rgConnectionPoints[1] = &m_cpPropNotify;

    *ppEnumConnectionPoints = (IEnumConnectionPoints *)(IEnumGeneric *) new CStandardEnum(IID_IEnumConnectionPoints,
                                2, sizeof(IConnectionPoint *), (void *)rgConnectionPoints,
                                CopyAndAddRefObject);
    if (!*ppEnumConnectionPoints) {
        HeapFree(g_hHeap, 0, rgConnectionPoints);
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetPages    [ISpecifyPropertyPages]
//=--------------------------------------------------------------------------=
// returns a counted array with the guids for our property pages.
//
// parameters:
//    CAUUID *    - [out] where to put the counted array.
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::GetPages
(
    CAUUID *pPages
)
{
    const GUID **pElems;
    void *pv;
    WORD  x;

    // if there are no property pages, this is actually pretty easy.
    //
    if (!CPROPPAGESOFCONTROL(m_ObjectType)) {
        pPages->cElems = 0;
        pPages->pElems = NULL;
        return S_OK;
    }

    // fill out the Counted array, using IMalloc'd memory.
    //
    pPages->cElems = CPROPPAGESOFCONTROL(m_ObjectType);
    pv = CoTaskMemAlloc(sizeof(GUID) * (pPages->cElems));
    RETURN_ON_NULLALLOC(pv);
    pPages->pElems = (GUID *)pv;

    // loop through our array of pages and get 'em.
    //
    pElems = PPROPPAGESOFCONTROL(m_ObjectType);
    for (x = 0; x < pPages->cElems; x++)
        pPages->pElems[x] = *(pElems[x]);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::m_pOleControl
//=--------------------------------------------------------------------------=
// returns a pointer to the control in which we are nested.
//
// Output:
//    COleControl *
//
// Notes:
//
inline COleControl *COleControl::CConnectionPoint::m_pOleControl
(
    void
)
{
    return (COleControl *)((BYTE *)this - ((m_bType == SINK_TYPE_EVENT)
                                          ? offsetof(COleControl, m_cpEvents)
                                          : offsetof(COleControl, m_cpPropNotify)));
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::QueryInterface
//=--------------------------------------------------------------------------=
// standard qi
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, IID_IConnectionPoint) || DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        *ppvObjOut = (IConnectionPoint *)this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddRef
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG COleControl::CConnectionPoint::AddRef
(
    void
)
{
    return m_pOleControl()->ExternalAddRef();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Release
//=--------------------------------------------------------------------------=
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG COleControl::CConnectionPoint::Release
(
    void
)
{
    return m_pOleControl()->ExternalRelease();
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionInterface
//=--------------------------------------------------------------------------=
// returns the interface we support connections on.
//
// Parameters:
//    IID *        - [out] interface we support.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::GetConnectionInterface
(
    IID *piid
)
{
    if (m_bType == SINK_TYPE_EVENT)
        *piid = EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType);
    else
        *piid = IID_IPropertyNotifySink;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::GetConnectionPointContainer
//=--------------------------------------------------------------------------=
// returns the connection point container
//
// Parameters:
//    IConnectionPointContainer **ppCPC
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::GetConnectionPointContainer
(
    IConnectionPointContainer **ppCPC
)
{
    return m_pOleControl()->ExternalQueryInterface(IID_IConnectionPointContainer, (void **)ppCPC);
}


//=--------------------------------------------------------------------------=
// COleControl::CConnectiontPoint::Advise
//=--------------------------------------------------------------------------=
// someboyd wants to be advised when something happens.
//
// Parameters:
//    IUnknown *        - [in]  guy who wants to be advised.
//    DWORD *           - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::Advise
(
    IUnknown *pUnk,
    DWORD    *pdwCookie
)
{
    HRESULT    hr;
    void      *pv;

    CHECK_POINTER(pdwCookie);

    // first, make sure everybody's got what they thinks they got
    //
    if (m_bType == SINK_TYPE_EVENT) {

        // CONSIDER: 12.95 -- this theoretically is broken -- if they do a find
        // connection point on IDispatch, and they just happened to also support
        // the Event IID, we'd advise on that.  this is not awesome, but will
        // prove entirely acceptable short term.
        //
        hr = pUnk->QueryInterface(EVENTIIDOFCONTROL(m_pOleControl()->m_ObjectType), &pv);
        if (FAILED(hr))
            hr = pUnk->QueryInterface(IID_IDispatch, &pv);
    }
    else
        hr = pUnk->QueryInterface(IID_IPropertyNotifySink, &pv);
    RETURN_ON_FAILURE(hr);

    // finally, add the sink.  it's now been cast to the correct type and has
    // been AddRef'd.
    //
    return AddSink(pv, pdwCookie);
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::AddSink
//=--------------------------------------------------------------------------=
// in some cases, we'll already have done the QI, and won't need to do the
// work that is done in the Advise routine above.  thus, these people can
// just call this instead. [this stems really from IQuickActivate]
//
// Parameters:
//    void *        - [in]  the sink to add. it's already been addref'd
//    DWORD *       - [out] cookie
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::CConnectionPoint::AddSink
(
    void  *pv,
    DWORD *pdwCookie
)
{
    IUnknown **rgUnkNew;
    int        i;

    // we optimize the case where there is only one sink to not allocate
    // any storage.  turns out very rarely is there more than one.
    //

    if (!m_cSinks) {
        m_SingleSink = (IUnknown *) pv;
        *pdwCookie = (DWORD)-1;
        m_cSinks = 1;
        return S_OK;
    }

    // Allocated the array yet?
    if (!m_rgSinks) {
        rgUnkNew = (IUnknown **)HeapAlloc(g_hHeap, HEAP_ZERO_MEMORY, 8 * sizeof(IUnknown *));
        RETURN_ON_NULLALLOC(rgUnkNew);
        m_cAllocatedSinks = 8;
        m_rgSinks = rgUnkNew;
        m_rgSinks[0] = m_SingleSink;
        m_rgSinks[1] = (IUnknown *)pv;
        m_SingleSink = NULL;
        m_cSinks = 2;
        *pdwCookie = 2;
        return S_OK;
    }

    // Find an empty slot.
    for (i = 0; i < m_cAllocatedSinks; i++) {
        if (!m_rgSinks[i]) {
            m_rgSinks[i] = (IUnknown *)pv;
            i++;
            *pdwCookie = i;
            m_cSinks++;
            return S_OK;
        }
    }

    // Didn't find one, grow the array.
    rgUnkNew = (IUnknown **)HeapReAlloc(g_hHeap, HEAP_ZERO_MEMORY, m_rgSinks, (m_cAllocatedSinks + 8) * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(rgUnkNew);
    m_rgSinks = rgUnkNew;
    m_rgSinks[m_cAllocatedSinks] = (IUnknown *)pv;
    i = m_cAllocatedSinks+1;
    m_cAllocatedSinks += 8;

    *pdwCookie = i;
    m_cSinks++;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::Unadvise
//=--------------------------------------------------------------------------=
// they don't want to be told any more.
//
// Parameters:
//    DWORD        - [in]  the cookie we gave 'em.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::CConnectionPoint::Unadvise
(
    DWORD dwCookie
)
{
    IUnknown *pUnk;

    if (!dwCookie)
        return S_OK;

    if (dwCookie == (DWORD) -1) {
        pUnk = m_SingleSink;
        m_SingleSink = NULL;
        if (m_rgSinks) {
            m_rgSinks[0] = NULL;
        }
    } else {
        if (dwCookie <= (DWORD)m_cAllocatedSinks) {
            if (m_rgSinks) {
                pUnk = m_rgSinks[dwCookie-1];
                m_rgSinks[dwCookie-1] = NULL;
            } else {
                return CONNECT_E_NOCONNECTION;
            }
        } else {
            return CONNECT_E_NOCONNECTION;
        }
    }

    m_cSinks--;

    if (!m_cSinks && m_rgSinks) {
        HeapFree(g_hHeap, 0, m_rgSinks);
        m_cAllocatedSinks = 0;
        m_rgSinks = NULL;
    }

    if (pUnk) {
        pUnk->Release();
        return S_OK;
    } else {
        return CONNECT_E_NOCONNECTION;
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::EnumConnections
//=--------------------------------------------------------------------------=
// enumerates all current connections
//
// Paramters:
//    IEnumConnections ** - [out] new enumerator object
//
// Output:
//    HRESULT
//
// NOtes:
//
STDMETHODIMP COleControl::CConnectionPoint::EnumConnections
(
    IEnumConnections **ppEnumOut
)
{
    CONNECTDATA *rgConnectData = NULL;
    unsigned int i;

    if (m_cSinks) {
        // allocate some memory big enough to hold all of the sinks.
        //
        rgConnectData = (CONNECTDATA *)HeapAlloc(g_hHeap, 0, m_cSinks * sizeof(CONNECTDATA));
        RETURN_ON_NULLALLOC(rgConnectData);

        if ((m_cSinks == 1) && !m_rgSinks) {
            rgConnectData[0].pUnk = m_SingleSink;
            rgConnectData[0].dwCookie = (DWORD)-1;
        } else {
            for (unsigned int x = 0, i=0; x < m_cAllocatedSinks; x++) {
                if (m_rgSinks[x]) {
                    rgConnectData[i].pUnk = m_rgSinks[x];
                    rgConnectData[i].dwCookie = x+1;
                    i++;
                }
            }
        }
    }

    // create yon enumerator object.
    //
    *ppEnumOut = (IEnumConnections *)(IEnumGeneric *)new CStandardEnum(IID_IEnumConnections,
                        m_cSinks, sizeof(CONNECTDATA), rgConnectData, CopyAndAddRefObject);
    if (!*ppEnumOut) {
        if (rgConnectData)
        {
            HeapFree(g_hHeap, 0, rgConnectData);
        }
        return E_OUTOFMEMORY;
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::~CConnectionPoint
//=--------------------------------------------------------------------------=
// cleans up
//
// Notes:
//
COleControl::CConnectionPoint::~CConnectionPoint ()
{
    int x;

    // clean up some memory stuff
    //
    if (!m_cSinks)
        return;
    else if (m_SingleSink)
        ((IUnknown *)m_SingleSink)->Release();
    else {
        for (x = 0; x < m_cAllocatedSinks; x++) {
    	    if (m_rgSinks[x]) {
                QUICK_RELEASE(m_rgSinks[x]);
	        }
        }
        HeapFree(g_hHeap, 0, m_rgSinks);
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPiont::DoInvoke
//=--------------------------------------------------------------------------=
// fires an event to all listening on our event interface.
//
// Parameters:
//    DISPID            - [in] event to fire.
//    DISPPARAMS        - [in]
//
// Notes:
//
void COleControl::CConnectionPoint::DoInvoke
(
    DISPID      dispid,
    DISPPARAMS *pdispparams
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.  we intentionally
    // ignore errors here.
    //
    if (m_cSinks == 0)
        return;
    else if (m_SingleSink) {
        ((IDispatch *)m_SingleSink)->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
    	    if (m_rgSinks[iConnection]) {
                ((IDispatch *)m_rgSinks[iConnection])->Invoke(dispid, IID_NULL, 0, DISPATCH_METHOD, pdispparams, NULL, NULL, NULL);
	        }
    	}
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnChanged
//=--------------------------------------------------------------------------=
// fires the OnChanged event for IPropertyNotifySink listeners.
//
// Parameters:
//    DISPID            - [in] dude that changed.
//
// Output:
//    none
//
// Notes:
//
void COleControl::CConnectionPoint::DoOnChanged
(
    DISPID dispid
)
{
    int iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        return;
    else if (m_SingleSink) {
        ((IPropertyNotifySink *)m_SingleSink)->OnChanged(dispid);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
    	    if (m_rgSinks[iConnection]) {
                ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnChanged(dispid);
            }
	    }
    }
}

//=--------------------------------------------------------------------------=
// COleControl::CConnectionPoint::DoOnRequestEdit
//=--------------------------------------------------------------------------=
// fires the OnRequestEdit for IPropertyNotifySinkListeners
//
// Parameters:
//    DISPID             - [in] dispid user wants to change.
//
// Output:
//    BOOL               - false means you cant
//
// Notes:
//
BOOL COleControl::CConnectionPoint::DoOnRequestEdit
(
    DISPID dispid
)
{
    HRESULT hr;
    int     iConnection;

    // if we don't have any sinks, then there's nothing to do.
    //
    if (m_cSinks == 0)
        hr = S_OK;
    else if (m_SingleSink) {
        hr =((IPropertyNotifySink *)m_SingleSink)->OnRequestEdit(dispid);
    } else {
        for (iConnection = 0; iConnection < m_cAllocatedSinks; iConnection++) {
    	    if (m_rgSinks[iConnection]) {
                hr = ((IPropertyNotifySink *)m_rgSinks[iConnection])->OnRequestEdit(dispid);
                if (hr != S_OK)
	        	    break;
    	    }
        }
    }

    return (hr == S_OK) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::CreateInPlaceWindow
//=--------------------------------------------------------------------------=
// creates the window with which we will be working.
// yay.
//
// Parameters:
//    int            - [in] left
//    int            - [in] top
//    BOOL           - [in] can we skip redrawing?
//
// Output:
//    HWND
//
// Notes:
//    - DANGER! DANGER!  this function is protected so that anybody can call it
//      from their control.  however, people should be extremely careful of when
//      and why they do this.  preferably, this function would only need to be
//      called by an end-control writer in design mode to take care of some
//      hosting/painting issues.  otherwise, the framework should be left to
//      call it when it wants.
//
HWND COleControl::CreateInPlaceWindow
(
    int  x,
    int  y,
    BOOL fNoRedraw
)
{
    BOOL    fVisible;
    HRESULT hr;
    DWORD   dwWindowStyle, dwExWindowStyle;
    char    szWindowTitle[128];

    // if we've already got a window, do nothing.
    //
    if (m_hwnd)
        return m_hwnd;

    // get the user to register the class if it's not already
    // been done.  we have to critical section this since more than one thread
    // can be trying to create this control
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!CTLWNDCLASSREGISTERED(m_ObjectType)) {
        if (!RegisterClassData()) {
            LeaveCriticalSection(&g_CriticalSection);
            return NULL;
        } else
            CTLWNDCLASSREGISTERED(m_ObjectType) = TRUE;
    }
    LeaveCriticalSection(&g_CriticalSection);

    // let the user set up things like the window title, the
    // style, and anything else they feel interested in fiddling
    // with.
    //
    dwWindowStyle = dwExWindowStyle = 0;
    szWindowTitle[0] = '\0';
    if (!BeforeCreateWindow(&dwWindowStyle, &dwExWindowStyle, szWindowTitle))
        return NULL;

    dwWindowStyle |= (WS_CHILD | WS_CLIPSIBLINGS);

    // create window visible if parent hidden (common case)
    // otherwise, create hidden, then shown.  this is a little subtle, but
    // it makes sense eventually.
    //
    if (!m_hwndParent)
        m_hwndParent = GetParkingWindow();

    fVisible = IsWindowVisible(m_hwndParent);

    // if a control is subclassed, and we're in
    // a host that doesn't support Message Reflecting, we have to create
    // the user window in another window which will do all the reflecting.
    // VERY blech. [don't however, bother in design mode]
    //
    if (SUBCLASSWNDPROCOFCONTROL(m_ObjectType) && (m_hwndParent != GetParkingWindow())) {
        // determine if the host supports message reflecting.
        //
        if (!m_fCheckedReflecting) {
            VARIANT_BOOL f;
            hr = GetAmbientProperty(DISPID_AMBIENT_MESSAGEREFLECT, VT_BOOL, &f);
            if (FAILED(hr) || !f)
                m_fHostReflects = FALSE;
            m_fCheckedReflecting = TRUE;
        }

        // if the host doesn't support reflecting, then we have to create
        // an extra window around the control window, and then parent it
        // off that.
        //
        if (!m_fHostReflects) {
            ASSERT(m_hwndReflect == NULL, "Where'd this come from?");
            m_hwndReflect = CreateReflectWindow(!fVisible, m_hwndParent, x, y, &m_Size);
            if (!m_hwndReflect)
                return NULL;
            SetWindowLongPtr(m_hwndReflect, GWLP_USERDATA, (LONG_PTR)this);
            dwWindowStyle |= WS_VISIBLE;
        }
    } else {
        if (!fVisible)
            dwWindowStyle |= WS_VISIBLE;
    }

    // we have to mutex the entire create window process since we need to use
    // the s_pLastControlCreated to pass in the object pointer.  nothing too
    // serious
    //
    EnterCriticalSection(&g_CriticalSection);
    s_pLastControlCreated = this;
    m_fCreatingWindow = TRUE;

    // finally, go create the window, parenting it as appropriate.
    //
    m_hwnd = CreateWindowEx(dwExWindowStyle,
                            WNDCLASSNAMEOFCONTROL(m_ObjectType),
                            szWindowTitle,
                            dwWindowStyle,
                            (m_hwndReflect) ? 0 : x,
                            (m_hwndReflect) ? 0 : y,
                            m_Size.cx, m_Size.cy,
                            (m_hwndReflect) ? m_hwndReflect : m_hwndParent,
                            NULL, g_hInstance, NULL);

    // clean up some variables, and leave the critical section
    //
    m_fCreatingWindow = FALSE;
    s_pLastControlCreated = NULL;
    LeaveCriticalSection(&g_CriticalSection);

    if (m_hwnd) {
        // let the derived-control do something if they so desire
        //
        if (!AfterCreateWindow()) {
            BeforeDestroyWindow();
            SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xFFFFFFFF);
            DestroyWindow(m_hwnd);
            m_hwnd = NULL;
            return m_hwnd;
        }

        // if we didn't create the window visible, show it now.
        //
		
        if (fVisible)
		{
			if (GetParent(m_hwnd) != m_hwndParent)
				// SetWindowPos fails if parent hwnd is passed in so keep
				// this behaviour in those cases without ripping.
				SetWindowPos(m_hwnd, m_hwndParent, 0, 0, 0, 0,
							 SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_SHOWWINDOW | ((fNoRedraw) ? SWP_NOREDRAW : 0));
		}
    }

    // finally, tell the host of this
    //
    if (m_pClientSite)
        m_pClientSite->ShowObject();

    return m_hwnd;
}

//=--------------------------------------------------------------------------=
// COleControl::SetInPlaceParent    [helper]
//=--------------------------------------------------------------------------=
// sets up the parent window for our control.
//
// Parameters:
//    HWND            - [in] new parent window
//
// Notes:
//
void COleControl::SetInPlaceParent
(
    HWND hwndParent
)
{
    ASSERT(!m_pInPlaceSiteWndless, "This routine should only get called for windowed OLE controls");

    if (m_hwndParent == hwndParent)
        return;

    m_hwndParent = hwndParent;
    if (m_hwnd)
        SetParent(GetOuterWindow(), hwndParent);
}

//=--------------------------------------------------------------------------=
// COleControl::ControlWindowProc
//=--------------------------------------------------------------------------=
// default window proc for an OLE Control.   controls will have their own
// window proc called from this one, after some processing is done.
//
// Parameters:
//    - see win32sdk docs.
//
// Notes:
//
LRESULT CALLBACK COleControl::ControlWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl = ControlFromHwnd(hwnd);
    HRESULT hr;
    LRESULT lResult;
    DWORD   dwCookie;

    // if the value isn't a positive value, then it's in some special
    // state [creation or destruction]  this is safe because under win32,
    // the upper 2GB of an address space aren't available.
    //
    if (!pCtl) {
        pCtl = s_pLastControlCreated;
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)pCtl);
            // This test and else clause, which you would resonably expect to never
            // ever happen, is needed for the plugin control when hosting the SGI
            // COSMO plugin.  That plugin queries GWL_USERDATA and uses it as a pointer.
            // In IE4.0 we in-place deactivate it when IE3 did not, causing the window
            // to be destroyed, and the SGI COSMO plugin to fault.  The fix is for the
            // Plugin control to never use the GWL_USERDATA == -1 mechanism.
            // -Tomsn, 1/2/97 (happy new year), IE4 bug 13292.
        if( pCtl != NULL ) {
            pCtl->m_hwnd = hwnd;
        }
        else {
            return DefWindowProc(hwnd, msg, wParam, lParam);
        }
    } else if ((LONG_PTR)pCtl == (LONG_PTR)0xffffffff) {
        return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    // message preprocessing
    //
    if (pCtl->m_pSimpleFrameSite) {
        hr = pCtl->m_pSimpleFrameSite->PreMessageFilter(hwnd, msg, wParam, lParam, &lResult, &dwCookie);
        if (hr == S_FALSE) return lResult;
    }

    // for certain messages, do not call the user window proc. instead,
    // we have something else we'd like to do.
    //
    switch (msg) {
      case WM_PAINT:
        {
        // call the user's OnDraw routine.
        //
        PAINTSTRUCT ps;
        RECT        rc;
        HDC         hdc;

        // if we're given an HDC, then use it
        //
        if (!wParam)
            hdc = BeginPaint(hwnd, &ps);
        else
            hdc = (HDC)wParam;

        GetClientRect(hwnd, &rc);
        pCtl->OnDraw(DVASPECT_CONTENT, hdc, (RECTL *)&rc, NULL, NULL, TRUE);

        if (!wParam)
            EndPaint(hwnd, &ps);
        }
        break;

      default:
        // call the derived-control's window proc
        //
        lResult = pCtl->WindowProc(msg, wParam, lParam);
        break;
    }

    // message postprocessing
    //
    switch (msg) {

      case WM_NCDESTROY:
        // after this point, the window doesn't exist any more
        //
        pCtl->m_hwnd = NULL;
        break;

      case WM_SETFOCUS:
      case WM_KILLFOCUS:
        // give the control site focus notification
        //
        if (pCtl->m_fInPlaceActive && pCtl->m_pControlSite)
            pCtl->m_pControlSite->OnFocus(msg == WM_SETFOCUS);
        break;

      case WM_SIZE:
        // a change in size is a change in view
        //
        if (!pCtl->m_fCreatingWindow)
            pCtl->ViewChanged();
        break;
    }

    // lastly, simple frame postmessage processing
    //
    if (pCtl->m_pSimpleFrameSite)
        pCtl->m_pSimpleFrameSite->PostMessageFilter(hwnd, msg, wParam, lParam, &lResult, dwCookie);

    return lResult;
}

//=--------------------------------------------------------------------------=
// COleControl::SetFocus
//=--------------------------------------------------------------------------=
// we have to override this routine to get UI Activation correct.
//
// Parameters:
//    BOOL              - [in] true means take, false release
//
// Output:
//    BOOL
//
// Notes:
//    - CONSIDER: this is pretty messy, and it's still not entirely clear
//      what the ole control/focus story is.
//
BOOL COleControl::SetFocus
(
    BOOL fGrab
)
{
    HRESULT hr;
    HWND    hwnd;

    // first thing to do is check out UI Activation state, and then set
    // focus [either with windows api, or via the host for windowless
    // controls]
    //
    if (m_pInPlaceSiteWndless) {
        if (!m_fUIActive && fGrab)
            if (FAILED(InPlaceActivate(OLEIVERB_UIACTIVATE))) return FALSE;

        hr = m_pInPlaceSiteWndless->SetFocus(fGrab);
        return (hr == S_OK) ? TRUE : FALSE;
    } else {

        // we've got a window.
        //
        if (m_fInPlaceActive) {
            hwnd = (fGrab) ? m_hwnd : m_hwndParent;
            if (!m_fUIActive && fGrab)
                return SUCCEEDED(InPlaceActivate(OLEIVERB_UIACTIVATE));
            else
                return SetGUIFocus(hwnd);
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::SetGUIFocus
//=--------------------------------------------------------------------------=
// does the work of setting the Windows GUI focus to the specified window
//
// Parameters:
//    HWND              - [in] window that should get focus
//
// Output:
//    BOOL              - [out] whether setting focus succeeded
//
// Notes:
//    we do this because some controls host non-ole window hierarchies, like
// the Netscape plugin ocx.  in such cases, the control may need to be UIActive
// to function properly in the document, but cannot take the windows focus
// away from one of its child windows.  such controls may override this method
// and respond as appropriate.
//
BOOL COleControl::SetGUIFocus
(
    HWND hwndSet
)
{
    return (::SetFocus(hwndSet) == hwndSet);
}


//=--------------------------------------------------------------------------=
// COleControl::ReflectWindowProc
//=--------------------------------------------------------------------------=
// reflects window messages on to the child window.
//
// Parameters and Output:
//    - see win32 sdk docs
//
// Notes:
//
LRESULT CALLBACK COleControl::ReflectWindowProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    COleControl *pCtl;

    switch (msg) {
        case WM_COMMAND:
        case WM_NOTIFY:
        case WM_CTLCOLORBTN:
        case WM_CTLCOLORDLG:
        case WM_CTLCOLOREDIT:
        case WM_CTLCOLORLISTBOX:
        case WM_CTLCOLORMSGBOX:
        case WM_CTLCOLORSCROLLBAR:
        case WM_CTLCOLORSTATIC:
        case WM_DRAWITEM:
        case WM_MEASUREITEM:
        case WM_DELETEITEM:
        case WM_VKEYTOITEM:
        case WM_CHARTOITEM:
        case WM_COMPAREITEM:
        case WM_HSCROLL:
        case WM_VSCROLL:
        case WM_PARENTNOTIFY:
        case WM_SETFOCUS:
        case WM_SIZE:
            pCtl = (COleControl *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            if (pCtl)
                return SendMessage(pCtl->m_hwnd, OCM__BASE + msg, wParam, lParam);
            break;
    }

    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientProperty    [callable]
//=--------------------------------------------------------------------------=
// returns the value of an ambient property
//
// Parameters:
//    DISPID        - [in]  property to get
//    VARTYPE       - [in]  type of desired data
//    void *        - [out] where to put the data
//
// Output:
//    BOOL          - FALSE means didn't work.
//
// Notes:
//
BOOL COleControl::GetAmbientProperty
(
    DISPID  dispid,
    VARTYPE vt,
    void   *pData
)
{
    DISPPARAMS dispparams;
    VARIANT v, v2;
    HRESULT hr;

    v.vt = VT_EMPTY;
    v.lVal = 0;
    v2.vt = VT_EMPTY;
    v2.lVal = 0;

    // get a pointer to the source of ambient properties.
    //
    if (!m_pDispAmbient) {
        if (m_pClientSite)
            m_pClientSite->QueryInterface(IID_IDispatch, (void **)&m_pDispAmbient);

        if (!m_pDispAmbient)
            return FALSE;
    }

    // now go and get the property into a variant.
    //
    memset(&dispparams, 0, sizeof(DISPPARAMS));
    hr = m_pDispAmbient->Invoke(dispid, IID_NULL, 0, DISPATCH_PROPERTYGET, &dispparams,
                                &v, NULL, NULL);
    if (FAILED(hr)) return FALSE;

    // we've got the variant, so now go an coerce it to the type that the user
    // wants.  if the types are the same, then this will copy the stuff to
    // do appropriate ref counting ...
    //
    hr = VariantChangeType(&v2, &v, 0, vt);
    if (FAILED(hr)) {
        VariantClear(&v);
        return FALSE;
    }

    // copy the data to where the user wants it
    //
    CopyMemory(pData, &(v2.lVal), g_rgcbDataTypeSize[vt]);
    VariantClear(&v);
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAmbientFont    [callable]
//=--------------------------------------------------------------------------=
// gets the current font for the user.
//
// Parameters:
//    IFont **         - [out] where to put the font.
//
// Output:
//    BOOL             - FALSE means couldn't get it.
//
// Notes:
//
BOOL COleControl::GetAmbientFont
(
    IFont **ppFont
)
{
    IDispatch *pFontDisp;

    // we don't have to do much here except get the ambient property and QI
    // it for the user.
    //
    *ppFont = NULL;
    if (!GetAmbientProperty(DISPID_AMBIENT_FONT, VT_DISPATCH, &pFontDisp))
        return FALSE;

    pFontDisp->QueryInterface(IID_IFont, (void **)ppFont);
    pFontDisp->Release();
    return (*ppFont) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::DesignMode
//=--------------------------------------------------------------------------=
// returns TRUE if we're in Design mode.
//
// Output:
//    BOOL            - true is design mode, false is run mode
//
// Notes:
//
BOOL COleControl::DesignMode
(
    void
)
{
    VARIANT_BOOL f;

    // if we don't already know our run mode, go and get it.  we'll assume
    // it's true unless told otherwise [or if the operation fails ...]
    //
    if (!m_fModeFlagValid) {
        f = TRUE;
        m_fModeFlagValid = TRUE;
        GetAmbientProperty(DISPID_AMBIENT_USERMODE, VT_BOOL, &f);
        m_fRunMode = f;
    }

    return !m_fRunMode;
}


//=--------------------------------------------------------------------------=
// COleControl::FireEvent
//=--------------------------------------------------------------------------=
// fires an event.  handles arbitrary number of arguments.
//
// Parameters:
//    EVENTINFO *        - [in] struct that describes the event.
//    ...                - arguments to the event
//
// Output:
//    none
//
// Notes:
//    - use stdarg's va_* macros.
//
void __cdecl COleControl::FireEvent
(
    EVENTINFO *pEventInfo,
    ...
)
{
    va_list    valist;
    DISPPARAMS dispparams;
    VARIANT    rgvParameters[MAX_ARGS];
    VARIANT   *pv;
    VARTYPE    vt;
    int        iParameter;
    int        cbSize;

    ASSERT(pEventInfo->cParameters <= MAX_ARGS, "Don't support more than MAX_ARGS params.  sorry.");

    va_start(valist, pEventInfo);

    // copy the Parameters into the rgvParameters array.  make sure we reverse
    // them for automation
    //
    pv = &(rgvParameters[pEventInfo->cParameters - 1]);
    for (iParameter = 0; iParameter < pEventInfo->cParameters; iParameter++) {

        vt = pEventInfo->rgTypes[iParameter];

        // if it's a by value variant, then just copy the whole
        // dang thing
        //
        if (vt == VT_VARIANT)
            *pv = va_arg(valist, VARIANT);
        else {
            // copy the vt and the data value.
            //
            pv->vt = vt;
            if (vt & VT_BYREF)
                cbSize = sizeof(void *);
            else
                cbSize = g_rgcbDataTypeSize[vt];

            // small optimization -- we can copy 2/4 bytes over quite
            // quickly.
            //
            if (cbSize == sizeof(short))
                V_I2(pv) = va_arg(valist, short);
            else if (cbSize == 4)
                V_I4(pv) = va_arg(valist, long);
            else {
                // copy over 8 bytes
                //
                ASSERT(cbSize == 8, "don't recognize the type!!");
                V_CY(pv) = va_arg(valist, CURRENCY);
            }
        }

        pv--;
    }

    // fire the event
    //
    dispparams.rgvarg = rgvParameters;
    dispparams.cArgs = pEventInfo->cParameters;
    dispparams.rgdispidNamedArgs = NULL;
    dispparams.cNamedArgs = 0;

    m_cpEvents.DoInvoke(pEventInfo->dispid, &dispparams);

    va_end(valist);
}

//=--------------------------------------------------------------------------=
// COleControl::AfterCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// something the user can pay attention to
//
// Output:
//    BOOL             - false means fatal error, can't continue
// Notes:
//
BOOL COleControl::AfterCreateWindow
(
    void
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::BeforeCreateWindow    [overridable]
//=--------------------------------------------------------------------------=
// called just before we create a window.  the user should register their
// window class here, and set up any other things, such as the title of
// the window, and/or sytle bits, etc ...
//
// Parameters:
//    DWORD *            - [out] dwWindowFlags
//    DWORD *            - [out] dwExWindowFlags
//    LPSTR              - [out] name of window to create
//
// Output:
//    BOOL               - false means fatal error, can't continue
//
// Notes:
//
BOOL COleControl::BeforeCreateWindow
(
    DWORD *pdwWindowStyle,
    DWORD *pdwExWindowStyle,
    LPSTR  pszWindowTitle
)
{
    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::InvalidateControl    [callable]
//=--------------------------------------------------------------------------=
void COleControl::InvalidateControl
(
    LPCRECT lpRect
)
{
    if (m_fInPlaceActive)
        InvalidateRect(m_hwnd, lpRect, TRUE);
    else
        ViewChanged();

    // CONSIDER: one might want to call pOleAdviseHolder->OnDataChanged() here
    // if there was support for IDataObject
}

//=--------------------------------------------------------------------------=
// COleControl::SetControlSize    [callable]
//=--------------------------------------------------------------------------=
// sets the control size. they'll give us the size in pixels.  we've got to
// convert them back to HIMETRIC before passing them on!
//
// Parameters:
//    SIZEL *        - [in] new size
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::SetControlSize
(
    SIZEL *pSize
)
{
    HRESULT hr;
    SIZEL slHiMetric;

    PixelToHiMetric(pSize, &slHiMetric);
    hr = SetExtent(DVASPECT_CONTENT, &slHiMetric);
    return (FAILED(hr)) ? FALSE : TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::RecreateControlWindow    [callable]
//=--------------------------------------------------------------------------=
// called by a [subclassed, typically] control to recreate it's control
// window.
//
// Parameters:
//    none
//
// Output:
//    HRESULT
//
// Notes:
//    - NOTE: USE ME EXTREMELY SPARINGLY! THIS IS AN EXTREMELY EXPENSIVE
//      OPERATION!
//
HRESULT COleControl::RecreateControlWindow
(
    void
)
{
    HRESULT hr;
    HWND    hwndPrev = HWND_TOP;

    // we need to correctly preserve the control's position within the
    // z-order here.
    //
    if (m_hwnd)
        hwndPrev = ::GetWindow(m_hwnd, GW_HWNDPREV);

    // if we're in place active, then we have to deactivate, and reactivate
    // ourselves with the new window ...
    //
    if (m_fInPlaceActive) {

        hr = InPlaceDeactivate();
        RETURN_ON_FAILURE(hr);
        hr = InPlaceActivate((m_fUIActive) ? OLEIVERB_UIACTIVATE : OLEIVERB_INPLACEACTIVATE);
        RETURN_ON_FAILURE(hr);

    } else if (m_hwnd) {
        DestroyWindow(m_hwnd);
        m_hwnd = NULL;
        if (m_hwndReflect) {
            DestroyWindow(m_hwndReflect);
            m_hwndReflect = NULL;
        }

        CreateInPlaceWindow(0, 0, FALSE);
    }

    // restore z-order position
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, hwndPrev, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE | SWP_NOACTIVATE);

    return m_hwnd ? S_OK : E_FAIL;
}

// from Globals.C. don't need to mutex it here since we only read it.
//
extern HINSTANCE g_hInstResources;

//=--------------------------------------------------------------------------=
// COleControl::GetResourceHandle    [callable]
//=--------------------------------------------------------------------------=
// gets the HINSTANCE of the DLL where the control should get resources
// from.  implemented in such a way to support satellite DLLs.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE COleControl::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // crit sect this for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fHaveLocale)
        // if we can't get the ambient locale id, then we'll just continue
        // with the globally set up value.
        //
        if (!GetAmbientProperty(DISPID_AMBIENT_LOCALEID, VT_I4, &g_lcidLocale))
            goto Done;

    g_fHaveLocale = TRUE;

  Done:
    LeaveCriticalSection(&g_CriticalSection);
    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ctlocx96.cpp ===
//=--------------------------------------------------------------------------=
// CtlOcx96.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the OCX 96 interfaces that don't quite fit in to the
// categories covered by embedding, persistence, and ctlmisc.cpp
//
//
#include "IPServer.H"

#include "CtrlObj.H"
#include "Globals.H"


//=--------------------------------------------------------------------------=
// COleControl::GetActivationPolicy    [IPointerInactive]
//=--------------------------------------------------------------------------=
// returns the present activation policy for this object.  for non-subclassed
// windows controls, this means we can put off in-place activation for quite
// a while.
//
// Parameters:
//    DWORD *        - [out] activation policy
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetActivationPolicy
(
    DWORD *pdwPolicy
)
{
    CHECK_POINTER(pdwPolicy);

    // just get the policy in the global structure describing this control.
    //
    *pdwPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::OnInactiveMouseMove    [IPointerInactive]
//=--------------------------------------------------------------------------=
// indicates to an inactive oobject that the mouse pointer has moved over the
// object.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveMouseMove
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg
)
{
    // OVERRIDE: end control writers should just override this if they want
    // to have a control that is never in-place active.
    //
    return S_OK;
}
    
//=--------------------------------------------------------------------------=
// COleControl::OnInactiveSetCursor    [IPointerInactive]
//=--------------------------------------------------------------------------=
// called by the container for the inactive object under the mouse pointer on
// recept of a WM_SETCURSOR message.
//
// Parameters:
//    LPCRECT            - [in]
//    long               - [in]
//    long               - [in]
//    DWORD              - [in]
//    BOOL               - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::OnInactiveSetCursor
(
    LPCRECT pRectBounds,
    long    x,
    long    y,
    DWORD   dwMouseMsg,
    BOOL    fSetAlways
)
{
    // OVERRIDE:  just get the user to override this if they want to never
    // be activated
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QuickActivate    [IQuickActivate]
//=--------------------------------------------------------------------------=
// allows the container to activate the control.
//
// Parameters:
//    QACONTAINER *        - [in]  info about the container
//    QACONTROL *          - [out] info about the control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QuickActivate
(
    QACONTAINER *pContainer,
    QACONTROL *pControl
)
{
    HRESULT hr;
    DWORD   dw;

    // we need these guys.
    //
    if (!pContainer) return E_UNEXPECTED;
    if (!pControl) return E_UNEXPECTED;

    // start grabbing things from the QACONTAINER structure and apply them
    // as relevant
    //
    if (pContainer->cbSize < sizeof(QACONTAINER)) return E_UNEXPECTED;
    if (pControl->cbSize < sizeof(QACONTROL)) return E_UNEXPECTED;

    // save out the client site, of course.
    //
    if (pContainer->pClientSite) {
        hr = SetClientSite(pContainer->pClientSite);
        RETURN_ON_FAILURE(hr);
    }

    // if the lcid is not LANG_NEUTRAL, score!
    //
    if (pContainer->lcid) {
        g_lcidLocale = pContainer->lcid;
        g_fHaveLocale = TRUE;
    }

    // pay attention to some ambients
    //
    if (pContainer->dwAmbientFlags & QACONTAINER_MESSAGEREFLECT) {
        m_fHostReflects = TRUE;
        m_fCheckedReflecting = TRUE;
    }

    // hook up some notifications.  first property notifications.
    //
    if (pContainer->pPropertyNotifySink) {
        pContainer->pPropertyNotifySink->AddRef();
        hr = m_cpPropNotify.AddSink((void *)pContainer->pPropertyNotifySink, &pControl->dwPropNotifyCookie);
        if (FAILED(hr)) {
            pContainer->pPropertyNotifySink->Release();
            return hr;
        }
    }

    // then the event sink.
    //
    if (pContainer->pUnkEventSink) {
        hr = m_cpEvents.Advise(pContainer->pUnkEventSink, &pControl->dwEventCookie);
        if (FAILED(hr)) {
            pContainer->pUnkEventSink->Release();
            return hr;
        }
    }

    // finally, the advise sink.
    //
    if (pContainer->pAdviseSink) {
        // don't need to pass the cookie back since there can only be one
        // person advising at a time.
        //
        hr = Advise(pContainer->pAdviseSink, &dw);
        RETURN_ON_FAILURE(hr);
    }

    // set up a few things in the QACONTROL structure.  we're opaque by default
    //
    pControl->dwMiscStatus = OLEMISCFLAGSOFCONTROL(m_ObjectType);
    pControl->dwViewStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    pControl->dwPointerActivationPolicy = ACTIVATIONPOLICYOFCONTROL(m_ObjectType);

    // that's pretty much all we're interested in.  we will, however, pass on the
    // rest of the things to the end control writer and see if they want to do
    // anything with them. they shouldn't touch any of the above except for the
    // ambients.
    //
    return OnQuickActivate(pContainer, &(pControl->dwViewStatus));
}

//=--------------------------------------------------------------------------=
// COleControl::SetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to set the content extent of the control.
//
// Parameters:
//    LPSIZEL            - [in] the size of the content extent
//
// Output:
//    HRESULT            - S_OK, or E_FAIL for fixed size control
//
// Notes:
//
STDMETHODIMP COleControl::SetContentExtent
(
    LPSIZEL pSize
)
{
    return SetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::GetContentExtent    [IQuickActivate]
//=--------------------------------------------------------------------------=
// the container calls this to get the content extent of the control
//
// Parameters:
//    LPSIZEL        - [out] returns current size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetContentExtent
(
    LPSIZEL pSize
)
{
    return GetExtent(DVASPECT_CONTENT, pSize);
}

//=--------------------------------------------------------------------------=
// COleControl::OnQuickActivate    [overridable]
//=--------------------------------------------------------------------------=
// not all the of the members of the QACONTAINER need to be consumed by the
// framework, but are, at least, extremely interesting.  thus, we will pass
// on the struture to the end control writer, and let them consume these.
//
// Parameters:
//    QACONTAINER *            - [in]  contains additional information
//    DWORD *                  - [out] put ViewStatus flags here.
//
// Output:
//    HRESULT
//
// Notes:
//    - control writers should only look at/consume:
//        a. dwAmbientFlags
//        b. colorFore/colorBack
//        c. pFont
//        d. pUndoMgr
//        e. dwAppearance
//        f. hpal
//
//    - all the others are set up the for the user by the framework.
//    - control writers should set up the pdwViewStatus with flags as per
//      IViewObjectEx::GetViewStatus.  if you don't know what this is or don't
//      care, then don't touch.
//
HRESULT COleControl::OnQuickActivate
(
    QACONTAINER *pContainer,
    DWORD       *pdwViewStatus
)
{
    // by default, nuthin much to do!
    //
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ctlview.cpp ===
//=--------------------------------------------------------------------------=
// CtlView.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of the IViewObjectEx interface, which is a moderately
// non-trivial bunch of code.
//
#include "IPServer.H"

#include "CtrlObj.H"
#include "Globals.H"
#include "Util.H"

// for ASSERT and FAIL
//
SZTHISFILE

// local functions we're going to find useful
//
HDC _CreateOleDC(DVTARGETDEVICE *ptd);

//=--------------------------------------------------------------------------=
// COleControl::Draw    [IViewObject2]
//=--------------------------------------------------------------------------=
// Draws a representation of an object onto the specified device context. 
//
// Parameters:
//    DWORD                - [in] draw aspect
//    LONG                 - [in] part of object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in] specifies the target device
//    HDC                  - [in] information context for target device
//    HDC                  - [in] target device context
//    LPCRECTL             - [in] rectangle in which the object is drawn
//    LPCRECTL             - [in] window extent and origin for metafiles
//    BOOL (*)(DWORD)      - [in] callback for continuing or cancelling drawing
//    DWORD                - [in] parameter to pass to callback.
//
// Output:
//    HRESULT
//
// Notes:
//    - we support the following OCX 96 extensions
//        a. flicker free drawing [multi-pass drawing]
//        b. pvAspect != NULL for optimized DC handling
//        c. prcBounds == NULL for windowless inplace active objects
//
STDMETHODIMP COleControl::Draw
(
    DWORD            dwDrawAspect,
    LONG             lIndex,
    void            *pvAspect,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    HDC              hdcDraw,
    LPCRECTL         prcBounds,
    LPCRECTL         prcWBounds,
    BOOL (__stdcall *pfnContinue)(ULONG_PTR dwContinue),
    ULONG_PTR        dwContinue
)
{
    HRESULT hr;
    RECTL rc;
    POINT pVp, pW;
    BOOL  fOptimize = FALSE;
    int iMode;
    BYTE fMetafile = FALSE;
    BYTE fDeleteDC = FALSE;

    // support the aspects required for multi-pass drawing
    //
    switch (dwDrawAspect) {
        case DVASPECT_CONTENT:
        case DVASPECT_OPAQUE:
        case DVASPECT_TRANSPARENT:
            break;
        default:
            return DV_E_DVASPECT;
    }

    // first, have to do a little bit to support printing.
    //
    if (GetDeviceCaps(hdcDraw, TECHNOLOGY) == DT_METAFILE) {

        // We are dealing with a metafile.
        //
        fMetafile = TRUE;

        // If attributes DC is NULL, create one, based on ptd.
        //
        if (!hicTargetDevice) {

            // Does _CreateOleDC have to return an hDC
            // or can it be flagged to return an hIC 
            // for this particular case?
            //
            hicTargetDevice = _CreateOleDC(ptd);
            fDeleteDC = TRUE;
        }
    }

    // check to see if we have any flags passed in the pvAspect parameter.
    //
    if (pvAspect && ((DVASPECTINFO *)pvAspect)->cb == sizeof(DVASPECTINFO))
        fOptimize = (((DVASPECTINFO *)pvAspect)->dwFlags & DVASPECTINFOFLAG_CANOPTIMIZE) ? TRUE : FALSE;

    // if we are windowless, then we just pass this on to the end control code.
    //
    if (m_fInPlaceActive) {

        // give them a rectangle with which to draw
        //
        //ASSERT(!m_fInPlaceActive || !prcBounds, "Inplace active and somebody passed in prcBounds!!!");
        if (prcBounds)
		memcpy(&rc, prcBounds, sizeof(rc));
	else
		memcpy(&rc, &m_rcLocation, sizeof(rc));
    } else {

        // first -- convert the DC back to MM_TEXT mapping mode so that the
        // window proc and OnDraw can share the same painting code.  save
        // some information on it, so we can restore it later [without using
        // a SaveDC/RestoreDC]
        //
        rc = *prcBounds;

        // Don't do anything to hdcDraw if it's a metafile.
        // The control's Draw method must make the appropriate
        // accomodations for drawing to a metafile
        //
        if (!fMetafile) {
            LPtoDP(hdcDraw, (POINT *)&rc, 2);
            SetViewportOrgEx(hdcDraw, 0, 0, &pVp);
            SetWindowOrgEx(hdcDraw, 0, 0, &pW);
            iMode = SetMapMode(hdcDraw, MM_TEXT);
        }
    }

    // prcWBounds is NULL and not used if we are not dealing with a metafile.
    // For metafiles, we pass on rc as *prcBounds, we should also include
    // prcWBounds
    //
    hr = OnDraw(dwDrawAspect, hdcDraw, &rc, prcWBounds, hicTargetDevice, fOptimize);

    // clean up the DC when we're done with it, if appropriate.
    //
    if (!m_fInPlaceActive) {
        SetViewportOrgEx(hdcDraw, pVp.x, pVp.y, NULL);
        SetWindowOrgEx(hdcDraw, pW.x, pW.y, NULL);
        SetMapMode(hdcDraw, iMode);
    }

    // if we created a dc, blow it away now
    //
    if (fDeleteDC && hicTargetDevice) DeleteDC(hicTargetDevice);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::DoSuperClassPaint
//=--------------------------------------------------------------------------=
// design time painting of a subclassed control.
//
// Parameters:
//    HDC                - [in]  dc to work with
//    LPCRECTL           - [in]  rectangle to paint to.  should be in pixels
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::DoSuperClassPaint
(
    HDC      hdc,
    LPCRECTL prcBounds
)
{
    HWND hwnd;
    RECT rcClient;
    int  iMapMode;
    POINT ptWOrg, ptVOrg;
    SIZE  sWOrg, sVOrg;

    // make sure we have a window.
    //
    hwnd = CreateInPlaceWindow(0,0, FALSE);
    if (!hwnd)
        return E_FAIL;

    GetClientRect(hwnd, &rcClient);

    // set up the DC for painting.  this code largely taken from the MFC CDK
    // DoSuperClassPaint() fn.  doesn't always get things like command
    // buttons quite right ...
    //
    // NOTE: there is a windows 95 problem in which the font instance manager
    // will leak a bunch of bytes in the global GDI pool whenever you 
    // change your extents and have an active font.  this code gets around
    // this for on-screen cases, but not for printing [which shouldn't be
    // too serious, because you're not often changing your control size and
    // printing rapidly in succession]
    //
    if ((rcClient.right - rcClient.left != prcBounds->right - prcBounds->left)
        && (rcClient.bottom - rcClient.top != prcBounds->bottom - prcBounds->top)) {

        iMapMode = SetMapMode(hdc, MM_ANISOTROPIC);
        SetWindowExtEx(hdc, rcClient.right, rcClient.bottom, &sWOrg);
        SetViewportExtEx(hdc, prcBounds->right - prcBounds->left, prcBounds->bottom - prcBounds->top, &sVOrg);
    }

    SetWindowOrgEx(hdc, 0, 0, &ptWOrg);
    SetViewportOrgEx(hdc, prcBounds->left, prcBounds->top, &ptVOrg);

#if STRICT
    CallWindowProc((WNDPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#else
    CallWindowProc((FARPROC)SUBCLASSWNDPROCOFCONTROL(m_ObjectType), hwnd, (g_fSysWin95Shell) ? WM_PRINT : WM_PAINT, (WPARAM)hdc, (LPARAM)(g_fSysWin95Shell ? PRF_CHILDREN | PRF_CLIENT : 0));
#endif // STRICT

    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::GetColorSet    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the logical palette that the control will use for drawing in its
// IViewObject::Draw method with the corresponding parameters.
//
// Parameters:
//    DWORD                - [in]  how the object is to be represented
//    LONG                 - [in]  part of the object to draw [not relevant]
//    void *               - NULL
//    DVTARGETDEVICE *     - [in]  specifies the target device
//    HDC                  - [in]  information context for the target device
//    LOGPALETTE **        - [out] where to put palette
//
// Output:
//    S_OK                 - Control has a palette, and returned it through the out param.
//    S_FALSE              - Control does not currently have a palette.
//    E_NOTIMPL            - Control will never have a palette so optimize handling of this control.
//
// Notes:
//
STDMETHODIMP COleControl::GetColorSet
(
    DWORD            dwDrawAspect,
    LONG             lindex,
    void            *IgnoreMe,
    DVTARGETDEVICE  *ptd,
    HDC              hicTargetDevice,
    LOGPALETTE     **ppColorSet
)
{
    if (dwDrawAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *ppColorSet = NULL;
    return (OnGetPalette(hicTargetDevice, ppColorSet)) ? ((*ppColorSet) ? S_OK : S_FALSE) : E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Freeze    [IViewObject2]
//=--------------------------------------------------------------------------=
// Freezes a certain aspect of the object's presentation so that it does not
// change until the IViewObject::Unfreeze method is called.
//
// Parameters:
//    DWORD            - [in] aspect
//    LONG             - [in] part of object to draw
//    void *           - NULL
//    DWORD *          - [out] for Unfreeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Freeze
(
    DWORD   dwDrawAspect,
    LONG    lIndex,
    void   *IgnoreMe,
    DWORD  *pdwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Unfreeze    [IVewObject2]
//=--------------------------------------------------------------------------=
// Releases a previously frozen drawing. The most common use of this method
// is for banded printing.
//
// Parameters:
//    DWORD        - [in] cookie from freeze
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Unfreeze
(
    DWORD dwFreeze
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::SetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Sets up a connection between the control and an advise sink so that the
// advise sink can be notified about changes in the control's view.
//
// Parameters:
//    DWORD            - [in] aspect
//    DWORD            - [in] info about the sink
//    IAdviseSink *    - [in] the sink
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SetAdvise
(
    DWORD        dwAspects,
    DWORD        dwAdviseFlags,
    IAdviseSink *pAdviseSink
)
{
    // if it's not a content aspect, we don't support it.
    //
    if (!(dwAspects & DVASPECT_CONTENT)) {
        return DV_E_DVASPECT;
    }

    // set up some flags  [we gotta stash for GetAdvise ...]
    //
    m_fViewAdvisePrimeFirst = (dwAdviseFlags & ADVF_PRIMEFIRST) ? TRUE : FALSE;
    m_fViewAdviseOnlyOnce = (dwAdviseFlags & ADVF_ONLYONCE) ? TRUE : FALSE;

    RELEASE_OBJECT(m_pViewAdviseSink);
    m_pViewAdviseSink = pAdviseSink;
    ADDREF_OBJECT(m_pViewAdviseSink);

    // prime them if they want it [we need to store this so they can get flags later]
    //
    if (m_fViewAdvisePrimeFirst)
        ViewChanged();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetAdvise    [IViewObject2]
//=--------------------------------------------------------------------------=
// Retrieves the existing advisory connection on the control if there is one.
// This method simply returns the parameters used in the most recent call to
// the IViewObject::SetAdvise method.
//
// Parameters:
//    DWORD *            - [out]  aspects
//    DWORD *            - [out]  advise flags
//    IAdviseSink **     - [out]  the sink
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP COleControl::GetAdvise
(
    DWORD        *pdwAspects,
    DWORD        *pdwAdviseFlags,
    IAdviseSink **ppAdviseSink
)
{
    // if they want it, give it to them
    //
    if (pdwAspects)
        *pdwAspects = DVASPECT_CONTENT;

    if (pdwAdviseFlags) {
        *pdwAdviseFlags = 0;
        if (m_fViewAdviseOnlyOnce) *pdwAdviseFlags |= ADVF_ONLYONCE;
        if (m_fViewAdvisePrimeFirst) *pdwAdviseFlags |= ADVF_PRIMEFIRST;
    }

    if (ppAdviseSink) {
        *ppAdviseSink = m_pViewAdviseSink;
        ADDREF_OBJECT(*ppAdviseSink);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetExtent    [IViewObject2]
//=--------------------------------------------------------------------------=
// Returns the size that the control will be drawn on the
// specified target device.
//
// Parameters:
//    DWORD            - [in] draw aspect
//    LONG             - [in] part of object to draw
//    DVTARGETDEVICE * - [in] information about target device
//    LPSIZEL          - [out] where to put the size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetExtent
(
    DWORD           dwDrawAspect,
    LONG            lindex,
    DVTARGETDEVICE *ptd,
    LPSIZEL         psizel
)
{
    // we already have an implementation of this [from IOleObject]
    //
    return GetExtent(dwDrawAspect, psizel);
}


//=--------------------------------------------------------------------------=
// COleControl::OnGetPalette    [overridable]
//=--------------------------------------------------------------------------=
// called when the host wants palette information.  ideally, people should use
// this sparingly and carefully.
//
// Parameters:
//    HDC            - [in]  HIC for the target device
//    LOGPALETTE **  - [out] where to put the palette
//
// Output:
//    BOOL           - TRUE means we processed it, false means nope.
//
// Notes:
//
BOOL COleControl::OnGetPalette
(
    HDC          hicTargetDevice,
    LOGPALETTE **ppColorSet
)
{
    return FALSE;
}


//=--------------------------------------------------------------------------=
// COleControl::GetRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns a rectnagle describing a given drawing aspect
//
// Parameters:
//    DWORD             - [in]  aspect
//    LPRECTL           - [out] region rectangle
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetRect
(
    DWORD    dvAspect,
    LPRECTL  prcRect
)
{
    RECTL rc;
    BOOL  f;

    // call the user routine and let them return the size
    //
    f = OnGetRect(dvAspect, &rc);
    if (!f) return DV_E_DVASPECT;

    // transform these dudes.
    //
    PixelToHiMetric((LPSIZEL)&rc, (LPSIZEL)prcRect);
    PixelToHiMetric((LPSIZEL)((LPBYTE)&rc + sizeof(SIZEL)), (LPSIZEL)((LPBYTE)prcRect + sizeof(SIZEL)));

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetViewStatus    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// returns information about the opactiy of the object and what drawing
// aspects are supported
//
// Parameters:
//    DWORD *            - [out] the status
//
/// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetViewStatus
(
    DWORD *pdwStatus
)
{
    // depending on the flag in the CONTROLOBJECTINFO structure, indicate our
    // transparency vs opacity.
    // OVERRIDE:  controls that wish to support multi-pass drawing should
    // override this routine and return, in addition to the flags indication
    // opacity, flags indicating what sort of drawing aspects they support.
    //
    *pdwStatus = FCONTROLISOPAQUE(m_ObjectType) ? VIEWSTATUS_OPAQUE : 0;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitPoint    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates whether a point is within a given aspect of an object.
//
// Parameters:
//    DWORD                - [in]  aspect
//    LPCRECT              - [in]  Bounds rectangle
//    POINT                - [in]  hit location client coordinates
//    LONG                 - [in]  what the container considers close
//    DWORD *              - [out] info about the hit
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitPoint
(
    DWORD    dvAspect,
    LPCRECT  prcBounds,
    POINT    ptLocation,
    LONG     lCloseHint,
    DWORD   *pdwHitResult
)
{
    // OVERRIDE: override me if you want to provide additional [non-opaque]
    // functionality
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = PtInRect(prcBounds, ptLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::QueryHitRect    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// indicates wheter any point in a rectangle is within a given drawing aspect
// of an object.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LPCRECT          - [in]  bounds
//    LPCRECT          - [in]  location
//    LONG             - [in]  what host considers close
//    DWORD *          - [out] hit result
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::QueryHitRect
(
    DWORD     dvAspect,
    LPCRECT   prcBounds,
    LPCRECT   prcLocation,
    LONG      lCloseHint,
    DWORD    *pdwHitResult
)
{
    RECT rc;

    // OVERRIDE: override this for additional behaviour
    //
    if (dvAspect != DVASPECT_CONTENT)
        return DV_E_DVASPECT;

    *pdwHitResult = IntersectRect(&rc, prcBounds, prcLocation) ? HITRESULT_HIT : HITRESULT_OUTSIDE;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetNaturalExtent    [IViewObjectEx]
//=--------------------------------------------------------------------------=
// supports two types of control sizing, content and integral.
//
// Parameters:
//    DWORD            - [in]  aspect
//    LONG             - [in]  index
//    DVTARGETDEVICE * - [in]  target device information
//    HDC              - [in]  HIC
//    DVEXTENTINFO *   - [in]  sizing data
//    LPSIZEL          - [out] sizing data retunred by control
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetNaturalExtent
(
    DWORD           dvAspect,
    LONG            lIndex,
    DVTARGETDEVICE *ptd,
    HDC             hicTargetDevice,
    DVEXTENTINFO   *pExtentInfo,
    LPSIZEL         pSizel
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::OnGetRect    [overridable
//=--------------------------------------------------------------------------=
// returns our rectangle
//
// Parameters:
//    DWORD              - [in]  aspect they want the rect for
//    RECTL *            - [out] the rectangle that matches this aspect
//
// Output:
//    BOOL               - false means we don't like the aspect
//
// Notes:
//
BOOL COleControl::OnGetRect
(
    DWORD   dvAspect,
    RECTL  *pRect
)
{
    // by default, we only support content drawing.
    //
    if (dvAspect != DVASPECT_CONTENT)
        return FALSE;

    // just give them our bounding rectangle
    //
    *((LPRECT)pRect) = m_rcLocation;
    return TRUE;
}

//=--------------------------------------------------------------------------=
// _CreateOleDC
//=--------------------------------------------------------------------------=
// creates an HDC given a DVTARGETDEVICE structure.
//
// Parameters:
//    DVTARGETDEVICE *              - [in] duh.
//
// Output:
//    HDC
//
// Notes:
//
HDC _CreateOleDC
(
    DVTARGETDEVICE *ptd
)
{
    LPDEVMODEW   pDevModeW;
    DEVMODEA     DevModeA, *pDevModeA;
    LPOLESTR     lpwszDriverName;
    LPOLESTR     lpwszDeviceName;
    LPOLESTR     lpwszPortName;
    HDC          hdc;

    // return screen DC for NULL target device
    //
    if (!ptd)
        return CreateDC("DISPLAY", NULL, NULL, NULL);

    if (ptd->tdExtDevmodeOffset == 0)
        pDevModeW = NULL;
    else
        pDevModeW = (LPDEVMODEW)((LPSTR)ptd + ptd->tdExtDevmodeOffset);

    lpwszDriverName = (LPOLESTR)((BYTE*)ptd + ptd->tdDriverNameOffset);
    lpwszDeviceName = (LPOLESTR)((BYTE*)ptd + ptd->tdDeviceNameOffset);
    lpwszPortName   = (LPOLESTR)((BYTE*)ptd + ptd->tdPortNameOffset);

    MAKE_ANSIPTR_FROMWIDE(pszDriverName, lpwszDriverName);
    MAKE_ANSIPTR_FROMWIDE(pszDeviceName, lpwszDeviceName);
    MAKE_ANSIPTR_FROMWIDE(pszPortName,   lpwszPortName);

    // 
    //
    if (pDevModeW) {
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmDeviceName, -1, (LPSTR)DevModeA.dmDeviceName, CCHDEVICENAME, NULL, NULL);
	memcpy(&DevModeA.dmSpecVersion, &pDevModeW->dmSpecVersion,
		offsetof(DEVMODEA, dmFormName) - offsetof(DEVMODEA, dmSpecVersion));
        WideCharToMultiByte(CP_ACP, 0, pDevModeW->dmFormName, -1, (LPSTR)DevModeA.dmFormName, CCHFORMNAME, NULL, NULL);
	memcpy(&DevModeA.dmLogPixels, &pDevModeW->dmLogPixels, sizeof(DEVMODEA) - offsetof(DEVMODEA, dmLogPixels));
        if (pDevModeW->dmDriverExtra) {
            pDevModeA = (DEVMODEA *)HeapAlloc(g_hHeap, 0, sizeof(DEVMODEA) + pDevModeW->dmDriverExtra);
            if (!pDevModeA) return NULL;
            memcpy(pDevModeA, &DevModeA, sizeof(DEVMODEA));
            memcpy(pDevModeA + 1, pDevModeW + 1, pDevModeW->dmDriverExtra);
        } else
            pDevModeA = &DevModeA;

	DevModeA.dmSize = sizeof(DEVMODEA);
    } else
        pDevModeA = NULL;

    hdc = CreateDC(pszDriverName, pszDeviceName, pszPortName, pDevModeA);
    if ((pDevModeA != &DevModeA) && pDevModeA) HeapFree(g_hHeap, 0, pDevModeA);
    return hdc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ctlpsst.cpp ===
//=--------------------------------------------------------------------------=
// CtlPsst.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of persistence interfaces for COleControl.
//
#include "IPServer.H"
#include "CtrlObj.H"

#include "CtlHelp.H"
#include "Util.H"

// this is the name of the stream we'll save our ole controls to.
//
const WCHAR wszCtlSaveStream [] = L"CONTROLSAVESTREAM";

// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// to help with out stream save implementation ...
//
#define STREAMHDR_SIGNATURE 0x12344321  // Signature to identify our format (avoid crashes!)
#define IPROP_END 0xFF                  // Marker at end of property list
#define MAXAUTOBUF 3800                 // Best if < 1 page.

typedef struct tagSTREAMHDR {

    DWORD  dwSignature;     // Signature.
    size_t cbWritten;       // Number of bytes written

} STREAMHDR;

//=--------------------------------------------------------------------------=
// COleControl persistence interfaces
//=--------------------------------------------------------------------------=


//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// IPersistPropertyBag.  we've got a property bag, so let's load our properties
// from it.
//
// Parameters:
//    IPropertyBag *      - [in] pbag from which to read props.
//    IErrorLog *         - [in] error log to write to
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    HRESULT hr;

    // load in our standard state first.  nothing serious here ... currently,
    // we've just got two properties, for cx and cy.
    //
    hr = LoadStandardState(pPropertyBag, pErrorLog);
    RETURN_ON_FAILURE(hr);

    // now call the user text load function, and get them to load in whatever
    // they're interested in.
    //
    hr = LoadTextState(pPropertyBag, pErrorLog);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistPropertyBag]
//=--------------------------------------------------------------------------=
// given a property bag, save out all the relevant state information.
//
// Parameters:
//    IPropertyBag *        - [in] property to write to
//    BOOL                  - [in] do we clear the dirty bit?
//    BOOL                  - [in] do we write out default values anyhoo?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IPropertyBag *pPropertyBag,
    BOOL          fClearDirty,
    BOOL          fWriteDefault
)
{
    HRESULT hr;

    // save out standard state information
    //
    hr = SaveStandardState(pPropertyBag);
    RETURN_ON_FAILURE(hr);

    // now call the user function and get them to save out
    // all of their properties.
    //
    hr = SaveTextState(pPropertyBag, fWriteDefault);
    RETURN_ON_FAILURE(hr);

    // now clear the dirty flag and send out notification that we're
    // done.
    //
    if (fClearDirty)
        m_fDirty = FALSE;

    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::GetClassID    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// returns the classid of this mamma
//
// Parameters:
//    CLSID *         - [out] where to put the clsid
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetClassID
(
    CLSID *pclsid
)
{
    CHECK_POINTER(pclsid);

    // copy the thing over
    //
    *pclsid = CLSIDOFOBJECT(m_ObjectType);
    return S_OK;
}


//=--------------------------------------------------------------------------=
// COleControl::IsDirty    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// asks if we're dirty or not.  duh.
//
// Output:
//    HRESULT        - S_OK: dirty, S_FALSE: not dirty
//
// Notes:
//
STDMETHODIMP COleControl::IsDirty
(
    void
)
{
    return (m_fDirty) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// causes the control to intialize itself with a new bunch of state information
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    void
)
{
    BOOL f;

    // call the overridable function to do this work
    //
    f = InitializeNewState();
    return (f) ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// COleControl::GetSizeMax    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
//
// Parameters:
//    ULARGE_INTEGER *    - [out]
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::GetSizeMax
(
    ULARGE_INTEGER *pulMaxSize
)
{
    return E_NOTIMPL;
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// load from an IStream
//
// Parameters:
//    IStream *    - [in] stream from which to load
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load
(
    IStream *pStream
)
{
    HRESULT hr;

    // first thing to do is read in standard properties the user don't
    // persist themselves.
    //
    hr = LoadStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // load in the user properties.  this method is one they -have- to implement
    // themselves.
    //
    hr = LoadBinaryState(pStream);
    
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStreamInit]
//=--------------------------------------------------------------------------=
// saves out our state using streams
//
// Parameters:
//    IStream *        - [in]
//    BOOL             - [in] clear dirty bit?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStream *pStream,
    BOOL     fClearDirty
)
{
    HRESULT hr;

    // use our helper routine that we share with the IStorage persistence
    // code.
    //
    hr = m_SaveToStream(pStream);
    RETURN_ON_FAILURE(hr);

    // clear out dirty flag [if appropriate] and notify that we're done
    // with save.
    //
    if (fClearDirty)
        m_fDirty = FALSE;
    if (m_pOleAdviseHolder)
        m_pOleAdviseHolder->SendOnSave();

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::InitNew    [IPersistStorage]
//=--------------------------------------------------------------------------=
// ipersiststorage version of this.  fweee
//
// Parameters:
//    IStorage *    - [in] we don't use this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::InitNew
(
    IStorage *pStorage
)
{
    // we already have an implementation of this [for IPersistStreamInit]
    //
    return InitNew();
}

//=--------------------------------------------------------------------------=
// COleControl::Load    [IPersistStorage]
//=--------------------------------------------------------------------------=
// Ipersiststorage version of this
//
// Parameters:
//    IStorage *    - [in] DUH.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Load(IStorage *pStorage)
{
    IStream *pStream;
    HRESULT  hr;

    // we're going to use IPersistStream::Load from the CONTENTS stream.
    //
    hr = pStorage->OpenStream(wszCtlSaveStream, 0, STGM_READ | STGM_SHARE_EXCLUSIVE, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // IPersistStreamInit::Load
    //
    hr = Load(pStream);
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::Save    [IPersistStorage]
//=--------------------------------------------------------------------------=
// save into the contents stream of the given storage object.
//
// Parameters:
//    IStorage *        - [in] 10 points if you figure it out
//    BOOL              - [in] is the storage the same as the load storage?
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::Save
(
    IStorage *pStorage,
    BOOL      fSameAsLoad
)
{
    IStream *pStream;
    HRESULT  hr;

    // we're just going to save out to the CONTENTES stream.
    //
    hr = pStorage->CreateStream(wszCtlSaveStream, STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
                                0, 0, &pStream);
    RETURN_ON_FAILURE(hr);

    // use our helper routine.
    //
    hr = m_SaveToStream(pStream);
    m_fSaveSucceeded = (FAILED(hr)) ? FALSE : TRUE;
    pStream->Release();
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveCompleted    [IPersistStorage]
//=--------------------------------------------------------------------------=
// lets us clear out our flags.
//
// Parameters:
//    IStorage *    - ignored
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP COleControl::SaveCompleted
(
    IStorage *pStorageNew
)
{
    // if our save succeeded, then we can do our post save work.
    //
    if (m_fSaveSucceeded) {
        m_fDirty = FALSE;
        if (m_pOleAdviseHolder)
            m_pOleAdviseHolder->SendOnSave();
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::HandsOffStorage    [IPersistStorage]
//=--------------------------------------------------------------------------=
// not interesting
//
// Output:
//    S_OK
//
// Notes:
//
STDMETHODIMP COleControl::HandsOffStorage
(
    void
)
{
    // we don't ever hold on to  a storage pointer, so this is remarkably
    // uninteresting to us.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::m_SaveToStream    [helper: IPersistStreamInit/IPersistStorage]
//=--------------------------------------------------------------------------=
// save ourselves to a stream
//
// Parameters:
//    IStream *        - figure it out
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::m_SaveToStream
(
    IStream *pStream
)
{
    HRESULT hr;

    // save out standard state information that the user has no control
    // over
    //
    hr = SaveStandardState(pStream);
    RETURN_ON_FAILURE(hr);

    // save out user-specific satte information.  they MUST implement this
    // function
    //
    hr = SaveBinaryState(pStream);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// text persistence APIs.  there is another version for streams.
//
// Parameters:
//    IPropertyBag *    - [in]
//    IErrorLog *       - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IPropertyBag *pPropertyBag,
    IErrorLog    *pErrorLog
)
{
    VARIANT v;
    HRESULT hr;
    SIZEL   slHiMetric = { 100, 50 };

    // currently, our only standard properties are related to size.
    // if we can't find them, then we'll just use some defaults.
    //
    v.vt = VT_I4;
    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentX", &v, pErrorLog);
    if (SUCCEEDED(hr)) slHiMetric.cx = v.lVal;

    v.lVal = 0;
    hr = pPropertyBag->Read(L"_ExtentY", &v, pErrorLog);
    if (SUCCEEDED(hr)) slHiMetric.cy = v.lVal;

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::LoadStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// reads in standard properties that all controls are going to have, using
// stream persistence APIs.  there is another version for text.
//
// Parameters:
//    IStream *         - [in] 
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::LoadStandardState
(
    IStream *pStream
)
{
    STREAMHDR stmhdr;
    HRESULT hr;
    SIZEL   slHiMetric;

    // look for our header structure, so we can verify stream validity.
    //
    hr = pStream->Read(&stmhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    if (stmhdr.dwSignature != STREAMHDR_SIGNATURE)
        return E_UNEXPECTED;

    // currently, the only standard state we're writing out is
    // a SIZEL structure describing the control's size.
    //
    if (stmhdr.cbWritten != sizeof(m_Size))
        return E_UNEXPECTED;

    // we like the stream.  let's go load in our two properties.
    //
    hr = pStream->Read(&slHiMetric, sizeof(slHiMetric), NULL);
    RETURN_ON_FAILURE(hr);

    HiMetricToPixel(&slHiMetric, &m_Size);
    return S_OK;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using text
// persistence APIs.  there is another version for stream persistence.
//
// Parameters:
//    IPropertyBag *        - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IPropertyBag *pPropertyBag
)
{
    HRESULT hr;
    VARIANT v;
    SIZEL   slHiMetric;

    // currently, the only standard proprerties we persist are Size related
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    v.vt = VT_I4;
    v.lVal = slHiMetric.cx;

    hr = pPropertyBag->Write(L"_ExtentX", &v);
    RETURN_ON_FAILURE(hr);

    v.lVal = slHiMetric.cy;

    hr = pPropertyBag->Write(L"_ExtentY", &v);

    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::SaveStandardState    [ helper ]
//=--------------------------------------------------------------------------=
// saves out standard properties that we're managing for a control using stream
// persistence APIs.  there is another version for text persistence.
//
// Parameters:
//    IStream *            - [in]
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT COleControl::SaveStandardState
(
    IStream *pStream
)
{
    STREAMHDR streamhdr = { STREAMHDR_SIGNATURE, sizeof(SIZEL) };
    HRESULT hr;
    SIZEL   slHiMetric;


    // first thing to do is write out our stream hdr structure.
    //
    hr = pStream->Write(&streamhdr, sizeof(STREAMHDR), NULL);
    RETURN_ON_FAILURE(hr);

    // the only properties we're currently persisting here are the size
    // properties for this control.  make sure we do that in HiMetric
    //
    PixelToHiMetric(&m_Size, &slHiMetric);

    hr = pStream->Write(&slHiMetric, sizeof(slHiMetric), NULL);
    return hr;
}

//=--------------------------------------------------------------------------=
// COleControl::InitializeNewState    [overridable]
//=--------------------------------------------------------------------------=
// the user can override this to initialize variables
//
// Output:
//    BOOL        - FALSE means couldn't do it.
//
// Notes:
//
BOOL COleControl::InitializeNewState
(
    void
)
{
    // we find this largely uninteresting
    //
    return TRUE;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\dwinvers.h ===
#define vszMakeDate	"April 10, 1996\0"
#define vszMakeVers	"Version 2810 - DEBUG - ntfs-f\0\0"
#define vszVersNum	"2810\0"
#define vszVersNumAll	"5.00.2810\0"
#define vusVersNuml2	10
#define vusVersNumf2	28
#define vszCopyright	"Copyright  1987-1996 Microsoft Corp.\0\0"
#define VBA_VERHI	0x50000
#define VBA_VERLO	0x183C
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\debug.cpp ===
//=--------------------------------------------------------------------------=
// Debug.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains various methods that will only really see any use in DEBUG builds
//
#ifdef DEBUG


#include "IPServer.H"
#include <stdlib.h>


//=--------------------------------------------------------------------------=
// Private Constants
//---------------------------------------------------------------------------=
//
static const char szFormat[]  = "%s\nFile %s, Line %d";
static const char szFormat2[] = "%s\n%s\nFile %s, Line %d";

#define _SERVERNAME_ "ActiveX Framework"

static const char szTitle[]  = _SERVERNAME_ " Assertion  (Abort = UAE, Retry = INT 3, Ignore = Continue)";


//=--------------------------------------------------------------------------=
// Local functions
//=--------------------------------------------------------------------------=
int NEAR _IdMsgBox(LPSTR pszText, LPCSTR pszTitle, UINT mbFlags);

//=--------------------------------------------------------------------------=
// DisplayAssert
//=--------------------------------------------------------------------------=
// Display an assert message box with the given pszMsg, pszAssert, source
// file name, and line number. The resulting message box has Abort, Retry,
// Ignore buttons with Abort as the default.  Abort does a FatalAppExit;
// Retry does an int 3 then returns; Ignore just returns.
//
VOID DisplayAssert
(
    LPSTR	 pszMsg,
    LPSTR	 pszAssert,
    LPSTR	 pszFile,
    UINT	 line
)
{
    char	szMsg[250];
    LPSTR	lpszText;

    lpszText = pszMsg;		// Assume no file & line # info

    // If C file assert, where you've got a file name and a line #
    //
    if (pszFile) {

        // Then format the assert nicely
        //
        wsprintf(szMsg, szFormat, (pszMsg&&*pszMsg) ? pszMsg : pszAssert, pszFile, line);
        lpszText = szMsg;
    }

    // Put up a dialog box
    //
    switch (_IdMsgBox(lpszText, szTitle, MB_ICONHAND|MB_ABORTRETRYIGNORE|MB_SYSTEMMODAL)) {
        case IDABORT:
            FatalAppExit(0, lpszText);
            return;

        case IDRETRY:
            // call the win32 api to break us.
            //
            DebugBreak();
            return;
    }

    return;
}


//=---------------------------------------------------------------------------=
// Beefed-up version of WinMessageBox.
//=---------------------------------------------------------------------------=
//
int NEAR _IdMsgBox
(
    LPSTR	pszText,
    LPCSTR	pszTitle,
    UINT	mbFlags
)
{
    HWND hwndActive;
    int  id;

    hwndActive = GetActiveWindow();

    id = MessageBox(hwndActive, pszText, pszTitle, mbFlags);

    return id;
}


#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ctlwrap.cpp ===
//=--------------------------------------------------------------------------=
// CtlWrap.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// wrappers for various routines that have slightly different implementations
// for windowed and windowless controls.
//
#include "IPServer.H"

#include "CtrlObj.H"


// for ASSERT and FAIL
//
SZTHISFILE

//=--------------------------------------------------------------------------=
// COleControl::OcxGetFocus    [wrapper]
//=--------------------------------------------------------------------------=
// indicates whether or not we have the focus.
//
// Parameters:
//    none
//
// Output:
//    TRUE if we have focus, else false
//
// Notes:
//
BOOL COleControl::OcxGetFocus
(
    void
)
{
    // if we're windowless, the site provides this functionality
    //
    if (m_pInPlaceSiteWndless) {
        return (m_pInPlaceSiteWndless->GetFocus() == S_OK);
    } else {

        // we've got a window.  just let the APIs do our work
        //
        if (m_fInPlaceActive)
            return (GetFocus() == m_hwnd);
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetWindowRect    [wrapper]
//=--------------------------------------------------------------------------=
// returns the current rectangle for this control, and correctly handles
// windowless vs windowed.
//
// Parameters:
//    LPRECT                - [out]  duh.
//
// Output:
//    BOOL                  - false means unexpected.
//
// Notes:
//
BOOL COleControl::OcxGetWindowRect
(
    LPRECT prc
)
{
    // if we're windowless, then we have this information already!
    //
    if (Windowless()) {
        *prc = m_rcLocation;
        return TRUE;
    } else
        return GetWindowRect(m_hwnd, prc);

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxDefWindowProc    [wrapper]
//=--------------------------------------------------------------------------=
// default window processing
//
// Parameters:
//    UINT           - [in] duh.
//    WPARAM         - [in] duh.
//    LPARAM         - [in] DUH.
//
// Output:
//    LRESULT
//
// Notes:
//
LRESULT COleControl::OcxDefWindowProc
(
    UINT   msg,
    WPARAM wParam,
    LPARAM lParam
)
{
    LRESULT l;

    // if we're windowless, this is a site provided pointer
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->OnDefWindowMessage(msg, wParam, lParam, &l);
    else
        // we've got a window -- just pass it along
        //
        l = DefWindowProc(m_hwnd, msg, wParam, lParam);

    return l;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetDC    [wrapper]
//=--------------------------------------------------------------------------=
// wraps the functionality of GetDC, and correctly handles windowless controls
//
// Parameters:
//    none
//
// Output:
//    HDC            - null means we couldn't get one
//
// Notes:
//    - we don't bother with a bunch of the IOleInPlaceSiteWindowless::GetDc
//      parameters, since the windows GetDC doesn't expose these either. users
//      wanting that sort of fine tuned control can call said routine
//      explicitly
//
HDC COleControl::OcxGetDC
(
    void
)
{
    HDC hdc = NULL;

    // if we're windowless, the site provides this functionality.
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->GetDC(NULL, 0, &hdc);
    else
        hdc = GetDC(m_hwnd);

    return hdc;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxReleaseDC    [wrapper]
//=--------------------------------------------------------------------------=
// releases a DC returned by OcxGetDC
//
// Parameters:
//    HDC             - [in] release me
//
// Output:
//    none
//
// Notes:
//
void COleControl::OcxReleaseDC
(
    HDC hdc
)
{
    // if we're windowless, the site does this for us
    //
    if (m_pInPlaceSiteWndless)
        m_pInPlaceSiteWndless->ReleaseDC(hdc);
    else
        ReleaseDC(m_hwnd, hdc);
}

//=--------------------------------------------------------------------------=
// COleControl::OcxSetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// provides a means for the control to get or release capture.
//
// Parameters:
//    BOOL            - [in] true means take, false release
//
// Output:
//    BOOL            - true means it's yours, false nuh-uh
//
// Notes:
//
BOOL COleControl::OcxSetCapture
(
    BOOL fGrab
)
{
    HRESULT hr;

    // the host does this for us if we're windowless [i'm getting really bored
    // of typing that]
    //
    if (m_pInPlaceSiteWndless) {
        hr = m_pInPlaceSiteWndless->SetCapture(fGrab);
        return (hr == S_OK);
    } else {
        // people shouldn't call this when they're not in-place active, but
        // just in case...
        //
        if (m_fInPlaceActive) {
            SetCapture(m_hwnd);
            return TRUE;
        } else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxGetCapture    [wrapper]
//=--------------------------------------------------------------------------=
// tells you whether or not you have the capture.
//
// Parameters:
//    none
//
// Output:
//    BOOL         - true it's yours, false it's not
//
// Notes:
//
BOOL COleControl::OcxGetCapture
(
    void
)
{
    // host does this for windowless dudes
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->GetCapture() == S_OK;
    else {
        // people shouldn't call this when they're not in-place active, but
        // just in case.
        //
        if (m_fInPlaceActive)
            return GetCapture() == m_hwnd;
        else
            return FALSE;
    }

    // dead code
}

//=--------------------------------------------------------------------------=
// COleControl::OcxInvalidateRect    [wrapper]
//=--------------------------------------------------------------------------=
// invalidates the control's rectangle
//
// Parameters:
//    LPCRECT            - [in] rectangle to invalidate
//    BOOL               - [in] do we erase background first?
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxInvalidateRect
(
    LPCRECT prcInvalidate,
    BOOL    fErase
)
{
    // if we're windowless, then we need to get the site to do all this for
    // us
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->InvalidateRect(prcInvalidate, fErase) == S_OK;
    else {
        // otherwise do something different depending on whether or not we're
        // in place active or not
        //
        if (m_fInPlaceActive)
            return InvalidateRect(m_hwnd, prcInvalidate, TRUE);
        else
            ViewChanged();
    }

    return TRUE;
}

//=--------------------------------------------------------------------------=
// COleControl::OcxScrollRect    [wrapper]
//=--------------------------------------------------------------------------=
// does some window scrolling for the control
//
// Parameters:
//    LPCRECT             - [in] region to scroll
//    LPCRECT             - [in] region to clip
//    int                 - [in] dx to scroll
//    int                 - [in] dy to scroll
//
// Output:
//    BOOL
//
// Notes:
//
BOOL COleControl::OcxScrollRect
(
    LPCRECT  prcBounds,
    LPCRECT  prcClip,
    int      dx,
    int      dy
)
{
    // if we're windowless, the site provides this functionality, otherwise
    // APIs do the job
    //
    if (m_pInPlaceSiteWndless)
        return m_pInPlaceSiteWndless->ScrollRect(dx, dy, prcBounds, prcClip) == S_OK;
    else {
        if (m_fInPlaceActive) 
            ScrollWindowEx(m_hwnd, dx, dy, prcBounds, prcClip, NULL, NULL, SW_INVALIDATE);
        else
            return FALSE;
    }

    return TRUE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\globals.cpp ===
//=--------------------------------------------------------------------------=
// Globals.C
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains global variables and strings and the like that just don't fit
// anywhere else.
//
#include "IPServer.H"

//=--------------------------------------------------------------------------=
// support for licensing
//
BOOL g_fMachineHasLicense;
BOOL g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
BOOL g_fServerHasTypeLibrary = TRUE;

//=--------------------------------------------------------------------------=
// our instance handles
//
HINSTANCE    g_hInstance;
HINSTANCE    g_hInstResources;
VARIANT_BOOL g_fHaveLocale;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
CRITICAL_SECTION    g_CriticalSection;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
BOOL    g_fSysWin95;                    // we're under Win95 system, not just NT SUR
BOOL    g_fSysWinNT;                    // we're under some form of Windows NT
BOOL    g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\extobj.cpp ===
////
//
// CExpandoObject
//
// Notes:
// 1) If the LCID passed to this object changes from call to call we are in trouble. This is hard to
// create an ASSERT for because it would require memoizing the LCID at some point.
// 2) There is a maximum on the number of slots allowed (this is currently 2048)
// 3) This is not a thread safe structure.
// 4) I'm currently using malloc -- this is probably wrong for IE.
//

// for ASSERT and FAIL
//

#include "IPServer.H"
#include "LocalSrv.H"
#include "Globals.H"
#include "extobj.h"
#include "Util.H"
#define GTR_MALLOC(size)  CoTaskMemAlloc(size)
#define GTR_FREE(pv) CoTaskMemFree(pv)

SZTHISFILE
////
//
// Private Utility Functions
//
////

////
//
// Get the ID of a Name
//

HRESULT CExpandoObject::GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id)
{
	HRESULT hr = NOERROR;
	ULONG hash = LHashValOfName(lcid, name);
	UINT hashIndex = hash % kSlotHashTableSize;
	CExpandoObjectSlot* slot;

	for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot->Next(m_slots))
	{
		if (slot->CompareName(name, hash, caseSensitive))
		{
			*id = slot->DispId();
			goto Exit;
		}
	}

	// not found
	hr = DISP_E_UNKNOWNNAME;
	*id = DISPID_UNKNOWN;

Exit:
	return hr;
}

////
//
// Add a new slot to the object
//

HRESULT CExpandoObject::AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id)
{
	HRESULT hr = NOERROR;
	ULONG hash = LHashValOfName(lcid, name);
	UINT hashIndex = hash % kSlotHashTableSize;
	CExpandoObjectSlot* slot;
	DISPID	dispId;

	// first check if the slot exists
	for (slot=GetHashTableHead(hashIndex); slot!=NULL; slot=slot->Next(m_slots))
	{
		// bail if the name matches
		if (slot->CompareName(name, hash, caseSensitive))
		{
			hr = E_INVALIDARG;
			goto Exit;
		}
	}

	// allocate a slot
	dispId = (DISPID) m_totalSlots;
	slot = AllocSlot();
	if (slot == NULL)
	{
		hr = E_OUTOFMEMORY;
		goto Exit;
	}

	// Initialize it
	// BUGBUG robwell 8May96 If this fails and the initialValue is not VT_EMTPY or VT_NULL
	// there in no cleanup code.
	hr = slot->Init(name, lcid, dispId + m_dispIdBase, initialValue);
	if (FAILED(hr))
	{
		// free the slot and dispId
		m_totalSlots -= 1;
		goto Exit;
	}

	// intern the slot into the proper hash table
	slot->Insert(m_slots, m_hashTable[hashIndex]);

	// set the DISPID return value
	*id = slot->DispId();

Exit:
	return hr;
}

////
//
// Slot allocation
//
// Because slots are never freed there is no free method
//

CExpandoObjectSlot* CExpandoObject::AllocSlot()
{
	// limit on the number of slots
	if (m_totalSlots >= kMaxTotalSlots)
		return NULL;

	// do we need to realloc the array?
	if (m_totalSlots == m_slotTableSize)
	{
		UINT i;
		UINT newSize;
		CExpandoObjectSlot* newSlots;

		// allocate twice as many slots unless first time around
		if (m_slotTableSize == 0)
			newSize = kInitialSlotTableSize;
		else
			newSize = m_slotTableSize * 2;

		// allocate the space for the slots
		newSlots = (CExpandoObjectSlot*) GTR_MALLOC(sizeof(CExpandoObjectSlot)*newSize);
		if (newSlots == NULL)
			return NULL;

		// copy the old values if the old m_slots is not NULL
		if (m_slots)
		{
			// copy the slots
			memcpy(newSlots, m_slots, sizeof(CExpandoObjectSlot)*m_totalSlots);
			// free the old values
			GTR_FREE(m_slots);
		}

		// construct all of the unused slots
		for (i=m_totalSlots; i<newSize; ++i)
			newSlots[i].Construct();

		// make the new array the new table and fix the total size
		m_slots = newSlots;
		m_slotTableSize = newSize;
	}

	// return a pointer to the slot and bump the totalSlots count
	return &m_slots[m_totalSlots++];
}

////
//
// Free all of the slots
//

void CExpandoObject::FreeAllSlots()
{
	UINT i;
	UINT initedSlotCount;
	CExpandoObjectSlot* slots;

	// first clear the hash table
	ClearHashTable();

	// detach the slots
	slots = m_slots;
	initedSlotCount = m_totalSlots;

	// clear the object info
	m_totalSlots = 0;
	m_slotTableSize = 0;
	m_slots = NULL;

	// only need to destruct those slots in use
	for (i=0; i<initedSlotCount; ++i)
		slots[i].Destruct();

	// free the storage
	if (slots)
		GTR_FREE(slots);
}



////
//
// IDispatch Methods
//
////

HRESULT CExpandoObject::GetTypeInfoCount(UINT *pctinfo)
{
	*pctinfo = 0;
	return NOERROR;
}

HRESULT CExpandoObject::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo **pptinfo)
{
	*pptinfo = NULL;
	return E_NOTIMPL;
}

HRESULT CExpandoObject::GetIDsOfNames(
	REFIID riid,
	LPOLESTR *prgpsz,
	UINT cpsz,
	LCID lcid,
	DISPID *prgdispid
)
{
	HRESULT hr;

	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	// First see if the outer object knows about the name
	if (m_pdisp)
	{
		hr = m_pdisp->GetIDsOfNames(
			riid,
			prgpsz,
			cpsz,
			lcid,
			prgdispid);

		// if so, just return
		if (SUCCEEDED(hr))
			return hr;
	}

	// Otherwise look on our expanded properties

	if (cpsz == 0)
		return NOERROR;

	// get the ids for the name
	hr = GetIDOfName(prgpsz[0], lcid, FALSE, &prgdispid[0]);

	// clear the rest of the array
	for (unsigned int i = 1; i < cpsz; i++)
	{
		if (SUCCEEDED(hr))
			hr = DISP_E_UNKNOWNNAME;
		prgdispid[i] = DISPID_UNKNOWN;
	}

	return hr;
}

HRESULT CExpandoObject::Invoke(
	DISPID dispID,
	REFIID riid,
	LCID lcid,
	WORD wFlags,
	DISPPARAMS *pdispparams,
	VARIANT *pvarRes,
	EXCEPINFO *pexcepinfo,
	UINT *puArgErr
)
{
	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	HRESULT hr;

	// First try the outer object's invoke
	if (m_pdisp)
	{
		hr = m_pdisp->Invoke(
				dispID,
				riid,
				lcid,
				wFlags,
				pdispparams,
				pvarRes,
				pexcepinfo,
				puArgErr
		);

		// If that succeeded, we're done
		if (SUCCEEDED(hr))
			return hr;
	}
	
	// Otherwise, try the expando object's invoke	
	if (NULL != puArgErr)
		*puArgErr = 0;

	if (wFlags & DISPATCH_PROPERTYGET)
	{
		if (NULL == pvarRes)
			return NOERROR;

		if (NULL != pdispparams && 0 != pdispparams->cArgs)
			return E_INVALIDARG;

		// clear the result slot
		pvarRes->vt = VT_EMPTY;
		return GetSlot(dispID, pvarRes);
	}

	if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
	{
		if (NULL == pdispparams
		|| 1 != pdispparams->cArgs
		|| 1 != pdispparams->cNamedArgs
		|| DISPID_PROPERTYPUT != pdispparams->rgdispidNamedArgs[0]
		)
			return DISP_E_PARAMNOTOPTIONAL;

		return SetSlot(dispID, &pdispparams->rgvarg[0]);
	}

	return DISP_E_MEMBERNOTFOUND;
}

////
//
// IDispatchEx methods
//
////

// Get dispID for names, with options
HRESULT STDMETHODCALLTYPE CExpandoObject::GetIDsOfNamesEx(
	REFIID riid,
	LPOLESTR *prgpsz,
	UINT cpsz,
	LCID lcid,
	DISPID *prgid,
	DWORD grfdex
)
{
	HRESULT hr;
	BOOL caseSensitive = ((grfdex & fdexCaseSensitive) != 0);


	// First see if the outer object knows about the name
	if (m_pdisp)
	{
		hr = m_pdisp->GetIDsOfNames(
			riid,
			prgpsz,
			cpsz,
			lcid,
			prgid);

		// if so, just return
		if (SUCCEEDED(hr))
			return hr;
	}


	if (IID_NULL != riid)
		return DISP_E_UNKNOWNINTERFACE;

	if (cpsz == 0)
		return NOERROR;

	// check the array arguments
	if (prgpsz == NULL || prgid == NULL)
		return E_INVALIDARG;

	// get the id from the name
	hr = GetIDOfName(prgpsz[0], lcid, caseSensitive, &prgid[0]);

	// create the slot?
	if (hr == DISP_E_UNKNOWNNAME && (grfdex & fdexDontCreate) == 0)
	{
		VARIANT initialValue;

		if (grfdex & fdexInitNull)
			initialValue.vt = VT_NULL;
		else
			initialValue.vt = VT_EMPTY;

		hr = AddSlot(prgpsz[0], lcid, caseSensitive, &initialValue, &prgid[0]);
	}

	// clear the rest of the array
	for (unsigned int i = 1; i < cpsz; i++)
	{
		hr = DISP_E_UNKNOWNNAME;
		prgid[i] = DISPID_UNKNOWN;
	}

	return hr;
}

// Enumerate dispIDs and their associated "names".
// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
// error code if the call fails.
HRESULT STDMETHODCALLTYPE CExpandoObject::GetNextDispID(
	DISPID id,
	DISPID *pid,
	BSTR *pbstrName
)
{
	HRESULT hr;
	CExpandoObjectSlot* slot;

	// check the outgoing parameters
	if (pid == NULL || pbstrName == NULL)
		return E_INVALIDARG;

	// set to the default failure case
	*pid = DISPID_UNKNOWN;
	*pbstrName = NULL;

	// get the next slot
	hr = Next(id, slot);
	if (hr == NOERROR)
	{
		BSTR name;

		// allocate the result string
		name = SysAllocString(slot->Name());
		if (name == NULL)
			return E_OUTOFMEMORY;

		// fill in the outgoing parameters
		*pid = slot->DispId();
		*pbstrName = name;
	}

	return hr;
}

// Copy all of the expando-object properties from obj
HRESULT
CExpandoObject::CloneProperties(CExpandoObject& obj)
{
    // BUGBUG  PhilBo
    // The initialization code below is copied from the default constructor.
    // This should be factored out into a shared method.

	// Copy each of the properties from the original object
    HRESULT hr = S_OK;
    DISPID dispid = 0;
    BSTR bstrName = NULL;

    while (obj.GetNextDispID(dispid, &dispid, &bstrName) == S_OK)
    {
        // Get the value of the property from the original object
        VARIANT varResult;
        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};
        VariantInit(&varResult);

        hr = obj.Invoke(
		        dispid,
		        IID_NULL,
		        LOCALE_SYSTEM_DEFAULT,
		        DISPATCH_PROPERTYGET,
		        &dispparamsNoArgs, &varResult, NULL, NULL);

        ASSERT(SUCCEEDED(hr), "");
        if (FAILED(hr))
            continue;

        // Set the property on the new object
        DISPID dispidNew = 0;
	    hr = GetIDsOfNamesEx(IID_NULL, &bstrName, 1, LOCALE_SYSTEM_DEFAULT,
		    &dispidNew, 0);

        ASSERT(SUCCEEDED(hr), "");
        if (FAILED(hr))
            continue;

        DISPPARAMS dispparams = {0};
        dispparams.rgvarg[0] = varResult;

        DISPID rgdispid[] = {DISPID_PROPERTYPUT};
        dispparams.rgdispidNamedArgs = rgdispid;
        dispparams.cArgs = 1;
        dispparams.cNamedArgs = 1;

        hr = Invoke(
		    dispidNew,
		    IID_NULL,
		    LOCALE_SYSTEM_DEFAULT,
		    DISPATCH_PROPERTYPUT,
		    &dispparams, NULL, NULL, NULL);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\internet.cpp ===
//=--------------------------------------------------------------------------=
// Internet.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains internet helper classes CDownloadSink and CInternetControl
//
#include "IPServer.H"
#include "Internet.H"
#include "Util.H"

static VARTYPE rgI4[] = { VT_I4 };

typedef enum {
    InternetEvent_Progress = 0,
    InternetEvent_ReadyStateChange = 1
} INTERNETEVENTS;

static EVENTINFO rgEvents [] = {
    { DISPID_PROGRESS, 1, rgI4 },           // (long percentDone)
    { DISPID_READYSTATECHANGE, 1, rgI4 },       // (OLE_READYSTATE newState)
};


// local class for doing async monitoring. It's not really all that
// general purpose, but it does the job...


class CDownloadSink : public IBindStatusCallback
{
public:
    CDownloadSink(IUnknown *punkOuter,CInternetControl *,DISPID );
    ~CDownloadSink();

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

        STDMETHOD(OnStartBinding)(
            /* [in] */ DWORD grfBSCOption,
            /* [in] */ IBinding *pib);

        STDMETHOD(GetPriority)(
            /* [out] */ LONG *pnPriority);

        STDMETHOD(OnLowResource)(
            /* [in] */ DWORD reserved);

        STDMETHOD(OnProgress)(
            /* [in] */ ULONG ulProgress,
            /* [in] */ ULONG ulProgressMax,
            /* [in] */ ULONG ulStatusCode,
            /* [in] */ LPCWSTR szStatusText);

        STDMETHOD(OnStopBinding)(
            /* [in] */ HRESULT hresult,
            /* [in] */ LPCWSTR szError);

        STDMETHOD(GetBindInfo)(
            /* [out] */ DWORD *grfBINDINFOF,
            /* [unique][out][in] */ BINDINFO *pbindinfo);

        STDMETHOD(OnDataAvailable)(
            /* [in] */ DWORD grfBSCF,
            /* [in] */ DWORD dwSize,
            /* [in] */ FORMATETC *pformatetc,
            /* [in] */ STGMEDIUM *pstgmed);

        STDMETHOD(OnObjectAvailable)(
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ IUnknown *punk);



        CDownloadSink * Next()                  { return(m_next); }
        void            Next(CDownloadSink *n)  { m_next = n; }

        DISPID          DispId()  { return(m_propId); }
        IBinding *      Binding() { return(m_binding); }

private:

        CDownloadSink *         m_next;
        CInternetControl *      m_control;
        DISPID                  m_propId;
        IBinding *              m_binding;
        DWORD                   m_ref;
                IStream *                               m_stream;

};


CDownloadSink::CDownloadSink
(
        IUnknown *              punkOuter,
        CInternetControl *      control,
        DISPID                  propId
)
{
//      CHECK_POINTER(control);

        m_control = control;
        m_control->AddRef();

        m_propId  = propId;
        m_next    = 0;
        m_binding = 0;
        m_ref     = 0;
        m_stream  = 0;
}

CDownloadSink::~CDownloadSink()
{
        if( m_control )
                m_control->Release();
        if( m_binding )
                m_binding->Release();
        if( m_stream )
                m_stream->Release();
}

STDMETHODIMP
CDownloadSink::QueryInterface(const GUID &iid,void **ppv )
{
        if( IsEqualGUID(iid,IID_IUnknown) || IsEqualGUID(iid,IID_IBindStatusCallback) )
        {
                *ppv = this;
                AddRef();
                return(NOERROR);
        }
        return( E_NOINTERFACE );
}

STDMETHODIMP_(ULONG)
CDownloadSink::AddRef()
{
        return(++m_ref);
}

STDMETHODIMP_(ULONG)
CDownloadSink::Release()
{
        if(!--m_ref)
        {
                delete this;
                return(0);
        }
        return( m_ref );
}


STDMETHODIMP
CDownloadSink::GetBindInfo( DWORD *grfBINDF, BINDINFO *pbindInfo)
{
    *grfBINDF = BINDF_ASYNCHRONOUS | BINDF_ASYNCSTORAGE | BINDF_PULLDATA;
        return(NOERROR);
}


STDMETHODIMP
CDownloadSink::OnStartBinding(DWORD /*grfBSCOption*/,IBinding *pib)
{
        // BUGBUG: should check to see options are what we think they are
        m_binding = pib;
        pib->AddRef();
        return(NOERROR);
}


STDMETHODIMP
CDownloadSink::GetPriority( LONG *pnPriority)
{
        return(E_NOTIMPL);
}

STDMETHODIMP
CDownloadSink::OnProgress
(
     ULONG ulProgress,
     ULONG ulProgressMax,
     ULONG ulStatusCode,
     LPCWSTR pwzStatusText
)
{
        return(m_control->OnProgress(m_propId,ulProgress,
                                                        ulProgressMax,ulStatusCode,pwzStatusText) );
}

STDMETHODIMP
CDownloadSink::OnDataAvailable
(
     DWORD                      grfBSCF,
     DWORD                      dwSize,
     FORMATETC *        pFmtetc,
         STGMEDIUM *    pstgmed
)
{
#ifdef DEBUG
        char msg[200];
        wsprintf(msg,"::OnDataAvailable(%0xd,%d,%s,%s)\n",grfBSCF,dwSize,
                pFmtetc ? "pFmtetc" : "NULL", pstgmed ? "pstgmed" : "NULL" );
        OutputDebugString(msg);
#endif

    if( !m_stream )
                m_stream = pstgmed->pstm;

        return(m_control->OnData(       m_propId,
                                                                grfBSCF,
                                                                m_stream,
                                                                dwSize ));
}

STDMETHODIMP
CDownloadSink::OnObjectAvailable
(
        REFIID riid,
    IUnknown *punk
)
{
        return(E_NOTIMPL);
}


STDMETHODIMP
CDownloadSink::OnLowResource( DWORD reserved)
{
        // BUGBUG: really should have this kind of harsh policy on this ...
        m_binding->Abort();
        return(S_OK);
}

STDMETHODIMP
CDownloadSink::OnStopBinding(HRESULT hrError, LPCWSTR szError)
{
        m_binding->Release();
        m_binding = 0;
        m_control->Release();
        m_control = 0;

        return(NOERROR);
}



//------------------------------------------------------
//
// class CInternetControl
//
//
CInternetControl::CInternetControl
(
        IUnknown *      pUnkOuter,
        int                     iPrimaryDispatch,
        void *          pMainInterface
)
        : COleControl(pUnkOuter,iPrimaryDispatch,pMainInterface)
{
        m_host = 0;
        m_readyState = READYSTATE_LOADING;
}

CInternetControl::~CInternetControl()
{
        if( m_host )
                m_host->Release();
}


HRESULT CInternetControl::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;
     return COleControl::InternalQueryInterface(riid, ppvObjOut);
}



HRESULT
CInternetControl::GetBindHost()
{

        if( m_host )
                return(NOERROR);

    // Try service provider first...

        IServiceProvider * serviceProvider = 0;

        HRESULT hr = m_pClientSite->QueryInterface
                                                                        (
                                                                                IID_IServiceProvider,
                                                                                (void**)&serviceProvider
                                                                        );

        if( SUCCEEDED(hr) )
    {
                hr = serviceProvider->QueryService
                                    (
                                        SID_IBindHost,
                                        IID_IBindHost,
                                        (void**)&m_host
                                    );
                serviceProvider->Release();
    }

    if( FAILED(hr) )
    {
        // Some containers put IBindHost directly on the client site

        hr = m_pClientSite->QueryInterface
                                                                        (
                                        IID_IBindHost,
                                        (void**)&m_host
                                                                        );


    }

        return(hr);

}


HRESULT CInternetControl::GetAMoniker( LPOLESTR url, IMoniker ** ppmkr )
{
        HRESULT hr = GetBindHost();

        if( SUCCEEDED(hr) )
                hr = m_host->CreateMoniker(url,NULL, ppmkr,0);

        if( FAILED(hr) )
    {
           // FUTURE: This really should be a call to MkParseDisplayNameEx!!!
       hr = ::CreateURLMoniker(0,url,ppmkr);
       // hr = ::MkParseDisplayNameEx(0, url, 0, ppmkr);
    }

        return( hr );
}


HRESULT CInternetControl::SetupDownload( LPOLESTR url, DISPID propId )
{
        CHECK_POINTER(url);

        IMoniker * pmkr;

        HRESULT hr = GetAMoniker( url, &pmkr );

        IBindCtx * pBindCtx = 0;

        if( SUCCEEDED(hr) )
    {
        hr = ::CreateBindCtx(0,&pBindCtx);
    }

        CDownloadSink * sink = 0;

        if( SUCCEEDED(hr) )
        {
                sink = new CDownloadSink(0,this,propId);
                if( sink )
                        sink->AddRef();
        }

        if( SUCCEEDED(hr) && !sink )
                hr = E_OUTOFMEMORY;

        if( SUCCEEDED(hr) )
        {
                // BUGBUG: There should be a define for 0x77
                hr = ::RegisterBindStatusCallback(pBindCtx, sink,0, 0) ;
        }

        IStream * strm = 0;

        if( SUCCEEDED(hr) )
                hr = pmkr->BindToStorage( pBindCtx, 0, IID_IStream, (void**)&strm );

        if( strm )
                strm->Release();

        if( pBindCtx )
                pBindCtx->Release();

        if( FAILED(hr) && sink )
                sink->Release();

        return(hr);

}


HRESULT CInternetControl::OnData( DISPID, DWORD,IStream *, DWORD)
{
        return(NOERROR);
}

HRESULT CInternetControl::OnProgress( DISPID, ULONG progress, ULONG themax, ULONG, LPCWSTR)
{
        return(NOERROR);
}


HRESULT CInternetControl::FireReadyStateChange( long newState )
{
        FireEvent( &::rgEvents[InternetEvent_ReadyStateChange], m_readyState = newState );
        return(S_OK);
}

HRESULT CInternetControl::FireProgress( ULONG dwAmount )
{
        FireEvent( &::rgEvents[InternetEvent_Progress], dwAmount );
        return(S_OK);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\stdenum.cpp ===
//=--------------------------------------------------------------------------=
// StdEnum.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of a generic enumerator object.
//
#include "IPServer.H"
#include "StdEnum.H"
#include "Globals.H"

SZTHISFILE

//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// create the object and initialize the refcount
//
// Parameters:
//    REFCLSID        - [in] type of enumerator that we are
//    int             - [in] number of elements in the enumeration
//    int             - [in] size of each element
//    void *          - [in] pointer to element data
//    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
//                    - [in] copying function
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CStandardEnum::CStandardEnum
(
    REFCLSID rclsid,
    int      cElements,
    int      cbElementSize,
    void    *rgElements,
    void (WINAPI *pfnCopyElement)(void *, const void *, DWORD)
)
: CUnknownObject(NULL, (IEnumGeneric *)this),
  m_iid(rclsid),
  m_cElements(cElements),
  m_cbElementSize(cbElementSize),
  m_iCurrent(0),
  m_rgElements(rgElements),
  m_pfnCopyElement(pfnCopyElement)
{
    m_pEnumClonedFrom = NULL;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CStandardEnum::CStandardEnum
//=--------------------------------------------------------------------------=
// "it is not death, but dying, which is terrible."
//    - Henry Fielding (1707-54)
//
// Notes:
//
CStandardEnum::~CStandardEnum ()
{
    // if we're a cloned object, then just release our parent object and
    // we're done. otherwise, free up the allocated memory we were given
    //
    if (m_pEnumClonedFrom)
        m_pEnumClonedFrom->Release();
    else {
        if (m_rgElements) HeapFree(g_hHeap, 0, m_rgElements);
    }
}

//=--------------------------------------------------------------------------=
// CStandardEnum::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support our internal iid, and that's all
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CStandardEnum::InternalQueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    if (DO_GUIDS_MATCH(riid, m_iid)) {
        ExternalAddRef();
        *ppvObjOut = (IEnumGeneric *)this;
        return S_OK;
    }

    return E_NOINTERFACE;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Next
//=--------------------------------------------------------------------------=
// returns the next dude in our iteration
//
// Parameters:
//    unsigned long     - [in]  count of elements requested
//    void    *         - [out] array of slots to put values in.
//    unsigned long *   - [out] actual number fetched
//
// Output:
//    HRESULT           - S_OK, E_INVALIDARG, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Next
(
    unsigned long  cElm,
    void          *rgDest,
    unsigned long *pcElmOut
)
{
    unsigned long cElementsFetched = 0;
    void         *pElementDest = rgDest;
    const void   *pElementSrc = (const BYTE *)m_rgElements + (m_cbElementSize * m_iCurrent);

    while (cElementsFetched < cElm) {

        // if we hit EOF, break out
        //
        if (m_iCurrent >= m_cElements)
            break;

        // copy the element out for them
        //
        m_pfnCopyElement(pElementDest, pElementSrc, m_cbElementSize);

        // increase the counters
        //
        pElementDest = (LPBYTE)pElementDest + m_cbElementSize;
        pElementSrc  = (const BYTE *)pElementSrc + m_cbElementSize;
        m_iCurrent++;
        cElementsFetched++;
    }

    if (pcElmOut)
        *pcElmOut = cElementsFetched;

    return (cElementsFetched < cElm)? S_FALSE : S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Skip
//=--------------------------------------------------------------------------=
// skips the requested number of rows.
//
// Parameters:
//    unsigned long     - [in] number to skip
//
// Output:
//    HRESULT           - S_OK, S_FALSE
//
// Notes:
//
STDMETHODIMP CStandardEnum::Skip
(
    unsigned long cSkip
)
{
    // handle running off the end
    //
    if (m_iCurrent + (int)cSkip > m_cElements) {
        m_iCurrent = m_cElements;
        return S_FALSE;
    }

    m_iCurrent += cSkip;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStandardEnum::Reset
//=--------------------------------------------------------------------------=
// reset the counter.
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
STDMETHODIMP CStandardEnum::Reset
(
    void
)
{
    m_iCurrent = 0;
    return S_OK;
}


//=--------------------------------------------------------------------------=
// CStandardEnum::Clone
//=--------------------------------------------------------------------------=
// clones the object and gives the new one the same position
//
// Parameters:
//    IEnumVARIANT **    - [out] where to put the new object.
//
// Output;
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStandardEnum::Clone
(
    IEnumGeneric **ppEnumClone
)
{
    CStandardEnum *pNewEnum;

    pNewEnum = new CStandardEnum(m_iid, m_cElements, m_cbElementSize, m_rgElements, m_pfnCopyElement);
    RETURN_ON_NULLALLOC(pNewEnum);

    // hold on to who we were cloned from so m_rgElements stays alive, and we don't
    // have to copy it.
    //
    pNewEnum->m_pEnumClonedFrom = this;

    // AddRef() ourselves on their behalf.
    //
    AddRef();
    *ppEnumClone = (IEnumGeneric *)pNewEnum;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\unknown.cpp ===
//=--------------------------------------------------------------------------=
// Unknown.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for various things in the unknown object that supports
// aggregation.
//
#include "IPServer.H"
#include "Unknown.H"
#include <stddef.h>


//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
//=--------------------------------------------------------------------------=
// this method is used when we're sitting in the private unknown object,
// and we need to get at the pointer for the main unknown.  basically, it's
// a little better to do this pointer arithmetic than have to store a pointer
// to the parent, etc.
//
inline CUnknownObject *CUnknownObject::CPrivateUnknownObject::m_pMainUnknown
(
    void
)
{
    return (CUnknownObject *)((LPBYTE)this - offsetof(CUnknownObject, m_UnkPrivate));
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::QueryInterface
//=--------------------------------------------------------------------------=
// this is the non-delegating internal QI routine.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
STDMETHODIMP CUnknownObject::CPrivateUnknownObject::QueryInterface
(
    REFIID riid,
    void **ppvObjOut
)
{
    CHECK_POINTER(ppvObjOut);

    // if they're asking for IUnknown, then we have to pass them ourselves.
    // otherwise defer to the inheriting object's InternalQueryInterface
    //
    if (DO_GUIDS_MATCH(riid, IID_IUnknown)) {
        m_cRef++;
        *ppvObjOut = (IUnknown *)this;
        return S_OK;
    } else
        return m_pMainUnknown()->InternalQueryInterface(riid, ppvObjOut);

    // dead code    
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::AddRef
//=--------------------------------------------------------------------------=
// adds a tick to the current reference count.
//
// Output:
//    ULONG        - the new reference count
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::AddRef
(
    void
)
{
    return ++m_cRef;
}

//=--------------------------------------------------------------------------=
// CUnknownObject::CPrivateUnknownObject::Release
//=--------------------------------------------------------------------------=
// removes a tick from the count, and delets the object if necessary
//
// Output:
//    ULONG         - remaining refs
//
// Notes:
//
ULONG CUnknownObject::CPrivateUnknownObject::Release
(
    void
)
{
    ULONG cRef = --m_cRef;

    if (!m_cRef)
        delete m_pMainUnknown();

    return cRef;
}


//=--------------------------------------------------------------------------=
// CUnknownObject::InternalQueryInterface
//=--------------------------------------------------------------------------=
// objects that are aggregated use this to support additional interfaces.
// they should call this method on their parent so that any of it's interfaces
// are queried.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CUnknownObject::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    *ppvObjOut = NULL;

    return E_NOINTERFACE;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\util.cpp ===
//=--------------------------------------------------------------------------=
// Util.C
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains routines that we will find useful.
//
#include "IPServer.H"

#include "Globals.H"
#include "Util.H"
#define DECL_CRTFREE
#define DEFINE_FLOAT_STUFF
#include <crtfree.h>

// for ASSERT and FAIL
//
SZTHISFILE


#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))


//=--------------------------------------------------------------------------=
// MakeWideFromAnsi
//=--------------------------------------------------------------------------=
// given a string, make a BSTR out of it.
//
// Parameters:
//    LPSTR         - [in]
//    BYTE          - [in]
//
// Output:
//    LPWSTR        - needs to be cast to final desired result
//
// Notes:
//
LPWSTR MakeWideStrFromAnsi
(
    LPSTR psz,
    BYTE  bType
)
{
    LPWSTR pwsz = NULL;
    int i;

    // arg checking.
    //
    if (!psz)
        return NULL;

    // compute the length of the required BSTR
    //
    i =  MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
    if (i <= 0) return NULL;

    // allocate the widestr
    //
    switch (bType) {
      case STR_BSTR:
        // -1 since it'll add it's own space for a NULL terminator
        //
        pwsz = (LPWSTR) SysAllocStringLen(NULL, i - 1);
        break;
      case STR_OLESTR:
        pwsz = (LPWSTR) CoTaskMemAlloc(i * sizeof(WCHAR));
        break;
      default:
        FAIL("Bogus String Type.");
    }

    if (!pwsz) return NULL;
    MultiByteToWideChar(CP_ACP, 0, psz, -1, pwsz, i);
    pwsz[i - 1] = 0;
    return pwsz;
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromResId
//=--------------------------------------------------------------------------=
// given a resource ID, load it, and allocate a wide string for it.
//
// Parameters:
//    WORD            - [in] resource id.
//    BYTE            - [in] type of string desired.
//
// Output:
//    LPWSTR          - needs to be cast to desired string type.
//
// Notes:
//
LPWSTR MakeWideStrFromResourceId
(
    WORD    wId,
    BYTE    bType
)
{
    int i;

    char szTmp[512];

    // load the string from the resources.
    //
    i = LoadString(GetResourceHandle(), wId, szTmp, 512);
    if (!i) return NULL;

    return MakeWideStrFromAnsi(szTmp, bType);
}

//=--------------------------------------------------------------------------=
// MakeWideStrFromWide
//=--------------------------------------------------------------------------=
// given a wide string, make a new wide string with it of the given type.
//
// Parameters:
//    LPWSTR            - [in]  current wide str.
//    BYTE              - [in]  desired type of string.
//
// Output:
//    LPWSTR
//
// Notes:
//
LPWSTR MakeWideStrFromWide
(
    LPWSTR pwsz,
    BYTE   bType
)
{
    LPWSTR pwszTmp;
    int i;

    if (!pwsz) return NULL;

    // just copy the string, depending on what type they want.
    //
    switch (bType) {
      case STR_OLESTR:
        i = lstrlenW(pwsz);
        pwszTmp = (LPWSTR)CoTaskMemAlloc((i * sizeof(WCHAR)) + sizeof(WCHAR));
        if (!pwszTmp) return NULL;
        memcpy(pwszTmp, pwsz, (sizeof(WCHAR) * i) + sizeof(WCHAR));
        break;

      case STR_BSTR:
        pwszTmp = (LPWSTR)SysAllocString(pwsz);
        break;
    }

    return pwszTmp;
}

//=--------------------------------------------------------------------------=
// StringFromGuidA
//=--------------------------------------------------------------------------=
// returns an ANSI string from a CLSID or GUID
//
// Parameters:
//    REFIID               - [in]  clsid to make string out of.
//    LPSTR                - [in]  buffer in which to place resultant GUID.
//
// Output:
//    int                  - number of chars written out.
//
// Notes:
//
int StringFromGuidA
(
    REFIID   riid,
    LPSTR    pszBuf
)
{
    return wsprintf((char *)pszBuf, "{%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}", riid.Data1,
            riid.Data2, riid.Data3, riid.Data4[0], riid.Data4[1], riid.Data4[2],
            riid.Data4[3], riid.Data4[4], riid.Data4[5], riid.Data4[6], riid.Data4[7]);

}

//=--------------------------------------------------------------------------=
// RegisterUnknownObject
//=--------------------------------------------------------------------------=
// registers a simple CoCreatable object.  nothing terribly serious.
// we add the following information to the registry:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
//
// Parameters:
//    LPCSTR       - [in] Object Name
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't register it all
//
// Notes:
//
BOOL RegisterUnknownObject
(
    LPCSTR   pszObjectName,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    DWORD dwPathLen, dwDummy;
    char  szScratch[MAX_PATH];
    long  l;

    // clean out any garbage
    //
    UnregisterUnknownObject(riidObject);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32 = <path to local server>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\InprocServer32  @ThreadingModel = Apartment
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "InprocServer32", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    dwPathLen = GetModuleFileName(g_hInstance, szScratch, sizeof(szScratch));
    if (!dwPathLen) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, dwPathLen + 1);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, "ThreadingModel", 0, REG_SZ, (BYTE *)"Apartment", sizeof("Apartment"));
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    return TRUE;

    // we are not very happy!
    //
  CleanUp:
    if (hk) RegCloseKey(hk);
    if (hkSub) RegCloseKey(hkSub);
    return FALSE;

}

// copied directly from shlwapi, since this guy doesnt use shlwapi we shouldnt make him link
// just because of prefast.
STDAPI_(LPSTR) StrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize)
{
    if (pszDest && pszSrc)
    {
        LPSTR psz = pszDest;
        
        // we walk forward till we find the end of pszDest, subtracting
        // from cchDestBuffSize as we go.
        while (*psz)
        {
            psz++;
            cchDestBuffSize--;
        }

        if (cchDestBuffSize > 0)
        {
            // Let kernel do the work for us. 
            //
            // WARNING: We might generate a truncated DBCS sting becuase kernel's lstrcpynA
            // dosent check for this. Ask me if I care.
            lstrcpynA(psz, pszSrc, cchDestBuffSize);
        }
    }

    return pszDest;
}
   
//=--------------------------------------------------------------------------=
// RegisterAutomationObject
//=--------------------------------------------------------------------------=
// given a little bit of information about an automation object, go and put it
// in the registry.
// we add the following information in addition to that set up in
// RegisterUnknownObject:
//
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
//
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
// HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//
BOOL RegisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject
)
{
    HKEY  hk = NULL, hkSub = NULL;
    char  szGuidStr[GUID_STR_LEN];
    char  szScratch[MAX_PATH];
    long  l;
    DWORD dwDummy;

    // first register the simple Unknown stuff.
    //
    if (!RegisterUnknownObject(pszObjectName, riidObject)) return FALSE;

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CLSID = <CLSID>
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>\CurVer = <ObjectName>.Object.<VersionNumber>
    //
    lstrcpyn(szScratch, pszLibName, ARRAYSIZE(szScratch));
    StrCatBuffA(szScratch, ".", ARRAYSIZE(szScratch));
    StrCatBuffA(szScratch, pszObjectName, ARRAYSIZE(szScratch));

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0L, "",
                       REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0L, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch)+1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0L, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    if (!StringFromGuidA(riidObject, szGuidStr))
        goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0L, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "CurVer", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> = <ObjectName> Object
    // HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber>\CLSID = <CLSID>
    //
    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s Object", pszObjectName);
    l = RegSetValueEx(hk, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "CLSID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);

    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\ProgID = <LibraryName>.<ObjectName>.<VersionNumber>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\VersionIndependentProgID = <LibraryName>.<ObjectName>
    // HKEY_CLASSES_ROOT\CLSID\<CLSID>\TypeLib = <LibidOfTypeLibrary>
    //
    if (!StringFromGuidA(riidObject, szGuidStr)) goto CleanUp;
    wsprintf(szScratch, "CLSID\\%s", szGuidStr);

    l = RegCreateKeyEx(HKEY_CLASSES_ROOT, szScratch, 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ|KEY_WRITE, NULL, &hk, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hk, "VersionIndependentProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    l = RegCreateKeyEx(hk, "ProgID", 0, "", REG_OPTION_NON_VOLATILE,
                       KEY_READ | KEY_WRITE, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szScratch, lstrlen(szScratch) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "TypeLib", 0, "", REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                       NULL, &hkSub, &dwDummy);

    if (!StringFromGuidA(riidLibrary, szGuidStr)) goto CleanUp;

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szGuidStr, lstrlen(szGuidStr) + 1);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);
    RegCloseKey(hk);
    return TRUE;

  CleanUp:
    if (hk) RegCloseKey(hkSub);
    if (hk) RegCloseKey(hk);
    return FALSE;
}

//=--------------------------------------------------------------------------=
// RegisterControlObject.
//=--------------------------------------------------------------------------=
// in addition to writing out automation object information, this function
// writes out some values specific to a control.
//
// What we add here:
//
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Control
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\MiscStatus\1 = <MISCSTATUSBITS>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\ToolboxBitmap32 = <PATH TO BMP>
// HKEY_CLASSES_ROOT\CLSID\<CLSID>\Version = <VERSION>
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] LIBID of type library
//    REFCLSID     - [in] CLSID of the object
//    DWORD        - [in] misc status flags for ctl
//    WORD         - [in] toolbox id for control
//
// Output:
//    BOOL
//
// Notes:
//    - not the most terribly efficient routine.
//
BOOL RegisterControlObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidLibrary,
    REFCLSID riidObject,
    DWORD    dwMiscStatus,
    WORD     wToolboxBitmapId
)
{
    HKEY    hk, hkSub = NULL, hkSub2 = NULL;
    char    szTmp[MAX_PATH];
    char    szGuidStr[GUID_STR_LEN];
    DWORD   dwDummy;
    LONG    l;

    // first register all the automation information for this.
    //
    if (!RegisterAutomationObject(pszLibName, pszObjectName, lVersion, riidLibrary, riidObject)) return FALSE;

    // then go and register the control specific stuff.
    //
    StringFromGuidA(riidObject, szGuidStr);
    wsprintf(szTmp, "CLSID\\%s", szGuidStr);
    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, szTmp, 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    // create the control flag.
    //
    l = RegCreateKeyEx(hk, "Control", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    // now set up the MiscStatus Bits...
    //
    RegCloseKey(hkSub);
    hkSub = NULL;
    l = RegCreateKeyEx(hk, "MiscStatus", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    szTmp[0] = '0';
    szTmp[1] = '\0';
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, 2);
    CLEANUP_ON_ERROR(l);

    l = RegCreateKeyEx(hkSub, "1", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub2, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%d", dwMiscStatus);
    l = RegSetValueEx(hkSub2, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    RegCloseKey(hkSub2);
    CLEANUP_ON_ERROR(l);

    RegCloseKey(hkSub);

    // now set up the toolbox bitmap
    //
    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
    wsprintf(szGuidStr, ", %d", wToolboxBitmapId);
    lstrcat(szTmp, szGuidStr);

    l = RegCreateKeyEx(hk, "ToolboxBitmap32", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);
    CLEANUP_ON_ERROR(l);

    // now set up the version information
    //
    RegCloseKey(hkSub);
    l = RegCreateKeyEx(hk, "Version", 0, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkSub, &dwDummy);
    CLEANUP_ON_ERROR(l);

    wsprintf(szTmp, "%ld.0", lVersion);
    l = RegSetValueEx(hkSub, NULL, 0, REG_SZ, (BYTE *)szTmp, lstrlen(szTmp) + 1);

  CleanUp:
    if (hk)
        RegCloseKey(hk);
    if (hkSub)
        RegCloseKey(hkSub);

    return (l == ERROR_SUCCESS) ? TRUE : FALSE;
}

//=--------------------------------------------------------------------------=
// UnregisterUnknownObject
//=--------------------------------------------------------------------------=
// cleans up all the stuff that RegisterUnknownObject puts in the
// registry.
//
// Parameters:
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means not all of it was registered
//
// Notes:
//    - WARNING: this routine will blow away all other keys under the CLSID
//      for this object.  mildly anti-social, but likely not a problem.
//
BOOL UnregisterUnknownObject
(
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    HKEY hk;
    BOOL f;
    long l;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\CLSID\<CLSID> [\] *
    //
    if (!StringFromGuidA(riidObject, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "CLSID", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);

    return f;
}

//=--------------------------------------------------------------------------=
// UnregisterAutomationObject
//=--------------------------------------------------------------------------=
// unregisters an automation object, including all of it's unknown object
// information.
//
// Parameters:
//    LPCSTR       - [in] Library Name
//    LPCSTR       - [in] Object Name
//    long         - [in] Version Number
//    REFCLSID     - [in] CLSID of the object
//
// Output:
//    BOOL         - FALSE means couldn't get it all unregistered.
//
// Notes:
//
BOOL UnregisterAutomationObject
(
    LPCSTR   pszLibName,
    LPCSTR   pszObjectName,
    long     lVersion,
    REFCLSID riidObject
)
{
    char szScratch[MAX_PATH];
    BOOL f;

    // first thing -- unregister Unknown information
    //
    f = UnregisterUnknownObject(riidObject);
    if (!f) return FALSE;

    // delete everybody of the form:
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName> [\] *
    //
    wsprintf(szScratch, "%s.%s", pszLibName, pszObjectName);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    // delete everybody of the form
    //   HKEY_CLASSES_ROOT\<LibraryName>.<ObjectName>.<VersionNumber> [\] *
    //
    wsprintf(szScratch, "%s.%s.%ld", pszLibName, pszObjectName, lVersion);
    f = DeleteKeyAndSubKeys(HKEY_CLASSES_ROOT, szScratch);
    if (!f) return FALSE;

    return TRUE;
}

//=--------------------------------------------------------------------------=
// UnregisterTypeLibrary
//=--------------------------------------------------------------------------=
// blows away the type library keys for a given libid.
//
// Parameters:
//    REFCLSID        - [in] libid to blow away.
//
// Output:
//    BOOL            - TRUE OK, FALSE bad.
//
// Notes:
//    - WARNING: this function just blows away the entire type library section,
//      including all localized versions of the type library.  mildly anti-
//      social, but not killer.
//
BOOL UnregisterTypeLibrary
(
    REFCLSID riidLibrary
)
{
    HKEY hk;
    char szScratch[GUID_STR_LEN];
    long l;
    BOOL f;

    // convert the libid into a string.
    //
    if (!StringFromGuidA(riidLibrary, szScratch))
        return FALSE;

    l = RegOpenKeyEx(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_ALL_ACCESS, &hk);
    if (l != ERROR_SUCCESS) return FALSE;

    f = DeleteKeyAndSubKeys(hk, szScratch);
    RegCloseKey(hk);
    return f;
}

//=--------------------------------------------------------------------------=
// DeleteKeyAndSubKeys
//=--------------------------------------------------------------------------=
// delete's a key and all of it's subkeys.
//
// Parameters:
//    HKEY                - [in] delete the descendant specified
//    LPSTR               - [in] i'm the descendant specified
//
// Output:
//    BOOL                - TRUE OK, FALSE baaaad.
//
// Notes:
//    - I don't feel too bad about implementing this recursively, since the
//      depth isn't likely to get all the great.
//    - Despite the win32 docs claiming it does, RegDeleteKey doesn't seem to
//      work with sub-keys under windows 95.
//
//    - REWRITTEN: To actually work as expected (07/30/97 -- jaym)
BOOL DeleteKeyAndSubKeys
(
    HKEY    hkIn,
    LPSTR   pszSubKey
)
{
    DWORD   dwRet;
    HKEY    hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyEx(hkIn, pszSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (dwRet == ERROR_SUCCESS)
    {
        DWORD   dwIndex;
        CHAR    szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = sizeof(szSubKeyName);
        CHAR    szClass[MAX_PATH];
        DWORD   cbClass = sizeof(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkSubKey,
                                szClass,
                                &cbClass,
                                NULL,
                                &dwIndex, // The # of subkeys -- all we need
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (dwRet == NO_ERROR)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (RegEnumKey(  hkSubKey,
                                --dwIndex,
                                szSubKeyName,
                                cchSubKeyName) == ERROR_SUCCESS)
            {
                DeleteKeyAndSubKeys(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKey(hkIn, pszSubKey);
    }

    return (dwRet == ERROR_SUCCESS);
}


//=--------------------------------------------------------------------------=
// Conversion Routines
//=--------------------------------------------------------------------------=
// the following stuff is stuff used for the various conversion routines.
//
#define HIMETRIC_PER_INCH   2540
#define MAP_PIX_TO_LOGHIM(x,ppli)   ( (HIMETRIC_PER_INCH*(x) + ((ppli)>>1)) / (ppli) )
#define MAP_LOGHIM_TO_PIX(x,ppli)   ( ((ppli)*(x) + HIMETRIC_PER_INCH/2) / HIMETRIC_PER_INCH )

static  int     s_iXppli;            // Pixels per logical inch along width
static  int     s_iYppli;            // Pixels per logical inch along height
static  BYTE    s_fGotScreenMetrics; // Are above valid?

//=--------------------------------------------------------------------------=
// GetScreenMetrics
//=--------------------------------------------------------------------------=
// private function we call to set up various metrics the conversion routines
// will use.
//
// Notes:
//
static void GetScreenMetrics
(
    void
)
{
    HDC hDCScreen;

    // we have to critical section this in case two threads are converting
    // things at the same time
    //
    EnterCriticalSection(&g_CriticalSection);
    if (s_fGotScreenMetrics)
        goto Done;

    // we want the metrics for the screen
    //
    hDCScreen = GetDC(NULL);

    ASSERT(hDCScreen, "couldn't get a DC for the screen.");
    s_iXppli = GetDeviceCaps(hDCScreen, LOGPIXELSX);
    s_iYppli = GetDeviceCaps(hDCScreen, LOGPIXELSY);

    ReleaseDC(NULL, hDCScreen);
    s_fGotScreenMetrics = TRUE;

    // we're done with our critical seciton.  clean it up
    //
  Done:
    LeaveCriticalSection(&g_CriticalSection);
}

//=--------------------------------------------------------------------------=
// HiMetricToPixel
//=--------------------------------------------------------------------------=
// converts from himetric to Pixels.
//
// Parameters:
//    const SIZEL *        - [in]  dudes in himetric
//    SIZEL *              - [out] size in pixels.
//
// Notes:
//
void HiMetricToPixel(const SIZEL * lpSizeInHiMetric, LPSIZEL lpSizeInPix)
{
    GetScreenMetrics();

    // We got logical HIMETRIC along the display, convert them to pixel units
    //
    lpSizeInPix->cx = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cx, s_iXppli);
    lpSizeInPix->cy = MAP_LOGHIM_TO_PIX(lpSizeInHiMetric->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// PixelToHiMetric
//=--------------------------------------------------------------------------=
// converts from pixels to himetric.
//
// Parameters:
//    const SIZEL *        - [in]  size in pixels
//    SIZEL *              - [out] size in himetric
//
// Notes:
//
void PixelToHiMetric(const SIZEL * lpSizeInPix, LPSIZEL lpSizeInHiMetric)
{
    GetScreenMetrics();

    // We got pixel units, convert them to logical HIMETRIC along the display
    //
    lpSizeInHiMetric->cx = MAP_PIX_TO_LOGHIM(lpSizeInPix->cx, s_iXppli);
    lpSizeInHiMetric->cy = MAP_PIX_TO_LOGHIM(lpSizeInPix->cy, s_iYppli);
}

//=--------------------------------------------------------------------------=
// _MakePath
//=--------------------------------------------------------------------------=
// little helper routine for RegisterLocalizedTypeLibs and GetResourceHandle.
// not terrilby efficient or smart, but it's registration code, so we don't
// really care.
//
// Notes:
//
void _MakePath
(
    LPSTR pszFull,
    const char * pszName,
    LPSTR pszOut
)
{
    LPSTR psz;
    LPSTR pszLast;

    lstrcpy(pszOut, pszFull);
    psz = pszLast = pszOut;
    while (*psz) {
        if (*psz == '\\')
            pszLast = AnsiNext(psz);
        psz = AnsiNext(psz);
    }

    // got the last \ character, so just go and replace the name.
    //
    lstrcpy(pszLast, pszName);
}

// from Globals.C
//
extern HINSTANCE    g_hInstResources;

//=--------------------------------------------------------------------------=
// GetResourceHandle
//=--------------------------------------------------------------------------=
// returns the resource handle.  we use the host's ambient Locale ID to
// determine, from a table in the DLL, which satellite DLL to load for
// localized resources.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE GetResourceHandle
(
    void
)
{
    int i;
    char szExtension[5], szTmp[MAX_PATH];
    char szDllName[MAX_PATH], szFinalName[MAX_PATH];

    // crit sect this so that we don't mess anything up.
    //
    EnterCriticalSection(&g_CriticalSection);

    // don't do anything if we don't have to
    //
    if (g_hInstResources || !g_fSatelliteLocalization)
        goto CleanUp;

    // we're going to call GetLocaleInfo to get the abbreviated name for the
    // LCID we've got.
    //
    i = GetLocaleInfo(g_lcidLocale, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
    if (!i) goto CleanUp;

    // we've got the language extension.  go and load the DLL name from the
    // resources and then tack on the extension.
    // please note that all inproc sers -must- have the string resource 1001
    // defined to the base name of the server if they wish to support satellite
    // localization.
    //
    i = LoadString(g_hInstance, 1001, szTmp, sizeof(szTmp));
    ASSERT(i, "This server doesn't have IDS_SERVERBASENAME defined in their resources!");
    if (!i) goto CleanUp;

    // got the basename and the extention. go and combine them, and then add
    // on the .DLL for them.
    //
    wsprintf(szDllName, "%s%s.DLL", szTmp, szExtension);

    // try to load in the DLL
    //
    GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
    _MakePath(szTmp, szDllName, szFinalName);

    g_hInstResources = LoadLibrary(szFinalName);

    // if we couldn't find it with the entire LCID, try it with just the primary
    // langid
    //
    if (!g_hInstResources) {
        LPSTR psz;
        LCID lcid;
        lcid = MAKELCID(MAKELANGID(PRIMARYLANGID(LANGIDFROMLCID(g_lcidLocale)), SUBLANG_DEFAULT), SORT_DEFAULT);
        i = GetLocaleInfo(lcid, LOCALE_SABBREVLANGNAME, szExtension, sizeof(szExtension));
        if (!i) goto CleanUp;

        // reconstruct the DLL name.  the -7 is the length of XXX.DLL. mildly
        // hacky, but it should be fine.  there are no DBCS lang identifiers.
        // finally, retry the load
        //
        psz = szFinalName + lstrlen(szFinalName);
        memcpy((LPBYTE)psz - 7, szExtension, 3);
        g_hInstResources = LoadLibrary(szFinalName);
    }

  CleanUp:
    // if we couldn't load the DLL for some reason, then just return the
    // current resource handle, which is good enough.
    //
    if (!g_hInstResources) g_hInstResources = g_hInstance;
    LeaveCriticalSection(&g_CriticalSection);

    return g_hInstResources;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\ipserver.cpp ===
//=--------------------------------------------------------------------------=
// IPServer.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implements all exported DLL functions for the program, as well as a few
// others that will be used by same
//
#include "IPServer.H"
#include "LocalSrv.H"

#include "AutoObj.H"
#include "ClassF.H"
#include "CtrlObj.H"
#include "Globals.H"
#include "Unknown.H"
#include "Util.H"

//=--------------------------------------------------------------------------=
// Private module level data
//
// for ASSERT and FAIL
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// These are used for reflection in OLE Controls.  Not that big of a hit that
// we mind defining them for all servers, including automation or generic
// COM.
//
char g_szReflectClassName [] = "CtlFrameWork_ReflectWindow";
BYTE g_fRegisteredReflect = FALSE;


//=--------------------------------------------------------------------------=
// allow controls to register for DLL_THREAD_ATTACH and DLL_THREAD_DETACH 
//
THRDNFYPROC g_pfnThreadProc = NULL;

extern "C" void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify)
{
    if ((g_pfnThreadProc = pfnThreadNotify) == NULL)
        DisableThreadLibraryCalls((HMODULE)g_hInstance);
}


// ref count for LockServer
//
LONG  g_cLocks;


// private routines for this file.
//
int       IndexOfOleObject(REFCLSID);
HRESULT   RegisterAllObjects(void);
HRESULT   UnregisterAllObjects(void);

//=--------------------------------------------------------------------------=
// DllMain
//=--------------------------------------------------------------------------=
// yon standard LibMain.
//
// Parameters and Output:
//    - see SDK Docs on DllMain
//
// Notes:
//
BOOL WINAPI DllMain
(
    HANDLE hInstance,
    DWORD  dwReason,
    void  *pvReserved
)
{
    int i;

    switch (dwReason) {
      // set up some global variables, and get some OS/Version information
      // set up.
      //
      case DLL_PROCESS_ATTACH:
        {
        DWORD dwVer = GetVersion();
        DWORD dwWinVer;

        //  swap the two lowest bytes of dwVer so that the major and minor version
        //  numbers are in a usable order.
        //  for dwWinVer: high byte = major version, low byte = minor version
        //     OS               Sys_WinVersion  (as of 5/2/95)
        //     =-------------=  =-------------=
        //     Win95            0x035F   (3.95)
        //     WinNT ProgMan    0x0333   (3.51)
        //     WinNT Win95 UI   0x0400   (4.00)
        //
        dwWinVer = (UINT)(((dwVer & 0xFF) << 8) | ((dwVer >> 8) & 0xFF));
        g_fSysWinNT = FALSE;
        g_fSysWin95 = FALSE;
        g_fSysWin95Shell = FALSE;

        if (dwVer < 0x80000000) {
            g_fSysWinNT = TRUE;
            g_fSysWin95Shell = (dwWinVer >= 0x0334);
        } else  {
            g_fSysWin95 = TRUE;
            g_fSysWin95Shell = TRUE;
        }

        // initialize a critical seciton for our apartment threading support
        //
        InitializeCriticalSection(&g_CriticalSection);

        // create an initial heap for everybody to use.
        // currently, we're going to let the system make things thread-safe,
        // which will make them a little slower, but hopefully not enough
        // to notice
        //
        g_hHeap = GetProcessHeap();
        if (!g_hHeap) {
            FAIL("Couldn't get Process Heap.  Not good!");
            return FALSE;
        }

        g_hInstance = (HINSTANCE)hInstance;

        // give the user a chance to initialize whatever
        //
        InitializeLibrary();

        // if they didn't ask for thread notifications then optimize by turning
        // them off for our DLL.
        //
        if (!g_pfnThreadProc)
            DisableThreadLibraryCalls((HMODULE)hInstance);
        }
        break;

      case DLL_THREAD_ATTACH:
      case DLL_THREAD_DETACH:
        if (g_pfnThreadProc)
            g_pfnThreadProc(hInstance, dwReason, pvReserved);
        break;

      // do  a little cleaning up!
      //
      case DLL_PROCESS_DETACH:

        // clean up our critical seciton
        //
        DeleteCriticalSection(&g_CriticalSection);

        // unregister all the registered window classes.
        //
        i = 0;

        while (!ISEMPTYOBJECT(i)) {
            if (g_ObjectInfo[i].usType == OI_CONTROL) {
                if (CTLWNDCLASSREGISTERED(i))
                    UnregisterClass(WNDCLASSNAMEOFCONTROL(i), g_hInstance);
            }
            i++;
        }

        // clean up our parking window.
        //
        if (g_hwndParking) {
            DestroyWindow(g_hwndParking);
            UnregisterClass("CtlFrameWork_Parking", g_hInstance);
            --g_cLocks;
        }

        // clean up after reflection, if appropriate.
        //
        if (g_fRegisteredReflect)
            UnregisterClass(g_szReflectClassName, g_hInstance);

        // give the user a chance to do some cleaning up
        //
        UninitializeLibrary();
        break;
    }

    return TRUE;
}



//=--------------------------------------------------------------------------=
// DllRegisterServer
//=--------------------------------------------------------------------------=
// registers the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllRegisterServer
(
    void
)
{
    HRESULT hr;

    hr = RegisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user registration function.
    //
    return (RegisterData())? S_OK : E_FAIL;
}



//=--------------------------------------------------------------------------=
// DllUnregisterServer
//=--------------------------------------------------------------------------=
// unregister's the Automation server
//
// Output:
//    HRESULT
//
// Notes:
//
STDAPI DllUnregisterServer
(
    void
)
{
    HRESULT hr;

    hr = UnregisterAllObjects();
    RETURN_ON_FAILURE(hr);

    // call user unregistration function
    //
    return (UnregisterData()) ? S_OK : E_FAIL;
}


//=--------------------------------------------------------------------------=
// DllCanUnloadNow
//=--------------------------------------------------------------------------=
// we are being asked whether or not it's okay to unload the DLL.  just check
// the lock counts on remaining objects ...
//
// Output:
//    HRESULT        - S_OK, can unload now, S_FALSE, can't.
//
// Notes:
//
STDAPI DllCanUnloadNow
(
    void
)
{
    // if there are any objects lying around, then we can't unload.  The
    // controlling CUnknownObject class that people should be inheriting from
    // takes care of this
    //
    return (g_cLocks) ? S_FALSE : S_OK;
}


//=--------------------------------------------------------------------------=
// DllGetClassObject
//=--------------------------------------------------------------------------=
// creates a ClassFactory object, and returns it.
//
// Parameters:
//    REFCLSID        - CLSID for the class object
//    REFIID          - interface we want class object to be.
//    void **         - pointer to where we should ptr to new object.
//
// Output:
//    HRESULT         - S_OK, CLASS_E_CLASSNOTAVAILABLE, E_OUTOFMEMORY,
//                      E_INVALIDARG, E_UNEXPECTED
//
// Notes:
//
STDAPI DllGetClassObject
(
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppvObjOut
)
{
    HRESULT hr;
    void   *pv;
    int     iIndex;

    // arg checking
    //
    if (!ppvObjOut)
        return E_INVALIDARG;

    // first of all, make sure they're asking for something we work with.
    //
    iIndex = IndexOfOleObject(rclsid);
    if (iIndex == -1)
        return CLASS_E_CLASSNOTAVAILABLE;

    // create the blank object.
    //
    pv = (void *)new CClassFactory(iIndex);
    if (!pv)
        return E_OUTOFMEMORY;

    // QI for whatever the user has asked for.
    //
    hr = ((IUnknown *)pv)->QueryInterface(riid, ppvObjOut);
    ((IUnknown *)pv)->Release();

    return hr;
}
//=--------------------------------------------------------------------------=
// IndexOfOleObject
//=--------------------------------------------------------------------------=
// returns the index in our global table of objects of the given CLSID.  if
// it's not a supported object, then we return -1
//
// Parameters:
//    REFCLSID     - [in] duh.
//
// Output:
//    int          - >= 0 is index into global table, -1 means not supported
//
// Notes:
//
int IndexOfOleObject
(
    REFCLSID rclsid
)
{
    int x = 0;

    // an object is creatable if it's CLSID is in the table of all allowable object
    // types.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (OBJECTISCREATABLE(x)) {
            if (rclsid == CLSIDOFOBJECT(x))
                return x;
        }
        x++;
    }

    return -1;
}

//=--------------------------------------------------------------------------=
// RegisterAllObjects
//=--------------------------------------------------------------------------=
// registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HERSULT        - S_OK, E_FAIL
//
// Notes:
//
HRESULT RegisterAllObjects
(
    void
)
{
    ITypeLib *pTypeLib;
    HRESULT hr;
    DWORD   dwPathLen;
    char    szTmp[MAX_PATH];
    int     x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        // depending on the object type, register different pieces of information
        //
        switch (g_ObjectInfo[x].usType) {

          // for both simple co-creatable objects and proeprty pages, do the same
          // thing
          //
          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            RegisterUnknownObject(NAMEOFOBJECT(x), CLSIDOFOBJECT(x));
            break;

          case OI_AUTOMATION:
            RegisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                     *g_pLibid, CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            RegisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x),
                                  *g_pLibid, CLSIDOFOBJECT(x), OLEMISCFLAGSOFCONTROL(x),
                                  BITMAPIDOFCONTROL(x));
            break;

        }
        x++;
    }

    // Load and register our type library.
    //
    if (g_fServerHasTypeLibrary) {
        dwPathLen = GetModuleFileName(g_hInstance, szTmp, MAX_PATH);
        MAKE_WIDEPTR_FROMANSI(pwsz, szTmp);
        hr = LoadTypeLib(pwsz, &pTypeLib);
        RETURN_ON_FAILURE(hr);
        hr = RegisterTypeLib(pTypeLib, pwsz, NULL);
        pTypeLib->Release();
        RETURN_ON_FAILURE(hr);
    }

    return S_OK;
}

//=--------------------------------------------------------------------------=
// UnregisterAllObjects
//=--------------------------------------------------------------------------=
// un-registers all the objects for the given automation server.
//
// Parameters:
//    none
//
// Output:
//    HRESULT        - S_OK
//
// Notes:
//
HRESULT UnregisterAllObjects
(
    void
)
{
    int x = 0;

    // loop through all of our creatable objects [those that have a clsid in
    // our global table] and register them.
    //
    while (!ISEMPTYOBJECT(x)) {
        if (!OBJECTISCREATABLE(x)) {
            x++;
            continue;
        }

        switch (g_ObjectInfo[x].usType) {

          case OI_UNKNOWN:
          case OI_PROPERTYPAGE:
            UnregisterUnknownObject(CLSIDOFOBJECT(x));
            break;

          case OI_CONTROL:
            UnregisterControlObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                    CLSIDOFOBJECT(x));
    
          case OI_AUTOMATION:
            UnregisterAutomationObject(g_szLibName, NAMEOFOBJECT(x), VERSIONOFOBJECT(x), 
                                       CLSIDOFOBJECT(x));
            break;

        }
        x++;
    }

    // if we've got one, unregister our type library [this isn't an API function
    // -- we've implemented this ourselves]
    //
    if (g_pLibid)
        UnregisterTypeLibrary(*g_pLibid);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\proppage.cpp ===
//=--------------------------------------------------------------------------=
// PropPage.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation of CPropertyPage object.
//
#include "IPServer.H"
#include "PropPage.H"
#include "Util.H"
#include "Globals.H"

// for ASSERT and FAIL
//
SZTHISFILE

// this variable is used to pass the pointer to the object to the hwnd.
//
static CPropertyPage *s_pLastPageCreated;

//=--------------------------------------------------------------------------=
// CPropertyPage::CPropertyPage
//=--------------------------------------------------------------------------=
// constructor.
//
// Parameters:
//    IUnknown *          - [in] controlling unknown
//    int                 - [in] object type.
//
// Notes:
//
#pragma warning(disable:4355)  // using 'this' in constructor
CPropertyPage::CPropertyPage
(
    IUnknown         *pUnkOuter,
    int               iObjectType
)
: CUnknownObject(pUnkOuter, this), m_ObjectType(iObjectType)
{
    // initialize various dudes.
    //
    m_pPropertyPageSite = NULL;
    m_hwnd = NULL;
    m_fDirty = FALSE;
    m_fActivated = FALSE;
    m_cObjects = 0;
}
#pragma warning(default:4355)  // using 'this' in constructor


//=--------------------------------------------------------------------------=
// CPropertyPage::~CPropertyPage
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CPropertyPage::~CPropertyPage()
{
    // clean up our window.
    //
    if (m_hwnd) {
        SetWindowLongPtr(m_hwnd, GWLP_USERDATA, (LONG_PTR)0xffffffff);
        DestroyWindow(m_hwnd);
    }

    // release all the objects we're holding on to.
    //
    m_ReleaseAllObjects();

    // release the site
    //
    QUICK_RELEASE(m_pPropertyPageSite);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::InternalQueryInterface
//=--------------------------------------------------------------------------=
// we support IPP and IPP2.
//
// Parameters:
//    REFIID        - [in]  interface they want
//    void **       - [out] where they want to put the resulting object ptr.
//
// Output:
//    HRESULT       - S_OK, E_NOINTERFACE
//
// Notes:
//
HRESULT CPropertyPage::InternalQueryInterface
(
    REFIID  riid,
    void  **ppvObjOut
)
{
    IUnknown *pUnk;

    *ppvObjOut = NULL;

    if (DO_GUIDS_MATCH(IID_IPropertyPage, riid)) {
        pUnk = (IUnknown *)this;
    } else if (DO_GUIDS_MATCH(IID_IPropertyPage2, riid)) {
        pUnk = (IUnknown *)this;
    } else {
        return CUnknownObject::InternalQueryInterface(riid, ppvObjOut);
    }

    pUnk->AddRef();
    *ppvObjOut = (void *)pUnk;
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetPageSite    [IPropertyPage]
//=--------------------------------------------------------------------------=
// the initialization function for a property page through which the page
// receives an IPropertyPageSite pointer.
//
// Parameters:
//    IPropertyPageSite *        - [in] new site.
//
// Output:
//    HRESULT
//
// Notes;
//
STDMETHODIMP CPropertyPage::SetPageSite
(
    IPropertyPageSite *pPropertyPageSite
)
{
    RELEASE_OBJECT(m_pPropertyPageSite);
    m_pPropertyPageSite = pPropertyPageSite;
    ADDREF_OBJECT(pPropertyPageSite);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Activate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to create it's display window as a child of hwndparent
// and to position it according to prc.
//
// Parameters:
//    HWND                - [in]  parent window
//    LPCRECT             - [in]  where to position ourselves
//    BOOL                - [in]  whether we're modal or not.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Activate
(
    HWND    hwndParent,
    LPCRECT prcBounds,
    BOOL    fModal
)
{
    HRESULT hr;

    // first make sure the dialog window is loaded and created.
    //
    hr = m_EnsureLoaded();
    RETURN_ON_FAILURE(hr);

    // set our parent window if we haven't done so yet.
    //
    if (!m_fActivated) {
        SetParent(m_hwnd, hwndParent);
        m_fActivated = TRUE;
    }

    // now move ourselves to where we're told to be and show ourselves
    //
    Move(prcBounds);
    ShowWindow(m_hwnd, SW_SHOW);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Deactivate    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to destroy the window created in activate
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Deactivate
(
    void
)
{
    // blow away yon window.
    //
    if (m_hwnd)
        DestroyWindow(m_hwnd);
    m_hwnd = NULL;
    m_fActivated = FALSE;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::GetPageInfo    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to fill a PROPPAGEINFO structure
//
// Parameters:
//    PROPPAGEINFO *    - [out] where to put info.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::GetPageInfo
(
    PROPPAGEINFO *pPropPageInfo
)
{
    RECT rect;

    CHECK_POINTER(pPropPageInfo);

    m_EnsureLoaded();

    // clear it out first.
    //
    memset(pPropPageInfo, 0, sizeof(PROPPAGEINFO));

    pPropPageInfo->pszTitle = OLESTRFROMRESID(TITLEIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszDocString = OLESTRFROMRESID(DOCSTRINGIDOFPROPPAGE(m_ObjectType));
    pPropPageInfo->pszHelpFile = OLESTRFROMANSI(HELPFILEOFPROPPAGE(m_ObjectType));
    pPropPageInfo->dwHelpContext = HELPCONTEXTOFPROPPAGE(m_ObjectType);

    if (!(pPropPageInfo->pszTitle && pPropPageInfo->pszDocString && pPropPageInfo->pszHelpFile))
        goto CleanUp;

    // if we've got a window yet, go and set up the size information they want.
    //
    if (m_hwnd) {
        GetWindowRect(m_hwnd, &rect);

        pPropPageInfo->size.cx = rect.right - rect.left;
        pPropPageInfo->size.cy = rect.bottom - rect.top;
    }

    return S_OK;

  CleanUp:
    if (pPropPageInfo->pszDocString) CoTaskMemFree(pPropPageInfo->pszDocString);
    if (pPropPageInfo->pszHelpFile) CoTaskMemFree(pPropPageInfo->pszHelpFile);
    if (pPropPageInfo->pszTitle) CoTaskMemFree(pPropPageInfo->pszTitle);

    return E_OUTOFMEMORY;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::SetObjects    [IPropertyPage]
//=--------------------------------------------------------------------------=
// provides the page with the objects being affected by the changes.
//
// Parameters:
//    ULONG            - [in] count of objects.
//    IUnknown **      - [in] objects.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::SetObjects
(
    ULONG      cObjects,
    IUnknown **ppUnkObjects
)
{
    HRESULT hr;
    ULONG   x;

    // free up all the old objects first.
    //
    m_ReleaseAllObjects();

    if (!cObjects)
        return S_OK;

    // now go and set up the new ones.
    //
    m_ppUnkObjects = (IUnknown **)HeapAlloc(g_hHeap, 0, cObjects * sizeof(IUnknown *));
    RETURN_ON_NULLALLOC(m_ppUnkObjects);

    // loop through and copy over all the objects.
    //
    for (x = 0; x < cObjects; x++) {
        m_ppUnkObjects[x] = ppUnkObjects[x];
        ADDREF_OBJECT(m_ppUnkObjects[x]);
    }

    // go and tell the object that there are new objects
    //
    hr = S_OK;
    m_cObjects = cObjects;
    // if we've got a window, go and notify it that we've got new objects.
    //
    if (m_hwnd)
        SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);
    if (SUCCEEDED(hr)) m_fDirty = FALSE;

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Show    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to show or hide its window
//
// Parameters:
//    UINT             - [in] whether to show or hide
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Show
(
    UINT nCmdShow
)
{
    if (m_hwnd)
        ShowWindow(m_hwnd, nCmdShow);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Move    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page to relocate and resize itself to a position other than what
// was specified through Activate
//
// Parameters:
//    LPCRECT        - [in] new position and size
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Move
(
    LPCRECT prcBounds
)
{
    // do what they sez
    //
    if (m_hwnd)
        SetWindowPos(m_hwnd, NULL, prcBounds->left, prcBounds->top,
                     prcBounds->right - prcBounds->left,
                     prcBounds->bottom - prcBounds->top,
                     SWP_NOZORDER);
    else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::IsPageDirty    [IPropertyPage]
//=--------------------------------------------------------------------------=
// asks the page whether it has changed its state
//
// Output
//    S_OK            - yep
//    S_FALSE         - nope
//
// Notes:
//
STDMETHODIMP CPropertyPage::IsPageDirty
(
    void
)
{
    return m_fDirty ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Apply    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page to send its changes to all the objects passed through
// SetObjects()
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Apply
(
    void
)
{
    HRESULT hr = S_OK;

    if (m_hwnd) {
        SendMessage(m_hwnd, PPM_APPLY, 0, (LPARAM)&hr);
        RETURN_ON_FAILURE(hr);

        if (m_fDirty) {
            m_fDirty = FALSE;
            if (m_pPropertyPageSite)
                m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY);
        }
    } else
        return E_UNEXPECTED;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::Help    [IPropertyPage]
//=--------------------------------------------------------------------------=
// instructs the page that the help button was clicked.
//
// Parameters:
//    LPCOLESTR        - [in] help directory
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::Help
(
    LPCOLESTR pszHelpDir
)
{
    BOOL f;

    ASSERT(m_hwnd, "How can somebody have clicked Help, but we don't have an hwnd?");

    // oblige them and show the help.
    //
    MAKE_ANSIPTR_FROMWIDE(psz, pszHelpDir);
    f = WinHelp(m_hwnd, psz, HELP_CONTEXT, HELPCONTEXTOFPROPPAGE(m_ObjectType));

    return f ? S_OK : E_FAIL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::TranslateAccelerator    [IPropertyPage]
//=--------------------------------------------------------------------------=
// informs the page of keyboard events, allowing it to implement it's own
// keyboard interface.
//
// Parameters:
//    LPMSG            - [in] message that triggered this
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::TranslateAccelerator
(
    LPMSG pmsg
)
{
    ASSERT(m_hwnd, "How can we get a TranslateAccelerator call if we're not visible?");

    // just pass this message on to the dialog proc and see if they want it.
    //
    return IsDialogMessage(m_hwnd, pmsg) ? S_OK : S_FALSE;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::EditProperty    [IPropertyPage2]
//=--------------------------------------------------------------------------=
// instructs the page to set the focus to the property matching the dispid.
//
// Parameters:
//    DISPID            - [in] dispid of property to set focus to.
//
// Output:
//    HRESULT
//
// Notes:
//
STDMETHODIMP CPropertyPage::EditProperty
(
    DISPID dispid
)
{
    HRESULT hr = E_NOTIMPL;

    // send the message on to the control, and see what they want to do with it.
    //
    SendMessage(m_hwnd, PPM_EDITPROPERTY, (WPARAM)dispid, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::m_EnsureLoaded
//=--------------------------------------------------------------------------=
// makes sure the dialog is actually loaded
//
// Output:
//    HRESULT
//
// Notes:
//
HRESULT CPropertyPage::m_EnsureLoaded
(
    void
)
{
    HRESULT hr = S_OK;

    // duh
    //
    if (m_hwnd)
        return S_OK;

    // set up the global variable so that when we're in the dialog proc, we can
    // stuff this in the hwnd
    //
    // crit sect this whole creation process for apartment threading support.
    //
    EnterCriticalSection(&g_CriticalSection);
    s_pLastPageCreated = this;

    // create the dialog window
    //
    CreateDialog(GetResourceHandle(), TEMPLATENAMEOFPROPPAGE(m_ObjectType), GetParkingWindow(),
                          CPropertyPage::PropPageDlgProc);
    ASSERT(m_hwnd, "Couldn't load Dialog Resource!!!");
    if (!m_hwnd) {
        LeaveCriticalSection(&g_CriticalSection);
        return HRESULT_FROM_WIN32(GetLastError());
    }

    // clean up variables and leave the critical section
    //
    s_pLastPageCreated = NULL;
    LeaveCriticalSection(&g_CriticalSection);

    // go and notify the window that it should pick up any objects that are
    // available
    //
    SendMessage(m_hwnd, PPM_NEWOBJECTS, 0, (LPARAM)&hr);

    return hr;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::m_ReleaseAllObjects
//=--------------------------------------------------------------------------=
// releases all the objects that we're working with
//
// Notes:
//
void CPropertyPage::m_ReleaseAllObjects
(
    void
)
{
    HRESULT hr;
    UINT x;

    if (!m_cObjects)
        return;

    // some people will want to stash pointers in the PPM_INITOBJECTS case, so
    // we want to tell them to release them now.
    //
    SendMessage(m_hwnd, PPM_FREEOBJECTS, 0, (LPARAM)&hr);

    // loop through and blow them all away.
    //
    for (x = 0; x < m_cObjects; x++)
        QUICK_RELEASE(m_ppUnkObjects[x]);

    HeapFree(g_hHeap, 0, m_ppUnkObjects);
    m_ppUnkObjects = NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::PropPageDlgProc
//=--------------------------------------------------------------------------=
// static global helper dialog proc that gets called before we pass the message
// on to anybody ..
//
// Parameters:
//    - see win32sdk docs on DialogProc
//
// Notes:
//
INT_PTR CALLBACK CPropertyPage::PropPageDlgProc
(
    HWND    hwnd,
    UINT    msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    CPropertyPage *pPropertyPage;

    // get the window long, and see if it's been set to the object this hwnd
    // is operating against.  if not, go and set it now.
    //
    pPropertyPage = (CPropertyPage *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    if (pPropertyPage == (CPropertyPage *)-1)
        return FALSE;
    if (!pPropertyPage) {
        SetWindowLongPtr(hwnd, GWLP_USERDATA, (LONG_PTR)s_pLastPageCreated);
        pPropertyPage = s_pLastPageCreated;
        pPropertyPage->m_hwnd = hwnd;
    }

    ASSERT(pPropertyPage, "Uh oh.  Got a window, but no CpropertyPage for it!");

    // just call the user dialog proc and see if they want to do anything.
    //
    return pPropertyPage->DialogProc(hwnd, msg, wParam, lParam);
}


//=--------------------------------------------------------------------------=
// CPropertyPage::FirstControl
//=--------------------------------------------------------------------------=
// returns the first controlish object that we are showing ourselves for.
// returns a cookie that must be passed in for Next ...
//
// Parameters:
//    DWORD *    - [out] cookie to be used for Next
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::FirstControl
(
    DWORD *pdwCookie
)
{
    // just use the implementation of NEXT.
    //
    *pdwCookie = 0;
    return NextControl(pdwCookie);
}

//=--------------------------------------------------------------------------=
// CPropertyPage::NextControl
//=--------------------------------------------------------------------------=
// returns the next control in the chain of people to work with given a cookie
//
// Parameters:
//    DWORD *            - [in/out] cookie to get next from, and new cookie.
//
// Output:
//    IUnknown *
//
// Notes:
//
IUnknown *CPropertyPage::NextControl
(
    DWORD *pdwCookie
)
{
    UINT      i;

    // go looking through all the objects that we've got, and find the
    // first non-null one.
    //
    for (i = *pdwCookie; i < m_cObjects; i++) {
        if (!m_ppUnkObjects[i]) continue;

        *pdwCookie = i + 1;                // + 1 so we start at next item next time
        return m_ppUnkObjects[i];
    }

    // couldn't find it .
    //
    *pdwCookie = 0xffffffff;
    return NULL;
}

//=--------------------------------------------------------------------------=
// CPropertyPage::MakeDirty    [helper, callable]
//=--------------------------------------------------------------------------=
// marks a page as dirty.
//
// Notes:
//
void CPropertyPage::MakeDirty
(
    void
)
{
    m_fDirty = TRUE;
    if (m_pPropertyPageSite)
        m_pPropertyPageSite->OnStatusChange(PROPPAGESTATUS_DIRTY|PROPPAGESTATUS_VALIDATE);
}


// from Globals.C
//
extern HINSTANCE g_hInstResources;


//=--------------------------------------------------------------------------=
// CPropertyPage::GetResourceHandle    [helper, callable]
//=--------------------------------------------------------------------------=
// returns current resource handle, based on pagesites ambient LCID.
//
// Output:
//    HINSTANCE
//
// Notes:
//
HINSTANCE CPropertyPage::GetResourceHandle
(
    void
)
{
    if (!g_fSatelliteLocalization)
        return g_hInstance;

    // if we've already got it, then there's not all that much to do.
    // don't need to crit sect this one right here since even if they do fall
    // into the ::GetResourceHandle call, it'll properly deal with things.
    //
    if (g_hInstResources)
        return g_hInstResources;

    // we'll get the ambient localeid from the host, and pass that on to the
    // automation object.
    //
    // enter a critical section for g_lcidLocale and g_fHavelocale
    //
    EnterCriticalSection(&g_CriticalSection);
    if (!g_fHaveLocale) {
        if (m_pPropertyPageSite) {
            m_pPropertyPageSite->GetLocaleID(&g_lcidLocale);
            g_fHaveLocale = TRUE;
        }
    }
    LeaveCriticalSection(&g_CriticalSection);

    return ::GetResourceHandle();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\framewrk\strcoll.cpp ===
//=--------------------------------------------------------------------------=
// StrColl.Cpp
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// implementation for our simple strings collections.
//
#include "IPServer.H"

#include "SimpleEnumVar.H"
#include "StringsColl.H"


// for asserts
//
SZTHISFILE


//=--------------------------------------------------------------------------=
// CStringsCollection::CStringsCollection
//=--------------------------------------------------------------------------=
// constructor. sets up the safearray pointer.
//
// Parameters:
//    SAFEARRAY        - [in] the collection we're working with.
//
// Notes:
//
CStringCollection::CStringCollection
(
    SAFEARRAY *psa
)
: m_psa(psa)
{
    ASSERT(m_psa, "Bogus Safearray pointer!");
}

//=--------------------------------------------------------------------------=
// CStringCollection::~CStringCollection
//=--------------------------------------------------------------------------=
//
// Notes:
//
CStringCollection::~CStringCollection()
{
}

//=--------------------------------------------------------------------------=
// CStringCollection::get_Count
//=--------------------------------------------------------------------------=
// returns the count of the things in the collection
//
// Parameters:
//    long *         - [out] the count
//
// Output:
//    HRESULT        - S_OK, one of the SAFEARRAY Scodes.
//
// Notes:
//    - we're assuming the safearray's lower bound is zero!
//
STDMETHODIMP CStringCollection::get_Count
(
    long *plCount
)
{
    HRESULT hr;

    ASSERT(m_psa, "Who created a collection without a SAFEARRAY?");

    CHECK_POINTER(plCount);

    // get the bounds.
    //
    hr = SafeArrayGetUBound(m_psa, 1, plCount);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // add one since we're zero-offset
    //
    (*plCount)++;

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringCollection::get_Item
//=--------------------------------------------------------------------------=
// returns a string given an INDEX
//
// Parameters:
//    long          - [in]  the index to get it from
//    BSTR *        - [out] the item
//
// Output:
//    HRESULT       - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStringCollection::get_Item
(
    long  lIndex,
    BSTR *pbstrItem
)
{
    HRESULT hr;

    CHECK_POINTER(pbstrItem);

    // get the element from the safearray
    //
    hr = SafeArrayGetElement(m_psa, &lIndex, pbstrItem);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // otherwise, we've got it, so we can return
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringCollection::get__NewEnum
//=--------------------------------------------------------------------------=
// returns a new IEnumVARIANT object with the collection in it.
//
// Parameters:
//    IUnknown     **    - [out] new enumvariant object.
//
// Output:
//    HRESULT            - S_OK, E_OUTOFMEMORY
//
// Notes:
//
STDMETHODIMP CStringCollection::get__NewEnum
(
    IUnknown **ppUnkNewEnum
)
{
    HRESULT hr;
    long    l;

    CHECK_POINTER(ppUnkNewEnum);

    // get the count of things in the SAFEARRAY
    //
    hr = get_Count(&l);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // create the object.
    //
    *ppUnkNewEnum = (IUnknown *) new CSimpleEnumVariant(m_psa, l);
    if (!*ppUnkNewEnum)
        CLEARERRORINFORET(E_OUTOFMEMORY);

    // refcount is already 1, so we can leave.
    //
    return S_OK;
}

//=--------------------------------------------------------------------------=
//=--------------------------------------------------------------------------=
// CStringDynaCollection::CStringDynaCollection
//=--------------------------------------------------------------------------=
// constructor for this object.  doesn't do very much.
//
// Parameters:
//    same as for CStringCollection
//
// Notes:
//
CStringDynaCollection::CStringDynaCollection
(
    SAFEARRAY *psa
)
: CStringCollection(psa)
{
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::~CStringDynaCollection
//=--------------------------------------------------------------------------=
// destructor.
//
// Notes:
//
CStringDynaCollection::~CStringDynaCollection()
{
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::put_Item
//=--------------------------------------------------------------------------=
// sets the value of an item in the array.
//
// Parameters:
//    long         - [in] index at which to put it
//    BSTR         - [in] new value.
//
// Output:
//    HRESULT      - S_OK, safearray Scode.
//
// Notes:
//    - NULLs are converted to ""
//
STDMETHODIMP CStringDynaCollection::put_Item
(
    long lIndex,
    BSTR bstr
)
{
    HRESULT hr;
    long l;
    BSTR bstr2 = NULL;

    // get the count and verify our index
    //
    hr = get_Count(&l);
    RETURN_ON_FAILURE(hr);
    if (lIndex < 0 || lIndex >= l)
        CLEARERRORINFORET(E_INVALIDARG);
    
    // put out the string, convert NULLs to ""
    //
    if (!bstr) {
        bstr2 = SysAllocString(L"");
        RETURN_ON_NULLALLOC(bstr2);
    }

    hr = SafeArrayPutElement(m_psa, &lIndex, (bstr) ? bstr : bstr2);
    if (bstr2) SysFreeString(bstr2);
    CLEARERRORINFORET_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::Add
//=--------------------------------------------------------------------------=
// adds a new string to the end of the collection.
//
// Parameters:
//    BSTR         - [in] the new string to add
//
// Notes:
//
STDMETHODIMP CStringDynaCollection::Add
(
    BSTR bstr
)
{
    SAFEARRAYBOUND sab;
    BSTR    bstr2 = NULL;
    HRESULT hr;
    long    l;

    // get the current size of the array.
    //
    hr = get_Count(&l);
    RETURN_ON_FAILURE(hr);

    // add one new elemnt
    //
    sab.cElements = l + 1;
    sab.lLbound = 0;

    // redim the array.
    //
    hr = SafeArrayRedim(m_psa, &sab);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // put the out string, converting NULLs to ""
    //
    if (!bstr) {
        bstr2 = SysAllocString(L"");
        RETURN_ON_NULLALLOC(bstr2);
    }

    hr = SafeArrayPutElement(m_psa, &l, (bstr) ? bstr : bstr2);
    if (bstr2) SysFreeString(bstr2);
    CLEARERRORINFORET_ON_FAILURE(hr);

    return S_OK;
}

//=--------------------------------------------------------------------------=
// CStringDynaCollection::Remove
//=--------------------------------------------------------------------------=
// removes an element from the collection, and shuffles all the rest down to
// fill up the space.
//
// Parameters:
//    long         - [in] index of dude to remove.
//
// Output:
//    HRESULT      - S_OK, safearray Scodes.
//
// Notes:
//
STDMETHODIMP CStringDynaCollection::Remove
(
    long lIndex
)
{
    SAFEARRAYBOUND sab;
    HRESULT hr;
    BSTR    bstr;
    long    lCount;
    long    x, y;

    // first get the count of things in our array.
    //
    hr = get_Count(&lCount);
    RETURN_ON_FAILURE(hr);

    // check the index
    //
    if (lIndex < 0 || lIndex >= lCount)
        CLEARERRORINFORET(E_INVALIDARG);

    // let's go through, shuffling everything down one.
    //
    for (x = lIndex, y = x + 1; x < lCount - 1; x++, y++) {
        // get the next element.
        //
        hr = SafeArrayGetElement(m_psa, &y, &bstr);
        CLEARERRORINFORET_ON_FAILURE(hr);

        // set it at the current location
        //
        hr = SafeArrayPutElement(m_psa, &x, bstr);
        CLEARERRORINFORET_ON_FAILURE(hr);
    }

    // we're at the last element.  let's go and kill it.
    //
    sab.cElements = lCount - 1;
    sab.lLbound = 0;

    // CONSIDER: 9.95 -- there is a bug in oleaut32.dll which causes the
    //         below to fail if cElements = 0.
    //
    hr = SafeArrayRedim(m_psa, &sab);
    CLEARERRORINFORET_ON_FAILURE(hr);

    // we're done.  go bye-bye.
    //
    return S_OK;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\autoobj.h ===
//=--------------------------------------------------------------------------=
// AutoObj.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// all of our objects will inherit from this class to share as much of the same
// code as possible.  this super-class contains the unknown and dispatch
// implementations for them.
//
#ifndef _AUTOOBJ_H_

// all automation objects will use the Unknown object that supports aggegation.
//
#include "Unknown.H"

//=--------------------------------------------------------------------------=
// the constants in this header file uniquely identify your automation objects.
// make sure that for each object you have in the g_ObjectInfo table, you have
// a constant in this header file.
//
#include "LocalSrv.H"
#include "extobj.h"

//=--------------------------------------------------------------------------=
// AUTOMATIONOBJECTINFO
//=--------------------------------------------------------------------------=
// for each automation object type you wish to expose to the programmer/user
// that is not a control, you must fill out one of these structures.  if the
// object isn't CoCreatable, then the first four fields should be empty.
// otherwise, they should be filled in with the appropriate information.
// use the macro DEFINE_AUTOMATIONOBJECT to both declare and define your object.
// make sure you have an entry in the global table of objects, g_ObjectInfo
// in the main .Cpp file for your InProc server.
//
typedef struct {

    UNKNOWNOBJECTINFO unknowninfo;               // fill in with 0's if we're not CoCreatable
    long         lVersion;                       // Version number of Object.  ONLY USE IF YOU'RE CoCreatable!
    const IID   *riid;                           // object's type
    LPCSTR       pszHelpFile;                    // the helpfile for this automation object.
    ITypeInfo   *pTypeInfo;                      // typeinfo for this object
    UINT         cTypeInfo;                      // number of refs to the type info

} AUTOMATIONOBJECTINFO;

// macros to manipulate the AUTOMATIONOBJECTINFO in the global table table.
//
#define VERSIONOFOBJECT(index)         ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->lVersion
#define INTERFACEOFOBJECT(index)       *(((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->riid)
#define PPTYPEINFOOFOBJECT(index)      &((((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo))
#define PTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pTypeInfo
#define CTYPEINFOOFOBJECT(index)       ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->cTypeInfo
#define HELPFILEOFOBJECT(index)        ((AUTOMATIONOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszHelpFile


#ifndef INITOBJECTS

#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
extern AUTOMATIONOBJECTINFO name##Object \

#else
#define DEFINE_AUTOMATIONOBJECT(name, clsid, objname, fn, ver, riid, pszh) \
    AUTOMATIONOBJECTINFO name##Object = { { clsid, objname, fn }, ver, riid, pszh, NULL, 0} \

#endif // INITOBJECTS

//=--------------------------------------------------------------------------=
// Standard Dispatch and SupportErrorInfo
//=--------------------------------------------------------------------------=
// all objects should declare these in their class definitions so that they
// get standard implementations of IDispatch and ISupportErrorInfo.
//
#define DECLARE_STANDARD_DISPATCH() \
    STDMETHOD(GetTypeInfoCount)(UINT *pctinfo) { \
        return CAutomationObject::GetTypeInfoCount(pctinfo); \
    } \
    STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo **ppTypeInfoOut) { \
        return CAutomationObject::GetTypeInfo(itinfo, lcid, ppTypeInfoOut); \
    } \
    STDMETHOD(GetIDsOfNames)(REFIID riid, OLECHAR **rgszNames, UINT cnames, LCID lcid, DISPID *rgdispid) { \
        return CAutomationObject::GetIDsOfNames(riid, rgszNames, cnames, lcid, rgdispid); \
    } \
    STDMETHOD(Invoke)(DISPID dispid, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pdispparams, VARIANT *pVarResult, EXCEPINFO *pexcepinfo, UINT *puArgErr) { \
        return CAutomationObject::Invoke(dispid, riid, lcid, wFlags, pdispparams, pVarResult, pexcepinfo, puArgErr); \
    } \


#define DECLARE_STANDARD_SUPPORTERRORINFO() \
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid) { \
        return CAutomationObject::InterfaceSupportsErrorInfo(riid); \
    } \

enum {EXPANDO_DISABLED=FALSE, EXPANDO_ENABLED=TRUE};

//=--------------------------------------------------------------------------=
// CAutomationObject
//=--------------------------------------------------------------------------=
// global class that all automation objects can inherit from to give them a
// bunch of implementation for free, namely IDispatch and ISupportsErrorInfo
//
//
class CAutomationObject : public CUnknownObject {

  public:
    // aggreation query interface support
    //
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    // IDispatch methods
    //
    STDMETHOD(GetTypeInfoCount)(UINT *);
    STDMETHOD(GetTypeInfo)(UINT, LCID, ITypeInfo **);
    STDMETHOD(GetIDsOfNames)(REFIID, OLECHAR **, UINT, LCID, DISPID *);
    STDMETHOD(Invoke)(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    //  ISupportErrorInfo methods
    //
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID);

    CAutomationObject(IUnknown *, int , void *, BOOL fExpandoEnabled=FALSE);
    virtual ~CAutomationObject();

    // callable functions -- things that most people will find useful.
    //
    virtual HINSTANCE GetResourceHandle(void);
    HRESULT Exception(HRESULT hr, WORD idException, DWORD dwHelpContextID);

  protected:
    // member variables that derived objects might need to get at information in the
    // global object table
    //
    int   m_ObjectType;

  private:
    // member variables we don't share.
    //
    BYTE  m_fLoadedTypeInfo;
	BYTE  m_fExpandoEnabled;
	CExpandoObject* m_pexpando;
};


#define _AUTOOBJ_H_
#endif // _AUTOOBJ_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\datapath.h ===
#ifndef __datapath_h__
#define __datapath_h__

#ifdef __cplusplus
extern "C"{
#endif

#include <ocidl.h>

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\debug.h ===
//=--------------------------------------------------------------------------=
// Debug.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the various macros and the like which are only useful in DEBUG
// builds
//
#ifndef _DEBUG_H_

//=---------------------------------------------------------------------------=
// all the things required to handle our ASSERT mechanism
//=---------------------------------------------------------------------------=
//
#if DEBUG

// Function Prototypes
//
VOID DisplayAssert(LPSTR pszMsg, LPSTR pszAssert, LPSTR pszFile, UINT line);

// Macros
//
// *** Include this macro at the top of any source file using *ASSERT*() macros ***
//
#define SZTHISFILE	static char _szThisFile[] = __FILE__;


// our versions of the ASSERT and FAIL macros.
//
#define ASSERT(fTest, szMsg)                                \
    if (!(fTest))  {                                        \
        static char szMsgCode[] = szMsg;                    \
        static char szAssert[] = #fTest;                    \
        DisplayAssert(szMsgCode, szAssert, _szThisFile, __LINE__); \
    }

#define FAIL(szMsg)                                         \
        { static char szMsgCode[] = szMsg;                    \
        DisplayAssert(szMsgCode, "FAIL", _szThisFile, __LINE__); }



// macro that checks a pointer for validity on input
//
#define CHECK_POINTER(val) if (!(val) || IsBadWritePtr((void *)(val), sizeof(void *))) return E_POINTER

#else  // DEBUG

#define SZTHISFILE
#define ASSERT(fTest, err)
#define FAIL(err)

#define CHECK_POINTER(val)
#endif	// DEBUG




#define _DEBUG_H_
#endif // _DEBUG_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\extobj.h ===
#ifndef __EXTOBJ_H
#define __EXTOBJ_H
////
//
// ExpandoObject header file
//
//
//
#include "IPServer.H"

////
//
// IDispatchEx
//
////

////
//
// the GUID
//

// {A0AAC450-A77B-11cf-91D0-00AA00C14A7C}
DEFINE_GUID(IID_IDispatchEx, 0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c);

////
//
// IDispatchEx flags:
//

enum
{
	fdexNil = 0x00,				// empty
	fdexDontCreate = 0x01,		// don't create slot if non-existant otherwise do
	fdexInitNull = 0x02,		// init a new slot to VT_NULL as opposed to VT_EMPTY
	fdexCaseSensitive = 0x04,	// match names as case sensitive
};

////
//
// This is the interface for extensible IDispatch objects.
//

class IDispatchEx : public IDispatch
{
public:
	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgid,
		DWORD grfdex
	) = 0;

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(
		DISPID id,
		DISPID *pid,
		BSTR *pbstrName
	) = 0;
};

////
//
// Globals and definitions
//
////

#define NUM_EXPANDO_DISPIDS		250
#define	NUM_CORE_DISPIDS		250
#define NUM_RESERVED_EXTENDER_DISPIDS (NUM_CORE_DISPIDS + NUM_EXPANDO_DISPIDS)
#define EXTENDER_DISPID_BASE ((ULONG)(0x80010000))
#define IS_EXTENDER_DISPID(x) ( ( (ULONG)(x) & 0xFFFF0000 ) == EXTENDER_DISPID_BASE )

////
//
// Slot: the state of a value slot
//

inline WCHAR ToUpper(WCHAR ch)
{
	if (ch>='a' && ch <= 'z')
		return ch - 'a' + 'A';
	else
		return ch;

}

class CExpandoObjectSlot
{
public:
	////
	//
	// Constructor/Destructor
	//

	// because these monsters are malloc'ed, we need a manual constructor and destructor methods
	void Construct()
	{
		m_name = NULL;
		m_next = -1;
		VariantInit(&m_value);
		// set hash and dispId to dummy values
		m_hash = 0;
		m_dispId = DISPID_UNKNOWN;
	}

	void Destruct()
	{
		if (m_name)
			SysFreeString(m_name);
		VariantClear(&m_value);
	}

private:
	// the constructors and destructors are private because they should never be called ...
	// we could use in-place construction if we wanted to be clever ...
	CExpandoObjectSlot()
	{
	}

	~CExpandoObjectSlot()
	{
	}

public:
	////
	//
	// Init the slot
	//

	HRESULT Init(LPOLESTR name, LCID lcid, DISPID dispId, VARIANT* value)
	{
		// allocate the string
		m_name = SysAllocString(name);
		if (m_name == NULL)
			return E_OUTOFMEMORY;

		// compute the hash: uses the standard OLE string hashing function
		// note that this function is case insensitive
		m_hash = LHashValOfName(lcid, name);

		// set the dispId
		m_dispId = dispId;

		// Copy the variant value
		return VariantCopy(&m_value, value);
	}

	////
	//
	// Name information
	//

	// get the name
	BSTR Name()
	{ return m_name; }

	// compare two names
	BOOL CompareName(LPOLESTR name, ULONG hash, BOOL caseSensitive)
	{

		// hash should be the same, length should be the same, and strings should compare
		// BUGBUG robwell 8May96 These functions are probably verboten.
		if (hash != m_hash)
			return FALSE;

		if (!name)
			return !m_name;

		WCHAR *c1 = name;
		WCHAR *c2 = m_name;

		// Travel down both strings until we reach a mismatched character
		// or the end of one (or both) of the strings

		if (caseSensitive)
			while (*c1 && *c2 && *c1++==*c2++);
		else
			while (*c1 && *c2 && ToUpper(*c1++)==ToUpper(*c2++));

		// The strings match if we reached the end of both without a mismatch
		return !*c1 && !*c2;
 	}

	////
	//
	// DispId information
	//

	// get the dispatch id
	DISPID DispId()
	{ return m_dispId; }

	////
	//
	// Get and set the property values
	//

	HRESULT Get(VARIANT* result)
	{ return VariantCopy(result, &m_value); }

	HRESULT Set(VARIANT* value)
	{ return VariantCopy(&m_value, value); }

	////
	//
	// List management
	//

	CExpandoObjectSlot* Next(CExpandoObjectSlot* base)
	{ return m_next == -1? NULL: &base[m_next]; }

	CExpandoObjectSlot* Insert(CExpandoObjectSlot* base, LONG& prev)
	{
		m_next = prev;
		prev = (LONG)(this - base);
		return this;
	}

private:
	// the DispId
	DISPID		m_dispId;
	// the name
	LPOLESTR	m_name;
	// the name hash
	ULONG		m_hash;
	// the property value
	VARIANT		m_value;
	// the hash bucket link (index based)
	LONG		m_next;
};

// NB: CExpandoObject implements a crippled version of aggegation.
// It delegates all IUnknown calls to its controlling IUnknown, and has no
// private IUnknown interface.
// If you want the CExpandoObject to go away, simply call delete on it.
class CExpandoObject: public IDispatchEx
{
public:

	////
	//
	// Constructor/Destructor
	//

	CExpandoObject(IUnknown *punkOuter, IDispatch *pdisp, ULONG dispIdBase = EXTENDER_DISPID_BASE + NUM_CORE_DISPIDS)
	{
		// remember our controlling outer
		m_punkOuter = punkOuter;

		// remember the IDispatch to try first for IDispatch functionality
		m_pdisp = pdisp;
		
		// clear the name hash table
		ClearHashTable();
		// set the total slots and the table of slots to 0 and empty respectively)
		m_totalSlots = 0;
		m_slotTableSize = 0;
		m_slots = NULL;
		m_dispIdBase = dispIdBase;
	}

	STDMETHODIMP_(ULONG) AddRef()
	{
		return m_punkOuter->AddRef();
	}

	STDMETHODIMP_(ULONG)Release()
	{
		return m_punkOuter->Release();
	}

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObjOut)
	{
		return m_punkOuter->QueryInterface(riid, ppvObjOut);
	}

    virtual ~CExpandoObject(void)
	{
		FreeAllSlots();
	}


    // Copy all of the properties from obj
   	HRESULT CloneProperties(CExpandoObject& obj);

	////
	//
	//
	// Utility functions
	//

	// free all slots
	void FreeAllSlots();

	// IDispatch methods
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfoCount(UINT *pctinfo);
	virtual HRESULT STDMETHODCALLTYPE GetTypeInfo(
		UINT itinfo,
		LCID lcid,
		ITypeInfo **pptinfo
	);
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNames(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgdispID
	);
	virtual HRESULT STDMETHODCALLTYPE Invoke(
		DISPID dispID,
		REFIID riid,
		LCID lcid,
		WORD wFlags,
		DISPPARAMS *pdispparams,
		VARIANT *pvarRes,
		EXCEPINFO *pexcepinfo,
		UINT *puArgErr
	);

	// IDispatchEx methods

	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(
		REFIID riid,
		LPOLESTR *prgpsz,
		UINT cpsz,
		LCID lcid,
		DISPID *prgid,
		DWORD grfdex
	);

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, NOERROR if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(
		DISPID id,
		DISPID *pid,
		BSTR *pbstrName
	);

private:
	////
	//
	// Implementation constants
	//

	enum
	{
		kSlotHashTableSize = 10,
		kInitialSlotTableSize = 4,
		kMaxTotalSlots = NUM_EXPANDO_DISPIDS
	};

	////
	//
	// Utility functions
	//

	//
	CExpandoObjectSlot* GetHashTableHead(UINT hashIndex)
	{
		LONG index;

		return (index = m_hashTable[hashIndex]) == -1? NULL: &m_slots[index];
	}

	// get the ID of from a slot name
	HRESULT GetIDOfName(LPOLESTR name, LCID lcid, BOOL caseSensitive, DISPID* id);
	// add a slot to the object
	HRESULT AddSlot(LPOLESTR name, LCID lcid, BOOL caseSensitive, VARIANT* initialValue, DISPID* id);
	// allocate a slot from the slot table
	CExpandoObjectSlot* AllocSlot();
	// clear the hash table
	void ClearHashTable()
	{
		UINT i;

		for (i=0; i<kSlotHashTableSize; ++i)
			m_hashTable[i] = -1;
	}

	////
	//
	// Slot operations
	//
	// DISPIDS start at kInitialDispId so we need to offset them by that amount
	// in this code.
	//

	HRESULT GetSlot(DISPID id, VARIANT* result)
	{
		if ((ULONG) id < m_dispIdBase || (ULONG) id >= (m_totalSlots+m_dispIdBase))
			return DISP_E_MEMBERNOTFOUND;

		return m_slots[id-m_dispIdBase].Get(result);
	}

	HRESULT SetSlot(DISPID id, VARIANT* result)
	{
		if ((ULONG) id < m_dispIdBase || (ULONG) id >= (m_totalSlots+m_dispIdBase))
			return DISP_E_MEMBERNOTFOUND;

		return m_slots[id-m_dispIdBase].Set(result);
	}

	////
	//
	// Iteration operations
	//

	UINT	NumDispIds()
	{ return m_totalSlots; }

	DISPID	First()
	{ return m_dispIdBase; }

	DISPID	Last()
	{ return m_totalSlots + m_dispIdBase - 1; }

	BOOL	ValidDispId(DISPID id)
	{ return id >= First() && id <= Last(); }

	HRESULT	Next(DISPID key, CExpandoObjectSlot*& slot)
	{
		// zero restarts the enumerator
		if (key == 0)
		{
			// if there are no slots we are done
			if (NumDispIds() == 0)
				return S_FALSE;

			// return the first slot
			slot = &m_slots[0];
			return NOERROR;
		}
		else
		if (key == Last())
		{
			// the key was the last slot so we are done
			return S_FALSE;
		}
		else
		if (ValidDispId(key))
		{
			// return the next slot
			slot = &m_slots[key-m_dispIdBase+1];
			return NOERROR;
		}
		else
			// the key must be invalid
			return E_INVALIDARG;
	}

	////
	//
	// The local state of the object
	//

	// the objects reference count
	ULONG	m_ref;

	// the base of objectIds
	ULONG	m_dispIdBase;

	// the hash table of slots - for fast GetIDSofNames lookup
	LONG	m_hashTable[kSlotHashTableSize];

	// the number of slots (and the next dispId to allocate)
	UINT	m_totalSlots;

	// the size of the allocated array of slots
	UINT	m_slotTableSize;

	// a pointer to the allocated array of slots
	CExpandoObjectSlot* m_slots;

	// controlling unknown
	IUnknown *m_punkOuter;

	// controlling IDispatch
	IDispatch *m_pdisp;
};

#endif // __EXTOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\globals.h ===
//=--------------------------------------------------------------------------=
// Globals.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains externs and stuff for Global variables, etc ..
//
#ifndef _GLOBALS_H_

// the library that we are
//
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// support for licensing
//
extern BOOL   g_fMachineHasLicense;
extern BOOL   g_fCheckedForLicense;

//=--------------------------------------------------------------------------=
// does our server have a type library?
//
extern BOOL   g_fServerHasTypeLibrary;

//=--------------------------------------------------------------------------=
// our instance handle, and various pieces of information interesting to
// localization
//
extern HINSTANCE    g_hInstance;

extern const VARIANT_BOOL g_fSatelliteLocalization;
extern VARIANT_BOOL       g_fHaveLocale;
extern LCID               g_lcidLocale;

//=--------------------------------------------------------------------------=
// apartment threading support.
//
extern CRITICAL_SECTION g_CriticalSection;

//=--------------------------------------------------------------------------=
// our global memory allocator and global memory pool
//
extern HANDLE   g_hHeap;

//=--------------------------------------------------------------------------=
// global parking window for parenting various things.
//
extern HWND     g_hwndParking;

//=--------------------------------------------------------------------------=
// system information
//
extern BOOL g_fSysWin95;                    // we're under Win95 system, not just NT SUR
extern BOOL g_fSysWinNT;                    // we're under some form of Windows NT
extern BOOL g_fSysWin95Shell;               // we're under Win95 or Windows NT SUR { > 3/51)

#define _GLOBALS_H_
#endif // _GLOBALS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\ctrlobj.h ===
//=--------------------------------------------------------------------------=
// CtrlObj.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the COleControl object
//
#ifndef _CTRLOBJ_H_

// we need the automation object and ctlole.h
//
#include "AutoObj.H"
#include <olectl.h>

// forward declaration
//
class COleControl;

//=--------------------------------------------------------------------------=
// Misc Helper Functions
//=--------------------------------------------------------------------------=
//
// given an Unknown pointer, get the COleControl * for it.  used typically
// in property page code.
//
COleControl *ControlFromUnknown(IUnknown *);


//=--------------------------------------------------------------------------=
// Misc Constants
//=--------------------------------------------------------------------------=
// maximum number of arguments that can be sent to FireEvent()
//
#define MAX_ARGS    32

// for the types of sinks that the COleControl class has.  you shouldn't ever
// need to use these
//
#define SINK_TYPE_EVENT      0
#define SINK_TYPE_PROPNOTIFY 1

// superclass window support.  you can pass this in to DoSuperClassPaint
//
#define DRAW_SENDERASEBACKGROUND        1

//=--------------------------------------------------------------------------=
// Various Hosts don't handle OLEIVERB_PROPERTIES correctly, so we can't use
// that as our Properties verb number.  Instead, we're going to define
// CTLIVERB_PROPERTIES as 1, and return that one in IOleObject::EnumVerbs,
// but we'll still handle OLEIVERB_PROPERTIES correctly in DoVerb.
//
#define CTLIVERB_PROPERTIES     1


//=--------------------------------------------------------------------------=
// this structure is like the OLEVERB structure, except that it has a resource ID
// instead of a string for the verb's name.  better support for localization.
//
typedef struct tagVERBINFO {

    LONG    lVerb;                // verb id
    ULONG   idVerbName;           // resource ID of verb name
    DWORD   fuFlags;              // verb flags
    DWORD   grfAttribs;           // Specifies some combination of the verb attributes in the OLEVERBATTRIB enumeration.

} VERBINFO;

// describes an event
//
typedef struct tagEVENTINFO {

    DISPID    dispid;                    // dispid of the event
    int       cParameters;               // number of arguments to the event
    VARTYPE  *rgTypes;                   // type of each argument

} EVENTINFO;

//=--------------------------------------------------------------------------=
// CONTROLOBJECTINFO
//=--------------------------------------------------------------------------=
// for each control you wish to expose to the programmer/user, you need to
// declare and define one of the following structures.  the first part should
// follow the rules of the AUTOMATIONOBJECTINFO structure.  it's pretty hard,
// however, to imagine a scenario where the control isn't CoCreatable ...
// once this structre is declared/defined, an entry should be put in the
// global g_ObjectInfo table.
//
typedef struct {

    AUTOMATIONOBJECTINFO AutomationInfo;           // automation and creation information
    const IID      *piidEvents;                    // IID of primary event interface
    DWORD           dwOleMiscFlags;                // control flags
    DWORD           dwActivationPolicy;            // IPointerInactive support
    VARIANT_BOOL    fOpaque;                       // is your control 100% opaque?
    VARIANT_BOOL    fWindowless;                   // do we do windowless if we can?
    WORD            wToolboxId;                    // resource ID of Toolbox Bitmap
    LPCSTR          szWndClass;                    // name of window control class
    VARIANT_BOOL    fWindowClassRegistered;        // has the window class been registered yet?
    WORD            cPropPages;                    // number of property pages
    const GUID    **rgPropPageGuids;               // array of the property page GUIDs
    WORD            cCustomVerbs;                  // number of custom verbs
    const VERBINFO *rgCustomVerbs;                 // description of custom verbs
    WNDPROC         pfnSubClass;                   // for subclassed controls.

} CONTROLOBJECTINFO;


#ifndef INITOBJECTS

#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo,  w, szwc, cpp, rgppg, ccv, rgcv) \
extern CONTROLOBJECTINFO name##Control \


#else
#define DEFINE_CONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, TRUE, FALSE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#define DEFINE_WINDOWLESSCONTROLOBJECT(name, clsid, progid, fn, ver, riid, pszh, piide, dwcf, dwap, fo, w, szwc, cpp, rgppg, ccv, rgcv) \
CONTROLOBJECTINFO name##Control = { { {clsid, progid, fn}, ver, riid, pszh, NULL, 0}, piide, dwcf, dwap, fo, TRUE, w, szwc, FALSE, cpp, rgppg, ccv, rgcv, NULL } \

#endif // !INITOBJECTS

#define OLEMISCFLAGSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwOleMiscFlags
#define FCONTROLISWINDOWLESS(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowless
#define FCONTROLISOPAQUE(index)          ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fOpaque
#define ACTIVATIONPOLICYOFCONTROL(index) ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->dwActivationPolicy
#define EVENTIIDOFCONTROL(index)         (*(((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->piidEvents))
#define WNDCLASSNAMEOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->szWndClass
#define CPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cPropPages
#define PPROPPAGESOFCONTROL(index)       ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgPropPageGuids
#define CCUSTOMVERBSOFCONTROL(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->cCustomVerbs
#define CUSTOMVERBSOFCONTROL(index)      ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->rgCustomVerbs
#define BITMAPIDOFCONTROL(index)         ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->wToolboxId
#define CTLWNDCLASSREGISTERED(index)     ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->fWindowClassRegistered
#define SUBCLASSWNDPROCOFCONTROL(index)  ((CONTROLOBJECTINFO *)(g_ObjectInfo[index].pInfo))->pfnSubClass


//=--------------------------------------------------------------------------=
// COleControl
//=--------------------------------------------------------------------------=
// the mother of all C++ objects
//
class COleControl : public CAutomationObject,
                    public IOleObject, public IOleControl,
                    public IOleInPlaceObjectWindowless, public IOleInPlaceActiveObject,
                    public IViewObjectEx, public IPersistPropertyBag,
                    public IPersistStreamInit, public IPersistStorage,
                    public IConnectionPointContainer, public ISpecifyPropertyPages,
                    public IProvideClassInfo, public IPointerInactive,
                    public IQuickActivate
{
  public:
    // IUnknown methods -- there are required since we inherit from variuos
    // people who themselves inherit from IUnknown.  just delegate to controlling
    // unknown
    //
    DECLARE_STANDARD_UNKNOWN();

    //=--------------------------------------------------------------------------=
    // IPersist methods.  used by IPersistStream and IPersistStorage
    //
    STDMETHOD(GetClassID)(THIS_ LPCLSID lpClassID);

    // IPersistStreamInit methods
    //
    STDMETHOD(IsDirty)(THIS);
    STDMETHOD(Load)(LPSTREAM pStm);
    STDMETHOD(Save)(LPSTREAM pStm, BOOL fClearDirty);
    STDMETHOD(GetSizeMax)(ULARGE_INTEGER FAR* pcbSize);
    STDMETHOD(InitNew)();

    // IPersistStorage
    //
    STDMETHOD(InitNew)(IStorage  *pStg);
    STDMETHOD(Load)(IStorage  *pStg);
    STDMETHOD(Save)(IStorage  *pStgSave, BOOL fSameAsLoad);
    STDMETHOD(SaveCompleted)(IStorage  *pStgNew);
    STDMETHOD(HandsOffStorage)(void);

    // IPersistPropertyBag
    //
    STDMETHOD(Load)(LPPROPERTYBAG pPropBag, LPERRORLOG pErrorLog);
    STDMETHOD(Save)(LPPROPERTYBAG pPropBag, BOOL fClearDirty,
                    BOOL fSaveAllProperties);

    // IOleControl methods
    //
    STDMETHOD(GetControlInfo)(LPCONTROLINFO pCI);
    STDMETHOD(OnMnemonic)(LPMSG pMsg);
    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);
    STDMETHOD(FreezeEvents)(BOOL bFreeze);

    // IOleObject methods
    //
    STDMETHOD(SetClientSite)(IOleClientSite  *pClientSite);
    STDMETHOD(GetClientSite)(IOleClientSite  * *ppClientSite);
    STDMETHOD(SetHostNames)(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj);
    STDMETHOD(Close)(DWORD dwSaveOption);
    STDMETHOD(SetMoniker)(DWORD dwWhichMoniker, IMoniker  *pmk);
    STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker  * *ppmk);
    STDMETHOD(InitFromData)(IDataObject  *pDataObject, BOOL fCreation, DWORD dwReserved);
    STDMETHOD(GetClipboardData)(DWORD dwReserved, IDataObject  * *ppDataObject);
    STDMETHOD(DoVerb)(LONG iVerb, LPMSG lpmsg, IOleClientSite  *pActiveSite, LONG lindex,
                                     HWND hwndParent, LPCRECT lprcPosRect);
    STDMETHOD(EnumVerbs)(IEnumOLEVERB  * *ppEnumOleVerb);
    STDMETHOD(Update)(void);
    STDMETHOD(IsUpToDate)(void);
    STDMETHOD(GetUserClassID)(CLSID  *pClsid);
    STDMETHOD(GetUserType)(DWORD dwFormOfType, LPOLESTR  *pszUserType);
    STDMETHOD(SetExtent)(DWORD dwDrawAspect,SIZEL  *psizel);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, SIZEL  *psizel);
    STDMETHOD(Advise)(IAdviseSink  *pAdvSink, DWORD  *pdwConnection);
    STDMETHOD(Unadvise)(DWORD dwConnection);
    STDMETHOD(EnumAdvise)(IEnumSTATDATA  * *ppenumAdvise);
    STDMETHOD(GetMiscStatus)(DWORD dwAspect, DWORD  *pdwStatus);
    STDMETHOD(SetColorScheme)(LOGPALETTE  *pLogpal);

    // IOleWindow.  required for IOleInPlaceObject and IOleInPlaceActiveObject
    //
    STDMETHOD(GetWindow)(HWND *phwnd);
    STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);

    // IOleInPlaceObject/IOleInPlaceObjectWindowless
    //
    STDMETHOD(InPlaceDeactivate)(void);
    STDMETHOD(UIDeactivate)(void);
    STDMETHOD(SetObjectRects)(LPCRECT lprcPosRect,LPCRECT lprcClipRect) ;
    STDMETHOD(ReactivateAndUndo)(void);
    STDMETHOD(OnWindowMessage)(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult);
    STDMETHOD(GetDropTarget)(IDropTarget **ppDropTarget);

    // IOleInPlaceActiveObject
    //
    STDMETHOD(TranslateAccelerator)(LPMSG lpmsg);
    STDMETHOD(OnFrameWindowActivate)(BOOL fActivate);
    STDMETHOD(OnDocWindowActivate)(BOOL fActivate);
    STDMETHOD(ResizeBorder)(LPCRECT prcBorder,
                            IOleInPlaceUIWindow  *pUIWindow,
                            BOOL fFrameWindow);
    STDMETHOD(EnableModeless)(BOOL fEnable);

    // IViewObject2/IViewObjectEx
    //
    STDMETHOD(Draw)(DWORD dwDrawAspect, LONG lindex, void  *pvAspect,
                    DVTARGETDEVICE  *ptd, HDC hdcTargetDev, HDC hdcDraw,
                    LPCRECTL lprcBounds, LPCRECTL lprcWBounds,
                    BOOL ( __stdcall  *pfnContinue )(ULONG_PTR dwContinue),
                    ULONG_PTR dwContinue);
    STDMETHOD(GetColorSet)(DWORD dwDrawAspect,LONG lindex, void  *pvAspect,
                           DVTARGETDEVICE  *ptd, HDC hicTargetDev,
                           LOGPALETTE  * *ppColorSet);
    STDMETHOD(Freeze)(DWORD dwDrawAspect, LONG lindex,
                      void  *pvAspect,DWORD  *pdwFreeze);
    STDMETHOD(Unfreeze)(DWORD dwFreeze);
    STDMETHOD(SetAdvise)(DWORD aspects, DWORD advf, IAdviseSink  *pAdvSink);
    STDMETHOD(GetAdvise)(DWORD *pAspects, DWORD  *pAdvf, IAdviseSink  * *ppAdvSink);
    STDMETHOD(GetExtent)(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE __RPC_FAR *ptd, LPSIZEL lpsizel);
    STDMETHOD(GetRect)(DWORD dwAspect, LPRECTL pRect);
    STDMETHOD(GetViewStatus)(DWORD *pdwStatus);
    STDMETHOD(QueryHitPoint)(DWORD dwAspect, LPCRECT pRectBounds, POINT ptlLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(QueryHitRect)(DWORD dwAspect, LPCRECT pRectBounds, LPCRECT prcLoc, LONG lCloseHint, DWORD *pHitResult);
    STDMETHOD(GetNaturalExtent)(DWORD dwAspect, LONG lindex, DVTARGETDEVICE *ptd, HDC hicTargetDev, DVEXTENTINFO *pExtentInfo, LPSIZEL psizel);

    // IConnectionPointContainer methods
    //
    STDMETHOD(EnumConnectionPoints)(LPENUMCONNECTIONPOINTS FAR* ppEnum);
    STDMETHOD(FindConnectionPoint)(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

    // ISpecifyPropertyPages
    //
    STDMETHOD(GetPages)(CAUUID * pPages);

    // IProvideClassInfo methods
    //
    STDMETHOD(GetClassInfo)(LPTYPEINFO * ppTI);

    // IPointerInactive methods
    //
    STDMETHOD(GetActivationPolicy)(DWORD *pdwPolicy);
    STDMETHOD(OnInactiveMouseMove)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg);
    STDMETHOD(OnInactiveSetCursor)(LPCRECT pRectBounds, long x, long y, DWORD dwMouseMsg, BOOL fSetAlways);

    // IQuickActivate methods
    //
    STDMETHOD(QuickActivate)(QACONTAINER *pqacontainer, QACONTROL *pqacontrol);
    STDMETHOD(SetContentExtent)(LPSIZEL);
    STDMETHOD(GetContentExtent)(LPSIZEL);

    // constructor and destructor
    //
    COleControl(IUnknown *pUnkOuter, int iPrimaryDispatch, void *pMainInterface,
		BOOL fExpandoEnabled=FALSE);
    virtual ~COleControl();

    //=--------------------------------------------------------------------------=
    // callable by anybody
    //
    static LRESULT CALLBACK ControlWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static LRESULT CALLBACK ReflectWindowProc(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);
    static COleControl * ControlFromHwnd(HWND hwnd) {
        return (COleControl *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
    }

    void __cdecl FireEvent(EVENTINFO * pEventInfo, ...);
    HINSTANCE    GetResourceHandle(void);


    //=--------------------------------------------------------------------------=
    // ole controls that want to support both windowed and windowless operations
    // should use these wrappers instead of the appropriate win32 api routine.
    // controls that don't care and just want to be windowed all the time can
    // just go ahead and use the api routines.
    //
    BOOL    SetFocus(BOOL fGrab);                       // SetFocus API
    BOOL    OcxGetFocus(void);                          // GetFocus() == m_hwnd
    BOOL    OcxGetWindowRect(LPRECT);                   // gets your current window rect
    LRESULT OcxDefWindowProc(UINT, WPARAM, LPARAM);     // DefWindowProc
    HDC     OcxGetDC(void);                             // GetDC(m_hwnd);
    void    OcxReleaseDC(HDC hdc);                      // ReleaseDC(m_hwnd, hdc);
    BOOL    OcxSetCapture(BOOL fGrab);                  // SetCapture(fGrab ? m_hwnd : NULL);
    BOOL    OcxGetCapture(void);                        // GetCapture() == m_hwnd
    BOOL    OcxInvalidateRect(LPCRECT, BOOL);           // InvalidateRect(m_hwnd, prc, f);
    BOOL    OcxScrollRect(LPCRECT, LPCRECT, int, int);  // ScrollWindowEx(...);

  protected:

    //=--------------------------------------------------------------------------=
    // member variables that derived controls can get at.
    //
    // derived controls Should NOT modify the following.
    //
    IOleClientSite     *m_pClientSite;             // client site
    IOleControlSite    *m_pControlSite;            // IOleControlSite ptr on client site
    IOleInPlaceSite    *m_pInPlaceSite;            // IOleInPlaceSite for managing activation
    IOleInPlaceFrame   *m_pInPlaceFrame;           // IOleInPlaceFrame ptr on client site
    IOleInPlaceUIWindow *m_pInPlaceUIWindow;       // for negotiating border space with client
    ISimpleFrameSite   *m_pSimpleFrameSite;        // simple frame site
    IDispatch          *m_pDispAmbient;            // ambient dispatch pointer
    SIZEL               m_Size;                    // the size of this control
    RECT                m_rcLocation;              // where we at
    HWND                m_hwnd;                    // our window
    HWND                m_hwndParent;              // our parent window
    HRGN                m_hRgn;

    // Windowless OLE controls support
    //
    IOleInPlaceSiteWindowless *m_pInPlaceSiteWndless; // IOleInPlaceSiteWindowless pointer

    // flags indicating internal state.  do not modify.
    //
    unsigned m_fDirty:1;                           // does the control need to be resaved?
    unsigned m_fInPlaceActive:1;                   // are we in place active or not?
    unsigned m_fInPlaceVisible:1;                  // we are in place visible or not?
    unsigned m_fUIActive:1;                        // are we UI active or not.
    unsigned m_fCreatingWindow:1;                  // indicates if we're in CreateWindowEx or not

    //=--------------------------------------------------------------------------=
    // methods that derived controls can override, but may need to be called
    // from their versions.
    //
    virtual void      ViewChanged(void);
    virtual HRESULT   InternalQueryInterface(REFIID riid, void **ppvObjOut);
    virtual BOOL      SetGUIFocus(HWND hwndSet);

    //=--------------------------------------------------------------------------=
    // member functions that provide for derived controls, or that we use, but
    // derived controls might still find useful.
    //
    HRESULT      DoSuperClassPaint(HDC, LPCRECTL);
    HRESULT      RecreateControlWindow(void);
    BOOL         DesignMode(void);
    BOOL         GetAmbientProperty(DISPID, VARTYPE, void *);
    BOOL         GetAmbientFont(IFont **ppFontOut);
    void         ModalDialog(BOOL fShow);
    void         InvalidateControl(LPCRECT prc);
    BOOL         SetControlSize(SIZEL *pSizel);

    HWND         CreateInPlaceWindow(int x, int y, BOOL fNoRedraw);
    HRESULT      InPlaceActivate(LONG lVerb);
    void         SetInPlaceVisible(BOOL);
    void         SetInPlaceParent(HWND);

    // IPropertyNotifySink stuff.
    //
    inline void  PropertyChanged(DISPID dispid) {
        m_cpPropNotify.DoOnChanged(dispid);
    }
    inline BOOL  RequestPropertyEdit(DISPID dispid) {
        return m_cpPropNotify.DoOnRequestEdit(dispid);
    }

    // subclassed windows controls support ...
    //
    inline HWND  GetOuterWindow(void) {
        return (m_hwndReflect) ? m_hwndReflect : m_hwnd;
    }

    // little routine for people to tell if they are windowless or not
    //
    inline BOOL  Windowless(void) {
        return !m_fInPlaceActive || m_pInPlaceSiteWndless;
    }

    // some people don't care if they're windowed or not -- they just need
    // a site pointer.  this makes it a little easier.
    //
    inline IOleInPlaceSite    *GetInPlaceSite(void) {
        return (IOleInPlaceSite *)(m_pInPlaceSiteWndless ? m_pInPlaceSiteWndless : m_pInPlaceSite);
    }

  private:
    //=--------------------------------------------------------------------------=
    // the following are methods that ALL control writers must override and implement
    //
    STDMETHOD(LoadBinaryState)(IStream *pStream) PURE;
    STDMETHOD(SaveBinaryState)(IStream *pStream) PURE;
    STDMETHOD(LoadTextState)(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog) PURE;
    STDMETHOD(SaveTextState)(IPropertyBag *pPropertyBag, BOOL fWriteDefault) PURE;
    STDMETHOD(OnDraw)(DWORD dvAspect, HDC hdcDraw, LPCRECTL prcBounds, LPCRECTL prcWBounds, HDC hicTargetDev, BOOL fOptimize) PURE;
    virtual LRESULT WindowProc(UINT msg, WPARAM wParam, LPARAM lParam) PURE;
    virtual BOOL    RegisterClassData(void) PURE;

    //=--------------------------------------------------------------------------=
    // OVERRIDABLES -- methods controls can implement for customized functionality
    //
    virtual void    AmbientPropertyChanged(DISPID dispid);
    virtual BOOL    BeforeCreateWindow(DWORD *, DWORD *, LPSTR);
    virtual void    BeforeDestroyWindow(void);
    virtual HRESULT DoCustomVerb(LONG lVerb);
    virtual BOOL    OnSetExtent(const SIZEL *pSizeL);
    virtual BOOL    OnSpecialKey(LPMSG);
    virtual BOOL    OnGetPalette(HDC, LOGPALETTE **);
    virtual HRESULT OnQuickActivate(QACONTAINER *, DWORD *);
    virtual BOOL    InitializeNewState();
    virtual BOOL    AfterCreateWindow(void);
    virtual BOOL    OnGetRect(DWORD dvAspect, LPRECTL prcRect);
    virtual void    OnSetObjectRectsChangingWindowPos(DWORD *dwFlag);
    virtual void    OnVerb(LONG lVerb);

    //=--------------------------------------------------------------------------=
    // methods that various people internally will share.  not needed, however, by
    // any inherting classes.
    //
    HRESULT         m_SaveToStream(IStream *pStream);
    HRESULT         LoadStandardState(IPropertyBag *pPropertyBag, IErrorLog *pErrorLog);
    HRESULT         LoadStandardState(IStream *pStream);
    HRESULT         SaveStandardState(IPropertyBag *pPropertyBag);
    HRESULT         SaveStandardState(IStream *pStream);

    //=--------------------------------------------------------------------------=
    // member variables we don't want anybody to get their hands on, including
    // inheriting classes
    //
    HWND              m_hwndReflect;               // for subclassed windows
    IOleAdviseHolder *m_pOleAdviseHolder;          // IOleObject::Advise holder object
    IAdviseSink      *m_pViewAdviseSink;           // IViewAdvise sink for IViewObject2
    unsigned short    m_nFreezeEvents;             // count of freezes versus thaws
    unsigned          m_fHostReflects:1;           // does the host reflect messages?
    unsigned          m_fCheckedReflecting:1;      // have we checked above yet?

    // internal flags.  various other flags are visible to the end control class.
    //
    unsigned m_fModeFlagValid:1;                   // we stash the mode as much as possible
    unsigned m_fSaveSucceeded:1;                   // did an IStorage save work correctly?
    unsigned m_fViewAdvisePrimeFirst: 1;           // for IViewobject2::setadvise
    unsigned m_fViewAdviseOnlyOnce: 1;             // for iviewobject2::setadvise
    unsigned m_fUsingWindowRgn:1;                  // for SetObjectRects and clipping
    unsigned m_fRunMode:1;                         // are we in run mode or not?

  protected:
    class CConnectionPoint : public IConnectionPoint {
      public:
        IUnknown **m_rgSinks;

        // IUnknown methods
        //
        STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
        STDMETHOD_(ULONG,AddRef)(THIS) ;
        STDMETHOD_(ULONG,Release)(THIS) ;

        // IConnectionPoint methods
        //
        STDMETHOD(GetConnectionInterface)(IID FAR* pIID);
        STDMETHOD(GetConnectionPointContainer)(IConnectionPointContainer FAR* FAR* ppCPC);
        STDMETHOD(Advise)(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie);
        STDMETHOD(Unadvise)(DWORD dwCookie);
        STDMETHOD(EnumConnections)(LPENUMCONNECTIONS FAR* ppEnum);

        void    DoInvoke(DISPID dispid, DISPPARAMS * pdispparam);
        void    DoOnChanged(DISPID dispid);
        BOOL    DoOnRequestEdit(DISPID dispid);
        HRESULT AddSink(void *, DWORD *);

        COleControl *m_pOleControl();
        CConnectionPoint(BYTE b){
            m_bType = b;
            m_rgSinks = NULL;
            m_cSinks = 0;
            m_cAllocatedSinks = 0;
            m_SingleSink = NULL;
        }
        ~CConnectionPoint();

        BYTE   m_bType;
        unsigned short m_cSinks;
        IUnknown *m_SingleSink;
        unsigned short m_cAllocatedSinks;

    } m_cpEvents, m_cpPropNotify;

    // so they can get at some of our protected things, like AddRef, QI, etc.
    //
    friend CConnectionPoint;
};

#define _CTRLOBJ_H_
#endif // _CTRLOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\localsrv.h ===
//=--------------------------------------------------------------------------=
// LocalSrv.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1995 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global routines that are specific to the inproc server itself, such as
// registration, object creation, object specification, etc...
//
#ifndef _LOCALSRV_H_

void      WINAPI InitializeLibrary(void);
void      WINAPI UninitializeLibrary(void);
BOOL      WINAPI RegisterData(void);
BOOL      WINAPI UnregisterData(void);
BOOL      WINAPI CheckForLicense();
BOOL      WINAPI CheckLicenseKey(LPWSTR wszCheckme);
BSTR      WINAPI GetLicenseKey(void);

// global variables that various people use to get information about the control.
//
extern const char g_szLibName [];
extern const CLSID *g_pLibid;

//=--------------------------------------------------------------------------=
// Global object information table
//=--------------------------------------------------------------------------=
// for each object in your application, you have an entry in this table.  they
// do not necessarily have to be CoCreatable, but if they are used, then they
// should reside here.  use the macros to fill in this table.
//
typedef struct tagOBJECTINFO {

    unsigned short usType;
    void          *pInfo;

} OBJECTINFO;

extern OBJECTINFO g_ObjectInfo[];

//=--------------------------------------------------------------------------=
// these things are used to set up our objects in our global object table
//
#define OI_UNKNOWN       0
#define OI_AUTOMATION    1
#define OI_CONTROL       2
#define OI_PROPERTYPAGE  3
#define OI_BOGUS         0xffff

#define OBJECTISCREATABLE(index)  (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid != NULL)
#define ISEMPTYOBJECT(index)      (g_ObjectInfo[index].usType == OI_BOGUS)

// these are the macros you should use to fill in the table.  Note that the name
// must be exactly the same as that used in the global structure you created
// for this object.
//
#define UNKNOWNOBJECT(name)    { OI_UNKNOWN,      (void *)&(name##Object) }
#define AUTOMATIONOBJECT(name) { OI_AUTOMATION,   (void *)&(name##Object) }
#define CONTROLOBJECT(name)    { OI_CONTROL,      (void *)&(name##Control) }
#define PROPERTYPAGE(name)     { OI_PROPERTYPAGE, (void *)&(name##Page) }
#define EMPTYOBJECT            { OI_BOGUS, NULL }

#define _LOCALSRV_H_
#endif // _LOCALSRV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\internet.h ===
//=--------------------------------------------------------------------------=
// Internet.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for the URLDib2 control.
//
#ifndef _INTERNET_H
#define _INTERNET_H

#define DISPID_PROGRESS 1958

#ifndef __MKTYPLIB__

#include "urlmon.H"
#include "ocidl.h"
#include "datapath.h" // for IBindHost
#include "docobj.h"   // for IServiceProvider

#include "IPServer.H"
#include "CtrlObj.H"



class CInternetControl : public COleControl
{
public:
	CInternetControl(IUnknown *     pUnkOuter, 
					int                     iPrimaryDispatch, 
					void *          pMainInterface);

	virtual ~CInternetControl();

    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

	// Call this method to start the download of a URL. 'propId' will 
	//      be passed back to you OnData below.
	HRESULT SetupDownload( LPOLESTR url, DISPID propId);


	//      Derived classes implement this method. It will be called when
	//      data has arrived for a given dispid.
	virtual HRESULT OnData( DISPID id, DWORD grfBSCF,
					IStream * bitstrm, DWORD amount );


	//      Derived classes can implement this method. It will be
	//      called at various times during the download.
	virtual HRESULT OnProgress( DISPID id, ULONG ulProgress,
					ULONG ulProgressMax,
					ULONG ulStatusCode,
					LPCWSTR pwzStatusText);

	//      Call this method to turn a URL into a Moniker.
	HRESULT GetAMoniker( LPOLESTR   url, IMoniker ** );


    HRESULT FireReadyStateChange( long newState );
	HRESULT FireProgress( ULONG dwAmount );


	// Override base class implementation...

    virtual HRESULT InternalQueryInterface(REFIID, void **);

protected:
	HRESULT GetBindHost();

    IBindHost *             m_host;
    long                    m_readyState;

    // BUGBUG: We should track all the downloads

};

#endif __MKTYPLIB__

#endif _INTERNET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\proppage.h ===
//=--------------------------------------------------------------------------=
// PropPage.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// class declaration for CPropertyPage.
//
#ifndef _PROPPAGE_H_

// things we really need
//
#include "Unknown.H"
#include <olectl.h>
#include "LocalSrv.H"

//=--------------------------------------------------------------------------=
// messages that we'll send to property pages to instruct them to accomplish
// tasks.
//
#define PPM_NEWOBJECTS    (WM_USER + 100)
#define PPM_APPLY         (WM_USER + 101)
#define PPM_EDITPROPERTY  (WM_USER + 102)
#define PPM_FREEOBJECTS   (WM_USER + 103)

//=--------------------------------------------------------------------------=
// structure that control writers will use to define property pages.
//
typedef struct tagPROPERTYPAGEINFO {

    UNKNOWNOBJECTINFO unknowninfo;
    WORD    wDlgResourceId;
    WORD    wTitleId;
    WORD    wDocStringId;
    LPCSTR  szHelpFile;
    DWORD   dwHelpContextId;

} PROPERTYPAGEINFO;

#ifndef INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    extern PROPERTYPAGEINFO name##Page \

#else // INITOBJECTS

#define DEFINE_PROPERTYPAGEOBJECT(name, pclsid, pszon, pfn, wr, wt, wd, pszhf, dwhci) \
    PROPERTYPAGEINFO name##Page = { {pclsid, pszon, pfn }, wr, wt, wd, pszhf, dwhci } \

#endif // INITOBJECTS


#define TEMPLATENAMEOFPROPPAGE(index)    MAKEINTRESOURCE(((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDlgResourceId)
#define TITLEIDOFPROPPAGE(index)         (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wTitleId)
#define DOCSTRINGIDOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->wDocStringId)
#define HELPCONTEXTOFPROPPAGE(index)     (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->dwHelpContextId)
#define HELPFILEOFPROPPAGE(index)        (((PROPERTYPAGEINFO *)(g_ObjectInfo[index].pInfo))->szHelpFile)

//=--------------------------------------------------------------------------=
//
class CPropertyPage : public CUnknownObject, public IPropertyPage2 {

  public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IPropertyPage methods
    //
    STDMETHOD(SetPageSite)(LPPROPERTYPAGESITE pPageSite);
    STDMETHOD(Activate)(HWND hwndParent, LPCRECT lprc, BOOL bModal);
    STDMETHOD(Deactivate)(void);
    STDMETHOD(GetPageInfo)(LPPROPPAGEINFO pPageInfo);
    STDMETHOD(SetObjects)(ULONG cObjects, LPUNKNOWN FAR* ppunk);
    STDMETHOD(Show)(UINT nCmdShow);
    STDMETHOD(Move)(LPCRECT prect);
    STDMETHOD(IsPageDirty)(void);
    STDMETHOD(Apply)(void);
    STDMETHOD(Help)(LPCOLESTR lpszHelpDir);
    STDMETHOD(TranslateAccelerator)(LPMSG lpMsg);

    // IPropertyPage2 methods
    //
    STDMETHOD(EditProperty)(THIS_ DISPID dispid);

    // constructor destructor
    //
    CPropertyPage(IUnknown *pUnkOuter, int iObjectType);
    virtual ~CPropertyPage();

    HINSTANCE GetResourceHandle(void);            // returns current resource handle.

  protected:
    IPropertyPageSite *m_pPropertyPageSite;       // pointer to our ppage site.
    void     MakeDirty();                         // makes the property page dirty.
    HWND     m_hwnd;                              // our hwnd.

    // the following two methods allow a property page implementer to get at all the
    // objects that we need to set here.
    //
    IUnknown *FirstControl(DWORD *dwCookie);
    IUnknown *NextControl(DWORD *dwCookie);

  private:
    IUnknown **m_ppUnkObjects;                    // objects that we're working with.

    unsigned m_fActivated:1;
    unsigned m_fDirty:1;
    int      m_ObjectType;                        // what type of object we are
    UINT     m_cObjects;                          // how many objects we're holding on to

    void     m_ReleaseAllObjects(void);           // clears out all objects we've got.
    HRESULT  m_EnsureLoaded(void);                // forces the load of the page.

    virtual HRESULT InternalQueryInterface(REFIID, void **);

    // default dialog proc for a page.
    //
    static INT_PTR CALLBACK PropPageDlgProc(HWND, UINT, WPARAM, LPARAM);

    // all page implementers MUST implement the following function.
    //
    virtual INT_PTR DialogProc(HWND, UINT, WPARAM, LPARAM) PURE;
};

#define _PROPPAGE_H_
#endif // _PROPPAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\ipserver.h ===
//=--------------------------------------------------------------------------=
// IPServer.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// global header file that contains all the windows stuff, etc ...  should
// be pre-compiled to speed things up a little bit.
//
#ifndef _IPSERVER_H_

//#define INC_OLE2
#include <windows.h>
#include <stddef.h>                    // for offsetof()
#include <olectl.h>

// things that -everybody- wants [read: is going to get]
//
#include "Debug.H"

//=--------------------------------------------------------------------------=
// controls can register for thread notifications in their InitializeLibrary()
//
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef void (CALLBACK *THRDNFYPROC)(HANDLE, DWORD, void *);
void SetLibraryThreadProc(THRDNFYPROC pfnThreadNotify);

#ifdef __cplusplus
}
#endif // __cplusplus
//=--------------------------------------------------------------------------=

//=--------------------------------------------------------------------------=
// Useful macros
//=--------------------------------------------------------------------------=
//
// handy error macros, randing from cleaning up, to returning to clearing
// rich error information as well.
//
#define RETURN_ON_FAILURE(hr) if (FAILED(hr)) return hr
#define RETURN_ON_NULLALLOC(ptr) if (!(ptr)) return E_OUTOFMEMORY
#define CLEANUP_ON_FAILURE(hr) if (FAILED(hr)) goto CleanUp
#define CLEARERRORINFORET(hr) { SetErrorInfo(0, NULL); return hr; }
#define CLEARERRORINFORET_ON_FAILURE(hr) if (FAILED(hr)) { SetErrorInfo(0, NULL); return hr; }

#define CLEANUP_ON_ERROR(l)    if (l != ERROR_SUCCESS) goto CleanUp

// conversions
//
#define BOOL_TO_VARIANTBOOL(f) (f) ? VARIANT_TRUE : VARIANT_FALSE

// Reference counting help.
//
#define RELEASE_OBJECT(ptr)    if (ptr) { IUnknown *pUnk = (ptr); (ptr) = NULL; pUnk->Release(); }
#define QUICK_RELEASE(ptr)     if (ptr) ((IUnknown *)ptr)->Release();
#define ADDREF_OBJECT(ptr)     if (ptr) (ptr)->AddRef()



//=--------------------------------------------------------------------------=
// QueryInterface Optimizations
//=--------------------------------------------------------------------------=
// for optimizing QI's
//
#define DO_GUIDS_MATCH(riid1, riid2) ((riid1.Data1 == riid2.Data1) && (riid1 == riid2))

// Data1_*
//
// the first dword of GUIDs for most of the interesting interfaces.  these are
// used by speed critical versions of QueryInterface
//
#define Data1_IAdviseSink                  0x0000010f
#define Data1_IAdviseSink2                 0x00000125
#define Data1_IAdviseSinkEx                0x3af24290
#define Data1_IBindCtx                     0x0000000e
#define Data1_ICDataDoc                    0xF413E4C0
#define Data1_IClassFactory                0x00000001
#define Data1_IClassFactory2               0xb196b28f
#define Data1_IConnectionPoint             0xb196b286
#define Data1_IConnectionPointContainer    0xb196b284
#define Data1_IControl_95                  0x9a4bbfb5
#define Data1_IControl                     0xa7fddba0
#define Data1_ICreateErrorInfo             0x22f03340
#define Data1_ICreateTypeInfo              0x00020405
#define Data1_ICreateTypeLib               0x00020406
#define Data1_IDataAdviseHolder            0x00000110
#define Data1_IDataFrame                   0x97F254E0
#define Data1_IDataFrameExpert             0x73687490
#define Data1_IDataObject                  0x0000010e
#define Data1_IDispatch                    0x00020400
#define Data1_IDropSource                  0x00000121
#define Data1_IDropTarget                  0x00000122
#define Data1_IEnumCallback                0x00000108
#define Data1_IEnumConnectionPoints        0xb196b285
#define Data1_IEnumConnections             0xb196b287
#define Data1_IEnumFORMATETC               0x00000103
#define Data1_IEnumGeneric                 0x00000106
#define Data1_IEnumHolder                  0x00000107
#define Data1_IEnumMoniker                 0x00000102
#define Data1_IEnumOLEVERB                 0x00000104
#define Data1_IEnumSTATDATA                0x00000105
#define Data1_IEnumSTATSTG                 0x0000000d
#define Data1_IEnumString                  0x00000101
#define Data1_IEnumOleUndoActions          0xb3e7c340
#define Data1_IEnumUnknown                 0x00000100
#define Data1_IEnumVARIANT                 0x00020404
#define Data1_IErrorInfo                   0x1cf2b120
#define Data1_IExternalConnection          0x00000019
#define Data1_IFont                        0xbef6e002
#define Data1_IFontDisp                    0xbef6e003
#define Data1_IFormExpert                  0x5aac7f70
#define Data1_IGangConnectWithDefault      0x6d5140c0
#define Data1_IInternalMoniker             0x00000011
#define Data1_ILockBytes                   0x0000000a
#define Data1_IMalloc                      0x00000002
#define Data1_IMarshal                     0x00000003
#define Data1_IMessageFilter               0x00000016
#define Data1_IMoniker                     0x0000000f
#define Data1_IMsoCommandTarget            0xb722bccb
#define Data1_IMsoDocument                 0xb722bcc5
#define Data1_IOleInPlaceComponent         0x5efc7970
#define Data1_IMsoView                     0xb722bcc6
#define Data1_IOleAdviseHolder             0x00000111
#define Data1_IOleCache                    0x0000011e
#define Data1_IOleCache2                   0x00000128
#define Data1_IOleCacheControl             0x00000129
#define Data1_IOleClientSite               0x00000118
#define Data1_IOleCompoundUndoAction       0xa1faf330
#define Data1_IOleContainer                0x0000011b
#define Data1_IOleControl                  0xb196b288
#define Data1_IOleControlSite              0xb196b289
#define Data1_IOleInPlaceActiveObject      0x00000117
#define Data1_IOleInPlaceFrame             0x00000116
#define Data1_IOleInPlaceObject            0x00000113
#define Data1_IOleInPlaceObjectWindowless  0x1c2056cc
#define Data1_IOleInPlaceSite              0x00000119
#define Data1_IOleInPlaceSiteEx            0x9c2cad80
#define Data1_IOleInPlaceSiteWindowless    0x922eada0
#define Data1_IOleInPlaceUIWindow          0x00000115
#define Data1_IOleItemContainer            0x0000011c
#define Data1_IOleLink                     0x0000011d
#define Data1_IOleManager                  0x0000011f
#define Data1_IOleObject                   0x00000112
#define Data1_IOlePresObj                  0x00000120
#define Data1_IOlePropertyFrame            0xb83bb801
#define Data1_IOleStandardTool             0xd97877c4
#define Data1_IOleUndoAction               0x894ad3b0
#define Data1_IOleUndoActionManager        0xd001f200
#define Data1_IOleWindow                   0x00000114
#define Data1_IPSFactory                   0x00000009
#define Data1_IPSFactoryBuffer             0xd5f569d0
#define Data1_IParseDisplayName            0x0000011a
#define Data1_IPerPropertyBrowsing         0x376bd3aa
#define Data1_IPersist                     0x0000010c
#define Data1_IPersistFile                 0x0000010b
#define Data1_IPersistPropertyBag          0x37D84F60
#define Data1_IPersistStorage              0x0000010a
#define Data1_IPersistStream               0x00000109
#define Data1_IPersistStreamInit           0x7fd52380
#define Data1_IPicture                     0x7bf80980
#define Data1_IPictureDisp                 0x7bf80981
#define Data1_IPointerInactive             0x55980ba0
#define Data1_IPropertyNotifySink          0x9bfbbc02
#define Data1_IPropertyPage                0xb196b28d
#define Data1_IPropertyPage2               0x01e44665
#define Data1_IPropertyPage3               0xb83bb803
#define Data1_IPropertyPageInPlace         0xb83bb802
#define Data1_IPropertyPageSite            0xb196b28c
#define Data1_IPropertyPageSite2           0xb83bb804
#define Data1_IProvideClassInfo            0xb196b283
#define Data1_IProvideDynamicClassInfo     0x6d5140d1
#define Data1_IQuickActivate               0xcf51ed10
#define Data1_IRequireClasses              0x6d5140d0
#define Data1_IRootStorage                 0x00000012
#define Data1_IRunnableObject              0x00000126
#define Data1_IRunningObjectTable          0x00000010
#define Data1_ISelectionContainer          0x6d5140c6
#define Data1_IServiceProvider             0x6d5140c1
#define Data1_ISimpleFrameSite             0x742b0e01
#define Data1_ISpecifyPropertyPages        0xb196b28b
#define Data1_IStdMarshalInfo              0x00000018
#define Data1_IStorage                     0x0000000b
#define Data1_IStream                      0x0000000c
#define Data1_ISupportErrorInfo            0xdf0b3d60
#define Data1_ITypeComp                    0x00020403
#define Data1_ITypeInfo                    0x00020401
#define Data1_ITypeLib                     0x00020402
#define Data1_IUnknown                     0x00000000
#define Data1_IViewObject                  0x0000010d
#define Data1_IViewObject2                 0x00000127
#define Data1_IViewObjectEx                0x3af24292
#define Data1_IWeakRef                     0x0000001a
#define Data1_ICategorizeProperties        0x4d07fc10


#define QI_INHERITS(pObj, itf)              \
    case Data1_##itf:                       \
      if(DO_GUIDS_MATCH(riid, IID_##itf))    \
      {                                     \
        *ppvObjOut = (void *)(itf *)pObj;   \
      }                                     \
      break;

#include "extobj.h"


#define _IPSERVER_H_
#endif // _IPSERVER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\prsht.h ===
/*****************************************************************************\
*                                                                             *
* prsht.h - - Interface for the Windows Property Sheet Pages                  *
*                                                                             *
* Version 1.0                                                                 *
*                                                                             *
* Copyright (c) 1991-1996, Microsoft Corp.      All rights reserved.          *
*                                                                             *
\*****************************************************************************/

#ifndef _PRSHT_H_
#define _PRSHT_H_

//
// Define API decoration for direct importing of DLL references.
//
#ifndef WINCOMMCTRLAPI
#if !defined(_COMCTL32_) && defined(_WIN32)
#define WINCOMMCTRLAPI DECLSPEC_IMPORT
#else
#define WINCOMMCTRLAPI
#endif
#endif // WINCOMMCTRLAPI

//
// For compilers that don't support nameless unions
//
#ifndef DUMMYUNIONNAME
#ifdef NONAMELESSUNION
#define DUMMYUNIONNAME   u
#define DUMMYUNIONNAME2  u2
#define DUMMYUNIONNAME3  u3
#else
#define DUMMYUNIONNAME
#define DUMMYUNIONNAME2
#define DUMMYUNIONNAME3
#endif
#endif // DUMMYUNIONNAME

#ifdef __cplusplus
extern "C" {
#endif


#ifdef __cplusplus
#define SNDMSG ::SendMessage
#else
#define SNDMSG SendMessage
#endif


#define MAXPROPPAGES            100

struct _PSP;
typedef struct _PSP FAR* HPROPSHEETPAGE;

#ifndef MIDL_PASS
struct _PROPSHEETPAGEA;
struct _PROPSHEETPAGEW;
#endif

typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA FAR *ppsp);
typedef UINT (CALLBACK FAR * LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW FAR *ppsp);

#ifdef UNICODE
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKW
#else
#define LPFNPSPCALLBACK         LPFNPSPCALLBACKA
#endif

#define PSP_DEFAULT             0x0000
#define PSP_DLGINDIRECT         0x0001
#define PSP_USEHICON            0x0002
#define PSP_USEICONID           0x0004
#define PSP_USETITLE            0x0008
#define PSP_RTLREADING          0x0010

#define PSP_HASHELP             0x0020
#define PSP_USEREFPARENT        0x0040
#define PSP_USECALLBACK         0x0080

#define PSPCB_RELEASE           1
#define PSPCB_CREATE            2


typedef struct _PROPSHEETPAGEA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        } DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        } DUMMYUNIONNAME2;
        LPCSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEA, FAR *LPPROPSHEETPAGEA;
typedef const PROPSHEETPAGEA FAR *LPCPROPSHEETPAGEA;

typedef struct _PROPSHEETPAGEW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HINSTANCE       hInstance;
        union {
            LPCWSTR          pszTemplate;
#ifdef _WIN32
            LPCDLGTEMPLATE  pResource;
#else
            const VOID FAR *pResource;
#endif
        }DUMMYUNIONNAME;
        union {
            HICON       hIcon;
            LPCWSTR      pszIcon;
        }DUMMYUNIONNAME2;
        LPCWSTR          pszTitle;
        DLGPROC         pfnDlgProc;
        LPARAM          lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT FAR * pcRefParent;
} PROPSHEETPAGEW, FAR *LPPROPSHEETPAGEW;
typedef const PROPSHEETPAGEW FAR *LPCPROPSHEETPAGEW;

#ifdef UNICODE
#define PROPSHEETPAGE           PROPSHEETPAGEW
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEW
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEW
#else
#define PROPSHEETPAGE           PROPSHEETPAGEA
#define LPPROPSHEETPAGE         LPPROPSHEETPAGEA
#define LPCPROPSHEETPAGE        LPCPROPSHEETPAGEA
#endif


#define PSH_DEFAULT             0x0000
#define PSH_PROPTITLE           0x0001
#define PSH_USEHICON            0x0002
#define PSH_USEICONID           0x0004
#define PSH_PROPSHEETPAGE       0x0008
#define PSH_WIZARD              0x0020
#define PSH_USEPSTARTPAGE       0x0040
#define PSH_NOAPPLYNOW          0x0080
#define PSH_USECALLBACK         0x0100
#define PSH_HASHELP             0x0200
#define PSH_MODELESS            0x0400
#define PSH_RTLREADING          0x0800

typedef int (CALLBACK *PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

typedef struct _PROPSHEETHEADERA {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCSTR      pszIcon;
        }DUMMYUNIONNAME;
        LPCSTR          pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCSTR      pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERA, FAR *LPPROPSHEETHEADERA;
typedef const PROPSHEETHEADERA FAR *LPCPROPSHEETHEADERA;

typedef struct _PROPSHEETHEADERW {
        DWORD           dwSize;
        DWORD           dwFlags;
        HWND            hwndParent;
        HINSTANCE       hInstance;
        union {
            HICON       hIcon;
            LPCWSTR     pszIcon;
        }DUMMYUNIONNAME;
        LPCWSTR         pszCaption;


        UINT            nPages;
        union {
            UINT        nStartPage;
            LPCWSTR     pStartPage;
        }DUMMYUNIONNAME2;
        union {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE FAR *phpage;
        }DUMMYUNIONNAME3;
        PFNPROPSHEETCALLBACK pfnCallback;
} PROPSHEETHEADERW, FAR *LPPROPSHEETHEADERW;
typedef const PROPSHEETHEADERW FAR *LPCPROPSHEETHEADERW;

#ifdef UNICODE
#define PROPSHEETHEADER         PROPSHEETHEADERW
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERW
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERW
#else
#define PROPSHEETHEADER         PROPSHEETHEADERA
#define LPPROPSHEETHEADER       LPPROPSHEETHEADERA
#define LPCPROPSHEETHEADER      LPCPROPSHEETHEADERA
#endif


#define PSCB_INITIALIZED  1
#define PSCB_PRECREATE    2

WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageA(LPCPROPSHEETPAGEA);
WINCOMMCTRLAPI HPROPSHEETPAGE WINAPI CreatePropertySheetPageW(LPCPROPSHEETPAGEW);
WINCOMMCTRLAPI BOOL           WINAPI DestroyPropertySheetPage(HPROPSHEETPAGE);
WINCOMMCTRLAPI int            WINAPI PropertySheetA(LPCPROPSHEETHEADERA);
WINCOMMCTRLAPI int            WINAPI PropertySheetW(LPCPROPSHEETHEADERW);

#ifdef UNICODE
#define CreatePropertySheetPage  CreatePropertySheetPageW
#define PropertySheet            PropertySheetW
#else
#define CreatePropertySheetPage  CreatePropertySheetPageA
#define PropertySheet            PropertySheetA
#endif



typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);


typedef struct _PSHNOTIFY
{
    NMHDR hdr;
    LPARAM lParam;
} PSHNOTIFY, FAR *LPPSHNOTIFY;


#define PSN_FIRST               (0U-200U)
#define PSN_LAST                (0U-299U)


#define PSN_SETACTIVE           (PSN_FIRST-0)
#define PSN_KILLACTIVE          (PSN_FIRST-1)
// #define PSN_VALIDATE            (PSN_FIRST-1)
#define PSN_APPLY               (PSN_FIRST-2)
#define PSN_RESET               (PSN_FIRST-3)
// #define PSN_CANCEL              (PSN_FIRST-3)
#define PSN_HELP                (PSN_FIRST-5)
#define PSN_WIZBACK             (PSN_FIRST-6)
#define PSN_WIZNEXT             (PSN_FIRST-7)
#define PSN_WIZFINISH           (PSN_FIRST-8)
#define PSN_QUERYCANCEL         (PSN_FIRST-9)


#define PSNRET_NOERROR              0
#define PSNRET_INVALID              1
#define PSNRET_INVALID_NOCHANGEPAGE 2


#define PSM_SETCURSEL           (WM_USER + 101)
#define PropSheet_SetCurSel(hDlg, hpage, index) \
        SNDMSG(hDlg, PSM_SETCURSEL, (WPARAM)index, (LPARAM)hpage)


#define PSM_REMOVEPAGE          (WM_USER + 102)
#define PropSheet_RemovePage(hDlg, index, hpage) \
        SNDMSG(hDlg, PSM_REMOVEPAGE, index, (LPARAM)hpage)


#define PSM_ADDPAGE             (WM_USER + 103)
#define PropSheet_AddPage(hDlg, hpage) \
        SNDMSG(hDlg, PSM_ADDPAGE, 0, (LPARAM)hpage)


#define PSM_CHANGED             (WM_USER + 104)
#define PropSheet_Changed(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_CHANGED, (WPARAM)hwnd, 0L)


#define PSM_RESTARTWINDOWS      (WM_USER + 105)
#define PropSheet_RestartWindows(hDlg) \
        SNDMSG(hDlg, PSM_RESTARTWINDOWS, 0, 0L)


#define PSM_REBOOTSYSTEM        (WM_USER + 106)
#define PropSheet_RebootSystem(hDlg) \
        SNDMSG(hDlg, PSM_REBOOTSYSTEM, 0, 0L)


#define PSM_CANCELTOCLOSE       (WM_USER + 107)
#define PropSheet_CancelToClose(hDlg) \
        SNDMSG(hDlg, PSM_CANCELTOCLOSE, 0, 0L)


#define PSM_QUERYSIBLINGS       (WM_USER + 108)
#define PropSheet_QuerySiblings(hDlg, wParam, lParam) \
        SNDMSG(hDlg, PSM_QUERYSIBLINGS, wParam, lParam)


#define PSM_UNCHANGED           (WM_USER + 109)
#define PropSheet_UnChanged(hDlg, hwnd) \
        SNDMSG(hDlg, PSM_UNCHANGED, (WPARAM)hwnd, 0L)


#define PSM_APPLY               (WM_USER + 110)
#define PropSheet_Apply(hDlg) \
        SNDMSG(hDlg, PSM_APPLY, 0, 0L)


#define PSM_SETTITLEA           (WM_USER + 111)
#define PSM_SETTITLEW           (WM_USER + 120)

#ifdef UNICODE
#define PSM_SETTITLE            PSM_SETTITLEW
#else
#define PSM_SETTITLE            PSM_SETTITLEA
#endif

#define PropSheet_SetTitle(hDlg, wStyle, lpszText)\
        SNDMSG(hDlg, PSM_SETTITLE, wStyle, (LPARAM)(LPCTSTR)lpszText)


#define PSM_SETWIZBUTTONS       (WM_USER + 112)
#define PropSheet_SetWizButtons(hDlg, dwFlags) \
        PostMessage(hDlg, PSM_SETWIZBUTTONS, 0, (LPARAM)dwFlags)



#define PSWIZB_BACK             0x00000001
#define PSWIZB_NEXT             0x00000002
#define PSWIZB_FINISH           0x00000004
#define PSWIZB_DISABLEDFINISH   0x00000008


#define PSM_PRESSBUTTON         (WM_USER + 113)
#define PropSheet_PressButton(hDlg, iButton) \
        SNDMSG(hDlg, PSM_PRESSBUTTON, (WPARAM)iButton, 0)


#define PSBTN_BACK              0
#define PSBTN_NEXT              1
#define PSBTN_FINISH            2
#define PSBTN_OK                3
#define PSBTN_APPLYNOW          4
#define PSBTN_CANCEL            5
#define PSBTN_HELP              6
#define PSBTN_MAX               6



#define PSM_SETCURSELID         (WM_USER + 114)
#define PropSheet_SetCurSelByID(hDlg, id) \
        SNDMSG(hDlg, PSM_SETCURSELID, 0, (LPARAM)id)


#define PSM_SETFINISHTEXTA      (WM_USER + 115)
#define PSM_SETFINISHTEXTW      (WM_USER + 121)

#ifdef UNICODE
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTW
#else
#define PSM_SETFINISHTEXT       PSM_SETFINISHTEXTA
#endif

#define PropSheet_SetFinishText(hDlg, lpszText) \
        SNDMSG(hDlg, PSM_SETFINISHTEXT, 0, (LPARAM)lpszText)


#define PSM_GETTABCONTROL       (WM_USER + 116)
#define PropSheet_GetTabControl(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETTABCONTROL, 0, 0)

#define PSM_ISDIALOGMESSAGE     (WM_USER + 117)
#define PropSheet_IsDialogMessage(hDlg, pMsg) \
        (BOOL)SNDMSG(hDlg, PSM_ISDIALOGMESSAGE, 0, (LPARAM)pMsg)

#define PSM_GETCURRENTPAGEHWND  (WM_USER + 118)
#define PropSheet_GetCurrentPageHwnd(hDlg) \
        (HWND)SNDMSG(hDlg, PSM_GETCURRENTPAGEHWND, 0, 0L)

#define ID_PSRESTARTWINDOWS     0x2
#define ID_PSREBOOTSYSTEM       (ID_PSRESTARTWINDOWS | 0x1)


#define WIZ_CXDLG               276
#define WIZ_CYDLG               140

#define WIZ_CXBMP               80

#define WIZ_BODYX               92
#define WIZ_BODYCX              184

#define PROP_SM_CXDLG           212
#define PROP_SM_CYDLG           188

#define PROP_MED_CXDLG          227
#define PROP_MED_CYDLG          215

#define PROP_LG_CXDLG           252
#define PROP_LG_CYDLG           218


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\stdenum.h ===
//=--------------------------------------------------------------------------=
// StdEnum.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// object definition for a generic enumerator object.
//
#ifndef _STDENUM_H_

#include "Unknown.H"

// to support a generic Enumerator object, we'll just define this
// interface.  it can be safely cast to any other enumerator, since all
// they differ in is their pointer type in Next().
//
class IEnumGeneric: public IUnknown {

  public:
    virtual HRESULT __stdcall Next(ULONG celt, LPVOID rgelt, ULONG *pceltFetched) = 0;
    virtual HRESULT __stdcall Skip(ULONG celt) = 0;
    virtual HRESULT __stdcall Reset(void) = 0;
    virtual HRESULT __stdcall Clone(IEnumGeneric **ppenum) = 0;
};

//=--------------------------------------------------------------------------=
// StandardEnum
//=--------------------------------------------------------------------------=
// a generic enumerator object.  given a pointer to generic data, some
// information about the elements, and a function to copy the elements,
// we can implement a generic enumerator.
//
// NOTE: this class assumes that rgElements is HeapAlloc'd, and will free it
//       in it's destructor [although it IS valid for this to be NULL if there
//       are no elements to enumerate over.]
//
class CStandardEnum: public CUnknownObject, public IEnumGeneric {

public:
    // IUnknown methods
    //
    DECLARE_STANDARD_UNKNOWN();

    // IEnumVariant methods
    //
    STDMETHOD(Next)(unsigned long celt, void * rgvar, unsigned long * pceltFetched); 
    STDMETHOD(Skip)(unsigned long celt); 
    STDMETHOD(Reset)(); 
    STDMETHOD(Clone)(IEnumGeneric **ppEnumOut); 

    CStandardEnum(REFIID riid, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));
    ~CStandardEnum();

private:
    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IID m_iid;                        // type of enumerator that we are
    int m_cElements;                  // Total number of elements
    int m_cbElementSize;              // Size of each element
    int m_iCurrent;                   // Current position: 0 = front, m_cElt = end
    VOID * m_rgElements;              // Array of elements  
    CStandardEnum *m_pEnumClonedFrom; // If we were cloned, from whom?
    void  (WINAPI * m_pfnCopyElement)(void *, const void *, DWORD);
};



#define _STDENUM_H_
#endif // _STDENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\strcoll.h ===
//=--------------------------------------------------------------------------=
// StrColl.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains the definitions for the various string collections we'll use
//
#ifndef _STRCOLL_H_

#include "CommDlgInterfaces.H"



//=--------------------------------------------------------------------------=
// the CStringsCollection class basically works with a safearray to expose the
// collection, and uses the safearray functions to maniplate it.
//=--------------------------------------------------------------------------=
// NOTES: 9.95 - this collection assumes that the safearray lbound is
//        zero!
//=--------------------------------------------------------------------------=
//
class CStringCollection {

  public:
    // a couple of methods that are common
    //
    STDMETHOD(get_Count)(THIS_ long FAR* pcStrings);
    STDMETHOD(get_Item)(THIS_ long lIndex, BSTR FAR* pbstrItem);
    STDMETHOD(get__NewEnum)(THIS_ IUnknown * FAR* ppUnkNewEnum);

    CStringCollection(SAFEARRAY *);
    virtual ~CStringCollection();

  protected:
    // what the collection will work with.
    //
    SAFEARRAY *m_psa;
};

class CStringDynaCollection : public CStringCollection {

  public:
    // in addition to the CStringCollection methods, we'll have
    //
    STDMETHOD(put_Item)(THIS_ long lIndex, BSTR bstrItem);
    STDMETHOD(Add)(THIS_ BSTR bstrNew);
    STDMETHOD(Remove)(THIS_ long lIndex);

    CStringDynaCollection(SAFEARRAY *);
    virtual ~CStringDynaCollection();

};


#define _STRCOLL_H_
#endif // _STRCOLL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\tools.inc ===
#=------------------------------------------------------------------------=
# Tools.Inc
#=------------------------------------------------------------------------=
# Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
#
# THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
# ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
# PARTICULAR PURPOSE.
#=--------------------------------------------------------------------------=
#
# sets up the various tools required to build a control.
#


CC=cl
!if "$(PROCESSOR_ARCHITECTURE)"=="ALPHA"
ML=asaxp
!elseif "$(PROCESSOR_ARCHITECTURE)"=="MIPS"
ML=cl
!elseif "$(PROCESSOR_ARCHITECTURE)"=="PPC"
ML=pas
!else
ML=ml
!endif
RC=rc
LINK=link
MKTYPLIB=mktyplib
MKDEP=mkdep
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\unknown.h ===
//=--------------------------------------------------------------------------=
// Unknown.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// a class definition for an IUnknown super-class that will support
// aggregation.
//
#ifndef _UNKNOWN_H_

//=--------------------------------------------------------------------------=
// UNKNOWNOBJECTINFO
//
// if you want a simple co-creatable object, with no other guarantees about
// it, then you need to put the following entry in the global table of objects.
// other object types that are more complex, such as automation objects, and
// controls, will also use this information...
//
typedef struct {

    const CLSID *rclsid;                    // CLSID of your object.      ONLY USE IF YOU'RE CoCreatable!
    LPCSTR       pszObjectName;             // Name of your object.       ONLY USE IF YOU'RE CoCreatable!
    IUnknown    *(*pfnCreate)(IUnknown *);  // pointer to creation fn.    ONLY USE IF YOU'RE CoCreatable!

} UNKNOWNOBJECTINFO;

#define NAMEOFOBJECT(index)       (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pszObjectName)
#define CLSIDOFOBJECT(index)      (*(((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->rclsid))
#define CREATEFNOFOBJECT(index)   (((UNKNOWNOBJECTINFO *)(g_ObjectInfo[(index)]).pInfo)->pfnCreate)

#ifndef INITOBJECTS

#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
extern UNKNOWNOBJECTINFO name##Object \

#else
#define DEFINE_UNKNOWNOBJECT(name, clsid, objname, fn) \
    UNKNOWNOBJECTINFO name##Object = { clsid, objname, fn } \

#endif // INITOBJECTS


//=--------------------------------------------------------------------------=
// DECLARE_STANDARD_UNKNOWN
//
// All objects that are going to inherit from CUnknown for their IUnknown
// implementation should put this in their class declaration instead of the
// three IUnknown methods.
//
#define DECLARE_STANDARD_UNKNOWN() \
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut) { \
        return ExternalQueryInterface(riid, ppvObjOut); \
    } \
    STDMETHOD_(ULONG, AddRef)(void) { \
        return ExternalAddRef(); \
    } \
    STDMETHOD_(ULONG, Release)(void) { \
        return ExternalRelease(); \
    } \

// global variable where we store the current lock count on our DLL.  This resides
// in InProcServer.Cpp
//
extern LONG g_cLocks;



//=--------------------------------------------------------------------------=
// this class doesn't inherit from IUnknown since people inheriting from it
// are going to do so, and just delegate their IUnknown calls to the External*
// member functions on this object.  the internal private unknown object does
// need to inherit from IUnknown, since it will be used directly as an IUnknown
// object.
//
class CUnknownObject {

  public:
    CUnknownObject(IUnknown *pUnkOuter, void *pvInterface)
        : m_pvInterface(pvInterface),
          m_pUnkOuter((pUnkOuter) ? pUnkOuter : &m_UnkPrivate)
        {  InterlockedIncrement(&g_cLocks); }

    virtual ~CUnknownObject() { 
#if DBG==1
        if ( 0 != g_cLocks )
        {
            DebugBreak();
        }
#endif
        InterlockedDecrement(&g_cLocks); 
    }

    // these are all protected so that classes that inherit from this can
    // at get at them.
    //
  protected:
    // IUnknown methods.  these just delegate to the controlling
    // unknown.
    //
    HRESULT ExternalQueryInterface(REFIID riid, void **ppvObjOut) {
        return m_pUnkOuter->QueryInterface(riid, ppvObjOut);
    }
    ULONG ExternalAddRef(void) {
        return m_pUnkOuter->AddRef();
    }
    ULONG ExternalRelease(void) {
        return m_pUnkOuter->Release();
    }

    // people should use this during creation to return their private
    // unknown
    //
    inline IUnknown *PrivateUnknown (void) {
        return &m_UnkPrivate;
    }

    virtual HRESULT InternalQueryInterface(REFIID riid, void **ppvObjOut);

    IUnknown *m_pUnkOuter;            // outer controlling Unknown
    void     *m_pvInterface;          // the real interface we're working with.

  private:
    // the inner, private unknown implementation is for the aggregator
    // to control the lifetime of this object, and for those cases where
    // this object isn't aggregated.
    //
    class CPrivateUnknownObject : public IUnknown {
      public:
        STDMETHOD(QueryInterface)(REFIID riid, void **ppvObjOut);
        STDMETHOD_(ULONG, AddRef)(void);
        STDMETHOD_(ULONG, Release)(void);

        // constructor is remarkably trivial
        //
        CPrivateUnknownObject() : m_cRef(1) {}

      private:
        CUnknownObject *m_pMainUnknown();
        ULONG m_cRef;
    } m_UnkPrivate;

    // so they can reference themselves in CUnknownObject from pMainUnknown()
    //
    friend class CPrivateUnknownObject;

    // by overriding this, people inheriting from this unknown can implement
    // additional interfaces.  declared as private here so they have to use their
    // own version.
    //
};




#define _UNKNOWN_H_
#endif // _UNKNOWN_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\vc41warn.h ===
//=--------------------------------------------------------------------------=
// VC41Warn.h
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// disables several new VC4.1 warnings that trip standard headers
//

// VC4.1 warning about bool
#pragma warning(disable:4237)

// VC4.1 warning - anachronism used
#pragma warning(disable:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\util.h ===
//=--------------------------------------------------------------------------=
// Util.H
//=--------------------------------------------------------------------------=
// Copyright 1995-1996 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF 
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO 
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A 
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
// contains utilities that we will find useful.
//
#ifndef _UTIL_H_

#include "Globals.H"


//=--------------------------------------------------------------------------=
// Misc Helper Routines
//=--------------------------------------------------------------------------=
//
HWND      GetParkingWindow(void);
HINSTANCE GetResourceHandle(void);

//=--------------------------------------------------------------------------=
// miscellaneous [useful] numerical constants
//=--------------------------------------------------------------------------=
// the length of a guid once printed out with -'s, leading and trailing bracket,
// plus 1 for NULL
//
#define GUID_STR_LEN    40


//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(g_hHeap, 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(g_hHeap, 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given and ANSI String, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPSTR pszA;
//  pszA = MyGetAnsiStringRoutine();
//  MAKE_WIDEPTR_FROMANSI(pwsz, pszA);
//  MyUseWideStringRoutine(pwsz);
//  ...
//
// similarily for MAKE_ANSIPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
#define MAKE_WIDEPTR_FROMANSI(ptrname, ansistr) \
    long __l##ptrname = (lstrlen(ansistr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, ansistr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()

//
// Note: allocate lstrlenW(widestr) * 2 because its possible for a UNICODE 
// character to map to 2 ansi characters this is a quick guarantee that enough
// space will be allocated.
//
#define MAKE_ANSIPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (lstrlenW(widestr) + 1) * 2 * sizeof(char); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPSTR ptrname = (LPSTR)__TempBuffer##ptrname.GetBuffer()

#define STR_BSTR   0
#define STR_OLESTR 1
#define BSTRFROMANSI(x)    (BSTR)MakeWideStrFromAnsi((LPSTR)(x), STR_BSTR)
#define OLESTRFROMANSI(x)  (LPOLESTR)MakeWideStrFromAnsi((LPSTR)(x), STR_OLESTR)
#define BSTRFROMRESID(x)   (BSTR)MakeWideStrFromResourceId(x, STR_BSTR)
#define OLESTRFROMRESID(x) (LPOLESTR)MakeWideStrFromResourceId(x, STR_OLESTR)
#define COPYOLESTR(x)      (LPOLESTR)MakeWideStrFromWide(x, STR_OLESTR)
#define COPYBSTR(x)        (BSTR)MakeWideStrFromWide(x, STR_BSTR)

LPWSTR MakeWideStrFromAnsi(LPSTR, BYTE bType);
LPWSTR MakeWideStrFromResourceId(WORD, BYTE bType);
LPWSTR MakeWideStrFromWide(LPWSTR, BYTE bType);


// takes a GUID, and a pointer to a buffer, and places the string form of the
// GUID in said buffer.
//
int StringFromGuidA(REFIID, LPSTR);


//=--------------------------------------------------------------------------=
// registry helpers.
//
// takes some information about an Automation Object, and places all the
// relevant information about it in the registry.
//
BOOL RegSetMultipleValues(HKEY hkey, ...);
BOOL RegisterUnknownObject(LPCSTR pszObjectName, REFCLSID riidObject);
BOOL RegisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject);
BOOL RegisterControlObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidLibrary, REFCLSID riidObject, DWORD dwMiscStatus, WORD wToolboxBitmapId);
BOOL UnregisterUnknownObject(REFCLSID riidObject);
BOOL UnregisterAutomationObject(LPCSTR pszLibName, LPCSTR pszObjectName, long lVersion, REFCLSID riidObject);
#define UnregisterControlObject UnregisterAutomationObject
BOOL UnregisterTypeLibrary(REFCLSID riidLibrary);

// deletes a key in the registr and all of it's subkeys
//
BOOL DeleteKeyAndSubKeys(HKEY hk, LPSTR pszSubKey);


//=--------------------------------------------------------------------------=
// conversion helpers.
//
void        HiMetricToPixel(const SIZEL *pSizeInHiMetric, SIZEL *pSizeinPixels);
void        PixelToHiMetric(const SIZEL *pSizeInPixels, SIZEL *pSizeInHiMetric);


#define _UTIL_H_
#endif // _UTIL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\inc\urlhlink.h ===
#ifndef __URLHLINK_H
#define __URLHLINK_H

#include "urlmon.h"

#ifdef __cplusplus
extern "C" {
#endif


// Flags for the UrlDownloadToCacheFile
#define	URLOSTRM_USECACHEDCOPY_ONLY		0x1								// Only get from cache
#define	URLOSTRM_USECACHEDCOPY			URLOSTRM_USECACHEDCOPY_ONLY	+1	// Get from cache if available else download
#define	URLOSTRM_GETNEWESTVERSION		URLOSTRM_USECACHEDCOPY		+1	// Get new version only. But put it in cache too


typedef HRESULT (STDAPICALLTYPE *LPFNUOSCALLBACK)(LPBINDSTATUSCALLBACK);


STDAPI URLOpenStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenStream  URLOpenStreamW
#else
#define URLOpenStream  URLOpenStreamA
#endif // !UNICODE
STDAPI URLOpenPullStreamA(LPUNKNOWN,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenPullStreamW(LPUNKNOWN,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenPullStream  URLOpenPullStreamW
#else
#define URLOpenPullStream  URLOpenPullStreamA
#endif // !UNICODE
STDAPI URLDownloadToFileA(LPUNKNOWN,LPCSTR,LPCSTR,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToFileW(LPUNKNOWN,LPCWSTR,LPCWSTR,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLDownloadToFile  URLDownloadToFileW
#else
#define URLDownloadToFile  URLDownloadToFileA
#endif // !UNICODE

STDAPI URLDownloadToCacheFileA(LPUNKNOWN,LPCSTR,LPTSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLDownloadToCacheFileW(LPUNKNOWN,LPCWSTR,LPWSTR,DWORD,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLDownloadToCacheFile  URLDownloadToCacheFileW
#else
#define URLDownloadToCacheFile  URLDownloadToCacheFileA
#endif // !UNICODE

STDAPI URLOpenBlockingStreamA(LPUNKNOWN,LPCSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);
STDAPI URLOpenBlockingStreamW(LPUNKNOWN,LPCWSTR,LPSTREAM*,DWORD,LPBINDSTATUSCALLBACK);
#ifdef UNICODE
#define URLOpenBlockingStream  URLOpenBlockingStreamW
#else
#define URLOpenBlockingStream  URLOpenBlockingStreamA
#endif // !UNICODE

#define UOSM_PUSH  0
#define UOSM_PULL  1
#define UOSM_BLOCK 2
#define UOSM_FILE  3

#define UOS_URLENCODEPOSTDATA BINDINFOF_URLENCODESTGMEDDATA
#define UOS_URLENCODEURL      BINDINFOF_URLENCODEDEXTRAINFO

typedef struct _UOSHTTPINFOA
{
	ULONG		ulSize;
	LPUNKNOWN	punkCaller;
	LPCSTR  	szURL;
	LPCSTR  	szVerb;
	LPCSTR  	szHeaders;
	LPBYTE		pbPostData;
	ULONG		ulPostDataLen;
	ULONG		fURLEncode;
	ULONG		ulResv;
	ULONG		ulMode;
	LPCSTR  	szFileName;
	LPSTREAM *	ppStream;
	LPBINDSTATUSCALLBACK	pbscb;
} UOSHTTPINFOA, * LPUOSHTTPINFOA; 
typedef struct _UOSHTTPINFOW
{
	ULONG		ulSize;
	LPUNKNOWN	punkCaller;
	LPCWSTR 	szURL;
	LPCWSTR 	szVerb;
	LPCWSTR 	szHeaders;
	LPBYTE		pbPostData;
	ULONG		ulPostDataLen;
	ULONG		fURLEncode;
	ULONG		ulResv;
	ULONG		ulMode;
	LPCWSTR 	szFileName;
	LPSTREAM *	ppStream;
	LPBINDSTATUSCALLBACK	pbscb;
} UOSHTTPINFOW, * LPUOSHTTPINFOW; 
#ifdef UNICODE
typedef UOSHTTPINFOW UOSHTTPINFO;
typedef LPUOSHTTPINFOW LPUOSHTTPINFO;
#else
typedef UOSHTTPINFOA UOSHTTPINFO;
typedef LPUOSHTTPINFOA LPUOSHTTPINFO;
#endif // UNICODE

STDAPI URLOpenHttpStreamA(LPUOSHTTPINFOA);
STDAPI URLOpenHttpStreamW(LPUOSHTTPINFOW);
#ifdef UNICODE
#define URLOpenHttpStream  URLOpenHttpStreamW
#else
#define URLOpenHttpStream  URLOpenHttpStreamA
#endif // !UNICODE

struct IBindStatusCallback;

STDAPI HlinkSimpleNavigateToString(
    /* [in] */ LPCWSTR szTarget,      // required - target document - null if local jump w/in doc
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szTargetFrameName,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

STDAPI HlinkSimpleNavigateToMoniker(
    /* [in] */ IMoniker *pmkTarget,   // required - target document - (may be null if local jump w/in doc)
    /* [in] */ LPCWSTR szLocation,    // optional, for navigation into middle of a doc
    /* [in] */ LPCWSTR szTargetFrameName,   // optional, for targeting frame-sets
    /* [in] */ IUnknown *pUnk,        // required - we'll search this for other necessary interfaces
    /* [in] */ IBindCtx *pbc,         // optional. caller may register an IBSC in this
	/* [in] */ IBindStatusCallback *,
    /* [in] */ DWORD grfHLNF,         // flags (TBD - HadiP needs to define this correctly?)
    /* [in] */ DWORD dwReserved       // for future use, must be NULL
);

STDAPI HlinkGoBack(IUnknown *pUnk);
STDAPI HlinkGoForward(IUnknown *pUnk);
STDAPI HlinkNavigateString(IUnknown *pUnk, LPCWSTR szTarget);
STDAPI HlinkNavigateMoniker(IUnknown *pUnk, IMoniker *pmkTarget);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\core\basecom.cxx ===
//+----------------------------------------------------------------------------
//  File:       basecom.cxx
//
//  Synopsis:   This file contains implementations of the root COM objects
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


//+----------------------------------------------------------------------------
//  Function:   SRelease, SClear
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
SRelease(
    IUnknown *  pUnk)
{
    if (pUnk)
    {
        pUnk->Release();
    }
}


void
SClear(
    IUnknown ** ppUnk)
{
    Assert(ppUnk);

    if (*ppUnk)
    {
        (*ppUnk)->Release();
        *ppUnk = NULL;
    }
}


//+----------------------------------------------------------------------------
//  Function:   PublicQueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CComponent::PublicQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    return _pUnkOuter->QueryInterface(riid, ppvObj);
}


//+----------------------------------------------------------------------------
//  Function:   PublicAddRef
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CComponent::PublicAddRef()
{
    return _pUnkOuter->AddRef();
}


//+----------------------------------------------------------------------------
//  Function:   PublicRelease
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CComponent::PublicRelease()
{
    return _pUnkOuter->Release();
}


//+----------------------------------------------------------------------------
//  Function:   PrivateQueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CComponent::PrivateQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    if (riid == IID_IUnknown)
    {
        *ppvObj = (void *)(IUnknown *)&_Unk;
        return S_OK;
    }
    return E_NOINTERFACE;
}


//+----------------------------------------------------------------------------
//  Function:   CUnknown::QueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CComponent::CUnknown::QueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    HRESULT hr;

    Assert(ppvObj);
    if (!ppvObj)
        return E_INVALIDARG;

    *ppvObj = NULL;

    hr = OWNING_CLASS(CComponent, _Unk)->PrivateQueryInterface(riid, ppvObj);

    if (!hr)
    {
        Assert(*ppvObj);
        ((IUnknown *)*ppvObj)->AddRef();
        hr = S_OK;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//  Function:   CUnknown::AddRef
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CComponent::CUnknown::AddRef()
{
    return ++(OWNING_CLASS(CComponent, _Unk)->_cRefs);
}


//+----------------------------------------------------------------------------
//  Function:   CUnknown::Release
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CComponent::CUnknown::Release()
{
    CComponent *    pComp = OWNING_CLASS(CComponent, _Unk);

    Assert(OWNING_CLASS(CComponent, _Unk)->_cRefs);

    if (!--pComp->_cRefs)
    {
        pComp->_cRefs += REF_GUARD;
        delete pComp;
        return 0;
    }
    return pComp->_cRefs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\core\corepch.cxx ===
//+----------------------------------------------------------------------------
//  File:       corepch.hxx  
//
//  Synopsis:   Pre-compiled header
//
//-----------------------------------------------------------------------------

// Includes -------------------------------------------------------------------
#include <core.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\core\dllreg.cxx ===
//+----------------------------------------------------------------------------
//  File:       dllreg.cxx
//
//  Synopsis:
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


// Prototypes -----------------------------------------------------------------
static const TCHAR * DeleteSubkeys(HKEY hkeyParent, const TCHAR * pszKey);
static const TCHAR * RegisterKey(HKEY hkeyParent, const TCHAR * pszKey);


//+----------------------------------------------------------------------------
//  Function:   DllRegisterServer
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
DllRegisterServer()
{
    const TCHAR **  ppszKey;
    const TCHAR *   pszKey;
    HKEY            hkey;
    LONG            lError;
    HRESULT         hr;

    hr = EnsureThreadState();
    if (hr)
        goto Cleanup;

    for (ppszKey=g_aszKeys; *ppszKey; ppszKey++)
    {
        pszKey = *ppszKey;

        lError = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                pszKey, 0, KEY_ALL_ACCESS,
                                &hkey);
        if (lError != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            break;
        }

        pszKey += _tcslen(pszKey) + 1;
        Assert(*pszKey);

        if (!RegisterKey(hkey, pszKey))
        {
            hr = E_FAIL;
            break;
        }

#ifdef _DEBUG
        Verify(::RegCloseKey(hkey) == ERROR_SUCCESS);
#else
        ::RegCloseKey(hkey);
#endif
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Function:   DllUnregisterServer
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
DllUnregisterServer()
{
    const TCHAR **  ppszKey;
    const TCHAR *   pszKey;
    HKEY            hkey;
    LONG            lError;
    HRESULT         hr;

    hr = EnsureThreadState();
    if (hr)
        goto Cleanup;

    for (ppszKey=g_aszKeys; *ppszKey; ppszKey++)
    {
        pszKey = *ppszKey;

        lError = ::RegOpenKeyEx(HKEY_CLASSES_ROOT,
                                pszKey, 0, KEY_ALL_ACCESS,
                                &hkey);
        if (lError != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            break;
        }

        pszKey += _tcslen(pszKey) + 1;
        Assert(*pszKey);

        if (!DeleteSubkeys(hkey, pszKey) ||
            ::RegDeleteKey(hkey, pszKey) != ERROR_SUCCESS)
        {
            hr = E_FAIL;
        }
#ifdef _DEBUG
        Verify(::RegCloseKey(hkey) == ERROR_SUCCESS);
#else
        ::RegCloseKey(hkey);
#endif
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Function:   DeleteSubkeys
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
const TCHAR *
DeleteSubkeys(
    HKEY            hkeyParent,
    const TCHAR *   pszKey)
{
    const TCHAR *   psz;
    HKEY            hkey = NULL;
    LONG            lError;

    lError = ::RegOpenKeyEx(hkeyParent, pszKey, 0, KEY_ALL_ACCESS, &hkey);
    if (lError != ERROR_SUCCESS)
        goto Error;

    pszKey += _tcslen(pszKey) + 1;

    while (*pszKey)
    {
        switch (*pszKey)
        {
        case chDEFAULT_SECTION:
            pszKey++;
            pszKey += _tcslen(pszKey) + 1;
            break;

        case chVALUES_SECTION:
            pszKey++;
            while (*pszKey)
            {
                pszKey += _tcslen(pszKey) + 1;
                pszKey += _tcslen(pszKey) + 1;
            }
            pszKey++;
            break;

        case chSUBKEY_SECTION:
            pszKey++;
            psz = pszKey;
            pszKey = DeleteSubkeys(hkey, pszKey);
            if (!pszKey)
                goto Error;
            lError = ::RegDeleteKey(hkey, psz);
            if (lError != ERROR_SUCCESS)
                goto Error;
            break;

#ifdef _DEBUG
        default:
            AssertF("Invalid section in registry key data");
#endif
        }
    }

    pszKey++;

Cleanup:
    if (hkey)
    {
#ifdef _DEBUG
        Verify(::RegCloseKey(hkey) == ERROR_SUCCESS);
#else
        ::RegCloseKey(hkey);
#endif
    }
    return pszKey;

Error:
    pszKey = NULL;
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//  Function:   RegisterKey
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
const TCHAR *
RegisterKey(
    HKEY            hkeyParent,
    const TCHAR *   pszKey)
{
    const TCHAR *   psz;
    HKEY            hkey = NULL;
    DWORD           dwDisposition;
    LONG            lError;

    lError = ::RegCreateKeyEx(hkeyParent, pszKey, 0, _T(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS, NULL,
                            &hkey, &dwDisposition);
    if (lError != ERROR_SUCCESS)
        goto Error;

    pszKey += _tcslen(pszKey) + 1;

    while (*pszKey)
    {
        switch (*pszKey)
        {
        case chDEFAULT_SECTION:
            pszKey++;
            if (!::lstrcmpi(pszKey, szMODULE_PATH))
            {
                TCHAR   szModule[MAX_PATH+1];

                Verify(::GetModuleFileName((HMODULE)g_hinst, szModule, ARRAY_SIZE(szModule)));
                lError = ::RegSetValueEx(hkey, NULL, 0,
                                        REG_SZ,
                                        (const BYTE *)szModule,
                                        sizeof(TCHAR) * (_tcslen(szModule) + 1));
            }
            else
            {
                lError = ::RegSetValueEx(hkey, NULL, 0,
                                        REG_SZ,
                                        (const BYTE *)pszKey,
                                        sizeof(TCHAR) * (_tcslen(pszKey) + 1));
            }
            if (lError != ERROR_SUCCESS)
                goto Error;
            pszKey += _tcslen(pszKey) + 1;
            break;

        case chVALUES_SECTION:
            pszKey++;
            while (*pszKey)
            {
                psz = pszKey;
                pszKey += _tcslen(pszKey) + 1;

                lError = ::RegSetValueEx(hkey, psz, 0,
                                        REG_SZ,
                                        (const BYTE *)pszKey,
                                        sizeof(TCHAR) * (_tcslen(pszKey) + 1));
                if (lError != ERROR_SUCCESS)
                    goto Error;

                pszKey += _tcslen(pszKey) + 1;
            }
            pszKey++;
            break;

        case chSUBKEY_SECTION:
            pszKey++;
            pszKey = RegisterKey(hkey, pszKey);
            if (!pszKey)
                goto Error;
            break;

#ifdef _DEBUG
        default:
            AssertF("Invalid section in registry key data");
#endif
        }
    }

    pszKey++;

Cleanup:
    if (hkey)
    {
#ifdef _DEBUG
        Verify(::RegCloseKey(hkey) == ERROR_SUCCESS);
#else
        ::RegCloseKey(hkey);
#endif
    }
    return pszKey;

Error:
    pszKey = NULL;
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\core\dll.cxx ===
//+----------------------------------------------------------------------------
//  File:       dll.cxx
//
//  Synopsis:   This file contains the core routines and globals for creating
//              DLLs
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


// Globals --------------------------------------------------------------------
static THREADSTATE *    g_pts = NULL;
HANDLE                  g_hinst = NULL;
HANDLE                  g_heap = NULL;
DWORD                   g_tlsThreadState = NULL_TLS;
LONG                    g_cUsage = 0;
GINFO                   g_ginfo = { 0 };

DECLARE_LOCK(DLL);


// Prototypes -----------------------------------------------------------------
class CClassFactory : public CComponent,
                      public IClassFactory2
{
    typedef CComponent parent;

public:
    CClassFactory(CLASSFACTORY * pcf);

    // IUnknown methods
    DEFINE_IUNKNOWN_METHODS;

    // IClassFactory methods
    STDMETHOD(CreateInstance)(IUnknown * pUnkOuter, REFIID riid, void ** ppvObj);
    STDMETHOD(LockServer)(BOOL fLock);

    // IClassFactory2 methods
	STDMETHOD(GetLicInfo)(LICINFO * pLicInfo);
	STDMETHOD(RequestLicKey)(DWORD dwReserved, BSTR * pbstrKey);
	STDMETHOD(CreateInstanceLic)(IUnknown * pUnkOuter,
	                             IUnknown * pUnkReserved,
	                             REFIID riid, BSTR bstrKey,
	                             void ** ppvObj);

private:
    CLASSFACTORY *  _pcf;

    HRESULT PrivateQueryInterface(REFIID riid, void ** ppvObj);
};

static HRESULT DllProcessAttach();
static void    DllProcessDetach();
static HRESULT DllThreadAttach();
static void    DllThreadDetach(THREADSTATE * pts);

static void    DllProcessPassivate();
static void    DllThreadPassivate();


//+----------------------------------------------------------------------------
//  Function:   DllMain
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" BOOL WINAPI
DllMain(
    HINSTANCE   hinst,
    DWORD       nReason,
    void *      )           // pvReserved - Unused
{
    HRESULT hr = S_OK;

    g_hinst = hinst;

    switch (nReason)
    {
    case DLL_PROCESS_ATTACH:
        hr = DllProcessAttach();
        break;

    case DLL_PROCESS_DETACH:
        DllProcessDetach();
        break;

    case DLL_THREAD_DETACH:
        {
            THREADSTATE *   pts = (THREADSTATE *)TlsGetValue(g_tlsThreadState);
            DllThreadDetach(pts);
        }
        break;
    }

    return !hr;
}


//+----------------------------------------------------------------------------
//  Function:   DllGetClassObject
//
//  Synopsis:
//
//  NOTE: This code limits class objects to supporting IUnknown and IClassFactory
//
//-----------------------------------------------------------------------------
STDAPI
DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    void **     ppv)
{
    CLASSFACTORY *  pcf;
    HRESULT         hr;

    hr = EnsureThreadState();
    if (hr)
        return hr;

    if (!ppv)
        return E_INVALIDARG;
    *ppv = NULL;

    if (riid != IID_IClassFactory &&
        riid != IID_IClassFactory2)
        return E_NOINTERFACE;

    for (pcf=g_acf; pcf->pclsid; pcf++)
    {
        if (*(pcf->pclsid) == rclsid)
            break;
    }
    if (!pcf)
        return CLASS_E_CLASSNOTAVAILABLE;

    if (riid == IID_IClassFactory2 && !pcf->pfnLicense)
        return E_NOINTERFACE;

    CClassFactory * pCF = new CClassFactory(pcf);
    if (!pCF)
        return E_OUTOFMEMORY;

    *ppv = (void *)(IClassFactory2 *)pCF;
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   DllCanUnloadNow
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDAPI
DllCanUnloadNow()
{
    return ((g_cUsage==0)
                ? S_OK
                : S_FALSE);
}


//+----------------------------------------------------------------------------
//  Function:   DllProcessAttach
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
DllProcessAttach()
{
    PFN_PATTACH *   ppfnPAttach;
    HRESULT         hr = S_OK;

    g_tlsThreadState = TlsAlloc();
    if (g_tlsThreadState == NULL_TLS)
    {
        return GetWin32Hresult();
    }

    INIT_LOCK(DLL);

    g_heap = GetProcessHeap();

    for (ppfnPAttach=g_apfnPAttach; *ppfnPAttach; ppfnPAttach++)
    {
        hr = (**ppfnPAttach)();
        if (hr)
            goto Error;
    }

Cleanup:
    return hr;

Error:
    DllProcessDetach();
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//  Function:   DllProcessDetach
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DllProcessDetach()
{
    THREADSTATE *   pts;
    PFN_PDETACH *   ppfnPDetach;

    Implies(g_pts, g_tlsThreadState != NULL_TLS);

    while (g_pts)
    {
        pts = g_pts;
        Verify(TlsSetValue(g_tlsThreadState, pts));
        DllThreadDetach(pts);

        Assert(!TlsGetValue(g_tlsThreadState));
        Assert(g_pts != pts);
    }

    for (ppfnPDetach=g_apfnPDetach; *ppfnPDetach; ppfnPDetach++)
        (**ppfnPDetach)();

    DEINIT_LOCK(DLL);

    if (g_tlsThreadState != NULL_TLS)
    {
        TlsFree(g_tlsThreadState);
    }
}


//+----------------------------------------------------------------------------
//  Function:   DllThreadAttach
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
DllThreadAttach()
{
    THREADSTATE *   pts;
    PFN_TATTACH *   ppfnTAttach;
    HRESULT         hr;

    LOCK(DLL);

    Assert(g_tlsThreadState != NULL_TLS);
    Assert(!::TlsGetValue(g_tlsThreadState));
    hr = AllocateThreadState(&pts);
    if (hr)
        goto Error;

    Assert(pts);
    pts->dll.idThread = GetCurrentThreadId();
    Verify(TlsSetValue(g_tlsThreadState, pts));

    Verify(SUCCEEDED(::CoGetMalloc(1, &pts->dll.pmalloc)));

    for (ppfnTAttach=g_apfnTAttach; *ppfnTAttach; ppfnTAttach++)
    {
        hr = (**ppfnTAttach)(pts);
        if (hr)
            goto Error;
    }

    pts->ptsNext = g_pts;
    g_pts = pts;

Cleanup:
    return hr;

Error:
    DllThreadDetach(pts);
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//  Function:   DllThreadDetach
//
//  Synopsis:
//
//  NOTE: Under Win95, DllThreadDetach may be called to clear memory on a
//        thread which did not allocate the memory.
//
//-----------------------------------------------------------------------------
void
DllThreadDetach(
    THREADSTATE * pts)
{
    THREADSTATE **  ppts;
    PFN_TDETACH *   ppfnTDetach;

    LOCK(DLL);

    if (!pts)
        return;

    Assert(!pts->dll.cUsage);
    Assert(pts == (THREADSTATE *)TlsGetValue(g_tlsThreadState));

    for (ppfnTDetach=g_apfnTDetach; *ppfnTDetach; ppfnTDetach++)
        (**ppfnTDetach)(pts);

    ::SRelease(pts->dll.pmalloc);

    ::TlsSetValue(g_tlsThreadState, NULL);

    for (ppts=&g_pts; *ppts && *ppts != pts; ppts=&((*ppts)->ptsNext));
    if (*ppts)
    {
        *ppts = pts->ptsNext;
    }
    delete pts;
}


//+----------------------------------------------------------------------------
//  Function:   DllProcessPassivate
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DllProcessPassivate()
{
    PFN_PPASSIVATE *    ppfnPPassivate;

    LOCK(DLL);

    Assert(!g_cUsage);

    // BUGBUG: What are the respective roles of process/thread passivation?
    // BUGBUG: This is an unsafe add into g_cUsage...fix this!
    g_cUsage += REF_GUARD;
    for (ppfnPPassivate=g_apfnPPassivate; *ppfnPPassivate; ppfnPPassivate++)
        (**ppfnPPassivate)();
    g_cUsage -= REF_GUARD;
}


//+----------------------------------------------------------------------------
//  Function:   DllThreadPassivate
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DllThreadPassivate()
{
    THREADSTATE *       pts = GetThreadState();
    PFN_TPASSIVATE *    ppfnTPassivate;

    Assert(!pts->dll.cUsage);
    pts->dll.cUsage += REF_GUARD;
    for (ppfnTPassivate=g_apfnTPassivate; *ppfnTPassivate; ppfnTPassivate++)
        (**ppfnTPassivate)(pts);
    pts->dll.cUsage -= REF_GUARD;
}


//+----------------------------------------------------------------------------
//  Function:   CClassFactory
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
CClassFactory::CClassFactory(
    CLASSFACTORY *  pcf)
    : CComponent(NULL)
{
    Assert(pcf);
    Assert(pcf->pfnFactory);
    _pcf = pcf;
}


//+----------------------------------------------------------------------------
//  Function:   CreateInstance
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::CreateInstance(
    IUnknown *  pUnkOuter,
    REFIID      riid,
    void **     ppvObj)
{
    if (!ppvObj)
        return E_INVALIDARG;
    *ppvObj = NULL;

    // BUGBUG: What error should be returned?
    if (pUnkOuter && riid != IID_IUnknown)
        return E_INVALIDARG;

    // BUGBUG: Should the factory just create the object and let this
    //         code perform the appropriate QI?
    // BUGBUG: This code should automatically handle aggregation
    Assert(_pcf);
    Assert(_pcf->pfnFactory);
    return _pcf->pfnFactory(pUnkOuter, riid, ppvObj);
}


//+----------------------------------------------------------------------------
//  Function:   LockServer
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::LockServer(
    BOOL    fLock)
{
    if (fLock)
    {
        AddRef();
        IncrementThreadUsage();
    }
    else
    {
        DecrementThreadUsage();
        Release();
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   GetLicInfo
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::GetLicInfo(
    LICINFO *   pLicInfo)

{
    Assert(_pcf->pfnLicense);
    return _pcf->pfnLicense(LICREQUEST_INFO, pLicInfo);
}


//+----------------------------------------------------------------------------
//  Function:   RequestLicKey
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::RequestLicKey(
    DWORD   ,   // dwReserved
    BSTR *  pbstrKey)
{
    Assert(_pcf->pfnLicense);
    return _pcf->pfnLicense(LICREQUEST_OBTAIN, pbstrKey);
}


//+----------------------------------------------------------------------------
//  Function:   CreateInstanceLic
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CClassFactory::CreateInstanceLic(
    IUnknown *  pUnkOuter,
    IUnknown *  ,           // pUnkReserved
    REFIID      riid,
    BSTR        bstrKey,
    void **     ppvObj)
{
    Assert(_pcf->pfnLicense);

    if (!ppvObj)
        return E_INVALIDARG;
    *ppvObj = NULL;

    if (_pcf->pfnLicense(LICREQUEST_VALIDATE, bstrKey) != S_OK)
    {
        return CLASS_E_NOTLICENSED;
    }

    return CreateInstance(pUnkOuter, riid, ppvObj);
}


//+----------------------------------------------------------------------------
//  Function:   PrivateQueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CClassFactory::PrivateQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    if (riid == IID_IClassFactory)
    {
        *ppvObj = (void *)(IClassFactory *)this;
    }
    else if (riid == IID_IClassFactory2)
    {
        if (_pcf->pfnLicense)
        {
            *ppvObj = (void *)(IClassFactory2 *)this;
        }
        else
        {
            return E_NOINTERFACE;
        }
    }
    else
    {
        return parent::PrivateQueryInterface(riid, ppvObj);
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   GetWin32Hresult
//
//  Synopsis:   Return an HRESULT derived from the current Win32 error
//
//-----------------------------------------------------------------------------
HRESULT
GetWin32Hresult()
{
    return HRESULT_FROM_WIN32(GetLastError());
}


//+----------------------------------------------------------------------------
//  Function:   EnsureThreadState
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
EnsureThreadState()
{
    extern DWORD g_tlsThreadState;
    Assert(g_tlsThreadState != NULL_TLS);
    if (!TlsGetValue(g_tlsThreadState))
        return DllThreadAttach();
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   IncrementProcessUsage
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
IncrementProcessUsage()
{
#ifdef _DEBUG
    Verify(InterlockedIncrement(&g_cUsage) > 0);
#else
    InterlockedIncrement(&g_cUsage);
#endif
}


//+----------------------------------------------------------------------------
//  Function:   DecrementProcessUsage
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DecrementProcessUsage()
{
#if DBG==1
    if( 0 == g_cUsage )
    {
        DebugBreak();   // ref counting problem
    }
#endif
    if (!InterlockedDecrement(&g_cUsage))
    {
        DllProcessPassivate();
    }
}



//+----------------------------------------------------------------------------
//  Function:   IncrementThreadUsage
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
IncrementThreadUsage()
{
#ifdef _DEBUG
    Verify(++TLS(dll.cUsage) > 0);
#else
    ++TLS(dll.cUsage);
#endif
    IncrementProcessUsage();
}


//+----------------------------------------------------------------------------
//  Function:   DecrementThreadUsage
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
void
DecrementThreadUsage()
{
    THREADSTATE *   pts = GetThreadState();
    if(pts)
    {
        pts->dll.cUsage--;
        Assert(pts->dll.cUsage >= 0);
        if (!pts->dll.cUsage)
        {
            DllThreadPassivate();
        }
    }
    DecrementProcessUsage();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\mgr\guids.cxx ===
//+----------------------------------------------------------------------------
//  File:       guids.cxx
//
//  Synopsis:   COM GUIDs
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#define INITGUID
#include <mgr.hxx>


// Globals --------------------------------------------------------------------
const char g_pszLPKVersion1[] = "{3d25aba1-caec-11cf-b34a-00aa00a28331}";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\core\mime64.cxx ===
//+----------------------------------------------------------------------------
//  File:       mime64.cxx
//
//  Synopsis:
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


// Constants ------------------------------------------------------------------
const LARGE_INTEGER LIB_ZERO = { 0, 0 };
const ULONG BUFFER_SIZE      = 256;
const UCHAR INVALID_CHAR     = (UCHAR)-2;
const UCHAR IGNORE_CHAR      = (UCHAR)-1;
const UCHAR CH_TERMINATION   = '=';
const char  achAlpha[]       = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
                               "abcdefghijklmnopqrstuvwxyz"
                               "0123456789+/";


// Globals --------------------------------------------------------------------
UCHAR   g_anBinary[256];


// Prototypes -----------------------------------------------------------------
inline ULONG BinaryFromASCII(UCHAR ch)  { return g_anBinary[ch]; }


//+----------------------------------------------------------------------------
//  Function:   ProcessAttachMIME64
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
ProcessAttachMIME64()
{
    UCHAR   ubin;
    UCHAR   ch;
    int     i;

    // BUGBUG: Hard code this table
    for (i=0; i < ARRAY_SIZE(g_anBinary); i++)
    {
        ch = (UCHAR)i;

        switch (ch)
        {
            case ' ' :
            case '\t':
            case '\n':
            case '\r':
                ubin = IGNORE_CHAR;
                break;

            default:
                if ((ch >= 'A') && (ch <= 'Z'))
                    ubin = (UCHAR)(ch - 'A');
                else if ((ch >= 'a') && (ch <= 'z'))
                    ubin = (UCHAR)(26 + (ch - 'a'));
                else if ((ch >= '0') && (ch <= '9'))
                    ubin = (UCHAR)(52 + (ch - '0'));
                else
                    ubin = INVALID_CHAR;
                break;

            case '+':
                ubin = 62;
                break;

            case '/':
                ubin = 63;
                break;
        }

        g_anBinary[i] = ubin;
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Function:   EncodeMIME64
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
EncodeMIME64(
    BYTE *      pbSrc,
    UINT        cbSrc,
    IStream *   pstmDest,
    ULONG *     pcbWritten)
{
    UCHAR   achOut[(2 * sizeof(UCHAR)) + CB_NEWLINE];
    ULONG   ichOut = 0;
    ULONG   cbWritten;
    ULONG   cbTotalWritten;
    ULONG   bAccum = 0;
    ULONG   cShift = 0;
    HRESULT hr = S_OK;

    Assert(pbSrc);
    Assert(pstmDest);

    if (!pcbWritten)
    {
        pcbWritten = &cbTotalWritten;
    }

    // Convert the source string, 6-bits at a time, to ASCII characters
    while (cbSrc)
    {
        bAccum <<= 8;
        cShift += 8;
        bAccum |= *pbSrc++;
        cbSrc--;

        while (cShift >= 6)
        {
            cShift -= 6;
            hr = pstmDest->Write(&achAlpha[(bAccum >> cShift) & 0x3FL], 1, &cbWritten);
            *pcbWritten += cbWritten;
            if (hr)
                goto Cleanup;
        }
    }

    // If there are bits not yet written, pad with zeros and write the resulting character
    if (cShift)
    {
        bAccum <<= 6 - cShift;
        achOut[ichOut++] = achAlpha[(bAccum >> cShift) & 0x3FL];
    }

    // Add a termination character and newline
    achOut[ichOut++] = CH_TERMINATION;
    ::memcpy(achOut+ichOut, SZ_NEWLINE, CB_NEWLINE);
    ichOut += CB_NEWLINE;

    hr = pstmDest->Write(achOut, ichOut, &cbWritten);
    *pcbWritten += cbWritten;
    if (hr)
        goto Cleanup;

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Function:   DecodeMIME64
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
DecodeMIME64(
    IStream *   pstmSrc,
    IStream *   pstmDest,
    ULONG *     pcbWritten)
{
    UCHAR   ch;
    UCHAR   achOut[BUFFER_SIZE];
    ULONG   ichOut = 0;
    ULONG   cbRead;
    ULONG   cbWritten;
    ULONG   cbTotalWritten = 0;
    ULONG   bAccum = 0;
    ULONG   cShift = 0;
    ULONG   bValue;
    HRESULT hr;

    if (!pcbWritten)
    {
        pcbWritten = &cbTotalWritten;
    }

    // As long as characters remain, convert them to binary
    // (This loop skips "whitespace" and stops when it encounters an out-of-range value)
    for (;;)
    {
        hr = pstmSrc->Read(&ch, sizeof(ch), &cbRead);
        if (hr)
            goto Cleanup;

        // Stop when no more characters remain
        if (!cbRead)
            break;

        bValue = BinaryFromASCII(ch);

        // Convert known characters back to binary
        if (bValue < 64)
        {
            bAccum <<= 6;
            cShift += 6;
            bAccum |= bValue;

            if (cShift >= 8)
            {
                cShift -= 8;
                achOut[ichOut++] = (UCHAR)((bAccum >> cShift) & 0xFF);

                if (ichOut >= ARRAY_SIZE(achOut))
                {
                    hr = pstmDest->Write(achOut, ichOut, &cbWritten);
                    *pcbWritten += cbWritten;
                    if (hr)
                        goto Cleanup;
                    ichOut = 0;
                }
            }
        }

        // Skip "whitespace"
        else if (bValue == IGNORE_CHAR)
            ;

        // Stop if anything else is encountered
        else
            break;
    }

    // If characters remain to be written, write them now
    if (ichOut)
    {
        hr = pstmDest->Write(achOut, ichOut, &cbWritten);
        *pcbWritten += cbWritten;
        if (hr)
            goto Cleanup;
    }

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\mgr\mgrpch.cxx ===
//+----------------------------------------------------------------------------
//  File:       mgrpch.hxx  
//
//  Synopsis:   Pre-compiled header
//
//-----------------------------------------------------------------------------

// Includes -------------------------------------------------------------------
#define	DLL_EXPORT
#include <mgr.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\mgr\array.cxx ===
//+----------------------------------------------------------------------------
//  File:       array.cxx
//
//  Synopsis:
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <mgr.hxx>
#include <factory.hxx>


//+----------------------------------------------------------------------------
//
//  Member:     AddClass
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CLicenseManager::AddClass(
    REFCLSID    rclsid,
    int *       piLic)
{
    IClassFactory2 *    pcf2 = NULL;
    LICINFO             licinfo;
    BSTR                bstrLic;
    int                 iLic;
    HRESULT             hr;

    Assert(piLic);
    Assert(!FindClass(rclsid, &iLic));

    // Get the class factory for the CLSID
    hr = ::CoGetClassObject(rclsid,
                            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
                            NULL,
                            IID_IClassFactory2, (void **)&pcf2);
    if (hr)
        goto Cleanup;
    Assert(pcf2);

    // Determine if the object supports the creation of runtime licenses
    licinfo.cbLicInfo = sizeof(LICINFO);
    hr = pcf2->GetLicInfo(&licinfo);
    if (hr)
        goto Cleanup;

    if (!licinfo.fRuntimeKeyAvail ||
        !licinfo.fLicVerified)
    {
        hr = CLASS_E_NOTLICENSED;
        goto Cleanup;
    }

    // Obtain the object's runtime license
    hr = pcf2->RequestLicKey(0, &bstrLic);
    if (hr)
        goto Cleanup;
    Assert(bstrLic);

    // Add the object and its runtime license to the array of CLSID-License pairs
    // (The class is added in ascending order based upon the first DWORD of the CLSID)
    hr = _aryLic.SetSize(_aryLic.Size()+1);
    if (hr)
        goto Cleanup;

    for (iLic = 0; iLic < (_aryLic.Size()-1); iLic++)
    {
        if (rclsid.Data1 < _aryLic[iLic].clsid.Data1)
            break;
    }

    if (iLic < (_aryLic.Size()-1))
    {
        ::memmove(&_aryLic[iLic+1], &_aryLic[iLic], sizeof(_aryLic[0])*(_aryLic.Size()-iLic-1));
    }

    _aryLic[iLic].clsid = rclsid;
    _aryLic[iLic].bstrLic = bstrLic;
    _aryLic[iLic].pcf2 = pcf2;
    pcf2 = NULL;
    *piLic = iLic;
    _fDirty = TRUE;

Cleanup:
    ::SRelease(pcf2);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     FindClass
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
BOOL
CLicenseManager::FindClass(
    REFCLSID    rclsid,
    int *       piLic)
{
    int iLic;

    Assert(piLic);

    // BUGBUG: Consider using a more efficient search if the number of classes is large
    for (iLic=0; iLic < _aryLic.Size(); iLic++)
    {
        if (_aryLic[iLic].clsid.Data1 == rclsid.Data1 &&
            _aryLic[iLic].clsid == rclsid)
            break;
    }

    if (iLic < _aryLic.Size())
    {
        *piLic = iLic;
    }
    return (iLic < _aryLic.Size());
}


//+----------------------------------------------------------------------------
//
//  Member:     OnChangeInRequiredClasses
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::OnChangeInRequiredClasses(
    IRequireClasses *   pRequireClasses)
{
    ULONG   cClasses;
    ULONG   iClass;
    int     cLic;
    int     iLic;
    CLSID   clsid;
    BOOL    fClassUsed;
    BOOL    fClassNotLicensed = FALSE;
    HRESULT hr;

    if (!pRequireClasses)
        return E_INVALIDARG;

    // Determine the number of required classes
    hr = pRequireClasses->CountRequiredClasses(&cClasses);
    if (hr)
        goto Cleanup;

    // Add new classes to the array of required classes
    // NOTE: During this pass, all required classes are also marked as "in use"
    //       Because of this, the second loop must also alway run, even when errors occur,
    //       to remove these marks; that is, this loop cannot "goto Cleanup"
    for (iClass = 0; iClass < cClasses; iClass++)
    {
        // Get the CLSID of the required class
        hr = pRequireClasses->GetRequiredClasses(iClass, &clsid);
        if (hr)
            break;

        // Check if the class is already known; if not, add it
        // (Ignore "false" errors which occur during adding the class and treat it as unlicensed)
        fClassUsed = TRUE;                      // Assume the class will be used
        if (!FindClass(clsid, &iLic))
        {
            hr = AddClass(clsid, &iLic);
            if (hr)
            {
                if (hr == E_OUTOFMEMORY)
                    break;
                fClassUsed = FALSE;             // Class was not found nor added
                fClassNotLicensed = TRUE;
                hr = S_OK;
            }
        }

        // Mark the class as "in use" by setting the high-order bit of the factory address
        if (fClassUsed)
        {
            Assert((ULONG)(_aryLic[iLic].pcf2) < (ULONG_PTR)ADDRESS_TAG_BIT);
            _aryLic[iLic].pcf2 = (IClassFactory2 *)((ULONG_PTR)(_aryLic[iLic].pcf2) | ADDRESS_TAG_BIT);
        }
    }

    // Remove from the array classes no longer required
    // NOTE: If hr is not S_OK, then this loop should still execute, but only to clear
    //       the mark bits on the IClassFactory2 interface pointers, no other changes
    //       should occur
    //       Also, early exits from this loop (using "break" for example) must not occur
    for (cLic = iLic = 0; iLic < _aryLic.Size(); iLic++)
    {
        // If the class is "in use", clear the mark bit
        if ((ULONG_PTR)(_aryLic[iLic].pcf2) & ADDRESS_TAG_BIT)
        {
            _aryLic[iLic].pcf2 = (IClassFactory2 *)((ULONG_PTR)(_aryLic[iLic].pcf2) & (ADDRESS_TAG_BIT-1));

            // If classes have been removed, shift this class down to the first open slot
            if (!hr && iLic > cLic)
            {
                _aryLic[cLic] = _aryLic[iLic];
                ::memset(&(_aryLic[iLic]), 0, sizeof(_aryLic[iLic]));
            }
        }

        // Otherwise, free the class and remove it from the array
        else if (!hr)
        {
            ::SysFreeString(_aryLic[iLic].bstrLic);
            ::SRelease(_aryLic[iLic].pcf2);
            ::memset(&(_aryLic[iLic]), 0, sizeof(_aryLic[iLic]));
            _fDirty = TRUE;
        }

        // As long as it points at a valid class, increment the class counter
        if (_aryLic[cLic].clsid != CLSID_NULL)
        {
            cLic++;
        }
    }
    Implies(hr, cLic == _aryLic.Size());
    Implies(!hr, (ULONG)cLic <= cClasses);
    Verify(SUCCEEDED(_aryLic.SetSize(cLic)));

Cleanup:
    // If a real error occurred, return it
    // Otherwise return CLASS_E_NOTLICENSED if any un-licensed objects were encountered
    return (hr
                ? hr
                : (fClassNotLicensed
                        ? CLASS_E_NOTLICENSED
                        : S_OK));
}


//+----------------------------------------------------------------------------
//
//  Member:     CreateInstance
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::CreateInstance(
    CLSID       clsid,
    IUnknown *  pUnkOuter,
    REFIID      riid,
    DWORD       dwClsCtx,
    void **     ppvObj)
{
    int     iLic;
    HRESULT hr;

    // If there is a runtime license for the class, create it using IClassFactory2
    if (FindClass(clsid, &iLic))
    {
        if (!_aryLic[iLic].pcf2)
        {
            //
            // The following code calls CoGetClassObject for an IClassFactory
            // then QIs for an IClassFactory2. This is because of an apparent
            // bug in ole32.dll.  On a win95 system if the call to
            // CoGetClassObject is remoted and you ask for IClassFactory2 the
            // process hangs.
            //

		    IClassFactory *pIClassFactory;

            hr = ::CoGetClassObject(clsid, dwClsCtx, NULL,
                                    IID_IClassFactory, (void **)&(pIClassFactory));

            if (SUCCEEDED(hr)) {

                hr = pIClassFactory->QueryInterface(IID_IClassFactory2,
                                                    (void **)&(_aryLic[iLic].pcf2));

                pIClassFactory->Release();
            }

            if (hr)			
                goto Cleanup;

        }

        Assert(_aryLic[iLic].pcf2);
        Assert(_aryLic[iLic].bstrLic != NULL);
        hr = _aryLic[iLic].pcf2->CreateInstanceLic(pUnkOuter, NULL,
                                                   riid, _aryLic[iLic].bstrLic, ppvObj);
    }

    // Otherwise, use the standard COM mechanisms
    else
    {
        hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsCtx, riid, ppvObj);
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetTypeLibOfClsid
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetTypeLibOfClsid(
    CLSID       clsid,
    ITypeLib ** ptlib)
{
    UNREF(clsid);
    UNREF(ptlib);
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetClassObjectOfClsid
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetClassObjectOfClsid(
    REFCLSID    rclsid,
    DWORD       dwClsCtx,
    LPVOID      lpReserved,
    REFIID      riid,
    void **     ppcClassObject)
{
    // Load the class object
    return ::CoGetClassObject(rclsid, dwClsCtx, lpReserved, riid, ppcClassObject);
}


//+----------------------------------------------------------------------------
//
//  Member:     CountRequiredClasses
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::CountRequiredClasses(
    ULONG * pcClasses)
{
    if (!pcClasses)
        return E_INVALIDARG;

    // Return the current number of classes
    *pcClasses = _aryLic.Size();

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetRequiredClasses
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetRequiredClasses(
    ULONG   iClass,
    CLSID * pclsid)
{
    if (!pclsid || iClass >= (ULONG)_aryLic.Size())
        return E_INVALIDARG;

    // Return the requested CLSID
    *pclsid = _aryLic[iClass].clsid;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\core\util.cxx ===
//+----------------------------------------------------------------------------
//  File:       util.cxx
//
//  Synopsis:
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <core.hxx>


// Globals --------------------------------------------------------------------
const UCHAR SZ_NEWLINE[] = "\n\r";


//+----------------------------------------------------------------------------
//  Function:   CopyStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CopyStream(
    IStream *           pstmDest,
    IStream *           pstmSrc,
    ULARGE_INTEGER      cbCopy,
    ULARGE_INTEGER *    pcbRead,
    ULARGE_INTEGER *    pcbWritten)
{
    DWORD   cb     = cbCopy.LowPart;
    DWORD   cbStep = min(cb, 0xFFFF);
    DWORD   cbRead, cbWritten;
    DWORD   cbTotalRead = 0;
    DWORD   cbTotalWritten = 0;
    void *  pv = NULL;
    HRESULT hr = S_OK;

    if (cbCopy.HighPart)
        return E_INVALIDARG;

    pv = new BYTE[cbStep];
    if (!pv)
        return E_OUTOFMEMORY;

    while (cb)
    {
        cbRead = min(cbStep, cb);

        hr = pstmSrc->Read(pv, cbRead, &cbRead);
        if (hr || !cbRead)
            break;

        cbTotalRead += cbRead;

        hr = pstmDest->Write(pv, cbRead, &cbWritten);
        if (S_OK != hr)
            break;

        cbTotalWritten += cbWritten;

        if (cbWritten != cbRead)
        {
            hr = E_UNEXPECTED;
            break;
        }

        cb -= cbRead;
    }

    if (pcbRead)
    {
        pcbRead->HighPart = 0;
        pcbRead->LowPart  = cbTotalRead;
    }

    if (pcbWritten)
    {
        pcbWritten->HighPart = 0;
        pcbWritten->LowPart  = cbTotalWritten;
    }

    delete [] pv;
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Read
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::Read(
    void *  pv,
    ULONG   cb,
    ULONG * pcbRead)
{
    Assert(_pbData);
    Assert(_ibPos <= _cbSize);

    cb = min(cb, _cbSize - _ibPos);

    ::memcpy(pv, _pbData + _ibPos, cb);
    _ibPos += cb;

    if (pcbRead)
    {
        *pcbRead = cb;
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Member:     Write
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::Write(
    const void *    pv,
    ULONG           cb,
    ULONG *         pcbWritten)
{
    HRESULT hr = S_OK;

    Assert(_pbData);
    Assert(_ibPos <= _cbSize);

    if ((_ibPos + cb) > _cbSize)
    {
        hr = STG_E_MEDIUMFULL;
        goto Cleanup;
    }

    ::memcpy(_pbData + _ibPos, pv, cb);
    _ibPos += cb;

Cleanup:
    if (pcbWritten)
    {
        *pcbWritten = (SUCCEEDED(hr) ? cb : 0);
    }
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Seek
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::Seek(
    LARGE_INTEGER       dlibMove,
    DWORD               dwOrigin,
    ULARGE_INTEGER *    plibNewPosition)
{
    LONG    ibOffset = (LONG)dlibMove.LowPart;

    Assert(_pbData);

    // Ensure only 32-bits is in-use
    if (!(dlibMove.HighPart ==  0 && ibOffset >= 0) &&
        !(dlibMove.HighPart == -1 && ibOffset < 0))
        return E_INVALIDARG;

    switch (dwOrigin)
    {
        case STREAM_SEEK_SET:
            break;

        case STREAM_SEEK_CUR:
            ibOffset = (LONG)_ibPos + ibOffset;
            break;

        case STREAM_SEEK_END:
            ibOffset = (LONG)_cbSize + ibOffset;
            break;

        default:
            return E_INVALIDARG;
    }

    // Ensure the new offset is within the correct range
    if ((ULONG)ibOffset > _cbSize)
        return E_INVALIDARG;

    // Store the new offset and return it
    _ibPos = (ULONG)ibOffset;

    if (plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart = _ibPos;
    }

    return S_OK;
}


//+----------------------------------------------------------------------------
//  Member:     SetSize
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::SetSize(
    ULARGE_INTEGER  libNewSize)
{
    if (libNewSize.HighPart)
        return STG_E_MEDIUMFULL;

    if (libNewSize.LowPart <= _cbSize)
    {
        _cbSize = libNewSize.LowPart;
    }
    else
    {
        BYTE *  pbData = new BYTE[libNewSize.LowPart];
        
        if (!pbData)
            return STG_E_MEDIUMFULL;

        if (_pbData && _cbSize)
        {
            ::memcpy(pbData, _pbData, _cbSize);
        }

        delete [] _pbData;
        _cbSize = libNewSize.LowPart;
        _pbData = pbData;
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//  Member:     CopyTo
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CMemoryStream::CopyTo(
    IStream *           pstm,
    ULARGE_INTEGER      cb,
    ULARGE_INTEGER *    pcbRead,
    ULARGE_INTEGER *    pcbWritten)
{
    if (!pstm)
        return STG_E_INVALIDPOINTER;

    if (cb.HighPart || ((_ibPos + cb.LowPart) > _cbSize))
        return E_INVALIDARG;

    Assert(_pbData);
    return ::CopyStream(pstm, this, cb, pcbRead, pcbWritten);
}


//+----------------------------------------------------------------------------
//  Member:     CBufferedStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
CBufferedStream::CBufferedStream(
    IStream *   pstm,
    ULONG       cbNewLine,
    BOOL        fRead)
{
    Assert(_pstm);

    _fRead = fRead;
    _pb = NULL;
    _cb = 0;
    _ib = 0;
    _cbLine    = 0;
    _cbNewLine = cbNewLine;
    _cbTotal   = 0;
    _pstm = ::SAddRef(pstm);
}


//+----------------------------------------------------------------------------
//  Member:     ~CBufferedStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
CBufferedStream::~CBufferedStream()
{
    Verify(SUCCEEDED(Flush()));
    ::SRelease(_pstm);
    delete [] _pb;
}


//+----------------------------------------------------------------------------
//  Member:     Flush
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CBufferedStream::Flush(
    ULONG * pcbWritten)
{
    ULONG   cbWritten;
    HRESULT hr = S_OK;

    Assert(_pstm);
    Implies(_cbNewLine, _ib <= (_cb + CB_NEWLINE));
    Implies(!_cbNewLine, _ib <= _cb);

    if (!pcbWritten)
    {
        pcbWritten = &cbWritten;
    }
    *pcbWritten = 0;

    // For read-only streams, "read" the rest of the buffer by setting the buffer index
    // (This will force a re-load during the next read)
    if (_fRead)
    {
        _ib = _cb;
    }

    // For write-only streams, write the buffer to the stream
    else if (_ib)
    {
        Assert(!_fRead);
        hr = _pstm->Write(_pb, _ib, pcbWritten);
        _cbTotal += *pcbWritten;
        if (S_OK == hr)
        {
            Assert(*pcbWritten == _ib);
            _ib = 0;
        }
    }

    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Load
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CBufferedStream::Load()
{
    HRESULT hr;

    Assert(_fRead);

    hr = _pstm->Read(_pb, _cb, &_cbTotal);
    if (S_OK != hr)
        goto Cleanup;
    _ib = 0;

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     SetBufferSize
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CBufferedStream::SetBufferSize(
    ULONG   cb)
{
    // The buffer size cannot be changed once it has been set
    // Also, it is illegal to use a zero-sized buffer
    if (_pb || !cb)
        return E_FAIL;

    // Allocate a new buffer of the requested size
    // (If the caller requested automatic interjection of NEWLINEs, slightly increase
    //  allocated buffer; the remembered size will continue to be that which they
    //  requested)
    _pb = new BYTE[cb + (_cbNewLine ? CB_NEWLINE : 0)];
    if (!_pb)
        return E_OUTOFMEMORY;
    _cb = cb;
    _ib = (_fRead ? _cb : 0);

    return S_OK;
}


//+----------------------------------------------------------------------------
//  Member:     Read
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CBufferedStream::Read(
    void *  pv,
    ULONG   cb,
    ULONG * pcbRead)
{
    ULONG   cbTotalRead;
    ULONG   cbRead;
    HRESULT hr = S_OK;

    Assert(_pb);
    Assert(_cb);
    Assert(_ib <= _cb);

    if (!pv)
        return E_INVALIDARG;

    if (!pcbRead)
    {
        pcbRead = &cbTotalRead;
    }
    *pcbRead = 0;

    // If bytes remain in the buffer, "read" those first
    if (_ib < _cbTotal)
    {
        cbRead = min(cb, _cbTotal-_ib);
        ::memcpy(pv, _pb+_ib, cbRead);
        _ib += cbRead;
        cb  -= cbRead;
        pv   = (void *)(((const BYTE *)pv) + cbRead);
        *pcbRead += cbRead;
    }

    // If bytes remain to be read, fetch them now
    if (cb)
    {
        Assert(_ib >= _cbTotal);
        Assert(_cbTotal <= _cb);

        // If the request fits within half of the buffer, then load a buffer full
        if (cb < (_cb/2))
        {
            hr = Load();
            if (S_OK != hr)
                goto Cleanup;

            cbRead = min(cb, _cbTotal);
            ::memcpy(pv, _pb, cbRead);

            _ib = cbRead;
            *pcbRead += cbRead;
        }

        // Otherwise, read directly into the callers buffer
        else
        {
            hr = _pstm->Read(pv, cb, pcbRead);
        }
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Write
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CBufferedStream::Write(
    const void *    pv,
    ULONG           cb,
    ULONG *         pcbWritten)
{
    const BYTE *    pbSrc = (const BYTE *)pv;
    ULONG           ibSrc = 0;
    ULONG           cbWritten;
    HRESULT         hr = S_OK;

    Assert(_pb);
    Assert(_cb);
    Assert(_ib <= _cb);

    if (!pv)
        return E_INVALIDARG;

    if (pcbWritten)
    {
        *pcbWritten = 0;
    }

    // Treat calls to write on a read-only stream as if the stream is full
    if (_fRead)
    {
        hr = STG_E_MEDIUMFULL;
        goto Cleanup;
    }

    // Write the bytes to the stream
    while (cb)
    {
        // Determine the number of bytes to write this time through
        cbWritten = min(cb, _cb-_ib);
        if (_cbNewLine)
        {
            cbWritten = min(cbWritten, _cbNewLine-_cbLine);
        }

        // Write the bytes to the local buffer
        ::memcpy(_pb + _ib, pbSrc + ibSrc, cbWritten);

        // Update the counters reflecting what has been written
        // (Adding a newline if necessary)
        cb    -= cbWritten;
        ibSrc += cbWritten;
        _ib   += cbWritten;
        if (_cbNewLine)
        {
            _cbLine += cbWritten;
            if (_cbLine >= _cbNewLine)
            {
                ::memcpy(_pb + _ib, SZ_NEWLINE, CB_NEWLINE);
                _cbLine = 0;
                _ib    += CB_NEWLINE;
            }
        }

        // If the buffer is full, write it to the stream
        if (_ib >= _cb)
        {
            hr = Flush(&cbWritten);
            if (pcbWritten)
            {
                *pcbWritten += cbWritten;
            }
            if (S_OK != hr)
                goto Cleanup;
        }
    }

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     CFileStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
CFileStream::CFileStream()
{
    _hFile = NULL;
}


//+----------------------------------------------------------------------------
//  Member:     ~CFileStream
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
CFileStream::~CFileStream()
{
    if (_hFile)
    {
        ::CloseHandle(_hFile);
    }
}


//+----------------------------------------------------------------------------
//  Member:     Init
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CFileStream::Init(
    LPCWSTR                 wszFileName,
    DWORD                   dwDesiredAccess,
    DWORD                   dwShareMode,
    LPSECURITY_ATTRIBUTES   pSecurityAttributes,
    DWORD                   dwCreationDistribution,
    DWORD                   dwFlagsAndAttributes,
    HANDLE                  hTemplateFile)
{
	int len = WideCharToMultiByte(CP_ACP, 0, wszFileName, -1, 0, 0, NULL, NULL);
	LPSTR psz = new CHAR[len];

    if (psz)
    {
        if (::WideCharToMultiByte(CP_ACP, 0, wszFileName, -1, (LPSTR)psz, len, NULL, NULL))
        {
	        _hFile = ::CreateFileA(psz, dwDesiredAccess, dwShareMode, pSecurityAttributes,	
                                dwCreationDistribution,	dwFlagsAndAttributes, hTemplateFile);
        }
	    delete [] psz;
    }
    else
    {
        return E_OUTOFMEMORY;
    }

	// CreateFile succeeded if we didn't get back INVALID_HANDLE_VALUE
    return ((_hFile != INVALID_HANDLE_VALUE)
                ? S_OK
                : GetWin32Hresult());
}


//+----------------------------------------------------------------------------
//  Member:     GetFileSize
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
HRESULT
CFileStream::GetFileSize(
    ULONG * pcbSize)
{
    Assert(_hFile);
    Assert(pcbSize);
    *pcbSize = ::GetFileSize(_hFile, NULL);
    return (*pcbSize == 0xFFFFFFFF
                ? GetWin32Hresult()
                : S_OK);
}


//+----------------------------------------------------------------------------
//  Member:     Read
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::Read(
    void *  pv,
    ULONG   cb,
    ULONG * pcbRead)
{
    ULONG   cbRead;
    HRESULT hr = S_OK;

    if (!pv)
        return E_INVALIDARG;

    if (!pcbRead)
    {
        pcbRead = &cbRead;
    }

    hr = (::ReadFile(_hFile, pv, cb, pcbRead, NULL)
                ? S_OK
                : S_FALSE);

    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Write
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::Write(
    const void *    pv,
    ULONG           cb,
    ULONG *         pcbWritten)
{
    ULONG   cbWritten;
    HRESULT hr;

    if (!pv)
        return E_INVALIDARG;

    if (!pcbWritten)
    {
        pcbWritten = &cbWritten;
    }

    hr = (::WriteFile(_hFile, pv, cb, pcbWritten, NULL)
                ? S_OK
                : STG_E_MEDIUMFULL);
    return hr;
}


//+----------------------------------------------------------------------------
//  Member:     Seek
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::Seek(
    LARGE_INTEGER       dlibMove,
    DWORD               dwOrigin,
    ULARGE_INTEGER *    plibNewPosition)
{
    DWORD           dwMoveMethod;
    ULARGE_INTEGER  libNewPosition;
    HRESULT         hr;

    if (plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart  = 0;
    }

    switch(dwOrigin)
    {
        case STREAM_SEEK_SET: dwMoveMethod = FILE_BEGIN; break;
        case STREAM_SEEK_CUR: dwMoveMethod = FILE_CURRENT; break;
        case STREAM_SEEK_END: dwMoveMethod = FILE_END; break;
        default:
            return E_INVALIDARG;
    }

    libNewPosition.LowPart = ::SetFilePointer(_hFile, dlibMove.LowPart, &dlibMove.HighPart, dwMoveMethod);
    libNewPosition.HighPart = dlibMove.HighPart;

    if (libNewPosition.LowPart == 0xFFFFFFFF &&
        ::GetLastError() != NO_ERROR)
    {
        hr = STG_E_INVALIDPOINTER;
    }
    else
    {
        if (plibNewPosition)
        {
            *plibNewPosition = libNewPosition;
        }
        hr = S_OK;
    }

    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     SetSize
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::SetSize(
    ULARGE_INTEGER  libNewSize)
{
    LONG    curLow, curHigh;
    BOOL    fEOFSet;

    curHigh = 0;
    curLow = ::SetFilePointer(_hFile, 0, &curHigh, FILE_CURRENT);
    if (0xFFFFFFFF == ::SetFilePointer(_hFile, libNewSize.LowPart,
                                        (LONG *)&libNewSize.HighPart, FILE_BEGIN))
    {
        return STG_E_INVALIDFUNCTION;
    }

    fEOFSet = ::SetEndOfFile(_hFile);
#ifdef _DEBUG
    Verify(0xFFFFFFFF != ::SetFilePointer(_hFile, curLow, &curHigh, FILE_BEGIN));
#else
    ::SetFilePointer(_hFile, curLow, &curHigh, FILE_BEGIN);
#endif

    return (fEOFSet
                ? S_OK
                : STG_E_MEDIUMFULL);
}


//+----------------------------------------------------------------------------
//
//  Member:     CopyTo
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CFileStream::CopyTo(
    IStream *           pstm,
    ULARGE_INTEGER      cb,
    ULARGE_INTEGER *    pcbRead,
    ULARGE_INTEGER *    pcbWritten)
{
    if (!pstm)
        return STG_E_INVALIDPOINTER;

    return ::CopyStream(pstm, this, cb, pcbRead, pcbWritten);
}


//+----------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
CFileStream::PrivateQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    if (riid == IID_IStream)
        *ppvObj = (IStream *)this;

    if (*ppvObj)
        return S_OK;
    else
        return parent::PrivateQueryInterface(riid, ppvObj);
}


//+----------------------------------------------------------------------------
//  Function:   CoAlloc
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void *
CoAlloc(
    ULONG   cb)
{
    Assert(TLS(dll.pmalloc));
    return TLS(dll.pmalloc)->Alloc(cb);
}


//+----------------------------------------------------------------------------
//  Function:   CoFree
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
void
CoFree(
    void *  pv)
{
    if (!pv)
        return;

    Assert(TLS(dll.pmalloc));
    Assert(CoDidAlloc(pv));
    TLS(dll.pmalloc)->Free(pv);
}


//+----------------------------------------------------------------------------
//  Function:   CoGetSize
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
ULONG
CoGetSize(
    void *  pv)
{
    Assert(TLS(dll.pmalloc));
    Assert(CoDidAlloc(pv));
    return (ULONG)(TLS(dll.pmalloc)->GetSize(pv));
}


//+----------------------------------------------------------------------------
//  Function:   CoDidAlloc
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------
BOOL
CoDidAlloc(
    void *  pv)
{
    Assert(TLS(dll.pmalloc));
    return (!pv || TLS(dll.pmalloc)->DidAlloc(pv) == 1
                ? TRUE
                : FALSE);
}


#ifdef _NOCRT
//+----------------------------------------------------------------------------
//  Function:   purecall
//
//  Synopsis:   _SHIP build replacement for CRT vtable routine
//
//-----------------------------------------------------------------------------
int __cdecl
_purecall()
{
    return 0;
}


//+----------------------------------------------------------------------------
//  Function:   _tcslen
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" size_t __cdecl
_tcslen(
    const TCHAR *   psz)
{
    for (size_t i=0; *psz; psz++, i++);
    return i;
}


//+----------------------------------------------------------------------------
//  Function:   memcmp
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" int __cdecl
memcmp(
    const void *    pv1,
    const void *    pv2,
    size_t          cb)
{
    size_t  i;
    int     d;
    for (i=0, d=0; i < cb && !d; i++)
        d = (*(const BYTE *)pv1) - (*(const BYTE *)pv2);
    return d;
}


//+----------------------------------------------------------------------------
//  Function:   memcpy
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" void * __cdecl
memcpy(
    void *          pvDest,
    const void *    pvSrc,
    size_t          cb)
{
    for (size_t i=0; i < cb; i++)
        ((BYTE *)pvDest)[i] = ((const BYTE *)pvSrc)[i];
    return pvDest;
}


//+----------------------------------------------------------------------------
//  Function:   memset
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" void * __cdecl
memset(
    void *  pv,
    int     c,
    size_t  cb)
{
    for (size_t i=0; i < cb; i++)
        ((BYTE *)pv)[i] = (BYTE)c;
    return pv;
}


//+----------------------------------------------------------------------------
//  Function:   memmove
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
extern "C" void * __cdecl
memmove(
    void *          pvDest,
    const void *    pvSrc,
    size_t          cb)
{
    BYTE *  pb1;
    BYTE *  pb2;

    if (pvSrc < pvDest)
    {
        pb1 = (BYTE *)pvDest + cb;
        pb2 = (BYTE *)pvSrc  + cb;
        for (; cb; cb--)
        {
            *pb1-- = *pb2--;
        }
    }
    else if (pvSrc > pvDest)
    {
        pb1 = (BYTE *)pvDest;
        pb2 = (BYTE *)pvSrc;
        for (; cb; cb--)
        {
            *pb1++ = *pb2++;
        }
    }
    return pvDest;
}
#endif // _NOCRT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\mgr\main.cxx ===
//+----------------------------------------------------------------------------
//  File:       main.cxx
//
//  Synopsis:   This file contains the core routines and globals for creating
//              LICMGR.DLL
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <mgr.hxx>
#include <factory.hxx>


// Globals --------------------------------------------------------------------
BEGIN_PROCESS_ATTACH
    ATTACH_METHOD(ProcessAttachMIME64)
END_PROCESS_ATTACH

BEGIN_PROCESS_DETACH
END_PROCESS_DETACH

BEGIN_THREAD_ATTACH
END_THREAD_ATTACH

BEGIN_THREAD_DETACH
END_THREAD_DETACH

BEGIN_PROCESS_PASSIVATE
END_PROCESS_PASSIVATE

BEGIN_THREAD_PASSIVATE
END_THREAD_PASSIVATE

BEGIN_CLASS_FACTORIES
    FACTORY(CLSID_LicenseManager, LicenseManagerFactory, NULL)
END_CLASS_FACTORIES

DEFINE_REGISTRY_SECKEY(LicenseManagerCLSID, CLSID, {5220cb21-c88d-11cf-b347-00aa00a28331})
    DEFAULT_VALUE(Microsoft Licensed Class Manager 1.0)
    BEGIN_SUBKEY(Implemented Categories)
        BEGIN_SUBKEY({7DD95801-9882-11CF-9FA9-00AA006C42C4})
        END_SUBKEY
        BEGIN_SUBKEY({7DD95802-9882-11CF-9FA9-00AA006C42C4})
        END_SUBKEY
    END_SUBKEY
    BEGIN_SUBKEY(InprocServer32)
        DEFAULT_VALUE(<m>)
        BEGIN_NAMED_VALUES
            NAMED_VALUE(ThreadingModel, Apartment)
        END_NAMED_VALUES
    END_SUBKEY
    BEGIN_SUBKEY(MiscStatus)
        DEFAULT_VALUE(0)
    END_SUBKEY
    BEGIN_SUBKEY(ProgID)
        DEFAULT_VALUE(License.Manager.1)
    END_SUBKEY
    BEGIN_SUBKEY(Version)
        DEFAULT_VALUE(1.0)
    END_SUBKEY
    BEGIN_SUBKEY(VersionIndependentProgID)
        DEFAULT_VALUE(License.Manager)
    END_SUBKEY
END_REGISTRY_KEY

DEFINE_REGISTRY_KEY(LicenseManagerProgID, License.Manager.1)
    DEFAULT_VALUE(Microsoft Licensed Class Manager 1.0)
    BEGIN_SUBKEY(CLSID)
        DEFAULT_VALUE({5220cb21-c88d-11cf-b347-00aa00a28331})
    END_SUBKEY
END_REGISTRY_KEY

DEFINE_REGISTRY_KEY(LicenseManagerVProgID, License.Manager)
    DEFAULT_VALUE(Microsoft Licensed Class Manager)
    BEGIN_SUBKEY(CurVer)
        DEFAULT_VALUE(License.Manager.1)
    END_SUBKEY
END_REGISTRY_KEY

BEGIN_REGISTRY_KEYS
    REGISTRY_KEY(LicenseManagerCLSID)
    REGISTRY_KEY(LicenseManagerProgID)
    REGISTRY_KEY(LicenseManagerVProgID)
END_REGISTRY_KEYS


//+----------------------------------------------------------------------------
//  Function:   AllocateThreadState
//
//  Synopsis:
//
//-----------------------------------------------------------------------------
HRESULT
AllocateThreadState(
    THREADSTATE **  ppts)
{
    Assert(ppts);

    *ppts = new THREADSTATE;
    if (!*ppts)
    {
        return E_OUTOFMEMORY;
    }

    memset(*ppts, 0, sizeof(THREADSTATE));
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Function:   LicensedClassManagerFactory
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
LicenseManagerFactory(
    IUnknown *  pUnkOuter,
    REFIID      riid,
    void **     ppvObj)
{
    CLicenseManager *  plcmgr = new CLicenseManager(pUnkOuter);

    if (!plcmgr)
    {
        *ppvObj = NULL;
        return E_OUTOFMEMORY;
    }

    return plcmgr->PrivateQueryInterface(riid, ppvObj);
}


//+----------------------------------------------------------------------------
//
//  Member:     CLicenseManager
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
CLicenseManager::CLicenseManager(
    IUnknown *  pUnkOuter)
 : CComponent(pUnkOuter)
{
    _pUnkSite = NULL;

    _fDirty  = FALSE;
    _fLoaded = FALSE;
    _fPersistPBag   = FALSE;
    _fPersistStream = FALSE;

    _guidLPK = GUID_NULL;
}


//+----------------------------------------------------------------------------
//
//  Member:     ~CLicenseManager
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
CLicenseManager::~CLicenseManager()
{
    int i;

    for (i = _aryLic.Size()-1; i >= 0; i--)
    {
        ::SysFreeString(_aryLic[i].bstrLic);
        ::SRelease(_aryLic[i].pcf2);
    }

    ::SRelease(_pUnkSite);
}


//+----------------------------------------------------------------------------
//
//  Member:     SetSite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::SetSite(
    IUnknown *  pUnkSite)
{
    ::SClear(&_pUnkSite);

    _pUnkSite = pUnkSite;
    if (_pUnkSite)
    {
        _pUnkSite->AddRef();
    }
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetSite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetSite(
    REFIID  riid,
    void ** ppvSite)
{
    HRESULT hr;

    if (!ppvSite)
        return E_INVALIDARG;

    if (_pUnkSite)
    {
        hr = _pUnkSite->QueryInterface(riid, ppvSite);
    }
    else
    {
        *ppvSite = NULL;
        hr = E_FAIL;
    }
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     SetClientSite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::SetClientSite(
    IOleClientSite *    pClientSite)
{
    return SetSite(pClientSite);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetClientSite
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetClientSite(
    IOleClientSite **   ppClientSite)
{
    return GetSite(IID_IOleClientSite, (void **)ppClientSite);
}


//+----------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CLicenseManager::PrivateQueryInterface(
    REFIID  riid,
    void ** ppvObj)
{
    if (riid == IID_IObjectWithSite)
        *ppvObj = (IObjectWithSite *)this;

    else if (riid == IID_IOleObject)
        *ppvObj = (IOleObject *)this;

    else if (riid == IID_ILicensedClassManager)
        *ppvObj = (ILicensedClassManager *)this;

    else if (riid == IID_ILocalRegistry)
        *ppvObj = (ILocalRegistry *)this;

    else if (riid == IID_IRequireClasses)
        *ppvObj = (IRequireClasses *)this;

    else if (riid == IID_IPersistStream && !_fPersistPBag)
    {
        _fPersistStream = TRUE;
        *ppvObj = (IPersistStream *)this;
    }

    else if (riid == IID_IPersistStreamInit && !_fPersistPBag)
    {
        _fPersistStream = TRUE;
        *ppvObj = (IPersistStreamInit *)this;
    }

    else if (riid == IID_IPersistPropertyBag && !_fPersistStream)
    {
        _fPersistPBag = TRUE;
        *ppvObj = (IPersistPropertyBag *)this;
    }

    if (*ppvObj)
        return S_OK;
    else
        return parent::PrivateQueryInterface(riid, ppvObj);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\mgr\version.h ===
#define rmj 1
#define rmm 0
#define rup 0
#define szVerName "licmgr"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iexplore\debug.c ===
// This file cannot be compiled as a C++ file, otherwise the linker
// will bail on unresolved externals (even with extern "C" wrapping 
// this).

#include "iexplore.h"
//#include <windows.h>
//#include <ccstock.h>

// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "iexplore"
#define SZ_MODULE           "IEXPLORE"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iecontrols\licmgr\mgr\persist.cxx ===
//+----------------------------------------------------------------------------
//  File:       persist.cxx
//
//  Synopsis:   
//
//-----------------------------------------------------------------------------


// Includes -------------------------------------------------------------------
#include <mgr.hxx>
#include <factory.hxx>
#include "wininet.h"

// Constants ------------------------------------------------------------------
const LARGE_INTEGER LIB_ZERO   = { 0, 0 };
const ULONG BUFFER_SIZE        = 256;
const ULONG CHARS_PER_LINE     = 65;
const WCHAR LPKPATH[]          = L"LPKPath";
const TCHAR SZ_URLMON[]        = _T("URLMON.DLL");
const TCHAR SZ_ISVALIDURL[]    = _T("IsValidURL");
const TCHAR SZ_URLDOWNLOADTOCACHEFILE[] = _T("URLDownloadToCacheFileW");

typedef HRESULT (STDMETHODCALLTYPE *ISVALIDURL)(LPBC, LPCWSTR, DWORD);
typedef HRESULT (STDMETHODCALLTYPE *URLDOWNLOADTOCACHEFILE)(LPUNKNOWN,LPCWSTR,LPWSTR,
                                                            DWORD,DWORD,LPBINDSTATUSCALLBACK);


//+----------------------------------------------------------------------------
//
//  Member:     FindInStream
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CLicenseManager::FindInStream(
    IStream *           pstm,
    BYTE *              pbData,
    ULONG               cbData)
{
    BYTE    bByte;
    ULONG   cbRead;
    ULONG   ibData = 0;
    HRESULT hr;

    Assert(pstm);
    Assert(pbData);
    Assert(cbData);

    // Read through the stream looking for the data
    for (;;)
    {
        // Read a byte of data
        hr = pstm->Read(&bByte, sizeof(BYTE), &cbRead);
        if (hr)
            goto Cleanup;
        if (!cbRead)
            break;

        if (bByte == pbData[ibData])
        {
            ibData++;
            if (ibData >= cbData)
                break;
        }
    }

    // If the data was found, return success
    hr = (ibData == cbData
                ? S_OK
                : E_FAIL);

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetClassID
//
//  Synopsis:   Return the object's CLSID
//
//  Arguments:  pclsid - Location at which to return the object's CLSID
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetClassID(
    CLSID * pclsid)
{
    if (!pclsid)
        return E_INVALIDARG;

    *pclsid = CLSID_LicenseManager;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     IsDirty
//
//  Synopsis:   Return whether the object is dirty or not
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::IsDirty()
{
    return (_fDirty
                ? S_OK
                : S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::Load(
    IStream *   pstm)
{
    CBufferedStream bstm(pstm);
    LARGE_INTEGER   libCur;
    ULARGE_INTEGER  uibSize;
    HRESULT         hr;

    Assert(_fPersistStream || _fPersistPBag);

    if (!pstm)
        return E_INVALIDARG;

    if (_fLoaded)
        return E_UNEXPECTED;

    // Prepare the buffered stream for use
    hr = bstm.SetBufferSize(BUFFER_SIZE);
    if (hr)
        goto Cleanup;

    // Determine the size of the stream
    hr = pstm->Seek(LIB_ZERO, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&libCur);
    if (hr)
        goto Cleanup;
    hr = pstm->Seek(LIB_ZERO, STREAM_SEEK_END, &uibSize);
    if (hr)
        goto Cleanup;
    hr = pstm->Seek(libCur, STREAM_SEEK_SET, NULL);
    if (hr)
        goto Cleanup;

    // Load from the buffered stream
    Assert(!uibSize.HighPart);
    hr = Load(&bstm, uibSize.LowPart);

Cleanup:
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
HRESULT
CLicenseManager::Load(
    IStream *   pstm,
    ULONG       cbSize)
{
    CMemoryStream   mstm;
    ULARGE_INTEGER  uibSize = { cbSize, 0 };
    char *          psz = NULL;
    OLECHAR *       polechar = NULL;
    DWORD           cch;
    DWORD           cchMax = 0;
    DWORD           cLic;
    DWORD           iLic;
    BOOL            fSkipClass;
    HRESULT         hr;

    // Scan for the LPK version identifier and skip over it
    cch = ::lstrlenA(g_pszLPKVersion1);
    hr = FindInStream(pstm, (BYTE *)g_pszLPKVersion1, cch);
    if (hr)
        goto Cleanup;

    // Allocate a memory-based stream to hold the binary data
    hr = mstm.SetSize(uibSize);
    if (hr)
        goto Cleanup;

    // Convert and load the LPK identifier
    hr = DecodeMIME64(pstm, &mstm, NULL);
    if (hr)
        goto Cleanup;
    Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));
    hr = mstm.Read((void *)&_guidLPK, sizeof(_guidLPK), NULL);
    if (hr)
        goto Cleanup;

    // Convert and load the number of CLSID-License pairs
    Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));
    hr = DecodeMIME64(pstm, &mstm, NULL);
    if (hr)
        goto Cleanup;
    Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));
    hr = mstm.Read((void *)&cLic, sizeof(DWORD), NULL);
    if (hr)
        goto Cleanup;
    hr = _aryLic.SetSize((int)cLic);
    if (hr)
        goto Cleanup;
    ::memset((LICENSE *)_aryLic, 0, sizeof(LICENSE)*cLic);

    // Convert the remainder of the stream and from it load each CLSID-License pair
    // (If, somehow, invalid CLSIDs end up in the stream, skip over them during load)
    for (iLic = 0; iLic < cLic; )
    {
        Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));
        hr = DecodeMIME64(pstm, &mstm, NULL);
        if (hr)
            goto Cleanup;
        Verify(SUCCEEDED(mstm.Seek(LIB_ZERO, STREAM_SEEK_SET, NULL)));

        hr = mstm.Read((void *)&(_aryLic[iLic].clsid), sizeof(_aryLic[0].clsid), NULL);
        if (hr)
            goto Cleanup;

        fSkipClass = (_aryLic[iLic].clsid == CLSID_NULL);

        hr = mstm.Read((void *)&cch, sizeof(DWORD), NULL);
        if (hr)
            goto Cleanup;

        if (cch > cchMax)
        {
            delete [] psz;
            delete [] polechar;

            psz      = new char[cch*sizeof(OLECHAR)]; // Review:JulianJ
            polechar = new OLECHAR[cch];
            if (!psz || !polechar)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            cchMax = cch;
        }
        Assert(psz);
        Assert(polechar);

		//
		// REVIEW JulianJ read cch*2 bytes as we persisted entire string
		//
        hr = mstm.Read((void *)psz, cch*sizeof(OLECHAR), NULL);
        if (hr)
            goto Cleanup;

        if (!fSkipClass)
        {
#if 1
			::memcpy(polechar, psz, cch*sizeof(OLECHAR));
#else
#ifndef _PPCMAC
            ::MultiByteToWideChar(CP_ACP, 0, psz, cch, polechar, cch);
#else
            ::memcpy(polechar, psz, cch);
#endif
#endif
            _aryLic[iLic].bstrLic = ::SysAllocStringLen(polechar, cch);
            if (!_aryLic[iLic].bstrLic)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            iLic++;
        }
        else
        {
            cLic--;
        }
    }

    // Ensure the array size is correct (in case any classes were skipped during load)
    if (cLic < (DWORD)_aryLic.Size())
    {
        Verify(SUCCEEDED(_aryLic.SetSize(cLic)));
    }

Cleanup:
    delete [] psz;
    delete [] polechar;
    _fLoaded = TRUE;
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::Save(
    IStream *   pstm,
    BOOL        fClearDirty)
{
    CBufferedStream bstm(pstm, CHARS_PER_LINE, FALSE);
    ULARGE_INTEGER  uibCur;
    TCHAR           szString[MAX_PATH];
    DWORD           cbBuf = 0;
    DWORD           cbLic;
    DWORD           cb;
    BYTE *          pb = NULL;
    BYTE *          pbNext;
    int             iLic;
    HRESULT         hr = S_OK;

    Assert(_fPersistStream);

    if (!pstm)
        return E_INVALIDARG;

    // If this is a new LPK, generate an identifying GUID
    if (_guidLPK == GUID_NULL)
    {
        Assert(!_fLoaded);
        Verify(SUCCEEDED(::CoCreateGuid(&_guidLPK)));
    }

    // Write the text header to the LPK
    for (iLic=IDS_COPYTEXT; iLic <= IDS_COPYTEXT_MAX; iLic++)
    {
        cb = ::LoadString((HINSTANCE)g_hinst, iLic, szString, ARRAY_SIZE(szString));

        hr = pstm->Write(szString, cb, NULL);
        if (hr)
            goto Cleanup;
        hr = pstm->Write(SZ_NEWLINE, CB_NEWLINE, NULL);
        if (hr)
            goto Cleanup;
    }

    // Write the version GUID to the LPK
    hr = pstm->Write(g_pszLPKVersion1, ::lstrlenA(g_pszLPKVersion1), NULL);
    if (hr)
        goto Cleanup;
    hr = pstm->Write(SZ_NEWLINE, CB_NEWLINE, NULL);
    if (hr)
        goto Cleanup;

    // Prepare the buffered stream as the target for encoding
    hr = bstm.SetBufferSize(BUFFER_SIZE);
    if (hr)
        goto Cleanup;
    
    // Write the identifying GUID to the LPK
    hr = EncodeMIME64((BYTE *)&_guidLPK, sizeof(_guidLPK), &bstm, NULL);
    if (hr)
        goto Cleanup;
    hr = bstm.Write(SZ_NEWLINE, CB_NEWLINE, NULL);
    if (hr)
        goto Cleanup;

    // Write the number of CLSID-License pairs to the LPK
    cb = (DWORD)_aryLic.Size();
    hr = EncodeMIME64((BYTE *)&cb, sizeof(cb), &bstm, NULL);
    if (hr)
        goto Cleanup;
    hr = bstm.Write(SZ_NEWLINE, CB_NEWLINE, NULL);
    if (hr)
        goto Cleanup;

    // Write each CLSID-License pair to the LPK
    // (If the array contains empty entries, they are still persisted; this is necessary
    //  because the number of entries persisted must match the count already written)
    for (iLic = 0; iLic < _aryLic.Size(); iLic++)
    {
        // Determine the amount of class data and ensure the buffer is sufficiently large
        cbLic = ::SysStringLen(_aryLic[iLic].bstrLic);
        cb    = sizeof(CLSID) + sizeof(DWORD) + (sizeof(OLECHAR) * cbLic);

        if (cb > cbBuf)
        {
            cbBuf = cb;
            delete [] pb;
            pb = new BYTE[cbBuf];
            if (!pb)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        pbNext = pb;

        // Fill the buffer with the persistent state of the class
        *((CLSID *)pbNext) = _aryLic[iLic].clsid;
        pbNext += sizeof(CLSID);

        *((DWORD *)pbNext) = cbLic;
        pbNext += sizeof(DWORD);

		//
		// REVIEW JulianJ, Weird - we seem to get back a length prefixed ansi string!
		//
#if 1
		memcpy(pbNext, _aryLic[iLic].bstrLic, cbLic * (sizeof(OLECHAR)));
#else
#ifndef _PPCMAC
        ::WideCharToMultiByte(CP_ACP, 0, _aryLic[iLic].bstrLic, cbLic, (LPSTR)pbNext, cbLic, NULL, NULL);
#else
        ::memcpy(pbNext, _aryLic[iLic].bstrLic, cbLic);
#endif
#endif
        // Encode the class to the stream
        hr = EncodeMIME64(pb, cb, &bstm, NULL);
        if (hr)
            goto Cleanup;
        hr = bstm.Write(SZ_NEWLINE, CB_NEWLINE, NULL);
        if (hr)
            goto Cleanup;
    }

    // Flush the buffered stream and mark the end of data
    // (Since not all streams support Seek and SetSize, errors from those methods
    //  are ignored; since the stream contains a count, it can be safely loaded
    //  without truncating unnecessary bytes)
    hr = bstm.Flush();
    if (hr)
        goto Cleanup;
    Verify(SUCCEEDED(pstm->Seek(LIB_ZERO, STREAM_SEEK_CUR, &uibCur)));
    Verify(SUCCEEDED(pstm->SetSize(uibCur)));

Cleanup:
    delete [] pb;
    _fLoaded = TRUE;
    _fDirty  = !fClearDirty && SUCCEEDED(hr);
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetSizeMax
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::GetSizeMax(
    ULARGE_INTEGER *    pcbSize)
{
    if (!pcbSize)
        return E_INVALIDARG;

    pcbSize->LowPart  =
    pcbSize->HighPart = 0;
    return E_NOTIMPL;
}


//+----------------------------------------------------------------------------
//
//  Member:     InitNew
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::InitNew()
{
    if (_fLoaded)
        return E_UNEXPECTED;
    _fLoaded = TRUE;
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     Load
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::Load(
    IPropertyBag *  pPropBag,
    IErrorLog *     pErrorLog)
{
    HMODULE hURLMon = NULL;
    VARIANT var;
    HRESULT hr;

    Assert(_fPersistPBag);

    if (!pPropBag)
        return E_INVALIDARG;

    if (_fLoaded)
        return E_UNEXPECTED;

    ::VariantInit(&var);
    V_VT(&var)   = VT_BSTR;
    V_BSTR(&var) = NULL;

    // Read the path from which to load the LPK file
    hr = pPropBag->Read(LPKPATH, &var, pErrorLog);
    if (!hr)
    {
        CFileStream     fstm;
        FARPROC         fpIsValidURL;
        FARPROC         fpURLDownloadToCacheFileW;
        WCHAR           szCachedFilename[MAX_PATH];

        // Load the URL moniker library
        hURLMon = (HMODULE)::LoadLibrary(SZ_URLMON);
        if (!hURLMon)
        {
            hr = GetWin32Hresult();
            goto Cleanup;
        }

        // Check the path, if it is for an absolute URL, reject it
        // (Only relative URLs are accepted)
        fpIsValidURL = GetProcAddress(hURLMon, SZ_ISVALIDURL);
        if (!fpIsValidURL)
        {
            hr = GetWin32Hresult();
            goto Cleanup;
        }
        hr = (*((ISVALIDURL)fpIsValidURL))(NULL, V_BSTR(&var), 0);
        if (hr == S_OK)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }


        // Download the .LPK to a locally cached file
        fpURLDownloadToCacheFileW = GetProcAddress(hURLMon, SZ_URLDOWNLOADTOCACHEFILE);
        if (!fpURLDownloadToCacheFileW)
        {
            hr = GetWin32Hresult();
            goto Cleanup;
        }

		//
		// Get the service provider from our site
		//
		IServiceProvider * pServiceProvider;
		hr = GetSite(IID_IServiceProvider, (void**)&pServiceProvider);
		if (!SUCCEEDED(hr))
			goto Cleanup;

		//
		// Get an IBindHost from the service provider
		//
		IBindHost *pBindHost;
		hr = pServiceProvider->QueryService( 
			SID_IBindHost, IID_IBindHost, (void**)&pBindHost);
		pServiceProvider->Release();

		if (!SUCCEEDED(hr))
			goto Cleanup;

		//
		// Now create a full moniker
		//
		IMoniker *pMoniker;
		hr = pBindHost->CreateMoniker(V_BSTR(&var), NULL, &pMoniker,0);
		pBindHost->Release();
		
		if (!SUCCEEDED(hr))
			goto Cleanup;

		//
		// Create a bind context
		//
		IBindCtx * pBindCtx;
		hr = CreateBindCtx(0, &pBindCtx);
		if (!SUCCEEDED(hr))
		{
			pMoniker->Release();
			goto Cleanup;
		}

		//
		// Extract display name
		//
		LPOLESTR wszFullLPKPath;
		hr = pMoniker->GetDisplayName(pBindCtx, NULL, &wszFullLPKPath);
		pMoniker->Release();
		pBindCtx->Release();

		if (!SUCCEEDED(hr))
			goto Cleanup;

        hr = (*((URLDOWNLOADTOCACHEFILE)fpURLDownloadToCacheFileW))(
				_pUnkOuter,
				wszFullLPKPath,
				szCachedFilename,
				URLOSTRM_GETNEWESTVERSION,
				0, NULL);

		CoTaskMemFree(wszFullLPKPath);

        if (hr)
            goto Cleanup;

        // Open a stream on the file and load from the stream
        hr = fstm.Init(szCachedFilename, GENERIC_READ);
        if (!hr)
        {
            CBufferedStream mstm(&fstm);
            ULONG           cbSize;

            hr = mstm.SetBufferSize(BUFFER_SIZE);
            if (hr)
                goto Cleanup;

            Verify(SUCCEEDED(fstm.GetFileSize(&cbSize)));
            hr = Load(&mstm, cbSize);
        }
    }

Cleanup:
    _fLoaded = TRUE;
    ::VariantClear(&var);
    if (hURLMon)
    {
        ::FreeLibrary(hURLMon);
    }
    return hr;
}


//+----------------------------------------------------------------------------
//
//  Member:     Save
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CLicenseManager::Save(
    IPropertyBag *  pPropBag,
    BOOL            fClearDirty,
    BOOL            fSaveAllProperties)
{
    UNREF(pPropBag);
    UNREF(fClearDirty);
    UNREF(fSaveAllProperties);
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iexplore\iexplore.h ===
#undef  STRICT
#define STRICT
#define _INC_OLE        // REVIEW: don't include ole.h in windows.h

#define OEMRESOURCE

// For dllload: change function prototypes to not specify declspec import
#define _SHDOCVW_      

#include <windows.h>

#include <stddef.h>

#include <commctrl.h>
#include <windowsx.h>
#include <ole2.h>
#include <shlobj.h>     // Includes <fcext.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <regstr.h>     // for REGSTR_PATH_EXPLORE

#ifdef UNICODE
#define CP_WINNATURAL   CP_WINUNICODE
#else
#define CP_WINNATURAL   CP_WINANSI
#endif

#include <ccstock.h>
#include <crtfree.h>
#include <port32.h>
// #include <heapaloc.h>
#include <debug.h>      // our version of Assert etc.
#include <shellp.h>
#include <wininet.h>
#include <shdocvw.h>


// Debug and trace message values
#define DF_DELAYLOADDLL         0x00000001
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iexplore\rcids.h ===
//---------------------------------------------------------------------------
// Defines for the rc file.
//---------------------------------------------------------------------------

//
// IE 2.0 icon ids
//
// NOTE for IE 2.0 compatibilty these icons MUST be in this order
//
#define RES_ICO_FRAME           32528
#define RES_ICO_HTML            32529
#define RES_ICO_EXTRA_1         32530
#define RES_ICO_EXTRA_2         32531
#define RES_ICO_EXTRA_3         32532
#define RES_ICO_EXTRA_4         32533
#define IDI_APPEARANCE          32534
#define IDI_ADVANCED            32535
#undef IDI_HOMEPAGE
#define IDI_HOMEPAGE            32536
#define IDI_GOTOURL             32537
#define IDI_FINDTEXT            32538
#define IDI_UNKNOWN_FILETYPE    32539
#define RES_ICO_JPEG            32540
#define RES_ICO_GIF             32541
#define IDI_INTERNET            32542
#define RES_ICON_FOLDER_OPEN    32543
#define RES_ICON_FOLDER_CLOSED  32544
#define RES_ICON_URL_FILE       32545
#define IDI_SECURITY            32546
#define RES_ICO_NOICON          32547
#define RES_ICO_FINDING         32548
#define RES_ICO_CONNECTING      32549
#define RES_ICO_ACCESSING       32550
#define RES_ICO_RECEIVING       32551
#define IDI_NEWS                32552
#define IDI_VRML                32553
#define IDI_MHTMLFILE           32554


// String IDS which are actually used:
#define IDS_COMPATMODEWARNING        700
#define IDS_COMPATMODEWARNINGTITLE   701
#define IDS_INTERNETEXPLORER         702


// Commmand ID
#define FCIDM_FIRST             FCIDM_GLOBALFIRST
#define FCIDM_LAST              FCIDM_BROWSERLAST

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_FILE      (FCIDM_BROWSERFIRST+0x0020)
#define FCIDM_FILECLOSE         (FCIDM_BROWSER_FILE+0x0001)
#define FCIDM_PREVIOUSFOLDER    (FCIDM_BROWSER_FILE+0x0002)
#define FCIDM_ENTER		(FCIDM_BROWSER_FILE+0x0003)

// these aren't real menu commands, but they map to accelerators or other things
#define FCIDM_NEXTCTL           (FCIDM_BROWSER_FILE+0x0010)
#define FCIDM_DROPDRIVLIST      (FCIDM_BROWSER_FILE+0x0011)

//---------------------------------------------------------------------------
#define FCIDM_VIEWTOOLBAR     (FCIDM_BROWSERFIRST + 0x0010)
#define FCIDM_VIEWSTATUSBAR   (FCIDM_BROWSERFIRST + 0x0011)
#define FCIDM_VIEWOPTIONS     (FCIDM_BROWSERFIRST + 0x0012)

//---------------------------------------------------------------------------
#define FCIDM_BROWSER_HELP      (FCIDM_BROWSERFIRST+0x0100)

#define FCIDM_HELPSEARCH        (FCIDM_BROWSER_HELP+0x0001)
#define FCIDM_HELPABOUT         (FCIDM_BROWSER_HELP+0x0002)

//----------------------------------------------------------------
#define FCIDM_BROWSER_EXPLORE   (FCIDM_BROWSERFIRST + 0x0110)
#define FCIDM_NAVIGATEBACK      (FCIDM_BROWSER_EXPLORE+0x0001)
#define FCIDM_NAVIGATEFORWARD   (FCIDM_BROWSER_EXPLORE+0x0002)
#define FCIDM_BROWSEROPTIONS    (FCIDM_BROWSER_EXPLORE+0x0003)
#define FCIDM_RECENTMENU        (FCIDM_BROWSER_EXPLORE+0x0010)
#define FCIDM_RECENTFIRST       (FCIDM_BROWSER_EXPLORE+0x0011)
#define FCIDM_RECENTLAST        (FCIDM_BROWSER_EXPLORE+0x0050)
#define FCIDM_FAVORITES         (FCIDM_BROWSER_EXPLORE+0x0052)
#define FCIDM_ADDTOFAVORITES    (FCIDM_BROWSER_EXPLORE+0x0053)
#define FCIDM_FAVORITEFIRST     (FCIDM_BROWSER_EXPLORE+0x0055)
#define FCIDM_FAVORITELAST      (FCIDM_BROWSER_EXPLORE+0x0100)
#define FCIDM_FAVORITE_ITEM     (FCIDM_FAVORITEFIRST + 0)
#define FCIDM_FAVORITECMDFIRST  (FCIDM_FAVORITES)
#define FCIDM_FAVORITECMDLAST   (FCIDM_FAVORITELAST)

#define MH_POPUPS	700
#define MH_ITEMS	(800-FCIDM_FIRST)
#define MH_TTBASE               (MH_ITEMS - (FCIDM_LAST - FCIDM_FIRST))
#define IDS_TT_PREVIOUSFOLDER   (MH_TTBASE+FCIDM_PREVIOUSFOLDER)
#define IDS_TT_NAVIGATEBACK             (MH_TTBASE + FCIDM_NAVIGATEBACK)
#define IDS_TT_NAVIGATEFORWARD          (MH_TTBASE + FCIDM_NAVIGATEFORWARD)
#define IDS_TT_FAVORITES             (MH_TTBASE + FCIDM_FAVORITES)
#define IDS_TT_ADDTOFAVORITES          (MH_TTBASE + FCIDM_ADDTOFAVORITES)

// Define string ids that go into resource file
#define IDS_MH_DRIVELIST        (MH_ITEMS+FCIDM_DRIVELIST)
#define IDS_MH_MENU_FILE        (MH_ITEMS+FCIDM_MENU_FILE)
#define IDS_MH_MENU_EXPLORE     (MH_ITEMS+FCIDM_MENU_EXPLORE)
#define IDS_MH_MENU_HELP        (MH_ITEMS+FCIDM_MENU_HELP)
#define IDS_MH_FILECLOSE        (MH_ITEMS+FCIDM_FILECLOSE)
#define IDS_MH_PREVIOUSFOLDER   (MH_ITEMS+FCIDM_PREVIOUSFOLDER)
#define IDS_MH_HELPSEARCH       (MH_ITEMS+FCIDM_HELPSEARCH)
#define IDS_MH_HELPABOUT        (MH_ITEMS+FCIDM_HELPABOUT)
#define IDS_MH_NAVIGATEBACK	(MH_ITEMS+FCIDM_NAVIGATEBACK)
#define IDS_MH_NAVIGATEBACK     (MH_ITEMS+FCIDM_NAVIGATEBACK)
#define IDS_MH_NAVIGATEFORWARD  (MH_ITEMS+FCIDM_NAVIGATEFORWARD)
#define IDS_MH_RECENTMENU       (MH_ITEMS+FCIDM_RECENTMENU)
#define IDS_MH_MENU_FAVORITES   (MH_ITEMS+FCIDM_MENU_FAVORITES)
#define IDS_MH_FAVORITES        (MH_ITEMS+FCIDM_FAVORITES)
#define IDS_MH_ADDTOFAVORITES   (MH_ITEMS+FCIDM_ADDTOFAVORITES)

#define IDS_NAVIGATEBACKTO  720
#define IDS_NAVIGATEFORWARDTO 721

#define IDS_OPTIONS	722
#define IDS_TITLE	723
#define IDS_ERROR_GOTO	724

#define IDS_NONE        725
#define IDS_NAME        726     // Used for NAME member function for fram programmability

// Accelerator ID
#define ACCEL_MERGE	0x100

// Menu ID
#define MENU_TEMPLATE	0x100
#define MENU_FAVORITES  0x101
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iexplore\mainloop.cpp ===
#include "iexplore.h"
#include "rcids.h"
#include "shlwapi.h"
#include "msodw.h"

#include <platform.h>

#ifdef UNIX
#include "unixstuff.h"
#endif

static const TCHAR c_szBrowseNewProcessReg[] = REGSTR_PATH_EXPLORER TEXT("\\BrowseNewProcess");
static const TCHAR c_szBrowseNewProcess[] = TEXT("BrowseNewProcess");

int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow);


STDAPI_(int) ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
#ifdef UNICODE
    LPTSTR pszCmdLine = GetCommandLine();
#else
    // for multibyte should make it unsigned
    BYTE * pszCmdLine = (BYTE *)GetCommandLine();
#endif


#if defined(UNIX) 
    // IEUNIX: On solaris we are getting out of file handles with new code pages added to mlang
    // causing more nls files to be mmapped.
    INCREASE_FILEHANDLE_LIMIT;
#endif

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if(StopWatchMode() & SPMODE_BROWSER)  // Used to get the start of browser total download time
    {
        StopWatch_Start(SWID_BROWSER_FRAME, TEXT("Browser Frame Start"), SPMODE_BROWSER | SPMODE_DEBUGOUT);
    }
    
    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    si.cb = sizeof(si);

    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, (LPTSTR)pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

#ifndef UNIX  
    ExitThread(i);  // We only come here when we are not the shell...
#else
// there seem to be some desirable side effect calling ExitThread on Windows
    ExitProcess(i); 
#endif
    return i;
}

//
// Create a unique event name
//
HANDLE AppendEvent(COPYDATASTRUCT *pcds)
{
    static DWORD dwNextID = 0;
    TCHAR szEvent[MAX_IEEVENTNAME];

    wsprintf(szEvent, "IE-%08X-%08X", GetCurrentThreadId(), dwNextID++);
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, szEvent);
    if (hEvent)
    {
        //
        // Put the (UNICODE) event name at the end of the cds data
        //
        LPWSTR pwszBufferEvent = (LPWSTR)(((BYTE *)pcds->lpData) + pcds->cbData);
#ifdef UNICODE
        lstrcpy(pwszBufferEvent, szEvent);
#else
        MultiByteToWideChar(CP_ACP, 0, szEvent, -1, pwszBufferEvent, ARRAYSIZE(szEvent));
#endif
        pcds->cbData += (lstrlenW(pwszBufferEvent) + 1) * sizeof(WCHAR);
    }

    return hEvent;
}

BOOL IsCommandSwitch(LPTSTR lpszCmdLine, LPTSTR pszSwitch, BOOL fRemoveSwitch)
{
    LPTSTR lpsz;
    
    if ((lpsz=StrStrI(lpszCmdLine, pszSwitch)) && (lpsz == lpszCmdLine))
    {
        int cch = lstrlen(pszSwitch);

        if (*(lpsz+cch) == 0 || *(lpsz+cch) == TEXT(' '))
        {
            while (*(lpsz+cch) == TEXT(' '))
                cch++;

            if (fRemoveSwitch)
            {
                // Remove the switch by copying everything up.
                *lpsz=0;
                lstrcat(lpsz, lpsz+cch);
            }
            return TRUE;
        }
    } 
    return FALSE;
}

BOOL CheckForNeedingAppCompatWindow(void)
{
    // Which I could simply get the Process of who spawned me.  For now
    // try hack to get the foreground window and go from there...
    TCHAR szClassName[80];
    HWND hwnd = GetForegroundWindow();

    if (hwnd && GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName)) > 0)
    {
        if (lstrcmpi(szClassName, TEXT("MauiFrame")) == 0)
            return TRUE;
    }
    return FALSE;
}

//
// AppCompat - Sequel NetPIM execs a browser and then waits forever
// looking for a visible top level window owned by this process.
//
HWND CreateAppCompatWindow(HINSTANCE hinst)
{
    HWND hwnd;
    static const TCHAR c_szClass[] = TEXT("IEDummyFrame");  // IE3 used "IEFrame"

    WNDCLASS wc = { 0, DefWindowProc, 0, 0, hinst, NULL, NULL, NULL, NULL, c_szClass };
    RegisterClass(&wc);

    // Netmanage ECCO Pro asks to get the menu...
    HMENU hmenu = CreateMenu();
    hwnd = CreateWindowEx(WS_EX_TOOLWINDOW, c_szClass, TEXT(""), 0,
                          0x00007FF0, 0x00007FF0, 0, 0,
                          NULL, hmenu, hinst, NULL);
    // Don't open SHOWDEFAULT or this turkey could end up maximized
    ShowWindow(hwnd, SW_SHOWNA);

    return hwnd;
}

#define USERAGENT_POST_PLATFORM_PATH_TO_KEY    TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\User Agent\\Post Platform")
void SetCompatModeUserAgentString(void)
{
    HKEY hkey;
    const char szcompat[]=TEXT("compat");
    
    if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER, USERAGENT_POST_PLATFORM_PATH_TO_KEY, &hkey))
    {
        RegSetValueEx( hkey,
                       szcompat,
                       0,
                       REG_BINARY,
                       (LPBYTE)NULL, 0);
        RegCloseKey(hkey);
    }
    
}

// Tell the user they are running in compat mode and not all the features will be available.
#define IECOMPAT_REG_VAL    TEXT("CompatWarningFor")

void WarnCompatMode(HINSTANCE hinst)
{
    TCHAR szFqFilename[MAX_PATH];
    TCHAR szRegVal[MAX_PATH];
    TCHAR szTitle[255];
    TCHAR szMsg[1024];
    LPTSTR szFile;

    GetModuleFileName(NULL, szFqFilename, ARRAYSIZE(szFqFilename));
    szFile = PathFindFileName(szFqFilename);
    

    // Build up string "compatmodewarningfor <exe name>" as value for reg key
    lstrcpy(szRegVal, IECOMPAT_REG_VAL);
    lstrcat(szRegVal, szFile);

    LoadString(hinst, IDS_COMPATMODEWARNINGTITLE, szTitle, ARRAYSIZE(szTitle));
    LoadString(hinst, IDS_COMPATMODEWARNING, szMsg, ARRAYSIZE(szMsg));

    SHMessageBoxCheck(NULL, szMsg, szTitle, MB_OK, FALSE, szRegVal);
}

#ifdef WINNT

// this is the same code that is in explorer.exe (initcab.c)
#define RSA_PATH_TO_KEY    TEXT("Software\\Microsoft\\Cryptography\\Defaults\\Provider\\Microsoft Base Cryptographic Provider v1.0")
#define CSD_REG_PATH       TEXT("System\\CurrentControlSet\\Control\\Windows")
#define CSD_REG_VALUE      TEXT("CSDVersion")


// the signatures we are looking for in the regsitry so that we can patch up 

#ifdef _M_IX86
static  BYTE  SP3Sig[] = {0xbd, 0x9f, 0x13, 0xc5, 0x92, 0x12, 0x2b, 0x72,
                          0x4a, 0xba, 0xb6, 0x2a, 0xf9, 0xfc, 0x54, 0x46,
                          0x6f, 0xa1, 0xb4, 0xbb, 0x43, 0xa8, 0xfe, 0xf8,
                          0xa8, 0x23, 0x7d, 0xd1, 0x85, 0x84, 0x22, 0x6e,
                          0xb4, 0x58, 0x00, 0x3e, 0x0b, 0x19, 0x83, 0x88,
                          0x6a, 0x8d, 0x64, 0x02, 0xdf, 0x5f, 0x65, 0x7e,
                          0x3b, 0x4d, 0xd4, 0x10, 0x44, 0xb9, 0x46, 0x34,
                          0xf3, 0x40, 0xf4, 0xbc, 0x9f, 0x4b, 0x82, 0x1e,
                          0xcc, 0xa7, 0xd0, 0x2d, 0x22, 0xd7, 0xb1, 0xf0,
                          0x2e, 0xcd, 0x0e, 0x21, 0x52, 0xbc, 0x3e, 0x81,
                          0xb1, 0x1a, 0x86, 0x52, 0x4d, 0x3f, 0xfb, 0xa2,
                          0x9d, 0xae, 0xc6, 0x3d, 0xaa, 0x13, 0x4d, 0x18,
                          0x7c, 0xd2, 0x28, 0xce, 0x72, 0xb1, 0x26, 0x3f,
                          0xba, 0xf8, 0xa6, 0x4b, 0x01, 0xb9, 0xa4, 0x5c,
                          0x43, 0x68, 0xd3, 0x46, 0x81, 0x00, 0x7f, 0x6a,
                          0xd7, 0xd1, 0x69, 0x51, 0x47, 0x25, 0x14, 0x40,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#else // other than _M_IX86
static  BYTE  SP3Sig[] = {0x8a, 0x06, 0x01, 0x6d, 0xc2, 0xb5, 0xa2, 0x66,
                          0x12, 0x1b, 0x9c, 0xe4, 0x58, 0xb1, 0xf8, 0x7d,
                          0xad, 0x17, 0xc1, 0xf9, 0x3f, 0x87, 0xe3, 0x9c,
                          0xdd, 0xeb, 0xcc, 0xa8, 0x6b, 0x62, 0xd0, 0x72,
                          0xe7, 0xf2, 0xec, 0xd6, 0xd6, 0x36, 0xab, 0x2d,
                          0x28, 0xea, 0x74, 0x07, 0x0e, 0x6c, 0x6d, 0xe1,
                          0xf8, 0x17, 0x97, 0x13, 0x8d, 0xb1, 0x8b, 0x0b,
                          0x33, 0x97, 0xc5, 0x46, 0x66, 0x96, 0xb4, 0xf7,
                          0x03, 0xc5, 0x03, 0x98, 0xf7, 0x91, 0xae, 0x9d,
                          0x00, 0x1a, 0xc6, 0x86, 0x30, 0x5c, 0xc8, 0xc7,
                          0x05, 0x47, 0xed, 0x2d, 0xc2, 0x0b, 0x61, 0x4b,
                          0xce, 0xe5, 0xb7, 0xd7, 0x27, 0x0c, 0x9e, 0x2f,
                          0xc5, 0x25, 0xe3, 0x81, 0x13, 0x9d, 0xa2, 0x67,
                          0xb2, 0x26, 0xfc, 0x99, 0x9d, 0xce, 0x0e, 0xaf,
                          0x30, 0xf3, 0x30, 0xec, 0xa3, 0x0a, 0xfe, 0x16,
                          0xb6, 0xda, 0x16, 0x90, 0x9a, 0x9a, 0x74, 0x7a,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
#endif      // _M_IX86

void CheckForSP3RSAOverwrite( void )
{
    // check for them having installed NTSP3 over the top of IE4, it nukes
    // the RSABASE reg stuff, so we have to re-do it. (our default platform is NT + SP3, but this
    // problem doesn't occur on NT5, so ignore it.

    OSVERSIONINFO osVer;

    ZeroMemory(&osVer, sizeof(osVer));
    osVer.dwOSVersionInfoSize = sizeof(osVer);

    if( GetVersionEx(&osVer) && (osVer.dwPlatformId == VER_PLATFORM_WIN32_NT) 
        && (osVer.dwMajorVersion == 4))
    {
        // now check to see we are on SP3 ...
        DWORD dwValue = 0;
        DWORD dwSize = sizeof( dwValue );
        
        if ( ERROR_SUCCESS == SHGetValue( HKEY_LOCAL_MACHINE, CSD_REG_PATH, CSD_REG_VALUE, NULL,
             &dwValue, &dwSize) && LOWORD( dwValue ) == 0x300 )
        {
            BYTE rgbSig[136];
            dwSize = sizeof(rgbSig);
            
            if (ERROR_SUCCESS == SHGetValue ( HKEY_LOCAL_MACHINE, RSA_PATH_TO_KEY, TEXT("Signature"), NULL,
                rgbSig, &dwSize))
            {
                if ((dwSize == sizeof(SP3Sig)) && 
                    (0 == memcmp(SP3Sig, rgbSig, sizeof(SP3Sig))))
                {
                    // need to do a DLLRegisterServer on RSABase
                    HINSTANCE hInst = LoadLibrary(TEXT("rsabase.dll"));
                    if ( hInst )
                    {
                        FARPROC pfnDllReg = GetProcAddress( hInst, "DllRegisterServer");
                        if ( pfnDllReg )
                        {
                            __try
                            {
                                pfnDllReg();
                            }
                            __except( EXCEPTION_EXECUTE_HANDLER)
                            {
                            }
                            __endexcept
                        }

                        FreeLibrary( hInst );
                    }
                }
            }
        }           
    }
}
#else
#define CheckForSP3RSAOverwrite() 
#endif


#define TEN_SECONDS (10 * 1000)

LONG WINAPI DwExceptionFilter(LPEXCEPTION_POINTERS pep)
{
    EXCEPTION_RECORD         *per;
    HANDLE                    hFileMap = NULL;
    DWSharedMem              *pdwsm = NULL;
    SECURITY_ATTRIBUTES       sa;
    LONG                      lReturn = 0;
    
    // we keep local copies of these in case another thread is trashing memory
    // it much more likely to trash the heap than our stack
    HANDLE                    hEventDone = NULL;          // event DW signals when done
    HANDLE                    hEventAlive = NULL;         // heartbeat event DW signals per EVENT_TIMEOUT
    HANDLE                    hMutex = NULL;              // to protect the signaling of EventDone  
    
    CHAR                      szCommandLine[MAX_PATH * 2];

    DWORD                     dwSize, dwType, dw;
    TCHAR                     tchURL[INTERNET_MAX_URL_LENGTH];
    
    BOOL                      fDwRunning;  
    
    STARTUPINFOA              si;
    PROCESS_INFORMATION       pi;
    
    // init
    if (pep)
    {
        per = pep->ExceptionRecord;
        if (EXCEPTION_BREAKPOINT == per->ExceptionCode)
            goto Cleanup;
    }

    // create shared memory
    memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
    sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    sa.bInheritHandle = TRUE;
    
    hFileMap = CreateFileMapping(INVALID_HANDLE_VALUE, &sa, PAGE_READWRITE, 0, 
                      sizeof(DWSharedMem), NULL);
    if (hFileMap == NULL)
    {
        lReturn = 1;
        goto Cleanup;
    }
        
    pdwsm = (DWSharedMem *) MapViewOfFile(hFileMap, 
                                          FILE_MAP_READ | FILE_MAP_WRITE,
                                          0, 0, 0);
    if (pdwsm == NULL)
    {
        lReturn = 1;
        goto Cleanup;
    }

    memset(pdwsm, 0, sizeof(DWSharedMem));

    hEventAlive = CreateEvent(&sa, FALSE, FALSE, NULL);
    hEventDone = CreateEvent(&sa, FALSE, FALSE, NULL);
    hMutex = CreateMutex(&sa, FALSE, NULL);

    if (!DuplicateHandle(GetCurrentProcess(), GetCurrentProcess(), 
                    GetCurrentProcess(), &pdwsm->hProc, PROCESS_ALL_ACCESS,
                    TRUE, 0))
    {
        lReturn = 1;
        goto Cleanup;
    }

    if (hEventAlive == NULL || hEventDone == NULL || hMutex == NULL
        || pdwsm->hProc == NULL)
    {
        lReturn = 1;
        goto Cleanup;
    }

    // setup interface structure
    pdwsm->pid = GetCurrentProcessId();
    pdwsm->tid = GetCurrentThreadId();
    pdwsm->hEventAlive = hEventAlive;
    pdwsm->hEventDone = hEventDone;
    pdwsm->hMutex = hMutex;
    pdwsm->dwSize = sizeof(DWSharedMem);
    pdwsm->pep = pep;
    if (pep)
        pdwsm->eip = (DWORD_PTR) pep->ExceptionRecord->ExceptionAddress;
    pdwsm->bfmsoctdsOffer = MSODWRESTARTQUIT;
    pdwsm->lcidUI = MLGetUILanguage();

    StrCpyNW(pdwsm->wzFormalAppName, L"Microsoft Internet Explorer", DW_APPNAME_LENGTH);

    StrCpyN(pdwsm->szRegSubPath, "Microsoft\\Office\\10.0\\Common", DW_MAX_REGSUBPATH);
    
    // Our language key?
    StrCpyN(pdwsm->szLCIDKeyValue, 
           "HKCU\\Software\\Microsoft\\Office\\10.0\\Common\\LanguageResources\\UILanguage", DW_MAX_PATH);

    // Hey, they're pointing to our PID!  That's cool.
    StrCpyN(pdwsm->szPIDRegKey, 
           "HKLM\\Software\\Microsoft\\Internet Explorer\\Registration\\DigitalProductID", DW_MAX_PATH);

    // Okay, I'll send it there.
    //
    dwSize = INTERNET_MAX_URL_LENGTH;

    if (ERROR_SUCCESS == SHGetValueA(HKEY_LOCAL_MACHINE,
                                     "Software\\Microsoft\\Internet Explorer\\Main",
                                     "IEWatsonURL",
                                     &dwType, tchURL, &dwSize))
    {
        StrCpyN(pdwsm->szServer, tchURL, DW_MAX_SERVERNAME);
    }
    else
    {
        StrCpyN(pdwsm->szServer, "watson.microsoft.com", DW_MAX_SERVERNAME);
    }

    // Do not set details string.
    //StrCpyNW(pdwsm->wzErrorMessage, L"Internet Explorer has encountered an internal error.", DW_MAX_ERROR_CWC);

    // Core modules
    StrCpyNW(pdwsm->wzDotDataDlls, L"browseui.dll\0shdocvw.dll\0mshtml.dll\0urlmon.dll\0wininet.dll\0", DW_MAX_PATH);

    // This will usually be "IEXPLORE.EXE"
    GetModuleFileNameWrapW(NULL, pdwsm->wzModuleFileName, DW_MAX_PATH);

    // ok, now we don't want to accidently change this
        
    memset(&si, 0, sizeof(STARTUPINFOA));
    si.cb = sizeof(STARTUPINFOA);
    memset(&pi, 0, sizeof(PROCESS_INFORMATION));
    
    wnsprintfA(szCommandLine, sizeof(szCommandLine),
              "dw15 -x -s %u", 
              (DWORD_PTR) hFileMap); 

    if (CreateProcessA(NULL, szCommandLine, NULL, NULL, TRUE, 
                  CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS, NULL,
                  NULL, &si, &pi))
    {
        fDwRunning = TRUE;
        while (fDwRunning)
        {
            if (WaitForSingleObject(hEventAlive, DW_TIMEOUT_VALUE) 
                == WAIT_OBJECT_0)
            {
                if (WaitForSingleObject(hEventDone, 1) == WAIT_OBJECT_0)
                {
                    fDwRunning = FALSE;
                }
                continue;
            }
                
             // we timed-out waiting for DW to respond, try to quit
            dw = WaitForSingleObject(hMutex, DW_TIMEOUT_VALUE);
            if (dw == WAIT_TIMEOUT)
                fDwRunning = FALSE; // either DW's hung or crashed, we must carry on  
            else if (dw == WAIT_ABANDONED)
            {
                fDwRunning = FALSE;
                ReleaseMutex(hMutex);
            }
            else
            {
                // DW has not woken up?
                if (WaitForSingleObject(hEventAlive, 1) != WAIT_OBJECT_0)
                    // tell DW we're through waiting for it's sorry self
                {
                    SetEvent(hEventDone);
                    fDwRunning = FALSE;
                }
                else
                {
                    // are we done
                    if (WaitForSingleObject(hEventDone, 1) 
                        == WAIT_OBJECT_0)
                        fDwRunning = FALSE;
                }
                ReleaseMutex(hMutex);
            }
        }

    } // end if CreateProcess succeeded
    
    
Cleanup:
    if (hEventAlive)
        CloseHandle(hEventAlive);
    if (hEventDone)
        CloseHandle(hEventDone);
    if (hMutex)
        CloseHandle(hMutex);
    if (pdwsm)
        UnmapViewOfFile(pdwsm);
    if (hFileMap)
        CloseHandle(hFileMap);

    return lReturn;
}

//---------------------------------------------------------------------------
int WinMainT(HINSTANCE hinst, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
#ifdef DEBUG
    CcshellGetDebugFlags();
#endif
    int  iRet = TRUE;
    HWND hwndDesktop ;
    BOOL fNowait = FALSE;
    BOOL fInproc = FALSE;
    BOOL fEval   = FALSE;
#ifdef UNIX
    BOOL fRemote = FALSE;
#endif


    // DwExceptionFilter(NULL);  For testing.

    while (1) {
#ifdef UNIX
        if (IsCommandSwitch(lpszCmdLine, TEXT("-remote"), TRUE))
        {
            fRemote = TRUE;
        }
#endif
        if (IsCommandSwitch(lpszCmdLine, TEXT("-eval"), TRUE))
        {
            fInproc = TRUE;
            fEval   = TRUE;
        } else if (IsCommandSwitch(lpszCmdLine, TEXT("-new"), TRUE))
        {
            fInproc = TRUE;
        }
        else if (IsCommandSwitch(lpszCmdLine, TEXT("-nowait"), TRUE)) 
        {
            fNowait = TRUE;
        } 
        else
            break;
    }

#ifndef UNIX
    if (!GetModuleHandle(TEXT("IEXPLORE.EXE")))
    {
        // For side by side install auto dection, if IExplore.exe is renamed, assume this is a side by side do dah
        // and we want to run in "evaluation" mode.
        fInproc = TRUE;
        fEval   = TRUE;        
    }
#endif

    
    // Should we run browser in a new process?
    if (fInproc || SHRegGetBoolUSValue(c_szBrowseNewProcessReg, c_szBrowseNewProcess, FALSE, FALSE))
    {
        goto InThisProcess;
    }

#ifdef UNIX
    if (!(fRemote && ConnectRemoteIE(lpszCmdLine, hinst)))
#endif
    
    if (WhichPlatform() == PLATFORM_INTEGRATED && (hwndDesktop = GetShellWindow()))
    {
        //
        // Integrated browser mode - package up a bunch of data into a COPYDATASTRUCT,
        // and send it to the desktop window via SendMessage(WM_COPYDATA).
        //
        COPYDATASTRUCT cds;
        cds.dwData = nCmdShow;

        //
        // First piece of data is a wide string version of the command line params.
        //
        LPWSTR pwszBuffer = (LPWSTR)LocalAlloc(LPTR, (INTERNET_MAX_URL_LENGTH + 2 * MAX_IEEVENTNAME) * sizeof(WCHAR));;
        if (pwszBuffer)
        {
#ifdef UNICODE
            lstrcpy(pwszBuffer, lpszCmdLine);
#else
            int cch = MultiByteToWideChar(CP_ACP, 0, lpszCmdLine, -1, pwszBuffer, INTERNET_MAX_URL_LENGTH);
            Assert(cch);
#endif
            cds.lpData = pwszBuffer;
            cds.cbData = sizeof(WCHAR) * (lstrlenW((LPCWSTR)cds.lpData) + 1);

            //
            // Second piece of data is the event to fire when
            // the browser window reaches WM_CREATE.
            //
            HANDLE hEventReady = AppendEvent(&cds);
            if (hEventReady)
            {
                //
                // Third piece of data is the event to fire when
                // the browser window closes.  This is optional,
                // we only create it (and wait for it) when there
                // are command line parameters.
                //
                HANDLE hEventDead = NULL;

                // The hard part is to figure out when we need the command line and when
                // we don't. For the most part if there is a command line we will assume that
                // we will need it (potentially) we could look for the -nowait flag.  But then
                // there are others like NetManage ECCO Pro who do their equiv of ShellExecute
                // who don't pass a command line...

                if ((*lpszCmdLine || CheckForNeedingAppCompatWindow()) && !fNowait)
                {
                    hEventDead = AppendEvent(&cds);
                }
                
                if (hEventDead || !*lpszCmdLine || fNowait)
                {
                    //
                    // Send that message!
                    //
                    int iRet = (int)SendMessage(hwndDesktop, WM_COPYDATA, (WPARAM)hwndDesktop, (LPARAM)&cds);

                    //
                    // Nobody needs the string anymore.
                    //
                    LocalFree(pwszBuffer);
                    pwszBuffer = NULL;

                    if (iRet)
                    {
                        //
                        // First, we wait for the browser window to hit WM_CREATE.
                        // When this happens, all DDE servers will have been registered.
                        //
                        DWORD dwRet = WaitForSingleObject(hEventReady, TEN_SECONDS);
                        ASSERT(dwRet == WAIT_OBJECT_0);

                        if (hEventDead)
                        {
                            //
                            // Create an offscreen IE-lookalike window
                            // owned by this process for app compat reasons.
                            //
                            HWND hwnd = CreateAppCompatWindow(hinst);

                            do
                            {
                                //
                                // Calling MsgWait... will cause any threads blocked
                                // on WaitForInputIdle(IEXPLORE) to resume execution.
                                // This is fine because the browser has already
                                // registered its DDE servers by now.
                                //
                                dwRet = MsgWaitForMultipleObjects(1, &hEventDead, FALSE, INFINITE, QS_ALLINPUT);

                                if (dwRet == WAIT_OBJECT_0)
                                {
                                    //
                                    // Kill our helper window cleanly too.
                                    //
                                    DestroyWindow(hwnd);
                                }

                                MSG msg;
                                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                                {
                                    if (msg.message == WM_QUIT)
                                    {
                                        //
                                        // We got a quit message, drop out.
                                        //
                                        dwRet = WAIT_OBJECT_0;
                                        break;
                                    }

                                    TranslateMessage(&msg);
                                    DispatchMessage(&msg);
                                }
                            }
                            while(dwRet != WAIT_OBJECT_0);
                        }
                    }

                    iRet = !iRet;
                }
                if (hEventDead)
                {
                    CloseHandle(hEventDead);
                }

                CloseHandle(hEventReady);
            }
        }
        if (pwszBuffer)
        {
            LocalFree(pwszBuffer);
            pwszBuffer = NULL;
        }
    }        
    else
    {

InThisProcess:
        // Browser only mode, check the SP3 bug
        CheckForSP3RSAOverwrite();

        if (fEval)
        {
            // Set "compat" mode user agent
            WarnCompatMode(hinst);

            // #75454... let the compat mode setup set useragent in HKLM.
            //SetCompatModeUserAgentString();
            
            // Run in eval mode. So we want everything from this dir.
            LoadLibrary("comctl32.DLL");
            LoadLibrary("browseui.DLL");            
            LoadLibrary("shdocvw.DLL");
            LoadLibrary("wininet.dll");
            LoadLibrary("urlmon.dll");
            LoadLibrary("mlang.dll");
            LoadLibrary("mshtml.dll");
            LoadLibrary("jscript.DLL");            
        }

        // On downlevel (non-Whistler), we set up a top-level exception filter so that we can report faults
        // using the Watson technology.
        //
        // In Whistler, this support is built in to the Kernel so we don't run this code.
        //
        if (!IsOS(OS_WHISTLERORGREATER))
        {

            DWORD  dw, dwSize, dwType;

            // As a policy check, look at HKLM before HKCU
            //
        
            dw = 1;  // Default to enabled.
            dwSize = sizeof(dw);

            if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE,
                                             "Software\\Microsoft\\Internet Explorer\\Main",
                                             "IEWatsonEnabled",
                                             &dwType, &dw, &dwSize))
            {
                // Check current user if we didn't find anything for the local machine.
                dwSize = sizeof(dw);
                SHGetValue(HKEY_CURRENT_USER,
                            "Software\\Microsoft\\Internet Explorer\\Main",
                            "IEWatsonEnabled",
                            &dwType, &dw, &dwSize);
            }

            if (dw)
            {
                SetUnhandledExceptionFilter(DwExceptionFilter);
            }
        }
                
        iRet = IEWinMain(lpszCmdLine, nCmdShow);
    }

    return iRet;
}

// DllGetLCID
//
// this API is for Office to retrieve our UI language
// when they are hosted by iexplore.
//
STDAPI_(LCID) DllGetLCID (IBindCtx * pbc)
{
     return MLGetUILanguage();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iexplore\msodw.h ===
#pragma once

/****************************************************************************
	MsoDW.h

	Owner: MRuhlen
	Copyright (c) 1999 Microsoft Corporation

	This files contains the handshake structure with which apps will launch
	DW (aka OfficeWatson, aka whatever the marketroids call it)
****************************************************************************/

#ifndef MSODW_H
#define MSODW_H
#pragma pack(push, msodw_h)
#pragma pack(4)

#define DW_TIMEOUT_VALUE	20000
#define DW_MUTEX_TIMEOUT    DW_TIMEOUT_VALUE / 2
#define DW_NOTIFY_TIMEOUT   120000 // 2 minutes
#define DW_MAX_ASSERT_CCH   1024
#define DW_MAX_PATH         260
#define DW_APPNAME_LENGTH	56
#define DW_MAX_SERVERNAME   DW_MAX_PATH
#define DW_MAX_ERROR_CWC    260 // must be at least max_path
#define DW_MAX_REGSUBPATH   200
#define DW_CMDLINE_RESPONSE "DwResponse="
#define DW_CMDLINE_REPORT   "DwReportResponse="

#define DW_BLUEPATH         "blue"
#define DW_WHISTLER_EVENTLOG_SOURCE L"Application Error"

// the following are the fields that can be specified in a manifest file to 
// launch DW in a file based reporting mode

// these are required

#define DW_MANIFEST_TITLENAME    L"TitleName="  
#define DW_MANIFEST_ERRORTEXT    L"ErrorText="
#define DW_MANIFEST_HDRTEXT      L"HeaderText="
#define DW_MANIFEST_ERRORSIG     L"ErrorSig="
#define DW_MANIFEST_ERRORDETAIL  L"ErrorDetail="
#define DW_MANIFEST_SERVERNAME   L"Server="
#define DW_MANIFEST_URL2         L"Stage2URL="
#define DW_MANIFEST_LCID         L"UI LCID="
#define DW_MANIFEST_DATAFILES    L"DataFiles="

// the following are optional, DW has default behavior for all of these

#define DW_MANIFEST_FLAGS        L"Flags="
#define DW_MANIFEST_BRAND        L"Brand="
#define DW_MANIFEST_EVENTSOURCE  L"EventLogSource="
#define DW_MANIFEST_EVENTID      L"EventID="
#define DW_MANIFEST_URL1         L"Stage1URL="
#define DW_MANIFEST_ERRORSUBPATH L"ErrorSubPath="
#define DW_MANIFEST_REGSUBPATH   L"RegSubPath="
#define DW_MANIFEST_DIGPIDPATH   L"DigPidRegPath="    
#define DW_MANIFEST_ICONFILE     L"IconFile="
#define DW_MANIFEST_CAPTION      L"Caption="
#define DW_MANIFEST_REPORTEE     L"Reportee="
#define DW_MANIFEST_PLEA         L"Plea="
#define DW_MANIFEST_REPORTBTN    L"ReportButton="
#define DW_MANIFEST_NOREPORTBTN  L"NoReportButton="

// Seperator for file lists (Manifest DataFiles and Exception Additional Files
#define DW_FILESEPA              '|'
#define DW_FILESEP_X(X)          L##X
#define DW_FILESEP_Y(X)          DW_FILESEP_X(X)
#define DW_FILESEP               DW_FILESEP_Y(DW_FILESEPA)

#ifdef DEBUG
enum // AssertActionCodes
{
	DwAssertActionFail = 0,
	DwAssertActionDebug,
	DwAssertActionIgnore,
	DwAssertActionAlwaysIgnore,
	DwAssertActionIgnoreAll,
	DwAssertActionQuit,
};	
#endif

//  Caller is the app that has experienced an exception and launches DW

enum // ECrashTimeDialogStates	// msoctds
{
	msoctdsNull          = 0x00000000,
	msoctdsQuit          = 0x00000001,
	msoctdsRestart       = 0x00000002,
	msoctdsRecover       = 0x00000004,
	msoctdsUnused        = 0x00000008,
	msoctdsDebug         = 0x00000010,
};

#define MSODWRECOVERQUIT (msoctdsRecover | msoctdsQuit)
#define MSODWRESTARTQUIT (msoctdsRestart | msoctdsQuit)
#define MSODWRESPONSES (msoctdsQuit | msoctdsRestart | msoctdsRecover)

// THIS IS PHASED OUT -- DON'T USE
enum  // EMsoCrashHandlerFlags  // msochf
{
	msochfNull                = 0x00000000,

	msochfUnused              = msoctdsUnused,  // THESE MUST BE THE SAME
	msochfCanRecoverDocuments = msoctdsRecover,
	
	msochfObsoleteCanDebug    = 0x00010001,  // not used anymore
	msochfCannotSneakyDebug   = 0x00010002,  // The "hidden" debug feature won't work
	msochfDefaultDontReport   = 0x00010004,
	msochReportingDisabled    = 0x00010008,  // User cannot change default reporting choice
};


// 
enum  // EMsoCrashHandlerResults  // msochr
{
	msochrNotHandled        = msoctdsNull,
	msochrUnused            = msoctdsUnused,
	msochrDebug             = msoctdsDebug,
	msochrRecoverDocuments  = msoctdsRecover,
	msochrRestart           = msoctdsRestart,
	msochrQuit              = msoctdsQuit,
};

enum  // EDwBehaviorFlags
{
	fDwOfficeApp            = 0x00000001,
	fDwNoReporting          = 0x00000002,   // don't report
	fDwCheckSig             = 0x00000004,   // checks the signatures of the App/Mod list
	fDwGiveAppResponse      = 0x00000008,   // hands szResponse to app on command line
	fDwWhistler             = 0x00000010,   // Whistler's exception handler is caller
	fDwUseIE                = 0x00000020,   // always launch w/ IE
	fDwDeleteFiles          = 0x00000040,   // delete the additional files after use.
	fDwHeadless             = 0x00000080,   // DW will auto-report. policy required to enable
	fDwUseHKLM              = 0x00000100,   // DW reg from HKLM instead of HKCU
	fDwUseLitePlea          = 0x00000200,   // DW won't suggest product change in report plea
	fDwUsePrivacyHTA        = 0x00000400,   // DW won't suggest product change in report plea
	fDwManifestDebug        = 0x00000800,   // DW will provide a debug button in manifset mode
	fDwReportChoice         = 0x00001000,   // DW will tack on the command line of the user
};


typedef struct _DWSharedMem10
{
	DWORD dwSize;               // should be set to size of DWSharedMem
	DWORD pid;                  // Process Id of caller
	DWORD tid;                  // Id of excepting thread
	DWORD_PTR eip;              // EIP of the excepting instruction
	PEXCEPTION_POINTERS pep;    // Exception pointers given to the callee's
	                            // exception handler
	HANDLE hEventDone;          // event DW signals when done
	                            // caller will also signal this if it things
								// DW has hung and restarts itself 
	HANDLE hEventNotifyDone;    // App sets when it's done w/ notifcation phase
	HANDLE hEventAlive;         // heartbeat event DW signals per EVENT_TIMEOUT
	HANDLE hMutex;              // to protect the signaling of EventDone  
	HANDLE hProc;               // handle to the calling process (! in Assert)
	
	DWORD bfDWBehaviorFlags;    // controls caller-specific behaviors
	
	DWORD msoctdsResult;      // result from crash-time dialog
	BOOL fReportProblem;      // did user approve reporting?
	DWORD bfmsoctdsOffer;     // bitfield of user choices to offer
	                          // note that you must specify two of:
							  // Quit, Restart, Recover, Ignore
							  // The Debug choice is independent
	DWORD bfmsoctdsNotify;    // bitfield of user choices for which the
	                          // app wants control back instead of simply being
							  // terminated by DW.  The app will then be
							  // responsible for pinging DW (if desired) with
							  // hEventAlive and for notify DW it's ok to
							  // terminate the app w/ hEventDone       

	DWORD bfmsoctdsLetRun;    // bitfield of user choices for which the
	                          // app wants control back instead of being
							  // terminated by DW.  DW can then safely ignore
							  // the app and exit.

	int iPingCurrent;         // current count for the recovery progress bar
	int iPingEnd;             // index for the end of the recovery progress bar
	
	char szFormalAppName[DW_APPNAME_LENGTH];   // the app name for display to user (ie "Microsoft Word")
	char szInformalAppName[DW_APPNAME_LENGTH]; // the app name for display to user (ie "Word")
	char szModuleFileName[DW_MAX_PATH];        // The result of GetModuleFileNameA(NULL)
	WCHAR wzErrorMessage[DW_MAX_ERROR_CWC];    // Error message to show user.
	
	char szServer[DW_MAX_SERVERNAME];  // name of server to try by default
	char szLCIDKeyValue[DW_MAX_PATH];  // name of key value DWORD containing the
	                                   // PlugUI LCID, if this string fails to
									   // be a valid key-value, DW will use the
									   // system LCID, and if it can't find
									   // an intl dll for that, will fall
									   // back on US English (1033)
	char szPIDRegKey[DW_MAX_PATH];     // name of the key that holds the PID
	                                   // can be used by the Server for
									   // spoof-detection
	
	char szRegSubPath[DW_MAX_REGSUBPATH]; // path to the key to contian the DW
	                                      // registry hive from both
									      // HKCU\Software and
									      // HKCU\Software\Policies (for policy)
	
	WCHAR wzDotDataDlls[DW_MAX_PATH];  // contains the list of DLLs, terminated
	                                   // by '\0' characters, that DW will
									   // collect the .data sections into the
									   // full minidump version
									   // e.g. "mso9.dll\0outllib.dll\0"
	WCHAR wzAdditionalFile[1024];      // File list, seperated by DW_FILESEP
	                                   // each of these files gets added to the
									   // cab at upload time

	char szBrand[DW_APPNAME_LENGTH];   // passed as a param to Privacy Policy link
#ifdef DEBUG
	// for Assert communication
	DWORD dwTag;                       // [in] AssertTag
	char szFile[DW_MAX_PATH];          // [in] File name of the assert
	int line;                          // [in] Line number of the assert
	char szAssert[DW_MAX_ASSERT_CCH];  // [in] Sz from the assert
	int AssertActionCode;              // [out] action code to take
#endif
} DWSharedMem10;

typedef struct _DWSharedMem15
{
	DWORD dwSize;               // should be set to size of DWSharedMem
	DWORD pid;                  // Process Id of caller
	DWORD tid;                  // Id of excepting thread
	DWORD_PTR eip;              // EIP of the excepting instruction
	PEXCEPTION_POINTERS pep;    // Exception pointers given to the callee's
	                            // exception handler
	HANDLE hEventDone;          // event DW signals when done
	                            // caller will also signal this if it things
								// DW has hung and restarts itself 
	HANDLE hEventNotifyDone;    // App sets when it's done w/ notifcation phase
	HANDLE hEventAlive;         // heartbeat event DW signals per EVENT_TIMEOUT
	HANDLE hMutex;              // to protect the signaling of EventDone  
	HANDLE hProc;               // handle to the calling process (! in Assert)
	
	DWORD bfDWBehaviorFlags;    // controls caller-specific behaviors
	
	DWORD msoctdsResult;      // result from crash-time dialog
	BOOL fReportProblem;      // did user approve reporting?
	DWORD bfmsoctdsOffer;     // bitfield of user choices to offer
	                          // note that you must specify two of:
							  // Quit, Restart, Recover, Ignore
							  // The Debug choice is independent
	DWORD bfmsoctdsNotify;    // bitfield of user choices for which the
	                          // app wants control back instead of simply being
							  // terminated by DW.  The app will then be
							  // responsible for pinging DW (if desired) with
							  // hEventAlive and for notify DW it's ok to
							  // terminate the app w/ hEventDone       

	DWORD bfmsoctdsLetRun;    // bitfield of user choices for which the
	                          // app wants control back instead of being
							  // terminated by DW.  DW can then safely ignore
							  // the app and exit.

	int iPingCurrent;         // current count for the recovery progress bar
	int iPingEnd;             // index for the end of the recovery progress bar
	
	WCHAR wzFormalAppName[DW_APPNAME_LENGTH];   // the app name for display to user (ie "Microsoft Word")
	WCHAR wzModuleFileName[DW_MAX_PATH];        // The result of GetModuleFileName(NULL)
	
	WCHAR wzErrorMessage[DW_MAX_ERROR_CWC]; // (optional) Error details message to show user.
	WCHAR wzErrorText[DW_MAX_ERROR_CWC];    // (optional) substitue error text (e.g. "you might have lost information")
	WCHAR wzCaption[DW_MAX_ERROR_CWC];      // (optional) substitue caption
	WCHAR wzHeader[DW_MAX_ERROR_CWC];       // (optional) substitue main dialog header text
	WCHAR wzReportee[DW_APPNAME_LENGTH];    // (optional) on whom's behalf we request the report
	WCHAR wzPlea[DW_MAX_ERROR_CWC];         // (optional) substitue report plea text
	WCHAR wzReportBtn[DW_APPNAME_LENGTH];   // (optional) substitue "Report Problem" text
	WCHAR wzNoReportBtn[DW_APPNAME_LENGTH]; // (optional) substitue "Don't Report" text
	
	char szServer[DW_MAX_SERVERNAME];  // name of server to try by default
	char szLCIDKeyValue[DW_MAX_PATH];  // name of key value DWORD containing the
	                                   // PlugUI LCID, if this string fails to
									   // be a valid key-value, DW will use the
									   // system LCID, and if it can't find
									   // an intl dll for that, will fall
									   // back on US English (1033)
	char szPIDRegKey[DW_MAX_PATH];     // name of the key that holds the PID
	                                   // can be used by the Server for
									   // spoof-detection
	
	LCID lcidUI;                       // will try this UI langauge if non-zero
	
	char szRegSubPath[DW_MAX_REGSUBPATH]; // path to the key to contian the DW
	                                      // registry hive from both
									      // HKCU\Software and
									      // HKCU\Software\Policies (for policy)
	
	WCHAR wzDotDataDlls[DW_MAX_PATH];  // contains the list of DLLs, terminated
	                                   // by '\0' characters, that DW will
									   // collect the .data sections into the
									   // full minidump version
									   // e.g. "mso9.dll\0outllib.dll\0"
	WCHAR wzAdditionalFile[1024];      // File list, seperated by DW_FILESEP
	                                   // each of these files gets added to the
									   // cab at upload time

	char szBrand[DW_APPNAME_LENGTH];   // passed as a param to Privacy Policy link
#if 0
	// for Assert communication
	DWORD dwTag;                       // [in] AssertTag
	char szFile[DW_MAX_PATH];          // [in] File name of the assert
	int line;                          // [in] Line number of the assert
	char szAssert[DW_MAX_ASSERT_CCH];  // [in] Sz from the assert
	int AssertActionCode;              // [out] action code to take
#endif
} DWSharedMem15, DWSharedMem;

#pragma pack(pop, msodw_h)
#endif // MSODW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iexplore\unixstuff.cpp ===
#include "iexplore.h"
#include "unixstuff.h"

//
// BOOL ConnectRemoteIE(LPTSTR pszCommandLine)
//
// This function will be called when -remote parameter is specified during the 
// invokation of IE. That's the same format as Netscape uses, see 
// http://home.netscape.com/newsref/std/x-remote.html. 
// For now, the only special action supported is openURL(URL), because we need 
// it for the NetShow. We just put it as the URL was specified as iexplorer 
// param. To be done - connection to the existent browser.
// Returns TRUE if succeed to connect to the existent browser.
//
#define c_szSpace TEXT(' ')

static BOOL IsOpenURL(LPCTSTR pszBeginCommand, LPCTSTR pszEndCommand, LPTSTR pszURL)
{
    const TCHAR c_szOpenURL[] = TEXT("openURL");
    const TCHAR c_szLBracket  = TEXT('(');
    const TCHAR c_szRBracket  = TEXT(')');
    const TCHAR c_szSQuote    = TEXT('\'');
    const TCHAR c_szDQuote  = TEXT('\"');
    LPCTSTR pszBeginURL, pszEndURL;
    BOOL bRet = TRUE;

    // Skip the leading/trailing spaces.
    while (*pszBeginCommand == c_szSpace) pszBeginCommand++;
    while ((*pszEndCommand == c_szSpace) && (pszBeginCommand <= pszEndCommand))
        pszEndCommand--;

    // Now, parse the value and replace in the cmd line, 
    // if there is openURL there. More formats later...
    if (StrCmpNI(pszBeginCommand, c_szOpenURL, lstrlen(c_szOpenURL)) ||
        (*pszEndCommand != c_szRBracket)) {
        pszBeginURL = pszBeginCommand;
        bRet = FALSE;
	pszEndURL = pszEndCommand;
    }
    else{
        pszBeginURL = pszBeginCommand+lstrlen(c_szOpenURL);
	while (*pszBeginURL == c_szSpace) pszBeginURL++;    
	if ((*pszBeginURL != c_szLBracket) || 
	    (pszBeginURL == pszEndCommand-1)) {
	    pszURL[0] = '\0';
	    return FALSE;
	}
	pszBeginURL++;
	pszEndURL = pszEndCommand-1;
    }

    // Skip the leading/trailing spaces.
    while (*pszBeginURL == c_szSpace) pszBeginURL++;    
    while (*pszEndURL == c_szSpace) pszEndURL--;

    // Take off quotes.
    if (((*pszBeginURL == c_szSQuote) && (*pszEndURL == c_szSQuote)) || 
	((*pszBeginURL == c_szDQuote) && (*pszEndURL == c_szDQuote))) {
        while (*pszBeginURL == c_szSpace) pszBeginURL++;    
	while (*pszEndURL == c_szSpace) pszEndURL--;
	if (pszBeginURL >= pszEndURL) {
	    pszURL[0] = '\0';
	    return FALSE;
	}
    }

    StrCpyN(pszURL, pszBeginURL, (pszEndURL-pszBeginURL)/sizeof(TCHAR) +2); 
    if (bRet) 
        bRet = pszURL[0];

    return bRet;
}


static BOOL ConnectExistentIE(LPCTSTR pszURL, HINSTANCE hInstance)
{
    HWND hwnd; 
   
    if (hwnd = FindWindow(IEREMOTECLASS, NULL))
    {
        COPYDATASTRUCT cds;
        cds.dwData = IEREMOTE_CMDLINE;
        cds.cbData = pszURL ? (lstrlen(pszURL)+1)*sizeof(TCHAR) : 0;
        cds.lpData = pszURL;
        SetForegroundWindow(hwnd);
        SendMessage(hwnd, WM_COPYDATA, (WPARAM)WMC_DISPATCH, (LPARAM)&cds);
	ExitProcess(0);
    }
    return FALSE;
}

BOOL ConnectRemoteIE(LPTSTR pszCmdLine, HINSTANCE hInstance)
{
    const TCHAR c_szDblQuote  = TEXT('"');
    const TCHAR c_szQuote     = TEXT('\'');

    LPTSTR pszBeginRemote, pszEndRemote;
    LPTSTR pszBeginCommand, pszEndCommand;
    TCHAR  szURL[INTERNET_MAX_URL_LENGTH];
    TCHAR  szRestCmdLine[INTERNET_MAX_URL_LENGTH * 2];

    // If we start with a quote, finish with a quote.
    // If we start with something else, finish 1 symbol before space
    // or end of string.
    pszBeginRemote = pszBeginCommand = pszCmdLine;
    
    if (*pszBeginCommand == c_szQuote || *pszBeginCommand == c_szDblQuote) {
        pszEndRemote = pszEndCommand = StrChr(pszBeginCommand+1, (WORD)(*pszBeginCommand));
        pszBeginCommand++;       
    }
    else {
        pszEndCommand = StrChr(pszBeginCommand, (WORD)c_szSpace);
        if (pszEndCommand == NULL)
            pszEndCommand = pszBeginCommand+lstrlen(pszBeginCommand);
       pszEndRemote = pszEndCommand-1;
    }

    if ((pszEndCommand == NULL) || (lstrlen(pszBeginCommand) <= 1))
        return FALSE;
    pszEndCommand--;

    //
    // Now, check the remote command and execute.
    // For now, we just replace the URL in the cmd line, 
    // if there is openURL there. More formats later...
    IsOpenURL(pszBeginCommand, pszEndCommand, szURL);
    if (ConnectExistentIE(szURL, hInstance))
        return TRUE;
    StrCpyN(szRestCmdLine, pszEndRemote+1, ARRAYSIZE(szRestCmdLine));
    *pszBeginRemote = '\0';   
    StrCat(pszCmdLine, szURL);
    StrCat(pszCmdLine, szRestCmdLine);

    // No connection with an existent IE was done.
    return FALSE;

}

#if 0
#define WMC_UNIX_NEWWINDOW            (WM_USER + 0x0400)
BOOL RemoteIENewWindow(LPTSTR pszCmdLine)
{
    HWND hwnd; 
    LPTSTR pszCurrent = pszCmdLine;

    while (*pszCurrent == TEXT(' '))
        pszCurrent++;
    if (*pszCurrent == TEXT('-'))
        return FALSE;
   
    if (hwnd = FindWindow(IEREMOTECLASS, NULL))
    {
        COPYDATASTRUCT cds;
        cds.dwData = IEREMOTE_CMDLINE;
        cds.cbData = pszCmdLine ? (lstrlen(pszCmdLine)+1)*sizeof(TCHAR) : 0;
        cds.lpData = pszCmdLine;
        SetForegroundWindow(hwnd);
        SendMessage(hwnd, WM_COPYDATA, (WPARAM)WMC_UNIX_NEWWINDOW, (LPARAM)&cds);
	printf("Opening a new window in the currently running Internet Explorer.\n");
	printf("To start a new instance of Internet Explorer, type \"iexplorer -new\".\n");
	return TRUE;
    }
    return FALSE;    
}
#endif

// Entry point for Mainwin is WinMain so create this function and call
// ModuleEntry() from here.

#if defined(MAINWIN)
EXTERN_C int _stdcall ModuleEntry(void);

EXTERN_C int WINAPI WinMain( HINSTANCE hinst, HINSTANCE hprev, LPSTR lpcmdline, int cmd )
{
        return ModuleEntry ();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\iexplore\unixstuff.h ===
#include <stdlib.h>
#include <mainwin.h>

#define IEREMOTE_CMDLINE        1
#define IEREMOTECLASS           TEXT("IEFrame")

BOOL ConnectRemoteIE(LPTSTR pszCmdLine, HINSTANCE hInstance);
BOOL IsCommandSwitch(LPTSTR lpszCmdLine, LPTSTR pszSwitch);
BOOL RemoteIENewWindow(LPTSTR pszCmdLine);

#if defined(UNIX)

#include <sys/time.h>
#include <sys/resource.h>

#define INCREASE_FILEHANDLE_LIMIT  \
    struct rlimit rl; \
    if ( 0 == getrlimit(RLIMIT_NOFILE, &rl)) { \
       rl.rlim_cur = rl.rlim_max; \
       setrlimit(RLIMIT_NOFILE, &rl); \
    } \

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\apwizhlp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1994
*
*  TITLE:	APWIZHLP.H
*
*  VERSION:	1.0
*
*  AUTHOR:	RAL
*
*  DATE:	11/8/94
*
*  Help IDs for Add/Remove Programs.
*  NOTE:  These IDs are reserved in the HELP.H file.  The IDs refer to entries
*	  in the main windows help file.
*
*******************************************************************************/


#ifndef _INC_APWIZHLP
#define _INC_APWIZHLP

//  Net install page
#define IDH_APPWIZ_NETINSTALL_INSTRUCT	5600
#define IDH_APPWIZ_NETINSTALL_LIST	5601
#define IDH_APPWIZ_NETINTALLL_BUTTON	5602

// Install/Uninstall Page
#define IDH_APPWIZ_DISKINSTALL_INSTRUCT 5610
#define IDH_APPWIZ_DISKINTALLL_BUTTON	5611
#define IDH_APPWIZ_UNINSTALL_INSTRUCT	5612
#define IDH_APPWIZ_UNINSTALL_LIST	5613
#define IDH_APPWIZ_UNINSTALL_BUTTON	5614

// Windows Setup page
#define IDH_APPWIZ_WINSETUP_INSTRUCT	5620
#define IDH_APPWIZ_WINSETUP_LIST	5621

// Startup Disk page
#define IDH_APPWIZ_STARTDISK_INSTRUCT	5630
#define IDH_APPWIZ_STARTDISK_BUTTON	5631

#endif // _INC_APWIZHLP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\backtrace.h ===
struct BACKTRACE {
BACKTRACE(const BACKTRACE &other);
~BACKTRACE();
BACKTRACE(INT nMax, INT nSkip); 
bool BACKTRACE::operator <(const BACKTRACE &second) const;
BOOL BACKTRACE::ComputeSymbolic(BOOL fOverWrite);
LPSTR pszSymbolicStack;
int nQuick;
LPVOID *ppNumeric;
int cch;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\autosecurity.h ===
/*****************************************************************************\
    FILE: autosecurity.h

    DESCRIPTION:
        Helpers functions to check if an Automation interface or ActiveX Control
    is hosted or used by a safe caller.

    BryanSt 8/20/1999
    Copyright (C) Microsoft Corp 1999-1999. All rights reserved.
\*****************************************************************************/

#ifndef _AUTOMATION_SECURITY_H_
#define _AUTOMATION_SECURITY_H_

#include <ocidl.h>          // IObjectWithSite
#include <shlwapip.h>        // IUnknown_AtomicRelease
#include <ccstock.h>        // ATOMICRELEASE

#include <mshtml.h>
#include <cowsite.h>        // CObjectWithSite
#include <objsafe.h>        // IObjectSafety
#include <cobjsafe.h>       // CObjectSafety


/***************************************************************\
    DESCRIPTION:
        This class will provide standard security functions that
    most ActiveX Controls or scriptable COM objects need.

    HOW TO USE THIS CLASS:
    1. If you don't want any security, don't implement this
       interface and don't implement IObjectSafety.  This should
       prevent your class from being used from any unsafe hosts.
    2. Create a list of any of your automation methods and actions
       invoked from your ActiveX Control's UI that can harm the user.
    3. For each of those methods/actions, decide if:
       A) It's only safe from hosts that are always safe (like HTA)
       B) It's only safe from hosts if their content is from
          a safe zone (Local Zone/Local Machine).
       C) If an UrlAction needs to be checked before the operation
          can be carried out.
    4. Based on #3, use IsSafeHost(), IsHostLocalZone(),
       or IsUrlActionAllowed() respectively.
    5. Call MakeObjectSafe on any object you create unless you
       can GUARANTEE that it will be IMPOSSIBLE for an unsafe
       caller to use it directly or indirectly to do something
       unsafe.
       
       An example of a direct case is a collection object
       creating an item object and then returning it to the unsafe
       host.  Since the host didn't create the object, it didn't
       get a chance to correctly use IObjectSafety, so
       MakeObjectSafe() is needed.

       An example of an indirect case is where unsafe code calls
       one of your automation methods and you decide to carry out
       the action.  If you create a helper object to perform a task
       and you can't guarantee that it will be safe, you need to
       call MakeObjectSafe on that object so it can decide
       internally if it's safe.

       WARNING: If MakeObjectSafe returns a FAILED(hr),
          then ppunk will be FREED because it isn't safe to use.
\***************************************************************/
#define    CAS_NONE            0x00000000  // None
#define    CAS_REG_VALIDATION  0x00000001  // Verify the host HTML is registered
#define    CAS_PROMPT_USER     0x00000002  // If the HTML isn't registered, prompt the user if they want to use it anyway.

class CAutomationSecurity   : public CObjectWithSite
                            , public CObjectSafety
{
public:
    //////////////////////////////////////////////////////
    // Public Methods
    //////////////////////////////////////////////////////
    BOOL IsSafeHost(OUT OPTIONAL HRESULT * phr);
    BOOL IsHostLocalZone(IN DWORD dwFlags, OUT OPTIONAL HRESULT * phr);
    BOOL IsUrlActionAllowed(IN IInternetHostSecurityManager * pihsm, IN DWORD dwUrlAction, IN DWORD dwFlags, OUT OPTIONAL HRESULT * phr);

    HRESULT MakeObjectSafe(IN OUT IUnknown ** ppunk);
};


#endif // _AUTOMATION_SECURITY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\bands.cpp ===
#include "bands.h"

#define DM_PERSIST      0           // trace IPS::Load, ::Save, etc.
#define DM_MENU         0           // menu code
#define DM_FOCUS        0           // focus
#define DM_FOCUS2       0           // like DM_FOCUS, but verbose

//=================================================================
// Implementation of CToolBand
//=================================================================

ULONG CToolBand::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CToolBand::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CToolBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] =
    {
        QITABENT(CToolBand, IDeskBand),         // IID_IDeskBand
        QITABENTMULTI(CToolBand, IOleWindow, IDeskBand),        // IID_IOleWindod
        QITABENTMULTI(CToolBand, IDockingWindow, IDeskBand),    // IID_IDockingWindow
        QITABENT(CToolBand, IInputObject),      // IID_IInputObject
        QITABENT(CToolBand, IOleCommandTarget), // IID_IOleCommandTarget
        QITABENT(CToolBand, IServiceProvider),  // IID_IServiceProvider
        QITABENT(CToolBand, IPersistStream),    // IID_IPersistStream
        QITABENTMULTI(CToolBand, IPersist, IPersistStream),     // IID_IPersist
        QITABENT(CToolBand, IObjectWithSite),   // IID_IObjectWithSite
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

//  *** IOleCommandTarget methods ***

HRESULT CToolBand::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return E_NOTIMPL;
}

HRESULT CToolBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    return E_NOTIMPL;
}

//  *** IServiceProvider methods ***

HRESULT CToolBand::QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
}

//  *** IOleWindow methods ***

HRESULT CToolBand::GetWindow(HWND * lphwnd)
{
    *lphwnd = _hwnd;

    if (*lphwnd)
        return S_OK;

    return E_FAIL;
}

//  *** IInputObject methods ***

HRESULT CToolBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    return E_NOTIMPL;
}

HRESULT CToolBand::HasFocusIO()
{
    HRESULT hres;
    HWND hwndFocus = GetFocus();

    hres = SHIsChildOrSelf(_hwnd, hwndFocus);
    ASSERT(hwndFocus != NULL || hres == S_FALSE);
    ASSERT(_hwnd != NULL || hres == S_FALSE);

    return hres;
}

HRESULT CToolBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    TraceMsg(DM_FOCUS, "ctb.uiaio(fActivate=%d) _fCanFocus=%d _hwnd=%x GF()=%x", fActivate, _fCanFocus, _hwnd, GetFocus());

    if (!_fCanFocus) {
        TraceMsg(DM_FOCUS, "ctb.uiaio: !_fCanFocus ret S_FALSE");
        return S_FALSE;
    }

    if (fActivate)
    {
        IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
        SetFocus(_hwnd);
    }

    return S_OK;
}

HRESULT CToolBand::ResizeBorderDW(LPCRECT prcBorder,
                                         IUnknown* punkToolbarSite,
                                         BOOL fReserved)
{
    return S_OK;
}


HRESULT CToolBand::ShowDW(BOOL fShow)
{
    return S_OK;
}

HRESULT CToolBand::SetSite(IUnknown *punkSite)
{
    if (punkSite != _punkSite)
    {
        IUnknown_Set(&_punkSite, punkSite);
        IUnknown_GetWindow(_punkSite, &_hwndParent);
    }
    return S_OK;
}

HRESULT CToolBand::_BandInfoChanged()
{
    VARIANTARG v = {0};
    VARIANTARG* pv = NULL;
    if (_dwBandID != (DWORD)-1)
    {
        v.vt = VT_I4;
        v.lVal = _dwBandID;
        pv = &v;
    }
    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_BANDINFOCHANGED, 0, pv, NULL);
}

//  *** IPersistStream methods ***

HRESULT CToolBand::IsDirty(void)
{
    return S_FALSE;     // never be dirty
}

HRESULT CToolBand::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    return E_NOTIMPL;
}

CToolBand::CToolBand() : _cRef(1)
{
    _dwBandID = (DWORD)-1;
    DllAddRef();
}

CToolBand::~CToolBand()
{
    ASSERT(_hwnd == NULL);      // CloseDW was called
    ASSERT(_punkSite == NULL);  // SetSite(NULL) was called

    DllRelease();
}

HRESULT CToolBand::CloseDW(DWORD dw)
{
    if (_hwnd)
    {
        DestroyWindow(_hwnd);
        _hwnd = NULL;
    }
    
    return S_OK;
}


//=================================================================
// Implementation of CToolbarBand
//=================================================================
// Class for bands whose _hwnd is a toolbar control.  Implements
// functionality generic to all such bands (e.g. hottracking 
// behavior).
//=================================================================

HRESULT CToolbarBand::_PushChevron(BOOL bLast)
{
    if (_dwBandID == (DWORD)-1)
        return E_UNEXPECTED;

    VARIANTARG v;
    v.vt = VT_I4;
    v.lVal = bLast ? DBPC_SELECTLAST : DBPC_SELECTFIRST;

    return IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_PUSHCHEVRON, _dwBandID, &v, NULL);
}

LRESULT CToolbarBand::_OnHotItemChange(LPNMTBHOTITEM pnmtb)
{
    LRESULT lres = 0;

    if (!(pnmtb->dwFlags & (HICF_LEAVING | HICF_MOUSE)))
    {
        // check to see if new hot button is clipped.  if it is,
        // then we pop down the chevron menu.
        RECT rc;
        GetClientRect(_hwnd, &rc);

        int iButton = (int)SendMessage(_hwnd, TB_COMMANDTOINDEX, pnmtb->idNew, 0);
        DWORD dwEdge = SHIsButtonObscured(_hwnd, &rc, iButton);
        if (dwEdge)
        {
            //
            // Only pop down the menu if the button is obscured
            // along the axis of the toolbar
            //
            BOOL fVertical = (ToolBar_GetStyle(_hwnd) & CCS_VERT);

            if ((fVertical && (dwEdge & (EDGE_TOP | EDGE_BOTTOM)))
                || (!fVertical && (dwEdge & (EDGE_LEFT | EDGE_RIGHT))))
            {
                // clear hot item
                SendMessage(_hwnd, TB_SETHOTITEM, -1, 0);

                // figure out whether to highlight first or last button in dd menu
                int cButtons = (int)SendMessage(_hwnd, TB_BUTTONCOUNT, 0, 0);
                BOOL bLast = (iButton == cButtons - 1);
                _PushChevron(bLast);
                lres = 1;
            }
        }
    }

    return lres;
}

LRESULT CToolbarBand::_OnNotify(LPNMHDR pnmh)
{
    LRESULT lres = 0;

    switch (pnmh->code)
    {
    case TBN_HOTITEMCHANGE:
        lres = _OnHotItemChange((LPNMTBHOTITEM)pnmh);
        break;
    }

    return lres;
}

// *** IWinEventHandler methods ***

HRESULT CToolbarBand::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HRESULT hres = S_OK;

    switch (dwMsg)
    {
    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        break;

    case WM_WININICHANGE:
        InvalidateRect(_hwnd, NULL, TRUE);
        _BandInfoChanged();
        break;
    }

    return hres;
}

HRESULT CToolbarBand::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwnd)
        return S_OK;
    else
        return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\batmeter.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1993-1994
*
*  TITLE:       BATMETER.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        31 Dec 1993
*
*
*******************************************************************************/

// Private BatMeter window message.
#define WM_DESTROYBATMETER WM_USER+100

#ifndef ARRAYSIZE
#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#endif

// This structure encapsulates what is displayed for each battery
// and the composite system.

typedef struct _BATTERY_STATE{
    ULONG                  ulSize;                 // Size of structure.
    struct _BATTERY_STATE  *bsNext;                // Next in list
    struct _BATTERY_STATE  *bsPrev;                // Previous in list
    ULONG                  ulBatNum;               // Display battery number.
    ULONG                  ulTag;                  // Zero implies no battery.
    HANDLE                 hDevice;                // Handle to the battery device.
#ifdef WINNT
    HDEVNOTIFY             hDevNotify;             // Device notification handle.
#endif
    UINT                   uiIconIDcache;          // Cache of the last Icon ID.
    HICON                  hIconCache;             // Cache of the last Icon handle.
    HICON                  hIconCache16;           // As above but 16x16.
    LPTSTR                 lpszDeviceName;         // The name of the battery device
    ULONG                  ulFullChargedCapacity;  // Same as PBATTERY_INFORMATION->FullChargedCapacity.
    ULONG                  ulPowerState;           // Same flags as PBATTERY_STATUS->PowerState.
    ULONG                  ulBatLifePercent;       // Battery life remaining as percentage.
    ULONG                  ulBatLifeTime;          // Battery life remaining as time in seconds.
    ULONG                  ulLastTag;              // Previous value of ulTag.
    ULONG                  ulLastPowerState;       // Previous value of ulPowerState.
    ULONG                  ulLastBatLifePercent;   // Previous value of ulBatLifePercent.
    ULONG                  ulLastBatLifeTime;      // Previous value of ulBatLifeTime.
} BATTERY_STATE, *PBATTERY_STATE;

// Power management UI help file:
#define PWRMANHLP TEXT("PWRMN.HLP")

// Number of batteries that battery meter can display.
#define NUM_BAT 8

#define BATTERY_RELATED_FLAGS (BATTERY_FLAG_HIGH | BATTERY_FLAG_LOW | BATTERY_FLAG_CRITICAL | BATTERY_FLAG_CHARGING | BATTERY_FLAG_NO_BATTERY)

// Public function prototypes:
BOOL PowerCapabilities();
BOOL BatMeterCapabilities(PUINT*);
BOOL UpdateBatMeter(HWND, BOOL, BOOL, PBATTERY_STATE);
HWND CreateBatMeter(HWND, HWND, BOOL, PBATTERY_STATE);
HWND DestroyBatMeter(HWND);

// DisplayFreeStr bFree parameters:
#define FREE_STR    TRUE
#define NO_FREE_STR FALSE

// Private functions implemented in BATMETER.C
LPTSTR  CDECL     LoadDynamicString( UINT StringID, ... );
LPTSTR            DisplayFreeStr(HWND, UINT, LPTSTR, BOOL);
LRESULT CALLBACK  BatMeterDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL              SwitchDisplayMode(HWND, BOOL);
BOOL              UpdateBatMeterProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);
UINT              GetBatteryDriverNames(LPTSTR*);
BOOL              UpdateDriverList(LPTSTR*, UINT);
VOID              FreeBatteryDriverNames(LPTSTR*);
UINT              MapBatInfoToIconID(PBATTERY_STATE);
HICON PASCAL      GetBattIcon(HWND, UINT, HICON, BOOL, UINT);

// Private functions implemented in DETAILS.C
LRESULT CALLBACK  BatDetailDlgProc(HWND, UINT, WPARAM, LPARAM);

// WalkBatteryState pbsStart parameters:
#define ALL     &g_bs
#define DEVICES g_bs.bsNext

// WalkBatteryState enum proc declaration.
typedef LRESULT (CALLBACK *WALKENUMPROC)(PBATTERY_STATE, HWND, LPARAM, LPARAM);

// RemoveMissingProc lParam2 parameters:
#define REMOVE_MISSING  0
#define REMOVE_ALL      1

// Private functions implemented in BATSTATE.C
BOOL WalkBatteryState(PBATTERY_STATE, WALKENUMPROC, HWND, LPARAM, LPARAM);
BOOL RemoveBatteryStateDevice(PBATTERY_STATE);
BOOL RemoveMissingProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);
BOOL FindNameProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);
BOOL UpdateBatInfoProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);
BOOL SimUpdateBatInfoProc(PBATTERY_STATE, HWND, LPARAM, LPARAM);

void SystemPowerStatusToBatteryState(LPSYSTEM_POWER_STATUS, PBATTERY_STATE);

PBATTERY_STATE AddBatteryStateDevice(LPTSTR, ULONG);
PBATTERY_STATE SimAddBatteryStateDevice(LPTSTR, ULONG);

#ifdef DBG
#define BATTRACE(_ARGS) DbgPrint _ARGS
#else
#define BATTRACE
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\brfcasep.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1993-1994
//
// File: brfcasep.h
//
//  Internal header shared between SHELL232 and SYNCUI
//
// History:
//  01-27-94 ScottH     Copied from brfcase.h
//
//---------------------------------------------------------------------------

#ifndef _BRFCASEP_H_
#define _BRFCASEP_H_

//===========================================================================
//
// IBriefcaseStg Interface
//
//  This is a private interface for use between the shell and the briefcase.
//
//  This interface is used by the Shell's IShellFolder implementation
// when it is bound to a folder that is (in) a briefcase.  The IShellView
// of the particular folder binds to this interface to open the briefcase
// database storage and optionally make modifications.  File-objects that
// are added to a folder in a briefcase are not added to the storage
// database until IBriefcaseStg::AddObject is called.  Keep in mind the
// difference between IBriefcaseStg and IShellFolder.  IBriefcaseStg
// simply provides access to the briefcase storage database--the file-system
// objects are only affected upon subsequent reconciliation using
// IBriefcaseStg::UpdateObject, unless otherwise noted.
//
//
// [Member functions]
//
//
// IBriefcaseStg::Initialize(pszFolder, hwndOwner)
//
//   Initializes the interface by specifying the folder for this storage
//   instance.  If the folder does not exist somewhere in a briefcase
//   storage hierarchy, then a briefcase database is created for this
//   folder.
//
// IBriefcaseStg::AddObject(pdtobj, pszFolderEx, uFlags, hwndOwner)
//
//   Adds a file-object(s) to the briefcase storage.  This function also
//   performs an update of the specific files to immediately make them
//   up-to-date.
//
//   Typically pdtobj refers to a file-object(s) outside the
//   briefcase.  Calling this function implies adding the object(s) to
//   the briefcase storage database in the folder that was specified by
//   IBriefcaseStg::Initialize().  This rule holds unless pszFolderEx is
//   non-NULL, in which case pdtobj is sync-associated to pszFolderEx
//   instead.
//
//   AddObject() returns NOERROR if the object(s) were added.  S_FALSE
//   is returned if the caller should handle the action (eg, moving
//   files from folder-to-folder within the briefcase).
//
// IBriefcaseStg::ReleaseObject(pdtobj, hwndOwner)
//
//   Releases a file-object(s) from the briefcase storage database.  This
//   does not delete the file from the file-system.
//
// IBriefcaseStg::UpdateObject(pdtobj, hwndOwner)
//
//   Performs a file-synchronization update to pdtobj.  If pdtobj refers to
//   the root of a briefcase storage hierarchy, the entire storage is updated.
//
// IBriefcaseStg::UpdateOnEvent(uEvent, hwndOwner)
//
//   Performs a complete update of the briefcase storage based on the
//   indicated event.  The event ordinals may be:
//
//      UOE_CONFIGCHANGED       Indicates a PnP DBT_CONFIGCHANGED message wants
//                              to be processed.  This occurs when a machine
//                              hot-docks.
//
//      UOE_QUERYCHANGECONFIG   Indicates a PnP DBT_QUERYCHANGECONFIG message
//                              wants to be processed.  This occurs when a
//                              machine is about to hot-undock.
//
// IBriefcaseStg::GetExtraInfo(pszName, uInfo, wParam, lParam)
//
//   Gets some specified extra info from the briefcase storage.  The
//   info is determined by uInfo, which is one of GEI_* values.
//
// IBriefcaseStg::Notify(pszPath, lEvent, puFlags, hwndOwner)
//
//   Sends a notify event to the briefcase storage, so it can mark
//   cached items stale.  If lEvent is NOE_RENAME, pszPath must be a double
//   null-terminated string, where the first is the old pathname, and the
//   second is the new pathname.  *puFlags is filled with flags pertaining
//   to what the member function did.  NF_REDRAWWINDOW means the window
//   needs to be redrawn.  NF_ITEMMARKED means the cached item in the
//   briefcase storage associated with pszPath was marked stale.
//
// IBriefcaseStg::GetRootOf(pszBuffer, cbBuffer)
//
//   Queries the briefcase storage for the root of the briefcase storage
//   hierarchy.
//
// IBriefcaseStg::FindFirst(pszBuffer, cbBuffer)
//
//   Finds the root of the first briefcase storage on the system.  The
//   buffer is filled with the fully qualified pathname.  This function
//   returns S_OK if a briefcase was found.  S_FALSE is returned to end
//   enumeration.
//
// IBriefcaseStg::FindNext(pszBuffer, cbBuffer)
//
//   Finds the root of the next briefcase storage on the system.  The
//   buffer is filled with the fully qualified pathname.  This function
//   returns S_OK if a briefcase was found.  S_FALSE is returned to end
//   enumeration.
//
//
//
//===========================================================================

#undef  INTERFACE
#define INTERFACE   IBriefcaseStg

DECLARE_INTERFACE_(IBriefcaseStg, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBriefcaseStg methods ***
    STDMETHOD(Initialize) (THIS_ LPCTSTR pszFolder, HWND hwnd) PURE;
    STDMETHOD(AddObject) (THIS_ LPDATAOBJECT lpdobj, LPCTSTR pszFolderEx, UINT uFlags, HWND hwnd) PURE;
    STDMETHOD(ReleaseObject) (THIS_ LPDATAOBJECT lpdobj, HWND hwnd) PURE;
    STDMETHOD(UpdateObject) (THIS_ LPDATAOBJECT lpdobj, HWND hwnd) PURE;
    STDMETHOD(UpdateOnEvent) (THIS_ UINT uEvent, HWND hwnd) PURE;
    STDMETHOD(GetExtraInfo) (THIS_ LPCTSTR pszName, UINT uInfo, WPARAM wParam, LPARAM lParam) PURE;
    STDMETHOD(Notify) (THIS_ LPCTSTR pszPath, LONG lEvent, UINT * puFlags, HWND hwndOwner) PURE;
    STDMETHOD(FindFirst) (THIS_ LPTSTR pszPath, int cchMax) PURE;
    STDMETHOD(FindNext) (THIS_ LPTSTR pszPath, int cchMax) PURE;
};

// Events for UpdateOnEvent member function
#define UOE_CONFIGCHANGED       1
#define UOE_QUERYCHANGECONFIG   2

// Flags for AddObject
#define AOF_DEFAULT             0x0000
#define AOF_UPDATEONREPLACE     0x0001
#define AOF_FILTERPROMPT        0x0002

// Notify events
#define NOE_RENAME              1L
#define NOE_RENAMEFOLDER        2L
#define NOE_CREATE              3L
#define NOE_CREATEFOLDER        4L
#define NOE_DELETE              5L
#define NOE_DELETEFOLDER        6L
#define NOE_DIRTY               7L
#define NOE_DIRTYFOLDER         8L
#define NOE_DIRTYALL            9L

// Flags that are returned by Notify member function
#define NF_REDRAWWINDOW     0x0001
#define NF_ITEMMARKED       0x0002

// Flags for GetExtraInfo                wParam        lParam
#define GEI_ROOT            1       //   cchBuf         pszBuf
#define GEI_ORIGIN          2       //   cchBuf         pszBuf
#define GEI_STATUS          3       //   cchBuf         pszBuf
#define GEI_DELAYHANDLE     4       //     --           phandle
#define GEI_DATABASENAME    5       //   cchBuf         pszBuf

typedef IBriefcaseStg *   LPBRIEFCASESTG;

// Special briefcase object struct
//
typedef struct _BriefObj
    {
    UINT    cbSize;             // size of allocated struct
    UINT    ibFileList;         // offset of file list in struct
    UINT    ibBriefPath;        // offset of briefcase path in struct
    UINT    cItems;             // count of file-system objects
    UINT    cbListSize;         // size of file list
    TCHAR   data[1];            // data
    } BriefObj, * PBRIEFOBJ;

// Helper macros for briefcase object struct
#define BOBriefcasePath(pbo)    ((LPTSTR)((LPBYTE)(pbo) + (pbo)->ibBriefPath))
#define BOFileList(pbo)         ((LPTSTR)((LPBYTE)(pbo) + (pbo)->ibFileList))
#define BOFileCount(pbo)        ((pbo)->cItems)
#define BOFileListSize(pbo)     ((pbo)->cbListSize)

// Clipboard format for above struct
//
#define CFSTR_BRIEFOBJECT  TEXT("Briefcase File Object")

#endif // _BRFCASEP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\browseui.h ===
// #include <shlobj.h> or <shellapi.h> before this to get the right
// BROWSEUIAPI macro definitions.
#ifdef BROWSEUIAPI

#ifndef _BROWSEUI_H_
#define _BROWSEUI_H_

#include <iethread.h>
#include "fldset.h"

BROWSEUIAPI SHOpenNewFrame(LPITEMIDLIST pidlNew, ITravelLog *ptl, DWORD dwBrowserIndex, UINT uFlags);

BROWSEUIAPI_(BOOL) SHOpenFolderWindow(IETHREADPARAM* pieiIn);
BROWSEUIAPI_(BOOL) SHParseIECommandLine(LPCWSTR * ppszCmdLine, IETHREADPARAM * piei);
BROWSEUIAPI_(IETHREADPARAM*) SHCreateIETHREADPARAM(LPCWSTR pszCmdLineIn, int nCmdShowIn, ITravelLog *ptlIn, IEFreeThreadedHandShake* piehsIn);
BROWSEUIAPI_(IETHREADPARAM*) SHCloneIETHREADPARAM(IETHREADPARAM* pieiIn);
BROWSEUIAPI_(void) SHDestroyIETHREADPARAM(IETHREADPARAM* piei);
#ifndef _SHELL32_   // shell32 has its own implementation of this function
BROWSEUIAPI_(BOOL) SHCreateFromDesktop(PNEWFOLDERINFO pfi);
#endif // _SHELL32_
// Exported from browseui, but also in shell\lib\brutil.cpp -- why?
STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl, LPWSTR pszDisplayNameW, DWORD cchDisplayName);

//
// The following four apis are exported for use by the channel oc (shdocvw).
// If the channel oc is moved into browseui these protoypes can be removed.
//
BROWSEUIAPI_(LPITEMIDLIST) Channel_GetFolderPidl(void);
BROWSEUIAPI_(IDeskBand *) ChannelBand_Create(LPCITEMIDLIST pidlDefault);
#ifndef _SHELL32_   // shell32 has its own implementation these functions
BROWSEUIAPI_(void) Channels_SetBandInfoSFB(IUnknown* punkBand);
BROWSEUIAPI IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi);
#endif // _SHELL32_
//
// Exported to support IE4 channel quick launch button.
//
BROWSEUIAPI_(HRESULT) Channel_QuickLaunch(void);

// NOTE: this export is new to IE5, so it can move to browseui
// along with the rest of this proxy desktop code
BROWSEUIAPI_(BOOL) SHOnCWMCommandLine(LPARAM lParam);

BROWSEUIAPI_(void) SHCreateSavedWindows(void);

BROWSEUIAPI SHCreateBandForPidl(LPCITEMIDLIST pidl, IUnknown** ppunk, BOOL fAllowBrowserBand);

BROWSEUIAPI_(DWORD) IDataObject_GetDeskBandState(IDataObject *pdtobj);

//-------------------------------------------------------------------------
//
// Default folder settings
//
//  Make sure to keep INIT_DEFFOLDERSETTINGS in sync.
//
//  dwDefRevCount is used to make sure that "set as settings for all new
//  folders" works.  When settings are loaded from the cache, we check
//  the dwDefRevCount.  If it's different from the one stored as the
//  global settings then it means that somebody changed the global settings
//  since we saved our settings, so we chuck our settings and use the
//  global settings.

typedef struct {
    BOOL bDefStatusBar : 1;     // win95
    BOOL bDefToolBarSingle : 1; // win95
    BOOL bDefToolBarMulti : 1;  // win95
    BOOL bUseVID : 1;           // nash.1

    UINT uDefViewMode;          // win95
    UINT fFlags;                // nash.0 - additional flags that get or'ed in
    SHELLVIEWID vid;            // nash.1

    DWORD dwStructVersion;      // nash.2
    DWORD dwDefRevCount;        // nash.3 - Rev count of the default folder settings

    DWORD dwViewPriority;       // whistler - view priority so we can tell the difference between "all like this" and "reset"

} DEFFOLDERSETTINGS;

typedef struct {
    BOOL bDefStatusBar : 1;     // win95
    BOOL bDefToolBarSingle : 1; // win95
    BOOL bDefToolBarMulti : 1;  // win95
    BOOL bUseVID : 1;           // nash.1

    UINT uDefViewMode;          // win95
    UINT fFlags;                // nash.0 - additional flags that get or'ed in
    SHELLVIEWID vid;            // nash.1

    DWORD dwStructVersion;      // nash.2
    DWORD dwDefRevCount;        // nash.3 - Rev count of the default folder settings
} DEFFOLDERSETTINGS_W2K;

#define DFS_NASH_VER 3
#define DFS_WHISTLER_VER 4
#define DFS_CURRENT_VER 4
#define DFS_VID_Default VID_WebView

//
//  This macro is used to initialize the default `default folder settings'.
//
#define INIT_DEFFOLDERSETTINGS                          \
    {                                                   \
        !(IsOS(OS_WHISTLERORGREATER) && (IsOS(OS_PERSONAL) || IsOS(OS_PROFESSIONAL))),           /* bDefStatusBar        */      \
        TRUE,           /* bDefToolBarSingle    */      \
        FALSE,          /* bDefToolBarMulti     */      \
        TRUE,           /* bUseVID              */      \
        FVM_ICON,       /* uDefViewMode         */      \
        0              ,/* fFlags               */      \
        { 0, 0, 0, { 0, 0,  0,  0,  0,  0,  0,  0 } }, /* vid                  */      \
        DFS_CURRENT_VER,/* dwStructVersion      */      \
        0,              /* dwDefRevCount        */      \
        VIEW_PRIORITY_CACHEMISS /*dwViewPriority*/      \
    }                                                   \

#undef  INTERFACE
#define INTERFACE   IGlobalFolderSettings

DECLARE_INTERFACE_(IGlobalFolderSettings, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IGlobalFolderSettings methods ***
    STDMETHOD(Get)(THIS_ DEFFOLDERSETTINGS *pdfs, int cbDfs) PURE;
    STDMETHOD(Set)(THIS_ const DEFFOLDERSETTINGS *pdfs, int cbDfs, UINT flags) PURE;
};

//
//  Flags for IGlobalFolderSettings::Set
//
#define GFSS_SETASDEFAULT   0x0001  // These settings become default
#define GFSS_VALID          0x0001  // Logical-or of all valid flags

#ifndef _SHELL32_   // shell32 has its own implementation these functions
// FEATURE these two are TEMPORARILY exported for the favorites to shdocvw split
BROWSEUIAPI_(HRESULT) SHGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl, DWORD *pdwAttribs);
BROWSEUIAPI_(BOOL)    GetInfoTip(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax);
#endif // _SHELL32_

int SHDosDateTimeToVariantTime(unsigned short wDosDate, unsigned short wDosTime, VARIANT * pvtime);
int SHVariantTimeToDosDateTime(const VARIANT * pvtime, unsigned short * pwDosDate, unsigned short * pwDosTime);
int SHVariantTimeToSystemTime(const VARIANT * pvtime, SYSTEMTIME * pst);

#define REG_MEDIA_STR           TEXT("Software\\Microsoft\\Internet Explorer\\Media")
#define REG_WMP8_STR            TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\{6BF52A52-394A-11d3-B153-00C04F79FAA6}")

#endif // _BROWSEUI_H_

#endif // BROWSEUIAPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\bands.h ===
#ifndef BANDS_H_
#define BANDS_H_

#include "cowsite.h"

// this is a virtual class!
class CToolBand : public IDeskBand
                , public CObjectWithSite
                , public IInputObject
                , public IPersistStream
                , public IOleCommandTarget
                , public IServiceProvider
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IPersistStreamInit methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID) = 0;
    virtual STDMETHODIMP IsDirty(void);
    virtual STDMETHODIMP Load(IStream *pStm) = 0;
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) = 0;
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dwReserved);
    virtual STDMETHODIMP ResizeBorderDW(LPCRECT prcBorder,
                                             IUnknown* punkToolbarSite,
                                             BOOL fReserved);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi) PURE;

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

protected:
    CToolBand();
    virtual ~CToolBand();

    HRESULT _BandInfoChanged();

    int         _cRef;
    HWND        _hwnd;
    HWND        _hwndParent;
    //IUnknown* CObjectWithSite::_punkSite;
    BOOL        _fCanFocus:1;   // we accept focus (see UIActivateIO)
    DWORD       _dwBandID;
};


IDeskBand* CBrowserBand_Create(LPCITEMIDLIST pidl);
IDeskBand* CSearchBand_Create();

#define CX_FILENAME_AVG    (6 * 12)    // '8.3' name in 'typical' font (approx)






class CToolbarBand: public CToolBand,
                    public IWinEventHandler
{
public:
    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

protected:
    HRESULT _PushChevron(BOOL bLast);
    LRESULT _OnHotItemChange(LPNMTBHOTITEM pnmtb);
    virtual LRESULT _OnNotify(LPNMHDR pnmh);
};



#endif  // BANDS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\brutil.cpp ===
/*
NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 

This file is #include'd in browseui\ and shdocvw\ util.cpp. these are too small
to add an extra dependency, so they're just shared. ideally, these should move
to shlwapi or comctl32 or some lib or ...

NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE NOTE 
*/

#include "ccstock2.h"
#include "mluisupp.h"
#include "richedit.h" //for charformat2

STDAPI_(BOOL) IsBrowseNewProcess()
{
    return SHRegGetBoolUSValue(REGSTR_PATH_EXPLORER TEXT("\\BrowseNewProcess"), TEXT("BrowseNewProcess"), FALSE, FALSE);
}

// Should we run browser in a new process?
STDAPI_(BOOL) IsBrowseNewProcessAndExplorer()
{
    if (GetModuleHandle(TEXT("EXPLORER.EXE")))
        return IsBrowseNewProcess();

    return FALSE;   // Not in shell process so ignore browse new process flag
}

HRESULT _NavigateFrame(IUnknown *punkFrame, LPCTSTR pszPath, BOOL fIsInternetShortcut)
{
    HRESULT hr = E_OUTOFMEMORY;
    BSTR bstr = SysAllocStringT(pszPath);

    if (bstr)
    {
        if (fIsInternetShortcut)
        {
            IOleCommandTarget *pcmdt;
            hr = IUnknown_QueryService(punkFrame, SID_SHlinkFrame, IID_PPV_ARG(IOleCommandTarget, &pcmdt));
            if (SUCCEEDED(hr))
            {
                VARIANT varShortCutPath = {0};
                VARIANT varFlag = {0};

                varFlag.vt = VT_BOOL;
                varFlag.boolVal = VARIANT_TRUE;

                varShortCutPath.vt = VT_BSTR;
                varShortCutPath.bstrVal = bstr;

                hr = pcmdt->Exec(&CGID_Explorer, SBCMDID_IESHORTCUT, 0, &varShortCutPath, &varFlag);                
                pcmdt->Release();
            }
        }
        else
        {
            IWebBrowser2 *pwb;
            hr = IUnknown_QueryService(punkFrame, SID_SHlinkFrame, IID_PPV_ARG(IWebBrowser2, &pwb));
            if (SUCCEEDED(hr))
            {
                hr = pwb->Navigate(bstr, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
                hr = pwb->put_Visible(VARIANT_TRUE);
                pwb->Release();
            }
        }
        SysFreeString(bstr);
    }
    return hr;
}

//
// Take a path or an URL and create a shorcut to navigare to it
//
STDAPI IENavigateIEProcess(LPCTSTR pszPath, BOOL fIsInternetShortcut)
{
    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IUnknown, &punk));
    if (SUCCEEDED(hr))
    {
        hr = _NavigateFrame(punk, pszPath, fIsInternetShortcut);
        punk->Release();
    }
    
    return hr;
}
        


// If this is an internet shortcut (.url file), we want it to
// navigate using using the file name so the frame frame
// can read data beyond out of that file. this includes frame set
// navigation and data that script on the page may have stored.

/*
    Purpose : This function takes a path to a file. if that file is a .URL we try
    to navigate with that file name. this is because .URL files have extra data stored
    in them that we want to let script on the page get to. the exec we send here
    lets the frame know the .URL file that this came from

    Parameters : file name of .URL file (maybe) : In param
    pUnk :       Pointer to Object from which you can get the IOleCommandTarget

  returns:
    TRUE    handled
    FALSE   not handled, file might not be a .URL
*/

STDAPI NavFrameWithFile(LPCTSTR pszPath, IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    LPTSTR pszExt = PathFindExtension(pszPath);
    // HACK: we hard code .URL. this should be a property of the file type
    if (0 == StrCmpI(pszExt, TEXT(".url")))
    {
#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
        if (IsBrowseNewProcessAndExplorer())
            hr = IENavigateIEProcess(pszPath, TRUE);
        else
#endif
            hr = _NavigateFrame(punk, pszPath, TRUE);
    }

    return hr;
}

// get the win32 file system name (path) for the item
// and optional attributes
//
// pdwAttrib may be NULL
// in/out:
//      pdwAttrib   may be NULL, attributes to query on the item

STDAPI GetPathForItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszPath, DWORD *pdwAttrib)
{
    HRESULT hres = E_FAIL;
    DWORD dwAttrib;

    if (pdwAttrib == NULL)
    {
        pdwAttrib = &dwAttrib;
        dwAttrib = SFGAO_FILESYSTEM;
    }
    else
        *pdwAttrib |= SFGAO_FILESYSTEM;

    if (SUCCEEDED(psf->GetAttributesOf(1, &pidl, pdwAttrib)) &&
        (*pdwAttrib & SFGAO_FILESYSTEM))
    {
        STRRET str;
        hres = psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING, &str);
        if (SUCCEEDED(hres))
            StrRetToBuf(&str, pidl, pszPath, MAX_PATH);
    }
    return hres;
}

STDAPI EditBox_TranslateAcceleratorST(LPMSG lpmsg)
{

    switch (lpmsg->message) {
    case WM_KEYUP:      // eat these (if we process corresponding WM_KEYDOWN)
    case WM_KEYDOWN:    // process these
        if (lpmsg->wParam != VK_TAB)
        {
            // all keydown messages except for the tab key should go straight to
            // the edit control -- unless the Ctrl key is down, in which case there
            // are 9 messages that should go straight to the edit control
#ifdef DEBUG
            if (lpmsg->wParam == VK_CONTROL)
                return S_FALSE;
#endif

            if (GetKeyState(VK_CONTROL) & 0x80000000)
            {
                switch (lpmsg->wParam)
                {
                case VK_RIGHT:
                case VK_LEFT:
                case VK_UP:
                case VK_DOWN:
                case VK_HOME:
                case VK_END:
                case VK_F4:
                case VK_INSERT:
                case VK_DELETE:
                case 'C':
                case 'X':
                case 'V':
                case 'A':
                case 'Z':
                    // these Ctrl+key messages are used by the edit control
                    // send 'em straight there
                    break;

                default:
                    return(S_FALSE);
                }
            }
            else
            {
                switch(lpmsg->wParam)
                {
                case VK_F5: // for refresh
                case VK_F6: // for cycle focus
                    return(S_FALSE);
                }
            }

            // Note that we return S_OK.
            goto TranslateDispatch;
        }
        break;


    case WM_CHAR:
TranslateDispatch:
        TranslateMessage(lpmsg);
        DispatchMessage(lpmsg);
        return(S_OK);
    }

    return S_FALSE;
}

// NOTE: dupe with shell32 util.cpp function
// like OLE GetClassFile(), but it only works on ProgID\CLSID type registration
// not real doc files or pattern matched files
//
STDAPI _CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid)
{
    TCHAR szProgID[80];
    DWORD cb = SIZEOF(szProgID);
    if (SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szProgID, &cb) == ERROR_SUCCESS)
    {
        TCHAR szCLSID[80];

        StrCatBuff(szProgID, TEXT("\\CLSID"), ARRAYSIZE(szProgID));
        cb = SIZEOF(szCLSID);

        if (SHGetValue(HKEY_CLASSES_ROOT, szProgID, NULL, NULL, szCLSID, &cb) == ERROR_SUCCESS)
        {
            return GUIDFromString(szCLSID, pclsid) ? S_OK : E_FAIL;
        }
    }
    return E_FAIL;
}

#if 0 // not used yet
// IShellLink is #defined to IShellLinkA or IShellLinkW depending on compile flags,
// bug Win95 did not support IShellLinkW.  So call this function instead and you
// get the correct results regardless of what platform you are running on.
// REVIEW: In fact, we probably want these for ALL IShellLink functions...
//
LWSTDAPI IShellLink_GetPathA(IUnknown *punk, LPSTR pszBuf, UINT cchBuf, DWORD dwFlags)
{
    HRESULT hres = E_INVALIDARG;
    
    RIPMSG(cchBuf && pszBuf && IS_VALID_WRITE_BUFFER(pszBuf, char, cchBuf), "IShellLink_GetPathA: callre passed bad pszBuf/cchBuf");
    DEBUGWhackPathBufferA(pszBuf, cchBuf);

    if (cchBuf && pszBuf)
    {
        // In case of gross failure, NULL output buffer
        *pszBuf = 0;

        IShellLinkA * pslA;
        hres = punk->QueryInterface(IID_IShellLinkA, (void**)&pslA);
        if (SUCCEEDED(hres))
        {
            hres = pslA->GetPath(pszBuf, cchBuf, NULL, dwFlags);
            pslA->Release();
        }
        else if (FAILED(hres))
        {
#ifdef UNICODE
            IShellLinkW *pslW;
            hres = punk->QueryInterface(IID_IShellLinkW, (void**)&pslW);
            if (SUCCEEDED(hres))
            {
                WCHAR wszPath[MAX_BUF];
                LPWSTR pwszBuf = wszPath;
                UINT cch = ARRAYSIZE(wszPath);

                // Our stack buffer is too small, allocate one of the output buffer size
                if (cchBuf > cch)
                {
                    LPWSTR pwsz = LocalAlloc(LPTR, cchBuf * sizeof(WCHAR));
                    if (pwsz)
                    {
                        pwszBuf = pwsz;
                        cch = cchBuf;
                    }
                }

                hres = pslW->GetPath(pwszBuf, cch, NULL, dwFlags);
                if (SUCCEEDED(hres))
                {
                    SHUnicodeToAnsi(pwszBuf, pszBuf, cchBuf);
                }

                pslW->Release();
            }
#endif
        }
    }

    return hres;
}

LWSTDAPI IShellLink_GetPathW(IUnknown *punk, LPWSTR pwszBuf, UINT cchBuf, DWORD dwFlags)
{
    HRESULT hres = E_INVALIDARG;
    
    RIPMSG(cchBuf && pwszBuf && IS_VALID_WRITE_BUFFER(pwszBuf, WCHAR, cchBuf), "IShellLink_GetPathW: caller passed bad pwszBuf/cchBuf");
    DEBUGWhackPathBufferW(pwszBuf, cchBuf);

    if (cchBuf && pwszBuf)
    {
        // In case of gross failure, NULL output buffer
        *pwszBuf = 0;

#ifdef UNICODE
        IShellLinkW * pslW;
        hres = punk->QueryInterface(IID_IShellLinkW, (void**)&pslW);
        if (SUCCEEDED(hres))
        {
            hres = pslW->GetPath(pszBuf, cchBuf, NULL, dwFlags);
            pslW->Release();
        }
        else if (FAILED(hres))
#endif
        {
            IShellLinkA *pslA;
            hres = punk->QueryInterface(IID_IShellLinkA, (void**)&pslA);
            if (SUCCEEDED(hres))
            {
                char szPath[MAX_BUF];
                LPSTR pszBuf = szPath;
                UINT cch = ARRAYSIZE(szPath);

                // Our stack buffer is too small, allocate one of the output buffer size
                if (cchBuf > cch)
                {
                    LPSTR psz = LocalAlloc(LPTR, cchBuf * sizeof(char));
                    if (psz)
                    {
                        pszBuf = psz;
                        cch = cchBuf;
                    }
                }

                hres = pslA->GetPath(pszBuf, cch, NULL, dwFlags);
                if (SUCCEEDED(hres))
                {
                    SHAnsiToUnicode(pszBuf, pwszBuf, cchBuf);
                }

                pslA->Release();
            }
        }
    }

    return hres;
}
#endif // 0

HRESULT IShellLinkAorW_GetPath(IShellLinkA *pslA, LPTSTR pszBuf, UINT cchBuf, DWORD dwFlags)
{
    HRESULT hres = E_FAIL;

// If we store the string unicode, we could be losing file information by asking
// through A version. Be unicode friendly and use the W version if it exists
//
#ifdef UNICODE
    IShellLinkW *pslW;
    hres = pslA->QueryInterface(IID_PPV_ARG(IShellLinkW, &pslW));
    if (SUCCEEDED(hres))
    {
        hres = pslW->GetPath(pszBuf, cchBuf, NULL, dwFlags);
        pslW->Release();
    }
#endif

    if (FAILED(hres))
    {
        char szBuf[MAX_URL_STRING];  // BOGUS, but this is a common size used, perhaps we should LocalAlloc...

        cchBuf = ARRAYSIZE(szBuf);

        hres = pslA->GetPath(szBuf, cchBuf, NULL, dwFlags);

        SHAnsiToTChar(szBuf, pszBuf, cchBuf);
    }

    return hres;
}

STDAPI GetLinkTargetIDList(LPCTSTR pszPath, LPTSTR pszTarget, DWORD cchTarget, LPITEMIDLIST *ppidl)
{
    IShellLinkA *psl;
    CLSID clsid;
    HRESULT hres;

    *ppidl = NULL;  // assume failure

    // WARNING: we really should call GetClassFile() but this could
    // slow this down a lot... so chicken out and just look in the registry

    if (FAILED(_CLSIDFromExtension(PathFindExtension(pszPath), &clsid)))
        clsid = CLSID_ShellLink;        // assume it's a shell link

    hres = CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &psl));
    if (SUCCEEDED(hres))
    {
        IPersistFile *ppf;
        hres = psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf));
        if (SUCCEEDED(hres))
        {
            WCHAR wszPath[MAX_PATH];

            SHTCharToUnicode(pszPath, wszPath, ARRAYSIZE(wszPath));
            hres = ppf->Load(wszPath, 0);
            if (SUCCEEDED(hres))
            {
                psl->GetIDList(ppidl);

                if (*ppidl == NULL)
                    hres = E_FAIL;  // NULL pidl is valid, but
                                    // lets not return that to clients
                if (pszTarget)
                {
                    IShellLinkAorW_GetPath(psl, pszTarget, cchTarget, 0);
                }
            }
            ppf->Release();
        }
        psl->Release();
    }

    // pszPath might == pszTarget so don't null out on entry always
    if (FAILED(hres) && pszTarget)
        *pszTarget = 0;
    return hres;
}


STDAPI_(void) PathToDisplayNameW(LPCTSTR pszPath, LPTSTR pszDisplayName, UINT cchDisplayName)
{
    SHFILEINFO sfi;
    if (SHGetFileInfo(pszPath, 0, &sfi, SIZEOF(sfi), SHGFI_DISPLAYNAME))
    {
        StrCpyN(pszDisplayName, sfi.szDisplayName, cchDisplayName);
    }
    else
    {
        StrCpyN(pszDisplayName, PathFindFileName(pszPath), cchDisplayName);
        PathRemoveExtension(pszDisplayName);
    }
}


STDAPI_(void) PathToDisplayNameA(LPSTR pszPathA, LPSTR pszDisplayNameA, int cchDisplayName)
{
    SHFILEINFOA sfi;
    if (SHGetFileInfoA(pszPathA, 0, &sfi, SIZEOF(sfi), SHGFI_DISPLAYNAME))
    {
        StrCpyNA(pszDisplayNameA, sfi.szDisplayName, cchDisplayName);
    }
    else
    {
        pszPathA = PathFindFileNameA(pszPathA);
        StrCpyNA(pszDisplayNameA, pszPathA, cchDisplayName);
        PathRemoveExtensionA(pszDisplayNameA);
    }
}

void* DataObj_GetDataOfType(IDataObject* pdtobj, UINT cfType, STGMEDIUM *pstg)
{
    void * pret = NULL;
    FORMATETC fmte = {(CLIPFORMAT)cfType, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    if (pdtobj->GetData(&fmte, pstg) == S_OK)
    {
        pret = GlobalLock(pstg->hGlobal);
        if (!pret)
            ReleaseStgMedium(pstg);
    }
    return pret;
}

void ReleaseStgMediumHGLOBAL(STGMEDIUM *pstg)
{
    ASSERT(pstg->tymed == TYMED_HGLOBAL);

    GlobalUnlock(pstg->hGlobal);
    ReleaseStgMedium(pstg);
}


// this looks for the file descriptor format to get the display name of a data object
STDAPI DataObj_GetNameFromFileDescriptor(IDataObject *pdtobj, LPWSTR pszDisplayName, UINT cch)
{
    HRESULT hres = E_FAIL;
    STGMEDIUM mediumFGD;

    InitClipboardFormats();
    FILEGROUPDESCRIPTORW * pfgd = (FILEGROUPDESCRIPTORW *)DataObj_GetDataOfType(pdtobj, g_cfFileDescW, &mediumFGD);
    if (pfgd)
    {
        if (pfgd->cItems > 0)
        {
            LPFILEDESCRIPTORW pfd = &(pfgd->fgd[0]);
            SHUnicodeToTChar(pfd->cFileName, pszDisplayName, cch);
            hres = S_OK;
        }
        ReleaseStgMediumHGLOBAL(&mediumFGD);
    }
    else
    {
        FILEGROUPDESCRIPTORA * pfgd = (FILEGROUPDESCRIPTORA *)DataObj_GetDataOfType(pdtobj, g_cfFileDescA, &mediumFGD);
        if (pfgd)
        {
            if (pfgd->cItems > 0)
            {
                LPFILEDESCRIPTORA pfd = &(pfgd->fgd[0]);
                SHAnsiToTChar(pfd->cFileName, pszDisplayName, cch);
                hres = S_OK;
            }
            ReleaseStgMediumHGLOBAL(&mediumFGD);
        }
    }
    return hres;
}

STDAPI SHPidlFromDataObject2(IDataObject *pdtobj, LPITEMIDLIST * ppidl)
{
    HRESULT hres = E_FAIL;
    STGMEDIUM medium;

    InitClipboardFormats();
    void *pdata = DataObj_GetDataOfType(pdtobj, g_cfHIDA, &medium);
    if (pdata)
    {
        *ppidl = IDA_ILClone((LPIDA)pdata, 0);
        if (*ppidl)
            hres = S_OK;
        else
            hres = E_OUTOFMEMORY;
        ReleaseStgMediumHGLOBAL(&medium);
    }

    return hres;
}

STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl,
                           LPWSTR pszDisplayNameW, DWORD cchDisplayName)
{
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM medium;

    *ppidl = NULL;

    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (hres == S_OK)
    {
        // This string is also used to store an URL in case it's an URL file
        TCHAR szPath[MAX_URL_STRING];
        hres = E_FAIL;
        if (DragQueryFile((HDROP)medium.hGlobal, 0, szPath, ARRAYSIZE(szPath)))
        {
            SHFILEINFO sfi;
            SHGetFileInfo(szPath, 0, &sfi, SIZEOF(sfi), SHGFI_ATTRIBUTES | SHGFI_DISPLAYNAME);

            if (pszDisplayNameW)
                SHTCharToUnicode(sfi.szDisplayName, pszDisplayNameW, MAX_PATH);

            if (sfi.dwAttributes & SFGAO_LINK)
                hres = GetLinkTargetIDList(szPath, szPath, ARRAYSIZE(szPath), ppidl);

            if (FAILED(hres))
                hres = IECreateFromPath(szPath, ppidl);
        }
        ReleaseStgMedium(&medium);
    }
    else
    {
        hres = SHPidlFromDataObject2(pdtobj, ppidl);
        if (FAILED(hres))
        {
            void *pdata = DataObj_GetDataOfType(pdtobj, g_cfURL, &medium);
            if (pdata)
            {
                LPSTR pszPath = (LPSTR)pdata;
                if (pszDisplayNameW) 
                {
                    if (FAILED(DataObj_GetNameFromFileDescriptor(pdtobj, pszDisplayNameW, cchDisplayName))) 
                    {
                        CHAR szDisplayNameA[MAX_URL_STRING];
                        ASSERT(cchDisplayName < MAX_URL_STRING);
                        SHUnicodeToAnsi(pszDisplayNameW, szDisplayNameA, cchDisplayName);
                        PathToDisplayNameA(pszPath, szDisplayNameA, cchDisplayName);
                    }
                }
                hres = IECreateFromPathA(pszPath, ppidl);
                ReleaseStgMediumHGLOBAL(&medium);
            }
        }
    }
    return hres;
}


// BharatS - Perhaps all the stuff below here should be moved to shlwapi after beta 2 ?

typedef struct _broadcastmsgparams
{
    BOOL fSendMessage; // If true - we call SendMessageTimeout
    UINT uTimeout; // Only Matters if fSendMessage is set
    UINT uMsg;
    WPARAM wParam;
    LPARAM lParam;
} BROADCAST_MSG_PARAMS;

BOOL CALLBACK EnumShellIEWindowsProc(  
    HWND hwnd,      // handle to parent window
    LPARAM lParam   // application-defined value - this has the info needed for posting/sending the message 
)
{
    BROADCAST_MSG_PARAMS *pParams = (BROADCAST_MSG_PARAMS *)lParam;
    BOOL fRet = TRUE;

    if(IsExplorerWindow(hwnd) || IsFolderWindow(hwnd))
    {
        if(pParams->fSendMessage)
        {
            UINT  uTimeout = (pParams->uTimeout < 4000) ? pParams->uTimeout : 4000;
            LRESULT lResult;
            DWORD_PTR dwpResult;
            if (g_fRunningOnNT)
            {
                lResult = SendMessageTimeout(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam, SMTO_ABORTIFHUNG | SMTO_NORMAL, uTimeout, &dwpResult);
            }
            else
            {           
                lResult = SendMessageTimeoutA(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam, SMTO_ABORTIFHUNG | SMTO_NORMAL, uTimeout, &dwpResult);
            }
            fRet = BOOLIFY(lResult);
        }
        else
        {
            fRet = PostMessage(hwnd, pParams->uMsg, pParams->wParam, pParams->lParam);

        }
    }
    return fRet;

}

// PostShellIEBroadcastMessage is commented out since it is not used currentl
/*

STDAPI_(LRESULT)  PostShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{   
    BROADCAST_MSG_PARAMS MsgParam;

    MsgParam.uMsg = uMsg;
    MsgParam.wParam = wParam;
    MsgParam.lParam = lParam;
    MsgParam.fSendMessage = FALSE;
    
    return EnumWindows(EnumShellIEWindowsProc, (LPARAM)&MsgParam);
}
*/

//
// We can be hung if we use sendMessage, and you can not use pointers with asynchronous
// calls such as PostMessage or SendNotifyMessage.  So we resort to using a timeout.
// This function should be used to broadcast notification messages, such as WM_SETTINGCHANGE, 
// that pass pointers. (stevepro)
//
STDAPI_(LRESULT) SendShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, UINT uTimeout)
{
    // Note that each this timeout is applied to each window that we broadcast to 

    BROADCAST_MSG_PARAMS MsgParam;

    MsgParam.uMsg = uMsg;
    MsgParam.wParam = wParam;

#ifdef UNICODE
    CHAR szSection[MAX_PATH];
    
    if (!g_fRunningOnNT && (uMsg == WM_WININICHANGE) && (0 != lParam))
    {
        SHUnicodeToAnsi((LPCWSTR)lParam, szSection, ARRAYSIZE(szSection));
        lParam = (LPARAM)szSection;
    }
#endif

    MsgParam.lParam = lParam;
    MsgParam.fSendMessage = TRUE;
    MsgParam.uTimeout = uTimeout;

    return EnumWindows(EnumShellIEWindowsProc, (LPARAM)&MsgParam);
}

// Return the parent psf and relative pidl given a pidl.
STDAPI IEBindToParentFolder(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild)
{
    HRESULT hres;

    //
    //  if this is a rooted pidl and it is just the root
    //  then we can bind to the target pidl of the root instead
    //
    if (ILIsRooted(pidl) && ILIsEmpty(_ILNext(pidl)))
        pidl = ILRootedFindIDList(pidl);
        
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    
    if (pidlParent)
    {
        hres = IEBindToObject(pidlParent, ppsfParent);
        ILFree(pidlParent);
    }
    else
        hres = E_OUTOFMEMORY;

    if (ppidlChild)
        *ppidlChild = ILFindLastID(pidl);

    return hres;
}

STDAPI GetDataObjectForPidl(LPCITEMIDLIST pidl, IDataObject ** ppdtobj)
{
    HRESULT hres = E_FAIL;
    if (pidl)
    {
        IShellFolder *psfParent;
        LPCITEMIDLIST pidlChild;
        hres = IEBindToParentFolder(pidl, &psfParent, &pidlChild);
        if (SUCCEEDED(hres))
        {
            hres = psfParent->GetUIObjectOf(NULL, 1, &pidlChild, IID_PPV_ARG_NULL(IDataObject, ppdtobj));
            psfParent->Release();
        }
    }
    return hres;
}

// Is this pidl a Folder/Directory in the File System?
STDAPI_(BOOL) ILIsFileSysFolder(LPCITEMIDLIST pidl)
{
    if (!pidl)
        return FALSE;

    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_FILESYSTEM;
    HRESULT hr = IEGetAttributesOf(pidl, &dwAttributes);
    return SUCCEEDED(hr) && ((dwAttributes & (SFGAO_FOLDER | SFGAO_FILESYSTEM)) == (SFGAO_FOLDER | SFGAO_FILESYSTEM));
}


// HACKHACK HACKHACK
// the following functions are to work around the menu
// munging that happens in the shlwapi wrappers... when we're
// manipulating menus which are tracked by the system, the
// menu munging code in our shlwapi wrappers (necessary
// for xcp plugUI) trashes them since the system doesn't
// understand munged menus... hence the work arounds below.
// note that many of these functions are copies of the shlwapi
// *WrapW functions (minus the munging).

#undef LoadMenuW

// from winuser.h
EXTERN_C WINUSERAPI HMENU WINAPI LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);

STDAPI_(HMENU)
LoadMenu_PrivateNoMungeW(HINSTANCE hInstance, LPCWSTR lpMenuName)
{
    ASSERT(HIWORD64(lpMenuName) == 0);

    if (g_fRunningOnNT)
    {
        return LoadMenuW(hInstance, lpMenuName);
    }

    return LoadMenuA(hInstance, (LPCSTR) lpMenuName);
}

#define CP_ATOM         0xFFFFFFFF          /* not a string at all */
#undef InsertMenuW

// from winuser.h
EXTERN_C WINUSERAPI BOOL WINAPI InsertMenuW(IN HMENU hMenu, IN UINT uPosition, IN UINT uFlags, IN UINT_PTR uIDNewItem, IN LPCWSTR lpNewItem);

STDAPI_(BOOL) InsertMenu_PrivateNoMungeW(HMENU       hMenu,
                           UINT        uPosition,
                           UINT        uFlags,
                           UINT_PTR    uIDNewItem,
                           LPCWSTR     lpNewItem)
{
    if (g_fRunningOnNT)
    {
        return InsertMenuW(hMenu, uPosition, uFlags, uIDNewItem, lpNewItem);
    }

    char szMenuItem[CCH_MENUMAX];

    SHUnicodeToAnsiCP((uFlags & MFT_NONSTRING) ? CP_ATOM : CP_ACP,
                      lpNewItem,
                      szMenuItem,
                      ARRAYSIZE(szMenuItem));

    return InsertMenuA(hMenu, uPosition, uFlags, uIDNewItem, szMenuItem);
}

#ifndef NO_MLUI_IN_SHELL32
STDAPI_(HMENU) LoadMenuPopup_PrivateNoMungeW(UINT id)
{
    HINSTANCE hinst = MLLoadShellLangResources();

    HMENU hMenuSub = NULL;
    HMENU hMenu = LoadMenu_PrivateNoMungeW(hinst, MAKEINTRESOURCEW(id));
    if (hMenu)
    {
        hMenuSub = GetSubMenu(hMenu, 0);
        if (hMenuSub)
        {
            RemoveMenu(hMenu, 0, MF_BYPOSITION);
        }

        // note this calls the shlwapi wrapper (that handles
        // destroying munged menus) but it looks like
        // it's safe to do so.
        DestroyMenu(hMenu);
    }

    MLFreeLibrary(hinst);

    return hMenuSub;
}
#endif // NO_MLUI_IN_SHELL32

// determine if a path is just a filespec (contains no path parts)
//
// REVIEW: we may want to count the # of elements, and make sure
// there are no illegal chars, but that is probably another routing
// PathIsValid()
//
// in:
//      lpszPath    path to look at
// returns:
//      TRUE        no ":" or "\" chars in this path
//      FALSE       there are path chars in there
//
//

BOOL PathIsFilePathA(LPCSTR lpszPath)
{
#ifdef UNIX
    if (lpszPath[0] == '/')
#else
    if ((lpszPath[0] == '\\') || (lpszPath[1] == ':'))
#endif
        return TRUE;

    return IsFileUrl(lpszPath);
}

//
// PrepareURLForDisplay
//
//     Decodes without stripping file:// prefix
//
STDAPI_(BOOL) PrepareURLForDisplayA(LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut)
{
    if (PathIsFilePathA(psz))
    {
        if (IsFileUrl(psz))
            return SUCCEEDED(PathCreateFromUrlA(psz, pszOut, pcchOut, 0));

        StrCpyNA(pszOut, psz, *pcchOut);
        *pcchOut = lstrlenA(pszOut);
        return TRUE;
    }
    return SUCCEEDED(UrlUnescapeA((LPSTR)psz, pszOut, pcchOut, 0));
}

#undef InsertMenuW
#undef LoadMenuW

// from w95wraps.h
#define InsertMenuW                 InsertMenuWrapW
#define LoadMenuW                   LoadMenuWrapW

STDAPI SHTitleFromPidl(LPCITEMIDLIST pidl, LPTSTR psz, DWORD cch, BOOL fFullPath)
{
    // Tries to get a system-displayable string from a pidl.
    // (On Win9x and NT4, User32 doesn't support font-linking,
    // so we can't display non-system language strings as window
    // titles or menu items.  In those cases, we call this function
    // to grab the path/URL instead, which will likely be system-
    // displayable).

    UINT uType;

    *psz = NULL;
    TCHAR szName[MAX_URL_STRING];

    if (fFullPath)
        uType = SHGDN_FORPARSING;
    else
        uType = SHGDN_NORMAL;

    uType |= SHGDN_FORADDRESSBAR; 
    DWORD dwAttrib = SFGAO_LINK;

    HRESULT hr = IEGetNameAndFlags(pidl, uType, szName, SIZECHARS(szName), &dwAttrib);
    if (SUCCEEDED(hr))
    {
        if ((uType & SHGDN_FORPARSING) && (dwAttrib & SFGAO_LINK))
        {
            // folder shortcut special case
            IShellLinkA *psl;  // Use A version for W95.
            if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IShellLinkA, &psl))))
            {
                LPITEMIDLIST pidlTarget;
                if (SUCCEEDED(psl->GetIDList(&pidlTarget)) && pidlTarget)
                {
                    hr = IEGetNameAndFlags(pidlTarget, uType, szName, SIZECHARS(szName), NULL);
                    ILFree(pidlTarget);
                }
            }
        }
    }
    else
    {
        // didn't work, try the reverse
        uType ^= SHGDN_FORPARSING;  // flip the for parsing bit
        hr = IEGetNameAndFlags(pidl, uType, szName, SIZECHARS(szName), NULL);

        // some old namespaces get confused by all our funny bits...
        if (FAILED(hr))
        {
            hr = IEGetNameAndFlags(pidl, SHGDN_NORMAL, szName, SIZECHARS(szName), NULL);
        }
    }

    if (SUCCEEDED(hr))
    {
        SHRemoveURLTurd(szName);
        SHCleanupUrlForDisplay(szName);

        // HTTP URLs are not escaped because they come from the
        // user or web page which is required to create correctly
        // escaped URLs.  FTP creates then via results from the
        // FTP session, so their pieces (username, password, path)
        // need to be escaped when put in URL form.  However,
        // we are going to put that URL into the Caption Bar, and
        // and we want to unescape it because it's assumed to be
        // a DBCS name.  All of this is done because unescaped URLs
        // are pretty. (NT #1272882)
        if (URL_SCHEME_FTP == GetUrlScheme(szName))
        {
            CHAR szUrlTemp[MAX_BROWSER_WINDOW_TITLE];
            CHAR szUnEscaped[MAX_BROWSER_WINDOW_TITLE];
            DWORD cchSizeTemp = ARRAYSIZE(szUnEscaped);

            // This thunking stuff is necessary.  Unescaping won't
            // gell into DBCS chars unless it's in ansi.
            SHTCharToAnsi(szName, szUrlTemp, ARRAYSIZE(szUrlTemp));
            PrepareURLForDisplayA(szUrlTemp, szUnEscaped, &cchSizeTemp);
            SHAnsiToTChar(szUnEscaped, psz, cch);
        }
        else
        {
            StrCpyN(psz, szName, cch);
        }
    }

    return hr;
}

BOOL IsSpecialUrl(LPCWSTR pchURL)
{
    UINT uProt = GetUrlSchemeW(pchURL);
    return (URL_SCHEME_JAVASCRIPT == uProt || 
            URL_SCHEME_VBSCRIPT == uProt ||
            URL_SCHEME_ABOUT == uProt);
}

HRESULT DetectSpecialUrlHacks(PCWSTR pszUrl)
{
    HRESULT     hr = S_OK;
    if (IsSpecialUrl(pszUrl))
    {
        //
        // If this is javascript:, vbscript: or about:, we used to append the
        // url of this document so that on the other side we can
        // decide whether or not to allow script execution.
        //
        //  since we did this, there were exploits that would take advantage of this
        //  so we block those "exploit-like" URLs even though we dont use the security 
        //  context anymore.
        //
        //  we used to loop with CoInternetParseUrl(PARSE_ENCODE) which is the 
        //  same as CoInternetParseUrl(PARSE_UNESCAPE) due to a bug in URLMON's 
        //  original implementation.
        //
        //  Unescaping is always lossy, and almost guarantees some kind of bug.
        //  therefore we no longer unescape here, although there may be some kind of compatibility issue.
        //
        if (StrChrW(pszUrl, L'\1')
        ||  StrStrW(pszUrl, L"%00")
        ||  StrStrW(pszUrl, L"%01"))
        {
            hr = E_ACCESSDENIED;
        }
    }

    return hr;
}

HRESULT WrapSpecialUrlFlat(LPWSTR pszUrl, DWORD cchUrl)
{
    return DetectSpecialUrlHacks(pszUrl);
}

//encode any incoming %1 so that people can't spoof our domain security code
HRESULT WrapSpecialUrl(BSTR * pbstrUrl)
{
    return DetectSpecialUrlHacks(*pbstrUrl);
}

STDAPI GetBrowserFrameOptions(IUnknown *punkFolder, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    HRESULT hr = E_INVALIDARG;

    *pdwOptions = BFO_NONE;
    if (punkFolder)
    {
        IBrowserFrameOptions *pbfo;
        hr = punkFolder->QueryInterface(IID_PPV_ARG(IBrowserFrameOptions, &pbfo));
        if (SUCCEEDED(hr))
        {
            hr = pbfo->GetFrameOptions(dwMask, pdwOptions);
            pbfo->Release();
        }
    }

    return hr;
}

STDAPI GetBrowserFrameOptionsPidl(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions)
{
    HRESULT hr = E_INVALIDARG;

    *pdwOptions = BFO_NONE;
    if (pidl)
    {
        IBrowserFrameOptions *pbfo;
        hr = IEBindToObjectEx(pidl, NULL, IID_PPV_ARG(IBrowserFrameOptions, &pbfo));
        if (SUCCEEDED(hr) && pbfo)
        {
            hr = pbfo->GetFrameOptions(dwMask, pdwOptions);
            pbfo->Release();
        }
    }

    return hr;
}

// Return TRUE only if all the bits in dwMask are set.
STDAPI_(BOOL) IsBrowserFrameOptionsSet(IN IShellFolder * psf, IN BROWSERFRAMEOPTIONS dwMask)
{
    BOOL fSet = FALSE;
    BROWSERFRAMEOPTIONS dwOptions = 0;

    if (SUCCEEDED(GetBrowserFrameOptions(psf, dwMask, &dwOptions)) &&
        (dwOptions == dwMask))
    {
        fSet = TRUE;
    }

    return fSet;
}


// Return TRUE only if all the bits in dwMask are set.
STDAPI_(BOOL) IsBrowserFrameOptionsPidlSet(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask)
{
    BOOL fSet = FALSE;
    BROWSERFRAMEOPTIONS dwOptions = 0;

    if (SUCCEEDED(GetBrowserFrameOptionsPidl(pidl, dwMask, &dwOptions)) &&
        (dwOptions == dwMask))
    {
        fSet = TRUE;
    }

    return fSet;
}


STDAPI_(BOOL) IsFTPFolder(IShellFolder * psf)
{
    BOOL fIsFTPFolder = FALSE;
    CLSID clsid;

    if (psf && SUCCEEDED(IUnknown_GetClassID(psf, &clsid)))
    {
        // Is this an FTP Folder?
        if (IsEqualIID(clsid, CLSID_FtpFolder))
            fIsFTPFolder = TRUE;
        else
        {
            // Not directly, but let's see if it is an Folder Shortcut to
            // an FTP Folder
            if (IsEqualIID(clsid, CLSID_FolderShortcut))
            {
                IShellLinkA * psl;
                HRESULT hr = psf->QueryInterface(IID_PPV_ARG(IShellLinkA, &psl));

                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;

                    hr = psl->GetIDList(&pidl);
                    if (SUCCEEDED(hr))
                    {
                        IShellFolder * psfTarget;

                        hr = IEBindToObject(pidl, &psfTarget);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(IUnknown_GetClassID(psfTarget, &clsid)) &&
                                IsEqualIID(clsid, CLSID_FtpFolder))
                            {
                                fIsFTPFolder = TRUE;
                            }

                            psfTarget->Release();
                        }

                        ILFree(pidl);
                    }

                    psl->Release();
                }
            }
        }
    }

    return fIsFTPFolder;
}

//+---------------------------------------------------------------------------
//
//  Function:   DrawFocusRectangle
//
//  Synopsis:   draws the focus rectangle for the edit control
//
//----------------------------------------------------------------------------
void DrawFocusRectangle (HWND hwnd, HDC hdc)
{
    RECT        rect;
    BOOL        fReleaseDC = FALSE;

    if ( hdc == NULL )
    {
        hdc = GetDC(hwnd);
        if ( hdc == NULL )
        {
            return;
        }
        fReleaseDC = TRUE;
    }

    GetClientRect(hwnd, &rect);
    DrawFocusRect(hdc, &rect);

    if ( fReleaseDC == TRUE )
    {
        ReleaseDC(hwnd, hdc);
    }
}

typedef struct {
    LPSTR   psz;
    LPCWSTR pwsz;
    LONG    byteoffset;
    BOOL    fStreamIn;
} STREAMIN_HELPER_STRUCT;

DWORD CALLBACK SetRicheditTextWCallback(
    DWORD_PTR dwCookie, // application-defined value
    LPBYTE  pbBuff,     // pointer to a buffer
    LONG    cb,         // number of bytes to read or write
    LONG    *pcb        // pointer to number of bytes transferred
)
{
    STREAMIN_HELPER_STRUCT *pHelpStruct = (STREAMIN_HELPER_STRUCT *) dwCookie;
    LONG  lRemain = ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);

    if (pHelpStruct->fStreamIn)
    {
        //
        // The whole string can be copied first time
        //
        if ((cb >= (LONG) (wcslen(pHelpStruct->pwsz) * sizeof(WCHAR))) && (pHelpStruct->byteoffset == 0))
        {
            memcpy(pbBuff, pHelpStruct->pwsz, wcslen(pHelpStruct->pwsz) * sizeof(WCHAR));
            *pcb = wcslen(pHelpStruct->pwsz) * sizeof(WCHAR);
            pHelpStruct->byteoffset = *pcb;
        }
        //
        // The whole string has been copied, so terminate the streamin callbacks
        // by setting the num bytes copied to 0
        //
        else if (((LONG)(wcslen(pHelpStruct->pwsz) * sizeof(WCHAR))) <= pHelpStruct->byteoffset)
        {
            *pcb = 0;
        }
        //
        // The rest of the string will fit in this buffer
        //
        else if (cb >= (LONG) ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset))
        {
            memcpy(
                pbBuff,
                ((BYTE *)pHelpStruct->pwsz) + pHelpStruct->byteoffset,
                ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset));
            *pcb = ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);
            pHelpStruct->byteoffset += ((wcslen(pHelpStruct->pwsz) * sizeof(WCHAR)) - pHelpStruct->byteoffset);
        }
        //
        // copy as much as possible
        //
        else
        {
            memcpy(
                pbBuff,
                ((BYTE *)pHelpStruct->pwsz) + pHelpStruct->byteoffset,
                cb);
            *pcb = cb;
            pHelpStruct->byteoffset += cb;
        }
    }
    else
    {
        //
        // This is the EM_STREAMOUT which is only used during the testing of
        // the richedit2.0 functionality.  (we know our buffer is 32 bytes)
        //
        if (cb <= 32)
        {
            memcpy(pHelpStruct->psz, pbBuff, cb);
        }
        *pcb = cb;
    }

    return 0;
}

void SetRicheditIMFOption(HWND hWndRichEdit)
{
    DWORD dwOptions;

    dwOptions = (DWORD)SendMessageW(hWndRichEdit, EM_GETLANGOPTIONS, 0, 0);
    dwOptions |= IMF_UIFONTS;
    SendMessageW(hWndRichEdit, EM_SETLANGOPTIONS, 0, dwOptions);
}

DWORD SetRicheditTextW(HWND hwndDlg, UINT id, LPCWSTR pwsz)
{
    EDITSTREAM              editStream;
    STREAMIN_HELPER_STRUCT  helpStruct;

    SetRicheditIMFOption(GetDlgItem(hwndDlg, id));

    //
    // setup the edit stream struct since it is the same no matter what
    //
    editStream.dwCookie = (DWORD_PTR) &helpStruct;
    editStream.dwError = 0;
    editStream.pfnCallback = SetRicheditTextWCallback;

    helpStruct.pwsz = pwsz;
    helpStruct.byteoffset = 0;
    helpStruct.fStreamIn = TRUE;

    SendDlgItemMessageW(hwndDlg, id, EM_STREAMIN, SF_TEXT | SF_UNICODE, (LPARAM) &editStream);

    return editStream.dwError;
}

//+---------------------------------------------------------------------------
//
//  Function:   RenderStringToEditControlW
//
//  Synopsis:   renders a string to the control given and if requested, gives
//              it a link look and feel, subclassed to the wndproc given
//
//  Arguments:  [hwndDlg]       -- dialog window handle
//              [pwsz]           -- string
//              [wndproc]       -- wndproc
//              [uID]           -- ID of control
//
//
//  Notes:
//
//----------------------------------------------------------------------------
void RenderStringToEditControlW (
                  HWND                      hwndDlg,
                  LPCWSTR                   pwsz,
                  WNDPROC                   wndproc,
                  UINT                      uID)
{
    HWND hControl;
    //
    // Get the control and set the text on it, make sure the background is right
    //

    hControl = GetDlgItem(hwndDlg, uID);
    SetRicheditIMFOption(GetDlgItem(hwndDlg, uID));
    SetRicheditTextW(hwndDlg, uID, L"");
    SetRicheditTextW(hwndDlg, uID, pwsz);

    SendMessage(
        hControl,
        EM_SETBKGNDCOLOR,
        0,
        (LPARAM)GetSysColor(COLOR_3DFACE)
        );

    //
    // Update for the link look
    //

    CHARFORMAT cf;

    memset(&cf, 0, sizeof(CHARFORMAT));
    cf.cbSize = sizeof(CHARFORMAT);
    cf.dwMask = CFM_COLOR | CFM_UNDERLINE | CFM_LINK;
    cf.crTextColor = RGB(0, 0, 255);
    cf.dwEffects |= CFE_UNDERLINE | CFE_LINK;

    SendMessage(hControl, EM_SETCHARFORMAT, SCF_ALL, (LPARAM)&cf);
    

    //subclass the window proc so we can handle the link specially
    LONG_PTR PrevWndProc = GetWindowLongPtr(hControl, GWLP_WNDPROC);
    SetWindowLongPtr(hControl, GWLP_USERDATA, (LONG_PTR)PrevWndProc);
    SetWindowLongPtr(hControl, GWLP_WNDPROC, (LONG_PTR)wndproc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\caggunk.h ===
#ifndef _CAGGUNK_H
#define _CAGGUNK_H

class CAggregatedUnknown  : public IUnknown
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
protected:
    virtual ~CAggregatedUnknown(); // so that subclasses get deleted right
    CAggregatedUnknown(IUnknown *punkAgg);

    // This is the IUnknown that subclasses returns from their CreateInstance func
    IUnknown* _GetInner() { return &_unkInner; }

    // A couple helper functions for subclasses to cache their aggregator's
    // (or their own) interfaces.
    void _ReleaseOuterInterface(IUnknown** ppunk);
    HRESULT _QueryOuterInterface(REFIID riid, void ** ppvOut);

    // Do non-cached QIs off this IUnknown
    IUnknown* _GetOuter() { return _punkAgg; }

    // Allow "delayed aggregation"
    void _SetOuter(IUnknown* punk) { _punkAgg = punk; }

    // This is the QueryInterface the aggregator implements
    virtual HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj) = 0;

    virtual BOOL v_HandleDelete(PLONG pcRef) { return FALSE; };
    
private:

    // Get a non-refcounted pointer to the canonical IUnknown of the
    // controlling unknown.  Used by _QueryOuterInterface and
    // _ReleaseOuterInterface.
    IUnknown *_GetCanonicalOuter(void);

    // Embed default IUnknown handler
    class CUnkInner : public IUnknown
    {
    public:
        virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
        virtual STDMETHODIMP_(ULONG) AddRef(void) ;
        virtual STDMETHODIMP_(ULONG) Release(void);

        CUnkInner() { _cRef = 1; }
    private:
        LONG _cRef;
    };
    friend class CUnkInner;
    CUnkInner _unkInner;
    IUnknown* _punkAgg; // points to _unkInner or aggregating IUnknown

};

#define RELEASEOUTERINTERFACE(p) _ReleaseOuterInterface((IUnknown**)((void **)&p))

#endif // _CAGGUNK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\brutil.h ===
#ifndef _BRUTIL_H_
#define _BRUTIL_H_

STDAPI_(BOOL) IsBrowseNewProcess();
STDAPI_(BOOL) IsBrowseNewProcessAndExplorer();
STDAPI IENavigateIEProcess(LPCTSTR pszPath, BOOL fIsInternetShortcut);
STDAPI NavFrameWithFile(LPCTSTR pszPath, IUnknown *punk);
STDAPI GetPathForItem(IShellFolder *psf, LPCITEMIDLIST pidl, LPTSTR pszPath, DWORD *pdwAttrib);
STDAPI EditBox_TranslateAcceleratorST(LPMSG lpmsg);
STDAPI _CLSIDFromExtension(LPCTSTR pszExt, CLSID *pclsid);
STDAPI GetLinkTargetIDList(LPCTSTR pszPath, LPTSTR pszTarget, DWORD cchTarget, LPITEMIDLIST *ppidl);
STDAPI_(void) PathToDisplayNameW(LPCTSTR pszPath, LPTSTR pszDisplayName, UINT cchDisplayName);
STDAPI_(void) PathToDisplayNameA(LPSTR pszPathA, LPSTR pszDisplayNameA, int cchDisplayName);
STDAPI DataObj_GetNameFromFileDescriptor(IDataObject *pdtobj, LPWSTR pszDisplayName, UINT cch);
STDAPI SHPidlFromDataObject2(IDataObject *pdtobj, LPITEMIDLIST * ppidl);
STDAPI SHPidlFromDataObject(IDataObject *pdtobj, LPITEMIDLIST *ppidl, LPWSTR pszDisplayNameW, DWORD cchDisplayName);
STDAPI_(LRESULT) SendShellIEBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam, UINT uTimeout);
STDAPI IEBindToParentFolder(LPCITEMIDLIST pidl, IShellFolder** ppsfParent, LPCITEMIDLIST *ppidlChild);
STDAPI GetDataObjectForPidl(LPCITEMIDLIST pidl, IDataObject ** ppdtobj);
STDAPI_(BOOL) ILIsFileSysFolder(LPCITEMIDLIST pidl);
STDAPI SHTitleFromPidl(LPCITEMIDLIST pidl, LPTSTR psz, DWORD cch, BOOL fFullPath);
STDAPI_(BOOL) IsBrowserFrameOptionsSet(IN IShellFolder * psf, IN BROWSERFRAMEOPTIONS dwMask);
STDAPI_(BOOL) IsBrowserFrameOptionsPidlSet(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask);
STDAPI GetBrowserFrameOptions(IUnknown *punkFolder, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);
STDAPI GetBrowserFrameOptionsPidl(IN LPCITEMIDLIST pidl, IN BROWSERFRAMEOPTIONS dwMask, OUT BROWSERFRAMEOPTIONS * pdwOptions);
STDAPI_(BOOL) IsFTPFolder(IShellFolder * psf);

// non-munging menu operations to work around the menu munging code
// in the shlwapi wrappers. for more info see the comment in the brutil.cpp.

STDAPI_(HMENU)  LoadMenu_PrivateNoMungeW(HINSTANCE hInstance, LPCWSTR lpMenuName);
STDAPI_(BOOL)   InsertMenu_PrivateNoMungeW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);
STDAPI_(HMENU)  LoadMenuPopup_PrivateNoMungeW(UINT id);

//encode any incoming %1 so that people can't spoof our domain security code
HRESULT WrapSpecialUrl(BSTR * pbstrUrl);
HRESULT WrapSpecialUrlFlat(LPWSTR pszUrl, DWORD cchUrl);
BOOL IsSpecialUrl(LPCWSTR pchURL);

void DrawFocusRectangle (HWND hwnd, HDC hdc);

void RenderStringToEditControlW (HWND hwndDlg,LPCWSTR pwsz,WNDPROC wndproc, UINT uID);

#endif // _BRUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\ccstock2.h ===
//
// addendum to ccstock.h:
//   this file has function prototypes that require shlobj.h.
//   ccstock.h does not have that requirement (and can not,
//   since comctl32 includes ccstock but not shlobj).
//
#ifndef __CCSTOCK2_H__
#define __CCSTOCK2_H__

STDAPI_(LPIDA) DataObj_GetHIDAEx(IDataObject *pdtobj, CLIPFORMAT cf, STGMEDIUM *pmedium);
STDAPI_(LPIDA) DataObj_GetHIDA(IDataObject *pdtobj, STGMEDIUM *pmedium);
STDAPI_(LPITEMIDLIST) IDA_ILClone(LPIDA pida, UINT i);
STDAPI_(void) HIDA_ReleaseStgMedium(LPIDA pida, STGMEDIUM * pmedium);
STDAPI_(LPCITEMIDLIST) IDA_GetIDListPtr(LPIDA pida, UINT i);


#endif __CCSTOCK2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\cfdefs.h ===
#ifndef _STATIC_CLASS_FACTORY_
#define _STATIC_CLASS_FACTORY_

#define VERSION_2 2 // so we don't get confused by too many integers
#define VERSION_1 1
#define VERSION_0 0
#define COCREATEONLY NULL,NULL,VERSION_0,0,0 // piid,piidEvents,lVersion,dwOleMiscFlags,dwClassFactFlags
#define COCREATEONLY_NOFLAGS NULL,NULL,VERSION_0,0 // piid,piidEvents,lVersion,dwOleMiscFlags

/*
 * Class Factory Implementation for C++ without CTRStartup required.
 */

#ifdef __cplusplus

#ifdef UNIX

#define STDMETHODX  STDMETHOD
#define STDMETHODX_ STDMETHOD_

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf: public IClassFactory                                \
   {                                                             \
     public:                                                     \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \


#else  // UNIX

#define STDMETHODX(fn)      HRESULT STDMETHODCALLTYPE fn
#define STDMETHODX_(ret,fn) ret STDMETHODCALLTYPE fn

#define DECLARE_CLASS_FACTORY(cf)                                \
   class cf                                                      \
   {                                                             \
     public:                                                     \
       IClassFactory *vtable;                                    \
       STDMETHODX (QueryInterface)(REFIID, void **);             \
       STDMETHODX_(ULONG, AddRef)();                             \
       STDMETHODX_(ULONG, Release)();                            \
                                                                 \
       STDMETHODX (CreateInstance)(IUnknown *, REFIID, void **); \
       STDMETHODX (LockServer)(BOOL);                            \
   }                                                             \

#endif // UNIX


DECLARE_CLASS_FACTORY( CClassFactory );


struct IClassFactoryVtbl
{
    // IUnknown
    HRESULT (STDMETHODCALLTYPE CClassFactory::*QueryInterface)(REFIID riid, void ** ppvObj);
    ULONG (STDMETHODCALLTYPE CClassFactory::*AddRef)();
    ULONG (STDMETHODCALLTYPE CClassFactory::*Release)();
    
    // IClassFactory
    HRESULT (STDMETHODCALLTYPE CClassFactory::*CreateInstance)(IUnknown *pUnkOuter, REFIID riid, void ** ppvObject);
    HRESULT (STDMETHODCALLTYPE CClassFactory::*LockServer)(BOOL);
};

typedef struct IClassFactoryVtbl IClassFactoryVtbl;

//
// class CObjectInfo
//

class CObjectInfo;
typedef CObjectInfo* LPOBJECTINFO;
typedef CObjectInfo const* LPCOBJECTINFO;
typedef HRESULT (*LPFNCREATEOBJINSTANCE)(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);

class CObjectInfo : public CClassFactory                               
{                                                                      
public:                                                                
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreateInstance;

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;

    CObjectInfo(CLSID const* pclsidin, LPFNCREATEOBJINSTANCE pfnCreatein,  IID const* piidIn, IID const* piidEventsIn, long lVersionIn,  DWORD dwOleMiscFlagsIn,  DWORD dwClassFactFlagsIn);

};
#ifndef NO_CFVTBL
const IClassFactoryVtbl c_CFVtbl = {
    CClassFactory::QueryInterface,  
    CClassFactory::AddRef, 
    CClassFactory::Release,
    CClassFactory::CreateInstance,
    CClassFactory::LockServer
};
#endif
//
// CLASS FACTORY TABLE STUFF
//

typedef struct tagOBJECTINFO
{
    void *cf;
    CLSID const* pclsid;
    LPFNCREATEOBJINSTANCE pfnCreateInstance;

    // for OCs and automation objects:
    IID const* piid;
    IID const* piidEvents;
    long lVersion;
    DWORD dwOleMiscFlags;
    DWORD dwClassFactFlags;
} OBJECTINFO;


#ifdef UNIX


#define CF_TABLE_BEGIN(cfTable) const CObjectInfo cfTable[] = { 
#define CF_TABLE_ENTRY         CObjectInfo
#define CF_TABLE_ENTRY_NOFLAGS CObjectInfo
#define CF_TABLE_ENTRY_ALL     CObjectInfo
#define CF_TABLE_END(cfTable)  \
    CF_TABLE_ENTRY(NULL, NULL, COCREATEONLY) };
#define GET_ICLASSFACTORY(ptr) ((IClassFactory *)ptr)

#else // UNIX

#define CF_TABLE_BEGIN(cfTable) const OBJECTINFO cfTable##_tble[] = { 
#define CF_TABLE_ENTRY(p1, p2, p3) { (void *)&c_CFVtbl, p1, p2, p3 }
#define CF_TABLE_ENTRY_NOFLAGS(p1, p2, p3, p4) { (void *)&c_CFVtbl, p1, p2, p3, p4 }
#define CF_TABLE_ENTRY_ALL(p1, p2, p3, p4, p5, p6, p7) { (void *)&c_CFVtbl, p1, p2, p3, p4 , p5, p6, p7}
#define CF_TABLE_END(cfTable)                                         \
    CF_TABLE_ENTRY(NULL, NULL, COCREATEONLY) }; \
    const CObjectInfo *cfTable = (const CObjectInfo *)cfTable##_tble;
#define GET_ICLASSFACTORY(ptr) ((IClassFactory *)&ptr->vtable)

#endif // UNIX

#define DECLARE_CF_TABLE(cfTable) extern const CObjectInfo *cfTable;

#endif // __cplusplus


#endif // _STATIC_CLASS_FACTORY_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\chanmgrp.h ===
//
// Private channel manager include file.
//

#undef  INTERFACE
#define INTERFACE   IChannelMgrPriv

DECLARE_INTERFACE_(IChannelMgrPriv, IUnknown)
{
    typedef enum _tagCHANNELFOLDERLOCATION { CF_CHANNEL, CF_SOFTWAREUPDATE } CHANNELFOLDERLOCATION;

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IChannelMgrPriv ***
    STDMETHOD(GetBaseChannelPath) (THIS_ LPSTR pszPath, int cch) PURE;
    STDMETHOD(InvalidateCdfCache) (THIS) PURE;
    STDMETHOD(PreUpdateChannelImage) (THIS_ LPCSTR pszPath, LPSTR pszHashItem,
                                      int* piIndex, UINT* puFlags,
                                      int* piImageIndex) PURE;
    STDMETHOD(UpdateChannelImage) (THIS_ LPCWSTR pszHashItem, int iIndex,
                                   UINT uFlags, int iImageIndex) PURE;
    STDMETHOD(GetChannelFolderPath) (THIS_ LPSTR pszPath, int cch, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(GetChannelFolder) (THIS_ LPITEMIDLIST* ppidl, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(DownloadMinCDF) (THIS_ HWND hwnd, LPCWSTR pwszURL, LPWSTR pwszTitle, 
                               DWORD cchTitle, SUBSCRIPTIONINFO *pSubInfo, BOOL *pfIsSoftware) PURE;
    STDMETHOD(ShowChannel) (THIS_ IWebBrowser2 *pWebBrowser2, LPWSTR pwszURL, HWND hwnd) PURE;
    STDMETHOD(IsChannelInstalled) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(IsChannelPreinstalled) (THIS_ LPCWSTR pwszURL, BSTR * bstrFile) PURE;
    STDMETHOD(RemovePreinstalledMapping) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(SetupPreinstalledMapping) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszFile) PURE;

    // WARNING!  BEFORE CALLING THE AddAndSubscribe METHOD YOU MUST DETECT
    // THE CDFVIEW VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    //  pSubscriptionMgr can be NULL
    STDMETHOD(AddAndSubscribe) (THIS_ HWND hwnd, LPCWSTR pwszURL, 
                                ISubscriptionMgr *pSubscriptionMgr) PURE;
};

#undef  INTERFACE
#define INTERFACE   IChannelMgrPriv2
DECLARE_INTERFACE_(IChannelMgrPriv2, IChannelMgrPriv)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IChannelMgrPriv ***
    STDMETHOD(GetBaseChannelPath) (THIS_ LPSTR pszPath, int cch) PURE;
    STDMETHOD(InvalidateCdfCache) (THIS) PURE;
    STDMETHOD(PreUpdateChannelImage) (THIS_ LPCSTR pszPath, LPSTR pszHashItem,
                                      int* piIndex, UINT* puFlags,
                                      int* piImageIndex) PURE;
    STDMETHOD(UpdateChannelImage) (THIS_ LPCWSTR pszHashItem, int iIndex,
                                   UINT uFlags, int iImageIndex) PURE;
    STDMETHOD(GetChannelFolderPath) (THIS_ LPSTR pszPath, int cch, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(GetChannelFolder) (THIS_ LPITEMIDLIST* ppidl, CHANNELFOLDERLOCATION cflChannel) PURE;
    STDMETHOD(DownloadMinCDF) (THIS_ HWND hwnd, LPCWSTR pwszURL, LPWSTR pwszTitle, 
                               DWORD cchTitle, SUBSCRIPTIONINFO *pSubInfo, BOOL *pfIsSoftware) PURE;
    STDMETHOD(ShowChannel) (THIS_ IWebBrowser2 *pWebBrowser2, LPWSTR pwszURL, HWND hwnd) PURE;
    STDMETHOD(IsChannelInstalled) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(IsChannelPreinstalled) (THIS_ LPCWSTR pwszURL, BSTR * bstrFile) PURE;
    STDMETHOD(RemovePreinstalledMapping) (THIS_ LPCWSTR pwszURL) PURE;
    STDMETHOD(SetupPreinstalledMapping) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszFile) PURE;

    // WARNING!  BEFORE CALLING THE AddAndSubscribe METHOD YOU MUST DETECT
    // THE CDFVIEW VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    //  pSubscriptionMgr can be NULL
    STDMETHOD(AddAndSubscribe) (THIS_ HWND hwnd, LPCWSTR pwszURL, 
                                ISubscriptionMgr *pSubscriptionMgr) PURE;

    // *** IChannelMgrPriv2 ***
    STDMETHOD(WriteScreenSaverURL) (THIS_ LPCWSTR pwszURL, LPCWSTR pwszScreenSaverURL) PURE;
    STDMETHOD(RefreshScreenSaverURLs) (THIS) PURE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\ccstock.h ===
//
// CCSHELL stock definition and declaration header
//


#ifndef __CCSTOCK_H__
#define __CCSTOCK_H__

#include <malloc.h> // for _alloca

#ifndef RC_INVOKED

// NT and Win95 environments set warnings differently.  This makes
// our project consistent across environments.

#pragma warning(3:4101)   // Unreferenced local variable

//
// Sugar-coating
//

#define PUBLIC
#define PRIVATE
#define IN
#define OUT
#define BLOCK

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

#ifndef DECLARE_STANDARD_TYPES_U

/*
 * For a type "FOO", define the standard derived UNALIGNED types PFOO, CFOO, and PCFOO.
 *  WINNT: RISC boxes care about ALIGNED, intel does not.
 */

#define DECLARE_STANDARD_TYPES_U(type)    typedef UNALIGNED type *P##type; \
                                          typedef UNALIGNED const type C##type; \
                                          typedef UNALIGNED const type *PC##type;

#endif

// For string constants that are always wide
#define __TEXTW(x)    L##x
#define TEXTW(x)      __TEXTW(x)

//
// Count of characters to count of bytes
//
#define CbFromCchW(cch)             ((cch)*sizeof(WCHAR))
#define CbFromCchA(cch)             ((cch)*sizeof(CHAR))
#ifdef UNICODE
#define CbFromCch                   CbFromCchW
#else  // UNICODE
#define CbFromCch                   CbFromCchA
#endif // UNICODE

//
// General flag macros
//
#define SetFlag(obj, f)             do {obj |= (f);} while (0)
#define ToggleFlag(obj, f)          do {obj ^= (f);} while (0)
#define ClearFlag(obj, f)           do {obj &= ~(f);} while (0)
#define IsFlagSet(obj, f)           (BOOL)(((obj) & (f)) == (f))
#define IsFlagClear(obj, f)         (BOOL)(((obj) & (f)) != (f))

//
// String macros
//
#define IsSzEqual(sz1, sz2)         (BOOL)(lstrcmpi(sz1, sz2) == 0)
#define IsSzEqualC(sz1, sz2)        (BOOL)(lstrcmp(sz1, sz2) == 0)

#define lstrnicmpA(sz1, sz2, cch)           StrCmpNIA(sz1, sz2, cch)
#define lstrnicmpW(sz1, sz2, cch)           StrCmpNIW(sz1, sz2, cch)
#define lstrncmpA(sz1, sz2, cch)            StrCmpNA(sz1, sz2, cch)
#define lstrncmpW(sz1, sz2, cch)            StrCmpNW(sz1, sz2, cch)

//
// lstrcatnA and lstrcatnW are #defined here to StrCatBuff which is implemented
// in shlwapi. We do this here (and not in shlwapi.h or shlwapip.h) in case the
// kernel guys ever decided to implement this.
//
#define lstrcatnA(sz1, sz2, cchBuffSize)    StrCatBuffA(sz1, sz2, cchBuffSize)
#define lstrcatnW(sz1, sz2, cchBuffSize)    StrCatBuffW(sz1, sz2, cchBuffSize)
#ifdef UNICODE
#define lstrcatn lstrcatnW
#else
#define lstrcatn lstrcatnA
#endif // UNICODE

#ifdef UNICODE
#define lstrnicmp       lstrnicmpW
#define lstrncmp        lstrncmpW
#else
#define lstrnicmp       lstrnicmpA
#define lstrncmp        lstrncmpA
#endif

#ifndef SIZEOF
#define SIZEOF(a)                   sizeof(a)
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)                (sizeof(a)/sizeof(a[0]))
#endif
#define SIZECHARS(sz)               (sizeof(sz)/sizeof(sz[0]))

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))
#define IsInRange                   InRange

// ATOMICRELEASE
//
#ifndef ATOMICRELEASE
#   ifdef __cplusplus
#       define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->Release();} }
#   else
#       define ATOMICRELEASET(p, type) { if(p) { type* punkT=p; p=NULL; punkT->lpVtbl->Release(punkT);} }
#   endif

// doing this as a function instead of inline seems to be a size win.
//
#   ifdef NOATOMICRELESEFUNC
#       define ATOMICRELEASE(p) ATOMICRELEASET(p, IUnknown)
#   else
#       ifdef __cplusplus
#           define ATOMICRELEASE(p) IUnknown_SafeReleaseAndNullPtr(p)
#       else
#           define ATOMICRELEASE(p) IUnknown_AtomicRelease((void **)&p)
#       endif
#   endif
#endif //ATOMICRELEASE

//
//  IID_PPV_ARG(IType, ppType) 
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
//  IID_PPV_ARG_NULL(IType, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks a NULL between the
//      IID and PPV (for IShellFolder::GetUIObjectOf).
//
//  IID_X_PPV_ARG(IType, X, ppType)
//
//      Just like IID_PPV_ARG, except that it sticks X between the
//      IID and PPV (for SHBindToObject).
//
//
#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)

#define PPUNK_SET(ppunkDst, punkSrc)    \
    {   ATOMICRELEASE(*ppunkDst);       \
        if (punkSrc)                    \
        {   punkSrc->AddRef();          \
            *ppunkDst = punkSrc;        \
        }                               \
    }

//
//  Helper macro for managing weak pointers to inner interfaces.
//  (It's the weak version of ATOMICRELEASE.)
//
//  The extra cast to (void **) is to keep C++ from doing strange
//  inheritance games when all I want to do is change the type.
//
#ifndef RELEASEINNERINTERFACE
#define RELEASEINNERINTERFACE(pOuter, p) \
        SHReleaseInnerInterface(pOuter, (IUnknown**)(void **)&(p))
#endif // RELEASEINNERINTERFACE

// For checking window charsets
#ifdef UNICODE
#define IsWindowTchar               IsWindowUnicode
#else  // !UNICODE
#define IsWindowTchar               !IsWindowUnicode
#endif // UNICODE

#ifdef DEBUG
// This macro is especially useful for cleaner looking code in
// declarations or for single lines.  For example, instead of:
//
//   {
//       DWORD dwRet;
//   #ifdef DEBUG
//       DWORD dwDebugOnlyVariable;
//   #endif
//
//       ....
//   }
//
// You can type:
//
//   {
//       DWORD dwRet;
//       DEBUG_CODE( DWORD dwDebugOnlyVariable; )
//
//       ....
//   }

#define DEBUG_CODE(x)               x
#else
#define DEBUG_CODE(x)

#endif  // DEBUG


//
// SAFECAST(obj, type)
//
// This macro is extremely useful for enforcing strong typechecking on other
// macros.  It generates no code.
//
// Simply insert this macro at the beginning of an expression list for
// each parameter that must be typechecked.  For example, for the
// definition of MYMAX(x, y), where x and y absolutely must be integers,
// use:
//
//   #define MYMAX(x, y)    (SAFECAST(x, int), SAFECAST(y, int), ((x) > (y) ? (x) : (y)))
//
//
#define SAFECAST(_obj, _type) (((_type)(_obj)==(_obj)?0:0), (_type)(_obj))


//
// Bitfields don't get along too well with bools,
// so here's an easy way to convert them:
//
#define BOOLIFY(expr)           (!!(expr))


// (scotth): we should probably make this a 'bool', but be careful
// because the Alpha compiler might not recognize it yet.  Talk to AndyP.
// This isn't a BOOL because BOOL is signed and the compiler produces 
// sloppy code when testing for a single bit.

typedef DWORD   BITBOOL;

//  a three state boolean for bools that need initialization
typedef enum 
{
    TRIBIT_UNDEFINED = 0,
    TRIBIT_TRUE,
    TRIBIT_FALSE,
} TRIBIT;

//
// DESTROY_OBJ_WITH_HANDLE(h, fn)
//
// Kind of like ATOMICRELEASE for handles.  Checks for NULL and assigns
// NULL when it's done.  You supply the destructor function.
//
#define DESTROY_OBJ_WITH_HANDLE(h, fn) { if (h) { fn(h); (h) = NULL; } }


// STOCKLIB util functions

// staticIsOS(): returns TRUE/FALSE if the platform is the indicated OS. 
// This function exists for those who cannot link to shlwapi.dll
STDAPI_(BOOL) staticIsOS(DWORD dwOS);

#include <pshpack2.h>
typedef struct tagDLGTEMPLATEEX
{
    WORD    wDlgVer;
    WORD    wSignature;
    DWORD   dwHelpID;
    DWORD   dwExStyle;
    DWORD   dwStyle;
    WORD    cDlgItems;
    short   x;
    short   y;
    short   cx;
    short   cy;
}   DLGTEMPLATEEX, *LPDLGTEMPLATEEX;
#include <poppack.h>

//
// round macro that rounds a to the next multiple of b.
//
#ifndef ROUNDUP
#define ROUNDUP(a,b)    ((((a)+(b)-1)/(b))*(b))
#endif

#define ROUND_TO_CLUSTER ROUNDUP

//
// macro that rounds cbSize fields to the nearest pointer size (for alignment)
//
#define ROUND_TO_POINTER(cbSize) ROUNDUP(cbSize, sizeof(void*))

//
// macro that sees if a give char is an number
//
#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

//
// inline that does PathIsDotOrDotDot
//
__inline BOOL PathIsDotOrDotDotW(LPCWSTR pszPath)
{
    return ((pszPath[0] == L'.') && 
            ((pszPath[1] == L'\0') || ((pszPath[1] == L'.') && (pszPath[2] == L'\0'))));
}

__inline BOOL PathIsDotOrDotDotA(LPCSTR pszPath)
{
    return ((pszPath[0] == '.') && 
            ((pszPath[1] == '\0') || ((pszPath[1] == '.') && (pszPath[2] == '\0'))));
}

#ifdef UNICODE
#define PathIsDotOrDotDot PathIsDotOrDotDotW
#else
#define PathIsDotOrDotDot PathIsDotOrDotDotA
#endif

//
//  FILETIME helpers
//
__inline unsigned __int64 _FILETIMEtoInt64(const FILETIME* pft)
{
    return ((unsigned __int64)pft->dwHighDateTime << 32) + pft->dwLowDateTime;
}

#define FILETIMEtoInt64(ft) _FILETIMEtoInt64(&(ft))

__inline void SetFILETIMEfromInt64(FILETIME *pft, unsigned __int64 i64)
{
    pft->dwLowDateTime = (DWORD)i64;
    pft->dwHighDateTime = (DWORD)(i64 >> 32);
}

__inline void IncrementFILETIME(FILETIME *pft, unsigned __int64 iAdjust)
{
    SetFILETIMEfromInt64(pft, _FILETIMEtoInt64(pft) + iAdjust);
}

__inline void DecrementFILETIME(FILETIME *pft, unsigned __int64 iAdjust)
{
    SetFILETIMEfromInt64(pft, _FILETIMEtoInt64(pft) - iAdjust);
}

//
//  FAT and NTFS use different values for "unknown date".
//
//  The FAT "unknown date" is January 1 1980 LOCAL TIME.
//  The NTFS "unknown date" is January 1 1601 GMT.
//
//  This LOCAL/GMT discrepancy is annoying.
//
#define FT_FAT_UNKNOWNLOCAL    ((unsigned __int64)0x01A8E79FE1D58000)
#define FT_NTFS_UNKNOWNGMT     ((unsigned __int64)0x0000000000000000)

//
//  FT_ONEHOUR is the number of FILETIME units in an hour.
//  FT_ONEDAY is the number of FILETIME units in a day.
//
//      10,000,000 FILETIME units per second *
//      3600 seconds per hour *
//      24 hours per day.
//
#define FT_ONESECOND           ((unsigned __int64)10000000)
#define FT_ONEHOUR             ((unsigned __int64)10000000 * 3600)
#define FT_ONEDAY              ((unsigned __int64)10000000 * 3600 * 24)


//
//
//  WindowLong accessor macros and other Win64 niceness
//

__inline void * GetWindowPtr(HWND hWnd, int nIndex) {
    return (void *)GetWindowLongPtr(hWnd, nIndex);
}

__inline void * SetWindowPtr(HWND hWnd, int nIndex, void * p) {
    return (void *)SetWindowLongPtr(hWnd, nIndex, (LONG_PTR)p);
}

//***   GetWindowLong0 -- 'fast' GetWindowLong (and GetWindowLongPtr)
// DESCRIPTION
//  what's up w/ this?  it's all about perf.  GetWindowLong has 'A' and 'W'
//  versions.  however 99% of the time they do the same thing (the other
//  0.1% has to do w/ setting the WndProc and having to go thru a thunk).
//  but we still need wrappers for the general case.  but most of the time
//  we're just doing a GWL(0), e.g. on entry to a wndproc to get our private
//  data.  so by having a special version of that, we save going thru the
//  wrapper (which was costing us 1-3% of our profile).
// NOTES
//  note that we call the 'A' version since that's guaranteed to exist on
// all platforms.
__inline LONG GetWindowLong0(HWND hWnd) {
    return GetWindowLongA(hWnd, 0);
}
__inline LONG SetWindowLong0(HWND hWnd, LONG l) {
    return SetWindowLongA(hWnd, 0, l);
}
__inline void * GetWindowPtr0(HWND hWnd) {
    return (void *)GetWindowLongPtrA(hWnd, 0);
}
__inline void * SetWindowPtr0(HWND hWnd, void * p) {
    return (void *)SetWindowLongPtrA(hWnd, 0, (LONG_PTR)p);
}


#define IS_WM_CONTEXTMENU_KEYBOARD(lParam) ((DWORD)(lParam) == 0xFFFFFFFF)

//
//  CharUpperChar - Convert a single character to uppercase
//
__inline WCHAR CharUpperCharW(int c)
{
    return (WCHAR)(DWORD_PTR)CharUpperW((LPWSTR)(DWORD_PTR)(c));
}

__inline CHAR CharUpperCharA(int c)
{
    return (CHAR)(DWORD_PTR)CharUpperA((LPSTR)(DWORD_PTR)(c));
}

//
//  CharLowerChar - Convert a single character to lowercase
//
__inline WCHAR CharLowerCharW(int c)
{
    return (WCHAR)(DWORD_PTR)CharLowerW((LPWSTR)(DWORD_PTR)(c));
}

__inline CHAR CharLowerCharA(int c)
{
    return (CHAR)(DWORD_PTR)CharLowerA((LPSTR)(DWORD_PTR)(c));
}

#ifdef UNICODE
#define CharUpperChar       CharUpperCharW
#define CharLowerChar       CharLowerCharW
#else
#define CharUpperChar       CharUpperCharA
#define CharLowerChar       CharLowerCharA
#endif

//
//  ShrinkProcessWorkingSet - Use this to stay Sundown-happy.
//
#define ShrinkWorkingSet() \
        SetProcessWorkingSetSize(GetCurrentProcess(), (SIZE_T) -1, (SIZE_T) -1)

//
//  COM Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHCoInitialize();
//      ... do COM stuff ...
//      SHCoUninitialize(hrInit);
//
//  Notice:  Continue doing COM stuff even if SHCoInitialize fails.
//  It might fail if somebody else already CoInit'd with different
//  flags, but we don't want to barf under those conditions.
//

STDAPI SHCoInitialize(void);
#define SHCoUninitialize(hr) if (SUCCEEDED(hr)) CoUninitialize()


//
//  OLE Initialization.
//
//  Usage:
//
//      HRESULT hrInit = SHOleInitialize(pMalloc);
//      ... do COM stuff ...
//      SHOleUninitialize(hrInit);
//

#define SHOleInitialize(pMalloc) OleInitialize(pMalloc)

#define SHOleUninitialize(hr)   if (SUCCEEDED(hr))  OleUninitialize()

#include <shtypes.h>

//
//  Name Parsing generic across the shell
//
//  Usage:
//
//      HRESULT SHGetNameAndFlags()
//          wrapper to bind to the folder and do a GetDisplayName()
//
STDAPI SHGetNameAndFlagsA(LPCITEMIDLIST pidl, DWORD dwFlags, LPSTR pszName, UINT cchName, DWORD *pdwAttribs);
STDAPI SHGetNameAndFlagsW(LPCITEMIDLIST pidl, DWORD dwFlags, LPWSTR pszName, UINT cchName, DWORD *pdwAttribs);

STDAPI SHBindToObject(struct IShellFolder *psf, REFIID riid, LPCITEMIDLIST pidl, void **ppv);
STDAPI SHBindToObjectEx(struct IShellFolder *psf, LPCITEMIDLIST pidl, struct IBindCtx *pbc, REFIID riid, void **ppv);
STDAPI SHGetUIObjectFromFullPIDL(LPCITEMIDLIST pidl, HWND hwnd, REFIID riid, void **ppv);
STDAPI SHGetTargetFolderIDList(LPCITEMIDLIST pidlFolder, LPITEMIDLIST *ppidl);
STDAPI SHGetTargetFolderPathW(LPCITEMIDLIST pidlFolder, LPWSTR pszPath, UINT cchBuf);
STDAPI SHGetTargetFolderPathA(LPCITEMIDLIST pidlFolder, LPSTR pszPath, UINT cchBuf);
STDAPI_(DWORD) SHGetAttributes(struct IShellFolder *psf, LPCITEMIDLIST pidl, DWORD dwAttributes);

#define SHGetAttributesOf(pidl, prgfInOut) SHGetNameAndFlags(pidl, 0, NULL, 0, prgfInOut)

#ifdef __IShellFolder2_FWD_DEFINED__
STDAPI GetDateProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, FILETIME *pft);
STDAPI GetLongProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, ULONGLONG *pdw);
STDAPI GetStringProperty(IShellFolder2 *psf, LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, LPTSTR pszVal, int cchMax);
#endif // __IShellFolder2_FWD_DEFINED__

STDAPI LoadFromFileW(REFCLSID clsid, LPCWSTR pszFile, REFIID riid, void **ppv);
STDAPI LoadFromIDList(REFCLSID clsid, LPCITEMIDLIST pidl, REFIID riid, void **ppv);

STDAPI_(DWORD) GetUrlSchemeW(LPCWSTR pszUrl);
STDAPI_(DWORD) GetUrlSchemeA(LPCSTR pszUrl);
STDAPI_(void) SHRemoveURLTurd(LPTSTR pszUrl);
STDAPI_(void) SHCleanupUrlForDisplay(LPTSTR pszUrl);
STDAPI_(BOOL) ShouldNavigateInIE(LPCWSTR pszUrl);
STDAPI_(BOOL) IsDesktopFrame(IUnknown *punk);

#ifdef UNICODE
#define SHGetNameAndFlags       SHGetNameAndFlagsW
#define GetUrlScheme            GetUrlSchemeW
#define SHGetTargetFolderPath   SHGetTargetFolderPathW
#define LoadFromFile            LoadFromFileW
#else
#define SHGetNameAndFlags       SHGetNameAndFlagsA
#define GetUrlScheme            GetUrlSchemeA
#define SHGetTargetFolderPath   SHGetTargetFolderPathA
#endif

//
//  BindCtx helpers
//
STDAPI BindCtx_CreateWithMode(DWORD grfMode, IBindCtx **ppbc);
STDAPI_(DWORD) BindCtx_GetMode(IBindCtx *pbc, DWORD grfModeDefault);
STDAPI_(BOOL) BindCtx_ContainsObject(IBindCtx *pbc, LPOLESTR sz);
STDAPI BindCtx_RegisterObjectParam(IBindCtx *pbcIn, LPCOLESTR pszRegister, IUnknown *punkRegister, IBindCtx **ppbcOut);
STDAPI BindCtx_CreateWithTimeoutDelta(DWORD dwTicksToAllow, IBindCtx **ppbc);
STDAPI BindCtx_GetTimeoutDelta(IBindCtx *pbc, DWORD *pdwTicksToAllow);
STDAPI BindCtx_RegisterUIWindow(IBindCtx *pbcIn, HWND hwnd, IBindCtx **ppbcOut);
STDAPI_(HWND) BindCtx_GetUIWindow(IBindCtx *pbc);

typedef struct _BINDCTX_PARAM
{
    LPCWSTR pszName;
    IBindCtx *pbcParam;
} BINDCTX_PARAM;
STDAPI BindCtx_RegisterObjectParams(IBindCtx *pbcIn, BINDCTX_PARAM *rgParams, UINT cParams, IBindCtx **ppbcOut);

// SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast)
//
// Given a pidl, you can get an interface pointer (as specified by riid) of the pidl's parent folder (in ppv)
// If ppidlLast is non-NULL, you can also get the pidl of the last item.
//
STDAPI SHBindToIDListParent(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);

//
// SHBindToFolderIDListParent
//
//  Same as SHBindToIDListParent, except you also specify which root to use.
//
STDAPI SHBindToFolderIDListParent(struct IShellFolder *psfRoot, LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlLast);


//
// context menu and dataobject helpers. 
//
STDAPI_(void) ReleaseStgMediumHGLOBAL(void *pv, STGMEDIUM *pmedium);
#define FAILED_AND_NOT_CANCELED(hr) (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
STDAPI SHInvokeCommandOnPidl(HWND hwnd, IUnknown* punk, LPCITEMIDLIST pidl, UINT uFlags, LPCSTR lpVerb);
STDAPI SHInvokeCommandOnPidlArray(HWND hwnd, IUnknown* punk, struct IShellFolder* psf, LPCITEMIDLIST *ppidlItem, UINT cItems, UINT uFlags, LPCSTR lpVerb);
STDAPI SHInvokeCommandOnDataObject(HWND hwnd, IUnknown* punk, IDataObject* pdo, UINT uFlags, LPCSTR lpVerb);


STDAPI DisplayNameOf(struct IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPTSTR psz, UINT cch);
STDAPI DisplayNameOfAsOLESTR(struct IShellFolder *psf, LPCITEMIDLIST pidl, DWORD flags, LPWSTR *ppsz);

//  clones the parent of the pidl
STDAPI_(LPITEMIDLIST) ILCloneParent(LPCITEMIDLIST pidl);

STDAPI SHGetIDListFromUnk(IUnknown *punk, LPITEMIDLIST *ppidl);

STDAPI_(BOOL) ILIsRooted(LPCITEMIDLIST pidl);
STDAPI_(LPCITEMIDLIST) ILRootedFindIDList(LPCITEMIDLIST pidl);
STDAPI_(BOOL) ILRootedGetClsid(LPCITEMIDLIST pidl, CLSID *clsid);
STDAPI_(LPITEMIDLIST) ILRootedCreateIDList(CLSID *pclsid, LPCITEMIDLIST pidl);
STDAPI_(int) ILRootedCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
#define ILIsEqualRoot(pidl1, pidl2) (0 == ILRootedCompare(pidl1, pidl2))
STDAPI ILRootedBindToRoot(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
STDAPI ILRootedBindToObject(LPCITEMIDLIST pidl, REFIID riid, void **ppv);
STDAPI ILRootedBindToParentFolder(LPCITEMIDLIST pidl, REFIID riid, void **ppv, LPCITEMIDLIST *ppidlChild);

typedef HGLOBAL HIDA;

STDAPI_(HIDA) HIDA_Create(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST *apidl);
STDAPI_(void) HIDA_Free(HIDA hida);
STDAPI_(HIDA) HIDA_Clone(HIDA hida);
STDAPI_(UINT) HIDA_GetCount(HIDA hida);
STDAPI_(UINT) HIDA_GetIDList(HIDA hida, UINT i, LPITEMIDLIST pidlOut, UINT cbMax);

STDAPI StgMakeUniqueName(IStorage *pStorageParent, LPCTSTR pszFileSpec, REFIID riid, void **ppv);

STDAPI_(BOOL) PathIsImage(LPCTSTR pszFile);
STDAPI_(BOOL) SHChangeMenuWasSentByMe(LPVOID self, LPCITEMIDLIST pidlNotify);
STDAPI_(void) SHSendChangeMenuNotify(LPVOID self, DWORD shcnee, DWORD shcnf, LPCITEMIDLIST pidl2);

STDAPI_(BOOL) Pidl_Set(LPITEMIDLIST* ppidl, LPCITEMIDLIST pidl);

STDAPI GetHTMLDoc2(IUnknown *punk, struct IHTMLDocument2 **ppHtmlDoc);
STDAPI LocalZoneCheck(IUnknown *punkSite);
STDAPI LocalZoneCheckPath(LPCWSTR pszUrl, IUnknown *punkSite);
STDAPI GetZoneFromUrl(LPCWSTR pszUrl, IUnknown * punkSite, DWORD * pdwZoneID);
STDAPI GetZoneFromSite(IUnknown *punkSite, DWORD * pdwZoneID);

STDAPI SHGetDefaultClientOpenCommandW(LPCWSTR pwszClientType,
        LPWSTR pwszClientCommand, DWORD dwCch,
        OPTIONAL LPWSTR pwszClientParams, DWORD dwCchParams);
STDAPI SHGetDefaultClientNameW(LPCWSTR pwszClientType, LPWSTR pwszBuf, DWORD dwCch);

//===========================================================================
// Helper functions for pidl allocation using the task allocator.
//
STDAPI_(LPITEMIDLIST) _ILCreate(UINT cbSize);
STDAPI SHILClone(LPCITEMIDLIST pidl, LPITEMIDLIST * ppidlOut);
STDAPI SHILCombine(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut);
#define SHILFree(pidl)  SHFree(pidl)

//
//  DLL version helper macros
//
//  To add DllGetVersion support to your DLL, do this:
//
//  1. foo.c
//
//      DLLVER_SINGLEBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);
//
//  or
//
//      DLLVER_DUALBINARY(VER_PRODUCTVERSION_DW, VER_PRODUCTBUILD_QFE);
//
//  depending on whether you are a single-binary or dual-binary component.
//
//  2. foo.src:
//
//      DllGetVersion = CCDllGetVersion             ULTRAPRIVATE
//
//  3. sources:
//
//      LINKLIBS = $(LINKLIBS) $(CCSHELL_DIR)\lib\$(O)\stocklib.lib
//

#define PRODUCTVER_GETMAJOR(ver)    (((ver) & 0xFF000000) >> 24)
#define PRODUCTVER_GETMINOR(ver)    (((ver) & 0x00FF0000) >> 16)
#define PRODUCTVER_GETBUILD(ver)    (((ver) & 0x0000FFFF) >>  0)

#define MAKEDLLVERULL_PRODUCTVERQFE(ver, qfe)               \
        MAKEDLLVERULL(PRODUCTVER_GETMAJOR(ver),             \
                      PRODUCTVER_GETMINOR(ver),             \
                      PRODUCTVER_GETBUILD(ver), qfe)

#define MAKE_DLLVER_STRUCT(ver, plat, qfe)                  \
EXTERN_C const DLLVERSIONINFO2 c_dllver = {                 \
  {                                 /* DLLVERSIONINFO    */ \
    0,                              /* cbSize            */ \
    PRODUCTVER_GETMAJOR(ver),       /* dwMajorVersion    */ \
    PRODUCTVER_GETMINOR(ver),       /* dwMinorVersion    */ \
    PRODUCTVER_GETBUILD(ver),       /* dwBuildNumber     */ \
    plat,                           /* dwPlatformID      */ \
  },                                                        \
    0,                              /* dwFlags           */ \
    MAKEDLLVERULL_PRODUCTVERQFE(ver, qfe), /* ullVersion */ \
}

#define DLLVER_9xBINARY(ver, qfe)                           \
        MAKE_DLLVER_STRUCT(ver, DLLVER_PLATFORM_WINDOWS, qfe)

#define DLLVER_NTBINARY(ver, qfe)                           \
        MAKE_DLLVER_STRUCT(ver, DLLVER_PLATFORM_NT, qfe)

#define DLLVER_SINGLEBINARY     DLLVER_9xBINARY

#ifdef WINNT
#define DLLVER_DUALBINARY       DLLVER_NTBINARY
#else
#define DLLVER_DUALBINARY       DLLVER_9xBINARY
#endif

STDAPI CCDllGetVersion(struct _DLLVERSIONINFO * pinfo);

//
// Mirroring-Support APIs (astracted in \shell\lib\stock5\rtlmir.cpp)
//
#ifdef __cplusplus
extern "C" {
#endif

extern BOOL g_bMirroredOS;

void EditBiDiDLGTemplate(LPDLGTEMPLATE pdt, DWORD dwFlags, PWORD pwIgnoreList, int cIgnore);
#define   EBDT_NOMIRROR        0x00000001
#define   EBDT_FLIP            0x00000002

#ifdef USE_MIRRORING

BOOL  IsBiDiLocalizedSystem( void );
BOOL  IsBiDiLocalizedSystemEx( LANGID *pLangID );
BOOL  Mirror_IsEnabledOS( void );
LANGID Mirror_GetUserDefaultUILanguage( void );
BOOL Mirror_IsUILanguageInstalled( LANGID langId );
BOOL CALLBACK Mirror_EnumUILanguagesProc(LPTSTR lpUILanguageString, LONG_PTR lParam);
BOOL  Mirror_IsWindowMirroredRTL( HWND hWnd );
DWORD Mirror_IsDCMirroredRTL( HDC hdc );
DWORD Mirror_MirrorDC( HDC hdc );
BOOL  Mirror_MirrorProcessRTL( void );
DWORD Mirror_GetLayout( HDC hdc );
DWORD Mirror_SetLayout( HDC hdc , DWORD dwLayout );
BOOL Mirror_GetProcessDefaultLayout( DWORD *pdwDefaultLayout );
BOOL Mirror_IsProcessRTL( void );
extern const DWORD dwNoMirrorBitmap;
extern const DWORD dwExStyleRTLMirrorWnd;
extern const DWORD dwExStyleNoInheritLayout;
extern const DWORD dwPreserveBitmap;
//
// 'g_bMirroredOS' is defined in each component which will use the
//  mirroring APIs. I decided to put it here, in order to make sure
//  each component has validated that the OS supports the mirroring
//  APIs before calling them.
//

#define GET_BIDI_LOCALIZED_SYSTEM_LANGID(pLangID) \
                                        IsBiDiLocalizedSystemEx(pLangID)
#define IS_BIDI_LOCALIZED_SYSTEM()      IsBiDiLocalizedSystem()
#define IS_MIRRORING_ENABLED()          Mirror_IsEnabledOS()
#define IS_WINDOW_RTL_MIRRORED(hwnd)    (g_bMirroredOS && Mirror_IsWindowMirroredRTL(hwnd))
#define IS_DC_RTL_MIRRORED(hdc)         (g_bMirroredOS && Mirror_IsDCMirroredRTL(hdc))
#define GET_PROCESS_DEF_LAYOUT(pdwl)    (g_bMirroredOS && Mirror_GetProcessDefaultLayout(pdwl))
#define IS_PROCESS_RTL_MIRRORED()       (g_bMirroredOS && Mirror_IsProcessRTL())
#define SET_DC_RTL_MIRRORED(hdc)        Mirror_MirrorDC(hdc)
#define SET_DC_LAYOUT(hdc,dwl)          Mirror_SetLayout(hdc,dwl)
#define SET_PROCESS_RTL_LAYOUT()        Mirror_MirrorProcessRTL()
#define GET_DC_LAYOUT(hdc)              Mirror_GetLayout(hdc) 
#define DONTMIRRORBITMAP                dwNoMirrorBitmap
#define RTL_MIRRORED_WINDOW             dwExStyleRTLMirrorWnd
#define RTL_NOINHERITLAYOUT             dwExStyleNoInheritLayout
#define LAYOUT_PRESERVEBITMAP           dwPreserveBitmap

#else

#define GET_BIDI_LOCALIZED_SYSTEM_LANGID(pLangID) \
                                        FALSE
#define IS_BIDI_LOCALIZED_SYSTEM()      FALSE
#define IS_MIRRORING_ENABLED()          FALSE
#define IS_WINDOW_RTL_MIRRORED(hwnd)    FALSE
#define IS_DC_RTL_MIRRORED(hdc)         FALSE
#define GET_PROCESS_DEF_LAYOUT(pdwl)    FALSE
#define IS_PROCESS_RTL_MIRRORED()       FALSE
#define SET_DC_RTL_MIRRORED(hdc)        
#define SET_DC_LAYOUT(hdc,dwl)
#define SET_PROCESS_DEFAULT_LAYOUT() 
#define GET_DC_LAYOUT(hdc)              0L

#define DONTMIRRORBITMAP                0L
#define RTL_MIRRORED_WINDOW             0L
#define LAYOUT_PRESERVEBITMAP           0L
#define RTL_NOINHERITLAYOUT             0L

#endif  // USE_MIRRROING

BOOL IsBiDiLocalizedWin95( BOOL bArabicOnly );

//------------------------------------------------------------------------
// Dynamic class array
//
typedef struct _DCA * HDCA;     // hdca

HDCA DCA_Create();
void DCA_Destroy(HDCA hdca);
int  DCA_GetItemCount(HDCA hdca);
BOOL DCA_AddItem(HDCA hdca, REFCLSID rclsid);
const CLSID * DCA_GetItem(HDCA hdca, int i);

void DCA_AddItemsFromKeyA(HDCA hdca, HKEY hkey, LPCSTR pszSubKey);
void DCA_AddItemsFromKeyW(HDCA hdca, HKEY hkey, LPCWSTR pszSubKey);

#ifdef UNICODE
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyW
#else
#define DCA_AddItemsFromKey     DCA_AddItemsFromKeyA
#endif 

STDAPI DCA_CreateInstance(HDCA hdca, int iItem, REFIID riid, void ** ppv);


#ifdef __cplusplus
};
#endif

#endif // RC_INVOKED

//------------------------------------------------------------------------
// Random helpful functions
//------------------------------------------------------------------------
//
#define EDGE_LEFT       0x00000001
#define EDGE_RIGHT      0x00000002
#define EDGE_TOP        0x00000004
#define EDGE_BOTTOM     0x00000008

STDAPI_(DWORD) SHIsButtonObscured(HWND hwnd, PRECT prc, INT_PTR i);
STDAPI_(void) _SHPrettyMenu(HMENU hm);
STDAPI_(BOOL) _SHIsMenuSeparator(HMENU hm, int i);
STDAPI_(BOOL) _SHIsMenuSeparator2(HMENU hm, int i, BOOL *pbIsNamed);
STDAPI_(BYTE) SHBtnStateFromRestriction(DWORD dwRest, BYTE fsState);
STDAPI_(BOOL) SHIsDisplayable(LPCWSTR pwszName, BOOL fRunOnFE, BOOL fRunOnNT5);

#define SHProcessMessagesUntilEvent(hwnd, hEvent, dwTimeout)        SHProcessMessagesUntilEventEx(hwnd, hEvent, dwTimeout, QS_ALLINPUT)
#define SHProcessSentMessagesUntilEvent(hwnd, hEvent, dwTimeout)    SHProcessMessagesUntilEventEx(hwnd, hEvent, dwTimeout, QS_SENDMESSAGE)
STDAPI_(DWORD) SHProcessMessagesUntilEventEx(HWND hwnd, HANDLE hEvent, DWORD dwTimeout, DWORD dwWakeMask);

STDAPI_(BOOL) SetWindowZorder(HWND hwnd, HWND hwndInsertAfter);
STDAPI_(BOOL) SHForceWindowZorder(HWND hwnd, HWND hwndInsertAfter);

STDAPI_(void) EnableOKButtonFromString(HWND hDlg, LPTSTR pszText);
STDAPI_(void) EnableOKButtonFromID(HWND hDlg, int id);

STDAPI_(void) AlphaStripRenderIcon(HDC hdc, int x, int y, HICON hicon, HDC hdcCompatible);

STDAPI_(void) SHAdjustLOGFONTA(IN OUT LOGFONTA *plf);
STDAPI_(void) SHAdjustLOGFONTW(IN OUT LOGFONTW *plf);
#ifdef UNICODE
#define SHAdjustLOGFONT         SHAdjustLOGFONTW
#else
#define SHAdjustLOGFONT         SHAdjustLOGFONTA
#endif

STDAPI SHLoadLegacyRegUIStringA(HKEY hk, LPCSTR pszSubkey, LPSTR pszOutBuf, UINT cchOutBuf);
STDAPI SHLoadLegacyRegUIStringW(HKEY hk, LPCWSTR pszSubkey, LPWSTR pszOutBuf, UINT cchOutBuf);
#ifdef UNICODE
#define SHLoadLegacyRegUIString SHLoadLegacyRegUIStringW
#else
#define SHLoadLegacyRegUIString SHLoadLegacyRegUIStringA
#endif

// These 2 functions determine whether a registry subkey exists by
// trying to open and close the key using the KEY_QUERY_VALUE sam.
STDAPI_(BOOL) SHRegSubKeyExistsA(HKEY hkey, PCSTR  pszSubKey);                                                      // DO NOT MAKE PUBLIC IN SHLWAPI: use SHRegGetValue() directly
STDAPI_(BOOL) SHRegSubKeyExistsW(HKEY hkey, PCWSTR pwszSubKey);                                                     // DO NOT MAKE PUBLIC IN SHLWAPI: use SHRegGetValue() directly
STDAPI        SHRegGetDWORDA(    HKEY hkey, PCSTR  pszSubKey,  PCSTR  pszValue,  DWORD *pdwData);                   // DO NOT MAKE PUBLIC IN SHLWAPI: use SHRegGetValue() directly
STDAPI        SHRegGetDWORDW(    HKEY hkey, PCWSTR pwszSubKey, PCWSTR pwszValue, DWORD *pdwData);                   // DO NOT MAKE PUBLIC IN SHLWAPI: use SHRegGetValue() directly
STDAPI        SHRegGetStringA(   HKEY hkey, PCSTR  pszSubKey,  PCSTR  pszValue,  PSTR   pszData,  DWORD cchData);   // DO NOT MAKE PUBLIC IN SHLWAPI: use SHRegGetValue() directly
STDAPI        SHRegGetStringW(   HKEY hkey, PCWSTR pwszSubKey, PCWSTR pwszValue, PWSTR  pwszData, DWORD cchData);   // DO NOT MAKE PUBLIC IN SHLWAPI: use SHRegGetValue() directly
STDAPI        SHRegAllocStringA( HKEY hkey, PCSTR  pszSubKey,  PCSTR  pszValue,  PSTR * ppszData);                  // DO NOT MAKE PUBLIC IN SHLWAPI: use SHRegGetValue() directly
STDAPI        SHRegAllocStringW( HKEY hkey, PCWSTR pwszSubKey, PCWSTR pwszValue, PWSTR *ppwszData);                 // DO NOT MAKE PUBLIC IN SHLWAPI: use SHRegGetValue() directly
#ifdef UNICODE
#define SHRegSubKeyExists SHRegSubKeyExistsW
#define SHRegGetDWORD     SHRegGetDWORDW
#define SHRegGetString    SHRegGetStringW
#define SHRegAllocString  SHRegAllocStringW
#else
#define SHRegSubKeyExists SHRegSubKeyExistsA
#define SHRegGetDWORD     SHRegGetDWORDA
#define SHRegGetString    SHRegGetStringA
#define SHRegAllocString  SHRegAllocStringA
#endif



STDAPI_(CHAR) SHFindMnemonicA(LPCSTR psz);
STDAPI_(WCHAR) SHFindMnemonicW(LPCWSTR psz);
#ifdef UNICODE
#define SHFindMnemonic SHFindMnemonicW
#else
#define SHFindMnemonic SHFindMnemonicA
#endif

typedef struct tagINSTALL_INFO
{
    LPTSTR szSource;
    LPTSTR szDest;
    DWORD dwDestAttrib;
} INSTALL_INFO;

//
//  Special attributes in INSTALL_INFO.dwDestAttrib.  We use attributes
//  that we would never otherwise use.
//
#define FILE_ATTRIBUTE_INSTALL_NTONLY    FILE_ATTRIBUTE_DEVICE
#define FILE_ATTRIBUTE_INSTALL_9XONLY    FILE_ATTRIBUTE_TEMPORARY

// superhidden files are attrib'ed +h +s
#define FILE_ATTRIBUTE_SUPERHIDDEN (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN) 
#define IS_SYSTEM_HIDDEN(dw) ((dw & FILE_ATTRIBUTE_SUPERHIDDEN) == FILE_ATTRIBUTE_SUPERHIDDEN) 

STDAPI GetInstallInfoFromResource(HINSTANCE hResourceInst, UINT uID, INSTALL_INFO *piiFile);
STDAPI InstallInfoFreeMembers(INSTALL_INFO *piiFile);
STDAPI InstallFileFromResource(HINSTANCE hInstResource, INSTALL_INFO *piiFile, LPCTSTR pszDestDir);

#ifndef OBJCOMPATFLAGS
typedef DWORD OBJCOMPATFLAGS;
#endif

STDAPI_(OBJCOMPATFLAGS) SHGetObjectCompatFlagsFromIDList(LPCITEMIDLIST pidl);

#define ROUS_DEFAULTALLOW       0x0000
#define ROUS_DEFAULTRESTRICT    0x0001
#define ROUS_KEYALLOWS          0x0000
#define ROUS_KEYRESTRICTS       0x0002

STDAPI_(BOOL) IsRestrictedOrUserSettingA(HKEY hkeyRoot, enum RESTRICTIONS rest, LPCSTR pszSubKey, LPCSTR pszValue, UINT flags);
STDAPI_(BOOL) IsRestrictedOrUserSettingW(HKEY hkeyRoot, enum RESTRICTIONS rest, LPCWSTR pszSubKey, LPCWSTR pszValue, UINT flags);
STDAPI_(BOOL) GetExplorerUserSettingA(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue);
STDAPI_(BOOL) GetExplorerUserSettingW(HKEY hkeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValue);

#ifdef UNICODE
#define IsRestrictedOrUserSetting   IsRestrictedOrUserSettingW
#define GetExplorerUserSetting      GetExplorerUserSettingW
#else
#define IsRestrictedOrUserSetting   IsRestrictedOrUserSettingA
#define GetExplorerUserSetting      GetExplorerUserSettingA
#endif

//
// PropertBag helpers

STDAPI_(void) SHPropertyBag_ReadStrDef(IPropertyBag* ppb, LPCWSTR pszPropName, LPWSTR psz, int cch, LPCWSTR pszDef);
STDAPI_(void) SHPropertyBag_ReadIntDef(IPropertyBag* ppb, LPCWSTR pszPropName, int* piResult, int iDef);
STDAPI_(void) SHPropertyBag_ReadSHORTDef(IPropertyBag* ppb, LPCWSTR pszPropName, SHORT* psh, SHORT shDef);
STDAPI_(void) SHPropertyBag_ReadLONGDef(IPropertyBag* ppb, LPCWSTR pszPropName, LONG* pl, LONG lDef);
STDAPI_(void) SHPropertyBag_ReadDWORDDef(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw, DWORD dwDef);
STDAPI_(void) SHPropertyBag_ReadBOOLDef(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL* pf, BOOL fDef);
STDAPI_(void) SHPropertyBag_ReadGUIDDef(IPropertyBag* ppb, LPCWSTR pszPropName, GUID* pguid, const GUID* pguidDef);
STDAPI_(void) SHPropertyBag_ReadPOINTLDef(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt, const POINTL* pptDef);
STDAPI_(void) SHPropertyBag_ReadPOINTSDef(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt, const POINTS* pptDef);
STDAPI_(void) SHPropertyBag_ReadRECTLDef(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc, const RECTL* prcDef);
STDAPI_(BOOL) SHPropertyBag_ReadBOOLDefRet(IPropertyBag* ppb, LPCWSTR pszPropName, BOOL fDef);
STDAPI SHPropertyBag_ReadStreamScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, IStream** ppstm);
STDAPI SHPropertyBag_WriteStreamScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, IStream* pstm);
STDAPI SHPropertyBag_ReadPOINTSScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, POINTS* ppt);
STDAPI SHPropertyBag_WritePOINTSScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTS* ppt);
STDAPI_(void) SHPropertyBag_ReadDWORDScreenResDef(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD* pdw, DWORD dwDef);
STDAPI SHPropertyBag_WriteDWORDScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, DWORD dw);
STDAPI SHPropertyBag_ReadPOINTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, POINTL* ppt);
STDAPI SHPropertyBag_WritePOINTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const POINTL* ppt);
STDAPI SHPropertyBag_ReadRECTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, RECTL* prc);
STDAPI SHPropertyBag_WriteRECTLScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName, const RECTL* prc);
STDAPI SHPropertyBag_DeleteScreenRes(IPropertyBag* ppb, LPCWSTR pszPropName);


#define VS_BAGSTR_EXPLORER      L"Shell"
#define VS_BAGSTR_DESKTOP       L"Desktop"
#define VS_BAGSTR_COMCLG        L"ComDlg"

#define VS_PROPSTR_MINPOS       L"MinPos"
#define VS_PROPSTR_MAXPOS       L"MaxPos"
#define VS_PROPSTR_POS          L"WinPos"
#define VS_PROPSTR_MODE         L"Mode"
#define VS_PROPSTR_REV          L"Rev"
#define VS_PROPSTR_WPFLAGS      L"WFlags"
#define VS_PROPSTR_SHOW         L"ShowCmd"
#define VS_PROPSTR_FFLAGS       L"FFlags"
#define VS_PROPSTR_HOTKEY       L"HotKey"
#define VS_PROPSTR_BUTTONS      L"Buttons"
#define VS_PROPSTR_STATUS       L"Status"
#define VS_PROPSTR_LINKS        L"Links"
#define VS_PROPSTR_ADDRESS      L"Address"
#define VS_PROPSTR_VID          L"Vid"
#define VS_PROPSTR_SCROLL       L"ScrollPos"
#define VS_PROPSTR_SORT         L"Sort"
#define VS_PROPSTR_SORTDIR      L"SortDir"
#define VS_PROPSTR_COL          L"Col"
#define VS_PROPSTR_COLINFO      L"ColInfo"
#define VS_PROPSTR_ITEMPOS      L"ItemPos"





//------------------------------------------------------------------------

////////////////
//
//  Critical section stuff
//
//  Helper macros that give nice debug support
//
EXTERN_C CRITICAL_SECTION g_csDll;
#ifdef DEBUG
EXTERN_C UINT g_CriticalSectionCount;
EXTERN_C DWORD g_CriticalSectionOwner;
EXTERN_C void Dll_EnterCriticalSection(CRITICAL_SECTION*);
EXTERN_C void Dll_LeaveCriticalSection(CRITICAL_SECTION*);
#if defined(__cplusplus) && defined(AssertMsg)
class DEBUGCRITICAL {
protected:
    BOOL fClosed;
public:
    DEBUGCRITICAL() {fClosed = FALSE;};
    void Leave() {fClosed = TRUE;};
    ~DEBUGCRITICAL() 
    {
        AssertMsg(fClosed, TEXT("you left scope while holding the critical section"));
    }
};
#define ENTERCRITICAL DEBUGCRITICAL debug_crit; Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL debug_crit.Leave(); Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#else // __cplusplus
#define ENTERCRITICAL Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL Dll_LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT Dll_EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT Dll_LeaveCriticalSection(&g_csDll)
#endif // __cplusplus
#define ASSERTCRITICAL ASSERT(g_CriticalSectionCount > 0 && GetCurrentThreadId() == g_CriticalSectionOwner)
#define ASSERTNONCRITICAL ASSERT(GetCurrentThreadId() != g_CriticalSectionOwner)
#else // DEBUG
#define ENTERCRITICAL EnterCriticalSection(&g_csDll)
#define LEAVECRITICAL LeaveCriticalSection(&g_csDll)
#define ENTERCRITICALNOASSERT EnterCriticalSection(&g_csDll)
#define LEAVECRITICALNOASSERT LeaveCriticalSection(&g_csDll)
#define ASSERTCRITICAL 
#define ASSERTNONCRITICAL
#endif // DEBUG

////////////////
//
//  computer display name support
//
//   Display name: A formatted name that NetFldr uses. It is currently constructed out of the computer name,
//                 and, if available, the computer comment (description).
//   DSheldon
STDAPI SHBuildDisplayMachineName(LPCWSTR pszMachineName, LPCWSTR pszComment, LPWSTR pszDisplayName, DWORD cchDisplayName);
STDAPI CreateFromRegKey(LPCWSTR pszKey, LPCWSTR pszValue, REFIID riid, void **ppv);

STDAPI_(LPCTSTR) SkipServerSlashes(LPCTSTR pszName);

//
// A couple of inline functions that create an HRESULT from
// a Win32 error code without the double-evaluation side effect of
// the HRESULT_FROM_WIN32 macro.  
//
// Use ResultFromWin32 in place of HRESULT_FROM_WIN32 if 
// the side effects of that macro are unwanted.  
// ResultFromLastError was created as a convenience for a 
// common idiom.  
// You could simply call ResultFromWin32(GetLastError()) yourself.
//
__inline HRESULT ResultFromWin32(DWORD dwErr)
{
    return HRESULT_FROM_WIN32(dwErr);
}

__inline HRESULT ResultFromLastError(void)
{
    return ResultFromWin32(GetLastError());
}

STDAPI_(void) IEPlaySound(LPCTSTR pszSound, BOOL fSysSound);

STDAPI IUnknown_DragEnter(IUnknown* punk, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
STDAPI IUnknown_DragOver(IUnknown* punk, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
STDAPI IUnknown_DragLeave(IUnknown* punk);
STDAPI IUnknown_Drop(IUnknown* punk, IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

STDAPI_(BOOL) IsTypeInList(LPCTSTR pszType, const LPCTSTR *arszList, UINT cList);

//----------------------------------------------------------------------
//  Msg:    WM_MSIME_MODEBIAS
//  Desc:   input mode bias
//  Owner:  YutakaN
//  Usage:  SendMessage( hwndDefUI, WM_MSIME_MODEBIAS, MODEBIAS_xxxx, MODEBIASMODE_xxxx );
//  wParam: operation of bias
//  lParam: bias mode
//  return: If wParam is MODEBIAS_GETVERSION,returns version number of interface.
//          If wParam is MODEBIAS_SETVALUE : return non-zero value if succeeded. Returns 0 if fail.
//          If wParam is MODEBIAS_GETVALUE : returns current bias mode.

// Label for RegisterWindowMessage
#define	RWM_MODEBIAS            TEXT("MSIMEModeBias")

// Current version
#define VERSION_MODEBIAS        1

// Set or Get (wParam)
#define MODEBIAS_GETVERSION     0
#define MODEBIAS_SETVALUE       1
#define MODEBIAS_GETVALUE       2

// Bias (lParam)
#define MODEBIASMODE_DEFAULT                0x00000000	// reset all of bias setting
#define MODEBIASMODE_FILENAME               0x00000001	// filename
#define MODEBIASMODE_READING                0x00000002	// reading recommended
#define MODEBIASMODE_DIGIT                  0x00000004	// ANSI-Digit Recommended Mode
#define MODEBIASMODE_URLHISTORY             0x00010000  // URL history

STDAPI_(void) SetModeBias(DWORD dwMode);



#endif // __CCSTOCK_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\cowsite.h ===
#ifndef _COWSITE_H_
#define _COWSITE_H_

class CObjectWithSite : public IObjectWithSite
{
public:
    CObjectWithSite()  {_punkSite = NULL;};
    virtual ~CObjectWithSite() {ATOMICRELEASE(_punkSite);}

    //*** IUnknown ****
    // (client must provide!)

    //*** IObjectWithSite ***
    STDMETHOD(SetSite)(IUnknown *punkSite);
    STDMETHOD(GetSite)(REFIID riid, void **ppvSite);

protected:
    IUnknown*   _punkSite;
};

//
//  use this when you dont have a good Destroy site chain event - ZekeL - 20-DEC-2000
//  if you need to call SetSite(NULL) on your children, and 
//  would prefer to do this cleanup in your destructor.
//  your object should be implemented like this
//
/******
class CMyObject : public IMyInterface
{
private:
    CSafeServiceSite *_psss;
    IKid _pkid;

    CMyObject() 
    {
        _psss = new CSafeServiceSite();
        if (_psss)
            _psss->SetProviderWeakRef(this);
    }

    ~CMyObject() 
    {
        if (_psss)
        {
            _psss->SetProviderWeakRef(NULL);
            _psss->Release();
        }

        if (_pkid)
        {
            IUnknown_SetSite(_pkid, _psss);
            _pkid->Release();
        }
    }

public:
    //  IMyInterface
    HRESULT Init()
    {
        CoCreate(CLSID_Kid, &_pkid);
        IUnknown_SetSite(_pkid, _psss);
    }
    // NOTE - there is no Uninit()
    //  so it's hard to know when to release _pkid
    //  and you dont want to _pkid->SetSite(NULL)
    //  unless you are sure you are done
};
******/
        
class CSafeServiceSite : public IServiceProvider
{
public:
    CSafeServiceSite() : _cRef(1), _psp(NULL) {}
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    // our personal weak ref
    HRESULT SetProviderWeakRef(IServiceProvider *psp);

private:    //  methods
    ~CSafeServiceSite()
        { ASSERT(_psp == NULL); }

private:    //  members
    LONG _cRef;
    IServiceProvider *_psp;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\cnctnpt.h ===
#ifndef __CNCTNPT_H__
#define __CNCTNPT_H__

//
//  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//
//  This class is shared between DLLs, and DLLs that use it have already
//  shipped as part of IE4 (specifically, shell32).  This means that
//  any changes you make must be done EXTREMELY CAREFULLY and TESTED
//  FOR INTEROPERABILITY WITH IE4!  For one thing, you have to make sure
//  that none of your changes alter the vtbl used by IE4's shell32.
//
//  If you change CIE4ConnectionPoint, you must build SHDOC401 and
//  test it on IE4!
//
//  WARNING WARNING WARNING WARNING WARNING WARNING WARNING WARNING
//

//
//  First, the class as it was defined in IE4.  All virtual functions
//  must be be listed in exactly the same order as they were in IE4.
//  Fortunately, no cross-component users mucked with the member
//  variables.
//
//  Change any of these at your own risk.
//
class CIE4ConnectionPoint : public IConnectionPoint {

public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
    virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;

    // IConnectionPoint methods
    //
    virtual STDMETHODIMP GetConnectionInterface(IID FAR* pIID) PURE;
    virtual STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer FAR* FAR* ppCPC) PURE;
    virtual STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD FAR* pdwCookie) PURE;
    virtual STDMETHODIMP Unadvise(DWORD dwCookie) PURE;
    virtual STDMETHODIMP EnumConnections(LPENUMCONNECTIONS FAR* ppEnum) PURE;

    // This is how you actually fire the events
    // Those called by shell32 are virtual
    // (Renamed to DoInvokeIE4)
    virtual HRESULT DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams) PURE;

    // This helper function does work that callers of DoInvoke often need done
    virtual HRESULT DoInvokePIDLIE4(DISPID dispid, LPCITEMIDLIST pidl, BOOL fCanCancel) PURE;

};

//
// CConnectionPoint is an implementation of a conection point.
// To get the rest of the implementation, you also have to include
// lib\cnctnpt.cpp in your project.
//
// Embed an instance of CConnectionPoint in an object that needs to
// implement a connectionpoint and call SetOwner to initialize it.
//
// Fire events to anyone connected to this connectionpoint via DoInvoke
// or DoOnChanged.  External clients should use the shlwapi functions
// like IConnectionPoint_Invoke or IConnectionPoint_OnChanged.
//

class CConnectionPoint : public CIE4ConnectionPoint {
    friend class CConnectionPointEnum;

public:
    // IUnknown methods
    //
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void)
        { return m_punk->AddRef(); }
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return m_punk->Release(); }

    // IConnectionPoint methods
    //
    virtual STDMETHODIMP GetConnectionInterface(IID * pIID);
    virtual STDMETHODIMP GetConnectionPointContainer(IConnectionPointContainer ** ppCPC);
    virtual STDMETHODIMP Advise(LPUNKNOWN pUnkSink, DWORD * pdwCookie);
    virtual STDMETHODIMP Unadvise(DWORD dwCookie);
    virtual STDMETHODIMP EnumConnections(LPENUMCONNECTIONS * ppEnum);

    // CIE4ConnectionPoint methods - called by IE4's shell32
    virtual HRESULT DoInvokeIE4(LPBOOL pf, LPVOID *ppv, DISPID dispid, DISPPARAMS *pdispparams);

    // DoInvokePidlIE4 is strange in that shell32 linked to it but never
    // actually called it.  This makes the implementation particularly simple.
    virtual HRESULT DoInvokePIDLIE4(DISPID dispid, LPCITEMIDLIST pidl, BOOL fCanCancel)
    { return E_NOTIMPL; }

public:
    // Additional helper methods

    // Performs a basic DISPID Invoke on the object
    inline HRESULT InvokeDispid(DISPID dispid) {
        return IConnectionPoint_SimpleInvoke(this, dispid, NULL);
    }

    // Performs an OnChanged on the object
    inline HRESULT OnChanged(DISPID dispid) {
        return IConnectionPoint_OnChanged(this, dispid);
    }

    // A couple functions to setup and destroy this subclass object
    ~CConnectionPoint(); // not virtual: nobody inherits from this class

    //
    //  The containing object must call SetOwner to initialize the
    //  connection point.
    //
    //  punk - The IUnknown of the object this ConnectionPoint is
    //         embedded in; it will be treated as the connection
    //         point container.
    //
    //  piid - The IID that the sinks are expected to support.
    //         If you call DoInvoke, then it must be derived from
    //         IID_IDispatch.  If you call DoOnChanged, then it must
    //         be exactly &IID_IPropertyNotifySink.
    //
    void SetOwner(IUnknown* punk, const IID* piid)
        {
            // Validate the special requirement on the piid parameter.
            if (*piid == IID_IPropertyNotifySink)
            {
                ASSERT(piid == &IID_IPropertyNotifySink);
            }

            // don't AddRef -- we're a member variable of the object punk points to
            m_punk = punk;
            m_piid = piid;
        }

    // The underline version is inline
    BOOL _HasSinks() { return (BOOL)m_cSinks; }

    // We are empty if there are no sinks
    BOOL IsEmpty() { return !_HasSinks(); }

    HRESULT UnadviseAll(void);

    // A lot of people need to convert a CConnectionPoint into an
    // IConnectionPoint.  We used to be multiply inherited, hence the
    // need for this member, but that's gone now.
    IConnectionPoint *CastToIConnectionPoint()
        { return SAFECAST(this, IConnectionPoint*); }

private:
    IUnknown **m_rgSinks;
    int m_cSinks;
    int m_cSinksAlloc;

    IUnknown *m_punk;   // IUnknown of object containing us
    const IID *m_piid;  // IID of this connection point
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\cobjsafe.h ===
#ifndef _COBJSAFE_H_
#define _COBJSAFE_H_

// Static functions of interest to others
HRESULT DefaultGetSafetyOptions(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
HRESULT DefaultSetSafetyOptions(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
HRESULT MakeSafeForScripting(IUnknown **punk); // returns TRUE if punk is safe for scripting

class CObjectSafety : public IObjectSafety
{
public:
    CObjectSafety() : _dwSafetyOptions(0) { }

    // IUnknown (we multiply inherit from IUnknown, disambiguate here)
    STDMETHOD(QueryInterface)(REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;
    
    // IObjectSafety
    STDMETHOD(GetInterfaceSafetyOptions)(REFIID riid, DWORD *pdwSupportedOptions, DWORD *pdwEnabledOptions);
    STDMETHOD(SetInterfaceSafetyOptions)(REFIID riid, DWORD dwOptionSetMask, DWORD dwEnabledOptions);
    
protected:
    DWORD           _dwSafetyOptions;   // IObjectSafety IID_IDispatch options

};
   
#endif // _COBJSAFE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\cstrinout.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-2000
//
//  File:       cstrinout.h
//
//  Contents:   shell-wide string thunkers, for use by unicode wrappers
//
//----------------------------------------------------------------------------

#ifndef _CSTRINOUT_HXX_
#define _CSTRINOUT_HXX_

#define CP_ATOM         0xFFFFFFFF          /* not a string at all */

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStr (CStr)
//
//  Purpose:    Base class for conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStr
{
public:
    operator char *();
    inline BOOL IsAtom() { return _uCP == CP_ATOM; }

protected:
    CConvertStr(UINT uCP);
    ~CConvertStr();
    void Free();

    UINT    _uCP;
    LPSTR   _pstr;
    char    _ach[MAX_PATH * sizeof(WCHAR)];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::CConvertStr
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::CConvertStr(UINT uCP)
{
    _uCP = uCP;
    _pstr = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::~CConvertStr
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStr::~CConvertStr()
{
    Free();
}





//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::operator char *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline
CConvertStr::operator char *()
{
    return _pstr;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrIn (CStrI)
//
//  Purpose:    Converts string function arguments which are passed into
//              a Windows API.
//
//----------------------------------------------------------------------------

class CStrIn : public CConvertStr
{
public:
    CStrIn(LPCWSTR pwstr);
    CStrIn(LPCWSTR pwstr, int cwch);
    CStrIn(UINT uCP, LPCWSTR pwstr);
    CStrIn(UINT uCP, LPCWSTR pwstr, int cwch);
    int strlen();

protected:
    CStrIn();
    void Init(LPCWSTR pwstr, int cwch);

    int _cchLen;
};




//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class with a given length
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn(LPCWSTR pwstr, int cwch) : CConvertStr(CP_ACP)
{
    Init(pwstr, cwch);
}

inline
CStrIn::CStrIn(UINT uCP, LPCWSTR pwstr, int cwch) : CConvertStr(uCP)
{
    Init(pwstr, cwch);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrIn::CStrIn() : CConvertStr(CP_ACP)
{
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrIn::strlen()
{
    return _cchLen;
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrInMulti (CStrIM)
//
//  Purpose:    Converts multiple strings which are terminated by two NULLs,
//              e.g. "Foo\0Bar\0\0"
//
//----------------------------------------------------------------------------

class CStrInMulti : public CStrIn
{
public:
    CStrInMulti(LPCWSTR pwstr);
};


//+---------------------------------------------------------------------------
//
//  Class:      CPPFIn
//
//  Purpose:    Converts string function arguments which are passed into
//              a Win9x PrivateProfile API.  Win9x DBCS has a bug where
//              passing a string longer than MAX_PATH will fault kernel.
//
//              PPF = Private Profile Filename
//
//----------------------------------------------------------------------------

class CPPFIn
{
public:
    operator char *();
    CPPFIn(LPCWSTR pwstr);

private:
    char _ach[MAX_PATH];
};

//+---------------------------------------------------------------------------
//
//  Member:     CPPFIn::operator char *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline
CPPFIn::operator char *()
{
    return _ach;
}

//+---------------------------------------------------------------------------
//
//  Class:      CStrOut (CStrO)
//
//  Purpose:    Converts string function arguments which are passed out
//              from a Windows API.
//
//----------------------------------------------------------------------------

class CStrOut : public CConvertStr
{
public:
    CStrOut(LPWSTR pwstr, int cwchBuf);
    CStrOut(UINT uCP, LPWSTR pwstr, int cwchBuf);
    ~CStrOut();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();
protected:
    void Init(LPWSTR pwstr, int cwchBuf);
private:
    LPWSTR  _pwstr;
    int     _cwchBuf;
};


//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOut::BufSize()
{
    return _cwchBuf * sizeof(WCHAR);
}

//
//	Multi-Byte ---> Unicode conversion
//

//+---------------------------------------------------------------------------
//
//  Class:      CConvertStrW (CStr)
//
//  Purpose:    Base class for multibyte conversion classes.
//
//----------------------------------------------------------------------------

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * sizeof(WCHAR)];
};



//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::CConvertStrW
//
//  Synopsis:   ctor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}


//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::~CConvertStrW
//
//  Synopsis:   dtor.
//
//----------------------------------------------------------------------------

inline
CConvertStrW::~CConvertStrW()
{
    Free();
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::operator WCHAR *
//
//  Synopsis:   Returns the string.
//
//----------------------------------------------------------------------------

inline 
CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}


//+---------------------------------------------------------------------------
//
//  Class:      CStrInW (CStrI)
//
//  Purpose:    Converts multibyte strings into UNICODE
//
//----------------------------------------------------------------------------

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr) { Init(pstr, -1); }
    CStrInW(LPCSTR pstr, int cch) { Init(pstr, cch); }
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch);

    int _cwchLen;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::CStrInW
//
//  Synopsis:   Initialization for derived classes which call Init.
//
//----------------------------------------------------------------------------

inline
CStrInW::CStrInW()
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::strlen
//
//  Synopsis:   Returns the length of the string in characters, excluding
//              the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrInW::strlen()
{
    return _cwchLen;
}

//+---------------------------------------------------------------------------
//
//  Class:      CStrOutW (CStrO)
//
//  Purpose:    Converts returned unicode strings into ANSI.  Used for [out]
//              params (so we initialize with a buffer that should later be
//              filled with the correct ansi data)
//
//
//----------------------------------------------------------------------------

class CStrOutW : public CConvertStrW
{
public:
    CStrOutW(LPSTR pstr, int cchBuf);
    ~CStrOutW();

    int     BufSize();
    int     ConvertIncludingNul();
    int     ConvertExcludingNul();

private:
    LPSTR  	_pstr;
    int     _cchBuf;
};

//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::BufSize
//
//  Synopsis:   Returns the size of the buffer to receive an out argument,
//              including the terminating NULL.
//
//----------------------------------------------------------------------------

inline int
CStrOutW::BufSize()
{
    return _cchBuf;
}



#endif // _CSTRINOUT_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\cwndproc.h ===
#ifndef _CWNDPROC_H_
#define _CWNDPROC_H_

// CImpWndProc
//
// Use this class when you want to associate a window with
// an object using a virtual wndproc.
// 
// NOTE: The window's lifetime must be encompassed by the object.
//       I.E. NO REFCOUNT IS HELD ON THE OBJECT!
//
// Messages after WM_NCCREATE up to and including WM_DESTROY
// are forwarded to v_WndProc.
//
// _hwnd is non-NULL from WM_NCCREATE up to but not during WM_DESTROY.
// (Not during because the final release may be tied to WM_DESTROY
// so we cannot reference member variables after forwarding thie message.)
//
class CImpWndProc
{
public:
    virtual ULONG __stdcall AddRef() = 0;
    virtual ULONG __stdcall Release() = 0;

protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    HWND _hwnd;

} ;


// CNotifySubclassWndProc
//
// This class subclasses an HWND, registers for SHChangeNotify events,
// and forwards them to the inheritor's IShellChangeNotify implementation.
//
// You need one instance of this class per window you want to subclass
// and register for events against. (So if you need >1 window hooked up
// in this matter, you need to have member implementations that inherit
// from this class.)
//
class CNotifySubclassWndProc
{
public:
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;

protected:
    BOOL _SubclassWindow(HWND hwnd);
    void _UnsubclassWindow(HWND hwnd);
    void _RegisterWindow(HWND hwnd, LPCITEMIDLIST pidl, long lEvents,
                         UINT uFlags = (SHCNRF_ShellLevel | SHCNRF_InterruptLevel));
    void _UnregisterWindow(HWND hwnd);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    void _FlushNotifyMessages(HWND hwnd);

private:
    static LRESULT CALLBACK _SubclassWndProc(
                                  HWND hwnd, UINT uMessage, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

    UINT        _uRegister;         // SHChangeNotify id

#ifdef DEBUG
    HWND        _hwndSubclassed;
#endif
} ;

#endif _CWNDPROC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\crtfree.h ===
//
// Code to help free modules from the bondage and tyranny of CRT libraries
//
// Include this header in a single component and #define DECL_CRTFREE.
// (CPP_FUNCTIONS is the old name.)
//

#if defined(__cplusplus) && (defined(CPP_FUNCTIONS) || defined(DECL_CRTFREE))

#ifndef UNIX

void *  __cdecl operator new(size_t nSize)
{
    // Zero init just to save some headaches
    return (LPVOID)LocalAlloc(LPTR, nSize);
}

void  __cdecl operator delete(void *pv)
{
    //delete and LocalFree both handle NULL, others don't
    //If changed to GlobalFree or HeapFree - must check for NULL here
    LocalFree((HLOCAL)pv);
}
#endif

extern "C" int __cdecl _purecall(void) 
{
#ifdef ASSERT_MSG
    ASSERT_MSG(0, "purecall() hit");
#endif

#ifdef DEBUG
    DebugBreak();
#endif // DEBUG
    return 0;
}

#endif  // DECL_CRTFREE


#ifdef __cplusplus
extern "C" {
#endif

#if defined(DEFINE_FLOAT_STUFF)
// If you aren't using any floating-point CRT functions and you know
// you aren't performing any float conversions or arithmetic, yet the
// linker wants these symbols declared, then define DEFINE_FLOAT_STUFF.
//
// Warning: declaring these symbols in a component that needs floating
// point support from the CRT will produce undefined results.  (You will
// need fp support from the CRT if you simply perform fp arithmetic.)

int _fltused = 0;
void __cdecl _fpmath(void) { }
#endif

#ifdef __cplusplus
};
#endif

//
// This file should be included in a global component header
// to use the following
//

#ifndef __CRTFREE_H_
#define __CRTFREE_H_

#ifdef __cplusplus

#endif

#endif  // __CRTFREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\cwndproc.cpp ===
#include "cwndproc.h"

#define ID_NOTIFY_SUBCLASS (DWORD)'CHN'     // CHN change notify
//
// CImpWndProc
//
LRESULT CALLBACK CImpWndProc::s_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (WM_NCCREATE == uMsg)
    {
        CImpWndProc* pThis = (CImpWndProc*)(((LPCREATESTRUCT)lParam)->lpCreateParams);
        if (EVAL(pThis))
        {
            pThis->_hwnd = hwnd;
            SetWindowPtr(hwnd, 0, pThis);

            // Even if pThis->vWndProc fails the create, USER will always
            // send us a WM_NCDESTROY so we always get a chance to clean up
            return pThis->v_WndProc(hwnd, uMsg, wParam, lParam);
        }
        return FALSE;
    }
    else
    {
        CImpWndProc* pThis = (CImpWndProc*)GetWindowPtr0(hwnd);    // GetWindowLong(hwnd, 0);
        LRESULT lres;

        if (pThis)
        {
            // Always retain a ref across the v_WndProc in case
            // the window destroys itself during the callback.
            pThis->AddRef();

            lres = pThis->v_WndProc(hwnd, uMsg, wParam, lParam);

            if (uMsg == WM_NCDESTROY)
            {
                SetWindowPtr(hwnd, 0, NULL);
                pThis->_hwnd = NULL;
            }
            pThis->Release();
        }
        else
        {
            //
            // The only way this should happen is if we haven't actually
            // gotten a WM_NCCREATE yet.  User sends a WM_GETMINMAXINFO
            // to some windows before WM_NCCREATE (for legacy compat).
            // Assert that we're hitting that case.
            //
            ASSERT(uMsg == WM_GETMINMAXINFO);

            lres = SHDefWindowProc(hwnd, uMsg, wParam, lParam);
        }

        return lres;
    }
}

#ifndef NO_NOTIFYSUBCLASSWNDPROC

//
// CNotifySubclassWndProc
//
UINT g_idFSNotify;        // the message SHChangeNotify sends

BOOL CNotifySubclassWndProc::_SubclassWindow(HWND hwnd)
{
    if (0 == g_idFSNotify)
    {
        g_idFSNotify = RegisterWindowMessage(TEXT("SubclassedFSNotify"));
    }

    DEBUG_CODE( _hwndSubclassed = hwnd; );

    return SetWindowSubclass(hwnd, _SubclassWndProc, ID_NOTIFY_SUBCLASS, (DWORD_PTR)this);
}

void CNotifySubclassWndProc::_UnsubclassWindow(HWND hwnd)
{
    RemoveWindowSubclass(hwnd, _SubclassWndProc, ID_NOTIFY_SUBCLASS);
}

LRESULT CNotifySubclassWndProc::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    return DefSubclassProc(hwnd, uMessage, wParam, lParam);
}

LRESULT CALLBACK CNotifySubclassWndProc::_SubclassWndProc(
                                  HWND hwnd, UINT uMessage, 
                                  WPARAM wParam, LPARAM lParam,
                                  UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    CNotifySubclassWndProc* pObj = (CNotifySubclassWndProc*)dwRefData;

    if (pObj)
    {
        if (uMessage == g_idFSNotify)
        {
            LPSHChangeNotificationLock pshcnl;
            LPITEMIDLIST *ppidl;
            LONG lEvent;

            if (g_fNewNotify && (wParam || lParam))
            {
                // New style of notifications need to lock and unlock in order to free the memory...
                pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD) lParam, &ppidl, &lEvent);
                if (pshcnl)
                {
                    pObj->OnChange(lEvent, ppidl[0], ppidl[1]);
                }
            }
            else
            {
                lEvent = (DWORD) lParam; // process id's are 32bits even in WIN64
                ppidl = (LPITEMIDLIST*)wParam;
                pshcnl = NULL;
                if (ppidl)
                {
                    pObj->OnChange(lEvent, ppidl[0], ppidl[1]);
                }
            }

            if (pshcnl)
            {
                SHChangeNotification_Unlock(pshcnl);
            }

            return 0;
        }
        else
        {
            return pObj->_DefWindowProc(hwnd, uMessage, wParam, lParam);
        }
    }
    else
    {
        return DefSubclassProc(hwnd, uMessage, wParam, lParam);
    }
}

void CNotifySubclassWndProc::_FlushNotifyMessages(HWND hwnd)
{
    MSG msg;

    ASSERT(hwnd == _hwndSubclassed);

    // This SHChangeNotify calls flushes notifications
    // via PostMessage, so I need to remove them
    // myself and process them immediately...
    //
    SHChangeNotify(0, SHCNF_FLUSH, NULL, NULL);

    while (PeekMessage(&msg, hwnd, g_idFSNotify, g_idFSNotify, PM_REMOVE))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

void CNotifySubclassWndProc::_RegisterWindow(HWND hwnd, LPCITEMIDLIST pidl, long lEvents,
                                             UINT uFlags/* = SHCNRF_ShellLevel | SHCNRF_InterruptLevel*/)
{
    ASSERT(0 != g_idFSNotify);

    // We only register if there's something to listen to
    //
    if (0==_uRegister)
    {
        // Since we don't know what this pidl actually points to,
        // we have to register to listen to everything that might affect it...
        //
        _uRegister = RegisterNotify(hwnd, g_idFSNotify, pidl, lEvents, uFlags, TRUE);

        ASSERT(hwnd == _hwndSubclassed);
    }
}

void CNotifySubclassWndProc::_UnregisterWindow(HWND hwnd)
{
    if (_uRegister)
    {
        ASSERT(hwnd == _hwndSubclassed);

        // Avoid getting reentered...
        UINT uRegister = _uRegister;
        _uRegister = 0;
        SHChangeNotifyDeregister(uRegister);
    }
}

#endif  // NO_NOTIFYSUBCLASSWNDPROC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dbutil.cpp ===
//***   dbutil.cpp -- debug helpers
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/dbutil.cpp"

#ifdef DEBUG // {

#if ( _X86_)

// warning: these macros assume we have an ebp-linked chain.  for debug we do.
#define BP_GETOLDBP(pbp)    (*((int *)(pbp) + 0))
#define BP_GETRET(pbp)      (*((int *)(pbp) + 1))

//***   DBGetStackBack -- walk stack frame
// #if 0 w/ sanity checks #endif
// ENTRY/EXIT
//  pfp         INOUT ptr to frame ptr (IN:starting, OUT:ending)
//  pstkback    OUT:fp/ret pairs, IN:optional size/addr pairs for sanity check
//  nstkback    ARRAYSIZE(pstckback)
//  #if 0
//  ncheck      # of IN pstkback size/addr sanity-check pairs
//  #endif
//  n           (return) # of frames successfully walked
// DESCRIPTION
//  fills in OUT pstckback w/ backtrace info for nstckback frames.
//  #if 0
//  if ncheck > 0, makes sure that initial backtrace entries are in the
//  range of the function specified by the IN size/addr pairs in pstkback.
//  #endif
// NOTES
//  not sure if we return the right pfp' value (untested)
int DBGetStackBack(int *pfp, struct DBstkback *pstkback, int nstkback /*,int nchk*/)
{
    int fp = *pfp;
    int ret;
    int i = 0;

    __try {
        for (; i < nstkback; i++, pstkback++) {
            ret = BP_GETRET(fp);
#if 0
            if (i < ncheck && pstkback->ret != 0) {
                ASSERT(pstkback->fp == 0 || pstkback->fp == -1 || pstkback->fp <= 512);
                if (!(pstkback->ret <= ret && ret <= pstkback->ret + pstkback->fp)) {
                    // constraint violated
                    break;
                }
            }
#endif
            fp = BP_GETOLDBP(fp);
            pstkback->ret = ret;
            pstkback->fp = fp;
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        TraceMsg(TF_ALWAYS, "atm: GPF");
        // just use last 'ret' we had
    }

    *pfp = fp;
    return i;
}

#endif
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dbutil.h ===
#ifndef _DBUTIL_H_
//***   dbutil.h -- debug helper routines
//

// dbutil.cpp
struct DBstkback {
    int fp;     // frame ptr
    int ret;    // return addr
};

int DBGetStackBack(int *pfp, struct DBstkback *pstkback, int nstkback);

// dump.c
// ...

#define _DBUTIL_H_
#endif // _DBUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dldecl.h ===
#ifndef _DLDECL_H_
#define _DLDECL_H_

// Delay load declarations

// The following are defined to get the DECLSPEC_IMPORT stuff right.
// Since we have identically-named local functions that thunk to the
// real function, we need to correct the dll linkage.

#ifdef DL_OLEAUT32
#define _OLEAUT32_
#endif

#ifdef DL_OLE32
#define _OLE32_
#endif

#endif // _DLDECL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\debug.h ===
//====== Assertion/Debug output APIs =================================

#include <platform.h> // for __endexcept

#pragma warning (disable:4096)      // '__cdecl' must be used with '...'
#pragma warning (disable:4201)      // nonstandard extension used : nameless struct/union
#pragma warning (disable:4115)      // named type definition in parentheses

#if defined(DECLARE_DEBUG) && defined(DEBUG)

//
// Declare module-specific debug strings
//
//   When including this header in your private header file, do not
//   define DECLARE_DEBUG.  But do define DECLARE_DEBUG in one of the
//   source files in your project, and then include this header file.
//
//   You may also define the following:
//
//      SZ_DEBUGINI     - the .ini file used to set debug flags
//      SZ_DEBUGSECTION - the section in the .ini file specific to
//                        the module component.
//      SZ_MODULE       - ansi version of the name of your module.
//
//

// (These are deliberately CHAR)
EXTERN_C const CHAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;

EXTERN_C const WCHAR c_wszTrace[] = L"t " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszErrorDbg[] = L"err " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszWarningDbg[] = L"wn " TEXTW(SZ_MODULE) L"  ";
EXTERN_C const WCHAR c_wszAssertMsg[] = TEXTW(SZ_MODULE) L"  Assert: ";
EXTERN_C const WCHAR c_wszAssertFailed[] = TEXTW(SZ_MODULE) L"  Assert %ls, line %d: (%ls)\r\n";
EXTERN_C const WCHAR c_wszRip[] = TEXTW(SZ_MODULE) L"  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const WCHAR c_wszRipNoFn[] = TEXTW(SZ_MODULE) L"  RIP at %s, line %d: (%s)\r\n";

// (These are deliberately CHAR)
EXTERN_C const CHAR  c_szTrace[] = "t " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szErrorDbg[] = "err " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szWarningDbg[] = "wn " SZ_MODULE "  ";
EXTERN_C const CHAR  c_szAssertMsg[] = SZ_MODULE "  Assert: ";
EXTERN_C const CHAR  c_szAssertFailed[] = SZ_MODULE "  Assert %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRip[] = SZ_MODULE "  RIP in %s at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRipNoFn[] = SZ_MODULE "  RIP at %s, line %d: (%s)\r\n";
EXTERN_C const CHAR  c_szRipMsg[] = SZ_MODULE "  RIP: ";

#endif  // DECLARE_DEBUG && DEBUG

#if defined(DECLARE_DEBUG) && defined(PRODUCT_PROF)
EXTERN_C const CHAR c_szCcshellIniFile[] = SZ_DEBUGINI;
EXTERN_C const CHAR c_szCcshellIniSecDebug[] = SZ_DEBUGSECTION;
#endif



#ifdef __cplusplus
extern "C" {
#endif

#if !defined(DECLARE_DEBUG)

//
// Debug macros and validation code
//

#if !defined(UNIX) || (defined(UNIX) && !defined(NOSHELLDEBUG))

// Undefine the macros that we define in case some other header
// might have tried defining these commonly-named macros.
#undef Assert
#undef AssertE
#undef AssertMsg
#undef AssertStrLen
#undef DebugMsg
#undef FullDebugMsg
#undef ASSERT
#undef EVAL
#undef ASSERTMSG            // catch people's typos
#undef DBEXEC

#ifdef _ATL_NO_DEBUG_CRT
#undef _ASSERTE             // we substitute this ATL macro
#endif

#endif // !UNIX


// Access these globals to determine which debug flags are set.
// These globals are modified by CcshellGetDebugFlags(), which
// reads an .ini file and sets the appropriate flags.
//
//   g_dwDumpFlags  - bits are application specific.  Typically 
//                    used for dumping structures.
//   g_dwBreakFlags - uses BF_* flags.  The remaining bits are
//                    application specific.  Used to determine
//                    when to break into the debugger.
//   g_qwTraceFlags - uses TF_* flags.  The remaining bits are
//                    application specific.  Used to display
//                    debug trace messages.
//   g_dwFuncTraceFlags - bits are application specific.  When
//                    TF_FUNC is set, CcshellFuncMsg uses this
//                    value to determine which function traces
//                    to display.
//   g_dwProtoype   - bits are application specific.  Use it for
//                    anything.
//   g_dwProfileCAP - bits are application specific. Used to
//                    control ICECAP profiling. 
//

extern DWORD g_dwDumpFlags;
extern DWORD g_dwBreakFlags;
extern ULONGLONG g_qwTraceFlags;
#ifdef DEBUG
extern DWORD g_dwPrototype;
#else
#define g_dwPrototype   0
#endif
extern DWORD g_dwFuncTraceFlags;

#if defined(DEBUG) || defined(PRODUCT_PROF)
BOOL CcshellGetDebugFlags(void);
#else
#define CcshellGetDebugFlags()  0
#endif

// Break flags for g_dwBreakFlags
#define BF_ASSERT           0x00000001      // Break on assertions
#define BF_ONAPIENTER       0x00000002      // Break on entering an API
#define BF_ONERRORMSG       0x00000004      // Break on TF_ERROR
#define BF_ONWARNMSG        0x00000008      // Break on TF_WARNING
#define BF_THR              0x00000100      // Break when THR() receives a failure
#define BF_RIP              0x00000200      // Break on RIPs
#define BF_LEAKS            0x80000000      // Break on detecting a leak

// Trace flags for g_qwTraceFlags
#define TF_ALWAYS           0xFFFFFFFFFFFFFFFF
#define TF_NEVER            0x00000000
#define TF_WARNING          0x00000001
#define TF_ERROR            0x00000002
#define TF_GENERAL          0x00000004      // Standard messages
#define TF_FUNC             0x00000008      // Trace function calls
#define TF_ATL              0x00000008      // Since TF_FUNC is so-little used, I'm overloading this bit
#define TF_MEMUSAGE                       0x0000000100000000      
#define TF_KEEP_ALLOCATION_STACKS         0x0000000200000000      
// (Upper 28 bits reserved for custom use per-module)

#define TF_CUSTOM1          0x40000000      // Custom messages #1
#define TF_CUSTOM2          0x80000000      // Custom messages #2

// Old, archaic debug flags.  
// APPCOMPAT (scotth): the following flags will be phased out over time.
#ifdef DM_TRACE
#undef DM_TRACE
#undef DM_WARNING
#undef DM_ERROR
#endif
#define DM_TRACE            TF_GENERAL      // OBSOLETE Trace messages
#define DM_WARNING          TF_WARNING      // OBSOLETE Warning
#define DM_ERROR            TF_ERROR        // OBSOLETE Error


// Use this macro to declare message text that will be placed
// in the CODE segment (useful if DS is getting full)
//
// Ex: DEBUGTEXT(szMsg, "Invalid whatever: %d");
//
#define DEBUGTEXT(sz, msg)      /* ;Internal */ \
    static const TCHAR sz[] = msg


#ifndef NOSHELLDEBUG    // Others have own versions of these.

#ifdef DEBUG

void    AttachUserModeDebugger (void);

#ifdef _X86_
// Use int 3 so we stop immediately in the source
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        AttachUserModeDebugger();                       \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                _asm int 3                              \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
        } while (gAlwaysAssert);                        \
    }
#else
#define DEBUG_BREAK                                     \
    {                                                   \
        static BOOL gAlwaysAssert = FALSE;              \
        AttachUserModeDebugger();                       \
        do                                              \
        {                                               \
            _try                                        \
            {                                           \
                DebugBreak();                           \
            }                                           \
            _except (EXCEPTION_EXECUTE_HANDLER)         \
            {                                           \
            }                                           \
            __endexcept                                 \
        } while (gAlwaysAssert);                        \
    }
#endif

// Prototypes for debug functions

void CcshellStackEnter(void);
void CcshellStackLeave(void);

void CDECL CcshellFuncMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellFuncMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _AssertMsgA(BOOL f, LPCSTR pszMsg, ...);
void CDECL _AssertMsgW(BOOL f, LPCWSTR pszMsg, ...);


void _AssertStrLenA(LPCSTR pszStr, int iLen);
void _AssertStrLenW(LPCWSTR pwzStr, int iLen);

#ifdef UNICODE
#define CcshellFuncMsg          CcshellFuncMsgW
#define CcshellAssertMsg        CcshellAssertMsgW
#define _AssertMsg              _AssertMsgW
#define _AssertStrLen           _AssertStrLenW
#else
#define CcshellFuncMsg          CcshellFuncMsgA
#define CcshellAssertMsg        CcshellAssertMsgA
#define _AssertMsg              _AssertMsgA
#define _AssertStrLen           _AssertStrLenA
#endif

#endif // DEBUG



// ASSERT(f)
//
//   Generates a "Assert file.c, line x (eval)" message if f is NOT true.
//
//   Use ASSERT() to check for logic invariance.  These are typically considered
//   fatal problems, and falls into the 'this should never ever happen' 
//   category.
//
//   Do *not* use ASSERT() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

BOOL CcshellAssertFailedA(LPCSTR szFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellAssertFailedW(LPCWSTR szFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
#ifdef UNICODE
#define CcshellAssertFailed     CcshellAssertFailedW
#else
#define CcshellAssertFailed     CcshellAssertFailedA
#endif

#define ASSERT(f)                                 \
    {                                             \
        DEBUGTEXT(szFile, TEXT(__FILE__));              \
        if (!(f) && CcshellAssertFailed(szFile, __LINE__, TEXT(#f), FALSE)) \
            DEBUG_BREAK;       \
    }

// The old Win95 code used to use "Assert()".  We discourage the use
// of this macro now because it is not msdev-friendly.
#ifdef DISALLOW_Assert
#define Assert(f)        Dont_use_Assert___Use_ASSERT
#else
#define Assert(f)           ASSERT(f)
#endif

#else  // DEBUG

#define ASSERT(f)
#define Assert(f)

#endif // DEBUG



// ASSERTMSG(f, szFmt, args...)
//
//   Behaves like ASSERT, except it prints the wsprintf-formatted message
//   instead of the file and line number.
//
//   The sz parameter is always ANSI; AssertMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

void CDECL CcshellAssertMsgW(BOOL bAssert, LPCSTR pszMsg, ...);
void CDECL CcshellAssertMsgA(BOOL bAssert, LPCSTR pszMsg, ...);
#ifdef UNICODE
#define CcshellAssertMsg        CcshellAssertMsgW
#else
#define CcshellAssertMsg        CcshellAssertMsgA
#endif

#define ASSERTMSG           CcshellAssertMsg

#else  // DEBUG

#define ASSERTMSG       1 ? (void)0 : (void)

#endif // DEBUG



// EVAL(f)
//
//   Behaves like ASSERT().  Evaluates the expression (f).  The expression 
//   is always evaluated, even in retail builds.  But the macro only asserts 
//   in the debug build.  This macro may be used on logical expressions, eg:
//
//          if (EVAL(exp))
//              // do something
//
//   Do *not* use EVAL() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   The BF_ASSERT bit in g_dwBreakFlags governs whether the function 
//   performs a DebugBreak().
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew and break
//      Full debug builds:  spew and break
//
#ifdef DEBUG

#define EVAL(exp)   \
    ((exp) || (CcshellAssertFailed(TEXT(__FILE__), __LINE__, TEXT(#exp), TRUE), 0))

#else  // DEBUG

#define EVAL(exp)       ((exp) != 0)

#endif // DEBUG



// RIP(f)
// 
//   Generates a "RIP at file.c, line x (eval)" message if f is NOT true.
//   
//   Use RIP() to perform parameter validation, especially when you
//   know the function or method may be called by a 3rd party app.
//   Typically, RIPs are used to indicate the caller passed in an invalid 
//   parameter, so the problem is really not in the code itself.
//
//   Do *not* use RIP() to verify successful API calls if the APIs can 
//   legitimately fail due to low resources.  For example, LocalAlloc can 
//   legally fail, so you shouldn't assert that it will never fail.
//
//   RIP performs a debugbreak only in the following processes:
//
//      explore.exe
//      iexplore.exe
//      rundll32.exe
//
//   In any other process, this just spews the debug message, but doesn't stop.
//   
//   Setting the BF_RIP bit in g_dwBreakFlags will cause the macro to perform 
//   a DebugBreak() even in non-shell processes.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       spew (other processes), spew and break (shell processes)
//      Full debug builds:  spew (other processes), spew and break (shell processes)
//
#ifdef DEBUG

BOOL CcshellRipA(LPCSTR pszFile, int line, LPCSTR pszEval, BOOL bBreakInside);
BOOL CcshellRipW(LPCWSTR pszFile, int line, LPCWSTR pwszEval, BOOL bBreakInside);
BOOL CDECL CcshellRipMsgA(BOOL bRip, LPCSTR pszMsg, ...);
BOOL CDECL CcshellRipMsgW(BOOL bRip, LPCSTR pszMsg, ...);


#ifdef UNICODE
#define CcshellRip      CcshellRipW
#define CcshellRipMsg   CcshellRipMsgW
#else
#define CcshellRip      CcshellRipA
#define CcshellRipMsg   CcshellRipMsgA
#endif

#define RIP(f)                                                                                              \
    {                                                                                                       \
        DEBUGTEXT(szFile, TEXT(__FILE__));                                                                  \
        if (!(f) && CcshellRip(szFile, __LINE__, TEXT(#f), FALSE))                                          \
        {                                                                                                   \
            DEBUG_BREAK;                                                                                    \
        }                                                                                                   \
    }                                                                                                       \

#define RIPMSG          CcshellRipMsg

#else  // DEBUG

#define RIP(f)
#define RIPMSG          1 ? (void)0 : (void)

#endif // DEBUG



// TraceMsg(dwMask, sz, args...) 
//
//   Generate wsprintf-formatted message using the specified trace dwMask.
//   dwMask may be one of the predefined bits:
//
//      TF_ERROR    - display "err <MODULE>  <string>"
//      TF_WARNING  - display "wn  <MODULE>  <string>"
//      TF_GENERAL  - display "t   <MODULE>  <string>"
//      TF_ALWAYS   - display "t   <MODULE>  <string>" regardless of g_qwTraceFlags.
//
//   or it may be a custom bit (any of the upper 28 bits).
//
//   The g_qwTraceFlags global governs whether the message is displayed (based
//   upon the dwMask parameter).
//
//   The sz parameter is always ANSI; TraceMsg correctly converts it
//   to unicode if necessary.  This is so you don't have to wrap your
//   debug strings with TEXT().
//
//   In addition to squirting the trace message, you may optionally cause
//   the trace message to stop if you need to trace down the source of
//   an error.  The BF_ONERRORMSG and BF_ONWARNMSG bits may be set in
//   g_dwBreakFlags to make TraceMsg stop when a TF_ERROR or TF_WARNING
//   message is displayed.  But typically these bits are disabled.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       only TF_ALWAYS and TF_ERROR messages spew
//      Full debug builds:  spew
//
#ifdef DEBUG

UINT GetStack(UINT nDepth, CHAR *szBuffer, UINT nBufferLength);
void CDECL CcshellDebugMsgW(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL CcshellDebugMsgA(ULONGLONG mask, LPCSTR pszMsg, ...);
void CDECL _DebugMsgA(ULONGLONG flag, LPCSTR psz, ...);
void CDECL _DebugMsgW(ULONGLONG flag, LPCWSTR psz, ...);
#ifdef UNICODE
#define CcshellDebugMsg         CcshellDebugMsgW
#define _DebugMsg               _DebugMsgW
#else
#define CcshellDebugMsg         CcshellDebugMsgA
#define _DebugMsg               _DebugMsgA
#endif

#define TraceMsgW           CcshellDebugMsgW
#define TraceMsgA           CcshellDebugMsgA
#define TraceMsg            CcshellDebugMsg

// Use TraceMsg instead of DebugMsg.  DebugMsg is obsolete.
#ifdef DISALLOW_DebugMsg
#define DebugMsg            Dont_use_DebugMsg___Use_TraceMsg
#else
#define DebugMsg            _DebugMsg

#endif

#else  // DEBUG

#define TraceMsgA       1 ? (void)0 : (void)
#define TraceMsgW       1 ? (void)0 : (void)
#define TraceMsg        1 ? (void)0 : (void)
#define DebugMsg        1 ? (void)0 : (void)

#endif // DEBUG



// THR(pfn)
// TBOOL(pfn)
// TINT(pfn)
// TPTR(pfn)
// TW32(pfn)
// 
//   These macros are useful to trace failed calls to functions that return
//   HRESULTs, BOOLs, ints, or pointers.  An example use of this is:
//
//   {
//       ...
//       hres = THR(CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, 
//                                   IID_IBar, (LPVOID*)&pbar));
//       if (SUCCEEDED(hres))
//       ...
//   }
//
//   If CoCreateInstance failed, you would see spew similar to:
//
//    err MODULE  THR: Failure of "CoCreateInstance(CLSID_Bar, NULL, CLSCTX_INPROC_SERVER, IID_IBar, (LPVOID*)&pbar)" at foo.cpp, line 100  (0x80004005)
//
//   THR keys off of the failure code of the hresult.
//   TBOOL considers FALSE to be a failure case.
//   TINT considers -1 to be a failure case.
//   TPTR considers NULL to be a failure case.
//   TW32 keys off the failure code of the Win32 error code.
//
//   Set the BF_THR bit in g_dwBreakFlags to stop when these macros see a failure.
//
//   Default Behavior-
//      Retail builds:      nothing
//      Debug builds:       nothing
//      Full debug builds:  spew on error
//
#ifdef DEBUG

EXTERN_C HRESULT TraceHR(HRESULT hrTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C BOOL    TraceBool(BOOL bTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C int     TraceInt(int iTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C LPVOID  TracePtr(LPVOID pvTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);
EXTERN_C DWORD   TraceWin32(DWORD dwTest, LPCSTR pszExpr, LPCSTR pszFile, int iLine);

#define THR(x)      (TraceHR((x), #x, __FILE__, __LINE__))
#define TBOOL(x)    (TraceBool((x), #x, __FILE__, __LINE__))
#define TINT(x)     (TraceInt((x), #x, __FILE__, __LINE__))
#define TPTR(x)     (TracePtr((x), #x, __FILE__, __LINE__))
#define TW32(x)     (TraceWin32((x), #x, __FILE__, __LINE__))

#else  // DEBUG

#define THR(x)          (x)
#define TBOOL(x)        (x)
#define TINT(x)         (x)
#define TPTR(x)         (x)
#define TW32(x)         (x)

#endif // DEBUG



// DBEXEC(flg, expr)
//
//   under DEBUG, does "if (flg) expr;" (w/ the usual safe syntax)
//   under !DEBUG, does nothing (and does not evaluate either of its args)
//
#ifdef DEBUG

#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)

#else  // DEBUG

#define DBEXEC(flg, expr)   /*NOTHING*/

#endif // DEBUG


// string and buffer whacking functions
//
#ifdef DEBUG

EXTERN_C void DEBUGWhackPathBufferA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathBufferW(LPWSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringA(LPSTR psz, UINT cch);
EXTERN_C void DEBUGWhackPathStringW(LPWSTR psz, UINT cch);

#else // DEBUG

#define DEBUGWhackPathBufferA(psz, cch)
#define DEBUGWhackPathBufferW(psz, cch)
#define DEBUGWhackPathStringA(psz, cch)
#define DEBUGWhackPathStringW(psz, cch)

#endif // DEBUG

#ifdef UNICODE
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferW
#define DEBUGWhackPathString DEBUGWhackPathStringW
#else
#define DEBUGWhackPathBuffer DEBUGWhackPathBufferA
#define DEBUGWhackPathString DEBUGWhackPathStringA
#endif


// Some trickery to map ATL debug macros to ours, so ATL code that stops
// or spews in our code will look like the rest of our squirties.

#ifdef DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)         ASSERT(f)

// We map ATLTRACE macros to our functions
void _cdecl ShellAtlTraceA(LPCSTR lpszFormat, ...);
void _cdecl ShellAtlTraceW(LPCWSTR lpszFormat, ...);
#ifdef UNICODE
#define ShellAtlTrace   ShellAtlTraceW
#else
#define ShellAtlTrace   ShellAtlTraceA
#endif
// These are turned off because they normally don't give
// feedback of error cases and so many fire that they
// swamp out other useful debug spew.
//#define ATLTRACE            ShellAtlTrace
#endif

#else  // DEBUG

#ifdef _ATL_NO_DEBUG_CRT
// ATL uses _ASSERTE.  Map it to ours.
#define _ASSERTE(f)

// We map ATLTRACE macros to our functions
#define ATLTRACE            1 ? (void)0 : (void)
#define ATLTRACE2           1 ? (void)0 : (void)
#endif

#endif // DEBUG


// ------ Stay away from these macros below ----------
// APPCOMPAT (scotth):  remove these by 8/15/98.  They should not be used anymore. 
#ifdef DEBUG

#define AssertE(f)          ASSERT(f)
#define AssertMsg           _AssertMsg
#define AssertStrLen        _AssertStrLen
#define AssertStrLenA       _AssertStrLenA
#define AssertStrLenW       _AssertStrLenW

#ifdef FULL_DEBUG
#define FullDebugMsg        _DebugMsg
#else
#define FullDebugMsg        1 ? (void)0 : (void)
#endif

#define ASSERT_MSGW         CcshellAssertMsgW
#define ASSERT_MSGA         CcshellAssertMsgA
#define ASSERT_MSG          CcshellAssertMsg
#else  // DEBUG

#define AssertE(f)      (f)
#define AssertMsg       1 ? (void)0 : (void)
#define AssertStrLen(lpStr, iLen)
#define FullDebugMsg    1 ? (void)0 : (void)
#define ASSERT_MSGA     1 ? (void)0 : (void)
#define ASSERT_MSGW     1 ? (void)0 : (void)
#define ASSERT_MSG      1 ? (void)0 : (void)

#endif // DEBUG
// ------ Stay away from these macros above ----------



// It's necessary to find when classes that were designed to be single threaded are used
// across threads so they can be fixed to be multithreaded.  These asserts will point
// out such cases.
#ifdef DEBUG
#define ASSERT_SINGLE_THREADED              AssertMsg(_dwThreadIDForSingleThreadedAssert == GetCurrentThreadId(), TEXT("MULTI-THREADED BUG: This class is being used by more than one thread, but it's not thread safe."))
#define INIT_SINGLE_THREADED_ASSERT         _dwThreadIDForSingleThreadedAssert = GetCurrentThreadId();
#define SINGLE_THREADED_MEMBER_VARIABLE     DWORD _dwThreadIDForSingleThreadedAssert;
#else // DEBUG
#define ASSERT_SINGLE_THREADED              NULL;
#define INIT_SINGLE_THREADED_ASSERT         NULL;
#define SINGLE_THREADED_MEMBER_VARIABLE     
#endif // DEBUG



#ifdef DEBUG

#define Dbg_SafeStrA(psz)   (SAFECAST(psz, LPCSTR), (psz) ? (psz) : "NULL string")
#define Dbg_SafeStrW(psz)   (SAFECAST(psz, LPCWSTR), (psz) ? (psz) : L"NULL string")
#ifdef UNICODE
#define Dbg_SafeStr         Dbg_SafeStrW
#else
#define Dbg_SafeStr         Dbg_SafeStrA
#endif

#define FUNC_MSG            CcshellFuncMsg


// Helpful macro for mapping manifest constants to strings.  Assumes
// return string is pcsz.  You can use this macro in this fashion:
//
// LPCSTR Dbg_GetFoo(FOO foo)
// {
//    LPCTSTR pcsz = TEXT("Unknown <foo>");
//    switch (foo)
//    {
//    STRING_CASE(FOOVALUE1);
//    STRING_CASE(FOOVALUE2);
//    ...
//    }
//    return pcsz;
// }
//
#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


// Debug function enter


// DBG_ENTER(flag, fn)  -- Generates a function entry debug spew for
//                          a function
//
#define DBG_ENTER(flagFTF, fn)                  \
        (FUNC_MSG(flagFTF, " > " #fn "()"), \
         CcshellStackEnter())

// DBG_ENTER_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function entry debug
//                          spew for functions that accept <type>.
//
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (FUNC_MSG(flagFTF, " < " #fn "(..., %s, ...)", (LPCTSTR)pfnStrFromType(dw)), \
         CcshellStackEnter())

// DBG_ENTER_SZ(flag, fn, sz)  -- Generates a function entry debug spew for
//                          a function that accepts a string as one of its
//                          parameters.
//
#define DBG_ENTER_SZ(flagFTF, fn, sz)                  \
        (FUNC_MSG(flagFTF, " > " #fn "(..., \"%s\",...)", Dbg_SafeStr(sz)), \
         CcshellStackEnter())


// Debug function exit


// DBG_EXIT(flag, fn)  -- Generates a function exit debug spew
//
#define DBG_EXIT(flagFTF, fn)                              \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "()"))

// DBG_EXIT_TYPE(flag, fn, dw, pfnStrFromType)  -- Generates a function exit debug
//                          spew for functions that return <type>.
//
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfnStrFromType)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (LPCTSTR)pfnStrFromType(dw)))

// DBG_EXIT_INT(flag, fn, us)  -- Generates a function exit debug spew for
//                          functions that return an INT.
//
#define DBG_EXIT_INT(flagFTF, fn, n)                       \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %d", (int)(n)))

// DBG_EXIT_BOOL(flag, fn, b)  -- Generates a function exit debug spew for
//                          functions that return a boolean.
//
#define DBG_EXIT_BOOL(flagFTF, fn, b)                      \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %s", (b) ? (LPTSTR)TEXT("TRUE") : (LPTSTR)TEXT("FALSE")))

// DBG_EXIT_UL(flag, fn, ul)  -- Generates a function exit debug spew for
//                          functions that return a ULONG.
//
#ifdef _WIN64
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#016I64x", (ULONG_PTR)(ul)))
#else
#define DBG_EXIT_UL(flagFTF, fn, ul)                   \
        (CcshellStackLeave(), \
         FUNC_MSG(flagFTF, " < " #fn "() with %#08lx", (ULONG)(ul)))
#endif // _WIN64

#define DBG_EXIT_DWORD      DBG_EXIT_UL

// DBG_EXIT_HRES(flag, fn, hres)  -- Generates a function exit debug spew for
//                          functions that return an HRESULT.
//
#define DBG_EXIT_HRES(flagFTF, fn, hres)     DBG_EXIT_TYPE(flagFTF, fn, hres, Dbg_GetHRESULTName)



#else   // DEBUG


#define Dbg_SafeStr     1 ? (void)0 : (void)

#define FUNC_MSG        1 ? (void)0 : (void)


#define DBG_ENTER(flagFTF, fn)
#define DBG_ENTER_TYPE(flagFTF, fn, dw, pfn)
#define DBG_ENTER_SZ(flagFTF, fn, sz)
#define DBG_EXIT(flagFTF, fn)
#define DBG_EXIT_INT(flagFTF, fn, n)
#define DBG_EXIT_BOOL(flagFTF, fn, b)
#define DBG_EXIT_UL(flagFTF, fn, ul)
#define DBG_EXIT_DWORD      DBG_EXIT_UL
#define DBG_EXIT_TYPE(flagFTF, fn, dw, pfn)
#define DBG_EXIT_HRES(flagFTF, fn, hres)

#endif  // DEBUG



// COMPILETIME_ASSERT(f)
//
//  Generates a build break at compile time if the constant expression
//  is not true.  Unlike the "#if" compile-time directive, the expression
//  in COMPILETIME_ASSERT() is allowed to use "sizeof".
//
//  Compiler magic!  If the expression "f" is FALSE, then you get the
//  compiler error "Duplicate case expression in switch statement".
//
#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:


#else  // NOSHELLDEBUG

#ifdef UNIX
#include <crtdbg.h>
#define ASSERT(f)	_ASSERT(f)
#include <mainwin.h>
#define TraceMsg(type, sformat)  DebugMessage(0, sformat)
#define TraceMSG(type, sformat, args)  DebugMessage(0, sformat, args)
#endif

#endif  // NOSHELLDEBUG


// 
// Debug dump helper functions
//

#ifdef DEBUG

LPCTSTR Dbg_GetCFName(UINT ucf);
LPCTSTR Dbg_GetHRESULTName(HRESULT hr);
LPCTSTR Dbg_GetREFIIDName(REFIID riid);
LPCTSTR Dbg_GetVTName(VARTYPE vt);

#else

#define Dbg_GetCFName(ucf)          (void)0
#define Dbg_GetHRESULTName(hr)      (void)0
#define Dbg_GetREFIIDName(riid)     (void)0
#define Dbg_GetVTName(vt)           (void)0

#endif // DEBUG

// I'm a lazy typist...
#define Dbg_GetHRESULT              Dbg_GetHRESULTName

// Parameter validation macros
#include "validate.h"

#endif // DECLARE_DEBUG

#ifdef PRODUCT_PROF 
int __stdcall StartCAP(void);	// start profiling
int __stdcall StopCAP(void);    // stop profiling until StartCAP
int __stdcall SuspendCAP(void); // suspend profiling until ResumeCAP
int __stdcall ResumeCAP(void);  // resume profiling
int __stdcall StartCAPAll(void);    // process-wide start profiling
int __stdcall StopCAPAll(void);     // process-wide stop profiling
int __stdcall SuspendCAPAll(void);  // process-wide suspend profiling
int __stdcall ResumeCAPAll(void);   // process-wide resume profiling
void __stdcall MarkCAP(long lMark);  // write mark to MEA
extern DWORD g_dwProfileCAP;
#else
#define StartCAP()      0
#define StopCAP()       0
#define SuspendCAP()    0
#define ResumeCAP()     0
#define StartCAPAll()   0
#define StopCAPAll()    0
#define SuspendCAPAll() 0
#define ResumeCAPAll()  0
#define MarkCAP(n)      0

#define g_dwProfileCAP  0
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\desktop2.h ===
#ifndef _DESKTOP2_H
#define _DESKTOP2_H

#include "uxtheme.h"
#include "tmschema.h"

#define WC_USERPANE     TEXT("Desktop User Pane")
#define WC_LOGOFF       TEXT("DesktopLogoffPane")
#define WC_SFTBARHOST   TEXT("DesktopSFTBarHost")
#define WC_MOREPROGRAMS TEXT("Desktop More Programs Pane")

/*
 
   This is the new Start Panel layout model.  
   Each pane in the following diagram will contain a 9Grid and a control offset w/in 9grid.

   STARTPANELMETRICS structure should be able to be initialized from a static.
   in the non-theme case, that static is what we'll use, otherwise we'll over-ride it with theme settings

 *************************
 *                       *
 *    User               *
 *************************
 *           *           *
 *           *           *
 *   MFU     *    Places *
 *           *           *
 *           *           *
 *           *           *
 *************           *
 * MoreProg  *           *
 *************************
 *                       *
 *      Logoff           *
 *************************

*/

#define SMPANETYPE_USER     0
#define SMPANETYPE_MFU      1
#define SMPANETYPE_MOREPROG 2
#define SMPANETYPE_PLACES   3
#define SMPANETYPE_LOGOFF   4
#define SMPANE_MAX SMPANETYPE_LOGOFF+1

// Common data which every pane will specify
typedef struct {
    LPCTSTR pszClassName;           // (const) window class name
    DWORD   dwStyle;                // (const) window style
    int     iPartId;                // (const) theme part id
    SIZE    size;                   // (default) initial size of this pane
    HTHEME  hTheme;                 // (runtime) theme to pass to the control
    HWND    hwnd;                   // (runtime) filled in at runtime
} SMPANEDATA;

typedef struct {
    SIZE sizPanel;    // Initial size of panel
    SMPANEDATA  panes[SMPANE_MAX];
} STARTPANELMETRICS;



//
//  For communication between the New Start Menu and the controls it hosts.
//  Note that these are positive numbers (app-specific).
//
//  Some of these notifications go from child to parent; others from parent
//  to child.  They will be indicated (c2p) or (p2c) accordingly.

#define SMN_FIRST           200         // 200 - 299
#define SMN_INITIALUPDATE   (SMN_FIRST+0) // p2c - Start Menu is being built
#define SMN_APPLYREGION     (SMN_FIRST+1) // p2c - make the window regional again
#define SMN_HAVENEWITEMS    (SMN_FIRST+2) // c2p - new items are here
                                          //       lParam -> SMNMBOOL (fNewInstall)
#define SMN_MODIFYSMINFO    (SMN_FIRST+3) // p2c - allow flags to be set (psminfo->dwFlags)
#define SMN_COMMANDINVOKED  (SMN_FIRST+4) // c2p - user executed a command
#define SMN_FILTEROPTIONS   (SMN_FIRST+5) // c2p - turn off options not supported
#define SMN_GETMINSIZE      (SMN_FIRST+6) // p2c - allow client to specify minimum size
#define SMN_SEENNEWITEMS    (SMN_FIRST+7) // p2c - user has seen new items; don't need balloon tip
#define SMN_POSTPOPUP       (SMN_FIRST+8) // p2c - Start Menu is has just popped up
#define SMN_NEEDREPAINT     (SMN_FIRST+9) // c2p - There was a change in a list, we need to repaint 
                                          //         This used to keep the cached bitmap up to date

//
//  SMN_FINDITEM - find/select an item (used in dialog navigation)
//
//      SMNDIALOGMESSAGE.flags member describes what type of search
//      is requested.  If SMNDM_SELECT is set, then the found item is
//      also selected.
//
//      If a match was found, set SMNDIALOGMESSAGE.itemID to a
//      value that uniquely identifies the item within the control,
//      and return TRUE.
//
//      If no match was found, set pt = coordinates of current selection,
//      set one of the orientation flags SMNDM_VERTICAL/SMNDM_HORIZONTAL,
//      and return FALSE.
//
#define SMN_FINDITEM        (SMN_FIRST+7) // p2c - find/select an item
#define SMN_TRACKSHELLMENU  (SMN_FIRST+8) // c2p - display a popup menu
#define SMN_SHOWNEWAPPSTIP  (SMN_FIRST+9) // p2c - show the "More Programs" tip
                                          //       lParam -> SMNMBOOL (fShow)
#define SMN_DISMISS         (SMN_FIRST+10)// p2c - Start Menu is being dismissed
#define SMN_CANCELSHELLMENU (SMN_FIRST+11)// c2p - cancel the popup menu
#define SMN_BLOCKMENUMODE   (SMN_FIRST+12)// c2p - lParam -> SMNMBOOL (fBlock)

#define SMN_REFRESHLOGOFF   (SMN_FIRST+13)// p2c - indicates a WM_DEVICECHANGE or a session change
#define SMN_SHELLMENUDISMISSED (SMN_FIRST+14)// p2c - notification that the menu has dismissed

// Formerly used by SMN_LINKCOMMAND to specify which command we want
#define SMNLC_LOGOFF        0
#define SMNLC_TURNOFF       1
#define SMNLC_DISCONNECT    2
// REUSE ME                 3
#define SMNLC_EJECT         4
#define SMNLC_MAX           5

typedef struct SMNMMODIFYSMINFO {
    NMHDR hdr;
    struct tagSMDATA *psmd; // IN
    struct tagSMINFO *psminfo; // IN OUT
} SMNMMODIFYSMINFO, *PSMNMMODIFYSMINFO;

typedef struct SMNMBOOL {
    NMHDR hdr;
    BOOL  f;
} SMNMBOOL, *PSMNMBOOL;

typedef struct SMNMAPPLYREGION {
    NMHDR hdr;
    HRGN hrgn;
} SMNMAPPLYREGION, *PSMNMAPPLYREGION;

typedef struct SMNHAVENEWITEMS {
    NMHDR hdr;
    FILETIME ftNewestApp;
} SMNMHAVENEWITEMS, *PSMNMHAVENEWITEMS;

typedef struct SMNMCOMMANDINVOKED {
    NMHDR hdr;
    RECT rcItem;
} SMNMCOMMANDINVOKED, *PSMNMCOMMANDINVOKED;

//
//  Options for SMN_FILTEROPTIONS.
//
#define SMNOP_LOGOFF        (1 << SMNLC_LOGOFF)       // 0x01
#define SMNOP_TURNOFF       (1 << SMNLC_TURNOFF)      // 0x02
#define SMNOP_DISCONNECT    (1 << SMNLC_DISCONNECT)   // 0x04
// REUSE ME                 (1 << SMNLC_????????????) // 0x08
#define SMNOP_EJECT         (1 << SMNLC_EJECT)        // 0x10

typedef struct SMNFILTEROPTIONS {
    NMHDR hdr;
    UINT  smnop;                // IN OUT
} SMNFILTEROPTIONS, *PSMNFILTEROPTIONS;

typedef struct SMNGETMINSIZE {
    NMHDR hdr;
    SIZE  siz;                  // IN OUT
} SMNGETMINSIZE, *PSMNGETMINSIZE;

typedef struct SMNDIALOGMESSAGE {
    NMHDR hdr;
    MSG *pmsg;                  // IN
    LPARAM itemID;              // IN OUT
    POINT pt;                   // IN OUT
    UINT flags;                 // IN
} SMNDIALOGMESSAGE, *PSMNDIALOGMESSAGE;

// Values for "flags" in SMNDIALOGMESSAGE

#define SMNDM_FINDFIRSTMATCH    0x0000  // Find first matching item (char)
#define SMNDM_FINDNEXTMATCH     0x0001  // Find next matching item (char)
#define SMNDM_FINDNEAREST       0x0002  // Find item nearest point
#define SMNDM_FINDFIRST         0x0003  // Find the first item
#define SMNDM_FINDLAST          0x0004  // Find the last item
#define SMNDM_FINDNEXTARROW     0x0005  // Find next in direction of arrow
#define SMNDM_INVOKECURRENTITEM 0x0006  // Invoke the current item
#define SMNDM_HITTEST           0x0007  // Find item under point
#define SMNDM_OPENCASCADE       0x0008  // Invoke current item if it cascade
#define SMNDM_FINDITEMID        0x0009  // Find the specied item (itemID)
#define SMNDM_FINDMASK          0x000F  // What type of search?

#define SMNDM_SELECT            0x0100  // Select found item?
#define SMNDM_TRYCASCADE        0x0200  // Attempt to open cascading menu before navigatin
#define SMNDM_KEYBOARD          0x0400  // Initiated from keyboard

// Output flags
#define SMNDM_VERTICAL          0x4000  // Client is vertically-oriented
#define SMNDM_HORIZONTAL        0x8000  // Client is horizontally-oriented

typedef struct SMNTRACKSHELLMENU {
    NMHDR hdr;
    struct IShellMenu *psm;
    RECT rcExclude;
    LPARAM itemID;                  // Which item is being tracked?
    DWORD dwFlags;                  // MPPF_* values
} SMNTRACKSHELLMENU, *PSMNTRACKSHELLMENU;

#define REGSTR_PATH_STARTPANE \
        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartPage")

#define REGSTR_PATH_STARTPANE_SETTINGS \
        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")

#define REGSTR_VAL_DV2_SHOWMC      TEXT("Start_ShowMyComputer")
#define REGSTR_VAL_DV2_SHOWNETPL   TEXT("Start_ShowNetPlaces")
#define REGSTR_VAL_DV2_SHOWNETCONN TEXT("Start_ShowNetConn")
#define REGSTR_VAL_DV2_SHOWRUN     TEXT("Start_ShowRun")
#define REGSTR_VAL_DV2_SHOWRECDOCS TEXT("Start_ShowRecentDocs")
#define REGSTR_VAL_DV2_SHOWMYDOCS  TEXT("Start_ShowMyDocs")
#define REGSTR_VAL_DV2_SHOWMYPICS  TEXT("Start_ShowMyPics")
#define REGSTR_VAL_DV2_SHOWMYMUSIC TEXT("Start_ShowMyMusic")
#define REGSTR_VAL_DV2_SHOWCPL     TEXT("Start_ShowControlPanel")
#define REGSTR_VAL_DV2_SHOWPRINTERS TEXT("Start_ShowPrinters")
#define REGSTR_VAL_DV2_SHOWHELP    TEXT("Start_ShowHelp")
#define REGSTR_VAL_DV2_SHOWSEARCH  TEXT("Start_ShowSearch")
#define REGSTR_VAL_DV2_FAVORITES   TEXT("StartMenuFavorites")   // shared with classic SM
#define REGSTR_VAL_DV2_LARGEICONS  TEXT("Start_LargeMFUIcons")
#define REGSTR_VAL_DV2_MINMFU      TEXT("Start_MinMFU")
#define REGSTR_VAL_DV2_SHOWOEM     TEXT("Start_ShowOEMLink")
#define REGSTR_VAL_DV2_AUTOCASCADE TEXT("Start_AutoCascade")
#define REGSTR_VAL_DV2_NOTIFYNEW   TEXT("Start_NotifyNewApps")
#define REGSTR_VAL_DV2_ADMINTOOLSROOT TEXT("Start_AdminToolsRoot")
#define REGSTR_VAL_DV2_MINMFU_DEFAULT   6

#define DV2_REGPATH TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\StartPage")
#define DV2_SYSTEM_START_TIME    TEXT("StartMenu_Start_Time")
#define DV2_NEWAPP_BALLOON_TIME  TEXT("StartMenu_Balloon_Time")

#define STARTPANELTHEME            L"StartPanel"
#define PROP_DV2_BALLOONTIP        L"StartMenuBalloonTip"

#define DV2_BALLOONTIP_MOREPROG     LongToHandle(1)
#define DV2_BALLOONTIP_CLIP         LongToHandle(2)
#define DV2_BALLOONTIP_STARTBUTTON  LongToHandle(3)

// protypes of functions which live in specfldr.cpp but trayprop needs access too
BOOL ShouldShowNetPlaces();
BOOL ShouldShowConnectTo();


#endif // _DESKTOP2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\desktopp.h ===
#ifndef _desktop_h
#define _desktop_h

#include <desktray.h>

// REVIEW: does not seem to be used...
// #define DTM_SIZEDESKTOP             (WM_USER + 75)
// #define DTM_EXITWINDOWS             (WM_USER + 78)


#define DTM_THREADEXIT              (WM_USER + 76)
#define DTM_SAVESTATE               (WM_USER + 77)
#define DTM_SHELLSERVICEOBJECTS     (WM_USER + 79)
#define DTM_STARTWAIT               (WM_USER + 80)
#define DTM_ENDWAIT                 (WM_USER + 81)

#define DTM_RELEASEPROXYDESKTOP     (WM_USER + 82)

#define DTM_RAISE                       (WM_USER + 83)
#define DTRF_RAISE      0
#define DTRF_LOWER      1
#define DTRF_QUERY      2    // to avoid sending a message to a hung desktop, query passes hwndTray in wParam, and desktop send TRAY a TM_DESKTOPSTATE message

#define DTM_ADDREFPROXYDESKTOP      (WM_USER + 84)
#define DTM_CREATESAVEDWINDOWS      (WM_USER + 85)
#define DTM_ENUMBANDS               (WM_USER + 86)

#ifdef DEBUG
#define DTM_NEXTCTL                 (WM_USER + 87)
#endif
#define DTM_UIACTIVATEIO            (WM_USER + 88)
#define DTM_ONFOCUSCHANGEIS         (WM_USER + 89)

#define DTM_SETUPAPPRAN             (WM_USER + 90)  // NT 5 USER posts this message to us

// END OF IE 4.00 / 4.01 MESSAGES

// BEGINNING OF IE 5.00 MESSAGES

#define DTM_GETVIEWAREAS            (WM_USER + 91)  // View area is WorkArea minus toolbar areas.
#define DTM_DESKTOPCONTEXTMENU      (WM_USER + 92)
#define DTM_UPDATENOW               (WM_USER + 93)

#define DTM_QUERYHKCRCHANGED        (WM_USER + 94)  // ask the desktop if HKCR has changed

#define DTM_MAKEHTMLCHANGES         (WM_USER + 95)  // Make changes to desktop html using dynamic HTML

#define DTM_STARTPAGEONOFF          (WM_USER + 96)  // Turn on/off the StartPage.

#define DTM_REFRESHACTIVEDESKTOP    (WM_USER + 97)  // Refresh the active desktop.

#define DTM_SETAPPSTARTCUR          (WM_USER + 98)  // UI feedback that we are starting an explorer window.

#define COF_NORMAL              0x00000000
#define COF_CREATENEWWINDOW     0x00000001      // "/N"
#define COF_USEOPENSETTINGS     0x00000002      // "/A"
#define COF_WAITFORPENDING      0x00000004      // Should wait for Pending
#define COF_EXPLORE             0x00000008      // "/E"
#define COF_NEWROOT             0x00000010      // "/ROOT"
#define COF_ROOTCLASS           0x00000020      // "/ROOT,<GUID>"
#define COF_SELECT              0x00000040      // "/SELECT"
#define COF_AUTOMATION          0x00000080      // The user is trying to use automation
#define COF_OPENMASK            0x000000FF
#define COF_NOTUSERDRIVEN       0x00000100      // Not user driven
#define COF_NOTRANSLATE         0x00000200      // Don't ILCombine(pidlRoot, pidl)
#define COF_INPROC              0x00000400      // not used
#define COF_CHANGEROOTOK        0x00000800      // Try Desktop root if not in our root
#define COF_NOUI                0x00001000      // Start background desktop only (no folder/explorer)
#define COF_SHDOCVWFORMAT       0x00002000      // indicates this struct has been converted to abide by shdocvw format. 
                                                // this flag is temporary until we rip out all the 
#define COF_NOFINDWINDOW        0x00004000      // Don't try to find the window
#define COF_HASHMONITOR         0x00008000      // pidlRoot in IETHREADPARAM struct contains an HMONITOR
#ifdef UNIX
#define COF_HELPMODE            0x00010000      // grabbed from IETHREAD.H (for completeness)
#endif
#define COF_SEPARATEPROCESS     0x00020000      // Start in a new process
#define COF_SHELLFOLDERWINDOW   0x01000000      // This is a folder window, don't append - Microsoft Internet... when no pidl...
#define COF_PARSEPATHW          0x02000000      // the NFI.pszPath needs to be parsed but it is UNICODE
#define COF_FIREEVENTONDDEREG   0x20000000      // Fire an event when DDE server is registered
#define COF_FIREEVENTONCLOSE    0x40000000      // Fire an event when browser window closes
#define COF_IEXPLORE            0x80000000

//  this is used by DTM_QUERYHKCRCHANGED and the OpenAs Dialog
//  because the OpenAs Dialog is always in a separate process,
//  and it needs to cache a cookie in the desktop for the DTM
//  the QHKCRID is passed as the wParam in the message.
typedef enum 
{
    QHKCRID_NONE = 0,
    QHKCRID_MIN = 1, 
    QHKCRID_OPENAS = QHKCRID_MIN,
    QHKCRID_VIEWMENUPOPUP,
    QHKCRID_MAX
} QHKCRID;

//  didnt add PARSEPATHA because only browseui adds it, and it is UNICODE
//  but might need it later...
#define COF_PARSEPATH      COF_PARSEPATHW

typedef struct
{
    LPSTR pszPath;
    LPITEMIDLIST pidl;

    UINT uFlags;                // COF_ bits, (shared with IETHREADPARAM.uFlags
    int nShow;
    HWND hwndCaller;
    DWORD dwHotKey;
    LPITEMIDLIST pidlSelect;    // Only used if COF_SELECT

    LPSTR pszRoot;              // Only used for Parse_CmdLine
    LPITEMIDLIST pidlRoot;      // Only used if COF_NEWROOT
    CLSID clsid;                // Only used if COF_NEWROOT

    CLSID clsidInProc;          // Only used if COF_INPROC
} NEWFOLDERINFO, *PNEWFOLDERINFO;

STDAPI_(HANDLE) SHCreateDesktop(IDeskTray* pdtray);
STDAPI_(BOOL) CreateFromDesktop(PNEWFOLDERINFO pfi);
STDAPI_(BOOL) SHCreateFromDesktop(PNEWFOLDERINFO pfi);
STDAPI_(BOOL) SHDesktopMessageLoop(HANDLE hDesktop);
STDAPI_(BOOL) SHExplorerParseCmdLine(PNEWFOLDERINFO pfi);

#define IDT_DDETIMEOUT      1
#define IDT_ENUMHKCR        2

// for the desktop to handle DDE
STDAPI_(LRESULT) DDEHandleMsgs(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
STDAPI_(void) DDEHandleTimeout(HWND hwnd);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\desktray.h ===
#ifndef _DESKTRAY_H_
#define _DESKTRAY_H_

#undef  INTERFACE
#define INTERFACE   IDeskTray

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */

DECLARE_INTERFACE_(IDeskTray, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDeskTray methods ***
    STDMETHOD_(UINT, AppBarGetState)(THIS) PURE;
    STDMETHOD(GetTrayWindow)(THIS_ HWND* phwndTray) PURE;
    STDMETHOD(SetDesktopWindow)(THIS_ HWND hwndDesktop) PURE;

    // WARNING!  BEFORE CALLING THE SetVar METHOD YOU MUST DETECT
    // THE EXPLORER VERSION BECAUSE IE 4.00 WILL CRASH IF YOU TRY
    // TO CALL IT

    STDMETHOD(SetVar)(THIS_ int var, DWORD value) PURE;
};

#define SVTRAY_EXITEXPLORER     0   // g_fExitExplorer

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#endif // _DESKTRAY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dobjutil.h ===
STDAPI          DataObj_GetBlob(IDataObject *pdtobj, UINT cf, LPVOID pvBlob, UINT cbBlob);
STDAPI          DataObj_SetBlob(IDataObject *pdtobj, UINT cf, LPCVOID pvBlob, UINT cbBlob);
STDAPI          DataObj_SetGlobal(IDataObject *pdtobj, UINT cf, HGLOBAL hGlobal);
STDAPI          DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw);
STDAPI_(DWORD)  DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD dwDefault);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dllload.c ===
// You are expected to #include this file from your private dllload.c.

// WARNING!   Failure to observe these rules will result in really subtle
// (and horrible) runtime/build problems.
//
// WARNING!  If you choose to delay-load a DLL, you **must** disable
// import thunks for that DLL when you include its header file.  For example,
// you must #define _OLE32_ before you #include <ole32.h>.  Otherwise,
// what happens is that the linker ends up exporting your delayload thunk
// (because it thinks it's an exported function because the header file
// said so) and then everybody who links to your DLL will accidentally
// use the delayload thunk instead of the original function.  This is
// particularly gruesome because this problem hoses every DLL in the system
// **except for you**.
//
// WARNING!  But if you are delay-loading an optional function and
// you are statically linking to the target DLL for required functions
// (e.g., you are delayloading an NT5-only function), then you should not
// disable import thunks since you really do want import thunks for the
// regular functions.  The way do handle this is to delayload the function
// with an alternate name (e.g., prepend an underscore) and use the MAP
// version of the delay-load macros.  Then in your global header file,
// #define the function to its mapped name.
//
// End of warnings.

// Delay loading mechanism.  This allows you to write code as if you are
// calling implicitly linked APIs, and yet have these APIs really be
// explicitly linked.  You can reduce the initial number of DLLs that 
// are loaded (load on demand) using this technique.
//
// Use the following macros to indicate which APIs/DLLs are delay-linked
// and -loaded.
//
//      DELAY_LOAD
//      DELAY_LOAD_HRESULT
//      DELAY_LOAD_SAFEARRAY
//      DELAY_LOAD_UINT
//      DELAY_LOAD_INT
//      DELAY_LOAD_VOID
//
// Use these macros for APIs that are exported by ordinal only.
//
//      DELAY_LOAD_ORD
//      DELAY_LOAD_VOID_ORD
//
// Use these macros for APIs that only exist on the integrated-shell
// installations (i.e., a new shell32 is on the system).
//
//      DELAY_LOAD_SHELL
//      DELAY_LOAD_SHELL_HRESULT
//      DELAY_LOAD_SHELL_VOID
//
//
// Use DELAY_LOAD_IE_* for APIs that come from BrowseUI.  This used
// to be important when BrowseUI was in the IEXPLORE directory, but
// now it's in the System directory so the difference is pretty
// meaningless.
//
// Use DELAY_LOAD_OCX_* for APIs that come from OCXs and not DLLs.
//

/**********************************************************************/

#ifdef DEBUG

void _DumpLoading(LPTSTR pszDLL, LPTSTR pszFunc)
{
#ifdef DF_DELAYLOADDLL
    if (g_dwDumpFlags & DF_DELAYLOADDLL)
    {
        TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time for %s",
                 pszDLL, pszFunc);
    }
#endif
}

#define ENSURE_LOADED(_hmod, _dll, _ext, pszfn)         \
    (_hmod ? (_hmod) : (_DumpLoading(TEXT(#_dll) TEXT(".") TEXT(#_ext), pszfn), \
                        _hmod = LoadLibraryA(#_dll "." #_ext)))

#else

#define ENSURE_LOADED(_hmod, _dll, _ext, pszfn)         \
    (_hmod ? (_hmod) : (_hmod = LoadLibraryA(#_dll "." #_ext)))

#endif  // DEBUG


/**********************************************************************/

void _GetProcFromDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
#ifdef DEBUG
    CHAR szProcD[MAX_PATH];
    if (!IS_INTRESOURCE(pszProc)) {
        lstrcpynA(szProcD, pszProc, ARRAYSIZE(szProcD));
    } else {
        wsprintfA(szProcD, "(ordinal %d)", LOWORD((DWORD_PTR)pszProc));
    }
#endif
    // If it's already loaded, return.
    if (*ppfn) {
        return;
    }

    if (*phmod == NULL) {
#ifdef DEBUG
#ifdef DF_DELAYLOADDLL
        if (g_dwDumpFlags & DF_DELAYLOADDLL)
        {
            TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time for %s",
                 pszDLL, szProcD);
        }
#endif
        if (g_dwBreakFlags & 0x00000080)
        {
            DebugBreak();
        }
#endif
        *phmod = LoadLibraryA(pszDLL);
#ifdef UNIX
        if (*phmod == NULL) {
           if (lstrcmpiA(pszDLL, "inetcpl.dll") == 0) {
               *phmod = LoadLibraryA("inetcpl.cpl");
           }
        }
#endif
        if (*phmod == NULL) {
            return;
        }
    }

#if defined(DEBUG) && defined(DF_DELAYLOADDLL)
    if (g_dwDumpFlags & DF_DELAYLOADDLL) {
        TraceMsg(TF_ALWAYS, "DLLLOAD: GetProc'ing %s from %s for the first time",
             pszDLL, szProcD);
    }
#endif
    *ppfn = GetProcAddress(*phmod, pszProc);
}

#if defined(DEBUG) && defined(BROWSEUI_IN_IEXPLORE_DIRECTORY)
void _GetProcFromSystemDLL(HMODULE* phmod, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{

#ifdef UNIX
    if (lstrcmpiA(pszDLL, "inetcpl.dll") == 0) {
        _GetProcFromDLL(phmod, "inetcpl.cpl", ppfn, pszProc);
        return;
    }
#endif

    // You must use DELAY_LOAD_IE for BROWSEUI since BROWSEUI lives in the
    // IE directory, not the System directory.
    if (lstrcmpiA(pszDLL, "BROWSEUI.DLL") == 0) {
        ASSERT(!"Somebody used DELAY_LOAD instead of DELAY_LOAD_IE on BROWSEUI");
    }
    _GetProcFromDLL(phmod, pszDLL, ppfn, pszProc);
}
#else
#define _GetProcFromSystemDLL           _GetProcFromDLL
#endif

// NOTE: this takes two parameters that are the function name. the First (_fn) is the name that
// NOTE: the function will be called in this DLL and the other (_fni) is the
// NOTE: name of the function we will GetProcAddress. This helps get around functions that
// NOTE: are defined in the header files with _declspec...

//
//  HMODULE _hmod - where we cache the HMODULE (aka HINSTANCE)
//           _dll - Basename of the target DLL, not quoted
//           _ext - Extension of the target DLL, not quoted (usually DLL)
//           _ret - Data type of return value
//        _fnpriv - Local name for the function
//            _fn - Exported name for the function
//          _args - Argument list in the form (TYPE1 arg1, TYPE2 arg2, ...)
//         _nargs - Argument list in the form (arg1, arg2, ...)
//           _err - Return value if we can't call the actual function
//
#define DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnpriv, _fn, _args, _nargs, _err) \
_ret __stdcall _fnpriv _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll "." #_ext, (FARPROC*)&_pfn##_fn, #_fn); \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define     DELAY_LOAD_NAME_ERR(_hmod, _dll,       _ret, _fnpriv, _fn, _args, _nargs, _err) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll,  DLL, _ret, _fnpriv, _fn, _args, _nargs, _err)

#define DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn,      _args, _nargs, _err) \
   DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fn, _args, _nargs, _err)

#define DELAY_LOAD(_hmod, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_UINT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, UINT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_INT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, INT, _fn, _args, _nargs, 0)
#define DELAY_LOAD_BOOL(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, BOOL, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_BOOLEAN(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, BOOLEAN, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_DWORD(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_LRESULT(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, LRESULT, _fn, _args, _nargs, FALSE)
#define DELAY_LOAD_WNET(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, DWORD, _fn, _args, _nargs, WN_NOT_SUPPORTED)
#define DELAY_LOAD_LPVOID(_hmod, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hmod, _dll, LPVOID, _fn, _args, _nargs, 0)

// the NAME variants allow the local function to be called something different from the imported
// function to avoid dll linkage problems.
#define DELAY_LOAD_NAME(_hmod, _dll, _ret, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, _ret, _fn, _fni, _args, _nargs, 0)
#define DELAY_LOAD_NAME_HRESULT(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, HRESULT, _fn, _fni, _args, _nargs, E_FAIL)
#define DELAY_LOAD_NAME_SAFEARRAY(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, SAFEARRAY *, _fn, _fni, _args, _nargs, NULL)
#define DELAY_LOAD_NAME_UINT(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, UINT, _fn, _fni, _args, _nargs, 0)
#define DELAY_LOAD_NAME_BOOL(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, BOOL, _fn, _fni, _args, _nargs, FALSE)
#define DELAY_LOAD_NAME_DWORD(_hmod, _dll, _fn, _fni, _args, _nargs) DELAY_LOAD_NAME_ERR(_hmod, _dll, DWORD, _fn, _fni, _args, _nargs, 0)

#define DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fni, _args, _nargs)                               \
void __stdcall _fn _args                                                                \
{                                                                                       \
    static void (__stdcall *_pfn##_fni) _args = NULL;                                   \
    if (!ENSURE_LOADED(_hmod, _dll, DLL, TEXT(#_fni)))                                       \
    {                                                                                   \
        AssertMsg(BOOLFROMPTR(_hmod), TEXT("LoadLibrary failed on ") ## TEXT(#_dll));         \
        return;                                                                         \
    }                                                                                   \
    if (_pfn##_fni == NULL)                                                              \
    {                                                                                   \
        *(FARPROC*)&(_pfn##_fni) = GetProcAddress(_hmod, #_fni);                         \
        AssertMsg(BOOLFROMPTR(_pfn##_fni), TEXT("GetProcAddress failed on ") ## TEXT(#_fni));    \
        if (_pfn##_fni == NULL)                                                          \
            return;                                                                     \
    }                                                                                   \
    _pfn##_fni _nargs;                                                                   \
}

#define DELAY_LOAD_VOID(_hmod, _dll, _fn, _args, _nargs)   DELAY_LOAD_NAME_VOID(_hmod, _dll, _fn, _fn, _args, _nargs)



// For private entrypoints exported by ordinal.
#define DELAY_LOAD_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_ORD(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_EXT_ORD(_hmod, _dll, _ext, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hmod, #_dll "." #_ext, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs)                     \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromSystemDLL(&_hmod, #_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}
#define DELAY_LOAD_VOID_ORD DELAY_LOAD_ORD_VOID // cuz people mess this up all the time

#define DELAY_LOAD_ORD_BOOL(_hmod, _dll, _fn, _ord, _args, _nargs) \
    DELAY_LOAD_ORD_ERR(_hmod, _dll, BOOL, _fn, _ord, _args, _nargs, 0)

#define DELAY_LOAD_EXT(_hmod, _dll, _ext, _ret, _fn, _args, _nargs) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fn, _fn, _args, _nargs, 0)

#define DELAY_LOAD_EXT_WRAP(_hmod, _dll, _ext, _ret, _fnWrap, _fnOrig, _args, _nargs) \
        DELAY_LOAD_NAME_EXT_ERR(_hmod, _dll, _ext, _ret, _fnWrap, _fnOrig, _args, _nargs, 0)

#if defined(BROWSEUI_IN_IEXPLORE_DIRECTORY) || defined(UNIX)
/*----------------------------------------------------------
Purpose: Loads the DLL via a CLSID it is known to be registered for
*/
void _GetProcFromCLSID(HMODULE* phmod, const CLSID *pclsid, FARPROC* ppfn, LPCSTR pszProc)
{
    if (*phmod == NULL) {
        //
        //  SHPinDLLOfCLSID does all the annoying work of opening the
        //  appropriate registry key, doing REG_EXPAND_SZ, etc.
        //  It also loads the DLL with exactly the same name that OLE does,
        //  which is important because NT4 SP3 didn't like it when you loaded
        //  a DLL sometimes via SFN and sometimes via LFN.  (It would
        //  think they were different DLLs, and two copies of it got loaded
        //  into memory.  Aigh!)
        //
        *phmod = (HMODULE)SHPinDllOfCLSID(pclsid);
        if (!*phmod) 
            return;
    }

    // We don't know the name of the DLL, but fortunately _GetProcFromDLL
    // doesn't need it if *phmod is already filled in.
    ASSERT(*phmod);
    _GetProcFromDLL(phmod, "", ppfn, pszProc);
}

//
//  Private exports by ordinal for browseui.  loads from the browseui in apppath dir
//

#ifndef UNIX

#define DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#else

#define DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)#_fn);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#endif
    
#ifndef UNIX

#define DELAY_LOAD_IE_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#else

#define DELAY_LOAD_IE_ORD_VOID(_hmod, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _GetProcFromCLSID(&_hmod, &CLSID_##_dll, (FARPROC*)&_pfn##_fn, (LPCSTR)#_fn); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#endif

#else // BrowseUI is in the System directory

#define DELAY_LOAD_IE_ORD_ERR       DELAY_LOAD_ORD_ERR
#define DELAY_LOAD_IE_ORD_VOID      DELAY_LOAD_ORD_VOID

#endif

#define DELAY_LOAD_IE(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_IE_HRESULT(_hmod, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)
#define DELAY_LOAD_IE_BOOL(_hmod, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, BOOL, _fn, _ord, _args, _nargs, FALSE)

#define DELAY_LOAD_IE_ORD(_hmod, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_IE_ORD_ERR(_hmod, _dll, _ret, _fn, _ord, _args, _nargs, 0)

#ifndef NO_LOADING_OF_SHDOCVW_ONLY_FOR_WHICHPLATFORM

/*----------------------------------------------------------
Purpose: Performs a loadlibrary on the DLL only if the machine
     has the integrated shell installation.

*/
void _SHGetProcFromDLL(HINSTANCE* phinst, LPCSTR pszDLL, FARPROC* ppfn, LPCSTR pszProc)
{
    if (PLATFORM_INTEGRATED == WhichPlatform())
        _GetProcFromSystemDLL(phinst, pszDLL, ppfn, pszProc);
    else
        TraceMsg(TF_ERROR, "Could not load integrated shell version of %s for %d", pszDLL, pszProc);
}

#endif // NO_LOADING_OF_SHDOCVW_ONLY_FOR_WHICHPLATFORM

//
//  Private exports by ordinal for integrated-shell installs
//


#define DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#define DELAY_LOAD_SHELL(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_SHELL_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)
#define DELAY_LOAD_SHELL_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs ) DELAY_LOAD_SHELL_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL )


#define DELAY_LOAD_SHELL_VOID(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

// Following Macros are functionally  same as above only that they are
// using function name on UNIX rather than ordinals. The above macros 
// are left untouched because other dlls like shdocvw/shdoc401 still use
// them.

#ifndef UNIX

#define DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err, _realfn) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#else

#define DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err, _realfn) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)#_realfn);   \
    if (_pfn##_fn)               \
        return _pfn##_fn _nargs; \
    return (_ret)_err;           \
}

#endif

#define DELAY_LOAD_SHELL_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _realfn) DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0, _realfn)
#define DELAY_LOAD_SHELL_HRESULT_FN(_hinst, _dll, _fn, _ord, _args, _nargs, realfn) DELAY_LOAD_SHELL_ERR_FN(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL, _realfn)


#ifndef UNIX

#define DELAY_LOAD_SHELL_VOID_FN(_hinst, _dll, _fn, _ord, _args, _nargs, _realfn) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)_ord); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#else

#define DELAY_LOAD_SHELL_VOID_FN(_hinst, _dll, _fn, _ord, _args, _nargs, _realfn) \
void __stdcall _fn _args                \
{                                       \
    static void (__stdcall *_pfn##_fn) _args = NULL;   \
    _SHGetProcFromDLL(&_hinst, #_dll ".DLL", (FARPROC*)&_pfn##_fn, (LPCSTR)#_realfn); \
    if (_pfn##_fn)              \
        _pfn##_fn _nargs;       \
    return;                     \
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dllreghelper.h ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      DllRegHelper.h
//
//  Contents:  helper classes to register COM components in DLLs
//
//------------------------------------------------------------------------

#ifndef _DLL_REG_HELPER_H
#define _DLL_REG_HELPER_H

#include <comcat.h>

//------------------------------------------------------------------------
enum DRH_REG_MODE
{
    CCR_REG = 1,
    CCR_UNREG = 0,
    CCR_UNREGIMP = -1
};

//------------------------------------------------------------------------
//***   RegisterOneCategory -- [un]register ComCat implementor(s) and category
// ENTRY/EXIT
//  eRegister   CCR_REG, CCR_UNREG, CCR_UNREGIMP
//      CCR_REG, UNREG      reg/unreg implementor(s) and category
//      CCR_UNREGIMP        unreg implementor(s) only
//  pcatidCat   e.g. CATID_DeskBand
//  idResCat    e.g. IDS_CATDESKBAND
//  pcatidImpl  e.g. c_DeskBandClasses
HRESULT DRH_RegisterOneCategory(const CATID *pcatidCat, UINT idResCat, const CATID * const *pcatidImpl, enum DRH_REG_MODE eRegister);


// Calls the ADVPACK entry-point which executes an inf file section.
HRESULT DRH_CallRegInstall(LPSTR pszSection, BOOL bUninstall);


#endif // _DLL_REG_HELPER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\doshelp.h ===
// Help ids

/* NOTE!  Any changes to this file must be cleared with UE! */

//#define IDH_NO_HELP                             28440   // if you don't know...

/* The following symbols are defined in core\inc\help.h, which we dup here */

#ifndef IDH_OK
#define IDH_OK                                  28443   // From Help.h
#endif

#ifndef IDH_CANCEL
#define IDH_CANCEL                              28444   // From Help.h
#endif

#ifndef IDH_COMM_GROUPBOX
#define IDH_COMM_GROUPBOX                       28548   // From Help.h
#endif


#define IDH_DOS_ADV_AUTOEXEC                    5200
#define IDH_DOS_ADV_CONFIG                      5201
#define IDH_NOMSDOSWARNING                      5202
#define IDH_DOS_ADV_PIFNAME                     5203
#define IDH_DOS_AVAIL_FONTS                     5204
#define IDH_DOS_DISPLAY_ROM                     5205
#define IDH_DOS_DISPLAY_SCREEN_SETTINGS         5206

#define IDH_DOS_ADV_CONFIG_BTN                  5208
#define IDH_DOS_ADV_PRG_SUGGEST                 5209
#define IDH_DOS_MEMORY_NOEMS_DETAILS            5211
#define IDH_DOS_FONT_FONT_PREVIEW               5212
#define IDH_DOS_FONT_SIZE                       5213
#define IDH_DOS_FONT_WINDOW_PREVIEW             5214
#define IDH_DOS_KEYBOARD_FASTPASTE              5215
#define IDH_DOS_KEYBOARD_SHORTCUTS              5216
#define IDH_DOS_MEMORY_CONV                     5217
#define IDH_DOS_MEMORY_CONV_GLOBAL              5218
#define IDH_DOS_MEMORY_DPMI                     5219
#define IDH_DOS_MEMORY_EXP                      5220
#define IDH_DOS_SCREEN_USAGE_FULL               5221
#define IDH_DOS_MEMORY_EXT                      5222
#define IDH_DOS_MEMORY_EXT_HMA                  5223
#define IDH_DOS_SCREEN_USAGE_WINDOW             5224
#define IDH_DOS_SCREEN_USAGE_AUTO               5225
#define IDH_DOS_PROGRAM_ADV_BUTTON              5226
#define IDH_DOS_PROGRAM_BATCH                   5227
#define IDH_DOS_PROGRAM_CHANGEICON              5228
#define IDH_DOS_PROGRAM_CMD_LINE                5229
#define IDH_DOS_PROGRAM_DESCRIPTION             5230
#define IDH_DOS_PROGRAM_ENVIRSZ                 5231
#define IDH_DOS_PROGRAM_ICON                    5232
#define IDH_DOS_PROGRAM_ICON_NAME               5233
#define IDH_DOS_PROGRAM_RUN                     5234
#define IDH_DOS_PROGRAM_SHORTCUT                5235
#define IDH_DOS_PROGRAM_WORKDIR                 5236
#define IDH_DOS_REALMODEPROPS                   5237
#define IDH_DOS_SCREEN_RESTORE                  5238
#define IDH_DOS_TASKING_ALLOW_SCREENSAVER       5239
#define IDH_DOS_TASKING_IDLE_SLIDER             5241
#define IDH_DOS_TASKING_SINGLE                  5242
#define IDH_DOS_TASKING_SUSPEND                 5243
#define IDH_DOS_WINDOWS_MOUSE_EXCLUSIVE         5246
#define IDH_DOS_WINDOWS_MOUSE_QUICKEDIT         5247
#define IDH_DOS_WINDOWS_QUIT_CLOSE              5248
#define IDH_DOS_WINDOWS_RESTORE                 5249
#define IDH_DOS_WINDOWS_TOOLBAR                 5250
#define IDH_DOS_WINDOWS_WARN                    5251
#define IDH_DOS_ADV_HIDEWINDOWS                 5252
#define IDH_DOS_SCREEN_DMA                      5253
#define IDH_DOS_ADV_CLEANCFG                    5254
#define IDH_DOS_ADV_CURCFG                      5255

#define IDH_CONSOLE_FONT_FONT                   5256
#define IDH_CONSOLE_FONT_BOLD_FONTS             5257

#define IDH_DOS_PROGRAM_PIF_TIMER_EMULATE       5262

#define IDH_CONSOLE_SIZE_BUFF_WIDTH             5263
#define IDH_CONSOLE_SIZE_BUFF_HEIGHT            5264
#define IDH_CONSOLE_SIZE_WIN_WIDTH              5265
#define IDH_CONSOLE_SIZE_WIN_HEIGHT             5266
#define IDH_CONSOLE_SIZE_POS_LEFT               5267
#define IDH_CONSOLE_SIZE_POS_TOP                5268
#define IDH_CONSOLE_SIZE_LET_SYS                5269
#define IDH_CONSOLE_COLOR_SCR_TEXT              5270
#define IDH_CONSOLE_COLOR_SCR_BACK              5271
#define IDH_CONSOLE_COLOR_POPUP_TEXT            5272
#define IDH_CONSOLE_COLOR_POPUP_BACK            5273
#define IDH_CONSOLE_COLOR_RED                   5274
#define IDH_CONSOLE_COLOR_GREEN                 5275
#define IDH_CONSOLE_COLOR_BLUE                  5276
#define IDH_CONSOLE_COLOR_SCR_COLORS            5277
#define IDH_CONSOLE_COLOR_WIN_COLORS            5278
#define IDH_CONSOLE_COLOR_COLOR_BAR             5279

#define IDH_CONSOLE_OPTIONS_BUFF_NUM            5280
#define IDH_CONSOLE_OPTIONS_BUFF_SIZE           5281
#define IDH_CONSOLE_OPTIONS_CURSOR              5282
#define IDH_CONSOLE_OPTIONS_CURSOR_LARGE        5283
#define IDH_CONSOLE_OPTIONS_CURSOR_MED          5284
#define IDH_CONSOLE_OPTIONS_DISCARD_DUPS        5285
#define IDH_CONSOLE_OPTIONS_INSERT              5286
#define IDH_CONSOLE_OPTIONS_QUICK_EDIT          5287
#define IDH_CONSOLE_OPTIONS_LANGUAGE            5288
#define IDH_CONSOLE_OPTIONS_AUTOCOMPLETE        5289
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dpastuff.h ===
#ifndef DPASTUFF_H_
#define DPASTUFF_H_

typedef struct
{
    DWORD           dwSortBy;           // the sort by flag.
    IShellFolder    *psf;               // shell folder to be ordered.

    // Caller of OrderList_Merge does *not* fill in this field.
    // This field is used internally by OrderList_Merge.
    IShellFolder2   *psf2;              // IShellFolder2 version of psf
    LPARAM          lParam;             // Other user data...

} ORDERINFO, * PORDERINFO;

// see shellp.h for ORDERITEM definition
typedef void (*LPFNORDERMERGENOMATCH)(LPVOID pvParam, LPCITEMIDLIST pidl);

int CALLBACK OrderItem_Compare(LPVOID pv1, LPVOID pv2, LPARAM lParam);
LPVOID CALLBACK OrderItem_Merge(UINT uMsg, LPVOID pvDest, LPVOID pvSrc, LPARAM lParam);
void OrderList_Merge(HDPA hdpaNew, HDPA hdpaOld, int iInsertPos, LPARAM lParam, 
                     LPFNORDERMERGENOMATCH pfn, LPVOID pvParam);
void OrderList_Reorder(HDPA hdpa);
HDPA OrderList_Clone(HDPA hdpa);
PORDERITEM OrderItem_Create(LPITEMIDLIST pidl, int nOrder);
void OrderList_Destroy(HDPA *hdpa, BOOL fKillPidls = TRUE);
int OrderItem_GetSystemImageListIndex(PORDERITEM poi, IShellFolder *psf, BOOL fUseCache);
DWORD OrderItem_GetFlags(PORDERITEM poi);
void OrderItem_SetFlags(PORDERITEM poi, DWORD dwFlags);
HRESULT OrderList_SaveToStream(IStream* pstm, HDPA hdpa, IShellFolder * psf);
HRESULT OrderList_LoadFromStream(IStream* pstm, HDPA * phdpa, IShellFolder * psfParent);
void OrderItem_Free(PORDERITEM poi, BOOL fKillPidls = TRUE);
BOOL OrderList_Append(HDPA hdpa, LPITEMIDLIST pidl, int nOrder);

HRESULT COrderList_GetOrderList(HDPA * phdpa, LPCITEMIDLIST pidl, IShellFolder * psf);
HRESULT COrderList_SetOrderList(HDPA hdpa, LPCITEMIDLIST pidl, IShellFolder *psf);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dpa.h ===
#ifndef GUARD_D70787804D9C11d28784F6E920524153
#define GUARD_D70787804D9C11d28784F6E920524153

#include "comctrlp.h"

//  The Ex versions of EnumCallback, DestroyCallback, Sort, Search, etc.
//  do stricter type checking to make sure that the reference data /
//  parameter matches both on the calling side and the callback side.


template <class T> class CDPA
{

public:
    // Typedefs
    typedef int (CALLBACK *_PFNDPAENUMCALLBACK)(T *p, void *pData);
    typedef int (CALLBACK *_PFNDPACOMPARE)(T *p1, T *p2, LPARAM lParam);

    // Functions

    CDPA(HDPA hdpa = NULL) {m_hdpa = hdpa;}

    BOOL IsDPASet() {return m_hdpa != NULL; }

    void Attach(const HDPA hdpa) {m_hdpa = hdpa;}
    HDPA Detach() {HDPA hdpa = m_hdpa; m_hdpa = NULL; return hdpa;}

    operator HDPA () { return m_hdpa; }

    BOOL    Create(int cItemGrow)
    {return (m_hdpa = DPA_Create(cItemGrow)) != NULL;}

    BOOL    CreateEx(int cpGrow, HANDLE hheap)
    {return (m_hdpa = DPA_CreateEx(cpGrow, hheap)) != NULL;}

    BOOL    Destroy()
    {BOOL fRet = DPA_Destroy(m_hdpa); m_hdpa = NULL; return fRet;}

    HDPA    Clone(HDPA hdpaNew)
    {return DPA_Clone(m_hdpa, hdpaNew);}

    T*      GetPtr(INT_PTR i)
    {return (T*) DPA_GetPtr(m_hdpa, i);}

    int     GetPtrIndex(T* p)
    {return DPA_GetPtrIndex(m_hdpa, (void *) p);}

    BOOL    Grow(int cp)
    {return DPA_Grow(m_hdpa, cp);}

    BOOL    SetPtr(int i, T* p)
    {return DPA_SetPtr(m_hdpa, i, (void *) p);}

    int     InsertPtr(int i, T* p)
    {return DPA_InsertPtr(m_hdpa, i, (void *) p);}

    T*      DeletePtr(int i)
    {return (T*) DPA_DeletePtr(m_hdpa, i);}

    BOOL    DeleteAllPtrs()
    {return DPA_DeleteAllPtrs(m_hdpa);}

    void    EnumCallback(_PFNDPAENUMCALLBACK pfnCB, void *pData)
    {DPA_EnumCallback(m_hdpa, (PFNDPAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    EnumCallbackEx(int (CALLBACK *pfnCB)(T* p, T2 pData), T2 pData)
    {EnumCallback((_PFNDPAENUMCALLBACK)pfnCB, reinterpret_cast<void *>(pData));}

    void    DestroyCallback(_PFNDPAENUMCALLBACK pfnCB, void *pData)
    {DPA_DestroyCallback(m_hdpa, (PFNDPAENUMCALLBACK)pfnCB, pData); m_hdpa = NULL;}

    template<class T2>
    void    DestroyCallbackEx(int (CALLBACK *pfnCB)(T* p, T2 pData), T2 pData)
    {DestroyCallback((_PFNDPAENUMCALLBACK)pfnCB, reinterpret_cast<void *>(pData));}

    int     GetPtrCount()
    {return DPA_GetPtrCount(m_hdpa);}

    T*      GetPtrPtr()
    {return (T*)DPA_GetPtrPtr(m_hdpa);}

    T*&     FastGetPtr(int i)
    {return (T*&)DPA_FastGetPtr(m_hdpa, i);}
    
    int     AppendPtr(T* pitem)
    {return DPA_AppendPtr(m_hdpa, (void *) pitem);}

#ifdef __IStream_INTERFACE_DEFINED__
    HRESULT LoadStream(PFNDPASTREAM pfn, IStream * pstream, void *pvInstData)
    {return DPA_LoadStream(&m_hdpa, pfn, pstream, pvInstData);}

    HRESULT SaveStream(PFNDPASTREAM pfn, IStream * pstream, void *pvInstData)
    {return DPA_SaveStream(m_hdpa, pfn, pstream, pvInstData);}
#endif

    BOOL    Sort(_PFNDPACOMPARE pfnCompare, LPARAM lParam)
    {return DPA_Sort(m_hdpa, (PFNDPACOMPARE)pfnCompare, lParam);}

    template<class T2>
    BOOL    SortEx(int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam), T2 lParam)
    {return Sort((_PFNDPACOMPARE)pfnCompare, reinterpret_cast<LPARAM>(lParam));}

    // Merge not supported through this object; use DPA_Merge

    int     Search(T* pFind, int iStart, _PFNDPACOMPARE pfnCompare,
                    LPARAM lParam, UINT options)
    {return DPA_Search(m_hdpa, (void *) pFind, iStart, (PFNDPACOMPARE)pfnCompare, lParam, options);}

    template<class T2>
    int     SearchEx(T* pFind, int iStart,
                    int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam),
                    T2 lParam, UINT options)
    {return Search(pFind, iStart, (_PFNDPACOMPARE)pfnCompare, reinterpret_cast<LPARAM>(lParam), options);}
    
    int     SortedInsertPtr(T* pFind, int iStart, _PFNDPACOMPARE pfnCompare,
                    LPARAM lParam, UINT options, T* pitem)
    {return DPA_SortedInsertPtr(m_hdpa, (void *) pFind, iStart, (PFNDPACOMPARE)pfnCompare, lParam, options, (void *) pitem);}

    template<class T2>
    int     SortedInsertPtrEx(T* pFind, int iStart,
                    int (CALLBACK *pfnCompare)(T *p1, T *p2, T2 lParam),
                    T2 lParam, UINT options, T* pitem)
    {return SortedInsertPtr(pFind, iStart, (_PFNDPACOMPARE)pfnCompare,
                    reinterpret_cast<LPARAM>(lParam), options, pitem);}

private:
    HDPA m_hdpa;
};

template <class T> class CDSA
{
public:
    // Typedefs
    typedef int (CALLBACK *_PFNDSAENUMCALLBACK)(T *p, void *pData);
    typedef int (CALLBACK *_PFNDSACOMPARE)(T *p1, T *p2, LPARAM lParam);

    // Functions

    CDSA(HDSA hdsa = NULL) {m_hdsa = hdsa;}

    void Attach(const HDSA hdsa) {m_hdsa = hdsa;}
    HDSA Detach() { HDSA hdsa = m_hdsa; m_hdsa = NULL; return hdsa; }

    operator HDSA () { return m_hdsa; }

    BOOL    Create(int cItemGrow)
    {return (m_hdsa = DSA_Create(sizeof(T), cItemGrow)) != NULL;}

    BOOL    Destroy()
    {BOOL fRet = DSA_Destroy(m_hdsa); m_hdsa = NULL; return fRet;}

    BOOL    GetItem(int i, T* pitem)
    {return DSA_GetItem(m_hdsa, i, (void *)pitem);}

    T*      GetItemPtr(int i)
    {return (T*)DSA_GetItemPtr(m_hdsa, i);}

    BOOL    SetItem(int i, T* pitem)
    {return DSA_SetItem(m_hdsa, i, (void *)pitem);}

    int     InsertItem(int i, T* pitem)
    {return DSA_InsertItem(m_hdsa, i, (void *)pitem);}

    virtual BOOL    DeleteItem(int i)
    {return DSA_DeleteItem(m_hdsa, i);}

    virtual BOOL    DeleteAllItems()
    {return DSA_DeleteAllItems(m_hdsa);}

    void    EnumCallback(_PFNDSAENUMCALLBACK pfnCB, void *pData)
    {DSA_EnumCallback(m_hdsa, (PFNDSAENUMCALLBACK)pfnCB, pData);}

    template<class T2>
    void    EnumCallbackEx(int (CALLBACK *pfnCB)(T *p, T2 pData), T2 pData)
    {EnumCallback((_PFNDSAENUMCALLBACK)pfnCB, reinterpret_cast<void *>(pData));}

    void    DestroyCallback(_PFNDSAENUMCALLBACK pfnCB, void *pData)
    {DSA_DestroyCallback(m_hdsa, (PFNDSAENUMCALLBACK)pfnCB, pData); m_hdsa = NULL;}

    template<class T2>
    void    DestroyCallbackEx(int (CALLBACK *pfnCB)(T *p, T2 pData), T2 pData)
    {DestroyCallback((_PFNDSAENUMCALLBACK)pfnCB, reinterpret_cast<void *>(pData));}

    int     GetItemCount()
    {return DSA_GetItemCount(m_hdsa);}

    int     AppendItem(T* pitem)
    {return DSA_AppendItem(m_hdsa, (void *)pitem);}

private:
    HDSA m_hdsa;
};

template <class T>
CDSA<T>* CDSA_Create(int cItemGrow)
{
    CDSA<T> *pdsa = new CDSA<T>();
    if (pdsa)
    {
        if (!pdsa->Create(cItemGrow))
        {
            delete pdsa;
            pdsa = NULL;
        }
    }
    return pdsa;
}


#endif // !GUARD_D70787804D9C11d28784F6E920524153
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dpastuff.cpp ===
#include "dpastuff.h"

//
//  The ORDERITEM structure is exposed via the IOrderList interface.
//  ORDERITEM2 contains our private hidden fields.
//
//  The extra fields contain information about the cached icon location.
//
//  ftModified is the modify-time on the pidl, which is used to detect
//  whether the cache needs to be refreshed.
//
//  If ftModified is nonzero, then { pwszIcon, iIconIndex, pidlTarget }
//  describe the icon that should be displayed for the item.
//
//  If pwszIcon is nonzero, then the item is a shortcut with a custom
//  icon.  pwszIcon points to the file name for the icon, iIconIndex
//  is the icon index within the pwszIcon file.
//
//  If pidlTarget is nonzero, then the item is a shortcut with a default
//  icon.  pidlTarget is the target pidl, whose icon we should use.
//

typedef struct ORDERITEM2 {
    ORDERITEM oi;               // part that clients see - must come first
    DWORD  dwFlags;             // User defined flags.
    LPWSTR pwszIcon;            // for cacheing the icon location
    int iIconIndex;             // for cacheing the icon location
    LPITEMIDLIST pidlTarget;    // use the icon for this pidl
} ORDERITEM2, *PORDERITEM2;

int CALLBACK OrderItem_Compare(LPVOID pv1, LPVOID pv2, LPARAM lParam)
{
    PORDERITEM  poi1 = (PORDERITEM)pv1;
    PORDERITEM  poi2 = (PORDERITEM)pv2;
    PORDERINFO  poinfo = (PORDERINFO)lParam;
    int nRet;

    if (!poinfo)
    {   
        ASSERT(FALSE);
        return 0;
    }
    switch (poinfo->dwSortBy)
    {
    case OI_SORTBYNAME:
    {
        // Make sure they're both non-null
        //
        if ( poi1->pidl && poi2->pidl )
        {
            HRESULT hres = poinfo->psf->CompareIDs(0, poi1->pidl, poi2->pidl);
            nRet = (short)HRESULT_CODE(hres);
        }
        else
        {
            if ( poi1->pidl == poi2->pidl )
                nRet = 0;
            else
                nRet = ((UINT_PTR)poi1->pidl < (UINT_PTR)poi2->pidl ? -1 : 1);
        }

        break;
    }

    case OI_SORTBYORDINAL:
        if (poi1->nOrder == poi2->nOrder)
            nRet = 0;
        else
            // do unsigned compare so -1 goes to end of list
            nRet = ((UINT)poi1->nOrder < (UINT)poi2->nOrder ? -1 : 1);
        break;

    default:
        ASSERT_MSG(0, "Bad dwSortBy passed to OrderItem_Compare");
        nRet = 0;
        break;
    }

    return nRet;
}

void OrderItem_FreeIconInfo(PORDERITEM poi)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    if (poi2->pwszIcon)
    {
        LPWSTR pwszIcon = poi2->pwszIcon;
        poi2->pwszIcon = NULL;
        LocalFree(pwszIcon);
    }

    if (poi2->pidlTarget)
    {
        LPITEMIDLIST pidl = poi2->pidlTarget;
        poi2->pidlTarget = NULL;
        ILFree(pidl);
    }
}


LPVOID CALLBACK OrderItem_Merge(UINT uMsg, LPVOID pvDst, LPVOID pvSrc, LPARAM lParam)
{
    PORDERITEM2 poi2Dst = CONTAINING_RECORD(pvDst, ORDERITEM2, oi);
    PORDERITEM2 poi2Src = CONTAINING_RECORD(pvSrc, ORDERITEM2, oi);
    PORDERINFO  poinfo = (PORDERINFO)lParam;
    LPVOID pvRet = pvDst;

    switch (uMsg)
    {
    case DPAMM_MERGE:
        // Transfer the order field
        poi2Dst->oi.nOrder = poi2Src->oi.nOrder;

        // Propagate any cached icon information too...
        if (poi2Src->pwszIcon || poi2Src->pidlTarget)
        {
            // To avoid useless allocation, we transfer the cache across
            // instead of copying it.
            if (poinfo->psf2 &&
                poinfo->psf2->CompareIDs(SHCIDS_ALLFIELDS, poi2Dst->oi.pidl, poi2Src->oi.pidl) == S_OK)
            {
                OrderItem_FreeIconInfo(&poi2Dst->oi);
                CopyMemory((LPBYTE)poi2Dst + sizeof(ORDERITEM),
                           (LPBYTE)poi2Src  + sizeof(ORDERITEM),
                           sizeof(ORDERITEM2) - sizeof(ORDERITEM));
                ZeroMemory((LPBYTE)poi2Src  + sizeof(ORDERITEM),
                           sizeof(ORDERITEM2) - sizeof(ORDERITEM));
            }
        }
        break;

    case DPAMM_DELETE:
    case DPAMM_INSERT:
        // Don't need to implement this
        ASSERT(0);
        pvRet = NULL;
        break;
    }
    
    return pvRet;
}

int OrderItem_UpdatePos(LPVOID p, LPVOID pData)
{
    PORDERITEM poi = (PORDERITEM)p;

    if (-1 == poi->nOrder)
    {
        poi->nOrder = (int)(INT_PTR)pData;
    }
    else if ((int)(INT_PTR)pData >= poi->nOrder)
    {
        poi->nOrder++;
    }

    return 1;
}

// OrderList_Merge sorts hdpaNew to match hdpaOld order,
// putting any items in hdpaNew that were not in hdpaOld
// at position iInsertPos (-1 means end of list).
//
// Assumes hdpaOld is already sorted by sort order in lParam (OI_SORTBYNAME by default)
// (if hdpaOld is specified)
//
void OrderList_Merge(HDPA hdpaNew, HDPA hdpaOld, int iInsertPos, LPARAM lParam,
                     LPFNORDERMERGENOMATCH pfn, LPVOID pvParam)
{
    PORDERINFO poinfo = (PORDERINFO)lParam;

    BOOL fMergeOnly = FALSE;
    if (poinfo->dwSortBy == OI_MERGEBYNAME)
    {
        poinfo->dwSortBy = OI_SORTBYNAME;
        fMergeOnly = TRUE;
    }

    // hdpaNew has not been sorted, sort by name
    DPA_Sort(hdpaNew, OrderItem_Compare, lParam);
    BOOL fForceNoMatch = FALSE;

    if (FAILED(poinfo->psf->QueryInterface(IID_IShellFolder2, (LPVOID *)&poinfo->psf2))) {
        // 239390: Network Connections folder doesn't implement QI correctly.  Its psf 
        // fails QI for IID_IShellFolder2, but doesn't null out ppvObj.  So do it for them.
        poinfo->psf2 = NULL;
    }

    // Copy order preferences over from old list to new list
    if (hdpaOld)
    {
        DPA_Merge(hdpaNew, hdpaOld, DPAM_SORTED | DPAM_NORMAL, OrderItem_Compare, OrderItem_Merge, lParam);

        // If we're waiting for the notify from a drag&drop operation,
        // update the new items (they will have a -1) to the insert position.
        if (-1 != iInsertPos)
        {
            DPA_EnumCallback(hdpaNew, OrderItem_UpdatePos, (LPVOID)(INT_PTR)iInsertPos);
        }

        if (poinfo->dwSortBy != OI_SORTBYORDINAL && !fMergeOnly)
        {
            poinfo->dwSortBy = OI_SORTBYORDINAL;
            DPA_Sort(hdpaNew, OrderItem_Compare, lParam);
        }
    }
    else
        fForceNoMatch = TRUE;

    // If the caller passed a NoMatch callback, then call it with
    // each item that is not matched.
    if (pfn)
    {
        for (int i = DPA_GetPtrCount(hdpaNew)-1 ; i >= 0 ; i--)
        {
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpaNew, i);

            // Does this item have order information?
            if (iInsertPos == poi->nOrder ||
                -1 == poi->nOrder ||
                fForceNoMatch)
            {
                // No; Then pass to the "No Match" callback
                pfn(pvParam, poi->pidl);
            }
        }
    }

    ATOMICRELEASE(poinfo->psf2);

    OrderList_Reorder(hdpaNew);
}

// OrderList_Reorder refreshes the order info
void OrderList_Reorder(HDPA hdpa)
{
    int i;

    for (i = DPA_GetPtrCount(hdpa)-1 ; i >= 0 ; i--)
    {
        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpa, i);

        poi->nOrder = i;
    }
}

BOOL OrderList_Append(HDPA hdpa, LPITEMIDLIST pidl, int nOrder)
{
    PORDERITEM poi = OrderItem_Create(pidl, nOrder);
    if (poi)
    {
        if (-1 != DPA_AppendPtr(hdpa, poi))
            return TRUE;

        OrderItem_Free(poi, FALSE); //don't free pidl because caller will do it
    }
    return FALSE;
}

// This differes from DPA_Clone in that it allocates new items!
HDPA OrderList_Clone(HDPA hdpa)
{
    HDPA hdpaNew = NULL;

    if (EVAL(hdpa))
    {
        hdpaNew = DPA_Create(DPA_GetPtrCount(hdpa));
    
        if (hdpaNew)
        {
            int i;
    
            for (i = 0 ; i < DPA_GetPtrCount(hdpa) ; i++)
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(hdpa, i);
                LPITEMIDLIST pidl = ILClone(poi->pidl);
                if (pidl)
                {
                    if (!OrderList_Append(hdpaNew, pidl, poi->nOrder))
                    {
                        ILFree(pidl);
                    }
                }
            }
        }
    }

    return hdpaNew;
}

// Does not clone the pidl but will free it.
// Does not addref the psf nor release it.
PORDERITEM OrderItem_Create(LPITEMIDLIST pidl, int nOrder)
{
    PORDERITEM2 poi = (PORDERITEM2)LocalAlloc(LPTR, SIZEOF(ORDERITEM2));

    if (poi)
    {
        poi->oi.pidl = pidl;
        poi->oi.nOrder = nOrder;
        return &poi->oi;
    }

    return NULL;
}

void OrderItem_Free(PORDERITEM poi, BOOL fKillPidls /* = TRUE */)
{
    if (fKillPidls)
        ILFree(poi->pidl);
    OrderItem_FreeIconInfo(poi);
    LocalFree(poi);
}

int OrderItem_FreeItem(LPVOID p, LPVOID pData)
{
    PORDERITEM poi = (PORDERITEM)p;

    OrderItem_Free(poi, (BOOL)(INT_PTR)pData);

    return 1;
}

void OrderList_Destroy(HDPA* phdpa, BOOL fKillPidls /* = fTrue */)
{
    if (*phdpa) {
        DPA_DestroyCallback(*phdpa, OrderItem_FreeItem, (LPVOID) (INT_PTR)fKillPidls);
        *phdpa = NULL;
    }
}

//
//  Return values:
//
//  S_OK    - icon obtained successfully
//  S_FALSE - icon not obtained, don't waste time trying
//  E_FAIL  - no cached icon, need to do more work
//
HRESULT OrderItem_GetSystemImageListIndexFromCache(PORDERITEM poi,
                                        IShellFolder *psf, int *piOut)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    IShellFolder *psfT;
    LPCITEMIDLIST pidlItem;
    HRESULT hr;

    // Do we have a cached icon location?
    if (poi2->pwszIcon)
    {
        *piOut = 0;
        // Validate Path existance.
        if (PathFileExistsW(poi2->pwszIcon))
        {
            *piOut = Shell_GetCachedImageIndex(poi2->pwszIcon, poi2->iIconIndex, GIL_PERINSTANCE);
        }

        return (*piOut > 0)? S_OK : E_FAIL;
    }

    // Do we have a cached pidlTarget?
    if (poi2->pidlTarget)
    {
        hr = SHBindToIDListParent(poi2->pidlTarget, IID_IShellFolder, (void**)&psfT, &pidlItem);
        if (SUCCEEDED(hr))
        {
            // Make sure the pidl exsists before binding. because the bind does succeed if it does not exist.
            DWORD dwAttrib = SFGAO_VALIDATE;
            hr = psfT->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlItem, &dwAttrib);
            if (SUCCEEDED(hr))
            {
                *piOut = SHMapPIDLToSystemImageListIndex(psfT, pidlItem, NULL);
            }
            psfT->Release();
            return hr;
        }

        // Bind failed - shortcut target was deleted
        // Keep the cache valid because we don't want to whack the disk
        // all the time only to discover it's busted.
        return E_FAIL;
    }

    return E_FAIL;
}

DWORD OrderItem_GetFlags(PORDERITEM poi)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    return poi2->dwFlags;
}

void OrderItem_SetFlags(PORDERITEM poi, DWORD dwFlags)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    poi2->dwFlags = dwFlags;
}


int OrderItem_GetSystemImageListIndex(PORDERITEM poi, IShellFolder *psf, BOOL fUseCache)
{
    PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
    HRESULT hr;
    int iBitmap;
    DWORD dwAttr;

    if (fUseCache)
    {
        hr = OrderItem_GetSystemImageListIndexFromCache(poi, psf, &iBitmap);
        if (SUCCEEDED(hr))
        {
            return iBitmap;
        }
        else
        {
            goto Fallback;
        }
    }
    else
    {
        //
        // Free any pointers we cached previously
        //
        if (poi2->pidlTarget)
        {
            ILFree(poi2->pidlTarget);
            poi2->pidlTarget = NULL;
        }

        Str_SetPtr(&poi2->pwszIcon, NULL);
    }

    //
    //  Go find the icon.
    //
    ASSERT(poi2->pidlTarget == NULL);
    ASSERT(poi2->pwszIcon == NULL);

    //
    //  Is this item shortcutlike at all?
    //
    dwAttr = SFGAO_LINK;
    hr = psf->GetAttributesOf(1, (LPCITEMIDLIST*)&poi->pidl, &dwAttr);
    if (FAILED(hr) || !(dwAttr & SFGAO_LINK))
        goto Fallback;                  // not a shortcut; use the fallback

    //
    // Must go for ANSI version first because client might not support
    // UNICODE.
    //
    // FEATURE - should QI for IExtractIcon to see if we get GIL_DONTCACHE
    // back.

    IShellLinkA *pslA;
    hr = psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&poi->pidl,
                            IID_IShellLinkA, 0, (LPVOID *)&pslA);

    if (FAILED(hr))
        goto Fallback;

    //
    //  If there's a UNICODE version, that's even better.
    //
    IShellLinkW *pslW;
    WCHAR wszIconPath[MAX_PATH];

    hr = pslA->QueryInterface(IID_IShellLinkW, (LPVOID *)&pslW);
    if (SUCCEEDED(hr))
    {
        hr = pslW->GetIconLocation(wszIconPath, ARRAYSIZE(wszIconPath), &poi2->iIconIndex);
        pslW->Release();
    }
    else
    {
        // Only IShellLinkA supported.  Thunk to UNICODE manually.
        CHAR szIconPath[ARRAYSIZE(wszIconPath)];
        hr = pslA->GetIconLocation(szIconPath, ARRAYSIZE(szIconPath), &poi2->iIconIndex);
        if (SUCCEEDED(hr))
            SHAnsiToUnicode(szIconPath, wszIconPath, ARRAYSIZE(wszIconPath));
    }

    // If we have a custom icon path, then save that
    if (SUCCEEDED(hr) && wszIconPath[0])
    {
        Str_SetPtr(&poi2->pwszIcon, wszIconPath);
    }
    else
    {
        // No icon path, get the target instead
        pslA->GetIDList(&poi2->pidlTarget);

        if (IsURLChild(poi2->pidlTarget, TRUE))
        {
            // If this is a url, we want to go to the "Fallback" case. The reason for this
            // is that the fallback case will go through 
            // where we will end up with the generic icon for .url files
            ILFree(poi2->pidlTarget);
            poi2->pidlTarget = NULL;

            pslA->Release();
            goto Fallback;
        }
    }

    pslA->Release();

    //
    //  Aw-right, the cache is all loaded up.  Let's try that again.
    //
    hr = OrderItem_GetSystemImageListIndexFromCache(poi, psf, &iBitmap);
    if (hr == S_OK)
    {
        return iBitmap;
    }

Fallback:
    return SHMapPIDLToSystemImageListIndex(psf, poi->pidl, NULL);
}


// Header for file menu streams
//
// The file menu stream consists of an IOSTREAMHEADER followed by
// a DPA_SaveStream of the order DPA.  Each item in the DPA consists
// of an OISTREAMITEM.
//
// To keep roaming profiles working between NT4 (IE4) and NT5 (IE5),
// the dwVersion used by NT5 must be the same as that used by NT4.
// I.e., it must be 2.

typedef struct tagOISTREAMHEADER
{
    DWORD cbSize;           // Size of header
    DWORD dwVersion;        // Version of header
} OISTREAMHEADER;

#define OISTREAMHEADER_VERSION  2

//
//  Each item in a persisted order DPA consists of an OISTREAMITEM
//  followed by additional goo.  All pidls stored include the
//  terminating (USHORT)0.
//
//  IE4:
//      OISTREAMITEM
//      pidl                    - the item itself
//
//  IE5 - shortcut has custom icon
//      OISTREAMITEM
//      pidl                    - the item itself (last-modify time implied)
//      <optional padding>      - for WCHAR alignment
//      dwFlags                 - User defined Flags
//      dwStringLen             - Length of the icon path 
//      UNICODEZ iconpath       - icon path
//      iIconIndex              - icon index
//
//  IE5 - shortcut takes its icon from another pidl
//      OISTREAMITEM
//      pidl                    - the item itself (last-modify time implied)
//      <optional padding>      - for WCHAR alignment
//      dwFlags                 - User defined Flags
//      (DWORD)0                - null string indicates "no custom icon"
//      pidlTarget              - use the icon for this pidl
//

typedef struct tagOISTREAMITEM
{
    DWORD cbSize;           // Size including trailing goo
    int   nOrder;           // User-specified order

    // variable-sized trailing goo comes here.
    //
    // See above for description of trailing goo.

} OISTREAMITEM;

#define CB_OISTREAMITEM     (sizeof(OISTREAMITEM))

//
//  Save a component of the orderitem to the stream.  If an error has
//  already occurred on the stream, *phrRc contains the old error code,
//  and we write nothing.
//
//  If pstm == NULL, then we are not actually writing anything.  We are
//  merely doing a dry run.
//
//  Otherwise, *phrRc accumulates the number of bytes actually written,
//  or receives an error code on failure.
//

void
OrderItem_SaveSubitemToStream(IStream *pstm, LPCVOID pvData, ULONG cb, HRESULT* phrRc)
{
    HRESULT hres;

    if (SUCCEEDED(*phrRc))
    {
        if (pstm)
        {
            hres = IStream_Write(pstm, (LPVOID)pvData, cb);
            if (SUCCEEDED(hres))
            {
                *phrRc += cb;           // successful write - accumulate
            }
            else
            {
                *phrRc = hres;          // error - return error code
            }
        }
        else
        {
            *phrRc += cb;               // no output stream - accumulate
        }
    }
}

//
//  This worker function (1) computes the numer of bytes we will actually
//  write out, and (2) actually writes it if pstm != NULL.
//
//  Return value is the number of bytes written (or would have been
//  written), or a COM error code on failure.
//

const BYTE c_Zeros[2] = { 0 };    // a bunch of zeros

HRESULT
OrderItem_SaveToStreamWorker(PORDERITEM2 poi2, OISTREAMITEM *posi,
                             IStream *pstm, IShellFolder2 *psf2)
{
    HRESULT hrRc = 0;           // no bytes, no error

    ASSERT(poi2->oi.pidl);

    //
    //  First comes the header.
    //
    OrderItem_SaveSubitemToStream(pstm, posi, CB_OISTREAMITEM, &hrRc);

    //
    //  Then the pidl.
    //

    // We're assuming this is an immediate child pidl.  If it's not,
    // the pidl is being truncated!
    ASSERT(0 == _ILNext(poi2->oi.pidl)->mkid.cb);

    OrderItem_SaveSubitemToStream(pstm, poi2->oi.pidl,
                                  poi2->oi.pidl->mkid.cb + sizeof(USHORT),
                                  &hrRc);
    // Insert padding to get back to WCHAR alignment.
    if (hrRc % sizeof(WCHAR)) 
    {
        OrderItem_SaveSubitemToStream(pstm, &c_Zeros, 1, &hrRc);
    }

    OrderItem_SaveSubitemToStream(pstm, &poi2->dwFlags, sizeof(DWORD), &hrRc);

    //
    //  If we haven't barfed yet and the IShellFolder supports identity
    //  and there is icon information, then save it.
    //
    if (SUCCEEDED(hrRc) && psf2 && (poi2->pwszIcon || poi2->pidlTarget))
    {
        // Optional icon is present. 

        if (poi2->pwszIcon)
        {
            // UNICODEZ path
            DWORD cbString = (lstrlenW(poi2->pwszIcon) + 1) * sizeof(WCHAR);

            // Save the String len
            OrderItem_SaveSubitemToStream(pstm, &cbString,
                      sizeof(DWORD) , &hrRc);

            OrderItem_SaveSubitemToStream(pstm, poi2->pwszIcon,
                      (lstrlenW(poi2->pwszIcon) + 1) * sizeof(WCHAR), &hrRc);

            // icon index
            OrderItem_SaveSubitemToStream(pstm, &poi2->iIconIndex,
                      sizeof(poi2->iIconIndex), &hrRc);
        }
        else
        {
            DWORD cbString = 0;
            OrderItem_SaveSubitemToStream(pstm, &cbString, sizeof(DWORD), &hrRc);

            // pidlTarget
            OrderItem_SaveSubitemToStream(pstm, poi2->pidlTarget,
                      ILGetSize(poi2->pidlTarget), &hrRc);
        }
    }
    return hrRc;
}

HRESULT 
CALLBACK 
OrderItem_SaveToStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID pvData)
{
    PORDERITEM2 poi2 = (PORDERITEM2)pinfo->pvItem;
    HRESULT hres = S_FALSE;
    IShellFolder2 *psf2 = (IShellFolder2 *)pvData;

    if (poi2->oi.pidl)
    {
        OISTREAMITEM osi;

        // First a dry run to compute the size of this item.
        hres = OrderItem_SaveToStreamWorker(poi2, NULL, NULL, psf2);

        // Nothing actually got written, so this should always succeed.
        ASSERT(SUCCEEDED(hres));

        osi.cbSize = hres;
        osi.nOrder = poi2->oi.nOrder;

        // Now write it out for real
        hres = OrderItem_SaveToStreamWorker(poi2, &osi, pstm, psf2);

        // On success, we must return exactly S_OK or DPA will blow us off
        if (SUCCEEDED(hres))
            hres = S_OK;
    }

    return hres;
}   

//
//  Check if a pidl we read out of a stream is a simple child pidl.
//  The pidl must be exactly cb bytes in length.
//  The pointer is known to be valid;
//  we just want to check that the contents are good, too.
//
BOOL
IsValidPersistedChildPidl(LPCITEMIDLIST pidl, UINT cb)
{
    // Must have at least room for one byte of pidl plus the terminating
    // zero.
    if (cb < 1 + sizeof(USHORT))
        return FALSE;

    // Make sure size is at least what it's supposed to be.
    if (pidl->mkid.cb + sizeof(USHORT) > cb)
        return FALSE;

    // Make sure there's a zero right after it.
    pidl = _ILNext(pidl);
    return pidl->mkid.cb == 0;
}

//
//  Just like ILGetSize, but returns (UINT)-1 if the pidl is corrupt.
//  We use (UINT)-1 as the return value because it will be bigger than
//  the buffer size we eventually compare it against.
UINT SafeILGetSize(LPCITEMIDLIST pidl)
{
    __try 
    {
        return ILGetSize(pidl);
    } 
    _except (EXCEPTION_EXECUTE_HANDLER) 
    {
    }
    return (UINT)-1;
}

HRESULT
CALLBACK 
OrderItem_LoadFromStream(DPASTREAMINFO * pinfo, IStream * pstm, LPVOID /*pvData*/)
{
    HRESULT hres;
    OISTREAMITEM osi;

    hres = IStream_Read(pstm, &osi, CB_OISTREAMITEM);
    if (SUCCEEDED(hres))
    {
        ASSERT(CB_OISTREAMITEM < osi.cbSize);
        if (CB_OISTREAMITEM < osi.cbSize)
        {
            UINT cb = osi.cbSize - CB_OISTREAMITEM;
            LPITEMIDLIST pidl = IEILCreate(cb);
            if ( !pidl )
                hres = E_OUTOFMEMORY;
            else
            {
                hres = IStream_Read(pstm, pidl, cb);
                if (SUCCEEDED(hres) && IsValidPersistedChildPidl(pidl, cb))
                {
                    PORDERITEM poi = OrderItem_Create(pidl, osi.nOrder);

                    if (poi)
                    {
                        PORDERITEM2 poi2 = CONTAINING_RECORD(poi, ORDERITEM2, oi);
                        pinfo->pvItem = poi;
                        // cbPos = offset to trailing gunk after pidl
                        UINT cbPos = pidl->mkid.cb + sizeof(USHORT);
                        cbPos = ROUNDUP(cbPos, sizeof(WCHAR));

                        // Do we have a DWORD hanging off the end of the pidl? This should be the flags.
                        if (cb >= cbPos + sizeof(DWORD))
                        {
                            poi2->dwFlags = *(UNALIGNED DWORD*)((LPBYTE)pidl + cbPos);
                        }

                        // Make sure there's at least a WCHAR to test against.
                        if (cb >= cbPos + sizeof(WCHAR) + 2 * sizeof(DWORD))
                        {
                            DWORD cbString = *(UNALIGNED DWORD*)((LPBYTE)pidl + cbPos + sizeof(DWORD));
                            LPWSTR pwszIcon = (LPWSTR)((LPBYTE)pidl + cbPos + 2 * sizeof(DWORD));

                            // Do we have a string lenght?
                            if (pwszIcon && cbString != 0)
                            {
                                // Yes, then this is a string not a pidl. We want to make sure this is a
                                // fully qualified path.
                                if (IS_VALID_STRING_PTRW(pwszIcon, cbString) &&
                                    !PathIsRelative(pwszIcon))
                                {
                                    poi2->pwszIcon = StrDup(pwszIcon);
                                    pwszIcon += lstrlenW(pwszIcon) + 1;
                                    poi2->iIconIndex = *(UNALIGNED int *)pwszIcon;
                                }
                            }
                            else
                            {
                                // A string length of zero is 
                                LPITEMIDLIST pidlTarget = (LPITEMIDLIST)(pwszIcon);
                                // We want to write
                                // cbPos + sizeof(WCHAR) + SafeILGetSize(pidlTarget) <= cb
                                // but SafeILGetSize returns (UINT)-1 on error, so we need
                                // to do some algebra to avoid overflows
                                if (SafeILGetSize(pidlTarget) <= cb - cbPos - 2 * sizeof(DWORD))
                                {
                                    poi2->pidlTarget = ILClone(pidlTarget);
                                }
                            }
                        }

                        hres = E_OUTOFMEMORY;

                        // pidl Contains extranious information. Take the hit of stripping it so that
                        // our working set doesn't bloat.
                        LPITEMIDLIST pidlNew = ILClone(poi2->oi.pidl);
                        if (pidlNew)
                        {
                            ILFree(poi2->oi.pidl);
                            poi2->oi.pidl = pidlNew;
                            hres = S_OK;
                        }
                    }
                    else
                        hres = E_OUTOFMEMORY;
                }
                else
                    hres = E_FAIL;

                // Cleanup
                if (FAILED(hres))
                    ILFree(pidl);
            }
        }
        else
            hres = E_FAIL;

    }

    ASSERT((S_OK == hres && pinfo->pvItem) || FAILED(hres));
    return hres;
}    

HRESULT OrderList_LoadFromStream(IStream* pstm, HDPA * phdpa, IShellFolder * psfParent)
{
    HDPA hdpa = NULL;
    OISTREAMHEADER oish;

    ASSERT(phdpa);
    ASSERT(pstm);

    // Read the header for more info
    if (SUCCEEDED(IStream_Read(pstm, &oish, sizeof(oish))) &&
        sizeof(oish) == oish.cbSize)
    {
        // Load the stream.  (Should be ordered by name.)
        DPA_LoadStream(&hdpa, OrderItem_LoadFromStream, pstm, psfParent);
        
        // if this is the wrong version, throw away the pidls.
        // we go through the load anyways to make suret he read pointer is set right
        if (OISTREAMHEADER_VERSION != oish.dwVersion)
            OrderList_Destroy(&hdpa, TRUE);
        
    }

    *phdpa = hdpa;

    return (NULL != hdpa) ? S_OK : E_FAIL;
}

HRESULT OrderList_SaveToStream(IStream* pstm, HDPA hdpaSave, IShellFolder *psf)
{
    HRESULT hres = E_OUTOFMEMORY;
    OISTREAMHEADER oish;
    HDPA hdpa;

    // Clone the array and sort by name for the purpose of persisting it
    hdpa = DPA_Clone(hdpaSave, NULL);
    if (hdpa)
    {
        ORDERINFO   oinfo = {0};
#ifdef DEBUG
        // use QI to help track down leaks
        if (psf)
            EVAL(SUCCEEDED(psf->QueryInterface(IID_IShellFolder, (LPVOID *)&oinfo.psf)));
#else
        oinfo.psf = psf;
        if (psf)
            oinfo.psf->AddRef();
#endif
        oinfo.dwSortBy = OI_SORTBYNAME;
        DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);

        // Save the header
        oish.cbSize = sizeof(oish);
        oish.dwVersion = OISTREAMHEADER_VERSION;

        hres = IStream_Write(pstm, &oish, sizeof(oish));
        if (SUCCEEDED(hres))
        {
            if (psf)
                oinfo.psf->QueryInterface(IID_IShellFolder2, (LPVOID *)&oinfo.psf2);
            hres = DPA_SaveStream(hdpa, OrderItem_SaveToStream, pstm, oinfo.psf2);
            ATOMICRELEASE(oinfo.psf2);
        }
        ATOMICRELEASE(oinfo.psf);
        DPA_Destroy(hdpa);
    }

    return hres;
}    

/////////////
//
// COrderList impl for export to channel installer
//

class COrderList  : public IPersistFolder, 
                    public IOrderList2
{
public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // IPersistFolder
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IOrderList
    virtual STDMETHODIMP GetOrderList(HDPA * phdpa);
    virtual STDMETHODIMP SetOrderList(HDPA hdpa, IShellFolder *psf);
    virtual STDMETHODIMP FreeOrderList(HDPA hdpa);

    virtual STDMETHODIMP SortOrderList(HDPA hdpa, DWORD dw);

    virtual STDMETHODIMP AllocOrderItem(PORDERITEM * ppoi, LPCITEMIDLIST pidl);
    virtual STDMETHODIMP FreeOrderItem(PORDERITEM poi);

    // IOrderList 2
    virtual STDMETHODIMP LoadFromStream(IStream* pstm, HDPA* hdpa, IShellFolder* psf);
    virtual STDMETHODIMP SaveToStream(IStream* pstm, HDPA hdpa);

protected:
    COrderList(IUnknown* punkOuter, LPCOBJECTINFO poi);
    friend IUnknown * COrderList_Create();

    COrderList();
    ~COrderList();

    int _cRef;
    IShellFolder *_psf;
    LPITEMIDLIST  _pidl;
    LPITEMIDLIST  _pidlFavorites;
};

COrderList::COrderList()
{
    _cRef = 1;
    DllAddRef();
}

COrderList::~COrderList()
{
    ILFree(_pidl);
    ILFree(_pidlFavorites);
    ATOMICRELEASE(_psf);
    DllRelease();
}

IUnknown * COrderList_Create()
{
    COrderList * pcol = new COrderList;
    if (pcol)
    {
        return SAFECAST(pcol, IPersistFolder*);
    }
    return NULL;
}

STDAPI COrderList_CreateInstance(IUnknown * pUnkOuter, IUnknown ** punk, LPCOBJECTINFO poi)
{
    *punk = COrderList_Create();

    return *punk ? S_OK : E_OUTOFMEMORY;
}

ULONG COrderList::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG COrderList::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT COrderList::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(COrderList, IPersistFolder),
        QITABENT(COrderList, IOrderList),
        QITABENTMULTI(COrderList, IOrderList2, IOrderList),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT COrderList::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_OrderListExport;

    return S_OK;
}


// This is the directory setup wants to re-order
HRESULT COrderList::Initialize(LPCITEMIDLIST pidl)
{
    if (!_pidlFavorites)
    {
        SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &_pidlFavorites);
        if (!_pidlFavorites)
            return E_OUTOFMEMORY;
    }

    if (!pidl || !ILIsParent(_pidlFavorites, pidl, FALSE))
        return E_INVALIDARG;

    // Initialize can be called multiple times
    ATOMICRELEASE(_psf);

    Pidl_Set(&_pidl, pidl);

    if (_pidl)
        IEBindToObject(_pidl, &_psf);

    if (!_psf)
        return E_OUTOFMEMORY;

    return S_OK;
}

HRESULT COrderList_GetOrderList(HDPA * phdpa, LPCITEMIDLIST pidl, IShellFolder * psf)
{
    IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, pidl, REG_SUBKEY_FAVORITESA, STGM_READ);
    if (pstm)
    {
        HRESULT hres = OrderList_LoadFromStream(pstm, phdpa, psf);
        pstm->Release();
        return hres;
    }
    *phdpa = NULL;
    return E_OUTOFMEMORY;
}

HRESULT COrderList::GetOrderList(HDPA * phdpa)
{
    HRESULT hres = E_FAIL;

    *phdpa = NULL;

    if (_psf)
        hres = COrderList_GetOrderList(phdpa, _pidl, _psf);

    return hres;
}

HRESULT COrderList_SetOrderList(HDPA hdpa, LPCITEMIDLIST pidl, IShellFolder *psf)
{
    IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, pidl, REG_SUBKEY_FAVORITESA, STGM_WRITE);
    if (EVAL(pstm))
    {
        HRESULT hres = OrderList_SaveToStream(pstm, hdpa, psf);
        pstm->Release();
        return hres;
    }
    return E_OUTOFMEMORY;
}

HRESULT COrderList::SetOrderList(HDPA hdpa, IShellFolder *psf)
{
    if (!_psf)
        return E_FAIL;

    return COrderList_SetOrderList(hdpa, _pidl, psf);
}

HRESULT COrderList::FreeOrderList(HDPA hdpa)
{
    OrderList_Destroy(&hdpa);
    return S_OK;
}

HRESULT COrderList::SortOrderList(HDPA hdpa, DWORD dw)
{
    if (OI_SORTBYNAME != dw && OI_SORTBYORDINAL != dw)
        return E_INVALIDARG;

    if (!_psf)
        return E_FAIL;

    ORDERINFO oinfo;
    oinfo.dwSortBy = dw;
    oinfo.psf = _psf;
#ifdef DEBUG
    oinfo.psf2 = (IShellFolder2 *)INVALID_HANDLE_VALUE; // force fault if someone uses it
#endif

    DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);

    return S_OK;
}

HRESULT COrderList::AllocOrderItem(PORDERITEM * ppoi, LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlClone = ILClone(pidl);

    *ppoi = NULL;

    if (pidlClone)
    {
        *ppoi = OrderItem_Create(pidlClone, -1);
        if (*ppoi)
            return S_OK;

        ILFree(pidlClone);
    }

    return E_OUTOFMEMORY;
}



HRESULT COrderList::FreeOrderItem(PORDERITEM poi)
{
    OrderItem_Free(poi);

    return S_OK;
}

// IOrderList2::LoadFromStream
STDMETHODIMP COrderList::LoadFromStream(IStream* pstm, HDPA* phdpa, IShellFolder* psf)
{
    ASSERT(_psf == NULL);
    _psf = psf;
    if (_psf)
        _psf->AddRef();
    return OrderList_LoadFromStream(pstm, phdpa, _psf);
}

// IOrderList2::SaveToStream
STDMETHODIMP COrderList::SaveToStream(IStream* pstm, HDPA hdpa)
{
    return OrderList_SaveToStream(pstm, hdpa, _psf);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\droptgt.cpp ===
#include "droptgt.h"

#define TF_DRAGDROP TF_BAND


#define MAX_DROPTARGETS 3

class CDropTargetWrap : public IDropTarget
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    CDropTargetWrap(IDropTarget** ppdtg, HWND hwnd);
protected:
    ~CDropTargetWrap();

private:
    int             _cRef;

    int             _count;
    IDropTarget*    _rgpdt[MAX_DROPTARGETS];
    DWORD           _rgdwEffect[MAX_DROPTARGETS];
    HWND            _hwnd;
};

CDropTargetWrap::CDropTargetWrap(IDropTarget** ppdt, HWND hwnd)
    : _hwnd(hwnd)
{
    _cRef = 1;

    for (int i = 0; i < MAX_DROPTARGETS; i++, ppdt++) {
        if (*ppdt) {
            _rgpdt[_count] = *ppdt;
            _rgpdt[_count]->AddRef();
            _count++;
        }
    }
}

CDropTargetWrap::~CDropTargetWrap()
{
    for (int i = 0 ; i < _count ; i++)
    {
        _rgpdt[i]->Release();
    }
}

IDropTarget* DropTargetWrap_CreateInstance(IDropTarget* pdtPrimary, IDropTarget* pdtSecondary, HWND hwnd, IDropTarget* pdt3)
{
    // no point in wrapping nothing...
    if (pdtPrimary || pdtSecondary || pdt3)
    {
        IDropTarget* pdt[MAX_DROPTARGETS] = { pdtPrimary, pdtSecondary, pdt3 };
        
        CDropTargetWrap* pdtw = new CDropTargetWrap(pdt, hwnd);
        if (pdtw)
        {
            return SAFECAST(pdtw, IDropTarget*);
        }
    }
    return NULL;
}

HRESULT CDropTargetWrap::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDropTargetWrap, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDropTargetWrap::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CDropTargetWrap::Release(void)
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

         The *pdwEffect that is returned is the first valid value
         of all the drop targets' returned effects.

*/
HRESULT CDropTargetWrap::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;

    for (int i = 0 ; i < _count ; i++)
    {
        _rgdwEffect[i] = *pdwEffect;

        if (SUCCEEDED(_rgpdt[i]->DragEnter(pdtobj, grfKeyState, ptl, &_rgdwEffect[i])))
        {
            if (dwEffectOut == DROPEFFECT_NONE)
            {
                dwEffectOut = _rgdwEffect[i];
            }
        }
        else
        {
            _rgdwEffect[i] = DROPEFFECT_NONE;
        }
    }
    *pdwEffect = dwEffectOut;
    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragOver method

*/
HRESULT CDropTargetWrap::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;
        
    for (int i = 0 ; i < _count ; i++)
    {
        _rgdwEffect[i] = *pdwEffect;

        if (SUCCEEDED(_rgpdt[i]->DragOver(grfKeyState, ptl, &_rgdwEffect[i])))
        {
            if (dwEffectOut == DROPEFFECT_NONE)
                dwEffectOut = _rgdwEffect[i];
        }
        else
        {
            _rgdwEffect[i] = DROPEFFECT_NONE;
        }
    }

    *pdwEffect = dwEffectOut;
    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragLeave method

*/
HRESULT CDropTargetWrap::DragLeave(void)
{
    for (int i = 0 ; i < _count ; i++)
    {
        _rgpdt[i]->DragLeave();
    }

    return(S_OK);
}


/*----------------------------------------------------------
Purpose: IDropTarget::Drop method

*/
HRESULT CDropTargetWrap::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwEffectOut = DROPEFFECT_NONE;
    int i;
    BOOL fDropTried = FALSE;

    for (i = 0 ; (DROPEFFECT_NONE == dwEffectOut) && i < _count ; i++)
    {
        if ((_rgdwEffect[i] && *pdwEffect) && !fDropTried)
        {
            dwEffectOut = *pdwEffect;
            _rgpdt[i]->Drop(pdtobj, grfKeyState, pt, &dwEffectOut);
            fDropTried = TRUE;
        }
        else
        {
            _rgpdt[i]->DragLeave();
        }
    }

    *pdwEffect = dwEffectOut;
    return(S_OK);
}


//=============================================================================
// CDelegateDropTarget
//
// This class implements IDropTarget given an IDelegateDropTargetCB interface.
// It handles all hit testing, caching, and scrolling for you.
//
//=============================================================================
#undef  CDropTargetWrap

CDelegateDropTarget::CDelegateDropTarget()
{
    TraceMsg(TF_SHDLIFE, "ctor CDelegateDropTarget %x", this);

}

CDelegateDropTarget::~CDelegateDropTarget()
{
    TraceMsg(TF_SHDLIFE, "dtor CDelegateDropTarget %x", this);

    ASSERT(!_pDataObj);
    ATOMICRELEASE(_pDataObj);
    ASSERT(!_pdtCur);
    ATOMICRELEASE(_pdtCur);
}

HRESULT CDelegateDropTarget::Init()
{
    HRESULT hres = GetWindowsDDT(&_hwndLock, &_hwndScroll);
    // We lock _hwndLock and do scrolling against _hwndScroll.
    // These can be different hwnds, but certain restrictions apply:
    if (_hwndLock != _hwndScroll)
    {
        BOOL fValid = IsChild(_hwndLock, _hwndScroll);
        if (!fValid)
        {
            TraceMsg(TF_DRAGDROP, "ctor CDelegateDropTarget: invalid windows %x and %x!", _hwndLock, _hwndScroll);
            _hwndLock = _hwndScroll = NULL;
        }
    }
    return hres;
}

void CDelegateDropTarget::_ReleaseCurrentDropTarget()
{
    if (_pdtCur)
    {
        _pdtCur->DragLeave();
        ATOMICRELEASE(_pdtCur);
    }
}

/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

*/
HRESULT CDelegateDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    // We can be re-entered due to ui on thread
    if (_pDataObj != NULL)       
    {
        TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragEnter called a second time!");
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragEnter with *pdwEffect=%x", *pdwEffect);

    ASSERT(!_pDataObj);
    _pDataObj = pdtobj;
    _pDataObj->AddRef();

    // cache state
    //
    // wait until first DragOver to get valid info
    //
    _fPrime = FALSE;
    _dwEffectOut = DROPEFFECT_NONE;

    // set up auto-scroll info
    //
    ASSERT(pdtobj);
    _DragEnter(_hwndLock, ptl, pdtobj);

    DAD_InitScrollData(&_asd);

    _ptLast.x = _ptLast.y = 0x7fffffff; // put bogus value to force redraw

    HitTestDDT(HTDDT_ENTER, NULL, NULL, NULL);

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragOver method

*/
HRESULT CDelegateDropTarget::DragOver(DWORD grfKeyState, POINTL ptl, LPDWORD pdwEffect)
{
    HRESULT hres = S_OK;
    DWORD_PTR itemNew;
    POINT pt;
    DWORD dwEffectScroll = 0;
    DWORD dwEffectOut = 0;
    BOOL fSameImage = FALSE;
    DWORD   dwCustDropEffect = 0;

    if (_pDataObj == NULL)
    {
        ASSERT(0);      // DragEnter should be called before.
        return E_FAIL;
    }

    // convert to window coords
    pt.x = ptl.x;
    pt.y = ptl.y;
    ScreenToClient(_hwndScroll, &pt);

    if (DAD_AutoScroll(_hwndScroll, &_asd, &pt))
        dwEffectScroll = DROPEFFECT_SCROLL;

    //
    //  If we are dragging over on a different item, get its IDropTarget
    // interface or adjust itemNew to -1.
    //
    if (SUCCEEDED(HitTestDDT(HTDDT_OVER, &pt, &itemNew, &dwCustDropEffect)) &&
        (itemNew != _itemOver || !_fPrime))
    {
        _fPrime = TRUE;

        _ReleaseCurrentDropTarget();

        _itemOver = itemNew;
        GetObjectDDT(_itemOver, IID_IDropTarget, (LPVOID*)&_pdtCur);

        if (_pdtCur)
        {
            // There's an IDropTarget for this hit, use it
            dwEffectOut = *pdwEffect;

            hres = _pdtCur->DragEnter(_pDataObj, grfKeyState, ptl, &dwEffectOut);
            if (FAILED(hres))
                dwEffectOut = DROPEFFECT_NONE;
        }
        else
        {
            // No IDropTarget, no effect
            dwEffectOut = DROPEFFECT_NONE;
        }
    }
    else
    {
        //
        // No change in the selection. We assume that *pdwEffect stays
        // the same during the same drag-loop as long as the key state doesn't change.
        //
        if ((_grfKeyState != grfKeyState) && _pdtCur)
        {
            dwEffectOut = *pdwEffect;

            hres = _pdtCur->DragOver(grfKeyState, ptl, &dwEffectOut);

            TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragOver DragOver()d id:%d dwEffect:%4x hres:%d", _itemOver, dwEffectOut, hres);
        }
        else
        {
            // Same item and same key state. Use the previous dwEffectOut.
            dwEffectOut = _dwEffectOut;
            fSameImage = TRUE;
        }
    }

    _grfKeyState = grfKeyState;    // store these for the next Drop
    _dwEffectOut = dwEffectOut;    // and DragOver

    // Is the Custdrop effect valid ?
    if (dwCustDropEffect != DROPEFFECT_NONE)    
    {
        //Yes then set the effect to Custdrop effect along with scroll effect
        *pdwEffect = dwCustDropEffect | dwEffectScroll;
    }
    else 
    {
        //No , set the effect to dwEffectOut along with scroll effect
        *pdwEffect = dwEffectOut | dwEffectScroll;
    }
        TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragOver (*pdwEffect=%x)", *pdwEffect);


    if (!(fSameImage && pt.x==_ptLast.x && pt.y==_ptLast.y))
    {
        _DragMove(_hwndLock, ptl);
        _ptLast.x = ptl.x;
        _ptLast.y = ptl.y;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragLeave method

*/
HRESULT CDelegateDropTarget::DragLeave()
{
    HitTestDDT(HTDDT_LEAVE, NULL, NULL, NULL);
    _ReleaseCurrentDropTarget();

    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::DragLeave");
    ATOMICRELEASE(_pDataObj);

    DAD_DragLeave();

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IDropTarget::Drop method

*/
HRESULT CDelegateDropTarget::Drop(IDataObject *pdtobj,
                             DWORD grfKeyState, POINTL pt, LPDWORD pdwEffect)
{
    HRESULT hres = S_OK;
    BOOL bDropHandled = FALSE;

    TraceMsg(TF_DRAGDROP, "CDelegateDropTarget::Drop (*pdwEffect=%x)", *pdwEffect);

    //
    // According to AlexGo (OLE), this is by-design. We should make it sure
    // that we use pdtobj instead of pdtobj.
    //
    //ASSERT(pdtobj == _pDataObj);
    pdtobj->AddRef();
    _pDataObj->Release();
    _pDataObj = pdtobj;

    //
    // Note that we don't use the drop position intentionally,
    // so that it matches to the last destination feedback.
    //
    if (_pdtCur)
    {
        // use this local because if _pdtCur::Drop does a UnlockWindow
        // then hits an error and needs to put up a dialog,
        // we could get re-entered
        IDropTarget *pdtCur = _pdtCur;
        _pdtCur = NULL;

        // HACK ALERT!!!!
        //
        //  If we don't call LVUtil_DragEnd here, we'll be able to leave
        // dragged icons visible when the menu is displayed. However, because
        // we are calling IDropTarget::Drop() which may create some modeless
        // dialog box or something, we can not ensure the locked state of
        // the list view -- LockWindowUpdate() can lock only one window at
        // a time. Therefore, we skip this call only if the _pdtCur
        // is a subclass of CIDLDropTarget, assuming its Drop calls
        // CDefView::DragEnd (or CIDLDropTarget_DragDropMenu) appropriately.
        //
#if 0 // later
        if (!IsIDLDropTarget(pdtCur))
#endif
        {
            //
            // This will hide the dragged image.
            //
            DAD_DragLeave();

            //
            //  We need to reset the drag image list so that the user
            // can start another drag&drop while we are in this
            // Drop() member function call.
            //
            // NOTE: we don't have to worry about the DAD_DragLeave
            // (called from during the DragLeave call at the end of
            // this function) cancelling the potential above-mentioned
            // drag&drop loop. If such a beast is going on, it should
            // complete before pdtCur->Drop returns.
            //
            DAD_SetDragImage(NULL, NULL);
        }

        if (S_FALSE != OnDropDDT(pdtCur, _pDataObj, &grfKeyState, pt, pdwEffect))
            pdtCur->Drop(_pDataObj, grfKeyState, pt, pdwEffect);
        else
            pdtCur->DragLeave(); // should be okay even if OnDrop did this already

        pdtCur->Release();
    }
    else
    {
        //
        // We come here if Drop is called without DragMove (with DragEnter).
        //
        *pdwEffect = DROPEFFECT_NONE;
    }

    //
    // Clean up everything (OLE won't call DragLeave after Drop).
    //
    DragLeave();

    return hres;
}

// ******************************************************************
// dummy drop target to only call DAD_DragEnterEx() on DragEnter();
// ******************************************************************

HRESULT CDropDummy::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDropDummy, IDropTarget),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDropDummy::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CDropDummy::Release(void)
{
    _cRef--;
    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IDropTarget::DragEnter method

         simply call DAD_DragEnterEx2() to get custom drag cursor 
         drawing.

*/
HRESULT CDropDummy::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    ASSERT(pdtobj);
    _DragEnter(_hwndLock, ptl, pdtobj);
    *pdwEffect = DROPEFFECT_NONE;
    return(S_OK);
}

HRESULT CDropDummy::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    _DragMove(_hwndLock, ptl);
    *pdwEffect = DROPEFFECT_NONE;
    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\droptgt.h ===
#ifndef _DROPTGT_H_
#define _DROPTGT_H_

// There are two drag-drop support objects:
//
//  CDropTargetWrap -       This object takes a collection of drop-target
//                          objects and wraps them as one drop-target
//                          handler.  The first drop-target wins over the
//                          the last one if there is a conflict in who
//                          will take the drop.
//
//  CDelegateDropTarget -   This class implements IDropTarget given an 
//                          IDelegateDropTargetCB interface.  It handles 
//                          all hit testing, caching, and scrolling for you.
//                          Use this class by inheriting it in your derived
//                          class; it is not intended to be instantiated alone.
//

// Event notifications for HitTestDDT
#define HTDDT_ENTER     0
#define HTDDT_OVER      1
#define HTDDT_LEAVE     2

class CDelegateDropTarget : public IDropTarget
{        
public:
    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** Other methods to be implemented by derived class ***

    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll) PURE;
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect) PURE;
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj) PURE;
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect) PURE;

    friend IDropTarget* DropTargetWrap_CreateInstance(IDropTarget* pdtPrimary, 
                                           IDropTarget* pdtSecondary,
                                           HWND hwnd, IDropTarget* pdt3 = NULL);
protected:
    CDelegateDropTarget();
    virtual ~CDelegateDropTarget();

    BOOL IsValid() { return (_hwndLock && _hwndScroll); }
    void SetCallback(IDelegateDropTargetCB* pdtcb);
    HRESULT Init(); // init lock + scroll windows
    friend IDropTarget* DelegateDropTarget_CreateInstance(IDelegateDropTargetCB* pdtcb);

private:
    void _ReleaseCurrentDropTarget();

    // the below are parameters we use to implement this IDropTarget
    HWND                    _hwndLock;
    HWND                    _hwndScroll;

    // the object we are dragging
    LPDATAOBJECT            _pDataObj;      // from DragEnter()/Drop()

    // the below indicate the current drag state
    BITBOOL                 _fPrime:1;      // TRUE iff _itemOver/_grfKeyState is valid
    DWORD_PTR               _itemOver;      // item we are visually dragging over
    IDropTarget*            _pdtCur;        // drop target for _itemOver
    DWORD                   _grfKeyState;   // cached key state
    DWORD                   _dwEffectOut;   // last *pdwEffect out
    POINT                   _ptLast;        // last dragged position

    // for scrolling
    RECT                    _rcLockWindow;  // WindowRect of hwnd for DAD_ENTER
    AUTO_SCROLL_DATA        _asd;           // for auto scrolling
    
} ;

// dummy drop target to only call DAD_DragEnterEx() on DragEnter();

class CDropDummy : public IDropTarget
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void)   
    { 
        DAD_DragLeave();  
        return(S_OK); 
    };
    virtual STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)   
    { 
        DragLeave();
        return(S_OK); 
    };

    CDropDummy(HWND hwndLock) : _hwndLock(hwndLock), _cRef(1)  { return; };
protected:
    ~CDropDummy()    { return; };
private:
    HWND _hwndLock;         // window for dummy drop target.
    int  _cRef;

};


#endif // _DROPTGT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dspsprt.h ===
#ifndef __DSPSPRT_H__
#define __DSPSPRT_H__

// get ITypeInfo uuid/lcid out of type library
STDAPI GetTypeInfoFromLibId(LCID lcid, REFGUID libid,
    USHORT wVerMajor, USHORT wVerMinor, 
    REFGUID uuid, ITypeInfo **ppITypeInfo);

//
// Helper C++ class used to share code for the IDispatch implementations
//
// Inherit from this class passing this IDispatch's IID to the ctor
// 
class CImpIDispatch
{
    public:

        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;

    protected:
        CImpIDispatch(REFGUID libid, USHORT wVerMajor, USHORT wVerMinor, REFIID riid);
        virtual ~CImpIDispatch(void);

        // For raising exceptions
        void Exception(WORD);

        // IDispatch members
        STDMETHODIMP GetTypeInfoCount(UINT *);
        STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
        STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
        STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD, DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);

    private:
        REFIID      m_riid;
        REFGUID     m_libid;
        USHORT      m_wVerMajor;
        USHORT      m_wVerMinor;

        ITypeInfo  *m_pITINeutral; // Cached Type information
};

#endif // __DSPSPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\filelist.h ===
//----------------------------------------------------------------------------
//
//----------------------------------------------------------------------------

typedef struct
{
    DWORD dwAttribs;
    LPITEMIDLIST pidl;
    PSTR pszName;
} FILELIST_ITEM;
typedef FILELIST_ITEM *PFILELIST_ITEM;

typedef BOOL (*PFN_FOLDER_ENUM_CALLBACK)(LPSHELLFOLDER psf, LPITEMIDLIST pidlFolder, LPITEMIDLIST pidlItem, LPVOID pv);
BOOL Folder_Enum(LPITEMIDLIST pidlFolder, PFN_FOLDER_ENUM_CALLBACK pfn, PVOID pv);

void FileList_Destroy(HDPA hdpa);
BOOL FileList_Create(LPITEMIDLIST pidlFolder, HDPA *phdpa, PINT pcItems);
BOOL FileList_Sort(HDPA hdpaFLI);

BOOL FileList_CreateItem(IShellFolder *psf, LPITEMIDLIST pidl, PFILELIST_ITEM *ppfli);
void FileList_DestroyItem(PFILELIST_ITEM pfli);
BOOL Sz_AllocCopy(LPCTSTR pszSrc, LPSTR *ppszDst);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\enumt.h ===
#ifndef __ENUMERATORTEMPLATES_H__
#define __ENUMERATORTEMPLATES_H__

template <class TIMPL, class TELT>
class CEnumAny : public TIMPL
{
public:
    CEnumAny() : _cRef(1), _cNext(0) {}
    virtual ~CEnumAny() {}
    
    // IUnknown methods
    // STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef()
    {
       return ++_cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef > 0)
            return _cRef;

        delete this;
        return 0;    
    }

    // IEnumXXXX methods
    STDMETHODIMP Next(ULONG celt, TELT *rgelt, ULONG *pcelt)
    {
        UINT cNum = 0;
        ZeroMemory(rgelt, sizeof(rgelt[0])*celt);
        while (cNum < celt 
        && _Next(&rgelt[cNum]))
        {
            _cNext++;
            cNum++;
        }

        if (pcelt)
           *pcelt = cNum;

        return (celt == cNum) ? S_OK: S_FALSE;
    }
        
    STDMETHODIMP Skip(ULONG celt)
        { return E_NOTIMPL; }
    STDMETHODIMP Reset()
        { return E_NOTIMPL; }
    STDMETHODIMP Clone(TIMPL **ppenum)
        { return E_NOTIMPL; }

protected:
    virtual BOOL _Next(TELT *pelt) = 0;
protected:
    LONG _cRef;
    ULONG _cNext;
};

class CEnumAssociationElements : public CEnumAny<IEnumAssociationElements, IAssociationElement *>
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv)
    {
        static const QITAB qit[] = {
            QITABENT(CEnumAssociationElements, IEnumAssociationElements),
            { 0 }
        };
        return QISearch(this, qit, riid, ppv);
    }
};

#endif // __ENUMERATORTEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\filetype.h ===
#ifndef _INC_FILETYPE_
#define _INC_FILETYPE_


// File Type Attributes key's bitmap values (HKEY_CLASSES_ROOT\filetype,Attributes)
#define FTA_Exclude             0x00000001 //  1. used to exclude types like drvfile
#define FTA_Show                0x00000002 //  2. used to show types like folder that don't have associations
#define FTA_HasExtension        0x00000004 //  3. type has assoc extension
#define FTA_NoEdit              0x00000008 //  4. no editing of file type
#define FTA_NoRemove            0x00000010 //  5. no deling of the file type
#define FTA_NoNewVerb           0x00000020 //  6. no adding of verbs
#define FTA_NoEditVerb          0x00000040 //  7. no editing of predefined verbs
#define FTA_NoRemoveVerb        0x00000080 //  8. no deling of predefined verbs
#define FTA_NoEditDesc          0x00000100 //  9. no editing of file type description
#define FTA_NoEditIcon          0x00000200 // 10. no editing of doc icon
#define FTA_NoEditDflt          0x00000400 // 11. no changing of default verb
#define FTA_NoEditVerbCmd       0x00000800 // 12. no editing of the verbs command
#define FTA_NoEditVerbExe       0x00001000 // 13. no editing of the verbs exe
#define FTA_NoDDE               0x00002000 // 14. no editing of the DDE fields
#define FTA_ExtShellOpen        0x00004000 // 15. old style type: HKCR/.ext/shell/open/command
#define FTA_NoEditMIME          0x00008000 // 16. no editing of the Content Type or Default Extension fields
#define FTA_OpenIsSafe          0x00010000 // 17. the file class's open verb may be safely invoked for downloaded files
#define FTA_AlwaysUnsafe        0x00020000 // 18. don't allow the "Never ask me" checkbox to be enabled; File Type dialog still allows user to turn this off
#define FTA_AlwaysShowExt       0x00040000 // 19. always show the extension (even if the user has "hide extensions" displayed)
#define FTA_MigratedShowExt     0x00080000 // 20. has the old AlwaysShowExt reg key been migrated into the class flags yet?
#define FTA_NoRecentDocs        0x00100000 // 21. dont add this file type to the Recent Documents folder

#define FTAV_UserDefVerb        0x00000001 // 1. identifies verb as being user defined (!predefined)


//================================================================
// typedef's
//================================================================

typedef enum mimeflags
{

    MIME_FL_CONTENT_TYPES_ADDED   = 0x0001, // The Content Type combo box drop down has been filled with MIME types.

    /* flag combinations */

    ALL_MIME_FLAGS                = MIME_FL_CONTENT_TYPES_ADDED
} MIMEFLAGS;


#endif // _INC_FILETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\findhlp.h ===
// Help id's for Find File dialog box (shell.dll)

#define NO_HELP                        ((DWORD) -1) // Disables Help for a control

#define IDH_FINDFILENAME_NAME           2200
#define IDH_FINDFILENAME_LOOKIN         2201
#define IDH_FINDFILENAME_BROWSE         2202
#define IDH_FINDFILENAME_TOPLEVEL       2203
#define IDH_FINDFILENAME_FINDNOW        2204
#define IDH_FINDFILENAME_STOP           2205
#define IDH_FINDFILENAME_NEWSEARCH      2206
#define IDH_FINDFILECRIT_OFTYPE         2207
#define IDH_FINDFILECRIT_CONTTEXT       2208
#define IDH_FINDFILECRIT_SIZEIS         2209
#define IDH_FINDFILECRIT_K              2210
#define IDH_FINDFILEDATE_ALLFILES       2211
#define IDH_FINDFILEDATE_CREATEORMOD    2212
#define IDH_FINDFILEDATE_DAYS           2213
#define IDH_FINDFILEDATE_FROM           2214
#define IDH_FINDFILEDATE_MONTHS         2215
#define IDH_FINDFILEDATE_RANGE          2216
#define IDH_FINDFILEDATE_TO             2217
#define IDH_FINDCOMP_NAME               2218
#define IDH_FINDCOMP_LOOKIN             2220
#define IDH_FINDCOMP_BROWSE             2221
#define IDH_FINDFILENAME_STATUSSCREEN   2223
#define IDH_BROWSELIST                  2224
#define IDH_DISPLAY_FOLDER              2225
#define IDH_CREATE_NEW_FOLDER           2226
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\fldset.h ===
#ifndef FLDSET_H_
#define FLDSET_H_


//
// view priority values
//
// NOTE: left gaps so that we can add more later
//
#define VIEW_PRIORITY_RESTRICTED    0x00000070  // a shell restriction is in place that forces this view to be the one we use
#define VIEW_PRIORITY_CACHEHIT      0x00000050  // we have registry info for the view, so the user has been there before
#define VIEW_PRIORITY_STALECACHEHIT 0x00000045  // we have stale registry info for the view, so we fall back to the "all folders like this" default
#define VIEW_PRIORITY_USEASDEFAULT  0x00000043  // "Use As Default" is more important than shellext, but less than a stale cache
#define VIEW_PRIORITY_SHELLEXT      0x00000040  // next we let the shell extension have its say
#define VIEW_PRIORITY_CACHEMISS     0x00000030  // if we have a cache miss, then we fall back to the "all folders like this" default
#define VIEW_PRIORITY_INHERIT       0x00000020  // then try to inherit the view from the previous window
#define VIEW_PRIORITY_SHELLEXT_ASBACKUP 0x0015  // If classic view state is enabled we want the shell to default to an inheritted view
#define VIEW_PRIORITY_DESPERATE     0x00000010  // just pick the last view that the window supports
#define VIEW_PRIORITY_NONE          0x00000000  // dont have a view yet

typedef struct CShellViews
{
    HDPA _dpaViews;
} CShellViews;

void CShellViews_Delete(CShellViews*);

typedef struct tagFolderSetData {
    FOLDERSETTINGS  _fs;
    SHELLVIEWID     _vidRestore;
    DWORD           _dwViewPriority; // one of the VIEW_PRIORITY_* from above
} FOLDERSETDATA, *LPFOLDERSETDATA;

typedef struct tagFolderSetDataBase {
    FOLDERSETDATA   _fld;
    CShellViews     _cViews;
    UINT            _iViewSet;
} FOLDERSETDATABASE, *LPFOLDERSETDATABASE;    
    

HRESULT FileCabinet_CreateViewWindow2(IShellBrowser* psb, FOLDERSETDATABASE* that, IShellView *psvNew,
    IShellView *psvOld, RECT *prcView, HWND *phWnd);
BOOL FileCabinet_GetDefaultViewID2(FOLDERSETDATABASE* that, SHELLVIEWID* pvid);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\expdsprt.h ===
#ifndef __EXPDSPRT_H__
#define __EXPDSPRT_H__

#include "cnctnpt.h"

#ifdef TF_SHDLIFE
#undef TF_SHDLIFE
#endif

#define TF_SHDLIFE       TF_CUSTOM1

//
// Helper C++ class used to share code for the IExpDispSupport...
//
// 
class CImpIExpDispSupport : public IExpDispSupport
{
    public:
        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
        virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
        virtual STDMETHODIMP_(ULONG) Release(void) PURE;

        // *** IExpDispSupport specific methods ***
        virtual STDMETHODIMP FindCIE4ConnectionPoint(REFIID riid, CIE4ConnectionPoint **ppccp);
        virtual STDMETHODIMP OnTranslateAccelerator(MSG __RPC_FAR *pMsg,DWORD grfModifiers);
        virtual STDMETHODIMP OnInvoke(DISPID dispidMember, REFIID iid, LCID lcid, WORD wFlags, DISPPARAMS FAR* pdispparams,
                            VARIANT FAR* pVarResult,EXCEPINFO FAR* pexcepinfo,UINT FAR* puArgErr);

    protected:
        virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID riid) PURE;

        CImpIExpDispSupport() { TraceMsg(TF_SHDLIFE, "ctor CImpIExpDispSupport %x", this); }
        ~CImpIExpDispSupport() { TraceMsg(TF_SHDLIFE, "dtor CImpIExpDispSupport %x", this); }
};

// CImpIExpDispSupport implements half of IConnectionPoint
// 
class CImpIConnectionPointContainer : public IConnectionPointContainer
{
    public:
        // We need access to the virtual QI -- define it PURE here
        virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj) PURE;
        virtual STDMETHODIMP_(ULONG) AddRef(void) PURE;
        virtual STDMETHODIMP_(ULONG) Release(void) PURE;

        // *** IConnectionPointContainer ***
        virtual STDMETHODIMP EnumConnectionPoints(LPENUMCONNECTIONPOINTS FAR* ppEnum) PURE;
        virtual STDMETHODIMP FindConnectionPoint(REFIID iid, LPCONNECTIONPOINT FAR* ppCP);

    protected:
        virtual CConnectionPoint* _FindCConnectionPointNoRef(BOOL fdisp, REFIID iid) PURE;

        CImpIConnectionPointContainer() { TraceMsg(TF_SHDLIFE, "ctor CImpIExpDispSupport %x", this); }
        ~CImpIConnectionPointContainer() { TraceMsg(TF_SHDLIFE, "dtor CImpIExpDispSupport %x", this); }
};

#endif // __EXPDSPRT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\dump.c ===
//
// Debug dump functions for common ADTs
//
// This file should be #included by your DLL.  It is not part of
// stocklib.lib because it requires linking to certain guid libs,
// and DLLs like COMCTL32 do not do this.  (Therefore, COMCTL32
// doesn't #include this file, but still links to stocklib.)
//
//

#include <intshcut.h>       // For error values
#include <sherror.h>
#include <strsafe.h>

#ifdef DEBUG

/*
 * macro for simplifying result to string translation, assumes result string
 * pointer pcsz
 */

#define STRING_CASE(val)               case val: pcsz = TEXT(#val); break


//
//  Debug value-to-string mapping functions
//


/*----------------------------------------------------------
Purpose: Return the string form of the clipboard format.

Returns: pointer to a static string
Cond:    --
*/
LPCTSTR 
Dbg_GetCFName(
    UINT ucf)
{
    LPCTSTR pcsz;
    static TCHAR s_szCFName[MAX_PATH];

    switch (ucf)
    {
        STRING_CASE(CF_TEXT);
        STRING_CASE(CF_BITMAP);
        STRING_CASE(CF_METAFILEPICT);
        STRING_CASE(CF_SYLK);
        STRING_CASE(CF_DIF);
        STRING_CASE(CF_TIFF);
        STRING_CASE(CF_OEMTEXT);
        STRING_CASE(CF_DIB);
        STRING_CASE(CF_PALETTE);
        STRING_CASE(CF_PENDATA);
        STRING_CASE(CF_RIFF);
        STRING_CASE(CF_WAVE);
        STRING_CASE(CF_UNICODETEXT);
        STRING_CASE(CF_ENHMETAFILE);
        STRING_CASE(CF_HDROP);
        STRING_CASE(CF_LOCALE);
        STRING_CASE(CF_MAX);
        STRING_CASE(CF_OWNERDISPLAY);
        STRING_CASE(CF_DSPTEXT);
        STRING_CASE(CF_DSPBITMAP);
        STRING_CASE(CF_DSPMETAFILEPICT);
        STRING_CASE(CF_DSPENHMETAFILE);

    default:
        if (! GetClipboardFormatName(ucf, s_szCFName, SIZECHARS(s_szCFName)))
            StringCchCopy(s_szCFName, ARRAYSIZE(s_szCFName), TEXT("UNKNOWN CLIPBOARD FORMAT"));
        pcsz = s_szCFName;
        break;
    }

    ASSERT(pcsz);

    return(pcsz);
}


LPCTSTR 
Dbg_GetHRESULTName(
    HRESULT hr)
{
    LPCTSTR pcsz;
    static TCHAR s_rgchHRESULT[] = TEXT("0x12345678");

    switch (hr)
        {
        STRING_CASE(S_OK);
        STRING_CASE(S_FALSE);

        STRING_CASE(DRAGDROP_S_CANCEL);
        STRING_CASE(DRAGDROP_S_DROP);
        STRING_CASE(DRAGDROP_S_USEDEFAULTCURSORS);

        STRING_CASE(E_UNEXPECTED);
        STRING_CASE(E_NOTIMPL);
        STRING_CASE(E_OUTOFMEMORY);
        STRING_CASE(E_INVALIDARG);
        STRING_CASE(E_NOINTERFACE);
        STRING_CASE(E_POINTER);
        STRING_CASE(E_HANDLE);
        STRING_CASE(E_ABORT);
        STRING_CASE(E_FAIL);
        STRING_CASE(E_ACCESSDENIED);

        STRING_CASE(CLASS_E_NOAGGREGATION);

        STRING_CASE(CO_E_NOTINITIALIZED);
        STRING_CASE(CO_E_ALREADYINITIALIZED);
        STRING_CASE(CO_E_INIT_ONLY_SINGLE_THREADED);

        STRING_CASE(DV_E_DVASPECT);
        STRING_CASE(DV_E_LINDEX);
        STRING_CASE(DV_E_TYMED);
        STRING_CASE(DV_E_FORMATETC);

        STRING_CASE(E_FLAGS);

        STRING_CASE(URL_E_INVALID_SYNTAX);
        STRING_CASE(URL_E_UNREGISTERED_PROTOCOL);

        STRING_CASE(IS_E_EXEC_FAILED);

        STRING_CASE(E_FILE_NOT_FOUND);
        STRING_CASE(E_PATH_NOT_FOUND);

    default:
        StringCchPrintf(s_rgchHRESULT, ARRAYSIZE(s_rgchHRESULT), TEXT("%#lx"), hr);
        pcsz = s_rgchHRESULT;
        break;
        }

    ASSERT(IS_VALID_STRING_PTR(pcsz, -1));

    return(pcsz);
}


/*----------------------------------------------------------
Purpose: Dump propvariant types

Returns: 
Cond:    --
*/
LPCTSTR 
Dbg_GetVTName(
    VARTYPE vt)
{
    LPCTSTR pcsz;
    static TCHAR s_szT[] = TEXT("0x12345678");

    switch (vt)
        {
        STRING_CASE(VT_EMPTY);
        STRING_CASE(VT_NULL);
        STRING_CASE(VT_I2);
        STRING_CASE(VT_I4);
        STRING_CASE(VT_R4);
        STRING_CASE(VT_R8);
        STRING_CASE(VT_CY);
        STRING_CASE(VT_DATE);
        STRING_CASE(VT_BSTR);
        STRING_CASE(VT_ERROR);
        STRING_CASE(VT_BOOL);
        STRING_CASE(VT_VARIANT);
        STRING_CASE(VT_UI1);
        STRING_CASE(VT_UI2);
        STRING_CASE(VT_UI4);
        STRING_CASE(VT_I8);
        STRING_CASE(VT_UI8);
        STRING_CASE(VT_LPSTR);
        STRING_CASE(VT_LPWSTR);
        STRING_CASE(VT_FILETIME);
        STRING_CASE(VT_BLOB);
        STRING_CASE(VT_STREAM);
        STRING_CASE(VT_STORAGE);
        STRING_CASE(VT_STREAMED_OBJECT);
        STRING_CASE(VT_STORED_OBJECT);
        STRING_CASE(VT_BLOB_OBJECT);
        STRING_CASE(VT_CLSID);
        STRING_CASE(VT_ILLEGAL);
        STRING_CASE(VT_CF);

    default:
        StringCchPrintf(s_szT, ARRAYSIZE(s_szT), TEXT("%#lx"), vt);
        pcsz = s_szT;
        break;
        }

    ASSERT(IS_VALID_STRING_PTR(pcsz, -1));

    return(pcsz);
}


#define STRING_RIID(val)               { &val, TEXT(#val) }

//
//  Alphabetical order, please.
//

struct 
    {
    REFIID riid;
    LPCTSTR psz;
    } const c_mpriid[] = 
{
#ifdef __IAddressList_INTERFACE_DEFINED__
        STRING_RIID(IID_IAddressList),
#endif
        STRING_RIID(IID_IAdviseSink),
#ifdef __IAddressList_INTERFACE_DEFINED__
        STRING_RIID(IID_IAddressList),
#endif
#ifdef __IAugmentedShellFolder_INTERFACE_DEFINED__
        STRING_RIID(IID_IAugmentedShellFolder),
#endif
#ifdef __IAugmentedShellFolder2_INTERFACE_DEFINED__
        STRING_RIID(IID_IAugmentedShellFolder2),
#endif
#ifdef __IAuthenticate_INTERFACE_DEFINED__
        STRING_RIID(IID_IAuthenticate),
#endif
#ifdef __IBandSiteHelper_INTERFACE_DEFINED__
        STRING_RIID(IID_IBandSiteHelper),
#endif
#ifdef __IBandProxy_INTERFACE_DEFINED__
        STRING_RIID(IID_IBandProxy),
#endif
#ifdef __IBindStatusCallback_INTERFACE_DEFINED__
        STRING_RIID(IID_IBindStatusCallback),
#endif
#ifdef __IBrowserBand_INTERFACE_DEFINED__
        STRING_RIID(IID_IBrowserBand),
#endif
#ifdef __IBrowserService_INTERFACE_DEFINED__
        STRING_RIID(IID_IBrowserService),
#endif
#ifdef __IBrowserService2_INTERFACE_DEFINED__
        STRING_RIID(IID_IBrowserService2),
#endif
        STRING_RIID(IID_IConnectionPoint),
#ifdef __IConnectionPointCB_INTERFACE_DEFINED__
        STRING_RIID(IID_IConnectionPointCB),
#endif
        STRING_RIID(IID_IConnectionPointContainer),
        STRING_RIID(IID_IContextMenu),
        STRING_RIID(IID_IContextMenu2),
#ifdef __IContextMenuCB_INTERFACE_DEFINED__
        STRING_RIID(IID_IContextMenuCB),
#endif
#ifdef __IContextMenuSire_INTERFACE_DEFINED__
        STRING_RIID(IID_IContextMenuSite),
#endif
        STRING_RIID(IID_IDataObject),
        STRING_RIID(IID_IDeskBand),
        STRING_RIID(IID_IDispatch),
#ifdef __IDocHostUIHandler_INTERFACE_DEFINED__
        STRING_RIID(IID_IDocHostUIHandler),
#endif
        STRING_RIID(IID_IDockingWindowFrame),
        STRING_RIID(IID_IDockingWindow),
        STRING_RIID(IID_IDockingWindowSite),
#ifdef __IDocNavigate_INTERFACE_DEFINED__
        STRING_RIID(IID_IDocNavigate),
#endif
        STRING_RIID(IID_IDocViewSite),
        STRING_RIID(IID_IDropTarget),
#ifdef __IDropTargetBackground_INTERFACE_DEFINED__
        STRING_RIID(IID_IDropTargetBackground),
#endif
#ifdef __IEFrameAuto_INTERFACE_DEFINED__
        STRING_RIID(IID_IEFrameAuto),
#endif        
        STRING_RIID(IID_IEnumUnknown),
        STRING_RIID(IID_IErrorInfo),
#ifdef __IExpDispSupport_INTERFACE_DEFINED__
        STRING_RIID(IID_IExpDispSupport),
#endif
#ifdef __IExpDispSupportOC_INTERFACE_DEFINED__
        STRING_RIID(IID_IExpDispSupportOC),
#endif
#ifdef __IExplorerToolbar_INTERFACE_DEFINED__
        STRING_RIID(IID_IExplorerToolbar),
#endif
        STRING_RIID(IID_IExtractIcon),
        STRING_RIID(IID_IExternalConnection),
#ifdef __FavoriteMenu_INTERFACE_DEFINED__
        STRING_RIID(IID_FavoriteMenu),
#endif
#ifdef __IHistSFPrivate_INTERFACE_DEFINED__
        STRING_RIID(IID_IHistSFPrivate),
#endif
#ifdef __IHlink_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlink),
#endif
#ifdef __IHlinkFrame_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkFrame),
#endif
#ifdef __IHlinkSite_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkSite),
#endif
#ifdef __IHlinkTarget_INTERFACE_DEFINED__
        STRING_RIID(IID_IHlinkTarget),
#endif
#ifdef __IHttpNegotiate_INTERFACE_DEFINED__
        STRING_RIID(IID_IHttpNegotiate),
#endif
#ifdef __IHttpSecurity_INTERFACE_DEFINED__
        STRING_RIID(IID_IHttpSecurity),
#endif
        STRING_RIID(IID_IInputObject),
        STRING_RIID(IID_IInputObjectSite),
#ifdef __IIsWebBrowserSB_INTERFACE_DEFINED__
        STRING_RIID(IID_IIsWebBrowserSB),
#endif
        STRING_RIID(IID_IMenuBand),
#ifdef __IMRU_INTERFACE_DEFINED__
        STRING_RIID(IID_IMRU),
#endif
#ifdef __INavigationStack_INTERFACE_DEFINED__
        STRING_RIID(IID_INavigationStack),
#endif
#ifdef __INavigationStackItem_INTERFACE_DEFINED__
        STRING_RIID(IID_INavigationStackItem),
#endif
        STRING_RIID(IID_INewShortcutHook),
#ifdef __IObjectCache_INTERFACE_DEFINED__
        STRING_RIID(IID_IObjectCache),
#endif
#ifdef __IObjectSafety_INTERFACE_DEFINED__
        STRING_RIID(IID_IObjectSafety),
#endif
        STRING_RIID(IID_IOleClientSite),
        STRING_RIID(IID_IOleCommandTarget),
        STRING_RIID(IID_IOleContainer),
        STRING_RIID(IID_IOleControl),
        STRING_RIID(IID_IOleControlSite),
        STRING_RIID(IID_IOleDocument),
        STRING_RIID(IID_IOleDocumentSite),
        STRING_RIID(IID_IOleDocumentView),
        STRING_RIID(IID_IOleInPlaceActiveObject),
        STRING_RIID(IID_IOleInPlaceFrame),
        STRING_RIID(IID_IOleInPlaceSite),
        STRING_RIID(IID_IOleInPlaceObject),
        STRING_RIID(IID_IOleInPlaceUIWindow),
        STRING_RIID(IID_IOleObject),
        STRING_RIID(IID_IOleWindow),
        STRING_RIID(IID_IPersist),
        STRING_RIID(IID_IPersistFolder),
#ifdef __IPersistMoniker_INTERFACE_DEFINED__
        STRING_RIID(IID_IPersistMoniker),
#endif
        STRING_RIID(IID_IPersistPropertyBag),
        STRING_RIID(IID_IPersistStorage),
        STRING_RIID(IID_IPersistStream),
        STRING_RIID(IID_IPersistStreamInit),
#ifdef __IPersistString_INTERFACE_DEFINED__
        STRING_RIID(IID_IPersistString),
#endif
        STRING_RIID(IID_IProvideClassInfo),
        STRING_RIID(IID_IPropertyNotifySink),
        STRING_RIID(IID_IPropertySetStorage),
        STRING_RIID(IID_IPropertyStorage),
#ifdef __IProxyShellFolder_INTERFACE_DEFINED__
        STRING_RIID(IID_IProxyShellFolder),
#endif
        STRING_RIID(IID_IServiceProvider),
#ifdef __ISetWinHandler_INTERFACE_DEFINED__
        STRING_RIID(IID_ISetWinHandler),
#endif
        STRING_RIID(IID_IShellBrowser),
        STRING_RIID(IID_IShellChangeNotify),
        STRING_RIID(IID_IShellDetails),
#ifdef __IShellDetails2_INTERFACE_DEFINED__
        STRING_RIID(IID_IShellDetails2),
#endif
        STRING_RIID(IID_IShellExtInit),
        STRING_RIID(IID_IShellFolder),
        STRING_RIID(IID_IShellIcon),
        STRING_RIID(IID_IShellLink),
        STRING_RIID(IID_IShellLinkDataList),
        STRING_RIID(IID_IShellMenu),
        STRING_RIID(IID_IShellMenuCallback),
        STRING_RIID(IID_IShellPropSheetExt),
#ifdef __IShellService_INTERFACE_DEFINED__
        STRING_RIID(IID_IShellService),
#endif
        STRING_RIID(IID_IShellView),
        STRING_RIID(IID_IShellView2),
#ifdef __ITargetEmbedding_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetEmbedding),
#endif
#ifdef __ITargetFrame2_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetFrame2),
#endif
#ifdef __ITargetFramePriv_INTERFACE_DEFINED__
        STRING_RIID(IID_ITargetFramePriv),
#endif
        STRING_RIID(IID_ITravelEntry),
        STRING_RIID(IID_ITravelLog),
        STRING_RIID(IID_IUniformResourceLocator),
        STRING_RIID(IID_IUnknown),
        STRING_RIID(IID_IViewObject),
        STRING_RIID(IID_IViewObject2),
        STRING_RIID(IID_IWebBrowser),
        STRING_RIID(IID_IWebBrowser2),
        STRING_RIID(IID_IWebBrowserApp),
#ifdef __IWinEventHandler_INTERFACE_DEFINED__
        STRING_RIID(IID_IWinEventHandler),
#endif
};

struct 
{
    IID iid;
    TCHAR szGuid[GUIDSTR_MAX];
} s_guid[50] = {0};

LPCTSTR
Dbg_GetREFIIDName(
    REFIID riid)
{
    int i;

    // search the known list
    for (i = 0; i < ARRAYSIZE(c_mpriid); i++)
        {
        if (IsEqualIID(riid, c_mpriid[i].riid))
            return c_mpriid[i].psz;
        }

    // get a display name for the the first few unknown requests
    for (i = 0; i < ARRAYSIZE(s_guid); i++)
        {
        if (TEXT('{') /*}*/ == s_guid[i].szGuid[0])
            {
            if (IsEqualIID(riid, &s_guid[i].iid))
                return s_guid[i].szGuid;
            }
        else
            {
            s_guid[i].iid = *riid;
            SHStringFromGUID(riid, s_guid[i].szGuid, ARRAYSIZE(s_guid[0].szGuid));
            return s_guid[i].szGuid;
            }
        }

    return TEXT("Unknown REFIID");
}

//***
// NOTE
//  must be called *after* Dbg_GetREFIIDName (since that is what creates entry)
void *
Dbg_GetREFIIDAtom(
    REFIID riid)
{
    int i;

    for (i = 0; i < ARRAYSIZE(c_mpriid); i++)
        {
        if (IsEqualIID(riid, c_mpriid[i].riid))
            return (void *) c_mpriid[i].riid;
        }

    // get a display name for the the first few unknown requests
    for (i = 0; i < ARRAYSIZE(s_guid); i++)
        {
        if (TEXT('{') /*}*/ == s_guid[i].szGuid[0])
            {
            if (IsEqualIID(riid, &s_guid[i].iid))
                return (void *) &s_guid[i].iid;
            }
        else
            {
            return NULL;
            }
        }

    return NULL;
}

#endif  // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\heapaloc.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1995.
//
//  File:       heapaloc.h
//
//  Contents:   Macros which wrap the standard memory API calls, redirecting
//              them to HeapAlloc.
//
//  Functions:  __inline HLOCAL  HeapLocalAlloc   (fuFlags, cbBytes)
//              __inline HLOCAL  HeapLocalReAlloc (hMem, cbBytes, fuFlags)
//              __inline HLOCAL  HeapLocalFree    (HLOCAL hMem)
//
//  History:    2-01-95   davepl   Created
//              12-15-97  t-saml   changed to be used only for leak tracking
//
//--------------------------------------------------------------------------

#ifndef _HEAPALOC_H
#define _HEAPALOC_H 1

#ifndef DEBUG
#define IMSAddToList(bAdd, pv, cb)
#else

// Function to add/remove from leak detection list
// In stocklib (shell\lib\debug.c)
STDAPI_(void) IMSAddToList(BOOL bAdd, void*pv, SIZE_T cb);
#ifdef _SHELLP_H_
// Function to call in allocspy.dll (GetShellMallocSpy)
typedef BOOL (__stdcall *PFNGSMS) (IShellMallocSpy **ppout);
#endif


#ifndef ASSERT
#define ASSERT Assert
#endif

#ifdef LocalAlloc
#error "HEAPALOC.H(42): LocalAlloc shouldn't be defined"
#endif

//
// These are functions normally in comctl32, but there's no good reason to call
// that dll, so handle them here.  Since Chicago may still want to use these
// shared memory routines, only "forward" them under NT.
//

#if defined(WINNT) && defined(_COMCTL32_)
#define Alloc(cb)                             HeapLocalAlloc(LMEM_ZEROINIT | LMEM_FIXED, cb)
#define ReAlloc(pb, cb)                       HeapLocalReAlloc(pb, cb, LMEM_ZEROINIT | LMEM_FIXED)
//
// Free() in comctl32 is just HeapFree(), so the return code reversing
// in HeapLocalFree is the opposite of what we want.  Reverse it
// again here for now, and consider redefining Free() as just
// HeapFree(g_hProcessHeap) if the compiler isn't smart enough
// to generate the same code already. 
// REVIEW: who checks the return value from a free?  What do you do if it fails?
//
#define Free(pb)                              (!HeapLocalFree(pb))
#define GetSize(pb)                           HeapLocalSize(pb)
#endif


#if 0

// GlobalAllocs cannot be trivially replaced since they are used for DDE, OLE,
// and GDI operations.  However, on a case-by-case version we can switch them
// over to HeapGlobalAlloc as we identify instances that don't _really_ require
// GlobalAllocs.

#define GlobalAlloc(fuFlags, cbBytes)         HeapGlobalAlloc(fuFlags, cbBytes)
#define GlobalReAlloc(hMem, cbBytes, fuFlags) HeapGlobalReAlloc(hMem, cbBytes, fuFlags)
#define GlobalSize(hMem)                      HeapGlobalSize(hMem)
#define GlobalFree(hMem)                      HeapGlobalFree(hMem)
#define GlobalCompact                         InvalidMemoryCall
#define GlobalDiscard                         InvalidMemoryCall
#define GlobalFlags                           InvalidMemoryCall
#define GlobalHandle                          InvalidMemoryCall
#define GlobalLock                            InvalidMemoryCall
#define GlobalUnlock                          InvalidMemoryCall

#endif


__inline HLOCAL HeapLocalAlloc(IN UINT fuFlags, IN SIZE_T cbBytes)
{
    void * pv;

    pv = LocalAlloc(fuFlags, cbBytes);

    IMSAddToList(TRUE, pv, cbBytes); // Add to leak tracking

    return (HLOCAL) pv;
}

__inline HLOCAL HeapLocalFree(HLOCAL hMem)
{
    IMSAddToList(FALSE, hMem, 0); // Free leak tracking

    return LocalFree(hMem);
}

__inline HLOCAL HeapLocalReAlloc(IN HGLOBAL hMem,
                                 IN SIZE_T  cbBytes,
                                 IN UINT    fuFlags)
{
    void * pv;

    // (DavePl) Why can we realloc on a null ptr?

    if (NULL == hMem)
    {
        return LocalAlloc(fuFlags, cbBytes);
    }

    pv = LocalReAlloc((void *) hMem, cbBytes, fuFlags);

    IMSAddToList(FALSE, hMem, 0);    // Take out the old
    IMSAddToList(TRUE, pv, cbBytes);  // And bring in the new

    return (HGLOBAL) pv;
}

// Redefine the standard memory APIs to thunk over to our Heap-based funcs


#define LocalAlloc(fuFlags, cbBytes)          HeapLocalAlloc(fuFlags, cbBytes)
#define LocalReAlloc(hMem, cbBytes, fuFlags)  HeapLocalReAlloc(hMem, cbBytes, fuFlags)
#define LocalFree(hMem)                       HeapLocalFree(hMem)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\hwtab.h ===
/*****************************************************************************
 *  Copyright (C) 1995-1998 Microsoft Corporation.  All Rights Reserved.
 *
 *  hwtab.h
 *
 *      Hardware tab
 *
 *****************************************************************************/

//  Hardware Tab Resources
//
//  The version of the template in the rc file is the
//  most compact form the dialog will take.
//  When inserted into a container, we will expand the dialog to
//  fill the available space.
//
//  Layout diagram.  All units are in dlu.
//
//       7 dlu                                             7 dlu
//       v                                                 v
//      +---------------------------------------------------+
//      |                                                   | <  7 dlu gap
//      | Devices:                                          | < 10 dlu tall
//      | +-----------------------------------------------+ | < 30 dlu tall
//      | | (listview contents)                           | |
//      | +-----------------------------------------------+ |
//      |                                                   | < 10 dlu gap
//      | +- Device Properties ---------------------------+ | < 12 dlu tall
//      | | Manufacturer                                  | | < 12 dlu tall
//      | | Hardware Revision                             | | < 12 dlu tall
//      | | Location                                      | | < 12 dlu tall
//      | | Device Status                                 | | < 36 dlu tall
//      | |                                               | |
//      | |^                                              | |
//      | |7 dlu                                          | |
//      | |                               4 dlu          4| |
//      | |                               v              v| |
//      | |               [ Troubleshoot ] [ Properties ] | | < 14 dlu tall
//      | |                                               | | <  7 dlu gap
//      | +-----------------------------------------------+ |
//      |                                                   | <  7 dlu gap
//      +---------------------------------------------------+
//                                         |            |
//                                         |<- 50 dlu ->|
//
//      Extra horizontal space is added to the listview and groupbox.
//      Extra vertical space is split between the listview and groupbox
//      in a ratio determined by the _dwViewMode.
//      The groupbox space is all given to the "Device Status" section.
//
//      The device property text remains pinned to the upper left corner
//      of the groupbox.
//
//      The troubleshoot and propeties buttons remain pinned to the
//      lower right corner of the groupbox.


// Relative size of TreeView in Hardware Tab
//
#define HWTAB_LARGELIST 1
#define HWTAB_MEDLIST   2
#define HWTAB_SMALLLIST 3

//
// Controls on the Hardware Tab that you might want to change the text of.
//
#define IDC_HWTAB_LVSTATIC              1411    // "Devices:"
#define IDC_HWTAB_GROUPBOX              1413    // "Device Properties"

// Functions to create your hardware tab page based on DEVCLASS guids
//
STDAPI_(HWND) DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid);
STDAPI_(HWND) DeviceCreateHardwarePageEx(HWND hwndParent, const GUID *pguid, int iNumClass, DWORD dwViewMode);

// This notification is used for listview filtering
//
// We use the non-typedef'd names of these so callers aren't required to
// have included <setupapi.h> first.
//
typedef struct NMHWTAB 
{
    NMHDR nm;               // Notify info
    PVOID hdev;		    // Device information handle (HDEVINFO)
    struct _SP_DEVINFO_DATA *pdinf; // Device information
    BOOL    fHidden;        // OnNotify true if device is to be hidden, Can be changed to hide/show individual devices
} NMHWTAB, *LPNMHWTAB;

// ListView Device Filtering Messages
//
#define HWN_FIRST		        100		        
#define HWN_FILTERITEM	        HWN_FIRST
#define HWN_SELECTIONCHANGED    (HWN_FIRST + 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\imgprop.h ===
// {56616500-C154-11CE-8553-00AA00A1F95B}
DEFINE_GUID(FMTID_FlashPix,       0x56616500L, 0xC154, 0x11CE, 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B);
#define PSGUID_FlashPix         { 0x56616500L, 0xC154, 0x11CE, 0x85, 0x53, 0x00, 0xAA, 0x00, 0xA1, 0xF9, 0x5B }

#define PID_File_source                         0x21000000 // VT_UI4: File source
#define PID_Scene_type                          0x21000001 // VT_UI4: Scene type
#define PID_Creation_path_vector                0x21000002 // VT_UI4 | VT_VECTOR: Creation path vector
#define PID_Software_Name_Manufacturer_Release  0x21000003 // VT_LPWSTR: Software Name/Manufacturer/Release
#define PID_User_defined_ID                     0x21000004 // VT_LPWSTR: User defined ID
#define PID_Sharpness_approximation             0x21000005 // VT_R4: Sharpness approximation

#define PID_Copyright_message                   0x22000000 // VT_LPWSTR: Copyright message
#define PID_Legal_broker_for_the_original_image 0x22000001 // VT_LPWSTR: Legal broker for the original image
#define PID_Legal_broker_for_the_digital_image  0x22000002 // VT_LPWSTR: Legal broker for the digital image
#define PID_Authorship                          0x22000003 // VT_LPWSTR: Authorship
#define PID_Intellectual_property_notes         0x22000004 // VT_LPWSTR: Intellectual property notes

#define PID_Test_target_in_the_image            0x23000000 // VT_UI4: Test target in the image
#define PID_Group_caption                       0x23000002 // VT_LPWSTR: Group caption
#define PID_Caption_text                        0x23000003 // VT_LPWSTR: Caption text
#define PID_People_in_the_image                 0x23000004 // VT_LPWSTR | VT_VECTOR
#define PID_Things_in_the_image                 0x23000007 // VT_LPWSTR | VT_VECTOR
#define PID_Date_of_the_original_image          0x2300000A // VT_FILETIME
#define PID_Events_in_the_image                 0x2300000B // VT_LPWSTR | VT_VECTOR
#define PID_Places_in_the_image                 0x2300000C // VT_LPWSTR | VT_VECTOR
#define PID_Content_description_notes           0x2300000F // VT_LPWSTR: Content description notes

#define PID_Camera_manufacturer_name            0x24000000 // VT_LPWSTR: Camera manufacturer name
#define PID_Camera_model_name                   0x24000001 // VT_LPWSTR: Camera model name
#define PID_Camera_serial_number                0x24000002 // VT_LPWSTR: Camera serial number

#define PID_Capture_date                        0x25000000  // VT_FILETIME: Capture date
#define PID_Exposure_time                       0x25000001  // VT_R4: Exposure time
#define PID_F_number                            0x25000002  // VT_R4: F-number
#define PID_Exposure_program                    0x25000003  // VT_UI4: Exposure program
#define PID_Brightness_value                    0x25000004  // VT_R4 | VT_VECTOR
#define PID_Exposure_bias_value                 0x25000005  // VT_R4: Exposure bias value
#define PID_Subject_distance                    0x25000006  // VT_R4 | VT_VECTOR
#define PID_Metering_mode                       0x25000007  // VT_UI4: Metering mode
#define PID_Scene_illuminant                    0x25000008  // VT_UI4: Scene illuminant
#define PID_Focal_length                        0x25000009  // VT_R4: Focal length
#define PID_Maximum_aperture_value              0x2500000A  // VT_R4: Maximum aperture value
#define PID_Flash                               0x2500000B  // VT_UI4: Flash
#define PID_Flash_energy                        0x2500000C  // VT_R4: Flash energy
#define PID_Flash_return                        0x2500000D  // VT_UI4: Flash return
#define PID_Back_light                          0x2500000E  // VT_UI4: Back light
#define PID_Subject_location                    0x2500000F  // VT_R4 | VT_VECTOR
#define PID_Exposure_index                      0x25000010  // VT_R4: Exposure index
#define PID_Special_effects_optical_filter      0x25000011  // VT_UI4 | VT_VECTOR
#define PID_Per_picture_notes                   0x25000012  // VT_LPWSTR: Per picture notes

#define PID_Sensing_method                      0x26000000 // VT_UI4: Sensing method
#define PID_Focal_plane_X_resolution            0x26000001 // VT_R4: Focal plane X resolution
#define PID_Focal_plane_Y_resolution            0x26000002 // VT_R4: Focal plane Y resolution
#define PID_Focal_plane_resolution_unit         0x26000003 // VT_UI4: Focal plane resolution unit
#define PID_Spatial_frequency_response          0x26000004 // VT_VARIANT | VT_VECTOR
#define PID_CFA_pattern                         0x26000005 // VT_VARIANT | VT_VECTOR
#define PID_Spectral_sensitivity                0x26000006 // VT_LPWSTR: Spectral sensitivity
#define PID_ISO_speed_ratings                   0x26000007 // VT_UI2 | VT_VECTOR
#define PID_OECF                                0x26000008 // VT_VARIANT | VT_VECTOR: OECF

#define PID_Film_brand                          0x27000000 // VT_LPWSTR: Film brand
#define PID_Film_category                       0x27000001 // VT_UI4: Film category
#define PID_Film_size                           0x27000002 // VT_VARIANT | VT_VECTOR: Film size
#define PID_Film_roll_number                    0x27000003 // VT_UI4: Film roll number
#define PID_Film_frame_number                   0x27000004 // VT_UI4: Film frame number

#define PID_Original_scanned_image_size         0x29000000 // VT_VARIANT | VT_VECTOR: Original scanned image size
#define PID_Original_document_size              0x29000001 // VT_VARIANT | VT_VECTOR: Original document size
#define PID_Original_medium                     0x29000002 // VT_UI4: Original medium
#define PID_Type_of_original                    0x29000003 // VT_UI4: Type of original

#define PID_Scanner_manufacturer_name           0x28000000 // VT_LPWSTR: Scanner manufacturer name
#define PID_Scanner_model_name                  0x28000001 // VT_LPWSTR: Scanner model name
#define PID_Scanner_serial_number               0x28000002 // VT_LPWSTR: Scanner serial number
#define PID_Scan_software                       0x28000003 // VT_LPWSTR: Scan software
#define PID_Scan_software_revision_date         0x28000004 // VT_DATE: Scan software revision date
#define PID_Service_bureau_organization_name    0x28000005 // VT_LPWSTR: Service bureau/organization name
#define PID_Scan_operator_ID                    0x28000006 // VT_LPWSTR: Scan operator ID
#define PID_Scan_date                           0x28000008 // VT_FILETIME: Scan date
#define PID_Last_modified_date                  0x28000009 // VT_FILETIME: Last modified date
#define PID_Scanner_pixel_size                  0x2800000A // VT_R4: Scanner pixel size


// these properties are independent of the file type, values are generated by GDI+ API calls not from embedded tags
//  FMTID_ImageSummaryInfo - Property IDs

#define PIDISI_FILETYPE                 0x00000002L  // VT_LPWSTR
#define PIDISI_CX                       0x00000003L  // VT_UI4
#define PIDISI_CY                       0x00000004L  // VT_UI4
#define PIDISI_RESOLUTIONX              0x00000005L  // VT_UI4
#define PIDISI_RESOLUTIONY              0x00000006L  // VT_UI4
#define PIDISI_BITDEPTH                 0x00000007L  // VT_UI4
#define PIDISI_COLORSPACE               0x00000008L  // VT_LPWSTR
#define PIDISI_COMPRESSION              0x00000009L  // VT_LPWSTR
#define PIDISI_TRANSPARENCY             0x0000000AL  // VT_UI4
#define PIDISI_GAMMAVALUE               0x0000000BL  // VT_UI4
#define PIDISI_FRAMECOUNT               0x0000000CL  // VT_UI4
#define PIDISI_DIMENSIONS               0x0000000DL  // VT_LPWSTR

//
// Define some tags that map to new tags in the EXIF/TIFF header for saving UNICODE properties
//
#define PropertyTagUnicodeDescription   40091
#define PropertyTagUnicodeComment       40092
#define PropertyTagUnicodeArtist        40093
#define PropertyTagUnicodeKeywords      40094
#define PropertyTagUnicodeSubject       40095
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\idhidden.h ===
#ifndef _IDHIDDEN_H_
#define _IDHIDDEN_H_

//
//  internal APIs for adding Hidden IDs to pidls
//      we use this to add data that we dont want
//      to be noticed by normal namespace handlers
//

typedef enum
{
    IDLHID_EMPTY            = 0xBEEF0000,   //  where's the BEEF?!
    IDLHID_URLFRAGMENT,                     //  Fragment IDs on URLs (#anchors)
    IDLHID_URLQUERY,                        //  Query strings on URLs (?query+info)
    IDLHID_JUNCTION,                        //  Junction point data
    IDLHID_IDFOLDEREX,                      //  IDFOLDEREX, extended data for CFSFolder
    IDLHID_DOCFINDDATA,                     //  DocFind's private attached data (not persisted)
    IDLHID_PERSONALIZED,                    //  personalized like (My Docs/Zeke's Docs)
    IDLHID_recycle2,                        //  recycle
    IDLHID_RECYCLEBINDATA,                  //  RecycleBin private data (not persisted)
    IDLHID_RECYCLEBINORIGINAL,              //  the original unthunked path for RecycleBin items
    IDLHID_PARENTFOLDER,                    //  merged folder uses this to encode the source folder.
    IDLHID_STARTPANEDATA,                   //  Start Pane's private attached data
    IDLHID_NAVIGATEMARKER                   //  Used by Control Panel's 'Category view'               
};
typedef DWORD IDLHID;

#pragma pack(1)
typedef struct _HIDDENITEMID
{
    WORD    cb;     //  hidden item size
    WORD    wVersion;
    IDLHID  id;     //  hidden item ID
} HIDDENITEMID;
#pragma pack()

typedef HIDDENITEMID UNALIGNED *PIDHIDDEN;
typedef const HIDDENITEMID UNALIGNED *PCIDHIDDEN;

STDAPI_(LPITEMIDLIST) ILAppendHiddenID(LPITEMIDLIST pidl, PCIDHIDDEN pidhid);
STDAPI ILCloneWithHiddenID(LPCITEMIDLIST pidl, PCIDHIDDEN pidhid, LPITEMIDLIST *ppidl);
STDAPI_(PCIDHIDDEN) ILFindHiddenIDOn(LPCITEMIDLIST pidl, IDLHID id, BOOL fOnLast);
#define ILFindHiddenID(p, i)    ILFindHiddenIDOn((p), (i), TRUE)
STDAPI_(BOOL) ILRemoveHiddenID(LPITEMIDLIST pidl, IDLHID id);
STDAPI_(void) ILExpungeRemovedHiddenIDs(LPITEMIDLIST pidl);
STDAPI_(LPITEMIDLIST) ILCreateWithHidden(UINT cbNonHidden, UINT cbHidden);

//  helpers for common data types.
STDAPI_(LPITEMIDLIST) ILAppendHiddenClsid(LPITEMIDLIST pidl, IDLHID id, CLSID *pclsid);
STDAPI_(BOOL) ILGetHiddenClsid(LPCITEMIDLIST pidl, IDLHID id, CLSID *pclsid);
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringW(LPITEMIDLIST pidl, IDLHID id, LPCWSTR psz);
STDAPI_(LPITEMIDLIST) ILAppendHiddenStringA(LPITEMIDLIST pidl, IDLHID id, LPCSTR psz);
STDAPI_(BOOL) ILGetHiddenStringW(LPCITEMIDLIST pidl, IDLHID id, LPWSTR psz, DWORD cch);
STDAPI_(BOOL) ILGetHiddenStringA(LPCITEMIDLIST pidl, IDLHID id, LPSTR psz, DWORD cch);
STDAPI_(int) ILCompareHiddenString(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, IDLHID id);

#ifdef UNICODE
#define ILAppendHiddenString            ILAppendHiddenStringW
#define ILGetHiddenString               ILGetHiddenStringW
#else //!UNICODE
#define ILAppendHiddenString            ILAppendHiddenStringA
#define ILGetHiddenString               ILGetHiddenStringA
#endif //UNICODE

#endif // _IDHIDDEN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\inetsmgr.h ===
#if !defined(_INETSMGR_H_)
#define _INETSMGR_H_

// whoever inherits this class must implement _IsSafeSite
class CInternetSecurityMgrImpl : public IInternetSecurityManager
{
public:
    // *** IUnknown ***
    // (client must provide!)
    
    // *** IInternetSecurityManager methods ***
    virtual STDMETHODIMP MapUrlToZone(LPCWSTR pwszUrl, DWORD *pdwZone, DWORD dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetSecurityId(LPCWSTR pwszUrl, BYTE* pbSecurityId, DWORD *pcbSecurityId, DWORD_PTR dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP ProcessUrlAction(LPCWSTR pwszUrl, DWORD dwAction, BYTE *pPolicy, DWORD cbPolicy,
                                  BYTE *pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
    {
        HRESULT hres = INET_E_DEFAULT_ACTION;

        if (_IsSafeUrl(pwszUrl))
        {
            if (cbPolicy >= SIZEOF(DWORD))
            {
                *(DWORD *)pPolicy = URLPOLICY_ALLOW;
                hres = S_OK;
            }
            else
                hres = S_FALSE;
        }

        return hres;
    }
    virtual STDMETHODIMP QueryCustomPolicy(LPCWSTR pwszUrl, REFGUID guidKey, BYTE **ppPolicy, DWORD *pcbPolicy,
                                   BYTE *pContext, DWORD cbContext, DWORD dwReserved)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP SetSecuritySite(IInternetSecurityMgrSite *pSite)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetSecuritySite(IInternetSecurityMgrSite **ppSite)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags)
    {
        return INET_E_DEFAULT_ACTION;
    }
    virtual STDMETHODIMP GetZoneMappings(DWORD dwZone, IEnumString **ppEnumString, DWORD dwFlags)
    {
        return INET_E_DEFAULT_ACTION;
    }

protected:
    virtual BOOL _IsSafeUrl(LPCWSTR pwszUrl) = 0;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\iethread.h ===
//
// Defines IETHREADPARAM for shdocvw.dll and explorer.exe
//

#ifndef __IETHREAD_H__
#define __IETHREAD_H__

#include <desktopp.h>

typedef struct
{
    DWORD   dwSize;
    UINT    uFlags;
    int     nShow;
    DWORD   dwHwndCaller;       // Must be DWORD for 32/64 interop
    DWORD   dwHotKey;
    CLSID   clsid;
    CLSID   clsidInProc;
    UINT    oidl;               // Offset to pidl or 0
    UINT    oidlSelect;         // Offset to pidl or 0
    UINT    oidlRoot;           // Offset to pidl or 0
    UINT    opszPath;           // Offset to path or 0
} NEWFOLDERBLOCK, *PNEWFOLDERBLOCK;

typedef struct _WINVIEW
{
    BOOL UNUSED:1;      // unused
    BOOL bStdButtons:1; // Win95 called this bToolbar
    BOOL bStatusBar:1;  // Win95
    BOOL bLinks:1;      // IE3 called this bITBar
    BOOL bAddress:1;    // IE4
} WINVIEW;


// the size in characters of the name of the Event used to signal IEXPLORE
#define MAX_IEEVENTNAME (2+1+8+1+8+1)

#undef  INTERFACE
#define INTERFACE   IEFreeThreadedHandShake
DECLARE_INTERFACE_(IEFreeThreadedHandShake, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IIEFreeThreadedHandShake methods ***
    STDMETHOD_(void,   PutHevent) (THIS_ HANDLE hevent) PURE;
    STDMETHOD_(HANDLE, GetHevent) (THIS) PURE;
    STDMETHOD_(void,    PutHresult) (THIS_ HRESULT hres) PURE;
    STDMETHOD_(HRESULT, GetHresult) (THIS) PURE;
    STDMETHOD_(IStream*, GetStream) (THIS) PURE;
};


#ifdef NO_MARSHALLING

#undef  INTERFACE
#define INTERFACE IWindowStatus
DECLARE_INTERFACE_(IWindowStatus, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWindowStatus methods ***
    STDMETHOD(IsWindowActivated)() PURE;
};

#endif


// NOTE: The IETHREADPARAM structure is used between shdocvw, shell32,
// and browseui, so it cannot be modified after we ship, only extended.
typedef struct
{
    LPCWSTR pszCmdLine;
    UINT    uFlags;             // COF_ bits
    int     nCmdShow;

    //  these will always be set together
    ITravelLog *ptl;
    DWORD dwBrowserIndex;

    IEFreeThreadedHandShake* piehs;   // caller (thread) owns it

    // these come from explorer's NEWFOLDERINFO
    LPITEMIDLIST pidl;

    WCHAR szDdeRegEvent[MAX_IEEVENTNAME];
    WCHAR szCloseEvent[MAX_IEEVENTNAME];
    
    IShellBrowser* psbCaller;
    HWND hwndCaller;
    ISplashScreen *pSplash;
    LPITEMIDLIST pidlSelect;    // Only used if COF_SELECT

    LPITEMIDLIST pidlRoot;      // Only used if COF_NEWROOT
                                // 99/04/07 #141049 vtan: Overload pidlRoot with
                                // HMONITOR information on Windows 2000. Check the
                                // uFlags for COF_HASHMONITOR before using this.

    CLSID clsid;                // Only used if COF_NEWROOT
    CLSID clsidInProc;          // Only used if COF_INPROC
    
    // these come from explorer.exe's cabview struct
    WINDOWPLACEMENT wp;
    FOLDERSETTINGS fs;
    UINT wHotkey;

    WINVIEW wv;

    SHELLVIEWID m_vidRestore;
    DWORD m_dwViewPriority;
    
    long dwRegister;            // The register that was gotten from RegisterPending
    IUnknown *punkRefProcess;

    BOOL fNoLocalFileWarning : 1;
    BOOL fDontUseHomePage : 1;
    BOOL fFullScreen : 1;
    BOOL fNoDragDrop : 1;
    BOOL fAutomation : 1;
    BOOL fCheckFirstOpen : 1;
    BOOL fDesktopChannel : 1;

#ifdef UNIX
    BOOL fShouldStart : 1;
#endif

#ifdef NO_MARSHALLING
    BOOL fOnIEThread : 1;
#endif //NO_MARSHALLING
} IETHREADPARAM;

#ifdef UNIX
#define COF_HELPMODE            0x00010000      // Special mode for help display
#endif

#endif // __IETHREAD_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\inetutil.h ===
/*****************************************************************************\
    FILE: inetutil.h

    DESCRIPTION:
        These are wininet wrappers that fix the error values and wrap functionality.

    BryanSt 10/12/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _INETUTIL_H
#define _INETUTIL_H


////////////////////////////////
//  Wininet/URL Helpers
////////////////////////////////
STDAPI DownloadUrl(LPCTSTR pszUrl, BSTR * pbstrXML);
STDAPI InternetOpenUrlWrap(HINTERNET hInternet, LPCTSTR pszUrl, LPCTSTR pszHeaders, DWORD dwHeadersLength, DWORD dwFlags, DWORD_PTR dwContext, HINTERNET * phFileHandle);
STDAPI InternetOpenWrap(LPCTSTR pszAgent, DWORD dwAccessType, LPCTSTR pszProxy, LPCTSTR pszProxyBypass, DWORD dwFlags, HINTERNET * phFileHandle);
STDAPI InternetReadIntoBSTR(HINTERNET hInternetRead, OUT BSTR * pbstrXML);
STDAPI InternetReadFileWrap(HINTERNET hFile, LPVOID pvBuffer, DWORD dwNumberOfBytesToRead, LPDWORD pdwNumberOfBytesRead);




#endif // _INETUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\inststub.h ===
#ifndef __cplusplus
#error Install stub code must be C++!
#endif

#ifndef HINST_THISDLL
#error HINST_THISDLL must be defined!
#endif

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof((a)[0]))
#endif

#include <ccstock.h>
#include <stubres.h>
#include <trayp.h>
#include <advpub.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <runonce.c>    // shared runonce code for ShellExecuteRegApp()
#ifdef __cplusplus
};
#endif

BOOL CheckWebViewShell();

/* This code runs the install/uninstall stubs recorded in the local-machine
 * part of the registry, iff the current user has not had them run in his
 * context yet.  Used for populating the user's profile with things like
 * links to applications.
 */
//---------------------------------------------------------------------------


BOOL ProfilesEnabled(void)
{
    BOOL fEnabled = FALSE;

    if (staticIsOS(OS_NT)) {
        fEnabled = TRUE;
    }
    else {
        HKEY hkeyLogon;
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Network\\Logon"), 0,
                    KEY_QUERY_VALUE, &hkeyLogon) == ERROR_SUCCESS) {
            DWORD fProfiles, cbData = sizeof(fProfiles), dwType;
            if (RegQueryValueEx(hkeyLogon, TEXT("UserProfiles"), NULL, &dwType,
                        (LPBYTE)&fProfiles, &cbData) == ERROR_SUCCESS) {
                if (dwType == REG_DWORD || (dwType == REG_BINARY && cbData == sizeof(DWORD)))
                    fEnabled = fProfiles;
            }
            RegCloseKey(hkeyLogon);
        }
    }
    return fEnabled;
}

// ---------------------------------------------------------------------------
// %%Function: GetVersionFromString
//
//  Snarfed from urlmon\download\helpers.cxx.
//
//    converts version in text format (a,b,c,d) into two dwords (a,b), (c,d)
//    The printed version number is of format a.b.d (but, we don't care)
// ---------------------------------------------------------------------------
    HRESULT
GetVersionFromString(LPCTSTR szBuf, LPDWORD pdwFileVersionMS, LPDWORD pdwFileVersionLS)
{
    LPCTSTR pch = szBuf;
    TCHAR ch;
    USHORT n = 0;

    USHORT a = 0;
    USHORT b = 0;
    USHORT c = 0;
    USHORT d = 0;

    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;


    *pdwFileVersionMS = 0;
    *pdwFileVersionLS = 0;

    if (!pch)            // default to zero if none provided
        return S_OK;

    if (lstrcmp(pch, TEXT("-1,-1,-1,-1")) == 0) {
        *pdwFileVersionMS = 0xffffffff;
        *pdwFileVersionLS = 0xffffffff;
    }


    for (ch = *pch++;;ch = *pch++) {

        if ((ch == ',') || (ch == '\0')) {

            switch (have) {

                case HAVE_NONE:
                    a = n;
                    have = HAVE_A;
                    break;

                case HAVE_A:
                    b = n;
                    have = HAVE_B;
                    break;

                case HAVE_B:
                    c = n;
                    have = HAVE_C;
                    break;

                case HAVE_C:
                    d = n;
                    have = HAVE_D;
                    break;

                case HAVE_D:
                    return E_INVALIDARG; // invalid arg
            }

            if (ch == '\0') {
                // all done convert a,b,c,d into two dwords of version

                *pdwFileVersionMS = ((a << 16)|b);
                *pdwFileVersionLS = ((c << 16)|d);

                return S_OK;
            }

            n = 0; // reset

        } else if ( (ch < '0') || (ch > '9'))
            return E_INVALIDARG;    // invalid arg
        else
            n = n*10 + (ch - '0');


    } /* end forever */

    // NEVERREACHED
}


// Reg keys and values for install/uninstall stub list.  Each subkey under
// HKLM\Software\InstalledComponents is a component identifier (GUID).
// Each subkey has values "Path" for the EXE to run to install or uninstall;
// IsInstalled (dword) indicating whether the component has been installed
// or uninstalled;  and an optional Revision (dword) used to refresh a
// component without changing its GUID.  Locale (string) is used to describe
// the language/locale for the component;  this string is not interpreted by
// the install stub code, it is just compared between the HKLM and HKCU keys.
// If it's different between the two, the stub is re-run.
//
// HKCU\Software\InstalledComponents contains similar GUID subkeys, but the
// only values under each subkey are the optional Revision and Locale values,
// and an optional DontAsk value (also DWORD).  Presence of the subkey indicates
// that the component is installed for that user.
//
// If the DontAsk value is present under an HKCU subkey and is non-zero, that
// means that the user has decided to keep their settings for that component
// on all machines, even those that have had the component uninstalled, and
// that they don't want to be asked if they want to run the uninstall stub
// every time they log on.  This implies that for that user, the uninstall
// stub will never be run for that component unless the user somehow clears
// the flag.
//
// NOTE: mslocusr.dll also knows these registry paths.

const TCHAR c_szRegInstalledComponentsKey[] = TEXT("Software\\Microsoft\\Active Setup\\Installed Components");
const TCHAR c_szRegInstallStubValue[] = TEXT("StubPath");
const TCHAR c_szRegIsInstalledValue[] = TEXT("IsInstalled");
const TCHAR c_szRegInstallSequenceValue[] = TEXT("Version");
const TCHAR c_szRegDontAskValue[] = TEXT("DontAsk");
const TCHAR c_szRegLocaleValue[] = TEXT("Locale");


UINT ConfirmUninstall(LPCTSTR pszDescription)
{
    /* The only case where the user wouldn't want settings cleaned up on
     * uninstall would be if they'd roamed to a machine that had had this
     * component uninstalled.  If user profiles aren't enabled (which is
     * the case on a fair number of customers' machines), they're certainly
     * not roaming, so there's not much point in asking them.  Just pretend
     * they said YES, they want to clean up the settings.
     */
    if (!ProfilesEnabled())
        return IDYES;

    /* FEATURE - change to a dialog with a checkbox for
     * the don't-ask value.
     */

    TCHAR szTitle[MAX_PATH];
#ifdef USERSTUB
    LoadString(HINST_THISDLL, IDS_DESKTOP, szTitle, ARRAYSIZE(szTitle));
#else
    MLLoadString(IDS_DESKTOP, szTitle, ARRAYSIZE(szTitle));
#endif

    TCHAR szMessageTemplate[MAX_PATH];
    LPTSTR pszMessage = NULL;
    int   cchMessage;

#ifdef USERSTUB
    LoadString(HINST_THISDLL, IDS_UNINSTALL, szMessageTemplate, ARRAYSIZE(szMessageTemplate));
#else
    MLLoadString(IDS_UNINSTALL, szMessageTemplate, ARRAYSIZE(szMessageTemplate));
#endif


    cchMessage = lstrlen(szMessageTemplate)+lstrlen(pszDescription)+4;
    pszMessage = (LPTSTR)LocalAlloc(LPTR, cchMessage * sizeof(TCHAR));
    if (pszMessage)
    {
        StringCchPrintf(pszMessage, cchMessage, szMessageTemplate, pszDescription);
    }
    else
    {
        pszMessage = szMessageTemplate;
    }

    // due to build in UNICODE the following call is broken under win95, user wsprintf above
    //if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING |
    //                   FORMAT_MESSAGE_ARGUMENT_ARRAY,
    //                   (LPVOID)szMessageTemplate,
    //                   0,
    //                   0,
    //                   (LPTSTR)&pszMessage,
    //                   0,        /* min chars to allocate */
    //                   (va_list *)&pszDescription)) {
    //    pszMessage = szMessageTemplate;
    //}


    UINT idRet = MessageBox(NULL, pszMessage, szTitle,
            MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_SETFOREGROUND | MB_TOPMOST);

    if (pszMessage != szMessageTemplate)
        LocalFree(pszMessage);

    return idRet;
}


HWND hwndProgress = NULL;
BOOL fTriedProgressDialog = FALSE;

INT_PTR ProgressDialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_SETCURSOR:
            SetCursor(LoadCursor(NULL, IDC_WAIT));
            return TRUE;


        default:
            return FALSE;
    }

    return TRUE;
}


void SetProgressInfo(HWND hwndProgress, LPCTSTR pszFriendlyName, BOOL fInstalling)
{
    HWND hwndInstalling = GetDlgItem(hwndProgress, IDC_RUNNING_INSTALL_STUB);
    HWND hwndUninstalling = GetDlgItem(hwndProgress, IDC_RUNNING_UNINSTALL_STUB);

    ShowWindow(hwndInstalling, fInstalling ? SW_SHOW : SW_HIDE);
    EnableWindow(hwndInstalling, fInstalling);
    ShowWindow(hwndUninstalling, fInstalling ? SW_HIDE : SW_SHOW);
    EnableWindow(hwndUninstalling, !fInstalling);
    SetDlgItemText(hwndProgress, IDC_INSTALL_STUB_NAME, pszFriendlyName);
}


void IndicateProgress(LPCTSTR pszFriendlyName, BOOL fInstalling)
{
    if (hwndProgress == NULL && !fTriedProgressDialog) {
        hwndProgress = CreateDialog(HINST_THISDLL, MAKEINTRESOURCE(IDD_InstallStubProgress),
                NULL, ProgressDialogProc);
    }

    if (hwndProgress != NULL) {
        SetProgressInfo(hwndProgress, pszFriendlyName, fInstalling);
        if (!fTriedProgressDialog) {
            ShowWindow(hwndProgress, SW_RESTORE);
            SetForegroundWindow(hwndProgress);
        }
    }
    fTriedProgressDialog = TRUE;
}


void CleanupProgressDialog(void)
{
    if (hwndProgress != NULL) {
        DestroyWindow(hwndProgress);
        hwndProgress = NULL;
    }
}


BOOL RunOneInstallStub( HKEY hklmList, HKEY hkcuList, LPCTSTR pszKeyName,
        LPCTSTR pszCurrentUsername, int iPass )
{
    BOOL bNextPassNeeded = FALSE;
    /* See if this component is installed or an uninstall tombstone. */
    HKEY hkeyComponent;

    DWORD err = RegOpenKeyEx(hklmList, pszKeyName, 0, KEY_QUERY_VALUE,
            &hkeyComponent);
    if (err == ERROR_SUCCESS) {
        TCHAR szCmdLine[MAX_PATH];
        DWORD fIsInstalled;
        DWORD dwType;
        DWORD cbData = sizeof(fIsInstalled);
        HKEY hkeyUser = NULL;

        /* Must have the stub path;  if not there, skip this entry. */
        cbData = sizeof(szCmdLine);
        if (SHQueryValueEx(hkeyComponent, c_szRegInstallStubValue,
                    NULL, &dwType, (LPBYTE)szCmdLine,
                    &cbData) != ERROR_SUCCESS || ((dwType != REG_SZ) && (dwType != REG_EXPAND_SZ)) ) {
            RegCloseKey(hkeyComponent);
            return bNextPassNeeded;
        }

        TCHAR szDescription[MAX_PATH];
        LPTSTR pszDescription = szDescription;
        cbData = sizeof(szDescription);
        if (SHQueryValueEx(hkeyComponent, TEXT(""),
                    NULL, &dwType, (LPBYTE)szDescription,
                    &cbData) != ERROR_SUCCESS || dwType != REG_SZ) {
            pszDescription = szCmdLine;
        }


        if (RegQueryValueEx(hkeyComponent, c_szRegIsInstalledValue,
                    NULL, &dwType, (LPBYTE)&fIsInstalled,
                    &cbData) != ERROR_SUCCESS ||
                (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))))
            fIsInstalled = TRUE;

        /* If it's installed, check the user's profile, and if the
         * component (or its current revision) isn't installed there,
         * run it.
         */
        if (fIsInstalled) {
            DWORD dwRevisionHi, dwRevisionLo;
            DWORD dwUserRevisionHi = 0;
            DWORD dwUserRevisionLo = 0;
            BOOL fSetRevision;
            TCHAR szRevision[24], szUserRevision[24];   /* 65535,65535,65535,65535\0 */
            TCHAR szLocale[10], szUserLocale[10];       /* usually not very big strings */
            TCHAR szInstallUsername[128+1];  /* 128 is the win95 system username limit */

            DWORD fIsCloneUser;
            cbData = sizeof(fIsCloneUser);
            if (RegQueryValueEx(hkeyComponent, TEXT("CloneUser"),
                        NULL, &dwType, (LPBYTE)&fIsCloneUser,
                        &cbData) != ERROR_SUCCESS ||
                    (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))))
                fIsCloneUser = FALSE;

            cbData = sizeof(szRevision);
            if (RegQueryValueEx(hkeyComponent, c_szRegInstallSequenceValue,
                        NULL, &dwType, (LPBYTE)szRevision,
                        &cbData) != ERROR_SUCCESS ||
                    dwType != REG_SZ ||
                    FAILED(GetVersionFromString(szRevision, &dwRevisionHi, &dwRevisionLo))) {
                fSetRevision = FALSE;
                dwRevisionHi = 0;
                dwRevisionLo = 0;
            }
            else {
                fSetRevision = TRUE;
            }

            cbData = sizeof(szLocale);
            err = RegQueryValueEx(hkeyComponent, c_szRegLocaleValue,
                    NULL, &dwType, (LPBYTE)szLocale,
                    &cbData);
            if (err != ERROR_SUCCESS || dwType != REG_SZ) {
                szLocale[0] = '\0';
            }

            err = RegOpenKeyEx(hkcuList, pszKeyName, 0,
                    KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyUser);
            if (err == ERROR_SUCCESS) {
                cbData = sizeof(szUserRevision);
                if (RegQueryValueEx(hkeyUser, c_szRegInstallSequenceValue,
                            NULL, &dwType, (LPBYTE)szUserRevision,
                            &cbData) != ERROR_SUCCESS ||
                        dwType != REG_SZ ||
                        FAILED(GetVersionFromString(szUserRevision, &dwUserRevisionHi, &dwUserRevisionLo))) {
                    dwUserRevisionHi = 0;
                    dwUserRevisionLo = 0;
                }

                if (szLocale[0] != '\0') {
                    cbData = sizeof(szUserLocale);
                    err = RegQueryValueEx(hkeyUser, c_szRegLocaleValue,
                            NULL, &dwType, (LPBYTE)szUserLocale,
                            &cbData);
                    /* If there's a locale string under the user key
                     * and it's the same as the machine one, then we
                     * blank out the machine one so we won't consider
                     * that when running the stub.
                     */
                    if (err == ERROR_SUCCESS && dwType == REG_SZ &&
                            !lstrcmp(szLocale, szUserLocale)) {
                        szLocale[0] = '\0';
                    }
                }
                if (fIsCloneUser) {
                    /* Clone-user install stub.  We need to re-run it if the
                     * username we used when we last installed to this profile,
                     * or the one it was copied from, is different from the
                     * current username.
                     */
                    cbData = sizeof(szInstallUsername);
                    if (RegQueryValueEx(hkeyUser, TEXT("Username"),
                                NULL, &dwType, (LPBYTE)szInstallUsername,
                                &cbData) != ERROR_SUCCESS ||
                            dwType != REG_SZ) {
                        szInstallUsername[0] = '\0';
                    }
                }
            }
            else {
                hkeyUser = NULL;
            }

            /* Install if:
             *
             * - User doesn't have component installed, OR
             *   - Component installed on machine has a revision AND
             *   - Machine component revision greater than user's
             * - OR
             *   - Component installed on machine has a locale AND
             *   - Machine component locale different than user's
             *     (this is actually checked above)
             * - OR
             *   - Component is a clone-user install stub and the username
             *     recorded for the stub is different from the current username
             */
            if ((hkeyUser == NULL) ||
                    (fSetRevision &&
                     ((dwRevisionHi > dwUserRevisionHi) ||
                      ((dwRevisionHi == dwUserRevisionHi) &&
                       (dwRevisionLo > dwUserRevisionLo)
                      )
                     )
                    ) ||
                    (szLocale[0] != '\0') ||
#ifdef UNICODE
                    (fIsCloneUser && StrCmpI(szInstallUsername, pszCurrentUsername))
#else
                    (fIsCloneUser && lstrcmpi(szInstallUsername, pszCurrentUsername))
#endif
               ) {

                if ( (iPass == -1 ) ||
                        ((iPass == 0) && (*pszKeyName == '<')) ||
                        ((iPass == 1) && (*pszKeyName != '<') && (*pszKeyName != '>')) ||
                        ((iPass == 2) && (*pszKeyName == '>')) )
                {
                    // the condition meets, run it now.
#ifdef TraceMsg
                    TraceMsg(TF_WARNING, "Running install stub ( %s )", szCmdLine);
#endif
                    IndicateProgress(pszDescription, TRUE);
                    ShellExecuteRegApp(szCmdLine, RRA_WAIT | RRA_NOUI);
                    if (hkeyUser == NULL) {
                        RegCreateKeyEx(hkcuList, pszKeyName, 0, NULL, REG_OPTION_NON_VOLATILE, 
                                KEY_SET_VALUE, NULL, &hkeyUser, NULL);
                    }
                    if (hkeyUser != NULL) {
                        if (fSetRevision) {
                            RegSetValueEx(hkeyUser, c_szRegInstallSequenceValue,
                                    0, REG_SZ,
                                    (LPBYTE)szRevision,
                                    (lstrlen(szRevision)+1)*sizeof(TCHAR));
                        }
                        if (szLocale[0]) {
                            RegSetValueEx(hkeyUser, c_szRegLocaleValue,
                                    0, REG_SZ,
                                    (LPBYTE)szLocale,
                                    (lstrlen(szLocale)+1)*sizeof(TCHAR));
                        }
                        if (fIsCloneUser) {
                            RegSetValueEx(hkeyUser, TEXT("Username"),
                                    0, REG_SZ,
                                    (LPBYTE)pszCurrentUsername,
                                    (lstrlen(pszCurrentUsername)+1)*sizeof(TCHAR));
                        }
                    }
                }
                else
                {
                    // decide if this belong to the next pass
                    // if it is in Pass 2, should never get here
                    if ( iPass == 0 )
                        bNextPassNeeded = TRUE;
                    else if ( (iPass == 1 ) && (*pszKeyName == '>') )
                        bNextPassNeeded = TRUE;
                }
            }
        }
        else {
            /* Component is an uninstall stub. */

            err = RegOpenKeyEx(hkcuList, pszKeyName, 0,
                    KEY_QUERY_VALUE, &hkeyUser);
            if (err == ERROR_SUCCESS) {
                DWORD fDontAsk = 0;

                /* Check the "Don't Ask" value.  If it's present, its value
                 * is interpreted as follows:
                 *
                 * 0 --> ask the user
                 * 1 --> do not run the stub
                 * 2 --> always run the stub
                 */
                cbData = sizeof(fDontAsk);
                if (RegQueryValueEx(hkeyComponent, c_szRegDontAskValue,
                            NULL, &dwType, (LPBYTE)&fDontAsk,
                            &cbData) != ERROR_SUCCESS ||
                        (dwType != REG_DWORD && (dwType != REG_BINARY || cbData != sizeof(DWORD))) ||
                        fDontAsk != 1) 
                {

                    if ( (iPass == -1 ) ||
                            ((iPass == 0) && (*pszKeyName == '>')) ||
                            ((iPass == 1) && (*pszKeyName != '<') && (*pszKeyName != '>')) ||
                            ((iPass == 2) && (*pszKeyName == '<')) )
                    {
                        // uninstall stub has the reversed order comparing with install stub
                        if (fDontAsk == 2 || ConfirmUninstall(pszDescription) == IDYES) {

#ifdef TraceMsg
                            TraceMsg(TF_WARNING, "Running uninstall stub ( %s )", szCmdLine);
#endif
                            IndicateProgress(pszDescription, FALSE);
                            ShellExecuteRegApp(szCmdLine, RRA_WAIT | RRA_NOUI);

                            /* Component has been uninstalled.  Forget that the
                             * user ever had it installed.
                             */
                            RegCloseKey(hkeyUser);
                            hkeyUser = NULL;
                            RegDeleteKey(hkcuList, pszKeyName);
                        }

                    }
                    else
                    {
                        // decide if this belong to the next pass
                        // if it is in Pass 2, should never get here
                        if ( iPass == 0 )
                            bNextPassNeeded = TRUE;
                        else if ( (iPass == 1 ) && (*pszKeyName == '<') )
                            bNextPassNeeded = TRUE;
                    }
                }
            }
        }

        if (hkeyUser != NULL) {
            RegCloseKey(hkeyUser);
        }
        RegCloseKey(hkeyComponent);
    }

    return bNextPassNeeded;
}


const TCHAR  c_szIE40GUID_STUB[] = TEXT("{89820200-ECBD-11cf-8B85-00AA005B4383}");
const TCHAR  c_szBlockIE4Stub[]  = TEXT("NoIE4StubProcessing");
const char pstrPendingGPOs[] =  "Software\\Microsoft\\IEAK\\GroupPolicy\\PendingGPOs";

void RunPendingGPOs()
{
    HKEY hKey = NULL;    
    char szValueName[16];
    char szPathName[MAX_PATH];
    char szSection[64];
    char szTempPath[MAX_PATH];
    DWORD cbPathName, cbSection;
    HRESULT hr;

    if (ERROR_SUCCESS == RegOpenKeyExA(HKEY_CURRENT_USER, pstrPendingGPOs, 0, KEY_QUERY_VALUE, &hKey))
    {
        GetTempPathA(sizeof(szTempPath), szTempPath);
        for (DWORD i=1; ; i++)
        {
            wnsprintfA(szValueName, sizeof(szValueName)-1, "Path%d", i);
            cbPathName = sizeof(szPathName);
            hr = RegQueryValueExA(hKey, szValueName, NULL, NULL, (LPBYTE)szPathName, &cbPathName);
            if (hr != ERROR_SUCCESS)
            {
                break;
            }

            wnsprintfA(szValueName, sizeof(szValueName)-1, "Section%d", i);
            cbSection = sizeof(szSection);
            hr = RegQueryValueExA(hKey, szValueName, NULL, NULL, (LPBYTE)szSection, &cbSection);
            if (hr != ERROR_SUCCESS)
            {
                break;
            }

            RunSetupCommand(NULL, szPathName, szSection, szTempPath, NULL, NULL,
                    RSC_FLAG_INF | RSC_FLAG_QUIET, 0);
        }

        RegCloseKey(hKey);
    }
    RegDeleteKeyA(HKEY_CURRENT_USER, pstrPendingGPOs);
}

extern "C" void RunInstallUninstallStubs2(LPCTSTR pszStubToRun)
{
    HKEY hklmList = NULL, hkcuList = NULL;
    LONG err;

    TCHAR szUsername[128+1];        /* 128 is the win95 limit, good default */
    LPTSTR pszCurrentUser = szUsername;

    /* As far as clone-user install stubs are concerned, we only want profile
     * usernames.
     */
    if (!ProfilesEnabled()) {
        *pszCurrentUser = '\0';
    }
    else {
        DWORD cbData = sizeof(szUsername);
        if (!GetUserName(szUsername, &cbData)) {
            if (cbData > sizeof(szUsername)) {
                cbData++;   /* allow for null char just in case */
                pszCurrentUser = (LPTSTR)LocalAlloc(LPTR, cbData+1);
                if (pszCurrentUser == NULL || !GetUserName(pszCurrentUser, &cbData)) {
                    if (pszCurrentUser != NULL)
                        LocalFree(pszCurrentUser);
                    pszCurrentUser = szUsername;
                    *pszCurrentUser = '\0';
                }
            }
            else {
                szUsername[0] = '\0';
            }
        }
    }

#ifdef TraceMsg
    TraceMsg(TF_WARNING, "Running install/uninstall stubs.");
#endif

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegInstalledComponentsKey, 0,
            KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE, &hklmList);

    if (err == ERROR_SUCCESS) {
        DWORD dwDisp;
        err = RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegInstalledComponentsKey, 0,
                TEXT(""), REG_OPTION_NON_VOLATILE,
                KEY_READ | KEY_WRITE, NULL, &hkcuList, &dwDisp);
    }

    if (err == ERROR_SUCCESS) {
        if (pszStubToRun != NULL) {
            // here we call with pass number -1 means no pass order enforced
            RunOneInstallStub(hklmList, hkcuList, pszStubToRun, pszCurrentUser, -1);
        }
        else {
            DWORD cbKeyName, iKey, iPass;
            TCHAR szKeyName[80];
            BOOL  bNextPassNeeded = TRUE;
            HANDLE hMutex;

            // This mutex check is to ensure if explore restarted due abnormal active desktop shutdown, and setup resume
            // per-user stubs should not be processed till setup is done.
            if (CheckWebViewShell())
            {
                hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, TEXT("Ie4Setup.Mutext"));
                if (hMutex)
                {
                    CloseHandle(hMutex);                
                    goto done;
                }
            }

            // check if we want to block the stub processing
            cbKeyName = sizeof(szKeyName);
            if ((RegQueryValueEx(hklmList, c_szBlockIE4Stub, NULL, NULL, 
                            (LPBYTE)szKeyName, &cbKeyName) == ERROR_SUCCESS) && 
                    (*CharUpper(szKeyName) == 'Y') )
            {
                goto done;
            }                       

            /* we will do TWO passes to meet the ordering requirement when run component stubs.
               Any KeyName with '*' as the first char, get run in the 1st Pass.  the rest run 2nd pass */
            for ( iPass = 0; ((iPass<3) && bNextPassNeeded); iPass++ )
            {
                bNextPassNeeded = FALSE;

                // APPCOMPAT: in 2nd pass, we do want to special case of IE4.0 base browser stub
                // to run first.  The reason we did not use '<' for this is to 1) reserve < stuff
                // for pre-ie4 stubs and this whole thing should redo in sorted fashion.  For now,
                // we hard code this IE4.0 base browser GUID
                if ( iPass == 1 )
                {
                    if ( RunOneInstallStub(hklmList, hkcuList, c_szIE40GUID_STUB, pszCurrentUser, iPass) )                    
                        bNextPassNeeded = TRUE;
                }                    

                /* Enumerate components that are installed on the local machine. */
                for (iKey = 0; ; iKey++)
                {
                    LONG lEnum;

                    cbKeyName = ARRAYSIZE(szKeyName);

                    // WARNING (Unicode, Davepl) I'm assuming that the data is UNICODE,
                    // but I'm not sure who put it there yet... double check.

                    if ((lEnum = RegEnumKey(hklmList, iKey, szKeyName, cbKeyName)) == ERROR_MORE_DATA)
                    {
                        // ERROR_MORE_DATA means the value name or data was too large
                        // skip to the next item
#ifdef TraceMsg
                        TraceMsg( DM_ERROR, "Cannot run oversize entry in InstalledComponents");
#endif
                        continue;
                    }
                    else if( lEnum != ERROR_SUCCESS )
                    {
                        // could be ERROR_NO_MORE_ENTRIES, or some kind of failure
                        // we can't recover from any other registry problem, anyway
                        break;
                    }

                    // in case the user say NO when we try to run the IE4 stub first time,
                    // we should not re-process this stub again.
                    if ( (iPass == 1) && (!lstrcmpi(szKeyName, c_szIE40GUID_STUB)) )
                        continue;

                    if ( RunOneInstallStub(hklmList, hkcuList, szKeyName, pszCurrentUser, iPass) )                    
                        bNextPassNeeded = TRUE;
                }
            }
        }
    }

    RunPendingGPOs();

done:

    if (hklmList != NULL)
        RegCloseKey(hklmList);
    if (hkcuList != NULL)
        RegCloseKey(hkcuList);

    if (pszCurrentUser != szUsername)
        LocalFree(pszCurrentUser);

    CleanupProgressDialog();
}

// Check shell32.dll's version and see if it is the one which supports the integrated WebView
BOOL CheckWebViewShell()
{
    HINSTANCE           hInstShell32;
    DLLGETVERSIONPROC   fpGetDllVersion;    
    BOOL                pWebViewShell = FALSE;

    hInstShell32 = LoadLibrary(TEXT("Shell32.dll"));
    if (hInstShell32)
    {
        fpGetDllVersion = (DLLGETVERSIONPROC)GetProcAddress(hInstShell32, "DllGetVersion");
        pWebViewShell = (fpGetDllVersion != NULL);
        FreeLibrary(hInstShell32);
    }
    return pWebViewShell;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\intlid.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    intlid.h

Abstract:

    This module contains the resource ids for the Regional Options applet.

Revision History:

--*/


//
//  Text String Constants.
//

//
//  Make sure the next two definitions are not redefined.
//     (This file included by main.cpl)
//
#ifndef IDS_NAME
  #define IDS_NAME                     1
#endif
#ifndef IDS_INFO
  #define IDS_INFO                     2
#endif

#define IDS_NAME_CUSTOM                3
#define IDS_LOCALE_GET_ERROR           4
#define IDS_INVALID_USE_OF_NUM         5
#define IDS_INVALID_TIME_STYLE         6
#define IDS_INVALID_DATE_STYLE         7
#define IDS_NO_LZERO                   8
#define IDS_LZERO                      9
#define IDS_METRIC                     10
#define IDS_US                         11
#define IDS_LOCALE_SET_ERROR           12
#define IDS_LOCALE_NO_NUMS_IN          13
#define IDS_LOCALE_DECIMAL_SYM         14
#define IDS_LOCALE_NEG_SIGN            15
#define IDS_LOCALE_GROUP_SYM           16
#define IDS_LOCALE_TIME_SEP            17
#define IDS_LOCALE_AM_SYM              18
#define IDS_LOCALE_PM_SYM              19
#define IDS_LOCALE_DATE_SEP            20
#define IDS_LOCALE_CURR_SYM            21
#define IDS_LOCALE_CDECIMAL_SYM        22
#define IDS_LOCALE_CGROUP_SYM          23
#define IDS_LOCALE_STYLE_ERR           24
#define IDS_LOCALE_TIME                25
#define IDS_LOCALE_SDATE               26
#define IDS_LOCALE_LDATE               27
#define IDS_LOCALE_YEAR_ERROR          28
#define IDS_LOCALE_SUP_LANG            29

#define IDS_STYLEUH                    55
#define IDS_STYLELH                    56
#define IDS_STYLEUM                    57
#define IDS_STYLELM                    58
#define IDS_STYLELS                    59
#define IDS_STYLELT                    60
#define IDS_STYLELD                    61
#define IDS_STYLELY                    62
#define IDS_TIMECHARS                  63
#define IDS_TCASESWAP                  64
#define IDS_SDATECHARS                 65
#define IDS_SDCASESWAP                 66
#define IDS_LDATECHARS                 67
#define IDS_LDCASESWAP                 68
#define IDS_REBOOT_STRING              69
#define IDS_TITLE_STRING               70
#define IDS_SETUP_STRING               71

#define IDS_ML_PERMANENT               72
#define IDS_ML_CANNOT_MODIFY           73
#define IDS_ML_COPY_FAILED             74
#define IDS_ML_INSTALL_FAILED          75
#define IDS_ML_SETUP_FAILED            76

#define IDS_KBD_LOAD_KBD_FAILED        83

#define IDS_TEXT_INPUT_METHODS         84

#define IDS_SUP_LANG_SUP_INST_TITLE    85
#define IDS_SUP_LANG_SUP_REM_TITLE     86
#define IDS_SUP_LANG_SUP_COMPLEX_INST  87
#define IDS_SUP_LANG_SUP_CJK_INST      88
#define IDS_SUP_LANG_SUP_COMPLEX_INST64  104
#define IDS_SUP_LANG_SUP_CJK_INST64    105
#define IDS_SUP_LANG_SUP_COMPLEX_REM   89
#define IDS_SUP_LANG_SUP_CJK_REM       90

#define IDS_DEF_USER_CONF_TITLE        91
#define IDS_DEF_USER_CONF              92

#define IDS_LOG_FONT_SUBSTITUTE        93

#define IDS_SPANISH_NAME               96
#define IDS_DEFAULT                    97

#define IDS_DEFAULT_USER_ERROR         99
#define IDS_CHANGE_UI_LANG_NOT_ADMIN   100

#define IDS_LOCALE_UNKNOWN             103

#ifndef IDS_UNKNOWN
  #define IDS_UNKNOWN                  198
#endif



//
//  Dialogs.
//

#define DLG_GENERAL                              101
#define DLG_LANGUAGES                            102
#define DLG_ADVANCED                             104
#define DLG_NUMBER                               105
#define DLG_CURRENCY                             106
#define DLG_TIME                                 107
#define DLG_DATE                                 108
#define DLG_SORTING                              109
#define DLG_SETUP_INFORMATION                    200
#define DLG_INPUT_LOCALES                        500

//
//  Icons.
//

#define IDI_ICON                       200


//
//  Digit Substitution Strings.
//

#define IDS_DIGIT_SUBST_CONTEXT        900
#define IDS_DIGIT_SUBST_NONE           (IDS_DIGIT_SUBST_CONTEXT + 1)
#define IDS_DIGIT_SUBST_NATIONAL       (IDS_DIGIT_SUBST_CONTEXT + 2)



//
//  Misc. Controls.
//

#define IDC_STATIC                     -1
#define IDC_GROUPBOX1                  1001
#define IDC_GROUPBOX2                  1002
#define IDC_GROUPBOX3                  1003
#define IDC_GROUPBOX4                  1004
#define IDC_SAMPLE1                    1005
#define IDC_SAMPLE2                    1006
#define IDC_SAMPLELBL1                 1007
#define IDC_SAMPLELBL2                 1008
#define IDC_SAMPLELBL3                 1009
#define IDC_SAMPLE1A                   1010
#define IDC_SAMPLE2A                   1011
#define IDC_SAMPLELBL1A                1012
#define IDC_SAMPLELBL2A                1013



//
//  General Page Controls.
//

#define IDC_USER_LOCALE_TEXT           1020
#define IDC_USER_LOCALE                1021
#define IDC_USER_REGION_TEXT           1022
#define IDC_USER_REGION                1023
#define IDC_CUSTOMIZE                  1024
#define IDC_SAMPLE_TEXT                1025
#define IDC_TEXT1                      1026
#define IDC_TEXT2                      1027
#define IDC_TEXT3                      1028
#define IDC_TEXT4                      1029
#define IDC_TEXT5                      1030
#define IDC_TEXT6                      1031
#define IDC_NUMBER_SAMPLE              1032
#define IDC_CURRENCY_SAMPLE            1033
#define IDC_TIME_SAMPLE                1034
#define IDC_SHRTDATE_SAMPLE            1035
#define IDC_LONGDATE_SAMPLE            1036


//
// Languages Dialog Controls
//

#define IDC_LANGUAGE_LIST_TEXT         1171
#define IDC_LANGUAGE_CHANGE            1172
#define IDC_LANGUAGE_COMPLEX           1173
#define IDC_LANGUAGE_CJK               1174
#define IDC_LANGUAGE_SUPPL_TEXT        1175
#define IDC_UI_LANGUAGE_TEXT           1177
#define IDC_UI_LANGUAGE                1178


//
//  Advanced Page Controls.
//

#define IDC_SYSTEM_LOCALE_TEXT1        1050
#define IDC_SYSTEM_LOCALE_TEXT2        1051
#define IDC_SYSTEM_LOCALE              1052
#define IDC_CODEPAGES                  1053
#define IDC_DEFAULT_USER               1054
#ifdef TEMP_UI
#define IDC_LANGUAGE_GROUPS            1056
#define IDC_CODEPAGE_CONVERSIONS       1057
#endif // TEMP_UI


//
//  Number and Currency Page Controls.
//

#define IDC_DECIMAL_SYMBOL             1070
#define IDC_CURRENCY_SYMBOL            1071
#define IDC_NUM_DECIMAL_DIGITS         1072
#define IDC_DIGIT_GROUP_SYMBOL         1073
#define IDC_NUM_DIGITS_GROUP           1074
#define IDC_POS_SIGN                   1075
#define IDC_NEG_SIGN                   1076
#define IDC_POS_CURRENCY_SYM           1077
#define IDC_NEG_NUM_FORMAT             1078
#define IDC_SEPARATOR                  1079
#define IDC_DISPLAY_LEAD_0             1080
#define IDC_MEASURE_SYS                1081
#define IDC_NATIVE_DIGITS_TEXT         1082
#define IDC_NATIVE_DIGITS              1083
#define IDC_DIGIT_SUBST_TEXT           1084
#define IDC_DIGIT_SUBST                1085



//
//  Time Page Controls.
//

#define IDC_TIME_STYLE                 1090
#define IDC_AM_SYMBOL                  1091
#define IDC_PM_SYMBOL                  1092



//
//  Date Page Controls.
//

#define IDC_CALENDAR_TYPE_TEXT         1100
#define IDC_CALENDAR_TYPE              1101
#define IDC_TWO_DIGIT_YEAR_LOW         1102
#define IDC_TWO_DIGIT_YEAR_HIGH        1103
#define IDC_TWO_DIGIT_YEAR_ARROW       1104
#define IDC_ADD_HIJRI_DATE             1105
#define IDC_SHORT_DATE_STYLE           1106
#define IDC_LONG_DATE_STYLE            1107
#define IDC_ADD_HIJRI_DATE_TEXT        1108


//
//  Sorting Page Controls.
//

#define IDC_SORTING                    1120
#define IDC_SORTING_TEXT1              1121
#define IDC_SORTING_TEXT2              1122

//
//  Unattended Log string
//

#define IDS_LOG_HEAD                   2330
#define IDS_LOG_FILE_ERROR             2331
#define IDS_LOG_INTL_ERROR             2332
#define IDS_LOG_SETUP_ERROR            2333
#define IDS_LOG_UPGRADE_SCENARIO       2334
#define IDS_LOG_SETUP_MODE             2335
#define IDS_LOG_SWITCH_G               2336
#define IDS_LOG_SWITCH_R               2337
#define IDS_LOG_SWITCH_I               2338
#define IDS_LOG_SWITCH_S               2339
#define IDS_LOG_SWITCH_F               2340
#define IDS_LOG_SWITCH_M               2341
#define IDS_LOG_SWITCH_U               2342
#define IDS_LOG_SWITCH_DEFAULT         2343
#define IDS_LOG_LANG_GROUP             2344
#define IDS_LOG_LANG                   2345
#define IDS_LOG_SYS_LOCALE             2346
#define IDS_LOG_SYS_LOCALE_DEF         2347
#define IDS_LOG_USER_LOCALE            2348
#define IDS_LOG_USER_LOCALE_DEF        2349
#define IDS_LOG_MUI_LANG               2350
#define IDS_LOG_MUI_LANG_DEF           2351
#define IDS_LOG_INPUT                  2352
#define IDS_LOG_INPUT_DEF              2353
#define IDS_LOG_LAYOUT                 2354
#define IDS_LOG_LAYOUT_INSTALLED       2355
#define IDS_LOG_INV_BLOCK              2356
#define IDS_LOG_NO_ADMIN               2357
#define IDS_LOG_SYS_LOCALE_CHG         2358
#define IDS_LOG_USER_LOCALE_CHG        2359
#define IDS_LOG_UNI_BLOCK              2360
#define IDS_LOG_SYS_DEF_LAYOUT         2361
#define IDS_LOG_USER_DEF_LAYOUT        2362
#define IDS_LOG_NO_VALID_FOUND         2363
#define IDS_LOG_EXT_LANG_FAIL          2364
#define IDS_LOG_EXT_LANG_CANCEL        2365
#define IDS_LOG_LOCALE_ACP_FAIL        2366
#define IDS_LOG_LOCALE_KBD_FAIL        2367
#define IDS_LOG_INVALID_LOCALE         2368
#define IDS_LOG_UNAT_HEADER            2369
#define IDS_LOG_UNAT_FOOTER            2370
#define IDS_LOG_UI_BLOCK               2371
#define IDS_LOG_UNAT_LOCATED           2372
#define IDS_LOG_LOCALE_LG_FAIL         2373
#define IDS_LOG_LOCALE_LG_REM          2374
#define IDS_LOG_SWITCH_D               2375

//
//  Ordinal for Text Services functions.
//
#define ORD_INPUT_DLG_PROC            101
#define ORD_INPUT_INST_LAYOUT         102
#define ORD_INPUT_UNINST_LAYOUT       103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\linklistt.h ===
template <class Type> class CLinkedList;

template <class Type> struct CLinkedNode    
{
public:
    CLinkedNode <Type> *pNext; 
    Type that;
};

template <class Type> class CLinkedWalk
{
public:
    CLinkedWalk(CLinkedList<Type> *plist) : _plist(plist), _pCurr(NULL), _pLast(NULL) {}
    CLinkedWalk() : _plist(NULL), _pCurr(NULL), _pLast(NULL) {}
    void Init(CLinkedList<Type> *plist) {_plist = plist; _pCurr = _pLast = NULL;}
    inline BOOL IsFirst(void) { return _pLast == NULL;}
    inline Type *That(void) {return _pCurr ? &_pCurr->that : NULL;}
    inline CLinkedNode<Type> *Node(void) {return _pCurr;}
    inline BOOL Step(void)
    {
        _pLast = _pCurr;

        if (_pCurr)
            _pCurr = _pCurr->pNext;
        else if (_plist)
            _pCurr = _plist->_pFirst;

        return (_pCurr != NULL);
    }

    inline CLinkedNode<Type> *Remove(void)
    {
        CLinkedNode<Type> *pRet = _pCurr;
        if (pRet)
        {
            _pCurr = _pCurr->pNext;

            //  update the list
            if (_pLast)
                _pLast->pNext = _pCurr;
            else
                _plist->_pFirst = _pCurr;
        }
        return pRet;
    }

    inline void Delete(void)
    {
        CLinkedNode<Type> *p = Remove();
        if (p)
            delete p;
    }

protected:
    CLinkedList<Type> *_plist;
    CLinkedNode<Type> *_pCurr;
    CLinkedNode<Type> *_pLast;
};

template <class Type> class CLinkedList
{
public: //methods
    CLinkedList() :_pFirst(NULL) {}
    ~CLinkedList()
    {
        CLinkedWalk<Type> lw(this);

        while (lw.Step())
        {
            lw.Delete();
        }
    }
    inline BOOL IsEmpty(void) {return _pFirst == NULL;}
    inline BOOL Insert(CLinkedNode<Type> *p)
    {
        p->pNext = _pFirst;
        _pFirst = p;
        return TRUE;
    }

    inline void Remove(CLinkedNode<Type> *pRemove)
    {
        CLinkedWalk<Type> lw(this);

        while (lw.Step())
        {
            if (lw.Node() == pRemove)
            {
                lw.Remove();
                break;
            }
        }
    }

protected:
    CLinkedNode <Type> *_pFirst;

    friend class CLinkedWalk<Type>;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\locbstr.h ===
// Local BSTR derived from WTL3.1 CString Class

#ifndef __LOCAL_BSTR__
#define __LOCAL_BSTR__

#pragma once

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#ifndef __ATLAPP_H__
	#error atlmisc.h requires atlapp.h to be included first
#endif

// We're ripping out non-Unicode support to remove potential buffer overrun problems in the ansi implementation
#ifdef _UNICODE

namespace LBSTR
{

/////////////////////////////////////////////////////////////////////////////
// Forward declarations

#ifndef _WTL_NO_LOCAL_BSTR
class CString;
#endif //!_WTL_NO_CSTRING

/////////////////////////////////////////////////////////////////////////////
// CString - String class

#ifdef DEBUG
#define VERIFY_LOCAL_BSTR
#endif

#ifdef VERIFY_LOCAL_BSTR

#ifdef DEBUG

#define VERIFY_ASSERT(expr) ASSERT(expr)

#else

#if     _MSC_VER >= 1300 && !defined(_CRT_PORTABLE)
#define _CrtRetailBreak() __debugbreak()
#elif   defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtRetailBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtRetailBreak() _BPT()
#elif   defined(_M_IA64) && !defined(_CRT_PORTABLE)
void __break(int);
#pragma intrinsic (__break)
#define _CrtRetailBreak() __break(0x80016)
#else
_CRTIMP void __cdecl _CrtRetailBreak(
        void
        );
#endif

#if     _MSC_VER >= 1300 || !defined(_M_IX86) || defined(_CRT_PORTABLE)
#define _RETAIL_ASSERT_BASE(expr) \
        (void) ((expr) || \
                (_CrtRetailBreak(), 0))
#else
#define _RETAIL_ASSERT_BASE(expr) \
        do { if (!(expr)) \
             _CrtRetailBreak(); } while (0)
#endif

#define VERIFY_ASSERT(expr) _RETAIL_ASSERT_BASE(expr)

#endif  // DEBUG

#endif  // VERIFY_LOCAL_BSTR

#ifndef _WTL_NO_LOCAL_BSTR

class CStringData
{
public:

#ifdef VERIFY_LOCAL_BSTR
    int nStartTag;
#endif

    long nRefs;     // reference count
    int nDataLength;
    int nAllocLength;

#ifdef VERIFY_LOCAL_BSTR
    int nMiddleTag;
#endif

    ULONG cbDataLength;

    void SetDataLength( int p_nDataLength )
    {
        ASSERT( p_nDataLength >= 0 );
        nDataLength = p_nDataLength;
        cbDataLength = p_nDataLength * sizeof(TCHAR);
    }

	// TCHAR data[nAllocLength]

	TCHAR* data()
		{ return (TCHAR*)(this + 1); }

#ifdef VERIFY_LOCAL_BSTR
    BYTE * GetTagPtr(void)
    {
        TCHAR *     pzEndTag;

        pzEndTag = data() + ( nAllocLength + 1 );

        return (BYTE *) pzEndTag;
    }

    int GetEndTag(void)
    {
        int         nEnd;

        memcpy( &nEnd, GetTagPtr(), sizeof(int) );

        return nEnd;
    }

    void SetEndTag( int nEnd )
    {
        memcpy( GetTagPtr(), &nEnd, sizeof(int) );
    }
#endif
};

// Globals

// For an empty string, m_pchData will point here
// (note: avoids special case of checking for NULL m_pchData)
// empty string data (and locked)

#ifdef VERIFY_LOCAL_BSTR

const int START_TAG = 0x01234567;
const int MIDDLE_TAG = 0x89abcdef;
const int END_TAG = 0xfedcba98;

_declspec(selectany) int rgInitData[] = { START_TAG, -1, 0, 0, MIDDLE_TAG, 0, 0, END_TAG };

#else

_declspec(selectany) int rgInitData[] = { -1, 0, 0, 0, 0 };

#endif

_declspec(selectany) CStringData* _atltmpDataNil = (CStringData*)&rgInitData;
_declspec(selectany) LPCTSTR _atltmpPchNil = (LPCTSTR)(((BYTE*)&rgInitData) + sizeof(CStringData));


class CString
{
public:
// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(TCHAR ch, int nRepeat = 1);
	CString(LPCSTR lpsz);
	CString(LPCWSTR lpsz);
	CString(LPCTSTR lpch, int nLength);
	CString(const unsigned char* psz);

#ifdef VERIFY_LOCAL_BSTR
    void VerifyInitData( void )
    {
        VerifyBlankData();

        CStringData *   pData = GetData();

        VerifyTagData( pData );
    }
#endif

// Attributes & Operations
	// as an array of characters
	int GetLength() const;
	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	TCHAR GetAt(int nIndex) const;      // 0 based
	TCHAR operator[](int nIndex) const; // same as GetAt
	void SetAt(int nIndex, TCHAR ch);
	operator LPCTSTR() const;           // as a C string
    operator BSTR() const;              // as a BSTR string

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(TCHAR ch);
	const CString& operator=(char ch);
	const CString& operator=(LPCSTR lpsz);
	const CString& operator=(LPCWSTR lpsz);
	const CString& operator=(const unsigned char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(TCHAR ch);
	const CString& operator+=(char ch);
	const CString& operator+=(LPCTSTR lpsz);

	friend CString __stdcall operator+(const CString& string1, const CString& string2);
	friend CString __stdcall operator+(const CString& string, TCHAR ch);
	friend CString __stdcall operator+(TCHAR ch, const CString& string);
	friend CString __stdcall operator+(const CString& string, char ch);
	friend CString __stdcall operator+(char ch, const CString& string);
	friend CString __stdcall operator+(const CString& string, LPCTSTR lpsz);
	friend CString __stdcall operator+(LPCTSTR lpsz, const CString& string);

	// string comparison
	int Compare(LPCTSTR lpsz) const;         // straight character
	int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
	int Collate(LPCTSTR lpsz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(LPCTSTR lpszCharSet) const;
	CString SpanExcluding(LPCTSTR lpszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// trimming whitespace (either side)
	void TrimRight();
	void TrimLeft();

	// advanced manipulation
	// replace occurrences of chOld with chNew
	int Replace(TCHAR chOld, TCHAR chNew);
	// replace occurrences of substring lpszOld with lpszNew;
	// empty lpszNew removes instances of lpszOld
	int Replace(LPCTSTR lpszOld, LPCTSTR lpszNew);
	// remove occurrences of chRemove
	int Remove(TCHAR chRemove);
	// insert character at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, TCHAR ch);
	// insert substring at zero-based index; concatenates
	// if index is past end of string
	int Insert(int nIndex, LPCTSTR pstr);
	// delete nCount characters starting at zero-based index
	int Delete(int nIndex, int nCount = 1);

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(TCHAR ch) const;               // like "C" strchr
	int ReverseFind(TCHAR ch) const;
	int FindOneOf(LPCTSTR lpszCharSet) const;

	// look for a specific sub-string
	int Find(LPCTSTR lpszSub) const;        // like "C" strstr

	// Concatentation for non strings
	const CString& Append(int n)
	{
		TCHAR szBuffer[10];
		wsprintf(szBuffer,_T("%d"),n);
		ConcatInPlace(SafeStrlen(szBuffer), szBuffer);
		return *this;
	}

	// simple formatting
	void __cdecl Format(LPCTSTR lpszFormat, ...);
	void __cdecl Format(UINT nFormatID, ...);

	// formatting for localization (uses FormatMessage API)
	BOOL __cdecl FormatMessage(LPCTSTR lpszFormat, ...);
	BOOL __cdecl FormatMessage(UINT nFormatID, ...);

	// Windows support
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max

#ifndef _ATL_NO_COM
	// OLE BSTR support (use for OLE automation)
	BSTR AllocSysString() const;
	BSTR SetSysString(BSTR* pbstr) const;
#endif //!_ATL_NO_COM

	// Access to string implementation buffer as "C" character array
	LPTSTR GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	LPTSTR GetBufferSetLength(int nNewLength);
	void FreeExtra();

	// Use LockBuffer/UnlockBuffer to turn refcounting off
	LPTSTR LockBuffer();
	void UnlockBuffer();

// Implementation
public:
	~CString();
	int GetAllocLength() const;

	static BOOL __stdcall _IsValidString(LPCWSTR lpsz, int nLength)
	{
		if(lpsz == NULL)
			return FALSE;
		return !::IsBadStringPtrW(lpsz, nLength);
	}

	static BOOL __stdcall _IsValidString(LPCSTR lpsz, int nLength)
	{
		if(lpsz == NULL)
			return FALSE;
		return !::IsBadStringPtrA(lpsz, nLength);
	}

protected:
	LPTSTR m_pchData;   // pointer to ref counted string data

	// implementation helpers
	CStringData* GetData() const;
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	BOOL AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
	BOOL ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
	void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
	void FormatV(LPCTSTR lpszFormat, va_list argList);
	void CopyBeforeWrite();
	BOOL AllocBeforeWrite(int nLen);
	void Release();
	static void PASCAL Release(CStringData* pData);
	static int PASCAL SafeStrlen(LPCTSTR lpsz);

	static int __stdcall _LoadString(UINT nID, LPTSTR lpszBuf, UINT nMaxBuf)
	{
#ifdef _DEBUG
		// LoadString without annoying warning from the Debug kernel if the
		//  segment containing the string is not present
		if (::FindResource(_Module.GetResourceInstance(), MAKEINTRESOURCE((nID>>4) + 1), RT_STRING) == NULL)
		{
			lpszBuf[0] = '\0';
			return 0; // not found
		}
#endif //_DEBUG
		int nLen = ::LoadString(_Module.GetResourceInstance(), nID, lpszBuf, nMaxBuf);
		if (nLen == 0)
			lpszBuf[0] = '\0';
		return nLen;
	}

#ifdef VERIFY_LOCAL_BSTR
    static void VerifyBlankData( void )
    {
        VERIFY_ASSERT( rgInitData[0] == START_TAG );
        VERIFY_ASSERT( rgInitData[1] == -1 );
        VERIFY_ASSERT( rgInitData[2] == 0 );
        VERIFY_ASSERT( rgInitData[3] == 0 );
        VERIFY_ASSERT( rgInitData[4] == MIDDLE_TAG );
        VERIFY_ASSERT( rgInitData[5] == 0 );
        VERIFY_ASSERT( rgInitData[6] == 0 );
        VERIFY_ASSERT( rgInitData[7] == END_TAG );
    }

    static void VerifyTagData( CStringData * pData )
    {
        if ( pData && pData != _atltmpDataNil )
        {
            VERIFY_ASSERT( pData->nStartTag == START_TAG );
            VERIFY_ASSERT( pData->nMiddleTag == MIDDLE_TAG );
            VERIFY_ASSERT( pData->GetEndTag() == END_TAG );
        }
    }
#endif

	static const CString& __stdcall _GetEmptyString()
	{
#ifdef VERIFY_LOCAL_BSTR
        VerifyBlankData();
#endif

		return *(CString*)&_atltmpPchNil;
	}

// CString conversion helpers
	static int __cdecl _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count)
	{
		if (count == 0 && mbstr != NULL)
			return 0;

		int result = ::WideCharToMultiByte(CP_ACP, 0, wcstr, -1, mbstr, (int)count, NULL, NULL);
		ATLASSERT(mbstr == NULL || result <= (int)count);
		if (result > 0)
			mbstr[result - 1] = 0;
		return result;
	}

	static int __cdecl _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count)
	{
		if (count == 0 && wcstr != NULL)
			return 0;

		int result = ::MultiByteToWideChar(CP_ACP, 0, mbstr, -1, wcstr, (int)count);
		ATLASSERT(wcstr == NULL || result <= (int)count);
		if (result > 0)
			wcstr[result - 1] = 0;
		return result;
	}

// Helpers to avoid CRT startup code
	static TCHAR* _cstrchr(const TCHAR* p, TCHAR ch)
	{
		//strchr for '\0' should succeed
		while (*p != 0)
		{
			if (*p == ch)
				break;
			p = ::CharNext(p);
		}
		return (TCHAR*)((*p == ch) ? p : NULL);
	}
	static TCHAR* _cstrchr_db(const TCHAR* p, TCHAR ch1, TCHAR ch2)
	{
		const TCHAR* lpsz = NULL;
		while (*p != 0)
		{
			if (*p == ch1 && *(p + 1) == ch2)
			{
				lpsz = p;
				break;
			}
			p = ::CharNext(p);
		}
		return (TCHAR*)lpsz;
	}
	static TCHAR* _cstrrchr(const TCHAR* p, TCHAR ch)
	{
		const TCHAR* lpsz = NULL;
		while (*p != 0)
		{
			if (*p == ch)
				lpsz = p;
			p = ::CharNext(p);
		}
		return (TCHAR*)lpsz;
	}
	static TCHAR* _cstrrev(TCHAR* pStr)
	{
		// Optimize NULL, zero-length, and single-char case.
		if ((pStr == NULL) || (pStr[0] == '\0') || (pStr[1] == '\0'))
			return pStr;

		TCHAR* p = pStr;

		while (p[1] != 0) 
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				char p1 = *(char*)p;
				*(char*)p = *(char*)(p + 1);
				*(char*)(p + 1) = p1;
			}
			p = pNext;
		}

		TCHAR* q = pStr;

		while (q < p)
		{
			TCHAR t = *q;
			*q = *p;
			*p = t;
			q++;
			p--;
		}
		return (TCHAR*)pStr;
	}
	static TCHAR* _cstrstr(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nLen = lstrlen(pCharSet);
		if (nLen == 0)
			return (TCHAR*)pStr;

		const TCHAR* pRet = NULL;
		const TCHAR* pCur = pStr;
		while((pStr = _cstrchr(pCur, *pCharSet)) != NULL)
		{
			if(memcmp(pCur, pCharSet, nLen * sizeof(TCHAR)) == 0)
			{
				pRet = pCur;
				break;
			}
			pCur = ::CharNext(pCur);
		}
		return (TCHAR*) pRet;
	}
	static int _cstrspn(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nRet = 0;
		TCHAR* p = (TCHAR*)pStr;
		while (*p != 0)
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				if(_cstrchr_db(pCharSet, *p, *(p + 1)) == NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(_cstrchr(pCharSet, *p) == NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static int _cstrcspn(const TCHAR* pStr, const TCHAR* pCharSet)
	{
		int nRet = 0;
		TCHAR* p = (TCHAR*)pStr;
		while (*p != 0)
		{
			TCHAR* pNext = ::CharNext(p);
			if(pNext > p + 1)
			{
				if(_cstrchr_db(pCharSet, *p, *(p + 1)) != NULL)
					break;
				nRet += 2;
			}
			else
			{
				if(_cstrchr(pCharSet, *p) != NULL)
					break;
				nRet++;
			}
			p = pNext;
		}
		return nRet;
	}
	static TCHAR* _cstrpbrk(const TCHAR* p, const TCHAR* lpszCharSet)
	{
		while (*p != 0)
		{
			if (_cstrchr(lpszCharSet, *p) != NULL)
			{
				return (TCHAR*)p;
				break;
			}
			p = ::CharNext(p);
		}
		return NULL;
	}

	static int _cstrisdigit(TCHAR ch)
	{
		WORD type;
		GetStringTypeEx(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_DIGIT) == C1_DIGIT;
	}

	static int _cstrisspace(TCHAR ch)
	{
		WORD type;
		GetStringTypeEx(GetThreadLocale(), CT_CTYPE1, &ch, 1, &type);
		return (type & C1_SPACE) == C1_SPACE;
	}

	static int _cstrcmp(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		return lstrcmp(pstrOne, pstrOther);
	}

	static int _cstrcmpi(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		return lstrcmpi(pstrOne, pstrOther);
	}

	static int _cstrcoll(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		int nRet = CompareString(GetThreadLocale(), 0, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet - 2;  // Convert to strcmp convention.  This really is documented.
	}

	static int _cstrcolli(const TCHAR* pstrOne, const TCHAR* pstrOther)
	{
		int nRet = CompareString(GetThreadLocale(), NORM_IGNORECASE, pstrOne, -1, pstrOther, -1);
		ATLASSERT(nRet != 0);
		return nRet - 2;  // Convert to strcmp convention.  This really is documented.
	}
};

// Compare helpers
bool __stdcall operator==(const CString& s1, const CString& s2);
bool __stdcall operator==(const CString& s1, LPCTSTR s2);
bool __stdcall operator==(LPCTSTR s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, const CString& s2);
bool __stdcall operator!=(const CString& s1, LPCTSTR s2);
bool __stdcall operator!=(LPCTSTR s1, const CString& s2);
bool __stdcall operator<(const CString& s1, const CString& s2);
bool __stdcall operator<(const CString& s1, LPCTSTR s2);
bool __stdcall operator<(LPCTSTR s1, const CString& s2);
bool __stdcall operator>(const CString& s1, const CString& s2);
bool __stdcall operator>(const CString& s1, LPCTSTR s2);
bool __stdcall operator>(LPCTSTR s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, const CString& s2);
bool __stdcall operator<=(const CString& s1, LPCTSTR s2);
bool __stdcall operator<=(LPCTSTR s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, const CString& s2);
bool __stdcall operator>=(const CString& s1, LPCTSTR s2);
bool __stdcall operator>=(LPCTSTR s1, const CString& s2);


/////////////////////////////////////////////////////////////////////////////
// CString Implementation

inline CStringData* CString::GetData() const
	{ ATLASSERT(m_pchData != NULL); return ((CStringData*)m_pchData) - 1; }
inline void CString::Init()
	{ m_pchData = _GetEmptyString().m_pchData; }
inline CString::CString(const unsigned char* lpsz)
	{ Init(); *this = (LPCSTR)lpsz; }
inline const CString& CString::operator=(const unsigned char* lpsz)
	{ *this = (LPCSTR)lpsz; return *this; }
inline const CString& CString::operator+=(char ch)
	{ *this += (TCHAR)ch; return *this; }
inline const CString& CString::operator=(char ch)
	{ *this = (TCHAR)ch; return *this; }
inline CString __stdcall operator+(const CString& string, char ch)
	{ return string + (TCHAR)ch; }
inline CString __stdcall operator+(char ch, const CString& string)
	{ return (TCHAR)ch + string; }

inline int CString::GetLength() const
	{ return GetData()->nDataLength; }
inline int CString::GetAllocLength() const
	{ return GetData()->nAllocLength; }
inline BOOL CString::IsEmpty() const
	{ return GetData()->nDataLength == 0; }
inline CString::operator LPCTSTR() const
	{ return m_pchData; }
inline CString::operator BSTR() const
    { return (BSTR) m_pchData; }
inline int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
	{ return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
inline int CString::Compare(LPCTSTR lpsz) const
	{ return _cstrcmp(m_pchData, lpsz); }    // MBCS/Unicode aware
inline int CString::CompareNoCase(LPCTSTR lpsz) const
	{ return _cstrcmpi(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
inline int CString::Collate(LPCTSTR lpsz) const
	{ return _cstrcoll(m_pchData, lpsz); }   // locale sensitive

inline TCHAR CString::GetAt(int nIndex) const
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline TCHAR CString::operator[](int nIndex) const
{
	// same as GetAt
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);
	return m_pchData[nIndex];
}
inline bool __stdcall operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) == 0; }
inline bool __stdcall operator==(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }
inline bool __stdcall operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) != 0; }
inline bool __stdcall operator!=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }
inline bool __stdcall operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) < 0; }
inline bool __stdcall operator<(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
inline bool __stdcall operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) > 0; }
inline bool __stdcall operator>(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
inline bool __stdcall operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) <= 0; }
inline bool __stdcall operator<=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
inline bool __stdcall operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(const CString& s1, LPCTSTR s2)
	{ return s1.Compare(s2) >= 0; }
inline bool __stdcall operator>=(LPCTSTR s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

inline CString::CString()
{
	Init();
}

inline CString::CString(const CString& stringSrc)
{
	ATLASSERT(stringSrc.GetData()->nRefs != 0);
	if (stringSrc.GetData()->nRefs >= 0)
	{
		ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
		m_pchData = stringSrc.m_pchData;
		InterlockedIncrement(&GetData()->nRefs);
	}
	else
	{
		Init();
		*this = stringSrc.m_pchData;
	}
}

inline BOOL CString::AllocBuffer(int nLen)
// always allocate one extra character for '\0' termination
// assumes [optimistically] that data length will equal allocation length
{
	ATLASSERT(nLen >= 0);
	ATLASSERT(nLen <= INT_MAX - 1);    // max size (enough room for 1 extra)

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

	if (nLen == 0)
	{
		Init();
	}
	else
	{
		CStringData* pData = NULL;
        int cbBufLen = sizeof(CStringData) + (nLen + 1) * sizeof(TCHAR);

#ifdef VERIFY_LOCAL_BSTR
        cbBufLen += sizeof(int);        // End Tag
#endif

		ATLTRY(pData = (CStringData*)new BYTE[ cbBufLen ]);
		if(pData == NULL)
			return FALSE;

		pData->nRefs = 1;
		pData->data()[nLen] = '\0';
        pData->SetDataLength( nLen );
		pData->nAllocLength = nLen;
		m_pchData = pData->data();

#ifdef VERIFY_LOCAL_BSTR
        pData->nStartTag = START_TAG;
        pData->nMiddleTag = MIDDLE_TAG;
        pData->SetEndTag( END_TAG );
#endif
	}

	return TRUE;
}

inline void CString::Release()
{
#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

	if (GetData() != _atltmpDataNil)
	{
        ASSERT( 0 != GetData()->nRefs );
		if (InterlockedDecrement(&GetData()->nRefs) == 0)
        {
			delete[] (BYTE*)GetData();
        }
		Init();
	}
}

inline void PASCAL CString::Release(CStringData* pData)
{
#ifdef VERIFY_LOCAL_BSTR
    VerifyBlankData();
    VerifyTagData( pData );
#endif

	if (pData != _atltmpDataNil)
	{
        ASSERT( 0 != pData->nRefs );
		if (InterlockedDecrement(&pData->nRefs) == 0)
        {
			delete[] (BYTE*)pData;
        }
	}
}

inline void CString::Empty()
{
	if (GetData()->nDataLength == 0)
		return;

	if (GetData()->nRefs >= 0)
		Release();
	else
		*this = _T("");

	ATLASSERT(GetData()->nDataLength == 0);
	ATLASSERT(GetData()->nRefs < 0 || GetData()->nAllocLength == 0);

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif
}

inline void CString::CopyBeforeWrite()
{
	if (GetData()->nRefs > 1)
	{
		CStringData* pData = GetData();
		Release();
		if(AllocBuffer(pData->nDataLength))
        {
			memcpy(m_pchData, pData->data(), (pData->nDataLength + 1) * sizeof(TCHAR));
        }
	}
	ATLASSERT(GetData()->nRefs <= 1);
}

inline BOOL CString::AllocBeforeWrite(int nLen)
{
	BOOL bRet = TRUE;
	if (GetData()->nRefs > 1 || nLen > GetData()->nAllocLength)
	{
		Release();
		bRet = AllocBuffer(nLen);
	}
	ATLASSERT(GetData()->nRefs <= 1);
	return bRet;
}

inline CString::~CString()
//  free any attached data
{
#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

	if (GetData() != _atltmpDataNil)
	{
        ASSERT( 0 != GetData()->nRefs );
		if (InterlockedDecrement(&GetData()->nRefs) == 0)
        {
			delete[] (BYTE*)GetData();
        }
	}
}

inline void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
	 int nExtraLen) const
{
	// will clone the data attached to this string
	// allocating 'nExtraLen' characters
	// Places results in uninitialized string 'dest'
	// Will copy the part or all of original data to start of new string

	int nNewLen = nCopyLen + nExtraLen;
	if (nNewLen == 0)
	{
		dest.Init();
	}
	else
	{
		if(dest.AllocBuffer(nNewLen))
			memcpy(dest.m_pchData, m_pchData + nCopyIndex, nCopyLen * sizeof(TCHAR));
	}
}

inline CString::CString(LPCTSTR lpsz)
{
	Init();
	if (lpsz != NULL && HIWORD(lpsz) == NULL)
	{
		UINT nID = LOWORD((DWORD_PTR)lpsz);
		if (!LoadString(nID))
			ATLTRACE2(atlTraceUI, 0, _T("Warning: implicit LoadString(%u) in CString failed\n"), nID);
	}
	else
	{
		int nLen = SafeStrlen(lpsz);
		if (nLen != 0)
		{
			if(AllocBuffer(nLen))
				memcpy(m_pchData, lpsz, nLen * sizeof(TCHAR));
		}
	}
}

inline CString::CString(LPCSTR lpsz)
{
	Init();
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if (nSrcLen != 0)
	{
		if(AllocBuffer(nSrcLen))
		{
			_mbstowcsz(m_pchData, lpsz, nSrcLen + 1);
			ReleaseBuffer();
		}
	}
}

// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

inline void CString::AssignCopy(int nSrcLen, LPCTSTR lpszSrcData)
{
	if(AllocBeforeWrite(nSrcLen))
	{
		memcpy(m_pchData, lpszSrcData, nSrcLen * sizeof(TCHAR));
		GetData()->SetDataLength( nSrcLen );
		m_pchData[nSrcLen] = '\0';
	}
}

inline const CString& CString::operator=(const CString& stringSrc)
{
	if (m_pchData != stringSrc.m_pchData)
	{
		if ((GetData()->nRefs < 0 && GetData() != _atltmpDataNil) || stringSrc.GetData()->nRefs < 0)
		{
			// actual copy necessary since one of the strings is locked
			AssignCopy(stringSrc.GetData()->nDataLength, stringSrc.m_pchData);
		}
		else
		{
			// can just copy references around
			Release();
			ATLASSERT(stringSrc.GetData() != _atltmpDataNil);
			m_pchData = stringSrc.m_pchData;
			InterlockedIncrement(&GetData()->nRefs);
		}
	}
	return *this;
}

inline const CString& CString::operator=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || _IsValidString(lpsz, FALSE));
	AssignCopy(SafeStrlen(lpsz), lpsz);
	return *this;
}

inline const CString& CString::operator=(LPCSTR lpsz)
{
	int nSrcLen = lpsz != NULL ? lstrlenA(lpsz) : 0;
	if(AllocBeforeWrite(nSrcLen))
	{
		_mbstowcsz(m_pchData, lpsz, nSrcLen + 1);
		ReleaseBuffer();
	}
	return *this;
}

// Concatenation
// NOTE: "operator+" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = TCHAR, LPCTSTR
//          CString + ?
//          ? + CString

inline BOOL CString::ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data,
	int nSrc2Len, LPCTSTR lpszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

	BOOL bRet = TRUE;
	int nNewLen = nSrc1Len + nSrc2Len;
	if (nNewLen != 0)
	{
		bRet = AllocBuffer(nNewLen);
		if (bRet)
		{
			memcpy(m_pchData, lpszSrc1Data, nSrc1Len * sizeof(TCHAR));
			memcpy(m_pchData + nSrc1Len, lpszSrc2Data, nSrc2Len * sizeof(TCHAR));
		}
	}
	return bRet;
}

inline CString __stdcall operator+(const CString& string1, const CString& string2)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, string2.GetData()->nDataLength, string2.m_pchData);
	return s;
}

inline CString __stdcall operator+(const CString& string, LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(string.GetData()->nDataLength, string.m_pchData, CString::SafeStrlen(lpsz), lpsz);
	return s;
}

inline CString __stdcall operator+(LPCTSTR lpsz, const CString& string)
{
	ATLASSERT(lpsz == NULL || CString::_IsValidString(lpsz, FALSE));
	CString s;
	s.ConcatCopy(CString::SafeStrlen(lpsz), lpsz, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline void CString::ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData)
{
	//  -- the main routine for += operators

	// concatenating an empty string is a no-op!
	if (nSrcLen == 0)
		return;

	// if the buffer is too small, or we have a width mis-match, just
	//   allocate a new buffer (slow but sure)
	if (GetData()->nRefs > 1 || GetData()->nDataLength + nSrcLen > GetData()->nAllocLength)
	{
		// we have to grow the buffer, use the ConcatCopy routine
		CStringData* pOldData = GetData();
		if (ConcatCopy(GetData()->nDataLength, m_pchData, nSrcLen, lpszSrcData))
		{
			ATLASSERT(pOldData != NULL);
			CString::Release(pOldData);
		}
	}
	else
	{
		// fast concatenation when buffer big enough
		memcpy(m_pchData + GetData()->nDataLength, lpszSrcData, nSrcLen * sizeof(TCHAR));
		GetData()->SetDataLength( GetData()->nDataLength + nSrcLen );
		ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
		m_pchData[GetData()->nDataLength] = '\0';
	}
}

inline const CString& CString::operator+=(LPCTSTR lpsz)
{
	ATLASSERT(lpsz == NULL || _IsValidString(lpsz, FALSE));
	ConcatInPlace(SafeStrlen(lpsz), lpsz);
	return *this;
}

inline const CString& CString::operator+=(TCHAR ch)
{
	ConcatInPlace(1, &ch);
	return *this;
}

inline const CString& CString::operator+=(const CString& string)
{
	ConcatInPlace(string.GetData()->nDataLength, string.m_pchData);
	return *this;
}

inline LPTSTR CString::GetBuffer(int nMinBufLength)
{
	ATLASSERT(nMinBufLength >= 0);

	if (GetData()->nRefs > 1 || nMinBufLength > GetData()->nAllocLength)
	{
		// we have to grow the buffer
		CStringData* pOldData = GetData();
		int nOldLen = GetData()->nDataLength;   // AllocBuffer will tromp it
		if (nMinBufLength < nOldLen)
			nMinBufLength = nOldLen;

		if(AllocBuffer(nMinBufLength))
		{
			memcpy(m_pchData, pOldData->data(), (nOldLen + 1) * sizeof(TCHAR));
            GetData()->SetDataLength( nOldLen );
			CString::Release(pOldData);
		}
	}

	ATLASSERT(GetData()->nRefs <= 1);

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

    // return a pointer to the character storage for this string
	ATLASSERT(m_pchData != NULL);
	return m_pchData;
}

inline void CString::ReleaseBuffer(int nNewLength)
{
	CopyBeforeWrite();  // just in case GetBuffer was not called

    if (nNewLength == -1)
		nNewLength = lstrlen(m_pchData); // zero terminated

	ATLASSERT(nNewLength <= GetData()->nAllocLength);
    GetData()->SetDataLength( nNewLength );
	m_pchData[nNewLength] = '\0';

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif
}

inline LPTSTR CString::GetBufferSetLength(int nNewLength)
{
	ATLASSERT(nNewLength >= 0);

	GetBuffer(nNewLength);

    if ( GetAllocLength() >= nNewLength )
    {
        GetData()->SetDataLength( nNewLength );
	    m_pchData[nNewLength] = '\0';
    }

#ifdef VERIFY_LOCAL_BSTR
    VerifyInitData();
#endif

	return m_pchData;
}

inline void CString::FreeExtra()
{
	ATLASSERT(GetData()->nDataLength <= GetData()->nAllocLength);
	if (GetData()->nDataLength != GetData()->nAllocLength)
	{
		CStringData* pOldData = GetData();
		if(AllocBuffer(GetData()->nDataLength))
		{
			memcpy(m_pchData, pOldData->data(), pOldData->nDataLength * sizeof(TCHAR));
			ATLASSERT(m_pchData[GetData()->nDataLength] == '\0');
			CString::Release(pOldData);
		}
	}
	ATLASSERT(GetData() != NULL);
}

inline LPTSTR CString::LockBuffer()
{
	LPTSTR lpsz = GetBuffer(0);
	GetData()->nRefs = -1;
	return lpsz;
}

inline void CString::UnlockBuffer()
{
	ATLASSERT(GetData()->nRefs == -1);
	if (GetData() != _atltmpDataNil)
		GetData()->nRefs = 1;
}

inline int CString::Find(TCHAR ch) const
{
	// find first single character
	LPTSTR lpsz = _cstrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found and index otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline int CString::FindOneOf(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	LPTSTR lpsz = _cstrpbrk(m_pchData, lpszCharSet);
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::MakeUpper()
{
	CopyBeforeWrite();
	CharUpper(m_pchData);
}

inline void CString::MakeLower()
{
	CopyBeforeWrite();
	CharLower(m_pchData);
}

inline void CString::MakeReverse()
{
	CopyBeforeWrite();
	_cstrrev(m_pchData);
}

inline void CString::SetAt(int nIndex, TCHAR ch)
{
	ATLASSERT(nIndex >= 0);
	ATLASSERT(nIndex < GetData()->nDataLength);

	CopyBeforeWrite();
	m_pchData[nIndex] = ch;
}

inline CString::CString(TCHAR ch, int nLength)
{
	ATLASSERT(!_istlead(ch));    // can't create a lead byte string
	Init();
	if (nLength >= 1)
	{
		if(AllocBuffer(nLength))
		{
			for (int i = 0; i < nLength; i++)
				m_pchData[i] = ch;
		}
	}
}

inline CString::CString(LPCTSTR lpch, int nLength)
{
	Init();
	if (nLength != 0)
	{
		if(AllocBuffer(nLength))
			memcpy(m_pchData, lpch, nLength * sizeof(TCHAR));
	}
}

inline const CString& CString::operator=(TCHAR ch)
{
	ATLASSERT(!_istlead(ch));    // can't set single lead byte
	AssignCopy(1, &ch);
	return *this;
}

inline CString __stdcall operator+(const CString& string1, TCHAR ch)
{
	CString s;
	s.ConcatCopy(string1.GetData()->nDataLength, string1.m_pchData, 1, &ch);
	return s;
}

inline CString __stdcall operator+(TCHAR ch, const CString& string)
{
	CString s;
	s.ConcatCopy(1, &ch, string.GetData()->nDataLength, string.m_pchData);
	return s;
}

inline CString CString::Mid(int nFirst) const
{
	return Mid(nFirst, GetData()->nDataLength - nFirst);
}

inline CString CString::Mid(int nFirst, int nCount) const
{
	// out-of-bounds requests return sensible things
	if (nFirst < 0)
		nFirst = 0;
	if (nCount < 0)
		nCount = 0;

	if (nFirst + nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength - nFirst;
	if (nFirst > GetData()->nDataLength)
		nCount = 0;

	CString dest;
	AllocCopy(dest, nCount, nFirst, 0);
	return dest;
}

inline CString CString::Right(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, GetData()->nDataLength-nCount, 0);
	return dest;
}

inline CString CString::Left(int nCount) const
{
	if (nCount < 0)
		nCount = 0;
	else if (nCount > GetData()->nDataLength)
		nCount = GetData()->nDataLength;

	CString dest;
	AllocCopy(dest, nCount, 0, 0);
	return dest;
}

// strspn equivalent
inline CString CString::SpanIncluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	return Left(_cstrspn(m_pchData, lpszCharSet));
}

// strcspn equivalent
inline CString CString::SpanExcluding(LPCTSTR lpszCharSet) const
{
	ATLASSERT(_IsValidString(lpszCharSet, FALSE));
	return Left(_cstrcspn(m_pchData, lpszCharSet));
}

inline int CString::ReverseFind(TCHAR ch) const
{
	// find last single character
	LPTSTR lpsz = _cstrrchr(m_pchData, (_TUCHAR)ch);

	// return -1 if not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

// find a sub-string (like strstr)
inline int CString::Find(LPCTSTR lpszSub) const
{
	ATLASSERT(_IsValidString(lpszSub, FALSE));

	// find first matching substring
	LPTSTR lpsz = _cstrstr(m_pchData, lpszSub);

	// return -1 for not found, distance from beginning otherwise
	return (lpsz == NULL) ? -1 : (int)(lpsz - m_pchData);
}

inline void CString::FormatV(LPCTSTR lpszFormat, va_list argList)
{
	ATLASSERT(_IsValidString(lpszFormat, FALSE));

	enum _FormatModifiers
	{
		FORCE_ANSI =	0x10000,
		FORCE_UNICODE =	0x20000,
		FORCE_INT64 =	0x40000
	};

	va_list argListSave = argList;

	// make a guess at the maximum length of the resulting string
	int nMaxLen = 0;
	for (LPCTSTR lpsz = lpszFormat; *lpsz != '\0'; lpsz = ::CharNext(lpsz))
	{
		// handle '%' character, but watch out for '%%'
		if (*lpsz != '%' || *(lpsz = ::CharNext(lpsz)) == '%')
		{
			nMaxLen += (int)lstrlen(lpsz);
			continue;
		}

		int nItemLen = 0;

		// handle '%' character with format
		int nWidth = 0;
		for (; *lpsz != '\0'; lpsz = ::CharNext(lpsz))
		{
			// check for valid flags
			if (*lpsz == '#')
				nMaxLen += 2;   // for '0x'
			else if (*lpsz == '*')
				nWidth = va_arg(argList, int);
			else if (*lpsz == '-' || *lpsz == '+' || *lpsz == '0' || *lpsz == ' ')
				;
			else // hit non-flag character
				break;
		}
		// get width and skip it
		if (nWidth == 0)
		{
			// width indicated by
			nWidth = _ttoi(lpsz);
			for (; *lpsz != '\0' && _cstrisdigit(*lpsz); lpsz = ::CharNext(lpsz))
				;
		}
		ATLASSERT(nWidth >= 0);

		int nPrecision = 0;
		if (*lpsz == '.')
		{
			// skip past '.' separator (width.precision)
			lpsz = ::CharNext(lpsz);

			// get precision and skip it
			if (*lpsz == '*')
			{
				nPrecision = va_arg(argList, int);
				lpsz = ::CharNext(lpsz);
			}
			else
			{
				nPrecision = _ttoi(lpsz);
				for (; *lpsz != '\0' && _cstrisdigit(*lpsz); lpsz = ::CharNext(lpsz))
					;
			}
			ATLASSERT(nPrecision >= 0);
		}

		// should be on type modifier or specifier
		int nModifier = 0;
		if(lpsz[0] == _T('I') && lpsz[1] == _T('6') && lpsz[2] == _T('4'))
		{
			lpsz += 3;
			nModifier = FORCE_INT64;
		}
		else
		{
			switch (*lpsz)
			{
			// modifiers that affect size
			case 'h':
				nModifier = FORCE_ANSI;
				lpsz = ::CharNext(lpsz);
				break;
			case 'l':
				nModifier = FORCE_UNICODE;
				lpsz = ::CharNext(lpsz);
				break;

			// modifiers that do not affect size
			case 'F':
			case 'N':
			case 'L':
				lpsz = ::CharNext(lpsz);
				break;
			}
		}

		// now should be on specifier
		switch (*lpsz | nModifier)
		{
		// single characters
		case 'c':
		case 'C':
			nItemLen = 2;
			va_arg(argList, TCHAR);
			break;
		case 'c' | FORCE_ANSI:
		case 'C' | FORCE_ANSI:
			nItemLen = 2;
			va_arg(argList, char);
			break;
		case 'c' | FORCE_UNICODE:
		case 'C' | FORCE_UNICODE:
			nItemLen = 2;
			va_arg(argList, WCHAR);
			break;

		// strings
		case 's':
		{
			LPCTSTR pstrNextArg = va_arg(argList, LPCTSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6;  // "(null)"
			}
			else
			{
				nItemLen = lstrlen(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 'S':
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = lstrlenA(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 's' | FORCE_ANSI:
		case 'S' | FORCE_ANSI:
		{
			LPCSTR pstrNextArg = va_arg(argList, LPCSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = lstrlenA(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}

		case 's' | FORCE_UNICODE:
		case 'S' | FORCE_UNICODE:
		{
			LPWSTR pstrNextArg = va_arg(argList, LPWSTR);
			if (pstrNextArg == NULL)
			{
				nItemLen = 6; // "(null)"
			}
			else
			{
				nItemLen = (int)wcslen(pstrNextArg);
				nItemLen = max(1, nItemLen);
			}
			break;
		}
		}

		// adjust nItemLen for strings
		if (nItemLen != 0)
		{
			nItemLen = max(nItemLen, nWidth);
			if (nPrecision != 0)
				nItemLen = min(nItemLen, nPrecision);
		}
		else
		{
			switch (*lpsz)
			{
			// integers
			case 'd':
			case 'i':
			case 'u':
			case 'x':
			case 'X':
			case 'o':
				if (nModifier & FORCE_INT64)
					va_arg(argList, __int64);
				else
					va_arg(argList, int);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;

#ifndef _ATL_USE_CSTRING_FLOAT
			case 'e':
			case 'f':
			case 'g':
			case 'G':
				ATLASSERT(!"Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class.");
#ifndef _DEBUG
				::OutputDebugString(_T("Floating point (%%e, %%f, %%g, and %%G) is not supported by the WTL::CString class."));
				::DebugBreak();
#endif //!_DEBUG
				break;
#else //_ATL_USE_CSTRING_FLOAT
			case 'e':
			case 'g':
			case 'G':
				va_arg(argList, double);
				nItemLen = 128;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;
			case 'f':
				{
					double f;
					LPTSTR pszTemp;

					// 312 == strlen("-1+(309 zeroes).")
					// 309 zeroes == max precision of a double
					// 6 == adjustment in case precision is not specified,
					//   which means that the precision defaults to 6
					pszTemp = (LPTSTR)_alloca(max(nWidth, 312 + nPrecision + 6));

					f = va_arg(argList, double);
					_stprintf(pszTemp, _T( "%*.*f" ), nWidth, nPrecision + 6, f);
					nItemLen = _tcslen(pszTemp);
				}
				break;
#endif //_ATL_USE_CSTRING_FLOAT

			case 'p':
				va_arg(argList, void*);
				nItemLen = 32;
				nItemLen = max(nItemLen, nWidth + nPrecision);
				break;

			// no output
			case 'n':
				va_arg(argList, int*);
				break;

			default:
				ATLASSERT(FALSE);  // unknown formatting option
			}
		}

		// adjust nMaxLen for output nItemLen
		nMaxLen += nItemLen;
	}

	GetBuffer(nMaxLen);
#ifndef _ATL_USE_CSTRING_FLOAT
	int nRet = wvsprintf(m_pchData, lpszFormat, argListSave);
#else //_ATL_USE_CSTRING_FLOAT
	int nRet = _vstprintf(m_pchData, lpszFormat, argListSave);
#endif //_ATL_USE_CSTRING_FLOAT
	nRet;	// ref
	ATLASSERT(nRet <= GetAllocLength());
	ReleaseBuffer();

	va_end(argListSave);
}

// formatting (using wsprintf style formatting)
inline void __cdecl CString::Format(LPCTSTR lpszFormat, ...)
{
	ATLASSERT(_IsValidString(lpszFormat, FALSE));

	va_list argList;
	va_start(argList, lpszFormat);
	FormatV(lpszFormat, argList);
	va_end(argList);
}

inline void __cdecl CString::Format(UINT nFormatID, ...)
{
	CString strFormat;
	BOOL bRet = strFormat.LoadString(nFormatID);
	bRet;	// ref
	ATLASSERT(bRet != 0);

	va_list argList;
	va_start(argList, nFormatID);
	FormatV(strFormat, argList);
	va_end(argList);
}

// formatting (using FormatMessage style formatting)
inline BOOL __cdecl CString::FormatMessage(LPCTSTR lpszFormat, ...)
{
	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, lpszFormat);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
			lpszFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free the temporary
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline BOOL __cdecl CString::FormatMessage(UINT nFormatID, ...)
{
	// get format string from string table
	CString strFormat;
	BOOL bRetTmp = strFormat.LoadString(nFormatID);
	bRetTmp;	// ref
	ATLASSERT(bRetTmp != 0);

	// format message into temporary buffer lpszTemp
	va_list argList;
	va_start(argList, nFormatID);
	LPTSTR lpszTemp;
	BOOL bRet = TRUE;

	if (::FormatMessage(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
			(LPCTSTR)strFormat, 0, 0, (LPTSTR)&lpszTemp, 0, &argList) == 0 || lpszTemp == NULL)
		bRet = FALSE;

	// assign lpszTemp into the resulting string and free lpszTemp
	*this = lpszTemp;
	LocalFree(lpszTemp);
	va_end(argList);
	return bRet;
}

inline void CString::TrimRight()
{
	CopyBeforeWrite();

	// find beginning of trailing spaces by starting at beginning (DBCS aware)
	LPTSTR lpsz = m_pchData;
	LPTSTR lpszLast = NULL;
	while (*lpsz != '\0')
	{
		if (_cstrisspace(*lpsz))
		{
			if (lpszLast == NULL)
				lpszLast = lpsz;
		}
		else
		{
			lpszLast = NULL;
		}
		lpsz = ::CharNext(lpsz);
	}

	if (lpszLast != NULL)
	{
		// truncate at trailing space start
		*lpszLast = '\0';
        GetData()->SetDataLength( (int)(DWORD_PTR)(lpszLast - m_pchData) );
	}
}

inline void CString::TrimLeft()
{
	CopyBeforeWrite();

	// find first non-space character
	LPCTSTR lpsz = m_pchData;
	while (_cstrisspace(*lpsz))
		lpsz = ::CharNext(lpsz);

	// fix up data and length
	int nDataLength = GetData()->nDataLength - (int)(DWORD_PTR)(lpsz - m_pchData);
	memmove(m_pchData, lpsz, (nDataLength + 1) * sizeof(TCHAR));
    GetData()->SetDataLength( nDataLength );
}

inline int CString::Delete(int nIndex, int nCount /* = 1 */)
{
	if (nIndex < 0)
		nIndex = 0;
	int nNewLength = GetData()->nDataLength;
	if (nCount > 0 && nIndex < nNewLength)
	{
		CopyBeforeWrite();
		int nBytesToCopy = nNewLength - (nIndex + nCount) + 1;

		memmove(m_pchData + nIndex, m_pchData + nIndex + nCount, nBytesToCopy * sizeof(TCHAR));
        GetData()->SetDataLength( nNewLength - nCount );
	}

	return nNewLength;
}

inline int CString::Insert(int nIndex, TCHAR ch)
{
	CopyBeforeWrite();

	if (nIndex < 0)
		nIndex = 0;

	int nNewLength = GetData()->nDataLength;
	if (nIndex > nNewLength)
		nIndex = nNewLength;
	nNewLength++;

	if (GetData()->nAllocLength < nNewLength)
	{
		CStringData* pOldData = GetData();
		LPTSTR pstr = m_pchData;
		if(!AllocBuffer(nNewLength))
			return -1;
		memcpy(m_pchData, pstr, (pOldData->nDataLength + 1) * sizeof(TCHAR));
		CString::Release(pOldData);
	}

	// move existing bytes down
	memmove(m_pchData + nIndex + 1, m_pchData + nIndex, (nNewLength - nIndex) * sizeof(TCHAR));
	m_pchData[nIndex] = ch;
    GetData()->SetDataLength( nNewLength );

	return nNewLength;
}

inline int CString::Insert(int nIndex, LPCTSTR pstr)
{
	if (nIndex < 0)
		nIndex = 0;

	int nInsertLength = SafeStrlen(pstr);
	int nNewLength = GetData()->nDataLength;
	if (nInsertLength > 0)
	{
		CopyBeforeWrite();
		if (nIndex > nNewLength)
			nIndex = nNewLength;
		nNewLength += nInsertLength;

		if (GetData()->nAllocLength < nNewLength)
		{
			CStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			if(!AllocBuffer(nNewLength))
				return -1;
			memcpy(m_pchData, pstr, (pOldData->nDataLength + 1) * sizeof(TCHAR));
			CString::Release(pOldData);
		}

		// move existing bytes down
		memmove(m_pchData + nIndex + nInsertLength, m_pchData + nIndex, (nNewLength - nIndex - nInsertLength + 1) * sizeof(TCHAR));
		memcpy(m_pchData + nIndex, pstr, nInsertLength * sizeof(TCHAR));
        GetData()->SetDataLength( nNewLength );
	}

	return nNewLength;
}

inline int CString::Replace(TCHAR chOld, TCHAR chNew)
{
	int nCount = 0;

	// short-circuit the nop case
	if (chOld != chNew)
	{
		// otherwise modify each character that matches in the string
		CopyBeforeWrite();
		LPTSTR psz = m_pchData;
		LPTSTR pszEnd = psz + GetData()->nDataLength;
		while (psz < pszEnd)
		{
			// replace instances of the specified character only
			if (*psz == chOld)
			{
				*psz = chNew;
				nCount++;
			}
			psz = ::CharNext(psz);
		}
	}
	return nCount;
}

inline int CString::Replace(LPCTSTR lpszOld, LPCTSTR lpszNew)
{
	// can't have empty or NULL lpszOld

	int nSourceLen = SafeStrlen(lpszOld);
	if (nSourceLen == 0)
		return 0;
	int nReplacementLen = SafeStrlen(lpszNew);

	// loop once to figure out the size of the result string
	int nCount = 0;
	LPTSTR lpszStart = m_pchData;
	LPTSTR lpszEnd = m_pchData + GetData()->nDataLength;
	LPTSTR lpszTarget;
	while (lpszStart < lpszEnd)
	{
		while ((lpszTarget = _cstrstr(lpszStart, lpszOld)) != NULL)
		{
			nCount++;
			lpszStart = lpszTarget + nSourceLen;
		}
		lpszStart += lstrlen(lpszStart) + 1;
	}

	// if any changes were made, make them
	if (nCount > 0)
	{
		CopyBeforeWrite();

		// if the buffer is too small, just
		//   allocate a new buffer (slow but sure)
		int nOldLength = GetData()->nDataLength;
		int nNewLength =  nOldLength + (nReplacementLen - nSourceLen) * nCount;
		if (GetData()->nAllocLength < nNewLength || GetData()->nRefs > 1)
		{
			CStringData* pOldData = GetData();
			LPTSTR pstr = m_pchData;
			if(!AllocBuffer(nNewLength))
				return -1;
			memcpy(m_pchData, pstr, pOldData->nDataLength * sizeof(TCHAR));
			CString::Release(pOldData);
		}
		// else, we just do it in-place
		lpszStart = m_pchData;
		lpszEnd = m_pchData + GetData()->nDataLength;

		// loop again to actually do the work
		while (lpszStart < lpszEnd)
		{
			while ( (lpszTarget = _cstrstr(lpszStart, lpszOld)) != NULL)
			{
				int nBalance = nOldLength - ((int)(DWORD_PTR)(lpszTarget - m_pchData) + nSourceLen);
				memmove(lpszTarget + nReplacementLen, lpszTarget + nSourceLen, nBalance * sizeof(TCHAR));
				memcpy(lpszTarget, lpszNew, nReplacementLen * sizeof(TCHAR));
				lpszStart = lpszTarget + nReplacementLen;
				lpszStart[nBalance] = '\0';
				nOldLength += (nReplacementLen - nSourceLen);
			}
			lpszStart += lstrlen(lpszStart) + 1;
		}
		ATLASSERT(m_pchData[nNewLength] == '\0');
        GetData()->SetDataLength( nNewLength );
	}

	return nCount;
}

inline int CString::Remove(TCHAR chRemove)
{
	CopyBeforeWrite();

	LPTSTR pstrSource = m_pchData;
	LPTSTR pstrDest = m_pchData;
	LPTSTR pstrEnd = m_pchData + GetData()->nDataLength;

	while (pstrSource < pstrEnd)
	{
		if (*pstrSource != chRemove)
		{
			*pstrDest = *pstrSource;
			pstrDest = ::CharNext(pstrDest);
		}
		pstrSource = ::CharNext(pstrSource);
	}
	*pstrDest = '\0';
	int nCount = (int)(DWORD_PTR)(pstrSource - pstrDest);
    GetData()->SetDataLength( GetData()->nDataLength - nCount );

    return nCount;
}

#define CHAR_FUDGE 1    // one TCHAR unused is good enough

inline BOOL CString::LoadString(UINT nID)
{
	// try fixed buffer first (to avoid wasting space in the heap)
	TCHAR szTemp[256];
	int nCount =  sizeof(szTemp) / sizeof(szTemp[0]);
	int nLen = _LoadString(nID, szTemp, nCount);
	if (nCount - nLen > CHAR_FUDGE)
	{
		*this = szTemp;
		return nLen > 0;
	}

	// try buffer size of 512, then larger size until entire string is retrieved
	int nSize = 256;
	do
	{
		nSize += 256;
		nLen = _LoadString(nID, GetBuffer(nSize - 1), nSize);
	} while (nSize - nLen <= CHAR_FUDGE);
	ReleaseBuffer();

	return nLen > 0;
}

#ifndef _ATL_NO_COM
inline BSTR CString::AllocSysString() const
{
	BSTR bstr = ::SysAllocStringLen(m_pchData, GetData()->nDataLength);
	return bstr;
}

inline BSTR CString::SetSysString(BSTR* pbstr) const
{
	::SysReAllocStringLen(pbstr, m_pchData, GetData()->nDataLength);
	ATLASSERT(*pbstr != NULL);
	return *pbstr;
}
#endif //!_ATL_NO_COM

#endif //!_WTL_NO_CSTRING

}; //namespace LBSTR

#endif // _UNICODE

#endif // __LOCAL_BSTR__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\isos.c ===
#include <shlwapi.h>
#include <regstr.h>

#if (_WIN32_WINNT >= 0x0500)
#include <lm.h> // for NetGetJoinInformation
#endif

// stolen from winuser
#ifndef SM_REMOTESESSION
#define SM_REMOTESESSION        0x1000
#endif


BOOL IsWinlogonRegValueSet(HKEY hKey, LPSTR pszKeyName, LPSTR pszPolicyKeyName, LPSTR pszValueName)
{
    BOOL bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;
    HKEY hkey;

    //  first check the per-machine location.
    if (RegOpenKeyExA(hKey, pszKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bRet);
        if (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)&bRet, &dwSize) == ERROR_SUCCESS)
        {
            if (dwType != REG_DWORD)
            {
                bRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }
    
    //  then let the policy value override
    if (RegOpenKeyExA(hKey, pszPolicyKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(bRet);
        if (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)&bRet, &dwSize) == ERROR_SUCCESS)
        {
            if (dwType != REG_DWORD)
            {
                bRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }

    return bRet;
}

BOOL IsWinlogonRegValuePresent(HKEY hKey, LPSTR pszKeyName, LPSTR pszValueName)
{
    BOOL bRet = FALSE;
    DWORD dwType;
    DWORD dwSize;
    HKEY hkey;

    //  first check the per-machine location.
    if (RegOpenKeyExA(hKey, pszKeyName, 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
    {
        char szValueData[MAX_PATH];

        dwSize = sizeof(szValueData);
        bRet = (RegQueryValueExA(hkey, pszValueName, NULL, &dwType, (LPBYTE)szValueData, &dwSize) == ERROR_SUCCESS);
        RegCloseKey(hkey);
    }
    
    return bRet;
}

/*
BOOL IsTermsrvRunning()
{
    BOOL fResult = TRUE; // assume the service is running
    SC_HANDLE hSCManager = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hSCManager)
    {
        SC_HANDLE hSCService = OpenService(hSCManager, TEXT("TermService"), SERVICE_QUERY_CONFIG);

        if (hSCService)
        {
            SERVICE_STATUS ServiceStatus;

            if (QueryServiceStatus(hSCService, &ServiceStatus))
            {
                if ((ServiceStatus.dwCurrentState == SERVICE_START_PENDING) ||
                    (ServiceStatus.dwCurrentState == SERVICE_RUNNING)       ||
                    (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING))
                {
                   fResult = FALSE;
                }
            }
        }

        CloseServiceHandle(hSCManager);
    }

    return fResult;
}
*/

#if (_WIN32_WINNT >= 0x0500)
// Have to use a LoadLibrary/GetProcAddress thunk since we are part of stock4.lib/stock.lib,
// and we can't require users of stocklib to delayload netapi32.dll
typedef NET_API_STATUS (* NETGETJOININFORMATION) (LPCWSTR, LPWSTR*, PNETSETUP_JOIN_STATUS);
NET_API_STATUS NT5_NetGetJoinInformation(LPCWSTR pszServer, LPWSTR* ppszNameBuffer, PNETSETUP_JOIN_STATUS BufferType)
{
    static NETGETJOININFORMATION s_pfn = (NETGETJOININFORMATION)-1;

    if (s_pfn == (NETGETJOININFORMATION)-1)
    {
        if (IsOS(OS_WIN2000ORGREATER))
        {
            s_pfn = (NETGETJOININFORMATION)GetProcAddress(LoadLibrary(TEXT("netapi32")), "NetGetJoinInformation");
        }
        else
        {
            s_pfn = NULL;
        }
    }

    if (s_pfn)
    {
        return s_pfn(pszServer, ppszNameBuffer, BufferType);
    }
    else
    {
        return ERROR_PROC_NOT_FOUND;
    }
}

typedef NET_API_STATUS (* NETAPIBUFFERFREE) (void*);
NET_API_STATUS NT5_NetApiBufferFree(LPVOID pv)
{
    static NETAPIBUFFERFREE s_pfn = (NETAPIBUFFERFREE)-1;

    if (s_pfn == (NETAPIBUFFERFREE)-1)
    {
        if (IsOS(OS_WIN2000ORGREATER))
        {
            s_pfn = (NETAPIBUFFERFREE)GetProcAddress(GetModuleHandle(TEXT("netapi32")), "NetApiBufferFree");
        }
        else
        {
            s_pfn = NULL;
        }
    }

    if (s_pfn)
    {
        return s_pfn(pv);
    }
    else
    {
        return ERROR_PROC_NOT_FOUND;
    }
}
#endif  // (_WIN32_WINNT >= 0x0500)


// checks to see if this machine is a member of a domain or not 
// NOTE: this will always return FALSE on downlevel platforms (older than win2k)
BOOL IsMachineDomainMember()
{
// don't call NetGetJoinInformation if we are part of stock4.lib
#if (_WIN32_WINNT >= 0x0500)

    static BOOL s_bIsDomainMember = FALSE;
    static BOOL s_bDomainCached = FALSE;

    if (IsOS(OS_WIN2000ORGREATER) && !s_bDomainCached)
    {
        LPWSTR pwszDomain;
        NETSETUP_JOIN_STATUS njs;
        NET_API_STATUS nas;

        nas = NT5_NetGetJoinInformation(NULL, &pwszDomain, &njs);
        if (nas == NERR_Success)
        {
            if (pwszDomain)
            {
                NT5_NetApiBufferFree(pwszDomain);
            }

            if (njs == NetSetupDomainName)
            {
                // we are joined to a domain!
                s_bIsDomainMember = TRUE;
            }
        }
        
        s_bDomainCached = TRUE;
    }
    
    return s_bIsDomainMember;
#else
    return FALSE;
#endif
}


typedef LONG (WINAPI *PFNTQUERYINFORMATIONPROCESS) (HANDLE ProcessHandle, int ProcessInformationClass, PVOID ProcessInformation, ULONG ProcessInformationLength, PULONG ReturnLength);

// this function checks to see if we are a 32-bit process running on a 64-bit platform
BOOL RunningOnWow64()
{
    static BOOL bRunningOnWow64 = (BOOL)-1;

    if (bRunningOnWow64 == (BOOL)-1)
    {
        PFNTQUERYINFORMATIONPROCESS pfn = (PFNTQUERYINFORMATIONPROCESS)GetProcAddress(GetModuleHandle(TEXT("ntdll.dll")), "NtQueryInformationProcess");

        if (pfn)
        {
            LONG lStatus;
            ULONG_PTR Wow64Info;

            #define ProcessWow64Information 26  // stolen from ntpsapi.h

            lStatus = pfn(GetCurrentProcess(), ProcessWow64Information, &Wow64Info, sizeof(Wow64Info), NULL); 
            if ((lStatus >= 0) && Wow64Info)
            {
                bRunningOnWow64 = TRUE;
            }
            else
            {
                bRunningOnWow64 = FALSE;
            }
        }
        else
        {
            bRunningOnWow64 = FALSE;
        }
    }

    return bRunningOnWow64;
}

BOOL ShouldShowServerAdminUI()
{
    DWORD dw = FALSE;
    HKEY hk;
    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER TEXT("\\Advanced"), 0, KEY_QUERY_VALUE, &hk) == ERROR_SUCCESS)
    {
        DWORD cb = sizeof(dw);
        RegQueryValueEx(hk, TEXT("ServerAdminUI"), NULL, NULL, (LPBYTE)&dw, &cb); // preinitialized dw for failure
        RegCloseKey(hk);
    }
    return dw;
}

BOOL IsApplianceServer()
{
    static BOOL s_bRet = (BOOL)-1;

    // Cache the value since it should not change normally. If any of the
    // following code fails, just assume it is not an appliance server.
    if (s_bRet == (BOOL)-1)
    {
        HKEY hkey;

        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\WPA\\ApplianceServer", 0, KEY_QUERY_VALUE, &hkey) == ERROR_SUCCESS)
        {
            DWORD dwType;
            DWORD dwValue;
            DWORD dwSize = sizeof(dwValue);

            if (RegQueryValueExA(hkey, "Installed", NULL, &dwType, (LPBYTE)&dwValue, &dwSize) == ERROR_SUCCESS)
            {
                if ((dwType == REG_DWORD) && (dwValue != 0))
                {
                    s_bRet = TRUE;
                }
            }
            RegCloseKey(hkey);
        }
    }

    if (s_bRet == (BOOL)-1)
    {
        s_bRet = FALSE;
    }

    return s_bRet;
}

/*----------------------------------------------------------
Purpose: Returns TRUE/FALSE if the platform is the given OS_ value.

*/
STDAPI_(BOOL) IsOS(DWORD dwOS)
{
    BOOL bRet;
    static OSVERSIONINFOEXA s_osvi = {0};
    static BOOL s_bVersionCached = FALSE;

    if (!s_bVersionCached)
    {
        s_bVersionCached = TRUE;
        s_osvi.dwOSVersionInfoSize = sizeof(s_osvi);
        if (!GetVersionExA((OSVERSIONINFOA*)&s_osvi))
        {
            // If it failed, it must be a down level platform
            s_osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
            GetVersionExA((OSVERSIONINFOA*)&s_osvi);
        }
    }

    switch (dwOS)
    {
    case OS_TERMINALCLIENT:
        // WARNING: this will only return TRUE for REMOTE TS sessions (eg you are comming in via tsclient).
        // If you want to see if TS is enabled or if the user is on the TS console, the use one of the other flags.
        bRet = GetSystemMetrics(SM_REMOTESESSION);
        break;

    case OS_WIN2000TERMINAL:
        // WARNING: this flag is VERY ambiguous... you probably want to use one of 
        // OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or  OS_PERSONALTERMINALSERVER instead.
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use one of OS_TERMINALSERVER, OS_TERMINALREMOTEADMIN, or OS_PERSONALTERMINALSERVER instead !");
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                s_osvi.dwMajorVersion >= 5);
        break;

    case OS_TERMINALSERVER:
        // NOTE: be careful about using OS_TERMINALSERVER. It will only return true for nt server boxes
        // configured in what used to be called "Applications Server" mode in the win2k days. It is now simply called
        // "Terminal Server" (hence the name of this flag).
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                !(VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
#ifdef DEBUG
        if (bRet)
        {
            // all "Terminal Server" machines have to be server (cannot be per/pro)
            ASSERT(VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType);
        }
#endif
        break;

    case OS_TERMINALREMOTEADMIN:
        // this checks to see if TS has been installed in the "Remote Administration" mode. This is
        // the default for server installs on win2k and whistler
        bRet = ((VER_SUITE_TERMINAL & s_osvi.wSuiteMask) &&
                (VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask));
        break;

    case OS_PERSONALTERMINALSERVER:
        bRet = ((VER_SUITE_SINGLEUSERTS & s_osvi.wSuiteMask) &&
                !(VER_SUITE_TERMINAL & s_osvi.wSuiteMask));
        break;

    case OS_FASTUSERSWITCHING:
        bRet = (((VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS) & s_osvi.wSuiteMask) &&
                IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                      "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                      "AllowMultipleTSSessions"));
        break;

    case OS_FRIENDLYLOGONUI:
        bRet = ((VER_NT_WORKSTATION == s_osvi.wProductType) &&
                !IsMachineDomainMember() &&
                !IsWinlogonRegValuePresent(HKEY_LOCAL_MACHINE,
                                           "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                           "GinaDLL") &&
                IsWinlogonRegValueSet(HKEY_LOCAL_MACHINE,
                                      "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon",
                                      "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\policies\\system",
                                      "LogonType"));
        break;

    case OS_DOMAINMEMBER:
        bRet = IsMachineDomainMember();
        ASSERT(VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId); // has to be a NT machine to be on a domain!
        break;

    case 4: // used to be OS_NT5, is the same as OS_WIN2000ORGREATER so use that instead
    case OS_WIN2000ORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 5);
        break;

    // NOTE: The flags in this section are bogus and SHOULD NOT BE USED 
    //       (but the ie4 shell32 uses them, so don't RIP on downlevel platforms)
    case OS_WIN2000PRO:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_PROFESSIONAL instead of OS_WIN2000PRO !");
        bRet = (VER_NT_WORKSTATION == s_osvi.wProductType &&
                s_osvi.dwMajorVersion == 5);
        break;
    case OS_WIN2000ADVSERVER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_ADVSERVER instead of OS_WIN2000ADVSERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000DATACENTER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_DATACENTER instead of OS_WIN2000DATACENTER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                s_osvi.dwMajorVersion == 5 &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;
    case OS_WIN2000SERVER:
        RIPMSG(!IsOS(OS_WHISTLERORGREATER), "IsOS: use OS_SERVER instead of OS_WIN2000SERVER !");
        bRet = ((VER_NT_SERVER == s_osvi.wProductType ||
                VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask)  && 
                s_osvi.dwMajorVersion == 5);
        break;
    // END bogus Flags

    case OS_EMBEDDED:
        bRet = (VER_SUITE_EMBEDDEDNT & s_osvi.wSuiteMask);
        break;

    case OS_WINDOWS:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId);
        break;

    case OS_NT:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId);
        break;

    case OS_WIN95:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_WIN95GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 0 &&
                LOWORD(s_osvi.dwBuildNumber) == 950);
        break;

    case OS_WIN98ORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                (s_osvi.dwMajorVersion > 4 || 
                 s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 10));
        break;

    case OS_WIN98_GOLD:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion == 10 &&
                LOWORD(s_osvi.dwBuildNumber) == 1998);
        break;


    case OS_MILLENNIUMORGREATER:
        bRet = (VER_PLATFORM_WIN32_WINDOWS == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion == 4 && s_osvi.dwMinorVersion >= 90) ||
                s_osvi.dwMajorVersion > 4));
        break;

    case OS_NT4:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                s_osvi.dwMajorVersion >= 4);
        break;

    case OS_WHISTLERORGREATER:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                ((s_osvi.dwMajorVersion > 5) ||
                (s_osvi.dwMajorVersion == 5 && (s_osvi.dwMinorVersion > 0 ||
                (s_osvi.dwMinorVersion == 0 && LOWORD(s_osvi.dwBuildNumber) > 2195)))));
        break;

    case OS_PERSONAL:
        bRet = (VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId &&
                (VER_SUITE_PERSONAL & s_osvi.wSuiteMask));
        break;

    case OS_PROFESSIONAL:
        bRet = ((VER_PLATFORM_WIN32_NT == s_osvi.dwPlatformId) && 
                (VER_NT_WORKSTATION == s_osvi.wProductType));
        break;

    case OS_DATACENTER:
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                (VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;

    case OS_ADVSERVER:
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                (VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask));
        break;

    case OS_SERVER:
        // NOTE: be careful! this specifically means Server -- will return false for Avanced Server and Datacenter machines
        bRet = ((VER_NT_SERVER == s_osvi.wProductType || VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType) &&
                !(VER_SUITE_DATACENTER & s_osvi.wSuiteMask) && 
                !(VER_SUITE_ENTERPRISE & s_osvi.wSuiteMask) &&
		!(VER_SUITE_BLADE & s_osvi.wSuiteMask) &&
		!(VER_SUITE_SMALLBUSINESS & s_osvi.wSuiteMask) &&
		!(VER_SUITE_SMALLBUSINESS_RESTRICTED & s_osvi.wSuiteMask));
        break;

    case OS_BLADE:
	// Blade has a direct suite mask
        bRet = (VER_SUITE_BLADE & s_osvi.wSuiteMask);
        break;

    case OS_SMALLBUSINESSSERVER:
	// SBS also has a direct suite mask
        bRet = (VER_SUITE_SMALLBUSINESS_RESTRICTED & s_osvi.wSuiteMask);
        break;

    case OS_ANYSERVER:
        // this is for people who want to know if this is ANY type of NT server machine (eg dtc, ads, or srv)
        bRet = ((VER_NT_SERVER == s_osvi.wProductType) || (VER_NT_DOMAIN_CONTROLLER == s_osvi.wProductType));
        break;

    case OS_WOW6432:
        bRet = RunningOnWow64();
        break;

#if (_WIN32_WINNT >= 0x0501)
    case OS_TABLETPC:
        bRet = GetSystemMetrics(SM_TABLETPC);
        break;
        
    case OS_MEDIACENTER:
        bRet = GetSystemMetrics(SM_MEDIACENTER);
        break;

    case OS_APPLIANCE:
        bRet = IsApplianceServer();
        break;
#endif

    case OS_SERVERADMINUI:
        // Note that it is possible to have server admin UI on a non-server machine.
        // This is to prevent "surprises" when an admin's profile roams to a non-server.
        // Otherwise the user gets a mix of admin settings (Start Menu, full path in
        // title bar, etc.) and nonadmin settings (hide taskbar icons, folder sniffing).
        //
        bRet = ShouldShowServerAdminUI();
        break;

    default:
        bRet = FALSE;
        break;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\mediahlpr.h ===
// mediahlpr.h: Media Bar helper objects that need to be shared between shdocvw & browseui

#ifndef _MEDIAHLPR_H_
#define _MEDIAHLPR_H_

//+----------------------------------------------------------------------------------------
// CMediaBarHelper - Helper object for disabling autoplay per navigation
//-----------------------------------------------------------------------------------------

class
CMediaBarHelper :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IServiceProvider,
    public IDispatchImpl<DWebBrowserEvents2, &DIID_DWebBrowserEvents2, &LIBID_SHDocVw>
{
public:
    CMediaBarHelper() : 
        _dwCPCookie(0),
        _dwServiceCookie(0),
        _fDisableOnce(false)
    {
    }

    ~CMediaBarHelper()
    {
        // for putting break points
        return;
    }

    BEGIN_COM_MAP(CMediaBarHelper)
        COM_INTERFACE_ENTRY(IServiceProvider)
        COM_INTERFACE_ENTRY(IDispatch)
        COM_INTERFACE_ENTRY_IID(DIID_DWebBrowserEvents2, IDispatch)
    END_COM_MAP();

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void ** ppvObj)
    {
        HRESULT hres = E_UNEXPECTED;

        if (IsEqualIID(guidService, CLSID_MediaBand))
        {
            hres = QueryInterface(riid, ppvObj);

            // If we are supposed to disable only the first autoplay, then 
            // we need to revoke the service after it has been queried for once. 
            if (_fDisableOnce && _spCP.p)
            {
                CComPtr<IConnectionPointContainer> spCPC;

                // Revoke the service
                HRESULT hr = _spCP->GetConnectionPointContainer(&spCPC);
                if (SUCCEEDED(hr))
                {
                    hr = ProfferService(spCPC, 
                                        CLSID_MediaBand, 
                                        NULL,
                                        &_dwServiceCookie);
            
                    ASSERT(SUCCEEDED(hr));

                    _dwServiceCookie = 0;

                    // unhook the web oc events so that we are destroyed
                    UnHookWebOCEvents();
                }
            }
        }
        return hres;
    }

    static HRESULT ProfferService(IUnknown         *punkSite, 
                                  REFGUID           sidWhat, 
                                  IServiceProvider *pService, 
                                  DWORD            *pdwCookie)
    {
        IProfferService *pps;
        HRESULT hr = IUnknown_QueryService(punkSite, SID_SProfferService, IID_PPV_ARG(IProfferService, &pps));
        if (SUCCEEDED(hr))
        {
            if (pService)
                hr = pps->ProfferService(sidWhat, pService, pdwCookie);
            else
            {
                hr = pps->RevokeService(*pdwCookie);
                *pdwCookie = 0;
            }
            pps->Release();
        }
        return hr;
    }

    static HRESULT DisableFirstAutoPlay(IUnknown * pUnk, bool fDisableAll = false)
    {
        CComObject<CMediaBarHelper> * pMediaBarHelper = NULL;
    
        HRESULT hr = CComObject<CMediaBarHelper>::CreateInstance(&pMediaBarHelper);
        if (SUCCEEDED(hr) && pMediaBarHelper)
        {
            pMediaBarHelper->AddRef();

            hr = ProfferService(pUnk, 
                                CLSID_MediaBand, 
                                SAFECAST(pMediaBarHelper, IServiceProvider *),
                                &(pMediaBarHelper->_dwServiceCookie));

            if (SUCCEEDED(hr) && !fDisableAll)
            {
                pMediaBarHelper->_fDisableOnce = true;

                // ISSUE: need to unhook events
                hr = pMediaBarHelper->HookWebOCEvents(pUnk);
            }
            else if(FAILED(hr) && pMediaBarHelper->_dwServiceCookie)
            {
                // Revoke the service
                hr = ProfferService(pUnk, 
                                    CLSID_MediaBand, 
                                    NULL,
                                    &(pMediaBarHelper->_dwServiceCookie));
            }

            pMediaBarHelper->Release();
        }

        return hr;
    }   

    // Hook Content Pane WebOC Events
    HRESULT HookWebOCEvents(IUnknown * pUnk)
    {
        HRESULT hr = E_FAIL;

        CComPtr<IConnectionPointContainer> spDocCPC; 
        CComPtr<IDispatch> spDocDispatch;
        CComPtr<IWebBrowser2> spWebBrowser;

        if (!pUnk)
        {
            goto done;
        }

        hr = IUnknown_QueryService(pUnk, SID_SWebBrowserApp, IID_IWebBrowser2, (LPVOID *)&spWebBrowser);
        if (FAILED(hr))
        {
            goto done;
        }

        // Get a connection point to the container
        hr = spWebBrowser->QueryInterface(IID_IConnectionPointContainer, (void**)&spDocCPC);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = spDocCPC->FindConnectionPoint( DIID_DWebBrowserEvents2, &_spCP );
        if (FAILED(hr))
        {
            goto done;
        }

        hr = _spCP->Advise(static_cast<IUnknown*>(static_cast<DWebBrowserEvents2*>(this)), &_dwCPCookie);
        if (FAILED(hr))
        {
            goto done;
        }

        hr = S_OK;
    done:
        return hr;
    }

    HRESULT UnHookWebOCEvents()
    {
        HRESULT hr = E_FAIL;

        if (_spCP)
        {
            CComPtr<IConnectionPointContainer> spCPC;

            // Revoke the service
            hr = _spCP->GetConnectionPointContainer(&spCPC);
            if (SUCCEEDED(hr) && _dwServiceCookie)
            {
                hr = ProfferService(spCPC, 
                                    CLSID_MediaBand, 
                                    NULL,
                                    &_dwServiceCookie);
                
                _dwServiceCookie = 0;
            }

            // unhook the events
            if (_dwCPCookie != 0)
            {
                hr = _spCP->Unadvise(_dwCPCookie);
                _dwCPCookie = 0;
            }
            _spCP.Release();
        }

        _dwCPCookie = 0;

        return hr;
    }

    STDMETHODIMP Invoke(
        /* [in] */ DISPID dispIdMember,
        /* [in] */ REFIID /*riid*/,
        /* [in] */ LCID /*lcid*/,
        /* [in] */ WORD /*wFlags*/,
        /* [out][in] */ DISPPARAMS* pDispParams,
        /* [out] */ VARIANT* pVarResult,
        /* [out] */ EXCEPINFO* /*pExcepInfo*/,
        /* [out] */ UINT* puArgErr)
    {
        HRESULT hr = E_FAIL;

        switch (dispIdMember)
        {
            case DISPID_ONQUIT:           // 253 (see exdispid.h)
            case DISPID_NAVIGATEERROR:    // 271
            // These events sometimes comes before the QS, so we ignore them
            // case DISPID_DOCUMENTCOMPLETE: // 259 
            // case DISPID_NAVIGATECOMPLETE2:// 252
            {
                hr = UnHookWebOCEvents();
                if (FAILED(hr))
                {
                    goto done;
                }
            }
            break;
        }

        hr = S_OK;
      done:
        return hr;
    }

public:
    CComPtr<IConnectionPoint> _spCP;
    DWORD _dwCPCookie;
    DWORD _dwServiceCookie;
    bool  _fDisableOnce;
};

#endif // _MEDIAHLPR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\maguids.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MAGUIDS.H
//
//	Declares the GUIDS for the Music Activity Center index
//
//	Copyright (c) Microsoft Corporation	1999
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MAGUIDS_HEADER_
#define _MAGUIDS_HEADER_

#ifdef __cplusplus
extern "C" {
#endif

//GUIDS for Player and Playlist

DEFINE_GUID(CLSID_MCPlayer, 
            0xFAB42950,0x3EFF,0x11D3,0xA2,0x07,0x00,0xC0,0x4F,0xA3,0xB6,0x0C);

DEFINE_GUID(IID_IMCPlayer,
            0x4DB04CC0,0x3F8B,0x11D3,0xA2,0x07,0x00,0xC0,0x4F,0xA3,0xB6,0x0C);

DEFINE_GUID(IID_IMCPList,
            0xEBC54B0C,0x4091,0x11D3,0xA2,0x08,0x00,0xC0,0x4F,0xA3,0xB6,0x0C);

//GUIDs for objects and property sets

DEFINE_GUID(IID_MusicActivity_Genre, 
            0x28EA7E1C, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_GenreProperties, 
            0x4180DD29, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_GenreUserProperties, 
            0x4180DD2A, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Artist, 
            0x4CC5C8BB, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_ArtistProperties, 
            0x53FD9046, 0x2FDA, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_ArtistUserProperties, 
            0x29F445CF, 0x2FDC, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_UserCollection, 
            0xC576D561, 0x38B1, 0x11d3, 0xA2, 0x04, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_UserCollectionProperties, 
            0x134E3665, 0x452F, 0x11d3, 0xA2, 0x08, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_UserCollectionUserProperties, 
            0xE5F3EB13, 0x3573, 0x11d3, 0xA2, 0x01, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Album, 
            0x3FB37412, 0x2FDC, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumProperties, 
            0x3C29F2EF, 0x2FDF, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumDownloadProperties, 
            0x3FB37413, 0x2FDC, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumUserProperties, 
            0x3FB37414, 0x2FDC, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumTrack, 
            0x20E88E93, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumTrackProperties, 
            0x20E88E94, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumTrackUserProperties, 
            0x27AB8251, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumPlaylist, 
            0x33DC77DA, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumPlaylistProperties, 
            0x33DC77DB, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_AlbumPlaylistUserProperties, 
            0x33DC77DC, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Playlist, 
            0xC23C63E7, 0x3573, 0x11d3, 0xA2, 0x01, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_PlaylistProperties, 
            0xC65B1A73, 0x4869, 0x11d3, 0xA2, 0x0A, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_PlaylistUserProperties, 
            0xF4A89EB2, 0x3573, 0x11d3, 0xA2, 0x01, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Track, 
            0x5C07A8AF, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_TrackProperties, 
            0x5C07A8B0, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_TrackDynamicProperties, 
            0x7F155F3F, 0x3C93, 0x11d3, 0xA2, 0x06, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_TrackUserProperties, 
            0x5C07A8B1, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Batch, 
            0xCCE3C6ED, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_BatchProperties, 
            0xCCE3C6EE, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Link, 
            0xE398889B, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_LinkProperties, 
            0xE398889C, 0x2FDD, 0x11d3, 0xA2, 0x0, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_Pictures, 
            0x7B2D2D4E, 0x453B, 0x11d3, 0xA2, 0x08, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_PictureProperties, 
            0x7B2D2D4F, 0x453B, 0x11d3, 0xA2, 0x08, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

DEFINE_GUID(IID_MusicActivity_PlaylistFromAlbum, 
            0xF3CCA94D, 0x004A, 0x4cef, 0xBA, 0x6E, 0x64, 0x4D, 0xEC, 0x03, 0x7D, 0x6F);

DEFINE_GUID(IID_MusicActivity_PlaylistFromAlbumProperties, 
            0x2159AF87, 0x8258, 0x4a6c, 0x85, 0x81, 0xDE, 0xF6, 0x8C, 0xA6, 0xBF, 0x4F);

DEFINE_GUID(IID_MusicActivity_PlaylistFromAlbumUserProperties, 
            0x1F821027, 0xE8AC, 0x4cf7, 0xB5, 0x66, 0x69, 0xC7, 0xC0, 0x18, 0x56, 0x2C);

//Property Numbers
#define MA_PROPERTY_GENRE_NAME                  1

#define MA_PROPERTY_ARTIST_NAME                 1
#define MA_PROPERTY_ARTIST_ROLE                 2

#define MA_PROPERTY_USERCOLLECTION_NAME         1

#define MA_PROPERTY_ALBUM_TITLE                 1
#define MA_PROPERTY_ALBUM_COPYRIGHT             2
#define MA_PROPERTY_ALBUM_LABEL                 3
#define MA_PROPERTY_ALBUM_RELEASEDATE           4
#define MA_PROPERTY_ALBUM_RATING                5
#define MA_PROPERTY_ALBUM_RATINGORG             6
#define MA_PROPERTY_ALBUM_CDID                  7
#define MA_PROPERTY_ALBUM_TOC                   8
#define MA_PROPERTY_ALBUM_LASTPLAYED            9

#define MA_PROPERTY_ALBUMDLD_PREMIUMMETA        1
#define MA_PROPERTY_ALBUMDLD_PREMIUMMETACACHE   2
#define MA_PROPERTY_ALBUMDLD_DOWNLOADDATE       3
#define MA_PROPERTY_ALBUMDLD_PROVIDER           4

#define MA_PROPERTY_ALBUMTRACK_TITLE            1
#define MA_PROPERTY_ALBUMTRACK_LYRICS           2
#define MA_PROPERTY_ALBUMTRACK_LENGTH           3
#define MA_PROPERTY_ALBUMTRACK_LASTPLAYED       4

#define MA_PROPERTY_ALBUMPLAYLIST_NAME          1

#define MA_PROPERTY_PLAYLIST_NAME               1

#define MA_PROPERTY_PLAYLISTFROMALBUM_NAME      1

#define MA_PROPERTY_TRACK_FILENAME              1
#define MA_PROPERTY_TRACK_TITLE                 2
#define MA_PROPERTY_TRACK_SUBTITLE              3
#define MA_PROPERTY_TRACK_COPYRIGHT             4
#define MA_PROPERTY_TRACK_FILETYPE              5
#define MA_PROPERTY_TRACK_TIME                  6
#define MA_PROPERTY_TRACK_DATE                  7
#define MA_PROPERTY_TRACK_LANGUAGE              8
#define MA_PROPERTY_TRACK_MEDIATYPE             9
#define MA_PROPERTY_TRACK_PARTINSET             10
#define MA_PROPERTY_TRACK_ENCODEDBY             11
#define MA_PROPERTY_TRACK_PUBLISHER             12
#define MA_PROPERTY_TRACK_TRACKNUMBER           13
#define MA_PROPERTY_TRACK_RECORDINGDATES        14
#define MA_PROPERTY_TRACK_NETRADIOSTATION       15
#define MA_PROPERTY_TRACK_NETRADIOOWNER         16
#define MA_PROPERTY_TRACK_YEAR                  17
#define MA_PROPERTY_TRACK_BEATSPERMINUTE        18
#define MA_PROPERTY_TRACK_MUSICALKEY            19
#define MA_PROPERTY_TRACK_LENGTHINMILLISECONDS  20
#define MA_PROPERTY_TRACK_ALBUM                 21
#define MA_PROPERTY_TRACK_ORIGINALALBUM         22
#define MA_PROPERTY_TRACK_ORIGINALFILENAME      23
#define MA_PROPERTY_TRACK_ORIGINALRELEASEYEAR   24
#define MA_PROPERTY_TRACK_FILEOWNER             25
#define MA_PROPERTY_TRACK_SIZE                  26
#define MA_PROPERTY_TRACK_ISRC                  27
#define MA_PROPERTY_TRACK_SOFTWARE              28
#define MA_PROPERTY_TRACK_RATING                29
#define MA_PROPERTY_TRACK_COMMENT               30

#define MA_PROPERTY_TRACKDYNA_TRACKEDLINK       1

#define MA_PROPERTY_BATCH_CDID                  1
#define MA_PROPERTY_BATCH_NUMTRACKS             2
#define MA_PROPERTY_BATCH_TOC                   3

#define MA_PROPERTY_LINK_NAME                   1
#define MA_PROPERTY_LINK_URL                    2

#define MA_PROPERTY_PICTURE_CAPTION             1
#define MA_PROPERTY_PICTURE_URL                 2
#define MA_PROPERTY_PICTURE_TRACKEDLINK         3
#define MA_PROPERTY_PICTURE_THUMBNAIL           4

//Property Names
#define MA_PROPERTYNAME_GENRE_NAME                  L"Name"

#define MA_PROPERTYNAME_ARTIST_NAME                 L"Name"
#define MA_PROPERTYNAME_ARTIST_ROLE                 L"Role"

#define MA_PROPERTYNAME_USERCOLLECTION_NAME         L"Name"

#define MA_PROPERTYNAME_ALBUM_TITLE                 L"Title"
#define MA_PROPERTYNAME_ALBUM_COPYRIGHT             L"Copyright"
#define MA_PROPERTYNAME_ALBUM_LABEL                 L"Label"
#define MA_PROPERTYNAME_ALBUM_RELEASEDATE           L"ReleaseDate"
#define MA_PROPERTYNAME_ALBUM_RATING                L"Rating"
#define MA_PROPERTYNAME_ALBUM_RATINGORG             L"RatingOrg"
#define MA_PROPERTYNAME_ALBUM_CDID                  L"CDID"
#define MA_PROPERTYNAME_ALBUM_TOC                   L"TOC"
#define MA_PROPERTYNAME_ALBUM_LASTPLAYED            L"LastPlayed"

#define MA_PROPERTYNAME_ALBUMDLD_PREMIUMMETA        L"PremiumMeta"
#define MA_PROPERTYNAME_ALBUMDLD_PREMIUMMETACACHE   L"PremiumMetaCache"
#define MA_PROPERTYNAME_ALBUMDLD_DOWNLOADDATE       L"DownloadDate"
#define MA_PROPERTYNAME_ALBUMDLD_PROVIDER           L"Provider"

#define MA_PROPERTYNAME_ALBUMTRACK_TITLE            L"Title"
#define MA_PROPERTYNAME_ALBUMTRACK_LYRICS           L"Lyrics"
#define MA_PROPERTYNAME_ALBUMTRACK_LENGTH           L"Length"
#define MA_PROPERTYNAME_ALBUMTRACK_LASTPLAYED       L"LastPlayed"

#define MA_PROPERTYNAME_ALBUMPLAYLIST_NAME          L"Name"

#define MA_PROPERTYNAME_PLAYLIST_NAME               L"Name"

#define MA_PROPERTYNAME_PLAYLISTFROMALBUM_NAME      L"Name"

#define MA_PROPERTYNAME_TRACK_FILENAME              L"Filename"
#define MA_PROPERTYNAME_TRACK_TITLE                 L"Title"
#define MA_PROPERTYNAME_TRACK_SUBTITLE              L"Subtitle"
#define MA_PROPERTYNAME_TRACK_COPYRIGHT             L"Copyright"
#define MA_PROPERTYNAME_TRACK_FILETYPE              L"Filetype"
#define MA_PROPERTYNAME_TRACK_TIME                  L"Time"
#define MA_PROPERTYNAME_TRACK_DATE                  L"Date"
#define MA_PROPERTYNAME_TRACK_LANGUAGE              L"Language"
#define MA_PROPERTYNAME_TRACK_MEDIATYPE             L"MediaType"
#define MA_PROPERTYNAME_TRACK_PARTINSET             L"PartInSet"
#define MA_PROPERTYNAME_TRACK_ENCODEDBY             L"EncodedBy"
#define MA_PROPERTYNAME_TRACK_PUBLISHER             L"Publisher"
#define MA_PROPERTYNAME_TRACK_TRACKNUMBER           L"TrackNumber"
#define MA_PROPERTYNAME_TRACK_RECORDINGDATES        L"RecordingDates"
#define MA_PROPERTYNAME_TRACK_NETRADIOSTATION       L"NetRadioStation"
#define MA_PROPERTYNAME_TRACK_NETRADIOOWNER         L"NetRadioOwner"
#define MA_PROPERTYNAME_TRACK_YEAR                  L"Year"
#define MA_PROPERTYNAME_TRACK_BEATSPERMINUTE        L"BeatsPerMinute"
#define MA_PROPERTYNAME_TRACK_MUSICALKEY            L"MusicalKey"
#define MA_PROPERTYNAME_TRACK_LENGTHINMILLISECONDS  L"LengthInMilliseconds"
#define MA_PROPERTYNAME_TRACK_ALBUM                 L"Album"
#define MA_PROPERTYNAME_TRACK_ORIGINALALBUM         L"OriginalAlbum"
#define MA_PROPERTYNAME_TRACK_ORIGINALFILENAME      L"OriginalFilename"
#define MA_PROPERTYNAME_TRACK_ORIGINALRELEASEYEAR   L"OriginalReleaseYear"
#define MA_PROPERTYNAME_TRACK_FILEOWNER             L"FileOwner"
#define MA_PROPERTYNAME_TRACK_SIZE                  L"Size"
#define MA_PROPERTYNAME_TRACK_ISRC                  L"ISRC"
#define MA_PROPERTYNAME_TRACK_SOFTWARE              L"Software"
#define MA_PROPERTYNAME_TRACK_RATING                L"Rating"
#define MA_PROPERTYNAME_TRACK_COMMENT               L"Comment"

#define MA_PROPERTYNAME_TRACKDYNA_TRACKEDLINK       L"TrackedLink"

#define MA_PROPERTYNAME_BATCH_CDID                  L"CDID"
#define MA_PROPERTYNAME_BATCH_NUMTRACKS             L"NumTracks"
#define MA_PROPERTYNAME_BATCH_TOC                   L"TOC"

#define MA_PROPERTYNAME_LINK_NAME                   L"Name"
#define MA_PROPERTYNAME_LINK_URL                    L"URL"

#define MA_PROPERTYNAME_PICTURE_CAPTION             L"Caption"
#define MA_PROPERTYNAME_PICTURE_URL                 L"URL"
#define MA_PROPERTYNAME_PICTURE_TRACKEDLINK         L"TrackedLink"
#define MA_PROPERTYNAME_PICTURE_THUMBNAIL           L"Thumbnail"

//Property Types
#define MA_PROPERTYTYPE_GENRE_NAME                  1

#define MA_PROPERTYTYPE_ARTIST_NAME                 1
#define MA_PROPERTYTYPE_ARTIST_ROLE                 1

#define MA_PROPERTYTYPE_USERCOLLECTION_NAME         1

#define MA_PROPERTYTYPE_ALBUM_TITLE                 1
#define MA_PROPERTYTYPE_ALBUM_COPYRIGHT             1
#define MA_PROPERTYTYPE_ALBUM_LABEL                 1
#define MA_PROPERTYTYPE_ALBUM_RELEASEDATE           2
#define MA_PROPERTYTYPE_ALBUM_RATING                1
#define MA_PROPERTYTYPE_ALBUM_RATINGORG             1
#define MA_PROPERTYTYPE_ALBUM_CDID                  0
#define MA_PROPERTYTYPE_ALBUM_TOC                   3
#define MA_PROPERTYTYPE_ALBUM_LASTPLAYED            2

#define MA_PROPERTYTYPE_ALBUMDLD_PREMIUMMETA        3
#define MA_PROPERTYTYPE_ALBUMDLD_PREMIUMMETACACHE   3
#define MA_PROPERTYTYPE_ALBUMDLD_DOWNLOADDATE       2
#define MA_PROPERTYTYPE_ALBUMDLD_PROVIDER           1

#define MA_PROPERTYTYPE_ALBUMTRACK_TITLE            1
#define MA_PROPERTYTYPE_ALBUMTRACK_LYRICS           4
#define MA_PROPERTYTYPE_ALBUMTRACK_LENGTH           0
#define MA_PROPERTYTYPE_ALBUMTRACK_LASTPLAYED       2

#define MA_PROPERTYTYPE_ALBUMPLAYLIST_NAME          1

#define MA_PROPERTYTYPE_PLAYLIST_NAME               1

#define MA_PROPERTYTYPE_PLAYLISTFROMALBUM_NAME      1

#define MA_PROPERTYTYPE_TRACK_FILENAME              1
#define MA_PROPERTYTYPE_TRACK_TITLE                 1
#define MA_PROPERTYTYPE_TRACK_SUBTITLE              1
#define MA_PROPERTYTYPE_TRACK_COPYRIGHT             1
#define MA_PROPERTYTYPE_TRACK_FILETYPE              1
#define MA_PROPERTYTYPE_TRACK_TIME                  1
#define MA_PROPERTYTYPE_TRACK_DATE                  1
#define MA_PROPERTYTYPE_TRACK_LANGUAGE              1
#define MA_PROPERTYTYPE_TRACK_MEDIATYPE             1
#define MA_PROPERTYTYPE_TRACK_PARTINSET             1
#define MA_PROPERTYTYPE_TRACK_ENCODEDBY             1
#define MA_PROPERTYTYPE_TRACK_PUBLISHER             1
#define MA_PROPERTYTYPE_TRACK_TRACKNUMBER           1
#define MA_PROPERTYTYPE_TRACK_RECORDINGDATES        1
#define MA_PROPERTYTYPE_TRACK_NETRADIOSTATION       1
#define MA_PROPERTYTYPE_TRACK_NETRADIOOWNER         1
#define MA_PROPERTYTYPE_TRACK_YEAR                  1
#define MA_PROPERTYTYPE_TRACK_BEATSPERMINUTE        1
#define MA_PROPERTYTYPE_TRACK_MUSICALKEY            1
#define MA_PROPERTYTYPE_TRACK_LENGTHINMILLISECONDS  1
#define MA_PROPERTYTYPE_TRACK_ALBUM                 1
#define MA_PROPERTYTYPE_TRACK_ORIGINALALBUM         1
#define MA_PROPERTYTYPE_TRACK_ORIGINALFILENAME      1
#define MA_PROPERTYTYPE_TRACK_ORIGINALRELEASEYEAR   1
#define MA_PROPERTYTYPE_TRACK_FILEOWNER             1
#define MA_PROPERTYTYPE_TRACK_SIZE                  1
#define MA_PROPERTYTYPE_TRACK_ISRC                  1
#define MA_PROPERTYTYPE_TRACK_SOFTWARE              1
#define MA_PROPERTYTYPE_TRACK_RATING                1
#define MA_PROPERTYTYPE_TRACK_COMMENT               1

#define MA_PROPERTYTYPE_TRACKDYNA_TRACKEDLINK       6

#define MA_PROPERTYTYPE_BATCH_CDID                  0
#define MA_PROPERTYTYPE_BATCH_NUMTRACKS             0
#define MA_PROPERTYTYPE_BATCH_TOC                   3

#define MA_PROPERTYTYPE_LINK_NAME                   1
#define MA_PROPERTYTYPE_LINK_URL                    3

#define MA_PROPERTYTYPE_PICTURE_CAPTION             1
#define MA_PROPERTYTYPE_PICTURE_URL                 3
#define MA_PROPERTYTYPE_PICTURE_TRACKEDLINK         6
#define MA_PROPERTYTYPE_PICTURE_THUMBNAIL           4

#ifdef __cplusplus
};
#endif

#endif  //_MAGUIDS_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\mediautil.h ===
// mediautil.h: media bar utility routines that need to be shared between shdocvw & browseui

#ifndef _MEDIAUTIL_H_
#define _MEDIAUTIL_H_

//+----------------------------------------------------------------------------------------
// CMediaBarUtil
//-----------------------------------------------------------------------------------------

class CMediaBarUtil
{
public:
    CMediaBarUtil() {}
    ~CMediaBarUtil() {}

    // Reg helpers
    static HRESULT SetMediaRegValue(LPWSTR pstrName, DWORD dwRegDataType, void *pvData, DWORD cbData, BOOL fMime = FALSE); 
    static HUSKEY  GetMediaRegKey();
    static HUSKEY  GetMimeRegKey();
    static HUSKEY  OpenRegKey(TCHAR * pchName);
    static HRESULT CloseRegKey(HUSKEY hUSKey);
    static HRESULT IsRegValueTrue(HUSKEY hUSKey, TCHAR * pchName, BOOL * pfValue);
    static BOOL    GetImplicitMediaRegValue(TCHAR * pchName);
    static BOOL    GetAutoplay();
    static BOOL    GetAutoplayPrompt();
    static HRESULT ToggleAutoplay(BOOL fOn);
    static HRESULT ToggleAutoplayPrompting(BOOL fOn);
    static BOOL    IsRecognizedMime(BSTR bstrMime);
    static HRESULT ShouldPlay(TCHAR * szMime, BOOL * pfShouldPlay);
    static BOOL IsWMP7OrGreaterCapable();
    static BOOL IsWMP7OrGreaterInstalled();
};


#endif // _MEDIAUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\memt.h ===
#ifndef __MEMORYTEMPLATES_H__
#define __MEMORYTEMPLATES_H__

template <class T>
inline HRESULT SHLocalAlloc(ULONG cb, T **ppv)
{
    *ppv = (T *) LocalAlloc(LPTR, cb);
    return *ppv ? S_OK : E_OUTOFMEMORY;
}

template <class T>
inline HRESULT SHCoAlloc(ULONG cb, T **ppv)
{
    *ppv = (T *) CoTaskMemAlloc(cb);
    return *ppv ? S_OK : E_OUTOFMEMORY;
}

template <class T>
class CSmartCoTaskMem
{
protected:
    T *p;

public:
    CSmartCoTaskMem() { p = NULL; }
    ~CSmartCoTaskMem() { if (p) CoTaskMemFree(p); }

    T** operator&()
    {
        ASSERT(p==NULL);
        return &p;
    }
    
    operator T*() { return p; }
};

#endif // __MEMORYTEMPLATES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\mirstyls.h ===
#ifndef _MIRSTYLS_H_
#define _MIRSTYLS_H_

#define PrivateWS_EX_LAYOUTRTL         0x00400000
#define PrivateWS_EX_NOINHERITLAYOUT   0x00100000

#if (WINVER >= 0x0500)
#if WS_EX_LAYOUTRTL != PrivateWS_EX_LAYOUTRTL
#error inconsistant WS_EX_LAYOUTRTL in winuser.h
#endif
#if WS_EX_NOINHERITLAYOUT != PrivateWS_EX_NOINHERITLAYOUT
#error inconsistant WS_EX_NOINHERITLAYOUT in winuser.h
#endif
#else
#define WS_EX_LAYOUTRTL          PrivateWS_EX_LAYOUTRTL
#define WS_EX_NOINHERITLAYOUT    PrivateWS_EX_NOINHERITLAYOUT
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\objclsid.h ===
#ifndef _OBJCLSID_H_
#define _OBJCLSID_H_

class CObjectCLSID : public IPersist
{
public:
    CObjectCLSID(const CLSID * pClsid)  {_clsid = *pClsid;};
    virtual ~CObjectCLSID() {}

    //*** IUnknown ****
    // (client must provide!)

    //*** IPersist ***
    STDMETHOD(GetClassID)(IN CLSID *pClassID)
    {
        HRESULT hr = E_INVALIDARG;

        if (pClassID)
        {
            *pClassID = _clsid;
            hr = S_OK;
        }

        return hr;
    }

protected:
    CLSID _clsid;
};

#endif // _OBJCLSID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\objwindow.h ===
#ifndef _OBJWINDOW_H_
#define _OBJWINDOW_H_

#pragma warning(disable:4100)   // disable 'unreferenced formal parameter' because this params are needed for interface compat.

class CObjectWindow : public IOleWindow
{
public:
    CObjectWindow(void) {}
    virtual ~CObjectWindow() {}

    //*** IUnknown ****
    // (client must provide!)

    //*** IOleWindow ***
    STDMETHOD(ContextSensitiveHelp)(IN BOOL fEnterMode) {return E_NOTIMPL;}
    STDMETHOD(GetWindow)(IN HWND * phwnd)
    {
        HRESULT hr = E_INVALIDARG;

        if (phwnd)
        {
            *phwnd = _hwnd;
            hr = S_OK;
        }

        return hr;
    }

protected:
    HWND _hwnd;
};

#endif // _OBJWINDOW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\mindex.h ===
///////////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  mindex.h
//
//	Declares the interface to the Media Content Index
//
//	Copyright (c) Microsoft Corporation	1999
//
//
///////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef _MINDEX_HEADER_
#define _MINDEX_HEADER_

#ifdef __cplusplus
extern "C" {
#endif

// Media Index class identifier
// {4B1CFD76-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(CLSID_MediaIndex, 
0x4b1cfd76, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

// Media Index "Multimedia" class ID
// {4C58C22D-4440-11d3-A208-00C04FA3B60C}
DEFINE_GUID(CLSID_MediaIndexMusicActivity, 
0x4c58c22d, 0x4440, 0x11d3, 0xa2, 0x8, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

typedef struct IMediaIndexManager           *LPMEDIAINDEXMANAGER;
typedef struct IMediaIndexScheme            *LPMEDIAINDEXSCHEME;
typedef struct IMediaIndexSchemeDebug       *LPMEDIAINDEXSCHEMEDEBUG;
typedef struct IMediaIndexRoot              *LPMEDIAINDEXROOT;
typedef struct IMediaIndexObject            *LPMEDIAINDEXOBJECT;
typedef struct IMediaIndexNotificationSink  *LPMEDIAINDEXNOTIFICATIONSINK;
typedef struct IMediaIndexMusicActivityRoot *LPMEDIAINDEXMUSICACTIVITYROOT;

//property types
#define PROPERTY_TYPE_NUMERIC        0
#define PROPERTY_TYPE_TEXT           1
#define PROPERTY_TYPE_DATE           2
#define PROPERTY_TYPE_URL            3
#define PROPERTY_TYPE_BINARY         4
#define PROPERTY_TYPE_UNICODE_TEXT   5
#define PROPERTY_TYPE_FILEPATH       6

//object change notification types
#define CHANGE_TYPE_ADDED           0
#define CHANGE_TYPE_REMOVED         1
#define CHANGE_TYPE_RELATIONSHIP    2
#define CHANGE_TYPE_PROPERTY        3

typedef struct _MEDIAINDEXOBJECTDESCRIPTION
{
    const CLSID*    Clsid;                      //Class id of a database object
    wchar_t         wszDesc[255];                //Its description
} MEDIAINDEXOBJECTDESCRIPTION, *LPMEDIAINDEXOBJECTDESCRIPTION;

typedef struct _MEDIAINDEX_PROPERTYDESCRIPTION
{
    const CLSID*    Clsid;                      //Class id of a database property
    DWORD           dwPropNumber;               //Known ID of property
    DWORD           dwDataType;                 //Data type (int, text, binary, etc.)
    wchar_t         wszDesc[255];               //Its description
} MEDIAINDEXPROPERTYDESCRIPTION, *LPMEDIAINDEXPROPERTYDESCRIPTION;

//
// IMediaIndexManager
//
// {5BC8AEBF-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexManager, 
0x5bc8aebf, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexManager

DECLARE_INTERFACE_(IMediaIndexManager, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)               (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)               (THIS) PURE;
    STDMETHOD_(DWORD, Release)              (THIS) PURE;

    // IMediaIndexManager methods
    STDMETHOD(OpenScheme)                   (THIS_ LPCWSTR wszName, LPMEDIAINDEXNOTIFICATIONSINK pSink, LPMEDIAINDEXSCHEME* ppScheme) PURE;
    STDMETHOD(RegisterSchemeFromXMLObject)  (THIS_ LPCWSTR wszName, IXMLDOMDocument* pXMLDoc) PURE;
    STDMETHOD(RegisterSchemeFromXMLScript)  (THIS_ LPCWSTR wszName, LPCWSTR wszXMLScript) PURE;
    STDMETHOD(BeginSchemeEnumeration)       (THIS) PURE;
    STDMETHOD(EnumerateScheme)              (THIS_ LPWSTR wszName, DWORD cchName) PURE;
    STDMETHOD(EndSchemeEnumeration)         (THIS) PURE;
};

//
// IMediaIndexScheme
//
// {6292C109-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexScheme, 
0x6292c109, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexScheme

DECLARE_INTERFACE_(IMediaIndexScheme, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)           (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)           (THIS) PURE;
    STDMETHOD_(DWORD, Release)          (THIS) PURE;

    STDMETHOD(GetSchemeInfo)            (THIS_ LPWSTR wszSchemeName, IXMLDOMDocument** ppXMLDoc) PURE;
    STDMETHOD(OpenIndex)                (THIS) PURE;
    STDMETHOD(CloseIndex)               (THIS) PURE;
    STDMETHOD(BeginUserEnumeration)     (THIS) PURE;
    STDMETHOD(EnumerateUser)            (THIS_ LPWSTR wszUserName) PURE;
    STDMETHOD(EndUserEnumeration)       (THIS) PURE;
    STDMETHOD(SetCurrentUser)           (THIS_ LPCWSTR wszUserName) PURE;
    STDMETHOD(BeginTransaction)         (THIS) PURE;
    STDMETHOD(EndTransaction)           (THIS_ BOOL fCommit) PURE;
    STDMETHOD(GetRoot)                  (THIS_ LPMEDIAINDEXROOT* ppObject) PURE;
};

//
// IMediaIndexSchemeDebug (Can QI from IMediaIndexScheme when running a debug build)
//
// {6B88573D-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexSchemeDebug, 
0x6b88573d, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexSchemeDebug

DECLARE_INTERFACE_(IMediaIndexSchemeDebug, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)   (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)   (THIS) PURE;
    STDMETHOD_(DWORD, Release)  (THIS) PURE;

    // IMediaIndexSchemeDebug methods
    STDMETHOD(DumpIndexToFile)  (THIS_ LPCWSTR wszFilename) PURE;
};

//
// IMediaIndexRoot
//
// {7C82B623-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexRoot, 
0x7c82b623, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexRoot

DECLARE_INTERFACE_(IMediaIndexRoot, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)               (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)               (THIS) PURE;
    STDMETHOD_(DWORD, Release)              (THIS) PURE;

    //IMediaIndexRoot methods
    STDMETHOD(BeginObjectEnumeration)       (THIS_ LPCGUID        pguidObjectType,
                                            DWORD                 dwStartingIndex, 
                                            BOOL                  fRestrictToCurrentUser,
                                            LPCGUID               pguidPropertySetID,
                                            DWORD                 dwPropertyID,
                                            void*                 pPropertyFilterValue,
                                            BOOL                  fThreaded,
                                            LPDWORD               dwThreadID,
                                            LPDWORD               pdwCount) PURE;
    STDMETHOD(EnumerateObjects)             (THIS_ REFGUID guidObjectType, LPVOID *ppvInterface) PURE;
    STDMETHOD(EndObjectEnumeration)         (THIS) PURE;
    STDMETHOD(Search)                       (THIS) PURE;
    STDMETHOD(CreateObject)                 (THIS_ REFGUID guidObjectType, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObject)                  (THIS_ REFGUID guidObjectType, DWORD dwInstanceID, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObjectByNumericProperty) (THIS_ REFGUID guidObjectType, REFGUID guidPropertySetID, DWORD dwPropertyID, DWORD dwValue, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObjectByTextProperty)    (THIS_ REFGUID guidObjectType, REFGUID guidPropertySetID, DWORD dwPropertyID, LPCWSTR szSearch, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(RemoveObject)                 (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;
};

//
// IMediaIndexObject
//
// {7666AF83-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexObject, 
0x7666af83, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexObject

DECLARE_INTERFACE_(IMediaIndexObject, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)               (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)               (THIS) PURE;
    STDMETHOD_(DWORD, Release)              (THIS) PURE;

    //IMediaIndexObject methods
    STDMETHOD(GetObjectInfo)                (THIS_ REFGUID guidObjectType, LPDWORD pdwInstanceID) PURE;
    STDMETHOD(BeginConnectionEnumeration)   (THIS_ BOOL     fChildren,
                                             DWORD          dwStartingIndex, 
                                             LPCGUID        pguidObjectType,
                                             BOOL           fRestrictToCurrentUser,
                                             LPCGUID        pguidPropertySetID,
                                             DWORD          dwPropertyID,
                                             void*          pPropertyFilterValue,
                                             BOOL           fThreaded,
                                             LPDWORD        dwThreadID,
                                             LPDWORD        pdwCount) PURE;
    STDMETHOD(EnumerateConnection)          (THIS_ REFGUID guidObjectType, LPVOID *ppvInterface) PURE;
    STDMETHOD(EndConnectionEnumeration)     (THIS) PURE;
    STDMETHOD(AddChild)                     (THIS_ LPMEDIAINDEXOBJECT pAddObject, LPMEDIAINDEXOBJECT pNextObject) PURE;
    STDMETHOD(RemoveChild)                  (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;
    STDMETHOD(GetProperty)                  (THIS_ REFGUID guidPropertySetID, DWORD dwPropertyID, LPWSTR wszPropertyName, LPDWORD pdwDataType, LPVOID pvDataBuffer, DWORD dwBufferSize, LPDWORD pdwRequiredSize) PURE;
    STDMETHOD(SetProperty)                  (THIS_ REFGUID guidPropertySetID, DWORD dwPropertyID, LPCWSTR wszPropertyName, DWORD dwDataType, LPCVOID pvBuffer, DWORD dwBufferSize) PURE;
    STDMETHOD(BeginPropertyEnumeration)     (THIS_ LPCGUID  pguidPropertySetID, LPDWORD pdwCount) PURE;
    STDMETHOD(EnumerateProperty)            (THIS_ REFGUID guidPropertySetID, LPDWORD pdwPropertyID, LPWSTR wszPropertyName, LPDWORD pdwDataType, LPVOID pvDataBuffer, DWORD dwBufferSize, LPDWORD pdwRequiredSize) PURE;
    STDMETHOD(EndPropertyEnumeration)       (THIS) PURE;
    STDMETHOD_(BOOL, IsParentOf)            (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;
    STDMETHOD_(BOOL, IsChildOf)             (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;
};

//
// IMediaIndexNotificationSink
//
// {892D3443-28C6-11d3-A1FF-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexNotificationSink, 
0x892d3443, 0x28c6, 0x11d3, 0xa1, 0xff, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexNotificationSink

DECLARE_INTERFACE_(IMediaIndexNotificationSink, IUnknown)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)       (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)       (THIS) PURE;
    STDMETHOD_(DWORD, Release)      (THIS) PURE;

    // IMediaIndexNotificationSink methods
    STDMETHOD(ObjectChanged)        (THIS_ REFGUID guidObjectType, DWORD dwInstanceID, DWORD dwChangeType, REFGUID guidPropertySetID, DWORD dwPropertyID);
    STDMETHOD(EnumerationCallback)  (THIS_ LPMEDIAINDEXOBJECT pObject, DWORD dwThreadID, HANDLE hCancelEvent);
};

//
// IMediaIndexMusicActivityRoot
//
// {AD27169C-443F-11d3-A208-00C04FA3B60C}
DEFINE_GUID(IID_IMediaIndexMusicActivityRoot,
0xAD27169C, 0x443F, 0x11d3, 0xa2, 0x08, 0x0, 0xc0, 0x4f, 0xa3, 0xb6, 0xc);

#undef INTERFACE
#define INTERFACE IMediaIndexMusicActivityRoot

DECLARE_INTERFACE_(IMediaIndexMusicActivityRoot, IMediaIndexRoot)
{
    // IUnknown methods
    STDMETHOD(QueryInterface)               (THIS_ REFIID iid, LPVOID *ppvInterface) PURE;
    STDMETHOD_(DWORD, AddRef)               (THIS) PURE;
    STDMETHOD_(DWORD, Release)              (THIS) PURE;

    //IMediaIndexRoot methods
    STDMETHOD(BeginObjectEnumeration)       (THIS_ LPCGUID        pguidObjectType,
                                            DWORD                 dwStartingIndex, 
                                            BOOL                  fRestrictToCurrentUser,
                                            LPCGUID               pguidPropertySetID,
                                            DWORD                 dwPropertyID,
                                            void*                 pPropertyFilterValue,
                                            BOOL                  fThreaded,
                                            LPDWORD               dwThreadID,
                                            LPDWORD               pdwCount) PURE;
    STDMETHOD(EnumerateObjects)             (THIS_ REFGUID guidObjectType, LPVOID *ppvInterface) PURE;
    STDMETHOD(EndObjectEnumeration)         (THIS) PURE;
    STDMETHOD(Search)                       (THIS) PURE;
    STDMETHOD(CreateObject)                 (THIS_ REFGUID guidObjectType, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObject)                  (THIS_ REFGUID guidObjectType, DWORD dwInstanceID, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObjectByNumericProperty) (THIS_ REFGUID guidObjectType, REFGUID guidPropertySetID, DWORD dwPropertyID, DWORD dwValue, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(FetchObjectByTextProperty)    (THIS_ REFGUID guidObjectType, REFGUID guidPropertySetID, DWORD dwPropertyID, LPCWSTR szSearch, LPMEDIAINDEXOBJECT* ppObject) PURE;
    STDMETHOD(RemoveObject)                 (THIS_ LPMEDIAINDEXOBJECT pObject) PURE;

    //IMediaIndexMusicActivityRoot methods
    STDMETHOD(OpenIndex)                    (THIS_ LPMEDIAINDEXNOTIFICATIONSINK pSink) PURE;
    STDMETHOD(CloseIndex)                   (THIS) PURE;
    STDMETHOD(GetSchemeInfo)                (THIS_ LPWSTR wszSchemeName, IXMLDOMDocument** ppXMLDoc) PURE;
};

#ifdef __cplusplus
};
#endif

#endif  //_MINDEX_HEADER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\mluisupp.h ===
#ifndef _INC_MLUISUPP
#define _INC_MLUISUPP

#include <shlwapi.h>
#include <shlwapip.h>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifdef __cplusplus
extern "C"
{
#endif

//+------------------------------------------------------------------
// Multilang Pluggable UI support
// inline functions defs (to centralize code)
//+------------------------------------------------------------------

#ifdef UNICODE
#define MLLoadString            MLLoadStringW
#define MLLoadShellLangString   MLLoadShellLangStringW
#define MLBuildResURLWrap       MLBuildResURLWrapW
#define MLLoadResources         MLLoadResourcesW
#define SHHtmlHelpOnDemandWrap  SHHtmlHelpOnDemandWrapW
#define SHWinHelpOnDemandWrap   SHWinHelpOnDemandWrapW
#else
#define MLLoadString            MLLoadStringA
#define MLLoadShellLangString   MLLoadShellLangStringA
#define MLBuildResURLWrap       MLBuildResURLWrapA
#define MLLoadResources         MLLoadResourcesA
#define SHHtmlHelpOnDemandWrap  SHHtmlHelpOnDemandWrapA
#define SHWinHelpOnDemandWrap   SHWinHelpOnDemandWrapA
#endif

void        MLFreeResources(HINSTANCE hinstParent);
HINSTANCE   MLGetHinst();
HINSTANCE   MLLoadShellLangResources();

#ifdef MLUI_MESSAGEBOX
int         MLShellMessageBox(HWND hWnd, LPCTSTR pszMsg, LPCTSTR pszTitle, UINT fuStyle, ...);
#endif

//
// The following should be both A and W suffixed
//

int         MLLoadStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax);

int         MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax);
int         MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax);

HRESULT     MLBuildResURLWrapA(LPSTR    pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPSTR    pszResName,
                               LPSTR    pszResURL,
                               int      nBufSize,
                               LPSTR    pszParentDll);

HRESULT     MLBuildResURLWrapW(LPWSTR   pszLibFile,
                               HMODULE  hModule,
                               DWORD    dwCrossCodePage,
                               LPWSTR   pszResName,
                               LPWSTR   pszResURL,
                               int      nBufSize,
                               LPWSTR   pszParentDll);

void        MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll);
void        MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll);

HWND        SHHtmlHelpOnDemandWrapA(HWND hwndCaller, LPCSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);
HWND        SHHtmlHelpOnDemandWrapW(HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData, DWORD dwCrossCodePage);

BOOL        SHWinHelpOnDemandWrapA(HWND hwndCaller, LPCSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);
BOOL        SHWinHelpOnDemandWrapW(HWND hwndCaller, LPCWSTR lpszHelp, UINT uCommand, DWORD_PTR dwData);

//
// End of: The following should be both A and W suffixed
//

#ifdef MLUI_INIT

// WARNING: do not attempt to access any of these members directly
// these members may not be initialized until appropriate accessors
// are called, for example hinstLocRes won't be intialized until
// you call MLGetHinst()... so just call the accessor.
struct tagMLUI_INFO
{
    HINSTANCE   hinstLocRes;
    HINSTANCE   hinstParent;
    WCHAR       szLocResDll[MAX_PATH];
    DWORD       dwCrossCodePage;
} g_mluiInfo;


// REARCHITECT: These aren't thread safe... Do they need to be?
//
void MLLoadResourcesA(HINSTANCE hinstParent, LPSTR pszLocResDll)
{
#ifdef RIP
    RIP(hinstParent != NULL);
    RIP(pszLocResDll != NULL);
#endif

    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        SHAnsiToUnicode(pszLocResDll, g_mluiInfo.szLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]));
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void MLLoadResourcesW(HINSTANCE hinstParent, LPWSTR pszLocResDll)
{
#ifdef RIP
    RIP(hinstParent != NULL);
    RIP(pszLocResDll != NULL);
#endif

    if (g_mluiInfo.hinstLocRes == NULL)
    {
#ifdef MLUI_SUPPORT
        // plugUI: resource dll == ?
        // resource dll must be dynamically determined and loaded.
        // but we are NOT allowed to LoadLibrary during process attach.
        // therefore we cache the info we need and load later when
        // the first resource is requested.
        StringCchCopyW(g_mluiInfo.szLocResDll, sizeof(g_mluiInfo.szLocResDll)/sizeof(g_mluiInfo.szLocResDll[0]), pszLocResDll);
        g_mluiInfo.hinstParent = hinstParent;
        g_mluiInfo.dwCrossCodePage = ML_CROSSCODEPAGE;
#else
        // non-plugUI: resource dll == parent dll
        g_mluiInfo.hinstLocRes = hinstParent;
#endif
    }
}

void
MLFreeResources(HINSTANCE hinstParent)
{
    if (g_mluiInfo.hinstLocRes != NULL &&
        g_mluiInfo.hinstLocRes != hinstParent)
    {
        MLClearMLHInstance(g_mluiInfo.hinstLocRes);
        g_mluiInfo.hinstLocRes = NULL;
    }
}

// this is a private internal helper.
// don't you dare call it from anywhere except at
// the beginning of new ML* functions in this file
__inline void
_MLResAssure()
{
#ifdef MLUI_SUPPORT
    if(g_mluiInfo.hinstLocRes == NULL)
    {
        g_mluiInfo.hinstLocRes = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                                               g_mluiInfo.hinstParent,
                                               g_mluiInfo.dwCrossCodePage);

        // we're guaranteed to at least have resources in the install language
        ASSERT(g_mluiInfo.hinstLocRes != NULL);
    }
#endif
}

int
MLLoadStringA(UINT id, LPSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringA(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    _MLResAssure();
    return LoadStringW(g_mluiInfo.hinstLocRes, id, sz, cchMax);
}

int
MLLoadShellLangStringA(UINT id, LPSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringA(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

int
MLLoadShellLangStringW(UINT id, LPWSTR sz, UINT cchMax)
{
    HINSTANCE   hinstShellLangRes;
    int         nRet;

    hinstShellLangRes = MLLoadShellLangResources();
    
    nRet = LoadStringW(hinstShellLangRes, id, sz, cchMax);

    MLFreeLibrary(hinstShellLangRes);

    return nRet;
}

HINSTANCE
MLGetHinst()
{
    _MLResAssure();
    return g_mluiInfo.hinstLocRes;
}

HINSTANCE
MLLoadShellLangResources()
{
    HINSTANCE hinst;
    
    hinst = MLLoadLibraryW(g_mluiInfo.szLocResDll,
                           g_mluiInfo.hinstParent,
                           ML_SHELL_LANGUAGE);

    // we're guaranteed to at least have resources in the install language
    // unless we're 100% toasted

    return hinst;
}

#ifdef MLUI_MESSAGEBOX
int MLShellMessageBox(HWND hWnd, LPCTSTR pszMsg, LPCTSTR pszTitle, UINT fuStyle, ...)
{
    va_list     vaList;
    int         nRet            = 0;
    LPTSTR      pszFormattedMsg = NULL;
    TCHAR       szTitleBuf[256];
    TCHAR       szBuffer[1024];

    //
    // prepare the message
    //

    if (IS_INTRESOURCE(pszMsg))
    {
        if (MLLoadShellLangString(LOWORD((DWORD_PTR)pszMsg), szBuffer, ARRAYSIZE(szBuffer)))
        {
            pszMsg = szBuffer;
        }
    }

    if (!IS_INTRESOURCE(pszMsg) &&  // the string load might have failed
        pszMsg != NULL)
    {
        va_start(vaList, fuStyle);

        if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                          pszMsg, 0, 0, (LPTSTR)&pszFormattedMsg, 0, &vaList))
        {
            pszMsg = pszFormattedMsg;
        }

        va_end(vaList);
    }

    //
    // prepare the title
    //

    if (!IS_INTRESOURCE(pszTitle) && pszTitle != NULL)
    {
        // do nothing
    }
    else if (pszTitle != NULL && MLLoadShellLangString(LOWORD((DWORD_PTR)pszTitle), szTitleBuf, ARRAYSIZE(szTitleBuf)))
    {
        pszTitle = szTitleBuf;
    }
    else if (hWnd && GetWindowText(hWnd, szTitleBuf, ARRAYSIZE(szTitleBuf)))
    {
        pszTitle = szTitleBuf;
    }
    else
    {
        pszTitle = TEXT("");
    }

    //
    // launch a MessageBox
    //
#ifdef SHFUSION_H
    ULONG_PTR uCookie = 0;
    SHActivateContext(&uCookie);
#endif

    nRet = MessageBox(hWnd, pszFormattedMsg, pszTitle, fuStyle | MB_SETFOREGROUND);
#ifdef SHFUSION_H
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
#endif

    if (pszFormattedMsg != NULL)
    {
        LocalFree(pszFormattedMsg);
    }

    return nRet;
}
#endif // MLUI_MESSAGEBOX

#include "htmlhelp.h"

HWND 
SHHtmlHelpOnDemandWrapA(HWND hwndCaller, 
                       LPCSTR pszFile,
                       UINT uCommand,
                       DWORD_PTR dwData,
                       DWORD dwCrossCodePage)
{
    BOOL    fEnabled;
    ULONG_PTR uCookie = 0;
    HWND hwnd = NULL;
    
#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

#ifdef SHFUSION_H
    SHActivateContext(&uCookie);
#endif
    hwnd = SHHtmlHelpOnDemandA(hwndCaller,
                              pszFile,
                              uCommand,
                              dwData,
                              dwCrossCodePage,
                              fEnabled);
#ifdef SHFUSION_H
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
#endif
    return hwnd;
}

HWND 
SHHtmlHelpOnDemandWrapW(HWND hwndCaller, 
                       LPCWSTR pszFile,
                       UINT uCommand,
                       DWORD_PTR dwData,
                       DWORD dwCrossCodePage)
{
    BOOL    fEnabled;
    ULONG_PTR uCookie = 0;
    HWND hwnd = NULL;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

#ifdef SHFUSION_H
    SHActivateContext(&uCookie);
#endif
    hwnd = SHHtmlHelpOnDemandW(hwndCaller,
                              pszFile,
                              uCommand,
                              dwData,
                              dwCrossCodePage,
                              fEnabled);
#ifdef SHFUSION_H
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
#endif
    return hwnd;
}

HWND
MLHtmlHelpWrap(HWND hwndCaller,
               LPCTSTR pszFile,
               UINT uCommand,
               DWORD dwData,
               DWORD dwCrossCodePage)
{
    HWND    hwnd;

    ULONG_PTR uCookie = 0;
#ifdef SHFUSION_H
    SHActivateContext(&uCookie);
#endif

#ifdef MLUI_SUPPORT
    hwnd = MLHtmlHelp(hwndCaller,
                      pszFile,
                      uCommand,
                      dwData,
                      dwCrossCodePage);
#else
    hwnd = HtmlHelp(hwndCaller,
                    pszFile,
                    uCommand,
                    dwData);
#endif

#ifdef SHFUSION_H
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }
#endif
    return hwnd;
}

BOOL
SHWinHelpOnDemandWrapA(HWND hwndCaller,
                      LPCSTR lpszHelp,
                      UINT uCommand,
                      DWORD_PTR dwData)
{
    BOOL    fEnabled;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

    return SHWinHelpOnDemandA(hwndCaller,
                             lpszHelp,
                             uCommand,
                             dwData,
                             fEnabled);

}

BOOL
SHWinHelpOnDemandWrapW(HWND hwndCaller,
                      LPCWSTR lpszHelp,
                      UINT uCommand,
                      DWORD_PTR dwData)
{
    BOOL    fEnabled;

#ifdef MLUI_SUPPORT
    fEnabled = TRUE;
#else
    fEnabled = FALSE;
#endif

    return SHWinHelpOnDemandW(hwndCaller,
                             lpszHelp,
                             uCommand,
                             dwData,
                             fEnabled);

}

BOOL
MLWinHelpWrap(HWND hwndCaller,
                   LPCTSTR lpszHelp,
                   UINT uCommand,
                   DWORD dwData)
{
    BOOL    fRet;

#ifdef MLUI_SUPPORT
    fRet = MLWinHelp(hwndCaller,
                     lpszHelp,
                     uCommand,
                     dwData);
#else
    fRet = WinHelp(hwndCaller,
                   lpszHelp,
                   uCommand,
                   dwData);
#endif

    return fRet;
}

HRESULT
MLBuildResURLWrapA(LPSTR    pszLibFile,
                   HMODULE  hModule,
                   DWORD    dwCrossCodePage,
                   LPSTR    pszResName,
                   LPSTR    pszResURL,
                   int      nBufSize,
                   LPSTR    pszParentDll)
{
    HRESULT hr;

#ifdef MLUI_SUPPORT
    hr = MLBuildResURLA(pszLibFile,
                        hModule,
                        dwCrossCodePage,
                        pszResName,
                        pszResURL,
                        nBufSize);
#else
    hr = StringCchPrintfA(pszResURL, nBufSize, "res://%s/%s", pszParentDll, pszResName);
#endif

    return hr;
}

HRESULT
MLBuildResURLWrapW(LPWSTR   pszLibFile,
                   HMODULE  hModule,
                   DWORD    dwCrossCodePage,
                   LPWSTR   pszResName,
                   LPWSTR   pszResURL,
                   int      nBufSize,
                   LPWSTR   pszParentDll)
{
    HRESULT hr;

#ifdef MLUI_SUPPORT
    hr = MLBuildResURLW(pszLibFile,
                        hModule,
                        dwCrossCodePage,
                        pszResName,
                        pszResURL,
                        nBufSize);
#else
    hr = StringCchPrintfW(pszResURL, nBufSize, L"res://%s/%s", pszParentDll, pszResName);
#endif

    return hr;
}

#endif  // MLUI_INIT

#ifdef __cplusplus
};
#endif

#endif  // _INC_MLUISUPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\port32.h ===
#ifdef WIN32

// These things have direct equivalents.

// Shouldn't be using these things.
#define WINCAPI __cdecl
#define _huge
#define _export
#define _loadds
#define SELECTOROF(x)   ((WPARAM)(x))
#define OFFSETOF(x)     ((WPARAM)(x))
#define ISLPTR(pv)      ((BOOL)pv)
#define MAKELP(hmem,off) ((LPVOID)((LPBYTE)hmem+off))
#define MAKELRESULTFROMUINT(i)  ((LRESULT)i)
#define ISVALIDHINSTANCE(hinst) BOOLFROMPTR(hinst)

// HIWORD is typically used to detect whether a pointer parameter
// is a real pointer or is a MAKEINTATOM.  HIWORD64 is the Win64-compatible
// version of this usage.  It does *NOT* return the top word of a 64-bit value.
// Rather, it returns the top 48 bits of the 64-bit value.
//
// Yes, the name isn't very good.  Any better ideas?
//
// BOOLFROMPTR is used when you have a pointer or a ULONG_PTR
// and you want to turn it into a BOOL.  In Win32,
// sizeof(BOOL) == sizeof(LPVOID) so a straight cast works.
// In Win64, you have to do it the slow way because pointers are 64-bit.
//
#ifdef _WIN64
#define HIWORD64(p)     ((ULONG_PTR)(p) >> 16)
#define BOOLFROMPTR(p)  ((p) != 0)
#define SPRINTF_PTR		"%016I64x"
#else
#define HIWORD64        HIWORD
#define BOOLFROMPTR(p)  ((BOOL)(p))
#define SPRINTF_PTR		"%08x"
#endif

#define IntToPtr_(T, i) ((T)IntToPtr(i))

#define DATASEG_READONLY    ".text"	        // don't use this, compiler does this for you
#define DATASEG_PERINSTANCE "INSTDATA"      // per instance data (per process)
#ifdef WINNT
#define DATASEG_SHARED
#else
#define DATASEG_SHARED      "SHARED"        // global global data (shared across process)
#endif
#define CODESEG_INIT        ".text"

#define GetWindowInt        GetWindowLongPtr
#define SetWindowInt        SetWindowLongPtr
#define SetWindowID(hwnd,id)    SetWindowLongPtr(hwnd, GWLP_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassLongPtr(hwnd, GCLP_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassLongPtr(hwnd, GCLP_HICON))
#define BOOL_PTR                INT_PTR

#ifdef WINNT

#else

typedef TBYTE TUCHAR;

#endif


#else  // !WIN32

typedef LPCSTR LPCTSTR;
typedef LPSTR  LPTSTR;
typedef const short far *LPCWSTR;
#define TEXT(x) (x)

#define ISLPTR(pv)      	(SELECTOROF(pv))
#define MAKELRESULTFROMUINT(i)  MAKELRESULT(i,0)
#define ISVALIDHINSTANCE(hinst) ((UINT)hinst>=(UINT)HINSTANCE_ERROR)

#define DATASEG_READONLY    "_TEXT"
#define DATASEG_PERINSTANCE
#define DATASEG_SHARED
#define CODESEG_INIT 	    "_INIT"

#define GetWindowInt    	GetWindowWord
#define SetWindowInt    	SetWindowWord
#define SetWindowID(hwnd,id)    SetWindowWord(hwnd, GWW_ID, id)
#define GetClassCursor(hwnd)    ((HCURSOR)GetClassWord(hwnd, GCW_HCURSOR))
#define GetClassIcon(hwnd)      ((HICON)GetClassWord(hwnd, GCW_HICON))

#define MAKEPOINTS(l)     (*((POINTS FAR*)&(l)))

#define GlobalAlloc16(f, s) GlobalAlloc(f, s)
#define GlobalLock16(h)     GlobalLock(h)
#define GlobalUnlock16(h)   GlobalUnlock(h)
#define GlobalFree16(h)     GlobalFree(h)
#define GlobalSize16(h)     GlobalSize(h)

#endif // WIN32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\powercfp.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       POWERCFP.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*   Public declarations for PowerCfg notification interface. Systray uses
*   this interface to notify PowerCfg that the user has changed something.
*
*******************************************************************************/

//  Private PowerCfg notification message.
#define PCWM_NOTIFYPOWER                (WM_USER + 201)

#define IDS_POWERPOLICIESTITLE 400

/*******************************************************************************
*
*  PowerCfg_Notify
*
*  DESCRIPTION:
*   Called by Systray to notify PowerCfg that something has changed.
*
*  PARAMETERS:
*
*******************************************************************************/

_inline BOOL PowerCfg_Notify(void)
{
    HINSTANCE hInst;
    static  LPTSTR lpszWndName;
    TCHAR   szBuf[128];
    HWND    hwnd, hwndPC;
    int     iLen;

    // first time initialization of the PowerCfg top level property sheet title.
    if (!lpszWndName) {
        if (hInst = LoadLibrary(TEXT("powercfg.cpl"))) {
            iLen = LoadString(hInst, IDS_POWERPOLICIESTITLE, szBuf, sizeof(szBuf)/sizeof(TCHAR));
            if (iLen) {
                if (lpszWndName = LocalAlloc(0, (iLen + 1) * sizeof(TCHAR))) {
                    lstrcpyn(lpszWndName, szBuf, iLen + 1);
                }
            }
        }
    }

    // Notify the child of the top level window.
    if (lpszWndName) {
        hwndPC = FindWindow(WC_DIALOG, lpszWndName);
        if (hwndPC) {
            hwnd = GetWindow(hwndPC, GW_CHILD);
            if (hwnd) {
                return (BOOL)SendMessage(hwnd, PCWM_NOTIFYPOWER, 0, 0);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\profileutil.h ===
//  --------------------------------------------------------------------------
//  Module Name: ProfileUtil.h
//
//  Copyright (c) 2000, Microsoft Corporation
//
//  Class to handle profile loading and unloading without a token.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

#ifndef     _ProfileUtil_
#define     _ProfileUtil_

//  --------------------------------------------------------------------------
//  CUserProfile
//
//  Purpose:    This class handles loading and unloading of a profile based
//              on object scope.
//
//  History:    2000-06-21  vtan        created
//  --------------------------------------------------------------------------

class   CUserProfile
{
    private:
                                CUserProfile (void);
    public:
                                CUserProfile (const TCHAR *pszUsername, const TCHAR *pszDomain);
                                ~CUserProfile (void);

                                operator HKEY (void)    const;
    private:
        static  PSID            UsernameToSID (const TCHAR *pszUsername, const TCHAR *pszDomain);
        static  bool            SIDStringToProfilePath (const TCHAR *pszSIDString, TCHAR *pszProfilePath);
    private:
                HKEY            _hKeyProfile;
                TCHAR*          _pszSID;
                bool            _fLoaded;

        static  const TCHAR     s_szUserHiveFilename[];
};

#endif  /*  _ProfileUtil_   */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\profsvc.h ===
#ifndef _PROFSVC_H_
#define _PROFSVC_H_

class IProfferServiceImpl : public IProfferService
{
public:
    // IProfferService
    STDMETHODIMP ProfferService(REFGUID rguidService, IServiceProvider *psp, DWORD *pdwCookie);
    STDMETHODIMP RevokeService(DWORD dwCookie);

    // delegate unrecognized QS's here
    HRESULT QueryService(REFGUID guidService, REFIID riid, void **ppv);

protected:
    IProfferServiceImpl();
    ~IProfferServiceImpl();

    HDSA _hdsa;             // list of services held
    DWORD _dwNextCookie;    // unique cookie index
};

#endif  // _PROFSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\propset.h ===
#ifndef _PROPSET_H_
#define _PROPSET_H_

// NOTE (scotth): this is a placeholder header so we can
//  use this according to the spec \\ole\specs\release\properties.doc

// Don't define if OLE definitions are in place!
#ifndef __IPropertyStorage_INTERFACE_DEFINED__
#define __IPropertyStorage_INTERFACE_DEFINED__

#include <ole2.h>


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif /* __cplusplus */

typedef struct tagPROPVARIANT PROPVARIANT;

#define TYPEDEF_CA(type, name) \
	typedef struct tag ## name {\
		ULONG cElems;\
		type *pElems;\
		} name
TYPEDEF_CA(unsigned char,		CAUI1);
TYPEDEF_CA(short,			CAI2);
TYPEDEF_CA(USHORT,		CAUI2);
TYPEDEF_CA(long,				CAI4);
TYPEDEF_CA(ULONG,			CAUI4);
TYPEDEF_CA(LARGE_INTEGER,	CAI8);
TYPEDEF_CA(ULARGE_INTEGER,CAUI8);
TYPEDEF_CA(float,				CAR4);
TYPEDEF_CA(double,			CAR8);
TYPEDEF_CA(CURRENCY,		CACY);
TYPEDEF_CA(DATE,			CADATE);
TYPEDEF_CA(BSTR,			CABSTR);
TYPEDEF_CA(VARIANT_BOOL,	CABOOL);
TYPEDEF_CA(SCODE,			CASCODE);
TYPEDEF_CA(FILETIME,		CAFILETIME);
TYPEDEF_CA(LPSTR,			CALPSTR);
TYPEDEF_CA(LPWSTR,		CALPWSTR);
TYPEDEF_CA(CLSID,			CACLSID);
TYPEDEF_CA(CLIPDATA,		CACLIPDATA);
TYPEDEF_CA(PROPVARIANT,	CAPROPVARIANT);

typedef struct tagPROPVARIANT{
	VARTYPE	vt;				// value type tag
	WORD 		wReserved1;		// padding to achieve 4-byte alignment
	WORD 		wReserved2;
	WORD 		wReserved3;
    union {							
	// none						// VT_EMPTY, VT_NULL, VT_ILLEGAL
	unsigned char 		bVal;		// VT_UI1
	short         		iVal;           	// VT_I2
	USHORT			uiVal;		// VT_UI2
	long          		lVal;			// VT_I4
	ULONG			ulVal;		// VT_UI4
	LARGE_INTEGER	hVal;		// VT_I8
	ULARGE_INTEGER  uhVal;		// VT_UI8
	float				fltVal;		// VT_R4
	double			dblVal;		// VT_R8
	CY				cyVal;		// VT_CY
	DATE			date;			// VT_DATE
	BSTR			bstrVal;		// VT_BSTR			// string in the current Ansi code page
	VARIANT_BOOL	bool;			// VT_BOOL
	SCODE         		scode;          	// VT_ERROR
	FILETIME			filetime;	// VT_FILETIME
	LPSTR			pszVal;		// VT_LPSTR			// string in the current Ansi code page
	LPWSTR        		pwszVal;		// VT_LPWSTR		// string in Unicode
	CLSID*			puuid;		// VT_CLSID
	CLIPDATA*		pclipdata;		// VT_CF

	BLOB			blob;			// VT_BLOB, VT_BLOBOBJECT
	IStream*		pStream;		// VT_STREAM, VT_STREAMED_OBJECT
	IStorage*		pStorage;		// VT_STORAGE, VT_STORED_OBJECT

	CAUI1			cab;		// VT_VECTOR | VT_UI1
	CAI2           		cai;            	// VT_VECTOR | VT_I2
	CAUI2			caui;			// VT_VECTOR | VT_UI2
	CAI4           		cal;            	// VT_VECTOR | VT_I4
	CAUI4			caul;			// VT_VECTOR | VT_UI4
	CAI8				cah;			// VT_VECTOR | VT_I8
	CAUI8			cauh;		// VT_VECTOR | VT_UI8
	CAR4         		caflt;			// VT_VECTOR | VT_R4
	CAR8         		cadbl;		// VT_VECTOR | VT_R8
	CACY          		cacy;           	// VT_VECTOR | VT_CY
	CADATE        		cadate;         	// VT_VECTOR | VT_DATE
	CABSTR        		cabstr;         	// VT_VECTOR | VT_BSTR
	CABOOL			cabool;		// VT_VECTOR | VT_BOOL
	CASCODE		cascode;		// VT_VECTOR | VT_ERROR
	CALPSTR       		calpstr;        	// VT_VECTOR | VT_LPSTR
	CALPWSTR      	calpwstr;       	// VT_VECTOR | VT_LPWSTR
	CAFILETIME    	cafiletime;     	// VT_VECTOR | VT_FILETIME
	CACLSID       		cauuid;         	// VT_VECTOR | VT_CLSID
	CACLIPDATA		caclipdata;	// VT_VECTOR | VT_CF
	CAPROPVARIANT 	capropvar;	     	// VT_VECTOR | VT_VARIANT
	}DUMMYUNIONNAME;
} PROPVARIANT;

#if 0
typedef enum {
	VT_EMPTY=0,		VT_NULL=1,		VT_I2=2,			VT_I4=3,			VT_R4=4
	VT_R8=5,		VT_CY=6,		VT_DATE=7,		VT_BSTR=8,		VT_ERROR=10,	VT_BOOL=11,
	VT_VARIANT=12,	VT_UI1=17, 		VT_UI2=18,		VT_UI4=19,
	VT_I8=20,		VT_UI8=21,		VT_LPSTR=30,	VT_LPWSTR=31,
	VT_FILETIME=64,	VT_BLOB=65,		VT_STREAM=66,	VT_STORAGE=67,	VT_STREAMED_OBJECT=68
	VT_STORED_OBJECT=69,			VT_BLOB_OBJECT=70,				VT_CF=71
	VT_CLSID=72,		VT_VECTOR=0x1000,
	VT_ILLEGAL=0xFFFFFFFF,
	VT_TYPEMASK=0xFFF,		// a mask for masking VT_VECTOR and other modifiers to get the raw VT_ value.
	} PROPVARENUM;
#endif // VT_EMPTY

#define	VT_ILLEGAL 0xFFFF

typedef enum
    {
    PRSPEC_LPWSTR   = 0,
    PRSPEC_PROPID   = 1,
    } PRSPEC;

// typedef LONG	PROPID;

typedef struct tagPROPSPEC {
	ULONG ulKind;		// PRSPEC_LPWSTR or PRSPEC_PROPID
	union {
		LPWSTR	lpwstr;
        		PROPID	propid;
	}DUMMYUNIONNAME;
} PROPSPEC;

typedef GUID		FMTID;

typedef struct tagSTATPROPSETSTG {	// used in IPropertySetStorage::Enum and IPropertyStorage::Stat
	FMTID		fmtid;		// The fmtid name of this property set.
	CLSID		clsid;		// The class id of this property set.
	DWORD		grfFlags;		// The flag values of this property set as specified in IPropertySetStorage::Create.
	FILETIME		mtime;		// The time in UTC at which this property set was last modified
	FILETIME		ctime;		// The time in UTC at which this property set was created.
	FILETIME		atime;		// The time in UTC at which this property set was last accessed.
	} STATPROPSETSTG;

typedef struct  tagSTATPROPSTG
    {
    LPOLESTR lpwstrName;
    PROPID propid;
    VARTYPE vt;
    }	STATPROPSTG;

#undef  INTERFACE
#define INTERFACE   IEnumSTATPROPSTG

DECLARE_INTERFACE_(IEnumSTATPROPSTG, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Next) (THIS_ ULONG celt, STATPROPSTG *rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATPROPSTG **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IEnumSTATPROPSETSTG

DECLARE_INTERFACE_(IEnumSTATPROPSETSTG, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(Next) (THIS_ ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset)(THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATPROPSTG **ppenum) PURE;
};


#undef  INTERFACE
#define INTERFACE   IPropertyStorage

DECLARE_INTERFACE_(IPropertyStorage, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    STDMETHOD(ReadMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgvar[]) PURE;
    STDMETHOD(WriteMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgvar[], PROPID propidNameFirst) PURE;
    STDMETHOD(DeleteMultiple)(THIS_ ULONG cpspec, const PROPSPEC rgpspec[]) PURE;
    STDMETHOD(ReadPropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]) PURE;
    STDMETHOD(WritePropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]) PURE;
    STDMETHOD(DeletePropertyNames)(THIS_ ULONG cpropid, const PROPID rgpropid[]) PURE;
    STDMETHOD(SetClass)(THIS_ REFCLSID clsid) PURE;
    STDMETHOD(Commit)(THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert)(THIS) PURE;
    STDMETHOD(Enum)(THIS_ IEnumSTATPROPSTG** ppenm) PURE;
    STDMETHOD(Stat)(THIS_ STATPROPSETSTG* pstatpsstg) PURE;
    STDMETHOD(SetTimes)(THIS_ const FILETIME* pmtime, const FILETIME* pctime, const FILETIME* patime) PURE;
};

typedef REFGUID	REFFMTID;

#undef  INTERFACE
#define INTERFACE   IPropertySetStorage

DECLARE_INTERFACE_(IPropertySetStorage, IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Create)(THIS_ REFFMTID fmtid, const CLSID* pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppPropStg)PURE;
    STDMETHOD(Open)(THIS_ REFFMTID fmtid, DWORD grfMode, IPropertyStorage** ppPropStg) PURE;
    STDMETHOD(Delete)(THIS_ REFFMTID fmtid) PURE;
    STDMETHOD(Enum)(THIS_ IEnumSTATPROPSETSTG** ppenum) PURE;
};

typedef enum PROPSETFLAG {
    PROPSETFLAG_NONSIMPLE	= 1,
    PROPSETFLAG_ANSI			= 2,
    } PROPSETFLAG;

extern  const IID IID_IPropertyStorage;
extern  const IID IID_IEnumSTATPROPSTG;
extern  const IID IID_IPropertySetStorage;
extern  const IID IID_IEnumSTATPROPSETSTG;


#ifdef __cplusplus
}

#endif  /* __cplusplus */

#endif // __IPropertyStorage_INTERFACE_DEFINED__

#endif // _PROPSET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\qistub.h ===
#ifndef _QISTUB_H_
#define _QISTUB_H_

#ifdef DEBUG
STDAPI_(BOOL) DBIsQIStub(void *);
STDAPI_(void) DBDumpQIStub(void *);
STDAPI_(BOOL) DBIsQIFunc(int ret, int delta);
#endif

#endif // _QISTUB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\regitemp.h ===
//
//  RegItemP.h  - header for regitem IDLists
//  
//  NOTE - these structures cannot be changed for any reason.
//

#ifndef _REGITEMP_H_
#define _REGITEMP_H_

#ifndef NOPRAGMAS
#pragma pack(1)
#endif

typedef struct _IDREGITEM
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bOrder;
    CLSID   clsid;
} IDREGITEM;
typedef UNALIGNED IDREGITEM *LPIDREGITEM;
typedef const UNALIGNED IDREGITEM *LPCIDREGITEM;


typedef struct
{
    IDREGITEM       idri;
    USHORT          cbNext;
} IDLREGITEM;           // "RegItem" IDList
typedef const UNALIGNED IDLREGITEM *LPCIDLREGITEM;

#ifndef NOPRAGMAS
#pragma pack()
#endif


// stolen from shell32\shitemid.h
#ifndef SHID_ROOTEDREGITEM
#define SHID_ROOTEDREGITEM       0x1e    //
#endif //SHID_ROOTEDREGITEM

// stolen from shell32\shitemid.h
#ifndef SHID_ROOT_REGITEM
#define SHID_ROOT_REGITEM        0x1f    //
#endif //SHID_ROOT_REGITEM

#endif // _REGITEMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\qistub.cpp ===
//***   qistub.cpp -- QI helpers (retail and debug)
// DESCRIPTION
//  this file has the shared-source 'master' implementation.  it is
// #included in each DLL that uses it.
//  clients do something like:
//      #include "priv.h"   // for types, ASSERT, DM_*, DF_*, etc.
//      #include "../lib/qistub.cpp"

#include "qistub.h"
#include <strsafe.h>

#define DM_MISC2            0       // misc stuff (verbose)

// hack-o-rama: shlwapi/qistub.cpp does #undef DEBUG but its PCH was
// built DEBUG, so lots of bad stuff happens.  work-around it here.
#undef DBEXEC
#ifdef DEBUG
#define DBEXEC(flg, expr)    ((flg) ? (expr) : 0)
#else
#define DBEXEC(flg, expr)    /*NOTHING*/
#endif

#ifdef DEBUG // {
//***   CUniqueTab {
// DESCRIPTION
//  key/data table insert and lookup, w/ interlock.
class CUniqueTab
{
    public:
        BOOL Init();
        void * Add(int val);
        void * Find(int val, int delta);
        void Reset(void);

        // n.b. *not* protected
        CUniqueTab(int cbElt);
        virtual ~CUniqueTab();

    protected:

    private:
        void _Lock(void) { EnterCriticalSection(&_hLock); }
        void _Unlock(void) { LeaveCriticalSection(&_hLock); }

        CRITICAL_SECTION    _hLock;
        // key + (arbitrary) limit of 4 int's of client data
#define CUT_CBELTMAX    (SIZEOF(int) + 4 * SIZEOF(int))
        int     _cbElt;                 // size of an entry (key + data)
        // (arbitrary) limit to catch clients running amuck
#define CUT_CVALMAX 256         // actually, a LIM not a MAX
        HDSA    _hValTab;
};

CUniqueTab::CUniqueTab(int cbElt)
{
    ASSERT(cbElt >= SIZEOF(DWORD));     // need at least a key; data optional
    _cbElt = cbElt;
    _hValTab = DSA_Create(_cbElt, 4);
    return;
}

CUniqueTab::~CUniqueTab()
{
    DSA_Destroy(_hValTab);
    DeleteCriticalSection(&_hLock);
    return;
}

BOOL CUniqueTab::Init()
{
    return InitializeCriticalSectionAndSpinCount(&_hLock, 0);
}

struct cutent {
    int iKey;
    char bData[CUT_CBELTMAX - SIZEOF(int)];
};
struct cfinddata {
    int iKey;
    int dRange;
    void *pEntry;
};

int _UTFindCallback(void *pEnt, void *pData)
{
#define INFUNC(base, p, range) ((base) <= (p) && (p) <= (base) + (range))
    struct cfinddata *pcd = (struct cfinddata *)pData;
    if (INFUNC(*(int *)pEnt, pcd->iKey, pcd->dRange)) {
        pcd->pEntry = pEnt;
        return 0;
    }
    return 1;
#undef  INFUNC
}

//***   CUniqueTab::Add -- add entry if not already there
//
void * CUniqueTab::Add(int val)
{
    struct cfinddata cd = { val, 0, NULL };

    _Lock();

    DSA_EnumCallback(_hValTab, _UTFindCallback, &cd);
    if (!cd.pEntry) {
        int i;
        // lazy,lazy,lazy: alloc max size and let DSA_AppendItem sort it out
        struct cutent elt = { val, 0 /*,0,...,0*/ };

        TraceMsg(DM_MISC2, "cut.add: add %x", val);
        if (DSA_GetItemCount(_hValTab) <= CUT_CVALMAX) {
            i = DSA_AppendItem(_hValTab, &elt);
            cd.pEntry = DSA_GetItemPtr(_hValTab, i);
        }
    }

    _Unlock();

    return cd.pEntry;
}

//***   CUniqueTab::Find -- find entry
//
void * CUniqueTab::Find(int val, int delta)
{
    struct cfinddata cd = { val, delta, NULL };

    DSA_EnumCallback(_hValTab, _UTFindCallback, &cd);
    if (cd.pEntry) {
        // TODO: add p->data[0] dump
        TraceMsg(DM_MISC2, "cut.find: found %x+%d", val, delta);
    }
    return cd.pEntry;
}

//***   _UTResetCallback -- helper for CUniqueTab::Reset
int _UTResetCallback(void *pEnt, void *pData)
{
    struct cutent *pce = (struct cutent *)pEnt;
    int cbEnt = *(int *)pData;
    // perf: could move the SIZEOF(int) into caller, but seems safer here
    memset(pce->bData, 0, cbEnt - SIZEOF(int));
    return 1;
}

//***   Reset -- clear 'data' part of all entries
//
void CUniqueTab::Reset(void)
{
    if (EVAL(_cbElt > SIZEOF(int))) {
        _Lock();
        DSA_EnumCallback(_hValTab, _UTResetCallback, &_cbElt);
        _Unlock();
    }
    return;
}
// }
#endif // }

//***   QueryInterface helpers {

//***   FAST_IsEqualIID -- fast compare
// (cast to 'LONG_PTR' so don't get overloaded ==)
#define FAST_IsEqualIID(piid1, piid2)   ((LONG_PTR)(piid1) == (LONG_PTR)(piid2))

#ifdef DEBUG // {
//***   DBNoOp -- do nothing (but suppress compiler optimizations)
// NOTES
//  this won't fool compiler when it gets smarter, oh well...
void DBNoOp()
{
    return;
}

void DBBrkpt()
{
    DBNoOp();
    return;
}

//***   DBBreakGUID -- debug hook (gets readable name, allows brkpt on IID)
// DESCRIPTION
//  search for 'BRKPT' for various hooks.
//  patch 'DBQIiid' to brkpt on a specific iface
//  patch 'DBQIiSeq' to brkpt on Nth QI of specific iface
//  brkpt on interesting events noted below
// NOTES
//  warning: returns ptr to *static* buffer!

typedef enum {
    DBBRK_NIL   = 0,
    DBBRK_ENTER = 0x01,
    DBBRK_TRACE = 0x02,
    DBBRK_S_XXX = 0x04,
    DBBRK_E_XXX = 0x08,
    DBBRK_BRKPT = 0x10,
} DBBRK;

DBBRK DBQIuTrace = DBBRK_NIL;   // BRKPT patch to enable brkpt'ing
GUID *DBQIiid = NULL;           // BRKPT patch to brkpt on iface
int DBQIiSeq = -1;              // BRKPT patch to brkpt on Nth QI of DBQIiid
long DBQIfReset = FALSE;        // BRKPT patch to reset counters

TCHAR *DBBreakGUID(const GUID *piid, DBBRK brkCmd)
{
    static TCHAR szClass[GUIDSTR_MAX];

    SHStringFromGUID(*piid, szClass, ARRAYSIZE(szClass));

    // FEATURE: fold these 2 if's together
    if ((DBQIuTrace & brkCmd) &&
            (DBQIiid == NULL || IsEqualIID(*piid, *DBQIiid))) {
        TraceMsg(DM_TRACE, "util: DBBreakGUID brkCmd=%x clsid=%s (%s)", brkCmd, szClass, Dbg_GetREFIIDName(*piid));
        // BRKPT put brkpt here to brkpt on 'brkCmd' event
        DBBrkpt();
    }

    if (DBQIiid != NULL && IsEqualIID(*piid, *DBQIiid)) {
        //TraceMsg(DM_TRACE, "util: DBBreakGUID clsid=%s (%s)", szClass, Dbg_GetREFIIDName(*piid));
        if (brkCmd != DBBRK_TRACE) {
            // BRKPT put brkpt here to brkpt on 'DBQIiid' iface
            DBNoOp();
        }
    }

    // BRKPT put your brkpt(s) here for various events
    switch (brkCmd) {
        case DBBRK_ENTER:
            // QI called w/ this iface
            DBNoOp();
            break;
        case DBBRK_TRACE:
            // looped over this iface
            DBNoOp();
            break;
        case DBBRK_S_XXX:
            // successful QI for this iface
            DBNoOp();
            break;
        case DBBRK_E_XXX:
            // failed QI for this iface
            DBNoOp();
            break;
        case DBBRK_BRKPT:
            // various brkpt events, see backtrace to figure out which one
            DBNoOp();
            break;
    }

    return szClass;
}
#endif // }

#ifdef DEBUG
CUniqueTab *DBpQIFuncTab;

STDAPI_(BOOL) DBIsQIFunc(int ret, int delta)
{
    BOOL fRet = FALSE;

    if (DBpQIFuncTab)
        fRet = BOOLFROMPTR(DBpQIFuncTab->Find(ret, delta));

    return fRet;
}
#endif

//  perf: shell split means FAST_IsEqIID often fails, so QI_EASY is off.
#define QI_EASY     0       // w/ shell split, seems to be too rare

#ifdef DEBUG // {
int DBcQITot, DBcQIUnk, DBcQIErr, DBcQIEasy, DBcQIHard;

LPCQITAB DBpqitStats;           // BRKPT: patch to enable QITABENT profiling
#define DBSTAT_CNT      20
int DBcStats[DBSTAT_CNT + 3];   // 0..n, overflow, IUnknown, E_FAIL

#define DBSI_FAIL       (-1)
#define DBSI_IUNKNOWN   (-2)
#define DBSI_OVERFLOW   (-3)

#define DBSI_SPEC(i)    (DBSTAT_CNT - 1 + (-(i)))

//***
// DESCRIPTION
//  search for 'BRKPT' for various hooks.
//  patch 'DBpqitStats' to gather stats on that QITAB
//  then break into debugger (ctrl+C) and dumpa 'DBcStats l 24'
//  then sort high count guys to the front, and 0 count guys to the end
//
void DBQIStats(LPCQITAB pqitab, INT_PTR i)
{
    if (pqitab != DBpqitStats)
        return;

    if (i >= DBSTAT_CNT)
        i = DBSI_OVERFLOW;
    if (i < 0)
        i = DBSTAT_CNT - 1 + (-i);
    DBcStats[i]++;
    return;
}

void DBDumpQIStats()
{
    int i;
    TCHAR *p;
    TCHAR buf[256];

    TraceMsg(TF_QISTUB, "qi stats: tot=%d unk=%d err=%d easy(%d)=%d hard=%d",
            DBcQITot, DBcQIUnk, DBcQIErr, QI_EASY, DBcQIEasy, DBcQIHard);

    if (DBpqitStats == NULL)
        return;

    p = buf;
    for (i = 0; i < DBSTAT_CNT; i++) {
        p += wnsprintf(p, ARRAYSIZE(buf) - (p-buf), TEXT(" %d"), DBcStats[i]);
    }
    StringCchPrintf(p, ARRAYSIZE(buf) - (p-buf), TEXT(" o=%d u=%d e=%d"),
            DBcStats[DBSI_SPEC(DBSI_OVERFLOW)],
            DBcStats[DBSI_SPEC(DBSI_IUNKNOWN)],
            DBcStats[DBSI_SPEC(DBSI_FAIL)]);

    TraceMsg(TF_QISTUB, "qi stats: %s", buf);
    return;
}

#endif // }


//***   QISearch -- table-driven QI
// ENTRY/EXIT
//  this        IUnknown* of calling QI
//  pqit        QI table of IID,cast_offset pairs
//  ppv         the usual
//  hr          the usual S_OK/E_NOINTERFACE, plus other E_* for errors
// NOTES
//  perf: shell split means FAST_IsEqIID often fails, so QI_EASY is off.
//  perf: IUnknown v. rare, so goes last.
//  PERF: explicit 'E_NOIFACE' entry in qitab for common miss(es)?
STDAPI_(void*) QIStub_CreateInstance(void* that, IUnknown* punk, REFIID riid);	// qistub.cpp

STDAPI QISearch(void* that, LPCQITAB pqitab, REFIID riid, LPVOID* ppv)
{
    // do *not* move this!!! (must be 1st on frame)
#ifdef DEBUG
#if (_X86_)
    int var0;       // *must* be 1st on frame
#endif
#endif

    LPCQITAB pqit;
#ifdef DEBUG
    TCHAR *pst;

    DBEXEC(TRUE, DBcQITot++);
#if ( _X86_) // QIStub only works for X86
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGQI)) {
        if (DBpQIFuncTab == NULL)
            DBpQIFuncTab = new CUniqueTab(SIZEOF(DWORD));   // LONG_PTR?
        if (DBpQIFuncTab && DBpQIFuncTab->Init()) {
            int n;
            int fp = (int) (1 + (int *)&var0);
            struct DBstkback sbtab[1] = { 0 };
            n = DBGetStackBack(&fp, sbtab, ARRAYSIZE(sbtab));
            DBpQIFuncTab->Add(sbtab[n - 1].ret);
        }
    }
#endif

    if (DBQIuTrace)
        pst = DBBreakGUID(&riid, DBBRK_ENTER);
#endif

    if (ppv == NULL)
        return E_POINTER;

#if QI_EASY
    // 1st try the fast way
    for (pqit = pqitab; pqit->piid != NULL; pqit++) {
        DBEXEC(DBQIuTrace, (pst = DBBreakGUID(pqit->piid, DBBRK_TRACE)));
        if (FAST_IsEqualIID(&riid, pqit->piid)) {
            DBEXEC(TRUE, DBcQIEasy++);
            goto Lhit;
        }
    }
#endif

    // no luck, try the hard way
    for (pqit = pqitab; pqit->piid != NULL; pqit++) {
        DBEXEC(DBQIuTrace, (pst = DBBreakGUID(pqit->piid, DBBRK_TRACE)));
        if (IsEqualIID(riid, *(pqit->piid))) {
            DBEXEC(TRUE, DBcQIHard++);
#if QI_EASY
Lhit:
#else
            // keep 'easy' stats anyway
            DBEXEC(FAST_IsEqualIID(&riid, pqit->piid), DBcQIEasy++);
#endif
#ifdef DEBUG
            DBEXEC(TRUE, DBQIStats(pqitab, pqit - pqitab));
#if ( _X86_) // QIStub only works for X86
            if (IsFlagSet(g_dwDumpFlags, DF_DEBUGQI)) {
                IUnknown* punk = (IUnknown*)((LONG_PTR)that + pqit->dwOffset);
                *ppv = QIStub_CreateInstance(that, punk, riid);
                if (*ppv) {
                    pst = DBBreakGUID(&riid, DBBRK_S_XXX);
                    return S_OK;
                }
            }
#endif
#endif
Lcast:
            IUnknown* punk = (IUnknown*)((LONG_PTR)that + pqit->dwOffset);
            DBEXEC(TRUE, (pst = DBBreakGUID(&riid, DBBRK_S_XXX)));
            punk->AddRef();
            *ppv = punk;
            return S_OK;
        }
    }

    // no luck, try IUnknown (which is implicit in the table)
    // we try IUnknown last not 1st since stats show it's rare
    if (IsEqualIID(riid, IID_IUnknown)) {
        // just use 1st table entry
        pqit = pqitab;
        DBEXEC(TRUE, DBcQIUnk++);
        DBEXEC(TRUE, DBQIStats(pqitab, DBSI_IUNKNOWN));

        goto Lcast;
    }

    DBEXEC(DBQIuTrace, (pst = DBBreakGUID(&riid, DBBRK_E_XXX)));
    DBEXEC(TRUE, DBcQIErr++);
    DBEXEC(TRUE, DBQIStats(pqitab, DBSI_FAIL));
    *ppv = NULL;
    return E_NOINTERFACE;
}

// }

#ifdef DEBUG // {
#if ( _X86_) // { QIStub only works for X86

//***   QIStub helpers {

class CQIStub
{
    public:
        virtual void thunk0();
        // FEATURE: should AddRef/Release up _iSeq? don't recommend it.
        virtual STDMETHODIMP_(ULONG) AddRef(void)
        { _cRef++; return _cRef; }
        virtual STDMETHODIMP_(ULONG) Release(void)
        { _cRef--; if (_cRef>0) return _cRef; delete this; return 0; }
        virtual void thunk3();
        virtual void thunk4();
        virtual void thunk5();
        virtual void thunk6();
        virtual void thunk7();
        virtual void thunk8();
        virtual void thunk9();
        virtual void thunk10();
        virtual void thunk11();
        virtual void thunk12();
        virtual void thunk13();
        virtual void thunk14();
        virtual void thunk15();
        virtual void thunk16();
        virtual void thunk17();
        virtual void thunk18();
        virtual void thunk19();
        virtual void thunk20();
        virtual void thunk21();
        virtual void thunk22();
        virtual void thunk23();
        virtual void thunk24();
        virtual void thunk25();
        virtual void thunk26();
        virtual void thunk27();
        virtual void thunk28();
        virtual void thunk29();
        virtual void thunk30();
        virtual void thunk31();
        virtual void thunk32();
        virtual void thunk33();
        virtual void thunk34();
        virtual void thunk35();
        virtual void thunk36();
        virtual void thunk37();
        virtual void thunk38();
        virtual void thunk39();
        virtual void thunk40();
        virtual void thunk41();
        virtual void thunk42();
        virtual void thunk43();
        virtual void thunk44();
        virtual void thunk45();
        virtual void thunk46();
        virtual void thunk47();
        virtual void thunk48();
        virtual void thunk49();
        virtual void thunk50();
        virtual void thunk51();
        virtual void thunk52();
        virtual void thunk53();
        virtual void thunk54();
        virtual void thunk55();
        virtual void thunk56();
        virtual void thunk57();
        virtual void thunk58();
        virtual void thunk59();
        virtual void thunk60();
        virtual void thunk61();
        virtual void thunk62();
        virtual void thunk63();
        virtual void thunk64();
        virtual void thunk65();
        virtual void thunk66();
        virtual void thunk67();
        virtual void thunk68();
        virtual void thunk69();
        virtual void thunk70();
        virtual void thunk71();
        virtual void thunk72();
        virtual void thunk73();
        virtual void thunk74();
        virtual void thunk75();
        virtual void thunk76();
        virtual void thunk77();
        virtual void thunk78();
        virtual void thunk79();
        virtual void thunk80();
        virtual void thunk81();
        virtual void thunk82();
        virtual void thunk83();
        virtual void thunk84();
        virtual void thunk85();
        virtual void thunk86();
        virtual void thunk87();
        virtual void thunk88();
        virtual void thunk89();
        virtual void thunk90();
        virtual void thunk91();
        virtual void thunk92();
        virtual void thunk93();
        virtual void thunk94();
        virtual void thunk95();
        virtual void thunk96();
        virtual void thunk97();
        virtual void thunk98();
        virtual void thunk99();

    protected:
        CQIStub(void *that, IUnknown* punk, REFIID riid);
        friend void* QIStub_CreateInstance(void *that, IUnknown* punk, REFIID riid);
        friend BOOL __stdcall DBIsQIStub(void *that);
        friend void __stdcall DBDumpQIStub(void *that);
        friend TCHAR *DBGetQIStubSymbolic(void *that);

    private:
        ~CQIStub();

        static void *_sar;              // C (not C++) ptr to CQIStub::AddRef

        int       _cRef;
        IUnknown* _punk;                // vtable we hand off to
        void*     _that;                // "this" pointer of object we stub (for reference)
        IUnknown* _punkRef;             // "punk" (for reference)
        REFIID    _riid;                // iid of interface (for reference)
        int       _iSeq;                // sequence #
        TCHAR     _szName[GUIDSTR_MAX]; // legible name of interface (for reference)
};

struct DBQISeq
{
    GUID *  pIid;
    int     iSeq;
};
//CASSERT(SIZEOF(GUID *) == SIZEOF(DWORD));   // CUniqueTab uses DWORD's

// FEATURE: todo: _declspec(thread)
CUniqueTab * DBpQISeqTab = NULL;

extern "C" void *Dbg_GetREFIIDAtom(REFIID riid);    // lib/dump.c (priv.h?)

//***
// NOTES
//  there's actually a race condition here -- another thread can come in
// and do seq++, then we do the reset, etc. -- but the assumption is that
// the developer has set the flag in a scenario where this isn't an issue.
void DBQIReset(void)
{
    ASSERT(!DBQIfReset);    // caller should do test-and-clear
    if (DBpQISeqTab)
        DBpQISeqTab->Reset();

    return;
}

void *DBGetVtblEnt(void *that, int i);
#define VFUNC_ADDREF  1     // AddRef is vtbl[1]

void * CQIStub::_sar = NULL;

CQIStub::CQIStub(void* that, IUnknown* punk, REFIID riid) : _cRef(1), _riid(riid)
{
    _that = that;

    _punk = punk;
    if (_punk)
        _punk->AddRef();

    _punkRef = _punk; // for reference, so don't AddRef it!

    // c++ won't let me get &CQIStub::AddRef as a 'real' ptr (!@#$),
    // so we need to get it the hard way, viz. new'ing an object which
    // we know inherits it.
    if (_sar == NULL) {
        _sar = DBGetVtblEnt((void *)this, VFUNC_ADDREF);
        ASSERT(_sar != NULL);
    }

    StringCchCopy(_szName, ARRAYSIZE(_szName), Dbg_GetREFIIDName(riid));

    // generate sequence #
    if (DBpQISeqTab == NULL)
        DBpQISeqTab = new CUniqueTab(SIZEOF(struct DBQISeq));
    if (DBpQISeqTab && DBpQISeqTab->Init()) {
        struct DBQISeq *pqiseq;

        if (InterlockedExchange(&DBQIfReset, FALSE))
            DBQIReset();

        pqiseq = (struct DBQISeq *) DBpQISeqTab->Add((DWORD) Dbg_GetREFIIDAtom(riid));
        if (EVAL(pqiseq))       // (might fail on table overflow)
            _iSeq = pqiseq->iSeq++;
    }

    TraceMsg(TF_QISTUB, "ctor QIStub %s seq=%d (that=%x punk=%x) %x", _szName, _iSeq, _that, _punk, this);
}

CQIStub::~CQIStub()
{
    TraceMsg(TF_QISTUB, "dtor QIStub %s (that=%x punk=%x) %x", _szName, _that, _punk, this);

    ATOMICRELEASE(_punk);
}

STDAPI_(void*) QIStub_CreateInstance(void* that, IUnknown* punk, REFIID riid)
{
    CQIStub* pThis = new CQIStub(that, punk, riid);

    if (DBQIiSeq == pThis->_iSeq && IsEqualIID(riid, *DBQIiid)) {
        TCHAR *pst;
        // BRKPT put brkpt here to brkpt on seq#'th call to 'DBQIiid' iface
        pst = DBBreakGUID(&riid, DBBRK_BRKPT);
    }

    return(pThis);
}

//***   DBGetVtblEnt -- get vtable entry
// NOTES
//  always uses 1st vtbl (so MI won't work...).
void *DBGetVtblEnt(void *that, int i)
{
    void **vptr;
    void *pfunc;

    __try {
        vptr = (void **) *(void **) that;
        pfunc = (vptr == 0) ? 0 : vptr[i];
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        // since we're called from the DebMemLeak, we're only *guessing*
        // that we have a vptr etc., so we might fault.
        TraceMsg(TF_ALWAYS, "gve: GPF");
        pfunc = 0;
    }

    return pfunc;
}

//***   DBIsQIStub -- is 'this' a ptr to a 'CQIStub' object?
// DESCRIPTION
//  we look at the vtbl and assume that if we have a ptr to CQIStub::AddRef,
// then it's us.
// NOTES
//  M00BUG we do a 'new' in here, which can cause pblms if we're in the middle
// of intelli-leak and we end up doing a ReAlloc which moves the heap (raymondc
// found such a case).
//  M00BUG in a release build (w/ identical COMDAT folding) we'll get false
// hits since most/all AddRefs are identical and folded.  if we ever need to
// be more exact we can add a signature and key off that.
//  M00BUG hack hack we actually return a void *, just in case you want to
// know the 'real' object.  if that turns out to be useful, we should change
// to return a void * instead of a BOOL.

BOOL DBIsQIStub(void* that)
{
    void *par;

#if 0
    if (_sar == NULL)
        TraceMsg(DM_TRACE, "qis: _sar == NULL");
#endif

    par = DBGetVtblEnt(that, VFUNC_ADDREF);

#if 0
    TraceMsg(TF_ALWAYS, "IsQIStub(%x): par=%x _sar=%x", that, _sar, par);
#endif

    return (CQIStub::_sar == par && CQIStub::_sar != NULL) ? (BOOL)((CQIStub *)that)->_punk : 0;
#undef  VFUNC_ADDREF
}

TCHAR *DBGetQIStubSymbolic(void* that)
{
    class CQIStub *pqis = (CQIStub *) that;
    return pqis->_szName;
}

//***   DBDumpQIStub -- pretty-print a 'CQIStub'
//
STDAPI_(void) DBDumpQIStub(void* that)
{
    class CQIStub *pqis = (CQIStub *) that;
    TraceMsg(TF_ALWAYS, "\tqistub(%x): cRef=0x%x iSeq=%x iid=%s", that, pqis->_cRef, pqis->_iSeq, pqis->_szName);
}

// Memory layout of CQIStub is:
//    lpVtbl  // offset 0
//    _cRef   // offset 4
//    _punk   // offset 8
//
// "this" pointer stored in stack
//
// mov eax, ss:4[esp]          ; get pThis
// mov ecx, 8[eax]             ; get real object (_punk)
// mov eax, [ecx]              ; load the real vtable (_punk->lpVtbl)
//                             ; the above will fault if referenced after we're freed
// mov ss:4[esp], ecx          ; fix up stack object (_punk)
// jmp dword ptr cs:(4*i)[eax] ; jump to the real function
//
#define QIStubThunk(i) \
void _declspec(naked) CQIStub::thunk##i() \
{ \
    _asm mov eax, ss:4[esp]          \
        _asm mov ecx, 8[eax]             \
        _asm mov eax, [ecx]              \
        _asm mov ss:4[esp], ecx          \
        _asm jmp dword ptr cs:(4*i)[eax] \
}

QIStubThunk(0);
QIStubThunk(3);
QIStubThunk(4);
QIStubThunk(5);
QIStubThunk(6);
QIStubThunk(7);
QIStubThunk(8);
QIStubThunk(9);
QIStubThunk(10);
QIStubThunk(11);
QIStubThunk(12);
QIStubThunk(13);
QIStubThunk(14);
QIStubThunk(15);
QIStubThunk(16);
QIStubThunk(17);
QIStubThunk(18);
QIStubThunk(19);
QIStubThunk(20);
QIStubThunk(21);
QIStubThunk(22);
QIStubThunk(23);
QIStubThunk(24);
QIStubThunk(25);
QIStubThunk(26);
QIStubThunk(27);
QIStubThunk(28);
QIStubThunk(29);
QIStubThunk(30);
QIStubThunk(31);
QIStubThunk(32);
QIStubThunk(33);
QIStubThunk(34);
QIStubThunk(35);
QIStubThunk(36);
QIStubThunk(37);
QIStubThunk(38);
QIStubThunk(39);
QIStubThunk(40);
QIStubThunk(41);
QIStubThunk(42);
QIStubThunk(43);
QIStubThunk(44);
QIStubThunk(45);
QIStubThunk(46);
QIStubThunk(47);
QIStubThunk(48);
QIStubThunk(49);
QIStubThunk(50);
QIStubThunk(51);
QIStubThunk(52);
QIStubThunk(53);
QIStubThunk(54);
QIStubThunk(55);
QIStubThunk(56);
QIStubThunk(57);
QIStubThunk(58);
QIStubThunk(59);
QIStubThunk(60);
QIStubThunk(61);
QIStubThunk(62);
QIStubThunk(63);
QIStubThunk(64);
QIStubThunk(65);
QIStubThunk(66);
QIStubThunk(67);
QIStubThunk(68);
QIStubThunk(69);
QIStubThunk(70);
QIStubThunk(71);
QIStubThunk(72);
QIStubThunk(73);
QIStubThunk(74);
QIStubThunk(75);
QIStubThunk(76);
QIStubThunk(77);
QIStubThunk(78);
QIStubThunk(79);
QIStubThunk(80);
QIStubThunk(81);
QIStubThunk(82);
QIStubThunk(83);
QIStubThunk(84);
QIStubThunk(85);
QIStubThunk(86);
QIStubThunk(87);
QIStubThunk(88);
QIStubThunk(89);
QIStubThunk(90);
QIStubThunk(91);
QIStubThunk(92);
QIStubThunk(93);
QIStubThunk(94);
QIStubThunk(95);
QIStubThunk(96);
QIStubThunk(97);
QIStubThunk(98);
QIStubThunk(99);

// }

#endif // }
#endif // }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\qsort.h ===
// template qsort adapted from  msdev\crt\src\qsort.c
// created 7/96  bobp

// template<class T>
// void QSort (T *base, unsigned nEl, BOOL fSortUp)
// 
// quicksort array of T
//
// Uses class T member functions:
//    operator =
//  operator <=

#ifndef __TQSORT_INCL
#define __TQSORT_INCL

template<class T>
inline void Swap(T &a, T &b)
{
    T x = a; a = b; b = x;
}

template<class T>
static void __cdecl ShortSort (T *lo, T *hi, BOOL fUp)
{
    T *p, *max;

    while (hi > lo) {
        max = lo;
        if (fUp) {
            for (p = lo+1; p <= hi; p++) {
                if ( !(*p <= *max) )
                    max = p;
            }
        } else {
            for (p = lo+1; p <= hi; p++) {
                if ( !(*max <= *p) )
                    max = p;
            }
        }

        Swap (*max, *hi);

        hi --;
    }
}

#define CUTOFF 8            /* testing shows that this is good value */

template<class T>
void QSort (T *base, unsigned nEl, BOOL fUp)
{
    T *lo, *hi;              /* ends of sub-array currently sorting */
    T *mid;                  /* points to middle of subarray */
    T *loguy, *higuy;        /* traveling pointers for partition step */
    unsigned size;           /* size of the sub-array */
    T *lostk[30], *histk[30];
    int stkptr;              /* stack for saving sub-array to be processed */

    /* Note: the number of stack entries required is no more than
       1 + log2(size), so 30 is sufficient for any array */

    if (nEl < 2)
        return;                 /* nothing to do */

    stkptr = 0;                 /* initialize stack */

    lo = base;
    hi = base + (nEl-1);        /* initialize limits */

recurse:

    size = (int)(hi - lo) + 1;   /* number of el's to sort */

    if (size <= CUTOFF) {
         ShortSort(lo, hi, fUp);
    }
    else {
        mid = lo + (size / 2);   /* find middle element */
        Swap(*mid, *lo);         /* swap it to beginning of array */
        loguy = lo;
        higuy = hi + 1;

        for (;;) {
            if (fUp) {
                do  {
                    loguy ++;
                } while (loguy <= hi && *loguy <= *lo);

                do  {
                    higuy --;
                } while (higuy > lo && *lo <= *higuy);
            } else {
                do  {
                    loguy ++;
                } while (loguy <= hi && *lo <= *loguy);

                do  {
                    higuy --;
                } while (higuy > lo && *higuy <= *lo);
            }

            if (higuy < loguy)
                break;

            Swap(*loguy, *higuy);
        }

        Swap(*lo, *higuy);     /* put partition element in place */

        if ( higuy - 1 - lo >= hi - loguy ) {
            if (lo + 1 < higuy) {
                lostk[stkptr] = lo;
                histk[stkptr] = higuy - 1;
                ++stkptr;
            }                           /* save big recursion for later */

            if (loguy < hi) {
                lo = loguy;
                goto recurse;           /* do small recursion */
            }
        }
        else {
            if (loguy < hi) {
                lostk[stkptr] = loguy;
                histk[stkptr] = hi;
                ++stkptr;               /* save big recursion for later */
            }

            if (lo + 1 < higuy) {
                hi = higuy - 1;
                goto recurse;           /* do small recursion */
            }
        }
    }

    --stkptr;
    if (stkptr >= 0) {
        lo = lostk[stkptr];
        hi = histk[stkptr];
        goto recurse;           /* pop subarray from stack */
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\rpctimeout.h ===
#ifndef _RPCTIMEOUT_H_
#define _RPCTIMEOUT_H_

////////////////
//
//  Timing out remote calls - Use this if you are using an out-of-proc
//  object (e.g., a clipboard data object) that may belong to an app
//  that is hung.
//
//  If any individual method takes more than dwTimeout milliseconds, the
//  call will be aborted and you will get an error code back.
//
//  Usage:
//
//  Typical usage...
//
//      CRPCTimeout timeout;            // optional timeout in milliseconds
//      hr = pdto->GetData(...);        // make some remote call
//      hr = pdto->GetData(...);        // make another remote call
//
//  If either of the GetData calls takes more than TIMEOUT_DEFAULT
//  milliseconds, it will be cancelled and return an error.
//
//  Timed-out-ness is sticky.  Once a single call has timed out, all
//  subsequent calls will be timed out immediately (to avoid hanging
//  on the same server over and over again) until the timeout object
//  is re-armed.
//
//  When the CRPCTimeout goes out of scope, it will disarm itself.
//  Or you can explicitly call the Disarm() method.
//
//  Fancier usage...
//
//      CRPCTimeout timeout(5000);      // five seconds
//      hr = pdto->GetData();           // this one times out after 5 seconds
//      timeout.Disarm();               // disable the timeout
//      hr = pdto->GetData();           // this one runs as long as necesary
//      timeout.Arm(2000);              // rearm the timer with a new timeout
//      hr = pdto->GetData();           // this one times out after 2 seconds
//      hr = pdto->GetData();           // this one times out after 2 seconds
//      if (timeout.TimedOut()) ...     // handle the timeout scenario
//
//
//
//  If you create multiple CRPCTimeout objects, you MUST disarm them in
//  reverse order or the timeout chain will be corrupted.  (Debug-only
//  code will attempt to catch this bug.)
//
//  Instead of creating multiple timeout objects at the same scope, you
//  should create just one object and rearm it.
//
//

class CRPCTimeout {
public:
    CRPCTimeout() { Init(); Arm(); }
    CRPCTimeout(DWORD dwTimeout) { Init(); Arm(dwTimeout); }
    ~CRPCTimeout() { Disarm(); }

    void Init();
    void Arm(DWORD dwTimeout = 0);
    void Disarm();
    BOOL TimedOut() const { return _fTimedOut; }

private:
    static void CALLBACK _Callback(PVOID lpParameter, BOOLEAN);

    DWORD   _dwThreadId;
    BOOL    _fTimedOut;
    HRESULT _hrCancelEnabled;
    HANDLE  _hTimer;
};

#endif // _RPCTIMEOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\runonce.h ===
//
// runonce.h
//

#ifndef _RUNONCE_INC
#define _RUNONCE_INC

// Cabinet_EnumRegApps flags 
#define RRA_DEFAULT               0x0000
#define RRA_DELETE                0x0001        // delete each reg value when we're done with it
#define RRA_WAIT                  0x0002        // Wait for current item to finish before launching next item
// was RRA_SHELLSERVICEOBJECTS    0x0004 -- do not reuse
#define RRA_NOUI                  0x0008        // prevents ShellExecuteEx from displaying error dialogs
#if (_WIN32_WINNT >= 0x0500)
#define RRA_USEJOBOBJECTS         0x0020        // wait on job objects instead of process handles
#endif

typedef UINT RRA_FLAGS;

typedef struct {
    TCHAR szSubkey[MAX_PATH];
    TCHAR szValueName[MAX_PATH];
    TCHAR szCmdLine[MAX_PATH];
} REGAPP_INFO;

// legacy from ripping this code out of explorer\initcab.cpp
extern BOOL g_fCleanBoot;   // are we running in SAFE-MODE?
extern BOOL g_fEndSession;  // did we process a WM_ENDSESSION?

typedef BOOL (WINAPI* PFNREGAPPSCALLBACK)(LPCTSTR szSubkey, LPCTSTR szCmdLine, RRA_FLAGS fFlags, LPARAM lParam);


STDAPI_(BOOL) ShellExecuteRegApp(LPCTSTR pszCmdLine, RRA_FLAGS fFlags);
STDAPI_(BOOL) Cabinet_EnumRegApps(HKEY hkeyParent, LPCTSTR pszSubkey, RRA_FLAGS fFlags, PFNREGAPPSCALLBACK pfnCallback, LPARAM lParam);
STDAPI_(BOOL) ExecuteRegAppEnumProc(LPCTSTR szSubkey, LPCTSTR szCmdLine, RRA_FLAGS fFlags, LPARAM lParam);


#endif // _RUNONCE_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\runtask.h ===
#ifndef _RUNTASK_H_
#define _RUNTASK_H_

class CRunnableTask : public IRunnableTask
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IRunnableTask ***
    virtual STDMETHODIMP Run(void);
    virtual STDMETHODIMP Kill(BOOL bWait);
    virtual STDMETHODIMP Suspend(void);
    virtual STDMETHODIMP Resume(void);
    virtual STDMETHODIMP_(ULONG) IsRunning(void);

    // *** pure virtuals ***
    virtual STDMETHODIMP RunInitRT(void) PURE;
    virtual STDMETHODIMP KillRT(BOOL bWait)     { return S_OK; };
    virtual STDMETHODIMP SuspendRT(void)        { return S_OK; };
    virtual STDMETHODIMP ResumeRT(void)         { return InternalResumeRT(); };
    virtual STDMETHODIMP InternalResumeRT(void) { _lState = IRTIR_TASK_FINISHED; return S_OK; };
    
protected:
    CRunnableTask(DWORD dwFlags);
    virtual ~CRunnableTask();
    
    LONG            _cRef;
    LONG            _lState;
    DWORD           _dwFlags;       // RTF_*
    HANDLE          _hDone;

#ifdef DEBUG
    DWORD           _dwTaskID;
#endif
};

// CRunnableTask flags
#define RTF_DEFAULT             0x00000000
#define RTF_SUPPORTKILLSUSPEND  0x00000001

#endif  // _RUNTASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\runonce.c ===
//
// runonce.c (shared runonce code between explorer.exe and runonce.exe)
//
#include <runonce.h>
// Need this to avoid build errors in places where this file is
// included but deperecated functions are still used
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#if (_WIN32_WINNT >= 0x0500)

// stolen from <tsappcmp.h>
#define TERMSRV_COMPAT_WAIT_USING_JOB_OBJECTS 0x00008000
#define CompatibilityApp 1
typedef LONG TERMSRV_COMPATIBILITY_CLASS;
typedef BOOL (* PFNGSETTERMSRVAPPINSTALLMODE)(BOOL bState);
typedef BOOL (* PFNGETTERMSRVCOMPATFLAGSEX)(LPWSTR pwszApp, DWORD* pdwFlags, TERMSRV_COMPATIBILITY_CLASS tscc);

// even though this function is in kernel32.lib, we need to have a LoadLibrary/GetProcAddress 
// thunk for downlevel components who include this
STDAPI_(BOOL) SHSetTermsrvAppInstallMode(BOOL bState)
{
    static PFNGSETTERMSRVAPPINSTALLMODE pfn = NULL;

    if (pfn == NULL)
    {
        // kernel32 should already be loaded
        HMODULE hmod = GetModuleHandle(TEXT("kernel32.dll"));

        if (hmod)
        {
            pfn = (PFNGSETTERMSRVAPPINSTALLMODE)GetProcAddress(hmod, "SetTermsrvAppInstallMode");
        }
        else
        {
            pfn = (PFNGSETTERMSRVAPPINSTALLMODE)-1;
        }
    }

    if (pfn && (pfn != (PFNGSETTERMSRVAPPINSTALLMODE)-1))
    {
        return pfn(bState);
    }
    else
    {
        return FALSE;
    }
}


STDAPI_(ULONG) SHGetTermsrCompatFlagsEx(LPWSTR pwszApp, DWORD* pdwFlags, TERMSRV_COMPATIBILITY_CLASS tscc)
{
    static PFNGETTERMSRVCOMPATFLAGSEX pfn = NULL;

    if (pfn == NULL)
    {
        HMODULE hmod = LoadLibrary(TEXT("TSAppCMP.DLL"));

        if (hmod)
        {
            pfn = (PFNGETTERMSRVCOMPATFLAGSEX)GetProcAddress(hmod, "GetTermsrCompatFlagsEx");
        }
        else
        {
            pfn = (PFNGETTERMSRVCOMPATFLAGSEX)-1;
        }
    }

    if (pfn && (pfn != (PFNGETTERMSRVCOMPATFLAGSEX)-1))
    {
        return pfn(pwszApp, pdwFlags, tscc);
    }
    else
    {
        *pdwFlags = 0;
        return 0;
    }
}


HANDLE SetJobCompletionPort(HANDLE hJob)
{
    HANDLE hRet = NULL;
    HANDLE hIOPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 1);

    if (hIOPort != NULL)
    {
        JOBOBJECT_ASSOCIATE_COMPLETION_PORT CompletionPort;

        CompletionPort.CompletionKey = hJob ;
        CompletionPort.CompletionPort = hIOPort;

        if (SetInformationJobObject(hJob,
                    JobObjectAssociateCompletionPortInformation,
                    &CompletionPort,
                    sizeof(CompletionPort)))
        {   
            hRet = hIOPort;
        }
        else
        {
            CloseHandle(hIOPort);
        }
    }

    return hRet;

}


STDAPI_(DWORD) WaitingThreadProc(void *pv)
{
    HANDLE hIOPort = (HANDLE)pv;

    if (hIOPort)
    {
        while (TRUE) 
        {
            DWORD dwCompletionCode;
            ULONG_PTR pCompletionKey;
            LPOVERLAPPED pOverlapped;

            if (!GetQueuedCompletionStatus(hIOPort, &dwCompletionCode, &pCompletionKey, &pOverlapped, INFINITE) ||
                    (dwCompletionCode == JOB_OBJECT_MSG_ACTIVE_PROCESS_ZERO))
            {
                break;
            }
        }
    }

    return 0;
}


//
// The following handles running an application and optionally waiting for it
// to all the child procs to terminate. This is accomplished thru Kernel Job Objects
// which is only available in NT5
//
BOOL _CreateRegJob(LPCTSTR pszCmd, BOOL bWait)
{
    BOOL bRet = FALSE;
    HANDLE hJobObject = CreateJobObjectW(NULL, NULL);

    if (hJobObject)
    {
        HANDLE hIOPort = SetJobCompletionPort(hJobObject);

        if (hIOPort)
        {
            DWORD dwID;
            HANDLE hThread = CreateThread(NULL,
                    0,
                    WaitingThreadProc,
                    (void*)hIOPort,
                    CREATE_SUSPENDED,
                    &dwID);

            if (hThread)
            {
                PROCESS_INFORMATION pi = {0};
                STARTUPINFO si = {0};
                UINT fMask = SEE_MASK_FLAG_NO_UI;
                DWORD dwCreationFlags = CREATE_SUSPENDED;
                TCHAR sz[MAX_PATH * 2];
                TCHAR szAppPath[MAX_PATH];

                if (GetSystemDirectory(szAppPath, ARRAYSIZE(szAppPath)))
                {
                    if (PathAppend(szAppPath, TEXT("RunDLL32.EXE")))
                    {
                        if (SUCCEEDED(StringCchPrintf(sz, ARRAYSIZE(sz), 
                                        TEXT("RunDLL32.EXE Shell32.DLL,ShellExec_RunDLL ?0x%X?%s"), fMask, pszCmd)))
                        {
                            si.cb = sizeof(si);

                            if (CreateProcess(szAppPath,
                                        sz,
                                        NULL,
                                        NULL,
                                        FALSE,
                                        dwCreationFlags,
                                        NULL,
                                        NULL,
                                        &si,
                                        &pi))
                            {
                                if (AssignProcessToJobObject(hJobObject, pi.hProcess))
                                {
                                    // success!
                                    bRet = TRUE;

                                    ResumeThread(pi.hThread);
                                    ResumeThread(hThread);

                                    if (bWait)
                                    {
                                        SHProcessMessagesUntilEvent(NULL, hThread, INFINITE);
                                    }
                                }
                                else
                                {
                                    TerminateProcess(pi.hProcess, ERROR_ACCESS_DENIED);    
                                }

                                CloseHandle(pi.hProcess);
                                CloseHandle(pi.hThread);
                            }
                        }
                    }
                }

                if (!bRet)
                {
                    TerminateThread(hThread, ERROR_ACCESS_DENIED);
                }

                CloseHandle(hThread);
            }

            CloseHandle(hIOPort);
        }

        CloseHandle(hJobObject);
    }

    return bRet;
}


BOOL _TryHydra(LPCTSTR pszCmd, RRA_FLAGS *pflags)
{
    // See if the terminal-services is enabled in "Application Server" mode
    if (IsOS(OS_TERMINALSERVER) && SHSetTermsrvAppInstallMode(TRUE))
    {
        WCHAR   sz[MAX_PATH];

        *pflags |= RRA_WAIT; 
        // Changing timing blows up IE 4.0, but IE5 is ok!
        // we are on a TS machine, NT version 4 or 5, with admin priv

        // see if the app-compatability flag is set for this executable
        // to use the special job-objects for executing module

        // get the module name, without the arguments
        if (0 < PathProcessCommand(pszCmd, sz, ARRAYSIZE(sz), PPCF_NODIRECTORIES))
        {
            ULONG   ulCompat;
            SHGetTermsrCompatFlagsEx(sz, &ulCompat, CompatibilityApp);

            // if the special flag for this module-name is set...
            if (ulCompat & TERMSRV_COMPAT_WAIT_USING_JOB_OBJECTS)
            {
                *pflags |= RRA_USEJOBOBJECTS;
            }
        }

        return TRUE;
    }

    return FALSE;
}
#endif // (_WIN32_WINNT >= 0x0500)

//
//  On success: returns process handle or INVALID_HANDLE_VALUE if no process
//              was launched (i.e., launched via DDE).
//  On failure: returns INVALID_HANDLE_VALUE.
//
BOOL _ShellExecRegApp(LPCTSTR pszCmd, BOOL fNoUI, BOOL fWait)
{
    TCHAR szQuotedCmdLine[MAX_PATH+2];
    LPTSTR pszArgs;
    SHELLEXECUTEINFO ei = {0};
    BOOL fNoError = TRUE;

    // Gross, but if the process command fails, copy the command line to let
    // shell execute report the errors
    if (PathProcessCommand((LPWSTR)pszCmd,
                (LPWSTR)szQuotedCmdLine,
                ARRAYSIZE(szQuotedCmdLine),
                PPCF_ADDARGUMENTS|PPCF_FORCEQUALIFY) == -1)
    {
        if (FAILED(StringCchCopy(szQuotedCmdLine, ARRAYSIZE(szQuotedCmdLine), pszCmd)))
        {
            fNoError = FALSE;
        }
    }

    if (fNoError)
    {
        pszArgs= PathGetArgs(szQuotedCmdLine);
        if (*pszArgs)
        {
            // Strip args
            *(pszArgs - 1) = 0;
        }

        PathUnquoteSpaces(szQuotedCmdLine);

        ei.cbSize          = sizeof(SHELLEXECUTEINFO);
        ei.lpFile          = szQuotedCmdLine;
        ei.lpParameters    = pszArgs;
        ei.nShow           = SW_SHOWNORMAL;
        ei.fMask           = SEE_MASK_NOCLOSEPROCESS;

        if (fNoUI)
        {
            ei.fMask |= SEE_MASK_FLAG_NO_UI;
        }

        if (ShellExecuteEx(&ei))
        {
            if (ei.hProcess)
            {
                if (fWait)
                {
                    SHProcessMessagesUntilEvent(NULL, ei.hProcess, INFINITE);
                }

                CloseHandle(ei.hProcess);
            }

            fNoError = TRUE;
        }
        else
        {
            fNoError = FALSE;
        }
    }
    return fNoError;
}


// The following handles running an application and optionally waiting for it
// to terminate.
STDAPI_(BOOL) ShellExecuteRegApp(LPCTSTR pszCmdLine, RRA_FLAGS fFlags)
{
    BOOL bRet = FALSE;

    if (!pszCmdLine || !*pszCmdLine)
    {
        // Don't let empty strings through, they will endup doing something dumb
        // like opening a command prompt or the like
        return bRet;
    }

#if (_WIN32_WINNT >= 0x0500)
    if (fFlags & RRA_USEJOBOBJECTS)
    {
        bRet = _CreateRegJob(pszCmdLine, fFlags & RRA_WAIT);
    }
#endif

    if (!bRet)
    {
        //  fallback if necessary.
        bRet = _ShellExecRegApp(pszCmdLine, fFlags & RRA_NOUI, fFlags & RRA_WAIT);
    }

    return bRet;
}


STDAPI_(BOOL) Cabinet_EnumRegApps(HKEY hkeyParent, LPCTSTR pszSubkey, RRA_FLAGS fFlags, PFNREGAPPSCALLBACK pfnCallback, LPARAM lParam)
{
    HKEY hkey;
    BOOL bRet = TRUE;

    // With the addition of the ACL controlled "policy" run keys RegOpenKey
    // might fail on the pszSubkey.  Use RegOpenKeyEx with MAXIMIM_ALLOWED
    // to ensure that we successfully open the subkey.
    if (RegOpenKeyEx(hkeyParent, pszSubkey, 0, MAXIMUM_ALLOWED, &hkey) == ERROR_SUCCESS)
    {
        DWORD cbValue;
        DWORD dwType;
        DWORD i;
        TCHAR szValueName[80];
        TCHAR szCmdLine[MAX_PATH];
        HDPA hdpaEntries = NULL;

#ifdef DEBUG
        //
        // we only support named values so explicitly purge default values
        //
        LONG cbData = sizeof(szCmdLine);
        if (RegQueryValue(hkey, NULL, szCmdLine, &cbData) == ERROR_SUCCESS)
        {
            ASSERTMSG((cbData <= 2), "Cabinet_EnumRegApps: BOGUS default entry in <%s> '%s'", pszSubkey, szCmdLine);
            RegDeleteValue(hkey, NULL);
        }
#endif
        // now enumerate all of the values.
        for (i = 0; !g_fEndSession ; i++)
        {
            LONG lEnum;
            DWORD cbData;

            cbValue = ARRAYSIZE(szValueName);
            cbData = sizeof(szCmdLine);

            lEnum = RegEnumValue(hkey, i, szValueName, &cbValue, NULL, &dwType, (LPBYTE)szCmdLine, &cbData);

            if (ERROR_MORE_DATA == lEnum)
            {
                // ERROR_MORE_DATA means the value name or data was too large
                // skip to the next item
                TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: cannot run oversize entry '%s' in <%s>", szValueName, pszSubkey);
                continue;
            }
            else if (lEnum != ERROR_SUCCESS)
            {
                if (lEnum != ERROR_NO_MORE_ITEMS)
                {
                    // we hit some kind of registry failure
                    bRet = FALSE;
                }
                break;
            }

            if ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))
            {
                REGAPP_INFO * prai;

                if (dwType == REG_EXPAND_SZ)
                {
                    DWORD dwChars;
                    TCHAR szCmdLineT[MAX_PATH];

                    if (FAILED(StringCchCopy(szCmdLineT, ARRAYSIZE(szCmdLineT), szCmdLine)))
                    {
                        // bail on this value if string doesn't fit 
                        continue;
                    }
                    dwChars = SHExpandEnvironmentStrings(szCmdLineT, 
                            szCmdLine,
                            ARRAYSIZE(szCmdLine));
                    if ((dwChars == 0) || (dwChars > ARRAYSIZE(szCmdLine)))
                    {
                        // bail on this value if we failed the expansion, or if the string is > MAX_PATH
                        TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: expansion of '%s' in <%s> failed or is too long", szCmdLineT, pszSubkey);
                        continue;
                    }
                }

                TraceMsg(TF_GENERAL, "Cabinet_EnumRegApps: subkey = %s cmdline = %s", pszSubkey, szCmdLine);

                if (g_fCleanBoot && (szValueName[0] != TEXT('*')))
                {
                    // only run things marked with a "*" in when in SafeMode
                    continue;
                }

                // We used to execute each entry, wait for it to finish, and then make the next call to 
                // RegEnumValue(). The problem with this is that some apps add themselves back to the runonce
                // after they are finished (test harnesses that reboot machines and want to be restarted) and
                // we dont want to delete them, so we snapshot the registry keys and execute them after we
                // have finished the enum.
                prai = (REGAPP_INFO *)LocalAlloc(LPTR, sizeof(REGAPP_INFO));
                if (prai)
                {
                    if (SUCCEEDED(StringCchCopy(prai->szSubkey, ARRAYSIZE(prai->szSubkey), pszSubkey)) &&
                            SUCCEEDED(StringCchCopy(prai->szValueName, ARRAYSIZE(prai->szValueName), szValueName)) &&
                            SUCCEEDED(StringCchCopy(prai->szCmdLine, ARRAYSIZE(prai->szCmdLine), szCmdLine)))
                    {
                        if (!hdpaEntries)
                        {
                            hdpaEntries = DPA_Create(5);
                        }

                        if (!hdpaEntries || (DPA_AppendPtr(hdpaEntries, prai) == -1))
                        {
                            LocalFree(prai);
                        }
                    }
                }
            }
        }

        if (hdpaEntries)
        {
            int iIndex;
            int iTotal = DPA_GetPtrCount(hdpaEntries);

            for (iIndex = 0; iIndex < iTotal; iIndex++)
            {
                REGAPP_INFO* prai = (REGAPP_INFO*)DPA_GetPtr(hdpaEntries, iIndex);
                ASSERT(prai);

                // NB Things marked with a '!' mean delete after
                // the CreateProcess not before. This is to allow
                // certain apps (runonce.exe) to be allowed to rerun
                // to if the machine goes down in the middle of execing
                // them. Be very afraid of this switch.
                if ((fFlags & RRA_DELETE) && (prai->szValueName[0] != TEXT('!')))
                {
                    // This delete can fail if the user doesn't have the privilege
                    if (RegDeleteValue(hkey, prai->szValueName) != ERROR_SUCCESS)
                    {
                        TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: skipping entry %s (cannot delete the value)", prai->szValueName);
                        LocalFree(prai);
                        continue;
                    }
                }

                pfnCallback(prai->szSubkey, prai->szCmdLine, fFlags, lParam);

                // Post delete '!' things.
                if ((fFlags & RRA_DELETE) && (prai->szValueName[0] == TEXT('!')))
                {
                    // This delete can fail if the user doesn't have the privilege
                    if (RegDeleteValue(hkey, prai->szValueName) != ERROR_SUCCESS)
                    {
                        TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: cannot delete the value %s ", prai->szValueName);
                    }
                }

                LocalFree(prai);
            }

            DPA_Destroy(hdpaEntries);
            hdpaEntries = NULL;
        }

        RegCloseKey(hkey);
    }
    else
    {
        TraceMsg(TF_WARNING, "Cabinet_EnumRegApps: failed to open subkey %s !", pszSubkey);
        bRet = FALSE;
    }


    if (g_fEndSession)
    {
        // NOTE: this is for explorer only, other consumers of runonce.c must declare g_fEndSession but leave
        // it set to FALSE always.

        // if we rx'd a WM_ENDSESSION whilst running any of these keys we must exit the process.
        ExitProcess(0);
    }

    return bRet;
}

STDAPI_(BOOL) ExecuteRegAppEnumProc(LPCTSTR szSubkey, LPCTSTR szCmdLine, RRA_FLAGS fFlags, LPARAM lParam)
{
    BOOL bRet;
    RRA_FLAGS flagsTemp = fFlags;
    BOOL fInTSInstallMode = FALSE;

#if (_WIN32_WINNT >= 0x0500)
    // In here, We only attempt TS specific in app-install-mode 
    // if RunOnce entries are being processed 
    if (0 == lstrcmpi(szSubkey, REGSTR_PATH_RUNONCE)) 
    {
        fInTSInstallMode = _TryHydra(szCmdLine, &flagsTemp);
    }
#endif

    bRet = ShellExecuteRegApp(szCmdLine, flagsTemp);

#if (_WIN32_WINNT >= 0x0500)
    if (fInTSInstallMode)
    {
        SHSetTermsrvAppInstallMode(FALSE);
    }
#endif

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\sfstorage.cpp ===
#include "sfstorage.h"

class CSFStorageEnum : public IEnumSTATSTG
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IEnumSTATSTG
    STDMETHOD(Skip)(ULONG celt)
        { return E_NOTIMPL; };
    STDMETHOD(Clone)(IEnumSTATSTG **ppenum)
        { return E_NOTIMPL; };

    STDMETHOD(Next)(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched);
    STDMETHOD(Reset)();

protected:
    CSFStorageEnum(CSFStorage* psfstg);
    ~CSFStorageEnum();

private:
    LONG         _cRef;
    CSFStorage  *_psfstg;
    IEnumIDList *_peidl;

    HRESULT _PidlToSTATSTG(LPCITEMIDLIST pidl, STATSTG *pstatstg);

    friend CSFStorage;
};


CSFStorageEnum::CSFStorageEnum(CSFStorage *psfstg) :
    _cRef(1)
{
    _psfstg = psfstg;
    _psfstg->AddRef();

    DllAddRef();
}

CSFStorageEnum::~CSFStorageEnum()
{
    _psfstg->Release();
    ATOMICRELEASE(_peidl);

    DllRelease();
}

STDMETHODIMP_(ULONG) CSFStorageEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CSFStorageEnum::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CSFStorageEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =  {
        QITABENT(CSFStorageEnum, IEnumSTATSTG), // IEnumSTATSTG
        { 0 },
    };    
    return QISearch(this, qit, riid, ppv);
}

HRESULT CSFStorageEnum::_PidlToSTATSTG(LPCITEMIDLIST pidl, STATSTG *pstatstg)
{
    ZeroMemory(pstatstg, sizeof(*pstatstg));  // per COM conventions

    VARIANT var;
    VariantInit(&var);
    HRESULT hr = _psfstg->GetDetailsEx(pidl, &SCID_FINDDATA, &var);
    if (SUCCEEDED(hr))
    {
        WIN32_FIND_DATAW wfd;
        if (VariantToBuffer(&var, &wfd, sizeof(wfd)))
        {
            pstatstg->atime = wfd.ftLastAccessTime;
            pstatstg->ctime = wfd.ftCreationTime;
            pstatstg->mtime = wfd.ftLastWriteTime;
            pstatstg->cbSize.HighPart = wfd.nFileSizeHigh;
            pstatstg->cbSize.LowPart = wfd.nFileSizeLow;
            pstatstg->type = (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) ? STGTY_STORAGE : STGTY_STREAM;
            hr = SHStrDupW(wfd.cFileName, &pstatstg->pwcsName);
        }
        VariantClear(&var);
    }
    return hr;
}

STDMETHODIMP CSFStorageEnum::Next(ULONG celt, STATSTG *rgelt, ULONG *pceltFetched)
{
    ASSERT((celt != 1) ? (pceltFetched != NULL) : TRUE);

    HRESULT hr = S_OK;
    
    if (!_peidl)
    {
        hr = _psfstg->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &_peidl);
    }

    if (S_OK == hr)
    {
        hr = E_OUTOFMEMORY;
        LPITEMIDLIST *apidl = new LPITEMIDLIST[celt];
        if (apidl)
        {
            ULONG celtFetched;
            hr = _peidl->Next(celt, apidl, &celtFetched);
            if (SUCCEEDED(hr))
            {
                ULONG celtConverted = 0;

                ULONG i;
                for (i = 0; i < celtFetched; i++)
                {
                    if (SUCCEEDED(_PidlToSTATSTG(apidl[i], &rgelt[celtConverted])))
                    {
                        celtConverted++;
                    }
                }

                hr = (celtConverted == celt) ? S_OK : S_FALSE;
                if (pceltFetched)
                {
                    *pceltFetched = celtConverted;
                }

                for (i = 0; i < celtFetched; i++)
                {
                    ILFree(apidl[i]);
                }
            }
            delete apidl;
        }
    }
    return hr;
}

STDMETHODIMP CSFStorageEnum::Reset()
{
    HRESULT hr = S_OK;
    if (_peidl)
    {
        hr = _peidl->Reset();
    }
    return hr;
}

HRESULT CSFStorage::_ParseAndVerify(LPCWSTR pwszName, LPBC pbc, LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    LPITEMIDLIST pidl;
    HRESULT hr = ParseDisplayName(NULL, pbc, (LPWSTR) pwszName, NULL, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        // must be single-level
        if (ILFindLastID(pidl) != pidl)
        {
            hr = E_FAIL;
            ILFree(pidl);
        }
        else
        {
            *ppidl = pidl;
        }
    }
    return hr;
}

HRESULT CSFStorage::_BindByName(LPCWSTR pwszName, LPBC pbcParse, DWORD grfMode, REFIID riid, void **ppv)
{
    *ppv = NULL;

    LPITEMIDLIST pidl;
    HRESULT hr = _ParseAndVerify(pwszName, pbcParse, &pidl);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(grfMode, &pbc);
        if (SUCCEEDED(hr))
        {
            hr = BindToObject(pidl, pbc, riid, ppv);

            pbc->Release();
        }
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CSFStorage::Commit(DWORD grfCommitFlags)
{
    return S_OK;
}

STDMETHODIMP CSFStorage::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::SetClass(REFCLSID clsid)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::SetStateBits(DWORD grfStateBits, DWORD grfMask)
{
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{
    // we can at least get the name to use in STATSTG.
    ZeroMemory(pstatstg, sizeof(*pstatstg));

    LPITEMIDLIST pidl;
    HRESULT hr = SHGetIDListFromUnk(SAFECAST(this, IShellFolder2*), &pidl);
    if (SUCCEEDED(hr))
    {
        LPCITEMIDLIST pidlLast;
        IShellFolder *psf;
        hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
        if (SUCCEEDED(hr))
        {
            TCHAR szName[MAX_PATH];
            hr = DisplayNameOf(psf, pidlLast, SHGDN_FORPARSING | SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
            {
                // don't know what mode we were bound with, STGM_READ is good enough.
                pstatstg->grfMode = STGM_READ;
                if (!(grfStatFlag & STATFLAG_NONAME))
                {
                    hr = SHStrDup(szName, &pstatstg->pwcsName);
                }
            }
            psf->Release();
        }
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CSFStorage::EnumElements(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum)
{
    HRESULT hr;
    CSFStorageEnum *penum = new CSFStorageEnum(this);
    if (penum)
    {
        *ppenum = (IEnumSTATSTG *) penum;
        hr = S_OK;
    }
    else
    {
        *ppenum = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

STDMETHODIMP CSFStorage::OpenStream(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm)
{
    HRESULT hr = _BindByName(pszRel, NULL, grfMode, IID_PPV_ARG(IStream, ppstm));
    return MapWin32ErrorToSTG(hr);
}

STDMETHODIMP CSFStorage::OpenStorage(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg)
{
    HRESULT hr = _BindByName(pszRel, NULL, grfMode, IID_PPV_ARG(IStorage, ppstg));
    return MapWin32ErrorToSTG(hr);
}

STDMETHODIMP CSFStorage::DestroyElement(LPCWSTR pszRel)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _ParseAndVerify(pszRel, NULL, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = _DeleteItemByIDList(pidl);
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CSFStorage::RenameElement(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName)
{
    LPITEMIDLIST pidl;
    HRESULT hr = _ParseAndVerify(pwcsOldName, NULL, &pidl);
    if (SUCCEEDED(hr))
    {
        // ISSUE: this might put up UI
        hr = SetNameOf(NULL, pidl, pwcsNewName, SHGDN_FORPARSING, NULL);
        ILFree(pidl);
    }
    return hr;
}

STDMETHODIMP CSFStorage::SetElementTimes(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime)
{
    // could have another virtual function here for the subclass to implement,
    // but nobody ever calls this function anyway.
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::CopyTo(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest)
{
    // TODO filefldr doesnt implement this so apparently nobody needs it yet
    return E_NOTIMPL;
}

STDMETHODIMP CSFStorage::MoveElementTo(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
{
    return StgMoveElementTo(SAFECAST(this, IShellFolder *), SAFECAST(this, IStorage *), pszRel, pstgDest, pwcsNewName, grfFlags);
}

HRESULT CSFStorage::_CreateHelper(LPCWSTR pwcsName, DWORD grfMode, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = S_OK;
    LPITEMIDLIST pidlTemp;
    if (!(grfMode & STGM_CREATE) && SUCCEEDED(_ParseAndVerify(pwcsName, NULL, &pidlTemp)))
    {
        ILFree(pidlTemp);
        hr = HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS);
    }
    
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbcParse;
        hr = BindCtx_CreateWithMode(STGM_CREATE, &pbcParse);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidl;
            hr = _ParseAndVerify(pwcsName, pbcParse, &pidl);
            if (SUCCEEDED(hr))
            {
                hr = _StgCreate(pidl, grfMode, riid, ppv);
                ILFree(pidl);
            }
            pbcParse->Release();
        }
    }
    return MapWin32ErrorToSTG(hr);
}

STDMETHODIMP CSFStorage::CreateStream(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm)
{
    return _CreateHelper(pwcsName, grfMode, IID_PPV_ARG(IStream, ppstm));
}

STDMETHODIMP CSFStorage::CreateStorage(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg)
{
    return _CreateHelper(pwcsName, grfMode, IID_PPV_ARG(IStorage, ppstg));
}

// factored out of filefldr.cpp
HRESULT StgMoveElementTo(IShellFolder *psf, IStorage *pstgSrc, LPCWSTR pwcsName, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags)
{
    if ((grfFlags != STGMOVE_MOVE) && (grfFlags != STGMOVE_COPY))
        return E_INVALIDARG;

    // Get the IDList for the source stream's file
    LPITEMIDLIST pidl;
    HRESULT hr = psf->ParseDisplayName(NULL, NULL, (LPWSTR) pwcsName, NULL, &pidl, NULL);
    if (SUCCEEDED(hr))
    {
        // Bind to the source file as an IStream
        IStream *pstmSrc;
        hr = psf->BindToObject(pidl, NULL, IID_PPV_ARG(IStream, &pstmSrc));
        if (SUCCEEDED(hr))
        {
            // Create the destination stream
            IStream *pstmDst;
            hr = pstgDest->CreateStream(pwcsNewName, STGM_WRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, NULL, &pstmDst);
            if (SUCCEEDED(hr))
            {
                ULARGE_INTEGER ulMax = {-1, -1};    // whole thing
                hr = pstmSrc->CopyTo(pstmDst, ulMax, NULL, NULL);

                // If all went well this is a move (not a copy), remove the source
                if (SUCCEEDED(hr))
                {
                    hr = pstmDst->Commit(STGC_DEFAULT);
                    if (SUCCEEDED(hr) && (grfFlags == STGMOVE_MOVE))
                        hr = pstgSrc->DestroyElement(pwcsName);
                }
                pstmDst->Release();
            }
            pstmSrc->Release();
        }
        else
        {
            IStorage *pstgSrc;
            hr = psf->BindToObject(pidl, NULL, IID_PPV_ARG(IStorage, &pstgSrc));
            if (SUCCEEDED(hr))
            {
                IStorage *pstgDst;
                hr = pstgDest->CreateStorage(pwcsNewName, STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, NULL, &pstgDst);
                if (SUCCEEDED(hr))
                {
                    IEnumSTATSTG *penum;
                    if (S_OK == pstgSrc->EnumElements(0, NULL, 0, &penum))
                    {
                        STATSTG stat;
                        while (S_OK == penum->Next(1, &stat, NULL))
                        {
                            hr = pstgSrc->MoveElementTo(stat.pwcsName, pstgDst, stat.pwcsName, grfFlags);
                            if (SUCCEEDED(hr))
                                hr = pstgDst->Commit(STGC_DEFAULT);
                            CoTaskMemFree(stat.pwcsName);
                            if (FAILED(hr))
                                break;
                        }
                        penum->Release();
                    }

                    if (SUCCEEDED(hr))
                        hr = pstgDst->Commit(STGC_DEFAULT);

                    pstgDst->Release();
                }
                pstgSrc->Release();
            }
        }

        ILFree(pidl);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\sfview.h ===
#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */



#ifdef __cplusplus
}       /* End of extern "C" { */
#endif /* __cplusplus */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\sfstorage.h ===
#ifndef _SFSTORAGE_H_
#define _SFSTORAGE_H_

HRESULT StgMoveElementTo(IShellFolder *psf, IStorage *pstg, LPCWSTR pwcsName, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags);


class CSFStorage : public IShellFolder2,
                   public IStorage
{
public:
    // IUnknown
    STDMETHOD (QueryInterface)(REFIID, void **) PURE;
    STDMETHOD_(ULONG, AddRef)() PURE;
    STDMETHOD_(ULONG, Release)() PURE;

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes) PURE;
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList) PURE;
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut) PURE;
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj) PURE;
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) PURE;
    STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, void **ppvOut) PURE;
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut) PURE;
    STDMETHOD(GetUIObjectOf)(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppvOut) PURE;
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName) PURE;
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST * ppidlOut) PURE;

    // IShellFolder2
    STDMETHOD(GetDefaultSearchGUID)(GUID *pGuid) PURE;
    STDMETHOD(EnumSearches)(IEnumExtraSearch **ppenum) PURE;
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) PURE;
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState) PURE;
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) PURE;
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails) PURE;
    STDMETHOD(MapColumnToSCID)(UINT iColumn, SHCOLUMNID *pscid) PURE;

    // IStorage
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(SetClass)(REFCLSID clsid);
    STDMETHOD(SetStateBits)(DWORD grfStateBits, DWORD grfMask);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(EnumElements)(DWORD reserved1, void *reserved2, DWORD reserved3, IEnumSTATSTG **ppenum);
    STDMETHOD(OpenStream)(LPCWSTR pszRel, VOID *reserved1, DWORD grfMode, DWORD reserved2, IStream **ppstm);
    STDMETHOD(OpenStorage)(LPCWSTR pszRel, IStorage *pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage **ppstg);
    STDMETHOD(DestroyElement)(LPCWSTR pszRel);
    STDMETHOD(RenameElement)(LPCWSTR pwcsOldName, LPCWSTR pwcsNewName);
    STDMETHOD(SetElementTimes)(LPCWSTR pszRel, const FILETIME *pctime, const FILETIME *patime, const FILETIME *pmtime);
    STDMETHOD(CopyTo)(DWORD ciidExclude, const IID *rgiidExclude, SNB snbExclude, IStorage *pstgDest);
    STDMETHOD(MoveElementTo)(LPCWSTR pszRel, IStorage *pstgDest, LPCWSTR pwcsNewName, DWORD grfFlags);
    STDMETHOD(CreateStream)(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStream **ppstm);
    STDMETHOD(CreateStorage)(LPCWSTR pwcsName, DWORD grfMode, DWORD res1, DWORD res2, IStorage **ppstg);

private:
    // must be implemented by subclass
    STDMETHOD(_DeleteItemByIDList)(LPCITEMIDLIST pidl) PURE;
    STDMETHOD(_StgCreate)(LPCITEMIDLIST pidl, DWORD grfMode, REFIID riid, void **ppv) PURE;

    HRESULT _ParseAndVerify(LPCWSTR pwszName, LPBC pbc, LPITEMIDLIST *ppidl);
    HRESULT _BindByName(LPCWSTR pwszName, LPBC pbcParse, DWORD grfMode, REFIID riid, void **ppv);
    HRESULT _CreateHelper(LPCWSTR pwcsName, DWORD grfMode, REFIID riid, void **ppv);
};

#endif // _SFSTORAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shalias.h ===
#ifndef _SHALIAS_H_
#define _SHALIAS_H_

// Editing modes
#define ADD_ALIAS   0x01
#define EDIT_ALIAS  0x02

#define LocalRealloc(a, b) LocalReAlloc(a, b, LMEM_MOVEABLE)

class CAlias;

typedef struct tagALIASINFO
{
    HWND hDlg;
    int  mode;
    HDPA aliasList;
    HDPA aliasDelList;
    BOOL fInternalChange;
    BOOL fChanged;
} ALIASINFO, * LPALIASINFO;

#define ALIASLIST_COLUMNS 2  

typedef struct tagALIASITEM 
{ 
	LPSTR aCols[ALIASLIST_COLUMNS]; 
} ALIASITEM; 

typedef struct tagALIASEDITINFO
{
    HDPA aliasList;
    CAlias * alias;
    HWND   hWnd;
    DWORD  dwFlags;
} ALIASEDITINFO, *LPALIASEDITINFO;

#define ALIASINFO_FROM_HDLG( hDlg ) \
    ((LPALIASINFO)GetWindowLong(hDlg, DWL_USER)) \

TCHAR *  EatSpaces( TCHAR * str );
TCHAR *  ChopSpaces( TCHAR * str );
TCHAR *  DuplicateString( TCHAR * str );

// CAlias - object representing one alias.
class CAlias
{
public:
    LPTSTR  m_alias;
    LPTSTR  m_szurl;
    BOOL    m_fDirty;
    CAlias( LPTSTR name );
   ~CAlias();
    
    // Operations defined for Asscociation

    Load();
    Save(); 
    Delete();

#ifdef DEBUG
    Print();
#endif
};

// Some Helper Function Prototypes
BOOL     FAR PASCAL InitAliasDialog(HWND hDlg, CAlias * current, BOOL fFullInit );
CAlias * GetCurrentAlias( HWND hDlg );

#define MAX_ALIAS_LENGTH 256

STDAPI_(BOOL) LoadAliases( HDPA aliasListIn );
STDAPI_(BOOL) SaveAliases( HDPA aliasListIn );
STDAPI_(BOOL) FreeAliases( HDPA aliasListIn );

STDAPI_(LPCTSTR) GetAliasName( CAlias * ptr );
STDAPI_(LPCTSTR) GetAliasUrl( CAlias * ptr );
STDAPI_(LPVOID)  CreateAlias( LPTSTR str );
STDAPI_(VOID)    DestroyAlias( CAlias * ptr );
STDAPI_(BOOL)    SetAliasInfo( CAlias * ptr, TCHAR * alias, TCHAR * url );

#ifdef UNICODE
// TODO :
#define FindAliasIndex FindAliasIndexW
#define FindAliasByURL FindAliasByURLW
#define AddAliasToList AddAliasToListW
#define GetURLForAlias GetURLForAliasW
#else
#define FindAliasIndex FindAliasIndexA
#define FindAliasByURL FindAliasByURLA
#define AddAliasToList AddAliasToListA
#define GetURLForAlias GetURLForAliasA
#endif

STDAPI_(BOOL)  GetURLForAliasW(HDPA  aliasListIn, LPWSTR alias, LPWSTR szurl, int cchUrl );
STDAPI_(BOOL)  AddAliasToListW(HDPA  aliasListIn, LPWSTR alias, LPWSTR szurl, HWND hwnd);
STDAPI_(BOOL)  FindAliasByURLW(HDPA  aliasListIn, LPWSTR szurl, LPWSTR alias, INT cchAlias);
STDAPI_(INT)   FindAliasIndexW(HDPA  aliasListIn, LPWSTR alias);

STDAPI_(BOOL)  GetURLForAliasA(HDPA  aliasListIn, LPSTR alias, LPSTR szurl, int cchUrl );
STDAPI_(BOOL)  AddAliasToListA(HDPA  aliasListIn, LPSTR alias, LPSTR szurl, HWND hwnd);
STDAPI_(BOOL)  FindAliasByURLA(HDPA  aliasListIn, LPSTR szurl, LPSTR alias, INT cchAlias);
STDAPI_(INT)   FindAliasIndexA(HDPA  aliasListIn, LPSTR alias);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shdload.h ===
// Override the linkers default behaviour to DELAYLOAD failures.  Instead of throwing an exception
// try and return a function that simulates a failure in that API, therefore allowing the caller
// to correctly handle it.
//
// To use this functionality exactly one source must include this with COMPILE_DELAYLOAD_STUBS defined,
// and link to shlwapi.

#ifdef __cplusplus
extern "C" {            // Assume C declarations for C++
#endif // __cplusplus

#ifdef COMPILE_DELAYLOAD_STUBS

#include "delayimp.h"

// NOTE: The names __pfnDliNotifyHook / __pfnDliFailureHook must not be changed,
// NOTE: as they are referenced by the linker's DELAYLOAD handler so we can hook
// NOTE: and process failures during symbol import.  

FARPROC WINAPI ShellDelayLoadHelper(UINT unReason, PDelayLoadInfo pInfo);

PfnDliHook  __pfnDliNotifyHook = ShellDelayLoadHelper;
PfnDliHook  __pfnDliFailureHook = ShellDelayLoadHelper;

#endif

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shconv.h ===
//
//  Wrapper for <atlconv.h> that redirects it to our C-callable
//  helper functions, and also creates the appropriate definitions
//  for C callers so everybody can use the A2W/W2A macros.
//

#ifndef _SHCONV_H
#define _SHCONV_H
//
//  Force these to EXTERN_C so we can use them from C code, too.
//
STDAPI_(LPWSTR) SHA2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
STDAPI_(LPSTR)  SHW2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);
#define ATLA2WHELPER SHA2WHelper
#define ATLW2AHELPER SHW2AHelper


#ifdef __cplusplus
#ifndef offsetof
#define offsetof(s,m)   ((size_t)&(((s *)0)->m))
#endif
#ifndef ATLASSERT
#define ATLASSERT(f) ASSERT(f)
#endif
#include <atlconv.h>
#else

#define USES_CONVERSION int _convert = 0

//
//  This macro assumes that lstrlenW(UNICODE) <= lstrlenA(ANSI)
//
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
            _convert = (lstrlenA(lpa)+1),\
            ATLA2WHELPER((LPWSTR) alloca(_convert*2), (LPCSTR)lpa, _convert)))

//
//  This macro assumes that lstrlenA(ANSI) <= lstrlenW(UNICODE) * 2
//

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
            _convert = (lstrlenW(lpw)+1)*2,\
            ATLW2AHELPER((LPSTR) alloca(_convert), lpw, _convert)))

#define A2CW(lpa) ((LPCWSTR)A2W(lpa))
#define W2CA(lpw) ((LPCSTR)W2A(lpw))

#ifdef UNICODE
        #define T2A W2A
        #define A2T A2W
        __inline LPWSTR T2W(LPTSTR lp) { return lp; }
        __inline LPTSTR W2T(LPWSTR lp) { return lp; }
        #define T2CA W2CA
        #define A2CT A2CW
        __inline LPCWSTR T2CW(LPCTSTR lp) { return lp; }
        __inline LPCTSTR W2CT(LPCWSTR lp) { return lp; }
#else
        #define T2W A2W
        #define W2T W2A
        __inline LPSTR T2A(LPTSTR lp) { return lp; }
        __inline LPTSTR A2T(LPSTR lp) { return lp; }
        #define T2CW A2CW
        #define W2CT W2CA
        __inline LPCSTR T2CA(LPCTSTR lp) { return lp; }
        __inline LPCTSTR A2CT(LPCSTR lp) { return lp; }
#endif

#include <crt/malloc.h>         // Get definition for alloca()

#endif // !C++

#endif // _SHCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\inc\shdocvw.h ===
#ifndef _SHDOCVW_H_
#define _SHDOCVW_H_

//
// Define used for unicode shodcvw.  When shdocvw is fully unicode and no longer
// builds an ansi version this should be removed.

#include <iethread.h>

//
// SHDOCVW private header
//

// #include <shlobj.h> or <shellapi.h> before this to get the right
// SHDOCAPI macro definitions.
//

// value under HKLM\software\microsoft\internet explorer where we cache the platform
#define REGVAL_INTEGRATEDBROWSER    TEXT("IntegratedBrowser")

SHDOCAPI_(int) IEWinMain(LPSTR pszCmdLine, int nCmdShow);

//
// Automation support.
//
SHDOCAPI CDDEAuto_Navigate(BSTR str, HWND *phwnd, long lLaunchNewWindow);

SHDOCAPI SHGetIDispatchForFolder(LPCITEMIDLIST pidl, IWebBrowserApp **ppauto);


SHDOCAPI URLQualifyA(LPCSTR pszURL, DWORD dwFlags, LPSTR * ppszOut);
SHDOCAPI URLQualifyW(LPCWSTR pszURL, DWORD dwFlags, LPWSTR * ppszOut);

#ifdef UNICODE
#define URLQualify      URLQualifyW
#else
#define URLQualify      URLQualifyA
#endif

// Flags for URLQualify
#define UQF_GUESS_PROTOCOL          0x00000001  // Try to guess based upon given path ("www.msn.com")
#define UQF_USE_DEFAULT_PROTOCOL    0x00000002  // Resort to default protocol if guess fails
#define UQF_IGNORE_FILEPATHS        0x00000004  // Don't special case file paths
#define UQF_CANONICALIZE            0x00000008  // Canonicalize if a valid URL
#define UQF_AUTOCORRECT             0x00000010  // Try to correct typo's
#define UQF_DEFAULT                 (UQF_GUESS_PROTOCOL | UQF_USE_DEFAULT_PROTOCOL)

// Quick pass to show Splash screens for IE components
SHDOCAPI_(HWND) SHShowSplashScreen(DWORD dwMember); // Which member of family...
SHDOCAPI        SHDismissSplashScreen(HWND hwnd);

SHDOCAPI_(BOOL) GenerateHTMLForDesktop();

#define COMP_TYPE_MASK          0x0000000F  // apply to COMP_TYPE to get the type
#define COMP_UNCHECKED          0x00001000
#define COMP_CHECKED            0x00002000
#define COMP_SELECTED           0x00002000
#define COMP_NOSCROLL           0x00004000


// shared icons. 
// instead of duplicating the icons in a bunch of dll's, we have a few that are shared
#define IDI_HOMEPAGE                    100   // Index:   0

SHDOCAPI_(BOOL) IsFileUrl(LPCSTR psz);
SHDOCAPI_(BOOL) IsFileUrlW(LPCWSTR pcwzUrl);
SHDOCAPI_(BOOL) PathIsFilePath(LPCWSTR lpszPath);

SHDOCAPI_(BOOL) IsErrorUrl(LPCWSTR pwszDisplayName);


// For dwSubstitutions parameter in URLSubstitution() and RegURLSubstitution().
//#define URLSUB_CLSID      0x00000001  // UNUSED (buzzr)
#define URLSUB_PRD          0x00000002  // Product IE (Example: "ie")
#define URLSUB_PVER         0x00000004  // Product Version (Example: "4.0")
#define URLSUB_OS           0x00000008  // System OS, same as header
#define URLSUB_RFC1766      0x00000010  // Human readable LCID (Example: "en-us")
#define URLSUB_OVER         0x00000020  // System OS Version (Example: 3.1, 3.5.1, 4.0).  Do not use year numbers.
#define URLSUB_OLCID        0x00000040  // The hexadecimal Locale ID (LCID) or Language ID (LID) of the operating system.
#define URLSUB_CLCID        0x00000080  // The hexadecimal Locale ID (LCID) or Language ID (LID) of the current users Regional Setting (as in Control Panel).
#define URLSUB_ALL          0xFFFFFFFF

SHDOCAPI  URLSubLoadString(HINSTANCE hInst, UINT idRes, LPWSTR pszUrlOut, 
                                DWORD cchSizeOut, DWORD dwSubstitutions);

SHDOCAPI_(void) SHInitRoot(IETHREADPARAM* piei);

SHDOCAPI URLSubstitution(LPCWSTR pszUrlIn, LPWSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);

SHDOCAPI_(IStream *) OpenPidlOrderStream(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidl, LPCSTR pszKey, DWORD grfMode);
SHDOCAPI DragDrop(HWND hwnd, IShellFolder * psfParent, LPCITEMIDLIST pidl, DWORD dwPrefEffect, DWORD *pdwEffect) ;
SHDOCAPI_(int) IEMapPIDLToSystemImageListIndex(IShellFolder *psfParent, LPCITEMIDLIST pidlChild, int *piSelectedImage);
SHDOCAPI_(void) IEInvalidateImageList(void);
SHDOCAPI_(BOOL) ILIsWeb(LPCITEMIDLIST pidl);
SHDOCAPI_(BOOL) IsURLChild(LPCITEMIDLIST pidl, BOOL fIncludeHome);
SHDOCAPI IEParseDisplayNameWithBCW(UINT uiCP, LPCWSTR pwszPath, IBindCtx * pbc, LPITEMIDLIST * ppidlOut);
SHDOCAPI IEParseDisplayName(UINT uiCP, LPCTSTR pszPath, LPITEMIDLIST * ppidlOut);
SHDOCAPI IEBindToObjectEx(LPCITEMIDLIST pidl, IBindCtx *pbc, REFIID riid, void **ppv);
SHDOCAPI IEBindToObject(LPCITEMIDLIST pidl, IShellFolder **ppsfOut);
SHDOCAPI IEGetAttributesOf(LPCITEMIDLIST pidl, DWORD* pdwAttribs);
SHDOCAPI IEGetDisplayName(LPCITEMIDLIST pidl, LPWSTR pszName, UINT uFlags);
SHDOCAPI IEGetNameAndFlags(LPCITEMIDLIST pidl, UINT uFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs);

//  flags for IEGetNameAndFlagsEx() dwIEFlags
#define     IEGDN_NOFRAGMENT    0x0001
SHDOCAPI IEGetNameAndFlagsEx(LPCITEMIDLIST pidl, UINT uSHFlags, DWORD dwIEFlags, LPWSTR pszName, DWORD cchName, DWORD *prgfInOutAttrs);
SHDOCAPI_(BOOL) IEILIsEqual(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fIgnoreHidden);
SHDOCAPI IECreateFromPathCPWithBCA(UINT uiCP, LPCSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut);
SHDOCAPI IECreateFromPathCPWithBCW(UINT uiCP, LPCWSTR pszPath, IBindCtx * pbc, LPITEMIDLIST *ppidlOut);

#define IEParseDisplayNameW(uiCP, pwszPath, ppidlOut)       IEParseDisplayNameWithBCW(uiCP, pwszPath, NULL, ppidlOut)
#define IECreateFromPathA(pszPath, ppidlOut) IECreateFromPathCPWithBCA(CP_ACP, pszPath, NULL, ppidlOut)
#define IECreateFromPathW(pszPath, ppidlOut) IECreateFromPathCPWithBCW(CP_ACP, pszPath, NULL, ppidlOut)

#ifdef UNICODE
#define IECreateFromPathCPWithBC            IECreateFromPathCPWithBCW
#define IECreateFromPath(pszPath, ppidlOut) IECreateFromPathCPWithBC(CP_ACP, pszPath, NULL, ppidlOut)
#else // UNICODE 
#define IECreateFromPathCPWithBC            IECreateFromPathCPWithBCA
#define IECreateFromPath(pszPath, ppidlOut) IECreateFromPathCPWithBC(CP_ACP, pszPath, NULL, ppidlOut)
#endif // UNICODE



SHDOCAPI CreateShortcutInDirA(IN LPCITEMIDLIST pidlTarget, IN LPSTR pszTitle, IN LPCSTR pszDir, 
                    OUT LPSTR pszOut, IN BOOL bUpdateProperties);
SHDOCAPI CreateShortcutInDirW(IN LPCITEMIDLIST pidlTarget, IN LPWSTR pwzTitle, IN LPCWSTR pwzDir, 
                    OUT LPWSTR pwzOut, IN BOOL bUpdateProperties);

#ifndef UNICODE
#define CreateShortcutInDir         CreateShortcutInDirA
#else
#define CreateShortcutInDir         CreateShortcutInDirW
#endif

SHDOCAPI_(void) IECleanUpAutomationObject();
SHDOCAPI_(void) IEOnFirstBrowserCreation(IUnknown* punkAuto);
SHDOCAPI_(BOOL) IEDDE_WindowDestroyed(HWND hwnd);
SHDOCAPI_(BOOL) IEDDE_NewWindow(HWND hwnd);

SHDOCAPI _GetStdLocation(LPWSTR pszPath, DWORD cchPathSize, UINT id);

SHDOCAPI SHCreateStreamWrapperCP(IStream *aStreams[], UINT cStreams, DWORD grfMode, UINT uiCodePage, IStream **ppstm);

#define DVIDM_GOHOME         (FCIDM_SHVIEWFIRST + 0x10E)

/// Browser command ids
//---------------------------------------------------------------------------


/// pre-merged browser menu command ids
///--------------------------------------------------------------------------
#define DVIDM_FIRST          (FCIDM_SHVIEWFIRST + 0x100)
#define DVIDM_OPEN           (FCIDM_SHVIEWFIRST + 0x100)
#define DVIDM_SAVE           (FCIDM_SHVIEWFIRST + 0x101)
#define DVIDM_SAVEASFILE     (FCIDM_SHVIEWFIRST + 0x102)
#define DVIDM_PAGESETUP      (FCIDM_SHVIEWFIRST + 0x103)
#define DVIDM_PRINT          (FCIDM_SHVIEWFIRST + 0x104)
#define DVIDM_PROPERTIES     (FCIDM_SHVIEWFIRST + 0x106)
#define DVIDM_CUT            (FCIDM_SHVIEWFIRST + 0x107)
#define DVIDM_COPY           (FCIDM_SHVIEWFIRST + 0x108)
#define DVIDM_PASTE          (FCIDM_SHVIEWFIRST + 0x109)
#define DVIDM_REFRESH        (FCIDM_SHVIEWFIRST + 0x10A)
#define DVIDM_STOPDOWNLOAD   (FCIDM_SHVIEWFIRST + 0x10B)
#define DVIDM_ZOOMIN         (FCIDM_SHVIEWFIRST + 0x10C)
#define DVIDM_ZOOMOUT        (FCIDM_SHVIEWFIRST + 0x10D)
#define DVIDM_GOSEARCH       (FCIDM_SHVIEWFIRST + 0x10F)
#define DVIDM_GOFIRSTHOME    (FCIDM_SHVIEWFIRST + 0x110)
#define DVIDM_GOFIRSTHOMERO  (FCIDM_SHVIEWFIRST + 0x111)
#define DVIDM_GOLOCALPAGE    (FCIDM_SHVIEWFIRST + 0x112)
#define DVIDM_NEWWINDOW      (FCIDM_SHVIEWFIRST + 0x113)
#define DVIDM_DHFAVORITES    (FCIDM_SHVIEWFIRST + 0x114)
#define DVIDM_PRINTPREVIEW   (FCIDM_SHVIEWFIRST + 0x115)
#define DVIDM_PRINTFRAME     (FCIDM_SHVIEWFIRST + 0x116)
#define DVIDM_NEWMESSAGE     (FCIDM_SHVIEWFIRST + 0x117)
#define DVIDM_SEARCHBAR      (FCIDM_SHVIEWFIRST + 0x118)
#define DVIDM_SEND           (FCIDM_SHVIEWFIRST + 0x119)
#define DVIDM_SENDPAGE       (FCIDM_SHVIEWFIRST + 0x11A)
#define DVIDM_SENDSHORTCUT   (FCIDM_SHVIEWFIRST + 0x11B)
#define DVIDM_DESKTOPSHORTCUT (FCIDM_SHVIEWFIRST + 0x11C)
#define DVIDM_SENDTO         (FCIDM_SHVIEWFIRST + 0x140)
#define DVIDM_SENDTOFIRST    (FCIDM_SHVIEWFIRST + 0x141)
#define DVIDM_SENDTOLAST     (FCIDM_SHVIEWFIRST + 0x14f)
#define DVIDM_HELPABOUT      (FCIDM_SHVIEWFIRST + 0x150)
#define DVIDM_HELPSEARCH     (FCIDM_SHVIEWFIRST + 0x151)
#define DVIDM_HELPTUTORIAL   (FCIDM_SHVIEWFIRST + 0x152)
#define DVIDM_HELPREPAIR     (FCIDM_SHVIEWFIRST + 0x153)
#define DVIDM_HELPMSWEB      (FCIDM_SHVIEWFIRST + 0x154)
#define DVIDM_HELPMSWEBLAST  (FCIDM_SHVIEWFIRST + 0x16f)

#define DVIDM_SHOWTOOLS      (FCIDM_SHVIEWFIRST + 0x170)
#define DVIDM_MAILNEWS       (FCIDM_SHVIEWFIRST + 0x171)
#define DVIDM_FONTS          (FCIDM_SHVIEWFIRST + 0x172)
#define DVIDM_EDITPAGE       (FCIDM_SHVIEWFIRST + 0x173)
#define DVIDM_DISCUSSIONS    (FCIDM_SHVIEWFIRST + 0x174)
#define DVIDM_ENCODING       (FCIDM_SHVIEWFIRST + 0x175)
#define DVIDM_IMPORTEXPORT   (FCIDM_SHVIEWFIRST + 0x176)
#define DVIDM_HELPIESEC      (FCIDM_SHVIEWFIRST + 0X177)
#define DVIDM_TRUSTEDSITES   (FCIDM_SHVIEWFIRST + 0x178)
#define DVIDM_INTRANETSITES  (FCIDM_SHVIEWFIRST + 0x179)
#define DVIDM_ADDSITE        (FCIDM_SHVIEWFIRST + 0x17a)

#define DVIDM_SUITE_APP_FIRST  (FCIDM_SHVIEWFIRST + 0x180)
#define DVIDM_NEW            (DVIDM_SUITE_APP_FIRST + 0x002)
#define DVIDM_NEWPOST        (DVIDM_SUITE_APP_FIRST + 0x003)
#define DVIDM_NEWAPPOINTMENT (DVIDM_SUITE_APP_FIRST + 0x004)
#define DVIDM_NEWMEETING     (DVIDM_SUITE_APP_FIRST + 0x005)
#define DVIDM_NEWCONTACT     (DVIDM_SUITE_APP_FIRST + 0x006)
#define DVIDM_NEWTASK        (DVIDM_SUITE_APP_FIRST + 0x007)
#define DVIDM_NEWTASKREQUEST (DVIDM_SUITE_APP_FIRST + 0x008)
#define DVIDM_NEWJOURNAL     (DVIDM_SUITE_APP_FIRST + 0x009)
#define DVIDM_NEWNOTE        (DVIDM_SUITE_APP_FIRST + 0x00a)
#define DVIDM_CALL           (DVIDM_SUITE_APP_FIRST + 0x00b)
#define DVIDM_SUITE_APP_LAST (DVIDM_SUITE_APP_FIRST + 0x020)

#define DVIDM_NONSUITE_APP_FIRST (FCIDM_SHVIEWFIRST + 0x1B0)
#define DVIDM_NONSUITE_APP_LAST (DVIDM_NONSUITE_APP_FIRST + 0x20)

// large block must be reserved for pre-merged menu
#define DVIDM_MSHTML_FIRST   (FCIDM_SHVIEWFIRST + 0x0400)
#define DVIDM_MSHTML_LAST    (FCIDM_SHVIEWFIRST + 0x1fff)

// Reserve a Block for Tools Menu Extensions
#define DVIDM_MENUEXT_FIRST     (DVIDM_MSHTML_LAST + 1)
#define DVIDM_MENUEXT_LAST      (DVIDM_MENUEXT_FIRST + 0x200)

#define IDS_HELP_FIRST          0x4000
#define IDS_HELP_OF(id)         ((id - DVIDM_FIRST)+IDS_HELP_FIRST)
#define IDS_HELP_OPEN           IDS_HELP_OF(DVIDM_OPEN           )
#define IDS_HELP_SAVE           IDS_HELP_OF(DVIDM_SAVE           )
#define IDS_HELP_SAVEASFILE     IDS_HELP_OF(DVIDM_SAVEASFILE     )
#define IDS_HELP_PAGESETUP      IDS_HELP_OF(DVIDM_PAGESETUP      )
#define IDS_HELP_PRINT          IDS_HELP_OF(DVIDM_PRINT          )
#define IDS_HELP_PROPERTIES     IDS_HELP_OF(DVIDM_PROPERTIES     )
#define IDS_HELP_CUT            IDS_HELP_OF(DVIDM_CUT            )
#define IDS_HELP_COPY           IDS_HELP_OF(DVIDM_COPY           )
#define IDS_HELP_PASTE          IDS_HELP_OF(DVIDM_PASTE          )
#define IDS_HELP_STOPDOWNLOAD   IDS_HELP_OF(DVIDM_STOPDOWNLOAD   )
#define IDS_HELP_REFRESH        IDS_HELP_OF(DVIDM_REFRESH        )
#define IDS_HELP_GOHOME         IDS_HELP_OF(DVIDM_GOHOME         )
#define IDS_HELP_GOSEARCH       IDS_HELP_OF(DVIDM_GOSEARCH       )
#define IDS_HELP_NEWWINDOW      IDS_HELP_OF(DVIDM_NEWWINDOW      )
#define IDS_HELP_PRINTPREVIEW   IDS_HELP_OF(DVIDM_PRINTPREVIEW   )
#define IDS_HELP_PRINTFRAME     IDS_HELP_OF(DVIDM_PRINTFRAME     )
#define IDS_HELP_NEWMESSAGE     IDS_HELP_OF(DVIDM_NEWMESSAGE     )
#define IDS_HELP_DHFAVORITES    IDS_HELP_OF(DVIDM_DHFAVORITES    )
#define IDS_HELP_HELPABOUT      IDS_HELP_OF(DVIDM_HELPABOUT      )
#define IDS_HELP_HELPSEARCH     IDS_HELP_OF(D