  apNodeInfo[iNi]->ulNsPrefixLen);
					if (FAILED (sc))
						goto ret;
				}

				//	Watch for UNHANDLED nodes.  Any node that ends up not being handled
				//	pushes us into a state where all we do is continue processing the
				//	XML stream until our unhandled count (which is really a depth) goesbd
				//	back to zero.  A subclass tells us something was unhandled by passing
				//	back S_FALSE;
				//
				if (S_FALSE == sc)
				{
					//	Any type that results in an EndChildren() call
					//	needs to add to the unhandled depth.
					//
					//$	WORKAROUND: There is a bug in the XML parser where it is
					//	giving us a non-terminal PCDATA!  Work around that here!
					//
					if (!apNodeInfo[iNi]->fTerminal && (XML_PCDATA != apNodeInfo[iNi]->dwType))
					{
						//	We should only get non-terminal node info structures
						//	as the first in the list or as attributes!
						//
						Assert ((0 == iNi) || (XML_ATTRIBUTE == apNodeInfo[iNi]->dwType));
						PushUnhandled ();
					}
				}

				//  For most attributes we expect the attribute to be followed by
				//  XML_PCDATA element, but we want to allow the empty namespace
				//  definition xmlns:a="".  This has no data element, so we need
				//  to adjust the state for this case.
				//
				if ((ST_INDOC == m_state) && (XML_NS == apNodeInfo[iNi]->dwSubType))
				{
					//  If we have sub type XML_NS, we know that it has to be of type
					//  XML_ATTTRIBUTE.
					//
					Assert (XML_ATTRIBUTE == apNodeInfo[iNi]->dwType);

					//  If there are no more records or if the next element is not of
					//  type XML_PCDATA, we know we hit an empty namespace declaration.
					//
					if ((iNi == cNumRecs - 1) ||
						(XML_PCDATA != apNodeInfo[iNi + 1]->dwType))
					{
						m_state = ST_INATTRDATA;
					}
				}

				//	If we just processed an attribute, then we had better transition
				//	into the right state for processing its value.
				//
				switch (m_state)
				{
					case ST_INDOC:

						if (XML_ATTRIBUTE == apNodeInfo[iNi]->dwType)
						{
							//$	REVIEW: if this is the last node, that means that the
							//	attribute value is empty.  Don't transition...
							//
							if (iNi < (cNumRecs - 1))
							{
								//	Remember that we have started processing an attribute.
								//	We need to do this so that we can call the subclass to
								//	tell them that the attribute is completed.
								//
								m_state = ST_INATTR;
							}
							//
							//$	REVIEW: end.
						}
						break;

					case ST_INATTR:

						//	We better not get anything other than PCDATA when dealing
						//	with attributes, otherwise it is an error.
						//
						if (XML_PCDATA == apNodeInfo[iNi]->dwType)
						{
							//	We also need to close the attribute off if this is
							//	the last node in the list, so we should fall through
							//	below to handle the termination case.
							//
							m_state = ST_INATTRDATA;
						}
						else
						{
							//	We better not get anything other than PCDATA
							//	when dealing with attributes, otherwise it
							//	is an error.
							//
							XmlTrace ("Xml: got something other than PC_DATA\n");
							sc = E_DAV_XML_PARSE_ERROR;
							goto ret;
						}

						/* !!! FALL THROUGH !!! */

					case ST_INATTRDATA:

						//	The next node is anything but PC_DATA or this is the
						//	last node in the list, then we need to close the current
						//	attribute.
						//
						if ((iNi == cNumRecs - 1) ||
							(XML_PCDATA != apNodeInfo[iNi + 1]->dwType))
						{
							m_state = ST_INDOC;

							//	Now that all the bits that define the node are handled
							//	by the subclass, we can pass on the end of the attributes.
							//
							//	If the subclass is handling the current context, pass
							//	the call along
							//
							if (0 == m_cUnhandled)
							{
								sc = ScCompleteAttribute ();
								if (FAILED (sc))
									goto ret;
							}
							else
							{
								//	Don't call the subclass but certainly pop the
								//	unhandled state
								//
								PopUnhandled();
							}
						}
						break;
				}
				break;
			}
		}
	}

	//	Complete the CreateNode() call
	//
	Assert (0 != cNumRecs);
	sc = ScCompleteCreateNode (apNodeInfo[0]->dwType);
	if (FAILED (sc))
		goto ret;

	//	Assert that in a completely successful call, we are still
	//	in the ST_INDOC state.
	//
	Assert (ST_INDOC == m_state);

	//	Make sure that any scoping that needed to happen, happens
	//
	Assert ((NULL == pxmlnss.get()) || (0 != cNumRecs));
	apNodeInfo[0]->pNode = pxmlnss.relinquish();

ret:
	return sc;
}

//	ScNewXMLParser() ----------------------------------------------------------
//
SCODE
ScNewXMLParser (CNodeFactory * pnf, IStream * pstm, IXMLParser ** ppxprsRet)
{
	auto_ref_ptr<IXMLParser> pxprsNew;
	SCODE sc = S_OK;

	//$	IMPORTANT: we are trusting that IIS has initialized co
	//	for us.  We have been told by the powers that be that
	//	we shall not init co.
	//
	//	Grab an instance of the XML parser
	//
	sc = CoCreateInstance (CLSID_XMLParser,
						   NULL,
						   CLSCTX_INPROC_SERVER,
						   IID_IXMLParser,
						   reinterpret_cast<LPVOID*>(pxprsNew.load()));
	//
	//$	IMPORTANT: end

	if (FAILED (sc))
		goto ret;

	//	Set the input to the parser
	//
	sc = pxprsNew->SetInput (pstm);
	if (FAILED (sc))
		goto ret;

	//	Initialize the node factory
	//
	sc = pnf->ScInit();
	if (FAILED (sc))
		goto ret;

	//	Push our node factory
	//
	sc = pxprsNew->SetFactory (pnf);
	if (FAILED (sc))
		goto ret;

	//	Set some flags that are fairly useful
	//
	sc = pxprsNew->SetFlags (XMLFLAG_SHORTENDTAGS | XMLFLAG_NOWHITESPACE);
	if (FAILED (sc))
		goto ret;

	//	Pass back the instantiated parser
	//
	*ppxprsRet = pxprsNew.relinquish();

ret:
	return sc;
}

//	ScParseXML() --------------------------------------------------------------
//
SCODE
ScParseXML (IXMLParser* pxprs, CNodeFactory * pnf)
{
	//	Note Run() can return E_PENDING when I/O is pending
	//	on the stream which we are parsing.
	//
	SCODE sc = pxprs->Run (-1);

	if (FAILED (sc) && pnf->FParserError(sc))
		sc = E_DAV_XML_PARSE_ERROR;

	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\xemit2.cpp ===
/*
 *	X E M I T 2 . C P P
 *
 *	XML emitter processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"

DEC_CONST CHAR gc_szXmlVersion[] = "<?xml version=\"1.0\"?>";
DEC_CONST UINT gc_cchXmlVersion = CElems(gc_szXmlVersion) - 1 ;


//	class CXMLEmitter ---------------------------------------------------------
//
SCODE
CXMLEmitter::ScAddNmspc (
	/* [in] */ const auto_ref_ptr<CNmspc>& pns,
	/* [in] */ CXNode* pxnRoot)
{
	Assert (pxnRoot);

	auto_ref_ptr<CXNode> pxn;
	CStackBuffer<WCHAR> pwsz;
	SCODE sc = S_OK;
	UINT cch;

	//	Allocate enough space for the prefix, colon and alias
	//
	cch = CchConstString(gc_wszXmlns) + 1 + pns->CchAlias();
	if (NULL == pwsz.resize(CbSizeWsz(cch)))
	{
		sc = E_OUTOFMEMORY;
		goto ret;
	}
	wcsncpy (pwsz.get(), gc_wszXmlns, CchConstString(gc_wszXmlns));
	if (pns->CchAlias())
	{
		pwsz[CchConstString(gc_wszXmlns)] = L':';
		wcsncpy(pwsz.get() + CchConstString(gc_wszXmlns) + 1,
				pns->PszAlias(),
				pns->CchAlias());
		pwsz[cch] = 0;
	}
	else
		pwsz[CchConstString(gc_wszXmlns)] = 0;

	//	Create the namespace attribute
	//
	sc = pxnRoot->ScGetChildNode (CXNode::XN_NAMESPACE, pxn.load());
	if (FAILED(sc))
		goto ret;

	Assert (pxn.get());
	sc = ScAddAttribute (pxn.get(),
						 pwsz.get(),
						 cch,
						 pns->PszHref(),
						 pns->CchHref());
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CXMLEmitter::ScAddAttribute (
	/* [in] */ CXNode * pxn,
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ UINT cchTag,
	/* [in] */ LPCWSTR pwszValue,
	/* [in] */ UINT cchValue)
{
	SCODE	sc = S_OK;

	//	Format:
	//
	//	" " [<alias> ":"] <tag> "=\"" <value> "\""
	//
	sc = m_pxb->ScAddTextBytes (1, " ");
	if (FAILED(sc))
		goto ret;

	sc = pxn->ScSetTag (this, cchTag, pwszTag);
	if (FAILED (sc))
		goto ret;

	sc = m_pxb->ScAddTextBytes (2, "=\"");
	if (FAILED(sc))
		goto ret;

	sc = pxn->ScSetValue (pwszValue, cchValue);
	if (FAILED (sc))
		goto ret;

	sc = m_pxb->ScAddTextBytes (1, "\"");
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

BOOL
CXMLEmitter::NmspcEmittingOp::operator() (const CRCWszN&, const auto_ref_ptr<CNmspc>& nmspc )
{
	return SUCCEEDED (m_emitter->ScAddNmspc (nmspc, m_pxnParent.get()));
}

SCODE
CXMLEmitter::ScNewNode (
	/* [in] */ XNT xnt,
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ CXNode * pxnParent,
	/* [in] */ auto_ref_ptr<CXNode>& pxnOut)
{
	auto_ref_ptr<CXNode> pxn;
	SCODE sc = S_OK;

	//	Create the node
	//
	sc = pxnParent->ScGetChildNode (xnt, pxn.load());
	if (FAILED(sc))
		goto ret;

	//	Set the tag name
	//
	switch (xnt)
	{
		case CXNode::XN_ELEMENT:
		case CXNode::XN_ATTRIBUTE:

			sc = pxn->ScSetTag (this, static_cast<UINT>(wcslen(pwszTag)), pwszTag);
			if (FAILED (sc))
				goto ret;

		case CXNode::XN_NAMESPACE:

			break;
	}

	//	Pass back a reference
	//
	Assert (S_OK == sc);
	pxnOut = pxn.get();

ret:
	return sc;
}

SCODE
CXMLEmitter::ScSetRoot (LPCWSTR pwszTag)
{
	SCODE	sc = S_OK;

	if (!m_pxnRoot.get())
	{
		//	Create the <?xml version="1.0"?> node and insert it
		//	into the document.
		//
		sc = m_pxb->ScAddTextBytes (gc_cchXmlVersion, gc_szXmlVersion);
		if (FAILED(sc))
			goto ret;

		sc = ScNewRootNode (pwszTag);
		if (FAILED(sc))
			goto ret;
	}

ret:
	return sc;
}

SCODE
CXMLEmitter::ScNewRootNode (LPCWSTR pwszTag)
{
	SCODE sc = S_OK;

	if (m_pxnRoot.get() == NULL)
	{
		//	Initialize the emitter's namespace cache
		//
		sc = ScInit();
		if (FAILED (sc))
			goto ret;

		//	Take this chance to initialize the local cache
		//
		if (!m_cacheLocal.FInit())
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		if (m_pNmspcLoader)
		{
			//	Load all the document level namespaces
			//
			sc = m_pNmspcLoader->ScLoadNamespaces(this);
		}
		else
		{
			//	Load the default namespace
			//
			sc = ScPreloadNamespace (gc_wszDav);
		}
		if (FAILED(sc))
			goto ret;

		//	Create the node
		//
		m_pxnRoot.take_ownership (new CXNode (CXNode::XN_ELEMENT, m_pxb.get()));
		if (!m_pxnRoot.get())
		{
			sc = E_OUTOFMEMORY;
			goto ret;
		}

		//	Set the tag name
		//
		sc = m_pxnRoot->ScSetTag (this, static_cast<UINT>(wcslen(pwszTag)), pwszTag);
		if (FAILED (sc))
			goto ret;

		//	Namespace must have been populated before root node is created
		//
		Assert (S_OK == sc);

		//	It's time to add all the namespaces
		//
		{
			NmspcEmittingOp op (this, m_pxnRoot.get());
			m_cache.ForEach(op);
		}
	}

ret:
	return sc;
}

SCODE
CXMLEmitter::ScFindNmspc (LPCWSTR pwsz, UINT cch, auto_ref_ptr<CNmspc>& pns)
{
	Assert (pwsz);

	SCODE sc = S_OK;

	//	Emitter has two namespace cache, one is the docoument level cache
	//	for namespaces that span the whole XML body, and the other one is
	//	for namesapces that scopes on the current record only.
	//
	//	Look into the record level cache first
	//
	if (m_cacheLocal.CItems())
	{
		CRCWszN key(pwsz, cch);
		auto_ref_ptr<CNmspc>* parp;
		parp = m_cacheLocal.Lookup (key);
		if (NULL != parp)
		{
			pns = *parp;
			return S_OK;
		}
	}

	//	Try and find the namespace in the document's cache
	//
	sc = ScNmspcFromHref (pwsz, cch, pns);

	return sc;
}

SCODE
CXMLEmitter::ScPreloadNamespace (LPCWSTR pwszTag)
{
	LPCWSTR pwsz;
	SCODE sc = S_OK;
	UINT cch;

	Assert (pwszTag);

	//	This must be done before root node is created
	//
	Assert (!m_pxnRoot.get());

	//	And should no local namespace yet
	//
	Assert (m_cacheLocal.CItems() == 0);

	//	Find the namespace separator
	//
	cch = CchNmspcFromTag (static_cast<UINT>(wcslen(pwszTag)), pwszTag, &pwsz);
	if (cch != 0)
	{
		//	Add to namespace cache
		//
		auto_ref_ptr<CNmspc> pns;
		sc = ScNmspcFromHref (pwszTag, cch, pns);
		if (FAILED (sc))
			goto ret;
	}

ret:
	return sc;
}

//
//	CXMLEmitter::ScPreloadNamespace
//		Preload namespaces
SCODE
CXMLEmitter::ScPreloadLocalNamespace (CXNode * pxn, LPCWSTR pwszTag)
{
	LPCWSTR pwsz;
	SCODE sc = S_OK;
	UINT cch;

	Assert (pwszTag);

	//	This must be done after root node is created
	//
	Assert (m_pxnRoot.get());

	//	Find the namespace separator
	//
	cch = CchNmspcFromTag (static_cast<UINT>(wcslen(pwszTag)), pwszTag, &pwsz);
	if (cch != 0)
	{
		auto_ref_ptr<CNmspc> pns;

		//	Add to namespace cache
		//
		sc = ScFindNmspc (pwszTag, cch, pns);
		if (FAILED (sc))
			goto ret;

		if (S_FALSE == sc)
		{
			//	It wasn't there, so if the root of the document has
			//	already been committed, then remove the name from the
			//	document cache and add it to the chunk cache.
			//
			CRCWszN key = IndexKey(pns);

			//	First, remove from the parent
			//
			Assert (NULL == m_cacheLocal.Lookup (key));
			m_cache.Remove (key);

			//	Looks like this is a new namespace to this
			//	chunk and needs to be cached.
			//
			if (!m_cacheLocal.FAdd (key, pns))
			{
				sc = E_OUTOFMEMORY;
				goto ret;
			}

			//	Emit this namespace
			//
			sc = ScAddNmspc (pns, pxn);
			if (FAILED(sc))
				goto ret;

			//	Regardless of whether or not this namespace was
			//	new to this chunk, we do not want it added to the
			//	document.  So we cannot return S_FALSE.
			//
			sc = S_OK;
		}
	}

ret:
	return sc;
}

//	CEmitterNode --------------------------------------------------------------
//
SCODE
CEmitterNode::ScConstructNode (
	/* [in] */ CXMLEmitter& emitter,
	/* [in] */ CXNode* pxnParent,
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ LPCWSTR pwszValue,
	/* [in] */ LPCWSTR pwszType)
{
	SCODE sc = S_OK;

	//	Create the new node...
	//
	Assert (pxnParent);
	Assert (m_emitter.get() == NULL);
	sc = emitter.ScNewNode (CXNode::XN_ELEMENT, pwszTag, pxnParent, m_pxn);
	if (FAILED (sc))
		goto ret;

	XmlTrace ("XML: constructing node:\n-- tag: %ws\n", pwszTag);

	//	Set the value type if it existed
	//
	if (pwszType)
	{
		//	Create the namespace attribute
		//
		auto_ref_ptr<CXNode> pxnType;
		sc = m_pxn->ScGetChildNode (CXNode::XN_ATTRIBUTE, pxnType.load());
		if (FAILED(sc))
			goto ret;

		Assert (pxnType.get());
		XmlTrace ("-- type: %ws\n", pwszType);
		sc = emitter.ScAddAttribute (pxnType.get(),
									 gc_wszLexType,
									 gc_cchLexType,
									 pwszType,
									 static_cast<UINT>(wcslen(pwszType)));
		if (FAILED (sc))
			goto ret;

	}

	//	Set the value
	//		Value must be emitted after type
	//
	if (pwszValue)
	{
		XmlTrace ("-- value: %ws\n", pwszValue);
		sc = m_pxn->ScSetValue (pwszValue);
		if (FAILED (sc))
			goto ret;
	}

	//	Stuff the emitter into the node
	//
	m_emitter = &emitter;

ret:
	return sc;
}

SCODE
CEmitterNode::ScAddNode (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ CEmitterNode& en,
	/* [in] */ LPCWSTR pwszValue,
	/* [in] */ LPCWSTR pwszType)
{
	SCODE sc = S_OK;

	//	Construct the node
	//
	Assert (m_emitter.get());
	sc = en.ScConstructNode (*m_emitter,
							 m_pxn.get(),
							 pwszTag,
							 pwszValue,
							 pwszType);
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}

SCODE
CEmitterNode::ScAddMultiByteNode (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ CEmitterNode& en,
	/* [in] */ LPCSTR pszValue,
	/* [in] */ LPCWSTR pwszType)
{
	SCODE sc = ScAddNode (pwszTag, en, NULL, pwszType);
	if (FAILED (sc))
		goto ret;

	Assert (pszValue);
	sc = en.Pxn()->ScSetValue (pszValue, static_cast<UINT>(strlen(pszValue)));
	if (FAILED (sc))
		goto ret;

ret:
	return sc;
}

SCODE
CEmitterNode::ScAddUTF8Node (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ CEmitterNode& en,
	/* [in] */ LPCSTR pszValue,
	/* [in] */ LPCWSTR pwszType)
{
	SCODE sc = ScAddNode (pwszTag, en, NULL, pwszType);
	if (FAILED (sc))
		goto ret;

	Assert (pszValue);
	sc = en.Pxn()->ScSetUTF8Value (pszValue, static_cast<UINT>(strlen(pszValue)));
	if (FAILED(sc))
		goto ret;

ret:
	return sc;
}

SCODE
CEmitterNode::ScAddDateNode (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ FILETIME* pft,
	/* [in] */ CEmitterNode& en)
{
	SYSTEMTIME st;
	WCHAR rgwch[128];

	Assert (pft);
	if (!FileTimeToSystemTime (pft, &st))
	{
		//	In case the filetime is invalid, default to zero
		//
		FILETIME ftDefault = {0};
		FileTimeToSystemTime (&ftDefault, &st);
	}
	if (FGetDateIso8601FromSystime (&st, rgwch, CElems(rgwch)))
	{
		return ScAddNode (pwszTag,
						  en,
						  rgwch,
						  gc_wszDavType_Date_ISO8601);
	}

	return W_DAV_XML_NODE_NOT_CONSTRUCTED;
}

SCODE
CEmitterNode::ScAddInt64Node (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ LARGE_INTEGER * pli,
	/* [in] */ CEmitterNode& en)
{
	WCHAR rgwch[36];

	Assert (pli);
	_ui64tow (pli->QuadPart, rgwch, 10);
	return ScAddNode (pwszTag, en, rgwch,gc_wszDavType_Int);
}

SCODE
CEmitterNode::ScAddBoolNode (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ BOOL f,
	/* [in] */ CEmitterNode& en)
{
	return ScAddNode (pwszTag,
					  en,
					  (f ? gc_wsz1 : gc_wsz0),
					  gc_wszDavType_Boolean);
}

SCODE
CEmitterNode::ScAddBase64Node (
	/* [in] */ LPCWSTR pwszTag,
	/* [in] */ ULONG cb,
	/* [in] */ LPVOID pv,
	/* [in] */ CEmitterNode& en,
	/* [in] */ BOOL fSupressType,
	/* [in] */ BOOL fUseBinHexIfNoValue)
{
	auto_heap_ptr<WCHAR> pwszBuf;
	Assert (pwszTag);
	Assert (pv);

	//	If they didn't request type supression, then label this node
	//	with the correct type -- bin.base64
	//
	LPCWSTR pwszType;

	if (fSupressType)
	{
		pwszType = NULL;
	}
	else
	{
		//	If fUseBinHexIfNoValue is TRUE AND cb = 0, then use "bin.hex"
		//	as the type rather than bin.base64.  This is to handle WebFolders (shipped Office9)
		//	which doesn't seem to handle 0 length bin.base64 properties correctly
		//	(fails).
		//
		if (fUseBinHexIfNoValue && (0 == cb))
			pwszType = gc_wszDavType_Bin_Hex;
		else
			pwszType = gc_wszDavType_Bin_Base64;
	}

	if (cb)
	{
		//	Allocate a buffer big enough for the entire encoded string.
		//	Base64 uses 4 chars out for each 3 bytes in, AND if there is ANY
		//	"remainder", it needs another 4 chars to encode the remainder.
		//	("+2" BEFORE "/3" ensures that we count any remainder as a whole
		//	set of 3 bytes that need 4 chars to hold the encoding.)
		//	We also need one char for terminal NULL of our string --
		//	CbSizeWsz takes care of that for the alloc, and we explicitly pass
		//	cchBuf+1 for the call to EncodeBase64.
		//
		ULONG cchBuf = CchNeededEncodeBase64 (cb);
		pwszBuf = static_cast<LPWSTR>(ExAlloc(CbSizeWsz(cchBuf)));
		EncodeBase64 (reinterpret_cast<BYTE*>(pv), cb, pwszBuf, cchBuf + 1);
	}
	return ScAddNode (pwszTag, en, pwszBuf, pwszType);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\_xmllib.h ===
/*
 *	_ X M L L I B . H
 *
 *	XML document processing
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#ifndef	__XMLLIB_H_
#define __XMLLIB_H_

//	Define _WINSOCKAPI_ to keep windows.h from including winsock.h,
//	whose declarations would be redefined in winsock2.h,
//	which is included by iisextp.h,
//	which we include below!
//
#define _WINSOCKAPI_
#include <windows.h>
#include <oledberr.h>
#include <limits.h>

#pragma warning(disable:4100)	//	unref formal parameter
#pragma warning(disable:4200)	//	non-standard extension
#pragma warning(disable:4201)	//	non-standard extension
#pragma warning(disable:4710)	//	unexpanded c++ methods

#include <ex\refcnt.h>
#include <ex\nmspc.h>
#include <ex\xml.h>
#include <ex\xmldata.h>
#include <ex\xprs.h>
#include <ex\cnvt.h>

#include <ex\atomcache.h>
#include <ex\xemit.h>

DEC_CONST WCHAR gc_wszNamespaceGuid[] = L"{xxxxxxxx-yyyy-zzzz-aaaa-bbbbbbbbbbbb}";

#endif	// __XMLLIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\base64.cpp ===
/*
 *	B A S E 6 4 . C P P
 *
 *	Sources Base64 encoding
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"

/* From RFC 1521:

5.2.  Base64 Content-Transfer-Encoding

   The Base64 Content-Transfer-Encoding is designed to represent
   arbitrary sequences of octets in a form that need not be humanly
   readable.  The encoding and decoding algorithms are simple, but the
   encoded data are consistently only about 33 percent larger than the
   unencoded data.	This encoding is virtually identical to the one used
   in Privacy Enhanced Mail (PEM) applications, as defined in RFC 1421.
   The base64 encoding is adapted from RFC 1421, with one change: base64
   eliminates the "*" mechanism for embedded clear text.

	  A 65-character subset of US-ASCII is used, enabling 6 bits to be
   represented per printable character. (The extra 65th character, "=",
   is used to signify a special processing function.)

	  NOTE: This subset has the important property that it is
	  represented identically in all versions of ISO 646, including US
	  ASCII, and all characters in the subset are also represented
	  identically in all versions of EBCDIC.  Other popular encodings,
	  such as the encoding used by the uuencode utility and the base85
	  encoding specified as part of Level 2 PostScript, do not share
	  these properties, and thus do not fulfill the portability
	  requirements a binary transport encoding for mail must meet.

   The encoding process represents 24-bit groups of input bits as output
   strings of 4 encoded characters. Proceeding from left to right, a
   24-bit input group is formed by concatenating 3 8-bit input groups.
   These 24 bits are then treated as 4 concatenated 6-bit groups, each
   of which is translated into a single digit in the base64 alphabet.
   When encoding a bit stream via the base64 encoding, the bit stream
   must be presumed to be ordered with the most-significant-bit first.
   That is, the first bit in the stream will be the high-order bit in
   the first byte, and the eighth bit will be the low-order bit in the
   first byte, and so on.

   Each 6-bit group is used as an index into an array of 64 printable
   characters. The character referenced by the index is placed in the
   output string. These characters, identified in Table 1, below, are
   selected so as to be universally representable, and the set excludes
   characters with particular significance to SMTP (e.g., ".", CR, LF)
   and to the encapsulation boundaries defined in this document (e.g.,
   "-").

			   Table 1: The Base64 Alphabet

	  Value Encoding  Value Encoding  Value Encoding  Value Encoding
		   0 A			  17 R			  34 i			  51 z
		   1 B			  18 S			  35 j			  52 0
		   2 C			  19 T			  36 k			  53 1
		   3 D			  20 U			  37 l			  54 2
		   4 E			  21 V			  38 m			  55 3
		   5 F			  22 W			  39 n			  56 4
		   6 G			  23 X			  40 o			  57 5
		   7 H			  24 Y			  41 p			  58 6
		   8 I			  25 Z			  42 q			  59 7
		   9 J			  26 a			  43 r			  60 8
		  10 K			  27 b			  44 s			  61 9
		  11 L			  28 c			  45 t			  62 +
		  12 M			  29 d			  46 u			  63 /
		  13 N			  30 e			  47 v
		  14 O			  31 f			  48 w		   (pad) =
		  15 P			  32 g			  49 x
		  16 Q			  33 h			  50 y

   The output stream (encoded bytes) must be represented in lines of no
   more than 76 characters each.  All line breaks or other characters
   not found in Table 1 must be ignored by decoding software.  In base64
   data, characters other than those in Table 1, line breaks, and other
   white space probably indicate a transmission error, about which a
   warning message or even a message rejection might be appropriate
   under some circumstances.

   Special processing is performed if fewer than 24 bits are available
   at the end of the data being encoded.  A full encoding quantum is
   always completed at the end of a body.  When fewer than 24 input bits
   are available in an input group, zero bits are added (on the right)
   to form an integral number of 6-bit groups.	Padding at the end of
   the data is performed using the '=' character.  Since all base64
   input is an integral number of octets, only the following cases can
   arise: (1) the final quantum of encoding input is an integral
   multiple of 24 bits; here, the final unit of encoded output will be
   an integral multiple of 4 characters with no "=" padding, (2) the
   final quantum of encoding input is exactly 8 bits; here, the final
   unit of encoded output will be two characters followed by two "="
   padding characters, or (3) the final quantum of encoding input is
   exactly 16 bits; here, the final unit of encoded output will be three
   characters followed by one "=" padding character.

   Because it is used only for padding at the end of the data, the
   occurrence of any '=' characters may be taken as evidence that the
   end of the data has been reached (without truncation in transit).  No
   such assurance is possible, however, when the number of octets
   transmitted was a multiple of three.

   Any characters outside of the base64 alphabet are to be ignored in
   base64-encoded data.	 The same applies to any illegal sequence of
   characters in the base64 encoding, such as "====="

   Care must be taken to use the proper octets for line breaks if base64
   encoding is applied directly to text material that has not been
   converted to canonical form.	 In particular, text line breaks must be
   converted into CRLF sequences prior to base64 encoding. The important
   thing to note is that this may be done directly by the encoder rather
   than in a prior canonicalization step in some implementations.

	  NOTE: There is no need to worry about quoting apparent
	  encapsulation boundaries within base64-encoded parts of multipart
	  entities because no hyphen characters are used in the base64
	  encoding.

*/

VOID inline
EncodeAtom (LPBYTE pbIn, WCHAR* pwszOut, UINT cbIn)
{
	static const WCHAR wszBase64[] = L"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
									 L"abcdefghijklmnopqrstuvwxyz"
									 L"0123456789+/";
	Assert (pbIn);
	Assert (pwszOut);
	Assert (cbIn);

	//	Set cbIn to 3 if it's greater than three: convenient for 'switch'
	//
	if (cbIn > 3)
		cbIn = 3;

	pwszOut[0] = wszBase64[pbIn[0] >> 2];
	switch(cbIn)
	{
		case 3:

			//	End of stream has not been reached yet
			//
			pwszOut[1] = wszBase64[((pbIn[0] & 0x03) << 4) + (pbIn[1] >> 4)];
			pwszOut[2] = wszBase64[((pbIn[1] & 0x0F) << 2) + (pbIn[2] >> 6)];
			pwszOut[3] = wszBase64[pbIn[2] & 0x3F];
			return;

		case 2:

			//	At the end of stream: pad with 1 byte
			//
			pwszOut[1] = wszBase64[((pbIn[0] & 0x03) << 4) + (pbIn[1] >> 4)];
			pwszOut[2] = wszBase64[ (pbIn[1] & 0x0F) << 2];
			pwszOut[3] = L'=';
			return;

		case 1:

			//	At the end of stream: pad with 2 bytes
			//
			pwszOut[1] = wszBase64[ (pbIn[0] & 0x03) << 4];
			pwszOut[2] = L'=';
			pwszOut[3] = L'=';
			return;

		default:

			//	Should never happen
			//
			Assert (FALSE);
	}
}

//	------------------------------------------------------------------------
//	EncodeBase64
//
//	Encode cbIn bytes of data from pbIn into the provided buffer
//	at pwszOut, up to cchOut chars.
//$REVIEW: Shouldn't this function return some kind of error if
//$REVIEW: cchOut didn't have enough space for the entire output string?!!!
//
void
EncodeBase64 (LPBYTE pbIn, UINT cbIn, WCHAR* pwszOut, UINT cchOut)
{
	//	They must have passed us at least one char of space -- for the terminal NULL.
	Assert (cchOut);

	//	Loop through, encoding atoms as we go...
	//
	while (cbIn)
	{
		//	NOTE: Yes, test for STRICTLY more than 4 WCHARs of space.
		//	We will use 4 WCHARs on this pass of the loop, and we always
		//	need one for the terminal NULL!
		Assert (cchOut > 4);

		//	Encode the next three bytes of data into four chars of output string.
		//	(NOTE: This does handle the case where we have <3 bytes of data
		//	left to encode -- thus we pass in cbIn!)
		//
		EncodeAtom (pbIn, pwszOut, cbIn);

		//	Update our pointers and counters.
		pbIn += min(cbIn, 3);
		pwszOut += 4;
		cchOut -= 4;
		cbIn -= min(cbIn, 3);
	}

	//	Ensure Termination
	//	(But first, check that we still have one WCHAR of space left
	//	for the terminal NULL!)
	//
	Assert (cchOut >= 1);
	*pwszOut = 0;
}

SCODE
ScDecodeBase64 (WCHAR* pwszIn, UINT cchIn, LPBYTE pbOut, UINT* pcbOut)
{
	//	Base64 Reverse alphabet.  Indexed by base 64 alphabet character
	//
	static const BYTE bEq = 254;
	static const BYTE rgbDict[128] = {

		255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,	// 0-F
		255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,	// 10-1F
		255,255,255,255,255,255,255,255,255,255,255, 62,255,255,255, 63,	// 20-2F
		 52, 53, 54, 55, 56, 57, 58, 59, 60, 61,255,255,255,bEq,255,255,	// 30-3f
		255,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14,	// 40-4f
		 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,255,255,255,255,255,	// 50-5f
		255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,	// 60-6f
		 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,255,255,255,255,255		// 70-7f
	};

	SCODE sc = S_OK;

	UINT cchConsumed = 0;
	UINT cbProduced = 0;
	UINT cbFudge = 0;

	Assert (pbOut);
	Assert (pcbOut);

	//	Check that they didn't lie about the size of their buffer!
	//
	Assert (!IsBadWritePtr(pbOut, *pcbOut));

	//	Check that the size of the output buffer is adequate for
	//	decoded data.
	//
	Assert (*pcbOut >= CbNeededDecodeBase64(cchIn));
	Assert (pwszIn);

	//	Output is generated in 3-byte increments for 4 bytes of input
	//
	Assert ((cchIn*3)/4 <= *pcbOut);

	//	Go until there is nothing left to decode...
	//
	while (cchConsumed < cchIn)
	{
		Assert (cbProduced <= *pcbOut);

		BYTE rgb[4];
		UINT ib = 0;
		
		//	However, if there is not enough space to
		//	decode the next atom into, then this has
		//	got to be an error...
		//
		if (*pcbOut - cbProduced < 3)
		{
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Not enough space to decode next base64 atom.");
			break;
		}

		//	The characters that do not fall into base 64 alphabet must be
		//	ignored, so let us assemble the 4 byte chunk of data that we
		//	will actually go with for the conversion
		//
		while ((cchConsumed < cchIn) &&
			   (ib < 4))
		{
			//	If the symbol is in the alphabet ...
			//
			if ((pwszIn[cchConsumed] < sizeof(rgbDict)) &&
				(rgbDict[pwszIn[cchConsumed]] != 0xFF))
			{
				//	...	save the character off into the
				//	array
				//
				rgb[ib++] = rgbDict[pwszIn[cchConsumed]];
			}

			//	... go for the next character in the line
			//
			cchConsumed++;
		}

		//	If there is no more data at all, then go
		//	away with no error, as up to that point
		//	we converted everything just fine, and
		//	the characters in the end were ignorable
		//
		if (0 == ib)
		{
			Assert(cchConsumed == cchIn);
			break;
		}
		else if ((4 != ib) || (0 != cbFudge))
		{
			//	There was some data to convert, but not enough to fill in
			//	the 4 byte buffer then data is incomplete and cannot be converted;
			//	If the end bEq markers were present some time before, data
			//	is also invalid, there should not be any data after the end
			//
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, data not complete, or extra data after padding: %ws\n", pwszIn);
			break;
		}

		//	Check that the characters 1 and 2 are not bEq
		//
		if ((rgb[0] == bEq) ||
			(rgb[1] == bEq))
		{
			sc = E_DAV_BASE64_ENCODING_ERROR;
			DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, terminating '=' characters earlier than expected: %ws\n", pwszIn);
			break;
		}

		//	Check if the third character is bEq
		//
		if (rgb[2] == bEq)
		{
			rgb[2] = 0;
			cbFudge += 1;

			//	... the fourth should be also bEq if the third was that way
			//
			if (rgb[3] != bEq)
			{
				sc = E_DAV_BASE64_ENCODING_ERROR;
				DebugTrace ("ScDecodeBase64: Invalid base64 input encountered, terminating '=' characters earlier than expected:  %ws\n", pwszIn);
				break;
			}
		}

		//	Check if the fourth character is bEq
		//
		if (rgb[3] == bEq)
		{
			rgb[3] = 0;
			cbFudge += 1;
		}

		//	Make sure that these are well formed 6bit characters.
		//
		Assert((rgb[0] & 0x3f) == rgb[0]);
		Assert((rgb[1] & 0x3f) == rgb[1]);
		Assert((rgb[2] & 0x3f) == rgb[2]);
		Assert((rgb[3] & 0x3f) == rgb[3]);

		//	Ok, we now have 4 6bit characters making up the 3 bytes of output.
		//
		//	Assemble them together to make a 3 byte word.
		//
		DWORD dwValue = (rgb[0] << 18) +
						(rgb[1] << 12) +
						(rgb[2] << 6) +
						(rgb[3]);

		//	This addition had better not have wrapped.
		//
		Assert ((dwValue & 0xff000000) == 0);

		//	Copy over the 3 bytes into the output stream.
		//
		pbOut[0] = (BYTE)((dwValue & 0x00ff0000) >> 16);
		Assert(pbOut[0] == (rgb[0] << 2) + (rgb[1] >> 4));
		pbOut[1] = (BYTE)((dwValue & 0x0000ff00) >>	 8);
		Assert(pbOut[1] == ((rgb[1] & 0xf) << 4) + (rgb[2] >> 2));
		pbOut[2] = (BYTE)((dwValue & 0x000000ff) >>	 0);
		Assert(pbOut[2] == ((rgb[2] & 0x3) << 6) + rgb[3]);
		cbProduced += 3;
		pbOut += 3;

		//	If cbFudge is non 0, it means we had "=" signs at the end
		//	of the buffer.	In this case, we overcounted the actual
		//	number of characters in the buffer.
		//
		//	Although cbFuge is counted in 6 bit chunks, but it assumes
		//	values just 0, 1 or 2. And that allows us to say that the
		//	number of bytes actually produced were by cbFuge less.
		//	Eg. if cbFuge = 1, then uuuuuu is padded, which could
		//		happen only when zzzzzzzz chunk was empty
		//		if cbFuge = 2, then zzzzzz uuuuuu is padded, which could
		//		happen only when yyyyyyyy and zzzzzzzz were empty
		//
		//	xxxxxx yyyyyy zzzzzz uuuuuu <- 6 bit chunks
		//	xxxxxx xxyyyy yyyyzz zzzzzz	<- 8 bit chunks
		//
		if (cbFudge)
		{
			Assert ((cbFudge < 3) && (cbFudge < cbProduced));
			cbProduced -= cbFudge;
			pbOut -= cbFudge;
		}		
	}

	//	Tell the caller the actuall size...
	//
	*pcbOut = cbProduced;
	return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\webdav\_xmllib\cnvt.cpp ===
/*
 *	C N V T . C P P
 *
 *	Data conversion routines
 *
 *	Copyright 1986-1997 Microsoft Corporation, All Rights Reserved
 */

#include "_xmllib.h"
#include <string.h>
#include <stdio.h>

//	Month names ---------------------------------------------------------------
//
DEC_CONST LPCWSTR c_rgwszMonthNames[] =
{
	L"Jan",
	L"Feb",
	L"Mar",
	L"Apr",
	L"May",
	L"Jun",
	L"Jul",
	L"Aug",
	L"Sep",
	L"Oct",
	L"Nov",
	L"Dec",
};
DEC_CONST ULONG c_cMonthNames = CElems(c_rgwszMonthNames);
DEC_CONST ULONG c_cchMonthName = 3;

DEC_CONST LPCWSTR c_rgwszDayNames[] =
{
	L"Sun",
	L"Mon",
	L"Tue",
	L"Wed",
	L"Thu",
	L"Fri",
	L"Sat",
};
DEC_CONST UINT c_cDayNames = CElems(c_rgwszDayNames);
DEC_CONST UINT c_cchDayName = 3;

//	Date formats --------------------------------------------------------------
//
DEC_CONST WCHAR gc_wszIso8601_min[]			= L"yyyy-mm-ddThh:mm:ssZ";
DEC_CONST UINT	gc_cchIso8601_min			= CchConstString(gc_wszIso8601_min);
DEC_CONST WCHAR gc_wszIso8601_scanfmt[]		= L"%04hu-%02hu-%02huT%02hu:%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_tz_scanfmt[]	= L"%02hu:%02hu";
DEC_CONST WCHAR gc_wszIso8601_fmt[]			= L"%04d-%02d-%02dT%02d:%02d:%02d.%03dZ";
DEC_CONST WCHAR gc_wszRfc1123_min[]			= L"www, dd mmm yyyy hh:mm:ss GMT";
DEC_CONST UINT	gc_cchRfc1123_min			= CchConstString (gc_wszRfc1123_min);
DEC_CONST WCHAR gc_wszRfc1123_fmt[] 		= L"%ls, %02d %ls %04d %02d:%02d:%02d GMT";

enum {
	tf_year,
	tf_month,
	tf_day,
	tf_hour,
	tf_minute,
	tf_second,
	cTimeFields,

	tz_hour = 0,
	tz_minute,
	cTzDeltaFields,

	RADIX_BASE = 10,
};

//	Conversion functions ------------------------------------------------------
//
/*
 *	CchFindChar
 *
 *	Look for the given char, obeying the cbMax limit.
 *	If the char is not found, return INVALID_INDEX.
 */
UINT __fastcall
CchFindChar(WCHAR wch, LPCWSTR pwszData, UINT cchMax)
{
	UINT cchParsed = 0;
	while (cchParsed < cchMax &&
		   wch != *pwszData)
	{
		cchParsed++;
		pwszData++;
	}

	if (cchParsed == cchMax)
		cchParsed = INVALID_INDEX;
	return cchParsed;
}

/*
 *	CchSkipWhitespace
 *
 *	Skips whitespace, obeying the cbMax limit.
 *	Returns the number of bytes parsed.
 */
UINT __fastcall
CchSkipWhitespace(LPCWSTR pwszData, UINT cchMax)
{
	UINT cchParsed = 0;
	while (cchParsed < cchMax &&
		   (L' ' == *pwszData ||
			L'\t' == *pwszData ||
			L'\n' == *pwszData ||
			L'\r' == *pwszData))
	{
		cchParsed++;
		pwszData++;
	}
	return cchParsed;
}

LONG __fastcall
LNumberFromParam(LPCWSTR pwszData, UINT cchMax)
{
	LONG lReturn = 0;
	UINT cchCurrent = 0;
	BOOL fNegative = FALSE;

	if (0 < cchMax)
	{
		// Get any sign char.
		//
		if (L'-' == *pwszData)
		{
			// Set the negative flag to true.
			//
			fNegative = TRUE;

			// Skip this valid character.
			//
			cchCurrent++;

			// Skip any whitespace.
			//
			cchCurrent += CchSkipWhitespace(&pwszData[1], cchMax - 1);
		}
		else if (L'+' == *pwszData)
		{
			// Skip any whitespace.
			//
			cchCurrent += CchSkipWhitespace(&pwszData[1], cchMax - 1);
		}
	}

	// From here, any non-number chars are invalid & mean we
	// should stop parsing.

	// Get the magnitude of the number.
	//
	while (cchCurrent < cchMax)
	{
		if (L'0' <= static_cast<USHORT>(pwszData[cchCurrent]) &&
		    L'9' >= static_cast<USHORT>(pwszData[cchCurrent]))
		{
			lReturn *= 10;
			lReturn += (pwszData[cchCurrent] - L'0');
		}
		else
		{
			// Not a number char.  Time to quit parsing.
			//
			break;
		}

		// Move to the next char.
		//
		cchCurrent++;
	}

	// Apply the negative sign, if any.
	//
	if (fNegative)
		lReturn = (0 - lReturn);

	return lReturn;
}

HRESULT __fastcall
HrHTTPDateToFileTime(LPCWSTR pwszDate,
					 FILETIME * pft)
{
	HRESULT		hr;
	SYSTEMTIME	systime;
	UINT		cchDate;

	//	Make sure we were passed something as a date string.
	//
	Assert(pwszDate);
	Assert(pft);

	//	Zero out the structure.
	//
	memset(&systime, 0, sizeof(SYSTEMTIME));

	//	Get the length of the date string.
	//
	cchDate = static_cast<UINT>(wcslen(pwszDate));

	//	Get the date and time pieces.  If either fails, return its
	//	error code.  Otherwise, convert to a file time at the end,
	//	return E_FAIL if the conversion fails, S_OK otherwise.
	//
	hr = GetFileDateFromParam(pwszDate,
							  cchDate,
							  &systime);
	if (FAILED(hr))
		return hr;

	hr = GetFileTimeFromParam(pwszDate,
							  cchDate,
							  &systime);

	if (FAILED(hr))
		return hr;

	if (!SystemTimeToFileTime(&systime, pft))
		return E_FAIL;

	return S_OK;
}


HRESULT __fastcall
GetFileDateFromParam (LPCWSTR pwszData,
	UINT cchTotal,
	SYSTEMTIME * psystime)
{
	LPCWSTR pwszCurrent;
	UINT cchLeft;
	UINT cchTemp;

	Assert(pwszData);
	Assert(psystime);

	// Skip leading whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszData, cchTotal);
	pwszCurrent = pwszData + cchTemp;
	cchLeft = cchTotal - cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid date 
	//  string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// If the first char's of the date are ddd, then the day of the
	// week is a part of the date, and we really do not care.
	//
	if (L'9' < static_cast<USHORT>(*pwszCurrent))
	{
		// Find the day
		//
		UINT uiDay;
		for (uiDay = 0; uiDay < c_cDayNames; uiDay++)
		{
			// Compare the month names.
			//
			if (*pwszCurrent == *(c_rgwszDayNames[uiDay]) &&
				(c_cchDayName <= cchLeft) && 
				!_wcsnicmp(pwszCurrent, c_rgwszDayNames[uiDay], c_cchDayName))
			{
				// Found the right month.  This index tells us the month number.
				//
				psystime->wDayOfWeek = static_cast<WORD>(uiDay);  // Sunday is 0
				break;
			}
		}
		if (uiDay == c_cDayNames)
			return E_FAIL;

		// Look for our space delimiter.
		//
		cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
		if (INVALID_INDEX == cchTemp)
		{
			// Invalid format to this data. Fail here.
			//
			return E_FAIL;
		}
		pwszCurrent += cchTemp;
		cchLeft -= cchTemp;
		//  CchFindChar will return INVALID_INDEX if we hit the end of the 
		//  string, so we can assert that we have more space in the string.
		//
		Assert(0 < cchLeft);

		// Again, skip whitespace.
		//
		cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
		pwszCurrent += cchTemp;
		cchLeft -= cchTemp;
		//  If we've hit the end of our buffer already, this was an invalid 
		//  date string.
		//
		if (0 == cchLeft)
			return E_FAIL;
	}

	// The date format is dd month yyyy.  Anything else is invalid.

	// Get the day-of-the-month number.
	//
	psystime->wDay = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// Look for our space delimiter.
	//
	cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// Invalid format to this data. Fail here.
		//
		return E_FAIL;
	}
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  CchFindChar will return INVALID_INDEX if we hit the end of the 
	//  string, so we can assert that we have more space in the string.
	//
	Assert(0 < cchLeft);

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid 
	//  date string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// Find the month number.
	//
	for (UINT uiMonth = 0; uiMonth < c_cMonthNames; uiMonth++)
	{
		// Compare the month names.
		//
		if (*pwszCurrent == *(c_rgwszMonthNames[uiMonth]) &&
			(c_cchMonthName <= cchLeft) && 
			!_wcsnicmp(pwszCurrent, c_rgwszMonthNames[uiMonth], c_cchMonthName))
		{
			// Found the right month.  This index tells us the month number.
			//
			psystime->wMonth = static_cast<WORD>(uiMonth + 1);  // January is 1.
			break;
		}
	}

	// Look for our space delimiter.
	//
	cchTemp = CchFindChar(L' ', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// Invalid format to this data. Fail here.
		//
		return E_FAIL;
	}
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  CchFindChar will return INVALID_INDEX if we hit the end of the 
	//  string, so we can assert that we have more space in the string.
	//
	Assert(0 < cchLeft);

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid 
	//  date string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// Now get the year.
	//
	psystime->wYear = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	return S_OK;
}

HRESULT __fastcall
GetFileTimeFromParam (LPCWSTR pwszData,
	UINT cchTotal,
	SYSTEMTIME * psystime)
{
	LPCWSTR pwszCurrent;
	UINT cchLeft;
	UINT cchTemp;

	Assert(pwszData);
	Assert(psystime);

	// Skip leading whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszData, cchTotal);
	pwszCurrent = pwszData + cchTemp;
	cchLeft = cchTotal - cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid 
	//  date string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// Skip any date information.  This could get called for date-time params!

	// Look for the first colon delimiter. Yes, we assume no colons in date info!
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No time info available. Fail here.
		//
		return E_FAIL;
	}
	
	//  Make sure we've got room to back up
	//
	if (2 > cchTemp)
	{
		return E_FAIL;
	}
	cchTemp--;		// Back up to get the hours digits.
	cchTemp--;
	
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  CchFindChar will return INVALID_INDEX if we hit the end of the 
	//  string, so we can assert that we have at least two digits plus a 
	//  ':' still in the string.
	//
	Assert(2 < cchLeft);

	// Skip whitespace (in case the parm is h:mm:ss).
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid 
	//  date string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// Time format is hh:mm:ss UT, GMT, +- hh:mm, anything else is invalid.
	// (Actually, we allow [h]h:mm[:ss], and whitespace around the colons.)

	// Get the hours.
	//
	psystime->wHour = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// Look for our colon delimiter.
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No minutes specified.  This is not allowed.  Fail here.
		//
		return E_FAIL;
	}
	cchTemp++;		// Skip the found character also.
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid 
	//  date string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid 
	//  date string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// Get the minutes.
	//
	psystime->wMinute = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// NOTE: The seconds are optional.  Don't fail here!

	// Look for our colon delimiter.
	//
	cchTemp = CchFindChar(L':', pwszCurrent, cchLeft);
	if (INVALID_INDEX == cchTemp)
	{
		// No seconds specified.  This is allowed.  Return success.
		//
		return S_OK;
	}
	cchTemp++;		// Skip the found character also.
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid 
	//  date string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// Again, skip whitespace.
	//
	cchTemp = CchSkipWhitespace(pwszCurrent, cchLeft);
	pwszCurrent += cchTemp;
	cchLeft -= cchTemp;
	//  If we've hit the end of our buffer already, this was an invalid 
	//  date string.
	//
	if (0 == cchLeft)
		return E_FAIL;

	// Get the seconds, if any.
	//
	psystime->wSecond = static_cast<WORD>(LNumberFromParam(pwszCurrent, cchLeft));

	// LATER: Get the timezone spec from the line and shift this data into our timezone...

	return S_OK;
}

BOOL __fastcall
FGetSystimeFromDateIso8601(LPCWSTR pwszDate, SYSTEMTIME * psystime)
{
	UINT i;

	// 	Iso8601 is a fixed digit format: "yyyy-mm-ddThh:mm:ssZ"
	//	we require the date strings has at least the required
	//	chars (we allow for the ommission of the fractional
	//	seconds, and the time delta), otherwise it is an error.
	//
	if (gc_cchIso8601_min > static_cast<UINT>(wcslen(pwszDate)))
	{
		DebugTrace ("Dav: date length < than minimal\n");
		return FALSE;
	}

	//	Scan the first bit of date information up to the
	//	optional bits
	//
	psystime->wMilliseconds = 0;
	if (cTimeFields != swscanf (pwszDate,
								gc_wszIso8601_scanfmt,
								&psystime->wYear,
								&psystime->wMonth,
								&psystime->wDay,
								&psystime->wHour,
								&psystime->wMinute,
								&psystime->wSecond))
	{
		DebugTrace ("Dav: minimal scan failed\n");
		return FALSE;
	}

	//	Take a look at what is next and process accordingly.
	//
	//	('Z'), ('.'), ('+') and ('-').
	//
	//	The ('Z') element signifies ZULU time and completes
	//	the time string.  The ('.') element signifies that a
	//	fractional second value follows.  And either a ('+')
	//	or ('-') element indicates that a timezone delta will
	//	follow.
	//
	i = gc_cchIso8601_min - 1;
	if (pwszDate[i] == L'Z')
		goto ret;
	else if (pwszDate[i] == L'.')
		goto frac_sec;
	else if ((pwszDate[i] == L'+') || (pwszDate[i] == L'+'))
		goto tz_delta;

	DebugTrace ("Dav: minimal date not terminated properly\n");
	return FALSE;

frac_sec:

	Assert (pwszDate[i] == L'.');
	{
		UINT iFrac;

		for (iFrac = ++i; pwszDate[i]; i++)
		{
			//	Any non-digit terminates the fractional seconds time
			//
			if ((pwszDate[i] > L'9') || (pwszDate[i] < L'0'))
			{
				//	At this point, we are expecting ('Z') or a timezone
				//	delta ('+') or ('-')
				//
				if (pwszDate[i] == L'Z')
					goto ret;
				else if ((pwszDate[i] == L'+') || (pwszDate[i] == L'-'))
					goto tz_delta;

				break;
			}

			//	It turns out, our granularity is only milliseconds, so
			//	we cannot keep any better precision than that.  However,
			//	we can round the last digit, so at best we will process
			//	the next four digits
			//
			if (i - iFrac < 3)
			{
				//	As many digits remain, comprise the fractional
				//
				psystime->wMilliseconds = static_cast<WORD>(
					psystime->wMilliseconds * RADIX_BASE + (pwszDate[i]-L'0'));
			}
			else if (i - iFrac < 4)
			{
				//	Our granularity is only milliseconds, so we cannot keep
				//	any better precision than that.  However, we can round this
				//	digit.
				//
				psystime->wMilliseconds = static_cast<WORD>(
					psystime->wMilliseconds + (((pwszDate[i]-L'0')>4)?1:0));
			}
		}

		//	We ran out of string before the time was terminated
		//
		return FALSE;
	}

tz_delta:

	Assert ((pwszDate[i] == L'+') || (pwszDate[i] == L'-'));
	{
		WORD wHr;
		WORD wMin;
		__int64 tm;
		__int64 tzDelta;
		static const __int64 sc_i64Min = 600000000;
		static const __int64 sc_i64Hr = 36000000000;
		FILETIME ft;

		//	Find the time delta in terms of FILETIME units
		//
		if (cTzDeltaFields != swscanf (pwszDate + i + 1,
									   gc_wszIso8601_tz_scanfmt,
									   &wHr,
									   &wMin))
		{
			DebugTrace ("Dav: tz delta scan failed\n");
			return FALSE;
		}
		tzDelta = (sc_i64Hr * wHr) + (sc_i64Min * wMin);

		//	Convert the time into a FILETIME, and stuff it into
		//	a 64bit integer
		//
		if (!SystemTimeToFileTime (psystime, &ft))
		{
			DebugTrace ("Dav: invalid time specified\n");
			return FALSE;
		}
		tm = FileTimeCastToI64(ft);

		//	Apply the delta
		//
		if (pwszDate[i] == L'+')
			tm = tm + tzDelta;
		else
		{
			Assert (pwszDate[i] == L'-');
			tm = tm - tzDelta;
		}

		//	Return the value converted back into a SYSTEMTIME
		//
		ft = I64CastToFileTime(tm);
		if (!FileTimeToSystemTime (&ft, psystime))
		{
			DebugTrace ("Dav: delta invalidated time\n");
			return FALSE;
		}
	}

ret:

	return TRUE;
}

BOOL __fastcall
FGetDateIso8601FromSystime(SYSTEMTIME * psystime, LPWSTR pwszDate, UINT cchSize)
{
	//	If there is not enough space...
	//
	if (gc_cchIso8601_min >= cchSize)
		return FALSE;

	//	Format it and return...
	//
	return (!!wsprintfW (pwszDate,
						 gc_wszIso8601_fmt,
						 psystime->wYear,
						 psystime->wMonth,
						 psystime->wDay,
						 psystime->wHour,
						 psystime->wMinute,
						 psystime->wSecond,
						 psystime->wMilliseconds));
}

BOOL __fastcall
FGetDateRfc1123FromSystime (SYSTEMTIME * psystime, LPWSTR pwszDate, UINT cchSize)
{
	//	If there is not enough space...
	//
	if (gc_cchRfc1123_min >= cchSize)
		return FALSE;

	//  If wDayOfWeek (Sun-Sat: 0-7) or wMonth (Jan-Dec: 1-12) is out of range, 
	//  we'll fail here (to protect our const array lookups below).
	//  Note:  psystime->wMonth is unsigned, so if there's an invalid value
	//  of 0, then we'll still catch it.
	//
	if (c_cDayNames <= psystime->wDayOfWeek)
		return FALSE;
	if (c_cMonthNames <= (psystime->wMonth - 1))
		return FALSE;

	//	Format it and return...
	//
	return (!!wsprintfW (pwszDate,
						 gc_wszRfc1123_fmt,
						 c_rgwszDayNames[psystime->wDayOfWeek],
						 psystime->wDay,
						 c_rgwszMonthNames[psystime->wMonth - 1],
						 psystime->wYear,
						 psystime->wHour,
						 psystime->wMinute,
						 psystime->wSecond));
}

//	BCharToHalfByte -----------------------------------------------------------
//
//	Switches a wide char to a half-byte hex value.  The incoming char
//	MUST be in the "ASCII-encoded hex digit" range: 0-9, A-F, a-f.
//
DEC_CONST BYTE gc_mpbchCharToHalfByte[] = {

	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0x1,0x2,0x3,0x4,0x5,0x6,0x7,	0x8,0x9,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Caps here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
	0x0,0xa,0xb,0xc,0xd,0xe,0xf,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	// Lowercase here.
	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,	0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
};

inline BYTE BCharToHalfByte(WCHAR ch)
{
	//	gc_mpbchCharToHalfByte - map a ASCII-encoded char representing a single hex
	//	digit to a half-byte value.  Used to convert hex represented strings into a
	//	binary representation.
	//
	//	Reference values:
	//
	//		'0' = 49, 0x31;
	//		'A' = 65, 0x41;
	//		'a' = 97, 0x61;
	//
    AssertSz (!(ch & 0xFF00), "BCharToHalfByte: char upper bits non-zero");
    AssertSz (iswxdigit(ch), "Char out of hex digit range.");

    return gc_mpbchCharToHalfByte[ch];
}

//	------------------------------------------------------------------------
//	c_mpwchbStringize - map a half-byte (low nibble) value to
//		the correspoding ASCII-encoded wide char.
//	Used to convert binary data into Unicode URL strings.
//
DEC_CONST WCHAR c_mpwchhbStringize[] =
{
	L'0', L'1', L'2', L'3',
	L'4', L'5', L'6', L'7',
	L'8', L'9', L'a', L'b',
	L'c', L'd', L'e', L'f',
};

//	------------------------------------------------------------------------
//	WchHalfByteToWideChar
//	Switches a half-byte to an ACSII-encoded wide char.
//	NOTE: The caller must mask out the "other half" of the byte!
//
inline WCHAR WchHalfByteToWideChar(BYTE b)
{
	AssertSz(!(b & 0xF0), "Garbage in upper nibble.");
	return c_mpwchhbStringize[b];
};

//	==========================================================================
//
//	UTILITY FUNCTIONS
//		Used in building some props -- like getetag, resourcetag and flat url.
//		This code has been moved from calcprops.cpp to exprops.cpp and now to
//		cnvt.cpp. The Flat URL code lives in this file because it is needed
//		by _storext, exdav and davex. _props is the other component which is
//		shared by all of them. But _cnvt seemed like a better place to put
//		it. The other utility functions are needed by the flat url generation
//		code and by davex in processing parameterized URLs.
//
//	==========================================================================

//	------------------------------------------------------------------------
//	Un-stringiz-ing support functions
//	(Stringize = dump a binary blob to a string.
//	Unstringize = make it a binary blob again.)
//
inline
void
AssertCharInHexRange (char ch)
{
	Assert ((ch >= '0' && ch <= '9') ||
			(ch >= 'A' && ch <= 'F') ||
			(ch >= 'a' && ch <= 'f'));
}

inline
BYTE
NibbleFromChar (char ch)
{
	//	Assumes data is already in range....
	//
	return static_cast<BYTE>((ch <= '9')
							 ? ch - '0'
							 : ((ch >= 'a')
								? ch - 'W'		// 'W' = 'a' - 0xa
								: ch - '7'));	// '7' = 'A' - 0xa
}

inline
BYTE
ByteFromTwoChars (char chLow, char chHigh)
{
	BYTE nibbleLow;
	BYTE nibbleHigh;

	nibbleLow = NibbleFromChar(chLow);
	nibbleHigh = NibbleFromChar(chHigh);

	return static_cast<BYTE>(nibbleLow | (nibbleHigh << 4));
}

//$REVIEW: The following two functions really does not belong to any common libraries
//$REVIEW: that are shared by davex, exdav and exoledb. (other options are _prop, _sql)
//$REVIEW: On the other hand, we definitely don't want add a new lib for this. so just
//$REVIEW: add it here. Feel free to move them to a better location if you find one
//
//	------------------------------------------------------------------------
//
//	ScDupPsid()
//
//	Copies a SID properly (using CopySid()) into a heap-allocated buffer
//	that is returned to the caller.  The caller must free the buffer when
//	it is done using it.
//
SCODE
ScDupPsid (PSID psidSrc,
		   DWORD dwcbSID,
		   PSID * ppsidDst)
{
	PSID psidDst;

	Assert (psidSrc);
	Assert (IsValidSid(psidSrc));
	Assert (GetLengthSid(psidSrc) == dwcbSID);

	psidDst = static_cast<PSID>(ExAlloc(dwcbSID));
	if (!psidDst)
	{
		DebugTrace ("ScDupPsid() - OOM allocating memory for dup'd SID\n");
		return E_OUTOFMEMORY;
	}

	//	"Right way" -- since MSDN says not to touch the SID directly.
	if (!CopySid (dwcbSID, psidDst, psidSrc))
	{
		DWORD dwLastError = GetLastError();

		DebugTrace ("ScDupPsid() - CopySid() failed %d\n", dwLastError);
		ExFree (psidDst);
		return HRESULT_FROM_WIN32(dwLastError);
	}

	*ppsidDst = psidDst;

	return S_OK;
}

//	------------------------------------------------------------------------
//
//	ScGetTokenInfo()
//
//	Extracts a user's security ID (SID) from a security token.  Returns the SID
//	in a heap-allocated buffer which the caller must free.
//
SCODE
ScGetTokenInfo (HANDLE hTokenUser,
				DWORD * pdwcbSIDUser,
				PSID * ppsidUser)
{
	CStackBuffer<TOKEN_USER> pTokenUser;
	DWORD dwcbTokenUser = pTokenUser.size(); //$OPT What is a good initial guess?

	Assert (pdwcbSIDUser);
	Assert (ppsidUser);

	//	Fetch the token info into local memory.  GetTokenInformation()
	//	returns the size of the buffer needed if the one passed in is
	//	not large enough so this loop should execute no more than twice.
	//
#ifdef DBG
	for ( UINT iPass = 0;
		  (Assert (iPass < 2), TRUE);
		  ++iPass )
#else
	for ( ;; )
#endif
	{
		if (NULL == pTokenUser.resize(dwcbTokenUser))
			return E_OUTOFMEMORY;

		if (GetTokenInformation (hTokenUser,
								 TokenUser,
								 pTokenUser.get(),
								 dwcbTokenUser,
								 &dwcbTokenUser))
		{
			break;
		}
		else if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
		{
			return HRESULT_FROM_WIN32(GetLastError());
		}
	}

	//	Dup and return the SID from the token info.
	//
	*pdwcbSIDUser = GetLengthSid(pTokenUser->User.Sid);
	return ScDupPsid (pTokenUser->User.Sid,
					  *pdwcbSIDUser,
					  ppsidUser);
}


//	Our own version of WideCharToMultiByte(CP_UTF8, ...)
//
//	It returns similarly to the system call WideCharToMultiByte:
//
//	If the function succeeds, and cbDest is nonzero, the return value is
//	the number of bytes written to the buffer pointed to by psz.
//
//	If the function succeeds, and cbDest is zero, the return value is
//	the required size, in bytes, for a buffer that can receive the translated
//	string.
//
//	If the function fails, the return value is zero. To get extended error
//	information, call GetLastError. GetLastError may return one of the
//	following error codes:
//
//	ERROR_INSUFFICIENT_BUFFER
//	ERROR_INVALID_FLAGS
//	ERROR_INVALID_PARAMETER
//
//	See the WideCharToMultiByte MSDN pages to find out more about
//	this function and its use.
//
UINT WideCharToUTF8(/* [in]  */ LPCWSTR	pwszSrc,
				    /* [in]  */ UINT	cchSrc,
				    /* [out] */ LPSTR	pszDest,
				    /* [in]  */ UINT	cbDest)
{
	//	UTF-8 multi-byte encoding.  See Appendix A.2 of the Unicode book for
	//	more info.
	//
	//		Unicode value    1st byte    2nd byte    3rd byte
	//		000000000xxxxxxx 0xxxxxxx
	//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
	//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
	//

	//	If cbDest == 0 is passed in then we should only calculate the length
	//	needed, not use the "pszDest" parameter.
	//
	BOOL	fCalculateOnly = FALSE;

	//	(comment from nt\private\windows\winnls\mbcs.c, corrected for accuracy):
	//  Invalid Parameter Check:
	//     - length of WC string is 0
	//     - multibyte buffer size is negative
	//     - WC string is NULL
	//     - length of MB string is NOT zero AND
	//         (MB string is NULL OR src and dest pointers equal)
	//
	if ( (cchSrc == 0) ||
		 (pwszSrc == NULL) ||
		 ((cbDest != 0) &&
		  ((pszDest == NULL) ||
		   (reinterpret_cast<VOID *>(pszDest) ==
			reinterpret_cast<VOID *>(const_cast<LPWSTR>(pwszSrc))))) )
	{
		SetLastError(ERROR_INVALID_PARAMETER);
		return 0;
	}

#ifdef DBG
	//	Check our parameters.  We must be given a non-NULL pwszSrc.
	//
	Assert(pwszSrc);

	//	Make sure we have a valid string.
	//
	Assert(!IsBadStringPtrW(pwszSrc, (INVALID_INDEX == cchSrc) ? INFINITE : cchSrc));

	//	If the user says that the length of the multi-byte string is non-Zero,
	//	we must be given a non-NULL pszDest.  We'll also check it with IsBadWritePtr().
	//
	if (cbDest)
	{
		Assert(pszDest);
		Assert(!IsBadWritePtr(pszDest, cbDest));
	}
#endif

	//	If -1 is passed in as the length of the string, then we calculate the
	//	length of the string on the fly, and include the NULL terminator.
	//
	if (INVALID_INDEX == cchSrc)
		cchSrc = static_cast<UINT>(wcslen(pwszSrc) + 1);

	//	If 0 is passed in as cbDest, then we calculate the length of the
	//	buffer that would be needed to convert the string.  We ignore the
	//	pszDest parameter in this case.
	//
	if (0 == cbDest)
		fCalculateOnly = TRUE;

	UINT ich = 0;
	UINT iwch = 0;
	for (; iwch < cchSrc; iwch++)
	{
		WCHAR wch = pwszSrc[iwch];
		//
		//	Single-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		000000000xxxxxxx 0xxxxxxx
		//
		if (wch < 0x80)
		{
			if (!fCalculateOnly)
			{
				if (ich >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich] = static_cast<BYTE>(wch);
			}
			ich++;
		}
		//
		//	Double-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		00000yyyyyxxxxxx 110yyyyy    10xxxxxx
		//
		else if (wch < 0x800)
		{
			if (!fCalculateOnly)
			{
				if ((ich + 1) >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich]		= static_cast<BYTE>((wch >> 6) | 0xC0);
				pszDest[ich + 1]	= static_cast<BYTE>((wch & 0x3F) | 0x80);
			}
			ich += 2;
		}
		//
		//	Triple-Byte Case:
		//		Unicode value    1st byte    2nd byte    3rd byte
		//		zzzzyyyyyyxxxxxx 1110zzzz    10yyyyyy    10xxxxxx
		//
		else
		{
			if (!fCalculateOnly)
			{
				if ((ich + 2) >= cbDest)
				{
					SetLastError(ERROR_INSUFFICIENT_BUFFER);
					return 0;
				}

				pszDest[ich]		= static_cast<BYTE>((wch >> 12) | 0xE0);
				pszDest[ich + 1]	= static_cast<BYTE>(((wch >> 6) & 0x3F) | 0x80);
				pszDest[ich + 2]	= static_cast<BYTE>((wch & 0x3F) | 0x80);
			}
			ich += 3;
		}
	}

	return ich;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\mib\mib.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mib.c

Abstract:

    SNMP Extension Agent for Windows NT.

Created:

    18-Feb-1995

Revision History:

--*/

#include "mib.h"


//
//  Private constants & macros.
//

//
//  This macro creates a MIB_ENTRY for a MIB group header.
//

#define MIB_ENTRY_HEADER(oid)                           \
            {                                           \
                { OID_SIZEOF(oid), (oid) },             \
                -1,                                     \
                MIB_NOACCESS,                           \
                NULL,                                   \
                ASN_RFC1155_OPAQUE,                     \
            }

//
//  This macro creates a generic MIB_ENTRY for a MIB variable.
//

#define MIB_ENTRY_ITEM(oid,field,type)                  \
            {                                           \
                { OID_SIZEOF(oid), (oid) },             \
                FIELD_OFFSET(FTP_STATISTICS_0,field),   \
                MIB_ACCESS_READ,                        \
                MIB_Stat,                               \
                (type),                                 \
            }

//
//  These macros create COUNTER and INTEGER type MIB_ENTRYs.
//

#define MIB_COUNTER(oid,field)              \
            MIB_ENTRY_ITEM(oid, field, ASN_RFC1155_COUNTER)

#define MIB_INTEGER(oid,field)              \
            MIB_ENTRY_ITEM(oid, field, ASN_INTEGER)


//
//  Private types.
//

typedef UINT (*LPMIBFUNC)( UINT                 Action,
                           struct _MIB_ENTRY  * MibPtr,
                           RFC1157VarBind     * VarBind,
                           LPVOID               Statistics
                           );

typedef struct _MIB_ENTRY
{
    //
    //  The OID for this MIB variable.
    //

    AsnObjectIdentifier Oid;

    //
    //  The offset within the statistics structure for this
    //  variable.
    //

    LONG                FieldOffset;

    //
    //  Access type (read, write, read-write, none).
    //

    UINT                Access;

    //
    //  Pointer to a function that manages this variable.
    //

    LPMIBFUNC           MibFunc;

    //
    //  Type (integer, counter, gauge, etc.)
    //

    BYTE                Type;

} MIB_ENTRY;


//
//  Private globals.
//

//
//  The InternetServer section of the OID tree is organized as follows:
//
//      iso(1)
//          org(3)
//              dod(6)
//                  internet(1)
//                      private(4)
//                          enterprises(1)
//                              microsoft(311)
//                                  software(1)
//                                      InternetServer(7)
//                                          InetSrvCommon(1)
//                                              InetSrvStatistics(1)
//                                          FtpServer(2)
//                                              FtpStatistics(1)
//                                          W3Server(3)
//                                              W3Statistics(1)
//                                          GopherServer(4)
//                                              GopherStatistics(1)
//

UINT                OID_Prefix[]  = { 1, 3, 6, 1, 4, 1, 311, 1, 7, 2 };
AsnObjectIdentifier MIB_OidPrefix = { OID_SIZEOF(OID_Prefix), OID_Prefix };


//
//  OID definitions.
//
//  All leaf variables have a zero appended to their OID to indicate
//  that it is the only instance of this variable and that it exists.
//

UINT MIB_Statistics[]                   = { 1 };
UINT MIB_TotalBytesSent_HighWord[]      = { 1,  1, 0 };
UINT MIB_TotalBytesSent_LowWord[]       = { 1,  2, 0 };
UINT MIB_TotalBytesReceived_HighWord[]  = { 1,  3, 0 };
UINT MIB_TotalBytesReceived_LowWord[]   = { 1,  4, 0 };
UINT MIB_TotalFilesSent[]               = { 1,  5, 0 };
UINT MIB_TotalFilesReceived[]           = { 1,  6, 0 };
UINT MIB_CurrentAnonymousUsers[]        = { 1,  7, 0 };
UINT MIB_CurrentNonAnonymousUsers[]     = { 1,  8, 0 };
UINT MIB_TotalAnonymousUsers[]          = { 1,  9, 0 };
UINT MIB_TotalNonAnonymousUsers[]       = { 1, 10, 0 };
UINT MIB_MaxAnonymousUsers[]            = { 1, 11, 0 };
UINT MIB_MaxNonAnonymousUsers[]         = { 1, 12, 0 };
UINT MIB_CurrentConnections[]           = { 1, 13, 0 };
UINT MIB_MaxConnections[]               = { 1, 14, 0 };
UINT MIB_ConnectionAttempts[]           = { 1, 15, 0 };
UINT MIB_LogonAttempts[]                = { 1, 16, 0 };


//
//  Private prototypes.
//

UINT
MIB_leaf_func(
    UINT                 Action,
    MIB_ENTRY          * MibPtr,
    RFC1157VarBind     * VarBind,
    LPVOID               Statistics
    );


UINT
MIB_Stat(
    UINT                 Action,
    MIB_ENTRY          * MibPtr,
    RFC1157VarBind     * VarBind,
    LPVOID               Statistics
    );

UINT
GetNextVar(
    RFC1157VarBind     * VarBind,
    MIB_ENTRY          * MibPtr,
    LPVOID               Statistics
    );


//
//  MIB definiton
//

MIB_ENTRY Mib[] =
    {
        //
        //  Statistics.
        //

        MIB_ENTRY_HEADER( MIB_Statistics ),
        MIB_COUNTER( MIB_TotalBytesSent_HighWord,     TotalBytesSent.HighPart ),
        MIB_COUNTER( MIB_TotalBytesSent_LowWord,      TotalBytesSent.LowPart ),
        MIB_COUNTER( MIB_TotalBytesReceived_HighWord, TotalBytesReceived.HighPart ),
        MIB_COUNTER( MIB_TotalBytesReceived_LowWord,  TotalBytesReceived.LowPart ),
        MIB_COUNTER( MIB_TotalFilesSent,              TotalFilesSent ),
        MIB_COUNTER( MIB_TotalFilesReceived,          TotalFilesReceived ),
        MIB_INTEGER( MIB_CurrentAnonymousUsers,       CurrentAnonymousUsers ),
        MIB_INTEGER( MIB_CurrentNonAnonymousUsers,    CurrentNonAnonymousUsers ),
        MIB_COUNTER( MIB_TotalAnonymousUsers,         TotalAnonymousUsers ),
        MIB_COUNTER( MIB_TotalNonAnonymousUsers,      TotalNonAnonymousUsers ),
        MIB_COUNTER( MIB_MaxAnonymousUsers,           MaxAnonymousUsers ),
        MIB_COUNTER( MIB_MaxNonAnonymousUsers,        MaxNonAnonymousUsers ),
        MIB_INTEGER( MIB_CurrentConnections,          CurrentConnections ),
        MIB_COUNTER( MIB_MaxConnections,              MaxConnections ),
        MIB_COUNTER( MIB_ConnectionAttempts,          ConnectionAttempts ),
        MIB_COUNTER( MIB_LogonAttempts,               LogonAttempts )
    };

#define NUM_MIB_ENTRIES ( sizeof(Mib) / sizeof(MIB_ENTRY) )


//
//  Public functions.
//

UINT
ResolveVarBind(
    RFC1157VarBind     * VarBind,
    UINT                 PduAction,
    LPVOID               Statistics
    )
//
// ResolveVarBind
//    Resolves a single variable binding.  Modifies the variable on a GET
//    or a GET-NEXT.
//
// Notes:
//
// Return Codes:
//    Standard PDU error codes.
//
// Error Codes:
//    None.
//
{
    MIB_ENTRY            *MibPtr;
    AsnObjectIdentifier  TempOid;
    int                  CompResult;
    UINT                 i;
    UINT                 nResult;
    DWORD TableIndex;
    BOOL  fTableMatch = FALSE;

    //
    //  Search for a varbind name in the MIB.
    //

    MibPtr = NULL;

    for( i = 0 ; i < NUM_MIB_ENTRIES ; i++ )
    {
        //
        //  Create a fully qualified OID for the current item in the MIB.
        //

        SNMP_oidcpy( &TempOid, &MIB_OidPrefix );
        SNMP_oidappend( &TempOid, &Mib[i].Oid );

        //
        //  See if the given OID is in the MIB.
        //

        CompResult = SNMP_oidcmp( &VarBind->name, &TempOid );
        SNMP_oidfree( &TempOid );

        //
        //  If result is negative, only valid operation is GET-NEXT.
        //

        if( CompResult < 0 )
        {
            //
            //  This could be the OID of a leaf (without a trailing 0) or
            //  it could be an invalid OID (between two valid OIDs).
            //

            if( PduAction == MIB_GETNEXT )
            {
                MibPtr = &Mib[i];

                SNMP_oidfree( &VarBind->name );
                SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
                SNMP_oidappend( &VarBind->name, &MibPtr->Oid );

                if( ( MibPtr->Type != ASN_RFC1155_OPAQUE ) &&
                    ( MibPtr->Type != ASN_SEQUENCE ) )
                {
                    PduAction = MIB_GET;
                }
            }
            else
            {
                nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
                goto Exit;
            }

            break;
        }
        else
        if( CompResult == 0 )
        {
            //
            //  Found one!
            //

            MibPtr = &Mib[i];
            break;
        }
    }

    if( i < NUM_MIB_ENTRIES )
    {
        //
        //  The associated function pointer will be NULL only if the
        //  match was with a group OID.
        //

        if( MibPtr->MibFunc == NULL )
        {
            if( PduAction == MIB_GETNEXT )
            {
                nResult = GetNextVar( VarBind, MibPtr, Statistics );
            }
            else
            {
                nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
            }

            goto Exit;
        }
    }
    else
    {
        nResult = SNMP_ERRORSTATUS_NOSUCHNAME;
        goto Exit;
    }

    //
    //  Call the associated function to process the request.
    //

    nResult = (MibPtr->MibFunc)( PduAction, MibPtr, VarBind, Statistics );

Exit:

    return nResult;

}   // ResolveVarBind


//
//  Private functions.
//

//
//  MIB_leaf_func
//      Performs generic actions on LEAF variables in the MIB.
//
//  Notes:
//
//  Return Codes:
//      Standard PDU error codes.
//
//  Error Codes:
//      None.
//
UINT
MIB_leaf_func(
    UINT                 Action,
    MIB_ENTRY          * MibPtr,
    RFC1157VarBind     * VarBind,
    LPVOID               Statistics
    )
{
    UINT  Result;
    DWORD Value;

    switch( Action )
    {
    case MIB_GETNEXT :
        //
        //  Determine if we're at the end of our MIB.
        //

        if( ( MibPtr - Mib ) >= NUM_MIB_ENTRIES )
        {
            Result = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
        }

        Result = GetNextVar( VarBind, MibPtr, Statistics );

        if (Result != SNMP_ERRORSTATUS_NOERROR)
        {
            goto Exit;
        }
        break;

    case MIB_GETFIRST :
    case MIB_GET :

        //
        //  Make sure that this variable's ACCESS is GET'able.
        //

        if( ( MibPtr->Access != MIB_ACCESS_READ ) &&
            ( MibPtr->Access != MIB_ACCESS_READWRITE ) )
        {
            Result = SNMP_ERRORSTATUS_NOSUCHNAME;
            goto Exit;
        }

        //
        //  Setup varbind's return value.
        //

        VarBind->value.asnType = MibPtr->Type;

        Value = *(LPDWORD)( (LPBYTE)Statistics + MibPtr->FieldOffset );

        switch( VarBind->value.asnType )
        {
        case ASN_RFC1155_COUNTER:
            VarBind->value.asnValue.number = (AsnCounter)Value;
            break;

        case ASN_RFC1155_GAUGE:
        case ASN_INTEGER:
            VarBind->value.asnValue.number = (AsnInteger)Value;
            break;

        case ASN_RFC1155_IPADDRESS:
        case ASN_OCTETSTRING:
            //
            //  Not supported for this MIB (yet).
            //

            Result = SNMP_ERRORSTATUS_GENERR;
            goto Exit;

        default:
            Result = SNMP_ERRORSTATUS_GENERR;
            goto Exit;
        }
        break;

    case MIB_SET:

        //
        //  We don't support settable variables (yet).
        //

        Result = SNMP_ERRORSTATUS_NOSUCHNAME;
        goto Exit;

    default:
        Result = SNMP_ERRORSTATUS_GENERR;
        goto Exit;
    }

    Result = SNMP_ERRORSTATUS_NOERROR;

Exit:

    return Result;

}   // MIB_leaf_func

//
//  MIB_Stat
//      Performs specific actions on the different MIB variable.
//
//  Notes:
//
//  Return Codes:
//      Standard PDU error codes.
//
//  Error Codes:
//      None.
//
UINT
MIB_Stat(
    UINT                 Action,
    MIB_ENTRY          * MibPtr,
    RFC1157VarBind     * VarBind,
    LPVOID               Statistics
    )
{
    UINT Result;

    switch( Action )
    {
    case MIB_SET :
    case MIB_GETNEXT :
        Result = MIB_leaf_func( Action, MibPtr, VarBind, Statistics );
        break;

    case MIB_GETFIRST :
    case MIB_GET :
        //
        //  If we have no statistics structure, bail.
        //

        if( Statistics == NULL )
        {
            Result = SNMP_ERRORSTATUS_GENERR;
            break;
        }

        //
        //  If there's no field offset associated with the current
        //  entry, also bail.
        //

        if( MibPtr->FieldOffset == -1 )
        {
            Result = SNMP_ERRORSTATUS_GENERR;
            break;
        }

        //
        //  Call the generic leaf function to perform the action.
        //

        Result = MIB_leaf_func( Action, MibPtr, VarBind, Statistics );
        break;

    default :
        Result = SNMP_ERRORSTATUS_GENERR;
        break;
    }

    return Result;

}   // MIB_Stat

UINT
GetNextVar(
    RFC1157VarBind     * VarBind,
    MIB_ENTRY          * MibPtr,
    LPVOID               Statistics
    )
{
    UINT Result;
    INT  i;

    //
    //  Calculate the current index within the MIB array.
    //

    i = DIFF( MibPtr - Mib );

    //
    //  Validate we have a reasonable value.
    //

    if( ( i < 0 ) || ( i >= NUM_MIB_ENTRIES ) )
    {
        return SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    //
    //  Scan through the remaining MIB entries.
    //

    for( i++ ; i < NUM_MIB_ENTRIES ; i++ )
    {
        MIB_ENTRY * NextMib;

        NextMib = &Mib[i];

        //
        //  Setup varbind name of next MIB variable.
        //

        SNMP_oidfree( &VarBind->name );
        SNMP_oidcpy( &VarBind->name, &MIB_OidPrefix );
        SNMP_oidappend( &VarBind->name, &NextMib->Oid );

        //
        //  If the function pointer is not NULL and the type of the MIB
        //  variable is anything but OPAQUE, then call the function to
        //  process the MIB variable.
        //

        if( ( NextMib->MibFunc != NULL ) &&
            ( NextMib->Type != ASN_RFC1155_OPAQUE ) )
        {
            Result = (NextMib->MibFunc)( MIB_GETFIRST,
                                         NextMib,
                                         VarBind,
                                         Statistics );
            break;
        }
    }

    if( i >= NUM_MIB_ENTRIES )
    {
        Result = SNMP_ERRORSTATUS_NOSUCHNAME;
    }

    return Result;

}   // GetNextVar
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\perfmon\ftpctrs.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpctrs.h

    Offset definitions for the FTP Server's counter objects & counters.

    These offsets *must* start at 0 and be multiples of 2.  In the
    FtpOpenPerformanceData procecedure, they will be added to the
    FTP Server's "First Counter" and "First Help" values in order to
    determine the absolute location of the counter & object names
    and corresponding help text in the registry.

    This file is used by the FTPCTRS.DLL DLL code as well as the
    FTPCTRS.INI definition file.  FTPCTRS.INI is parsed by the
    LODCTR utility to load the object & counter names into the
    registry.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.
        KestutiP    15-May-1999 Added uptime counter

*/


#ifndef _FTPCTRS_H_
#define _FTPCTRS_H_


//
//  The FTP Server counter object.
//

#define FTPD_COUNTER_OBJECT                     0


//
//  The individual counters.
//

#define FTPD_BYTES_SENT_COUNTER                 2
#define FTPD_BYTES_RECEIVED_COUNTER             4
#define FTPD_BYTES_TOTAL_COUNTER                6
#define FTPD_FILES_SENT_COUNTER                 8
#define FTPD_FILES_RECEIVED_COUNTER             10
#define FTPD_FILES_TOTAL_COUNTER                12
#define FTPD_CURRENT_ANONYMOUS_COUNTER          14
#define FTPD_CURRENT_NONANONYMOUS_COUNTER       16
#define FTPD_TOTAL_ANONYMOUS_COUNTER            18
#define FTPD_TOTAL_NONANONYMOUS_COUNTER         20
#define FTPD_MAX_ANONYMOUS_COUNTER              22
#define FTPD_MAX_NONANONYMOUS_COUNTER           24
#define FTPD_CURRENT_CONNECTIONS_COUNTER        26
#define FTPD_MAX_CONNECTIONS_COUNTER            28
#define FTPD_CONNECTION_ATTEMPTS_COUNTER        30
#define FTPD_LOGON_ATTEMPTS_COUNTER             32
#define FTPD_SERVICE_UPTIME_COUNTER             34

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
#define FTPD_TOTAL_ALLOWED_REQUESTS_COUNTER     34
#define FTPD_TOTAL_REJECTED_REQUESTS_COUNTER    36
#define FTPD_TOTAL_BLOCKED_REQUESTS_COUNTER     38
#define FTPD_CURRENT_BLOCKED_REQUESTS_COUNTER   40
#define FTPD_MEASURED_BANDWIDTH_COUNTER         42
*/
#endif  // _FTPCTRS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\mib\mib.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    mib.h

Abstract:

    SNMP Extension Agent for Windows NT.

Created:

    18-Feb-1995

Revision History:

--*/

#ifndef _MIB_H_
#define _MIB_H_


//
//  Required include files.
//

#include <windows.h>
#include <snmp.h>

#include <lm.h>
#include <iisinfo.h>
#include <iis64.h>


//
//  MIB Specifics.
//

#define MIB_PREFIX_LEN            MIB_OidPrefix.idLength


//
//  MIB function actions.
//

#define MIB_GET         ASN_RFC1157_GETREQUEST
#define MIB_SET         ASN_RFC1157_SETREQUEST
#define MIB_GETNEXT     ASN_RFC1157_GETNEXTREQUEST
#define MIB_GETFIRST    (ASN_PRIVATE | ASN_CONSTRUCTOR | 0x0)


//
//  MIB Variable access privileges.
//

#define MIB_ACCESS_READ        0
#define MIB_ACCESS_WRITE       1
#define MIB_ACCESS_READWRITE   2
#define MIB_NOACCESS           3


//
//  Macro to determine number of sub-oid's in array.
//

#define OID_SIZEOF( Oid )      ( sizeof Oid / sizeof(UINT) )


//
//  Prefix to every variable in the MIB.
//

extern AsnObjectIdentifier MIB_OidPrefix;


//
//  Function Prototypes.
//

UINT
ResolveVarBind(
    RFC1157VarBind     * VarBind,
    UINT                 PduAction,
    LPVOID               Statistics
    );

#endif  // _MIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\mib\main.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    main.c

Abstract:

    SNMP Extension Agent for Windows NT.

Created:

    18-Feb-1995

Revision History:

    Murali R. Krishnan (MuraliK) 16-Nov-1995  Removed undoc apis

--*/

#include "mib.h"
#include "apiutil.h"


//
//  Extension Agent DLLs need access to elapsed time agent has been active.
//  This is implemented by initializing the Extension Agent with a time zero
//  reference, and allowing the agent to compute elapsed time by subtracting
//  the time zero reference from the current system time.  This example
//  Extension Agent implements this reference with dwTimeZero.
//

DWORD dwTimeZero = 0;


//
//  Extension Agent DLLs provide the following entry point to coordinate the
//  initializations of the Extension Agent and the Extendible Agent.  The
//  Extendible Agent provides the Extension Agent with a time zero reference;
//  and the Extension Agent provides the Extendible Agent with an Event handle
//  for communicating occurence of traps, and an object identifier representing
//  the root of the MIB subtree that the Extension Agent supports.
//

BOOL
SnmpExtensionInit(
    DWORD                 dwTimeZeroReference,
    HANDLE              * hPollForTrapEvent,
    AsnObjectIdentifier * supportedView
    )
{
    //
    //  Record the time reference provided by the Extendible Agent.
    //

    dwTimeZero = dwTimeZeroReference;

    //
    //  Indicate the MIB view supported by this Extension Agent, an object
    //  identifier representing the sub root of the MIB that is supported.
    //

    *supportedView = MIB_OidPrefix; // NOTE!  structure copy

    //
    //  Indicate that Extension Agent initialization was sucessfull.
    //

    return TRUE;

}   // SnmpExtensionInit

//
//  Extension Agent DLLs provide the following entry point to communcate traps
//  to the Extendible Agent.  The Extendible Agent will query this entry point
//  when the trap Event (supplied at initialization time) is asserted, which
//  indicates that zero or more traps may have occured.  The Extendible Agent
//  will repetedly call this entry point until FALSE is returned, indicating
//  that all outstanding traps have been processed.
//

BOOL
SnmpExtensionTrap(
    AsnObjectIdentifier * enterprise,
    AsnInteger          * genericTrap,
    AsnInteger          * specificTrap,
    AsnTimeticks        * timeStamp,
    RFC1157VarBindList  * variableBindings
    )
{
    //
    //  We don't support traps (yet).
    //

    return FALSE;

}   // SnmpExtensionTrap

//
//  Extension Agent DLLs provide the following entry point to resolve queries
//  for MIB variables in their supported MIB view (supplied at initialization
//  time).  The requestType is Get/GetNext/Set.
//

BOOL
SnmpExtensionQuery(
    BYTE                 requestType,
    RFC1157VarBindList * variableBindings,
    AsnInteger         * errorStatus,
    AsnInteger         * errorIndex
    )
{
    LPFTP_STATISTICS_0 Statistics = NULL;
    NET_API_STATUS     Status;
    UINT               i;

    //
    //  Try to query the statistics now so we'll have a consitent
    //  view across all variable bindings.
    //

    Status = FtpQueryStatistics2( NULL,                    // pszServer
                                  0,                       // Level,
                                  INET_INSTANCE_GLOBAL,
                                  0,
                                  (LPBYTE *)&Statistics );

    try
    {
        //
        //  Iterate through the variable bindings list to resolve individual
        //  variable bindings.
        //

        for( i = 0 ; i < variableBindings->len ; i++ )
        {
            *errorStatus = ResolveVarBind( &variableBindings->list[i],
                                           requestType,
                                           Statistics );

            //
            //  Test and handle case where Get Next past end of MIB view
            //  supported by this Extension Agent occurs.  Special
            //  processing is required to communicate this situation to
            //  the Extendible Agent so it can take appropriate action,
            //  possibly querying other Extension Agents.
            //

            if( ( *errorStatus == SNMP_ERRORSTATUS_NOSUCHNAME ) &&
                ( requestType == MIB_GETNEXT ) )
            {
                *errorStatus = SNMP_ERRORSTATUS_NOERROR;

                //
                //  Modify variable binding of such variables so the OID
                //  points just outside the MIB view supported by this
                //  Extension Agent.  The Extendible Agent tests for this,
                //  and takes appropriate action.
                //

               SNMP_oidfree( &variableBindings->list[i].name );
               SNMP_oidcpy( &variableBindings->list[i].name, &MIB_OidPrefix );
               variableBindings->list[i].name.ids[MIB_PREFIX_LEN-1]++;
            }

            //
            //  If an error was indicated, communicate error status and error
            //  index to the Extendible Agent.  The Extendible Agent will
            //  ensure that the origional variable bindings are returned in
            //  the response packet.

            if( *errorStatus != SNMP_ERRORSTATUS_NOERROR )
            {
                *errorIndex = i+1;
            }
            else
            {
                *errorIndex = 0;
            }
        }
    }
    except( EXCEPTION_EXECUTE_HANDLER )
    {
        //
        //  For now do nothing.
        //
    }

    //
    //  Free the statistics structure if we managed to actually get one.
    //

    if( Statistics != NULL )
    {
        MIDL_user_free( (LPVOID)Statistics );
    }

    return SNMPAPI_NOERROR;

}   // SnmpExtensionQuery
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\perfmon\ftpdata.c ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpdata.c

    Constant data structures for the FTP Server's counter objects &
    counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#include <windows.h>
#include <winperf.h>
#include <ftpctrs.h>
#include <ftpdata.h>


//
//  Initialize the constant portitions of these data structure.
//  Certain parts (especially the name/help indices) will be
//  updated at initialization time.
//

FTPD_DATA_DEFINITION FtpdDataDefinition =
{
    {   // FtpdObjectType
        sizeof(FTPD_DATA_DEFINITION) + sizeof( FTPD_COUNTER_BLOCK) ,
        sizeof(FTPD_DATA_DEFINITION),
        sizeof(PERF_OBJECT_TYPE),
        FTPD_COUNTER_OBJECT,
        0,
        FTPD_COUNTER_OBJECT,
        0,
        PERF_DETAIL_ADVANCED,
        NUMBER_OF_FTPD_COUNTERS,
        2,                              // Default = Bytes Total/sec
        PERF_NO_INSTANCES,
        0,
        { 0, 0 },
        { 0, 0 }
    },

    {   // FtpdBytesSent
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_BYTES_SENT_COUNTER,
        0,
        FTPD_BYTES_SENT_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        0
    },

    {   // FtpdBytesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_BYTES_RECEIVED_COUNTER,
        0,
        FTPD_BYTES_RECEIVED_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        0
    },

    {   // FtpdBytesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_BYTES_TOTAL_COUNTER,
        0,
        FTPD_BYTES_TOTAL_COUNTER,
        0,
        -4,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_BULK_COUNT,
        sizeof(LARGE_INTEGER),
        0
    },

    {   // FtpdFilesSent
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_FILES_SENT_COUNTER,
        0,
        FTPD_FILES_SENT_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FtpdFilesReceived
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_FILES_RECEIVED_COUNTER,
        0,
        FTPD_FILES_RECEIVED_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FtpdFilesTotal
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_FILES_TOTAL_COUNTER,
        0,
        FTPD_FILES_TOTAL_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdCurrentAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CURRENT_ANONYMOUS_COUNTER,
        0,
        FTPD_CURRENT_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdCurrentNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CURRENT_NONANONYMOUS_COUNTER,
        0,
        FTPD_CURRENT_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdTotalAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_ANONYMOUS_COUNTER,
        0,
        FTPD_TOTAL_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdTotalNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_NONANONYMOUS_COUNTER,
        0,
        FTPD_TOTAL_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdMaxAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_MAX_ANONYMOUS_COUNTER,
        0,
        FTPD_MAX_ANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdMaxNonAnonymous
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_MAX_NONANONYMOUS_COUNTER,
        0,
        FTPD_MAX_NONANONYMOUS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdCurrentConnections
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CURRENT_CONNECTIONS_COUNTER,
        0,
        FTPD_CURRENT_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdMaxConnections
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_MAX_CONNECTIONS_COUNTER,
        0,
        FTPD_MAX_CONNECTIONS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdConnectionAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CONNECTION_ATTEMPTS_COUNTER,
        0,
        FTPD_CONNECTION_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdLogonAttempts
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_LOGON_ATTEMPTS_COUNTER,
        0,
        FTPD_LOGON_ATTEMPTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdServiceUptime
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_SERVICE_UPTIME_COUNTER,
        0,
        FTPD_SERVICE_UPTIME_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    {   // FtpdTotalAllowedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_ALLOWED_REQUESTS_COUNTER,
        0,
        FTPD_TOTAL_ALLOWED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FtpdTotalRejectedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_REJECTED_REQUESTS_COUNTER,
        0,
        FTPD_TOTAL_REJECTED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FtpdTotalBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_TOTAL_BLOCKED_REQUESTS_COUNTER,
        0,
        FTPD_TOTAL_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdCurrentBlockedRequests
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        FTPD_CURRENT_BLOCKED_REQUESTS_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },

    {   // FptdMeasuredBandwidth
        sizeof(PERF_COUNTER_DEFINITION),
        FTPD_MEASURED_BANDWIDTH_COUNTER,
        0,
        FTPD_MEASURED_BANDWIDTH_COUNTER,
        0,
        0,
        PERF_DETAIL_ADVANCED,
        PERF_COUNTER_RAWCOUNT,
        sizeof(DWORD),
        0
    },
*/
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\perfmon\makefile.inc ===
MY_BINPLACE = -binplace -P $(BINPLACE_PLACEFILE)

copyini:
    $(MY_BINPLACE) ftpctrs.ini
    $(MY_BINPLACE) ftpctrs.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\perfmon\perfftp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    perfftp.cxx

    This file implements the Extensible Performance Objects for
    the FTP Server service.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created, based on RussBl's sample code.

        MuraliK     16-Nov-1995 Modified dependencies and removed NetApi
        SophiaC     06-Nov-1996 Supported mutlitiple instances
*/

#define INITGUID

#include <windows.h>
#include <winperf.h>
#include <lm.h>
#include <string.h>
#include <stdlib.h>
#include <ole2.h>

#include "iis64.h"
#include "dbgutil.h"
#include "iisinfo.h"
#include "ftpd.h"
#include "ftpctrs.h"
#include "ftpmsg.h"
#include "iadm.h"

extern "C" {
#include "perfutil.h"
#include "apiutil.h"
#include "ftpdata.h"
} // extern "C"

#define APP_NAME                     (TEXT("FTPCtrs"))
#define MAX_SIZEOF_INSTANCE_NAME     METADATA_MAX_NAME_LEN
#define TOTAL_INSTANCE_NAME          L"_Total"

//
//  Private globals.
//

DWORD   cOpens    = 0;                  // Active "opens" reference count.
BOOL    fInitOK   = FALSE;              // TRUE if DLL initialized OK.

HANDLE  hEventLog = NULL;               // event log handle

//
//  Public prototypes.
//

PM_OPEN_PROC    OpenFtpPerformanceData;
PM_COLLECT_PROC CollectFtpPerformanceData;
PM_CLOSE_PROC   CloseFtpPerformanceData;

//
//  Private prototypes.
//
VOID
CopyStatisticsData(
    IN FTP_STATISTICS_0         * pFTPStats,
    OUT FTPD_COUNTER_BLOCK      * pCounterBlock
    );

VOID
Update_TotalStatisticsData(
    IN FTPD_COUNTER_BLOCK       * pCounterBlock,
    OUT FTPD_COUNTER_BLOCK      * pTotal
    );

//
//  Public functions.
//

/*******************************************************************

    NAME:       OpenFtpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate
                performance counters with the registry.

    ENTRY:      lpDeviceNames - Poitner to object ID of each device
                    to be opened.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD OpenFtpPerformanceData( LPWSTR lpDeviceNames )
{
    DWORD err  = NO_ERROR;
    HKEY  hkey = NULL;
    DWORD size;
    DWORD type;
    DWORD dwFirstCounter;
    DWORD dwFirstHelp;
    PERF_COUNTER_DEFINITION * pctr;
    FTPD_COUNTER_BLOCK        ftpc;
    DWORD                     i;

    //
    //  Since WINLOGON is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). The registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem.
    //

    if( !fInitOK )
    {

        //
        //  This is the *first* open.
        //

        // open event log interface

        if (hEventLog == NULL){
            hEventLog = RegisterEventSource ((LPTSTR)NULL,            // Use Local Machine
                                             APP_NAME);               // event log app name to find in registry
            if (hEventLog == NULL)
            {
                return GetLastError();
            }
        }

        //
        //  Open the FTP Server service's Performance key.
        //

        err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            FTPD_PERFORMANCE_KEY,
                            0,
                            KEY_READ,
                            &hkey );

        if( err == NO_ERROR )
        {
            //
            //  Read the first counter DWORD.
            //

            size = sizeof(DWORD);

            err = RegQueryValueEx( hkey,
                                   "First Counter",
                                   NULL,
                                   &type,
                                   (LPBYTE)&dwFirstCounter,
                                   &size );
            if( err == NO_ERROR )
            {
                //
                //  Read the first help DWORD.
                //

                size = sizeof(DWORD);

                err = RegQueryValueEx( hkey,
                                    "First Help",
                                    NULL,
                                    &type,
                                    (LPBYTE)&dwFirstHelp,
                                    &size );

                if ( err == NO_ERROR )
                {
                    //
                    //  Update the object & counter name & help indicies.
                    //

                    FtpdDataDefinition.FtpdObjectType.ObjectNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdObjectType.ObjectHelpTitleIndex
                        += dwFirstHelp;

                    FtpdDataDefinition.FtpdBytesSent.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdBytesSent.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdBytesSent.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.BytesSent - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdBytesReceived.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdBytesReceived.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdBytesReceived.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.BytesReceived - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdBytesTotal.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdBytesTotal.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdBytesTotal.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.BytesTotal - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdFilesSent.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdFilesSent.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdFilesSent.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.FilesSent - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdFilesReceived.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdFilesReceived.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdFilesReceived.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.FilesReceived - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdFilesTotal.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdFilesTotal.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdFilesTotal.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.FilesTotal - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdCurrentAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdCurrentAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdCurrentAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.CurrentAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdCurrentNonAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdCurrentNonAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdCurrentNonAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.CurrentNonAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdTotalAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdTotalAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdTotalAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.TotalAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdTotalNonAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdTotalNonAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdTotalNonAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.TotalNonAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdMaxAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdMaxAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdMaxAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.MaxAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdMaxNonAnonymous.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdMaxNonAnonymous.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdMaxNonAnonymous.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.MaxNonAnonymous - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdCurrentConnections.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdCurrentConnections.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdCurrentConnections.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.CurrentConnections - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdMaxConnections.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdMaxConnections.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdMaxConnections.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.MaxConnections - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdConnectionAttempts.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdConnectionAttempts.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdConnectionAttempts.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.ConnectionAttempts - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdLogonAttempts.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdLogonAttempts.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdLogonAttempts.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.LogonAttempts - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdServiceUptime.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdServiceUptime.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdServiceUptime.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.ServiceUptime - (LPBYTE)&ftpc);

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
                    FtpdDataDefinition.FtpdBlockedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdBlockedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdBlockedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.BlockedRequests - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdAllowedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdAllowedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdAllowedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.AllowedRequests - (LPBYTE)&ftpc);


                    FtpdDataDefinition.FtpdRejectedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdRejectedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdRejectedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.RejectedRequests - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdCurrentBlockedRequests.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdCurrentBlockedRequests.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdCurrentBlockedRequests.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.CurrentBlockedRequests - (LPBYTE)&ftpc);

                    FtpdDataDefinition.FtpdMeasuredBandwidth.CounterNameTitleIndex
                        += dwFirstCounter;
                    FtpdDataDefinition.FtpdMeasuredBandwidth.CounterHelpTitleIndex
                        += dwFirstHelp;
                    FtpdDataDefinition.FtpdMeasuredBandwidth.CounterOffset =
                        (DWORD)((LPBYTE)&ftpc.MeasuredBandwidth - (LPBYTE)&ftpc);

*/

                    //
                    //  Remember that we initialized OK.
                    //

                    fInitOK = TRUE;
                } else {
                    ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                                 0, FTP_UNABLE_QUERY_DATA,
                                 (PSID)NULL, 0,
                                 sizeof(err), NULL,
                                 (PVOID)(&err));
                }
            } else {
                ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                             0, FTP_UNABLE_QUERY_DATA,
                             (PSID)NULL, 0,
                             sizeof(err), NULL,
                             (PVOID)(&err));
            }

            //
            //  Close the registry if we managed to actually open it.
            //

            if( hkey != NULL )
            {
                RegCloseKey( hkey );
                hkey = NULL;
            }
        } else {
            ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                         0, FTP_UNABLE_QUERY_DATA,
                         (PSID)NULL, 0,
                         sizeof(err), NULL,
                         (PVOID)(&err));
        }
    }

    //
    //  Bump open counter.
    //

    InterlockedIncrement((LPLONG )&cOpens);

    return err;

}   // OpenFTPPerformanceData

/*******************************************************************

    NAME:       CollectFtpPerformanceData

    SYNOPSIS:   Initializes the data structures used to communicate

    ENTRY:      lpValueName - The name of the value to retrieve.

                lppData - On entry contains a pointer to the buffer to
                    receive the completed PerfDataBlock & subordinate
                    structures.  On exit, points to the first bytes
                    *after* the data structures added by this routine.

                lpcbTotalBytes - On entry contains a pointer to the
                    size (in BYTEs) of the buffer referenced by lppData.
                    On exit, contains the number of BYTEs added by this
                    routine.

                lpNumObjectTypes - Receives the number of objects added
                    by this routine.

    RETURNS:    DWORD - Win32 status code.  MUST be either NO_ERROR
                    or ERROR_MORE_DATA.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CollectFtpPerformanceData( LPWSTR    lpValueName,
                                 LPVOID  * lppData,
                                 LPDWORD   lpcbTotalBytes,
                                 LPDWORD   lpNumObjectTypes )
{
    PERF_INSTANCE_DEFINITION * pPerfInstanceDefinition;
    DWORD                   dwInstanceIndex = 0;
    DWORD                   dwInstanceCount = 0;
    DWORD                   i = 0;
    DWORD                   dwQueryType;
    ULONG                   cbRequired;
    DWORD                   * pdwCounter;
    LARGE_INTEGER           * pliCounter;
    FTPD_COUNTER_BLOCK      * pCounterBlock;
    FTPD_COUNTER_BLOCK      * pTotal;
    FTPD_DATA_DEFINITION    * pFtpdDataDefinition;
    FTP_STATISTICS_0        * pFTPStats;
    NET_API_STATUS          neterr;
    HRESULT                 hresErr;
    DWORD                   dwBufferSize = 0;

    LPINET_INFO_SITE_LIST   pSites;


    //
    //  No need to even try if we failed to open...
    //

    if( !fInitOK )
    {

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        //
        //  According to the Performance Counter design, this
        //  is a successful exit.  Go figure.
        //

        return NO_ERROR;
    }

    //
    //  Determine the query type.
    //

    dwQueryType = GetQueryType( lpValueName );

    if (( dwQueryType == QUERY_FOREIGN ) || (dwQueryType == QUERY_COSTLY))
    {
        //
        //  We don't do foreign queries.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        return NO_ERROR;
    }

    if( dwQueryType == QUERY_ITEMS )
    {
        //
        //  The registry is asking for a specific object.  Let's
        //  see if we're one of the chosen.
        //

        if( !IsNumberInUnicodeList(
                        FtpdDataDefinition.FtpdObjectType.ObjectNameTitleIndex,
                        lpValueName ) )
        {
            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return NO_ERROR;
        }
    }

    //
    //  Enumerate and get total number of instances count.
    //
    pFtpdDataDefinition = (FTPD_DATA_DEFINITION *)*lppData;

    neterr = InetInfoGetSites(
                NULL,
                INET_FTP_SVC_ID,
                &pSites
                );


    if( neterr != NERR_Success )
    {

        //
        //  Only event log once for each server down
        //

        // if the server is down, we don't log an error.
		if ( !( neterr == RPC_S_SERVER_UNAVAILABLE ||
                neterr == RPC_S_UNKNOWN_IF         ||
                neterr == ERROR_SERVICE_NOT_ACTIVE ||
                neterr == RPC_S_CALL_FAILED_DNE ))
        {
            //
            //  Error retrieving statistics.
            //

            ReportEvent(hEventLog, EVENTLOG_ERROR_TYPE,
                        0, FTP_UNABLE_QUERY_DATA,
                        (PSID)NULL, 0,
                        sizeof(neterr), NULL,
                        (PVOID)(&neterr));

        }

        cbRequired = sizeof(FTPD_DATA_DEFINITION) +
                            sizeof(PERF_INSTANCE_DEFINITION) +
                            (sizeof(WCHAR) * MAX_SIZEOF_INSTANCE_NAME ) +
                            sizeof(FTPD_COUNTER_BLOCK);

        if( *lpcbTotalBytes < cbRequired )
        {
            //
            //  Nope.
            //

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            return ERROR_MORE_DATA;
        }

        // We always return the _Total instance even if the counters
        // are not accessible.  This is so we stay in sync with how the
        // other IIS counters work.  For the PERF_NO_INSTANCE counters we need
        // to do this so that WMI get's it's definition data even if the service
        // is not running, and logging doesn't get confused by a PERF_NO_INSTANCE
        // counter returning zero instances.

        // First we move in the definition.
        memmove( pFtpdDataDefinition,
                 &FtpdDataDefinition,
                 sizeof(FTPD_DATA_DEFINITION) );

        ((PERF_OBJECT_TYPE*) pFtpdDataDefinition)->NumInstances = 1;
        ((PERF_OBJECT_TYPE*) pFtpdDataDefinition)->TotalByteLength = cbRequired;

        LPVOID pData = (LPVOID) ( pFtpdDataDefinition + 1 );

        // Now we setup the PERF_INSTANCE_DEFINITION
        ((PERF_INSTANCE_DEFINITION*) pData)->ByteLength = sizeof(PERF_INSTANCE_DEFINITION) + 
                                                          MAX_SIZEOF_INSTANCE_NAME * sizeof(WCHAR);
        ((PERF_INSTANCE_DEFINITION*) pData)->ParentObjectTitleIndex = 0;
        ((PERF_INSTANCE_DEFINITION*) pData)->ParentObjectInstance = 0;
        ((PERF_INSTANCE_DEFINITION*) pData)->UniqueID = PERF_NO_UNIQUE_ID;
        ((PERF_INSTANCE_DEFINITION*) pData)->NameOffset = sizeof(PERF_INSTANCE_DEFINITION);
        ((PERF_INSTANCE_DEFINITION*) pData)->NameLength = (wcslen(TOTAL_INSTANCE_NAME) + 1) * sizeof(WCHAR);

        pData = (LPBYTE) pData + sizeof(PERF_INSTANCE_DEFINITION);

        // Next copy in the Instance Name including the 
        // NULL, we know we have enough room because of
        // the check above for size.
        wcsncpy ( (LPWSTR) pData, TOTAL_INSTANCE_NAME, wcslen(TOTAL_INSTANCE_NAME) + 1 );

        // To avoid suttle differences we use the same MAX_INSTANCE_NAME
        // amount of space even for this faked up _Total Site.
        pData = (LPBYTE) pData + ( MAX_SIZEOF_INSTANCE_NAME * sizeof(WCHAR));

        // Lastly copy in a block of zero's for the _Total site data.
        memset ( pData, 0, sizeof(FTPD_COUNTER_BLOCK) );

        // This is setting the size in the structure, it is the first
        // DWORD in the W3_CONTER_BLOCK.
        *((DWORD*) (pData)) = sizeof(FTPD_COUNTER_BLOCK);

        *lpcbTotalBytes   = cbRequired;
        *lpNumObjectTypes = 1;
        *lppData = (LPBYTE) pFtpdDataDefinition + cbRequired;

        return NO_ERROR;
    }

    //
    //  add 1 to dwInstanceCount for _Total instance
    //

    dwInstanceCount = pSites->cEntries + 1;

    //
    //  always return an "instance sized" buffer after the definition
    //  blocks to prevent perfmon from reading bogus data. This is strictly
    //  a hack to accomodate how PERFMON handles the "0" instance case.
    //  By doing this, perfmon won't choke when there are no instances
    //  and the counter object & counters will be displayed in the list
    //  boxes, even though no instances will be listed.
    //

    cbRequired = sizeof(FTPD_DATA_DEFINITION) +
                 (dwInstanceCount * (sizeof(PERF_INSTANCE_DEFINITION) +
                 MAX_SIZEOF_INSTANCE_NAME +
                 sizeof (FTPD_COUNTER_BLOCK)));

    //
    //  See if there's enough space.
    //

    if( *lpcbTotalBytes < cbRequired )
    {
        //
        //  Nope.
        //

        *lpcbTotalBytes   = 0;
        *lpNumObjectTypes = 0;

        MIDL_user_free(pSites);
        return ERROR_MORE_DATA;
    }

    //
    //  Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove( pFtpdDataDefinition,
             &FtpdDataDefinition,
             sizeof(FTPD_DATA_DEFINITION) );

    //
    //  Create data for return for each instance
    //

    pPerfInstanceDefinition = (PERF_INSTANCE_DEFINITION *)
                                  &pFtpdDataDefinition[1];

    //
    // Set first block of Buffer for _Total
    //

    MonBuildInstanceDefinition(
        pPerfInstanceDefinition,
        (PVOID *)&pCounterBlock,
        0,
        0,
        (DWORD)-1, // use name
        TOTAL_INSTANCE_NAME );   // pass in instance name

    pTotal = pCounterBlock;
    memset( pTotal, 0, sizeof(FTPD_COUNTER_BLOCK ));
    pTotal->PerfCounterBlock.ByteLength = sizeof (FTPD_COUNTER_BLOCK);
    pPerfInstanceDefinition =
        (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock +
         sizeof(FTPD_COUNTER_BLOCK));


    neterr = FtpQueryStatistics2(
                            NULL,
                            0,
                            0,  // instance id, 0 for global stats
                            0,
                            (LPBYTE *)&pFTPStats );

    if( neterr == NERR_Success )
    {
        pTotal->ServiceUptime = pFTPStats->ServiceUptime;
    }

    MIDL_user_free( pFTPStats );

    for ( i = 0; i < pSites->cEntries; i++)
    {
        MonBuildInstanceDefinition(
            pPerfInstanceDefinition,
            (PVOID *)&pCounterBlock,
            0,
            0,
            (DWORD)-1,                          // use name
            pSites->aSiteEntry[i].pszComment    // pass in instance name
            );

        //
        // query for statistics info
        //

        neterr = FtpQueryStatistics2(
                            NULL,
                            0,
                            pSites->aSiteEntry[i].dwInstance,  // instance id
                            0,
                            (LPBYTE *)&pFTPStats );

        if( neterr != NERR_Success )
        {
            //
            //  Only event log once for each server down
            //

            // if the server is down, we don't log an error.
	        if ( !( neterr == RPC_S_SERVER_UNAVAILABLE ||
                    neterr == RPC_S_UNKNOWN_IF         ||
                    neterr == ERROR_SERVICE_NOT_ACTIVE ||
                    neterr == RPC_S_CALL_FAILED_DNE ))
            {
                //
                //  Error retrieving statistics.
                //
                ReportEvent (hEventLog, EVENTLOG_ERROR_TYPE,
                    0, FTP_UNABLE_QUERY_DATA,
                    (PSID)NULL, 0,
                    sizeof(neterr), NULL,
                    (PVOID)(&neterr));
            }

            *lpcbTotalBytes   = 0;
            *lpNumObjectTypes = 0;

            MIDL_user_free(pSites);
            return NO_ERROR;
        }

        //
        //  Format the FTP Server data.
        //

        CopyStatisticsData( pFTPStats,
                            pCounterBlock );

        //
        //  update _total instance counters
        //

        Update_TotalStatisticsData( pCounterBlock,
                                    pTotal );

        pPerfInstanceDefinition =
            (PERF_INSTANCE_DEFINITION *)((LPBYTE)pCounterBlock +
             sizeof(FTPD_COUNTER_BLOCK));

        //
        //  Free the API buffer.
        //

        MIDL_user_free( pFTPStats );
    }

    if (dwInstanceCount == 1) {
        DWORD cbSize = sizeof(PERF_INSTANCE_DEFINITION) +
                           MAX_SIZEOF_INSTANCE_NAME +
                           sizeof(FTPD_COUNTER_BLOCK);

        //
        //  zero fill one instance sized block of data if there's no data
        //  instances
        //

        memset (pPerfInstanceDefinition, 0, cbSize);

        // adjust pointer to point to end of zeroed block
        pPerfInstanceDefinition += cbSize;
    }

    //
    //  Update arguments for return.
    //

    *lppData          = (PVOID)(pPerfInstanceDefinition);

    *lpNumObjectTypes = 1;

    pFtpdDataDefinition->FtpdObjectType.NumInstances = dwInstanceCount;

    pFtpdDataDefinition->FtpdObjectType.TotalByteLength =
        *lpcbTotalBytes   = DIFF((PBYTE)pPerfInstanceDefinition -
                                 (PBYTE)pFtpdDataDefinition);

    //
    //  Success!  Honest!!
    //

    MIDL_user_free(pSites);

    return NO_ERROR;

}   // CollectFTPPerformanceData

/*******************************************************************

    NAME:       CloseFtpPerformanceData

    SYNOPSIS:   Terminates the performance counters.

    RETURNS:    DWORD - Win32 status code.

    HISTORY:
        KeithMo     07-Jun-1993 Created.

********************************************************************/
DWORD CloseFtpPerformanceData( VOID )
{

    DWORD dwCount = InterlockedDecrement((LPLONG )&cOpens);

    if ((dwCount) == 0) {
        if (hEventLog != NULL)
        {
            DeregisterEventSource (hEventLog);
            hEventLog = NULL;
        };
    }

    return NO_ERROR;

}   // CloseFTPPerformanceData


VOID
CopyStatisticsData(
    IN FTP_STATISTICS_0          * pFTPStats,
    OUT FTPD_COUNTER_BLOCK       * pCounterBlock
    )
{
    //
    //  Format the FTP Server data.
    //

    pCounterBlock->PerfCounterBlock.ByteLength = sizeof (FTPD_COUNTER_BLOCK);

    pCounterBlock->BytesSent       = pFTPStats->TotalBytesSent.QuadPart;
    pCounterBlock->BytesReceived   = pFTPStats->TotalBytesReceived.QuadPart;
    pCounterBlock->BytesTotal      = pFTPStats->TotalBytesSent.QuadPart +
                                     pFTPStats->TotalBytesReceived.QuadPart;

    pCounterBlock->FilesSent        = pFTPStats->TotalFilesSent;
    pCounterBlock->FilesReceived    = pFTPStats->TotalFilesReceived;
    pCounterBlock->FilesTotal       = pFTPStats->TotalFilesSent +
                                      pFTPStats->TotalFilesReceived;

    pCounterBlock->CurrentAnonymous = pFTPStats->CurrentAnonymousUsers;
    pCounterBlock->CurrentNonAnonymous = pFTPStats->CurrentNonAnonymousUsers;

    pCounterBlock->TotalAnonymous   = pFTPStats->TotalAnonymousUsers;
    pCounterBlock->TotalNonAnonymous = pFTPStats->TotalNonAnonymousUsers;

    pCounterBlock->MaxAnonymous     = pFTPStats->MaxAnonymousUsers;
    pCounterBlock->MaxNonAnonymous  = pFTPStats->MaxNonAnonymousUsers;

    pCounterBlock->CurrentConnections = pFTPStats->CurrentConnections;
    pCounterBlock->MaxConnections   = pFTPStats->MaxConnections;
    pCounterBlock->ConnectionAttempts = pFTPStats->ConnectionAttempts;

    pCounterBlock->LogonAttempts    = pFTPStats->LogonAttempts;

    pCounterBlock->ServiceUptime    = pFTPStats->ServiceUptime;

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    pCounterBlock->BlockedRequests  = pFTPStats->TotalBlockedRequests;
    pCounterBlock->AllowedRequests  = pFTPStats->TotalAllowedRequests;
    pCounterBlock->RejectedRequests = pFTPStats->TotalRejectedRequests;
    pCounterBlock->MeasuredBandwidth= pFTPStats->MeasuredBandwidth;
    pCounterBlock->CurrentBlockedRequests = pFTPStats->CurrentBlockedRequests;
*/
}   // CopyStatisticsData


VOID
Update_TotalStatisticsData(
    IN FTPD_COUNTER_BLOCK        * pCounterBlock,
    OUT FTPD_COUNTER_BLOCK       * pTotal
    )
{
    //
    //  update _total instance counters
    //

    pTotal->BytesSent += pCounterBlock->BytesSent;
    pTotal->BytesReceived += pCounterBlock->BytesReceived;
    pTotal->BytesTotal += pCounterBlock->BytesTotal;

    pTotal->FilesSent += pCounterBlock->FilesSent;
    pTotal->FilesReceived += pCounterBlock->FilesReceived;
    pTotal->FilesTotal += pCounterBlock->FilesTotal;
    pTotal->CurrentAnonymous += pCounterBlock->CurrentAnonymous;
    pTotal->CurrentNonAnonymous += pCounterBlock->CurrentNonAnonymous;
    pTotal->TotalAnonymous += pCounterBlock->TotalAnonymous;
    pTotal->TotalNonAnonymous += pCounterBlock->TotalNonAnonymous;

    pTotal->MaxAnonymous += pCounterBlock->MaxAnonymous;
    pTotal->MaxNonAnonymous += pCounterBlock->MaxNonAnonymous;

    pTotal->CurrentConnections += pCounterBlock->CurrentConnections;
    pTotal->MaxConnections += pCounterBlock->MaxConnections;
    pTotal->ConnectionAttempts = pCounterBlock->ConnectionAttempts;

    pTotal->LogonAttempts += pCounterBlock->LogonAttempts;

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    pTotal->BlockedRequests += pCounterBlock->BlockedRequests;
    pTotal->RejectedRequests += pCounterBlock->RejectedRequests;
    pTotal->AllowedRequests += pCounterBlock->AllowedRequests;
    pTotal->MeasuredBandwidth += pCounterBlock->MeasuredBandwidth;
    pTotal->CurrentBlockedRequests += pCounterBlock->CurrentBlockedRequests;
*/

}   // Update_TotalStatisticsData
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\perfmon\ftpdata.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    ftpdata.h

    Extensible object definitions for the FTP Server's counter
    objects & counters.


    FILE HISTORY:
        KeithMo     07-Jun-1993 Created.

*/


#ifndef _FTPDATA_H_
#define _FTPDATA_H_

#pragma pack(8) 

//
//  The counter structure returned.
//

typedef struct _FTPD_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            FtpdObjectType;

    PERF_COUNTER_DEFINITION     FtpdBytesSent;
    PERF_COUNTER_DEFINITION     FtpdBytesReceived;
    PERF_COUNTER_DEFINITION     FtpdBytesTotal;

    PERF_COUNTER_DEFINITION     FtpdFilesSent;
    PERF_COUNTER_DEFINITION     FtpdFilesReceived;
    PERF_COUNTER_DEFINITION     FtpdFilesTotal;

    PERF_COUNTER_DEFINITION     FtpdCurrentAnonymous;
    PERF_COUNTER_DEFINITION     FtpdCurrentNonAnonymous;
    PERF_COUNTER_DEFINITION     FtpdTotalAnonymous;
    PERF_COUNTER_DEFINITION     FtpdTotalNonAnonymous;
    PERF_COUNTER_DEFINITION     FtpdMaxAnonymous;
    PERF_COUNTER_DEFINITION     FtpdMaxNonAnonymous;

    PERF_COUNTER_DEFINITION     FtpdCurrentConnections;
    PERF_COUNTER_DEFINITION     FtpdMaxConnections;
    PERF_COUNTER_DEFINITION     FtpdConnectionAttempts;
    PERF_COUNTER_DEFINITION     FtpdLogonAttempts;
    PERF_COUNTER_DEFINITION     FtpdServiceUptime;

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    PERF_COUNTER_DEFINITION     FtpdAllowedRequests;
    PERF_COUNTER_DEFINITION     FtpdRejectedRequests;
    PERF_COUNTER_DEFINITION     FtpdBlockedRequests;
    PERF_COUNTER_DEFINITION     FtpdCurrentBlockedRequests;
    PERF_COUNTER_DEFINITION     FtpdMeasuredBandwidth;
*/
} FTPD_DATA_DEFINITION;

typedef struct _FTPD_COUNTER_BLOCK
{
    PERF_COUNTER_BLOCK  PerfCounterBlock;
    LONGLONG            BytesSent;
    LONGLONG            BytesReceived;
    LONGLONG            BytesTotal;

    DWORD               FilesSent;
    DWORD               FilesReceived;
    DWORD               FilesTotal;

    DWORD               CurrentAnonymous;
    DWORD               CurrentNonAnonymous;
    DWORD               TotalAnonymous;
    DWORD               TotalNonAnonymous;

    DWORD               MaxAnonymous;
    DWORD               MaxNonAnonymous;
    DWORD               CurrentConnections;
    DWORD               MaxConnections;

    DWORD               ConnectionAttempts;
    DWORD               LogonAttempts;
    DWORD               ServiceUptime;

// These counters are currently meaningless, but should be restored if we
// ever enable per-FTP-instance bandwidth throttling.
/*
    DWORD               AllowedRequests;
    DWORD               RejectedRequests;
    DWORD               BlockedRequests;
    DWORD               CurrentBlockedRequests;
    DWORD               MeasuredBandwidth;
*/
} FTPD_COUNTER_BLOCK;


//
//  The routines that load these structures assume that all fields
//  are DWORD packed & aligned.
//

extern  FTPD_DATA_DEFINITION    FtpdDataDefinition;

#define NUMBER_OF_FTPD_COUNTERS ((sizeof(FTPD_DATA_DEFINITION) -        \
                                  sizeof(PERF_OBJECT_TYPE)) /           \
                                  sizeof(PERF_COUNTER_DEFINITION))


//
//  Restore default packing & alignment.
//

#pragma pack()

#endif  // _FTPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\adio.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 2001                **/
/**********************************************************************/

/*
    adio.cxx

    This module manages access to Active Directory.

    Functions exported by this module:


    FILE HISTORY:
        RobSol      17-May-2001 Created.
*/

#include <ftpdp.hxx>

# include <mbstring.h>

//--------------------------------------------------------------------------------------------
// LdapCacheItem globals/statics
//--------------------------------------------------------------------------------------------

//
// number of retries to find a DC
//
const ULONG GetDcNameMaxRetries = 2;

//--------------------------------------------------------------------------------------------
// ADIO_ASYNC globals/statics
//--------------------------------------------------------------------------------------------

//
// Time to sleep (in msec) when no request is ready before re-checking
// If the async work list is empty, or no request is ready, this is the time
// we sleep before re-examining the list.
//
const ULONG AsyncPollXval = 1000;

//
// constants for managing the async request object cache
//
const LONG AsyncMaxFreeReqRate = 50;    // start freeing when this percent of free req objects
const LONG AsyncMinFreeReqRate = 10;    // stop freeing when this percent of free objects
const LONG AsyncMinFreeReqObjs = 10;    // leave at least this number of free objs

//
// FTP related attributes stored in AD for user objects
//
const PSTR pszFtpRoot = "msIIS-FTPRoot";
const PSTR pszFtpDir  = "msIIS-FTPDir";
static PSTR aszRetAttribs[] = { pszFtpRoot, pszFtpDir, NULL };

//
// format string to construct a query
//
const PCHAR pszQueryFormatString = "(&(objectClass=user)(samAccountName=%s))";


//------------------------------------------------------------------------------------------
//
// implementation of the LdapCacheItem Class methods
//
//------------------------------------------------------------------------------------------

/*++
    class constructor. Initializes the LDAP connection and binds to the server
    uses ldap_bind_s, a synchronous call, as the asynchronous call is limited in
    taking authentication parameters and will only perform clear text authentication


    Arguments:

        DomainName   the domain name for which the LDAP connection is made. We search for
                     and connect to a DC servicing this domain name

        strUser      name of user to authenticate with active directory

        strDomain    domain of user to authenticate with active directory

        strPassword  password of user to authenticate with active directory


    Returns:

        SetLastError() to indicate success/failure
--*/

LdapCacheItem::LdapCacheItem(
            const STR & DomainName,
            const STR & strUser,
            const STR & strDomain,
            const STR & strPassword) :
    m_ldapConnection( NULL),
    m_RefCount( 1)
{
    ULONG                     err;
    ULONG                     ulOptVal;
    SEC_WINNT_AUTH_IDENTITY   sSecIdent;
    DWORD                     fDsGetDcName = DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME;
    DWORD                     dwDsGetDcNameRetriesLeft = GetDcNameMaxRetries;
    PDOMAIN_CONTROLLER_INFO   pDCInfo;
    STACK_STR                 (localPassword, PWLEN+1);


    //
    // store the domain name
    //

    m_strDomainName.Copy( DomainName );


    do {
        //
        // locate a DC for the domain of interest
        //


        err = pfn_DsGetDcName(
                        NULL,
                        m_strDomainName.QueryStr(),
                        NULL,
                        NULL,
                        fDsGetDcName,
                        &pDCInfo);

        if (err != NO_ERROR) {
            DBGPRINTF((DBG_CONTEXT, "DsGetDcName() failed (0x%X)", err));
            break;
        }

        DBG_ASSERT( pDCInfo );

        //
        // save a converted forest name (for later use by ldap_search)
        // and initialize the DC connection
        //

        err = Forest2DN(pDCInfo->DomainName);

        m_ldapConnection = pfn_ldap_init(
                                      pDCInfo->DomainControllerName + 2,
                                      0);

        //
        // we no longer need the DCInfo structure, so release it.
        //

        pfn_NetApiBufferFree( pDCInfo );

        //
        // now check the result of the previous calls
        //

        if ( err != NO_ERROR) {
            DBGPRINTF((DBG_CONTEXT, "Forest2DN() failed (0x%X)", err));
            break;
        }

        if ( m_ldapConnection == NULL ) {
            err = pfn_LdapGetLastError();
            if (err == LDAP_SUCCESS) {
                err = LDAP_OPERATIONS_ERROR;
            }
            DBGPRINTF((DBG_CONTEXT, "ldap_init() failed (0x%X)", err));
            break;
        }

        //
        // now tell LDAP what version of the API we are using, and set some other options
        //

        ulOptVal = LDAP_VERSION3;
        err = pfn_ldap_set_option(
                             m_ldapConnection,
                             LDAP_OPT_VERSION,
                             &ulOptVal );
        if ( err != LDAP_SUCCESS ) {
            DBGPRINTF((DBG_CONTEXT, "ldap_set_option(LDAP_OPT_VERSION) failed (0x%X)\n", err));
            break;
        }

        ulOptVal = 1;
        err = pfn_ldap_set_option(
                             m_ldapConnection,
                             LDAP_OPT_SIZELIMIT,
                             &ulOptVal );
        if ( err != LDAP_SUCCESS ) {
            DBGPRINTF((DBG_CONTEXT, "ldap_set_option(LDAP_OPT_SIZELIMIT) failed (0x%X)\n", err));
            break;
        }

        ulOptVal = LDAP_NO_LIMIT; //10; /* BUGBUG: make this configurable */ // timelimit in seconds
        err = pfn_ldap_set_option(
                             m_ldapConnection,
                             LDAP_OPT_TIMELIMIT,
                             &ulOptVal );
        if ( err != LDAP_SUCCESS ) {
            DBGPRINTF((DBG_CONTEXT, "ldap_set_option(LDAP_OPT_TIMELIMIT) failed (0x%X)\n", err));
            break;
        }

        err = pfn_ldap_set_option(
                             m_ldapConnection,
                             LDAP_OPT_AUTO_RECONNECT,
                             LDAP_OPT_ON );
        if ( err != LDAP_SUCCESS ) {
            DBGPRINTF((DBG_CONTEXT, "ldap_set_option(LDAP_OPT_AUTO_RECONNECT) failed (0x%X)\n", err));
            break;
        }

        err = pfn_ldap_set_option(
                             m_ldapConnection,
                             LDAP_OPT_REFERRALS,
                             LDAP_OPT_OFF );
        if ( err != LDAP_SUCCESS ) {
            DBGPRINTF((DBG_CONTEXT, "ldap_set_option(LDAP_OPT_REFERRALS) failed (0x%X)\n", err));
            break;
        }

        //
        // unhash the password so we can use it
        //

        strPassword.Clone( &localPassword);
        localPassword.Unhash();

        //
        // next, bind to the DC using the provided user credentianls
        //

        sSecIdent.User = (PUCHAR)strUser.QueryStr();
        sSecIdent.UserLength = strUser.QueryCCH();
        sSecIdent.Domain = (PUCHAR)strDomain.QueryStr();
        sSecIdent.DomainLength = strDomain.QueryCCH();
        sSecIdent.Password = (PUCHAR)localPassword.QueryStr();
        sSecIdent.PasswordLength = localPassword.QueryCCH();
        sSecIdent.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

        err = pfn_ldap_bind_s(
                     m_ldapConnection,
                     NULL,
                     (PCHAR)&sSecIdent,
                     LDAP_AUTH_NEGOTIATE);

        // clear the password first
        localPassword.Clear();

        if ( err == LDAP_SUCCESS ) {
            //
            // successful bind - we are done here.
            //
            break;
        }

        DBGPRINTF((DBG_CONTEXT, "ldap_bind_s() failed (0x%X)\n", err));

        //
        // add rediscovery flag for the retry call to DsGetDcName()
        //
        fDsGetDcName |= DS_FORCE_REDISCOVERY;

    } while (--dwDsGetDcNameRetriesLeft > 0);

    SetLastError( err );
}


/*++
    class distructor. if there is a valid LDAP connection handle, close it.

    Arguments:
        none.

    Returns:
        none.

--*/

LdapCacheItem::~LdapCacheItem()
{
    if ( m_ldapConnection != NULL ) {
        pfn_ldap_unbind( m_ldapConnection );
    }
}


/*++
    Given a forest name, format a Distinguished Name string. Stores the result in
    m_strForestDN. Result format: DC=dom,DC=org,DC=comp,DC=com

    Arguments:

        pszForest - input of the format dom.org.corp.com

    return:

        LDAP error codes. LDAP_SUCCESS or appropriate error code.

--*/

DWORD
LdapCacheItem::Forest2DN(
   IN  PCSTR pszForest)
{
    BOOL fOk = TRUE;
    PCSTR cp;

    m_strForestDN.Reset();

    //
    // for empty input we are done.
    //

    if ( (pszForest == NULL) || (*pszForest == '\0') ) {
        fOk = FALSE;
    }

    //
    // iterate through the '.' separated components of the forest name
    //

    while (fOk) {
        //
        // start each component with a 'DC='
        //

        fOk &= m_strForestDN.Append( "DC=" );

        cp = (PCSTR)_mbschr( (const UCHAR *)pszForest, '.');

        if (cp == NULL) {

            //
            // last component
            //

            fOk &= m_strForestDN.Append( pszForest );
            break;
        }

        fOk &= m_strForestDN.Append( pszForest, DIFF(cp - pszForest) );

        fOk &= m_strForestDN.Append( "," ); // append ',' to separate next component

        pszForest = cp+1;
    }

    return fOk ? ERROR_SUCCESS : ERROR_BAD_FORMAT;
}


//------------------------------------------------------------------------------------------
//
// implementation of the LDAP_CONN_CACHE Class methods
//
//------------------------------------------------------------------------------------------

/*++
    class constructor. initialize critical section and list head.

    Arguments:
        none.

    Returns:
        none.

--*/

LDAP_CONN_CACHE::LDAP_CONN_CACHE()
{
    INITIALIZE_CRITICAL_SECTION( &m_cs );
    InitializeListHead( &m_ConnList );
    m_User.Reset();
    m_Domain.Reset();
    m_Pass.Reset();
}


/*++
    class distructor. free the list of cached connections.

    Arguments:
        none.

    Returns:
        none.

--*/

LDAP_CONN_CACHE::~LDAP_CONN_CACHE()
{
    Lock();

    //
    // indicates the object is invalid
    //
    m_User.Reset();

    //
    // unlink from the list and release.
    //
    while( !IsListEmpty( &m_ConnList ) ) {
        CONTAINING_RECORD(RemoveHeadList( &m_ConnList ), LdapCacheItem, m_Link)->Release();
    }

    Unlock();

    DeleteCriticalSection( &m_cs );
}


/*++
    set/change configuration. set the credentials of the user authenticating the LDAP connections.

    Arguments:

        strUser - name of authentiating user

        strDomain - Domain of authenticating user

        strPassword - Password of authenticating user

    Returns:
        NO_ERROR. the function always succeeds

--*/

DWORD
LDAP_CONN_CACHE::Configure(
            const STR & strUser,
            const STR & strDomain,
            const STR & strPassword)
{
    Lock();

    //
    // if all configuration parameters match, we do nothing.
    // otherwise, just close all current connections.
    //
    if ( !m_User.Equ( strUser ) ||
         !m_Domain.Equ( strDomain ) ||
         !m_Pass.Equ( strPassword ) ) {

        m_User.Copy( strUser );
        m_Domain.Copy( strDomain );
        m_Pass.Copy( strPassword );

        //
        // delete the existing connections.
        // could clone the list head and do this outside the lock, but the list should
        // be very short so we would not gain much
        //
        while( !IsListEmpty( &m_ConnList ) ) {
            CONTAINING_RECORD(RemoveHeadList( &m_ConnList ), LdapCacheItem, m_Link)->Release();
        }
    }

    Unlock();

    return NO_ERROR;
}


/*++
    look up a cached connection or create a new one.

    Arguments:

        Domain - name of domain for which we need a connection.

    Returns:

        Pointer to LdapCacheItem object if successful. If returning a valid pointer,
        we AddRef the object, and the caller must call ->Release() when done.
        On failure, return NULL and SetLastError();

--*/

PLdapCacheItem
LDAP_CONN_CACHE::QueryLdapConnection( const STR & Domain )
{
    DWORD err = NO_ERROR;
    PLdapCacheItem pCacheItem = NULL;
    PLdapCacheItem pNewCacheItem;
    PLIST_ENTRY pElem;
    BOOL fFound = FALSE;


    Lock();

    if ( m_User.IsEmpty() ) {

        //
        // we might be shuting down
        //
        err = ERROR_NOT_READY;

    } else {

        //
        // search for a cached connection
        //
        for ( pElem = m_ConnList.Flink; pElem != &m_ConnList; pElem = pElem->Flink)
        {
            pCacheItem = CONTAINING_RECORD(pElem, LdapCacheItem, m_Link);
            if ( pCacheItem->IsDomainNameMatch( Domain ) )
            {
                fFound = TRUE;
                pCacheItem->AddRef();
                break;
            }
        }
    }

    Unlock();

    //
    // found one or error, we are done.
    //

    if (fFound || err) {
        goto QueryLdapConnection_Exit;
    }


    //
    // create a new object, that will also bind etc.
    //

    pNewCacheItem = new LdapCacheItem(
                                Domain,
                                m_User,
                                m_Domain,
                                m_Pass);

    if ( pNewCacheItem == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto QueryLdapConnection_Exit;
    }

    if ( (err = GetLastError()) != NO_ERROR) {
        //
        // object initialization failed
        //
        pNewCacheItem->Release();
        goto QueryLdapConnection_Exit;
    }


    //
    // now that we have the new connection, we'll check again if we are not shuting down
    // and if the same domain has not been cached in the meantime by another thread
    //

    Lock();

    fFound = FALSE;

    if ( m_User.IsEmpty() ) {

        //
        // we might be shuting down
        //
        err = ERROR_NOT_READY;

    } else {

        for ( pElem = m_ConnList.Flink; pElem != &m_ConnList; pElem = pElem->Flink)
        {
            pCacheItem = CONTAINING_RECORD(pElem, LdapCacheItem, m_Link);
            if ( pCacheItem->IsDomainNameMatch( Domain ) )
            {
                fFound = TRUE;
                pCacheItem->AddRef();
                break;
            }
        }
    }


    //
    // if we found another cached item (or shutting down), release the new one and use the
    // cached one. If we did not (which is the mainstream scenario), then link in the new item.
    //
    if ( fFound || err )
    {
        pNewCacheItem->Release();

    } else {
        InsertHeadList( &m_ConnList, &pNewCacheItem->m_Link );
        pCacheItem = pNewCacheItem;
        pCacheItem->AddRef();
    }

    Unlock();

QueryLdapConnection_Exit:

    if ( err != NO_ERROR ) {
        SetLastError( err );
        pCacheItem = NULL;
    }

    return pCacheItem;
}


//------------------------------------------------------------------------------------------
//
// implementation of the AD_IO Class methods
//
//------------------------------------------------------------------------------------------

#if !defined( USE_STATIC_FUNCTION_BINDING )

HMODULE                AD_IO::hNetApi32 = NULL;
type_DsGetDcName       AD_IO::_pfn_DsGetDcName = NULL;
type_NetApiBufferFree  AD_IO::_pfn_NetApiBufferFree = NULL;
HMODULE                AD_IO::hWLdap32 = NULL;
type_ldap_init         AD_IO::_pfn_ldap_init = NULL;
type_ldap_set_option   AD_IO::_pfn_ldap_set_option = NULL;
type_ldap_bind_s       AD_IO::_pfn_ldap_bind_s = NULL;
type_ldap_unbind       AD_IO::_pfn_ldap_unbind = NULL;
type_ldap_search       AD_IO::_pfn_ldap_search = NULL;
type_ldap_search_s     AD_IO::_pfn_ldap_search_s = NULL;
type_ldap_first_entry  AD_IO::_pfn_ldap_first_entry = NULL;
type_ldap_get_values   AD_IO::_pfn_ldap_get_values = NULL;
type_ldap_abandon      AD_IO::_pfn_ldap_abandon = NULL;
type_ldap_result       AD_IO::_pfn_ldap_result = NULL;
type_ldap_parse_result AD_IO::_pfn_ldap_parse_result = NULL;
type_ldap_value_free   AD_IO::_pfn_ldap_value_free = NULL;
type_ldap_msgfree      AD_IO::_pfn_ldap_msgfree = NULL;
type_LdapGetLastError  AD_IO::_pfn_LdapGetLastError = NULL;

#endif // USE_STATIC_FUNCTION_BINDING

DWORD              AD_IO::m_dwRefCount = 0;
CRITICAL_SECTION   AD_IO::m_cs;
BOOL               AD_IO::m_fLibsInitOK = FALSE;

/*++
    AD_IO constructor
    There is one instance of this class for each FTP server instance that is configured for
    Active Directory Isolation mode.
    THe first instance will dynamically load the LDAP DLLs and initialize the function pointers,
    and intialize the threads servicing the asynchronous LDAP requests.

    Must be followed by call to Configure() before any other call is made. to configure the
    per instance data, including a cache for the anonymous user properties, and one for a
    list of cached LDAP connections.

    Arguments:
        None.

    Returns:
        SetLastError().

--*/

AD_IO::AD_IO() :
    m_pConnCache( NULL ),
    m_pAnonymCache( NULL )
{
    BOOL fOk = TRUE;

    Lock();

    m_dwRefCount++;

#if !defined( USE_STATIC_FUNCTION_BINDING )
    if ( !m_fLibsInitOK ) {

        //
        // Initialize the dynamic bind function pointers
        //


#define GPA( h, FN )   (_pfn_##FN = (type_ ## FN) GetProcAddress( h, #FN ))
#define GPAA( h, FN )  (_pfn_##FN = (type_ ## FN) GetProcAddress( h, #FN "A" ))

        fOk =
            (hNetApi32 = LoadLibrary( "netapi32.dll" )) &&
            GPAA( hNetApi32, DsGetDcName)                 &&
            GPA( hNetApi32, NetApiBufferFree)             ;

        fOk = fOk &&
            (hWLdap32  = LoadLibrary( "wldap32.dll"  )) &&
            GPA( hWLdap32, LdapGetLastError)              &&
            GPA( hWLdap32, ldap_init)                     &&
            GPA( hWLdap32, ldap_set_option)               &&
            GPA( hWLdap32, ldap_bind_s)                   &&
            GPA( hWLdap32, ldap_unbind)                   &&
            GPA( hWLdap32, ldap_search)                   &&
            GPA( hWLdap32, ldap_search_s)                 &&
            GPA( hWLdap32, ldap_first_entry)              &&
            GPA( hWLdap32, ldap_abandon)                  &&
            GPA( hWLdap32, ldap_result)                   &&
            GPA( hWLdap32, ldap_parse_result)             &&
            GPA( hWLdap32, ldap_get_values)               &&
            GPA( hWLdap32, ldap_value_free)               &&
            GPA( hWLdap32, ldap_msgfree)                  ;

        fOk = fOk && ADIO_ASYNC::Initialize();

        if ( !fOk ) {
            if (hNetApi32) {
                FreeLibrary( hNetApi32 );
                hNetApi32 = NULL;
            }

            if (hWLdap32) {
                FreeLibrary( hWLdap32 );
                hWLdap32 = NULL;
            }

            ADIO_ASYNC::Terminate();
        }
    }
#endif // !USE_STATIC_FUNCTION_BINDING

    if ( fOk ) {

        //
        // communicate success. Failure would have been communicated above.
        //

        SetLastError( NO_ERROR );

        m_fLibsInitOK = TRUE;

    } else if (GetLastError() == NO_ERROR) {

        //
        // if anything failed, this is our only way to communicate the initialization failed.
        //

        SetLastError( ERROR_INVALID_HANDLE );
    }

    Unlock();
}


//
//  AD_IO destructor
//
//  Last object causes AD Client DLLs to be freed.
//


/*++
    AD_IO destructor. Called when an instance configured to enterprise isolation is terminating.
    When the last instance using AD_IO is terminating, the LDAP libraries are unloaded, and the
    asynchronous request processing threads are ended.

    Arguments:
        None.

    Returns:
        None.
--*/

AD_IO::~AD_IO()
{
    //
    // clean up the connection and anonymous caches
    //

    if (m_pAnonymCache) {
        delete m_pAnonymCache;
    }

    if (m_pConnCache) {
        delete m_pConnCache;
    }


    //
    // clean up static data if this is the last instance
    //
    Lock();

    if (--m_dwRefCount == 0 ) {

        m_fLibsInitOK = FALSE;

        ADIO_ASYNC::Terminate();

#if !defined( USE_STATIC_FUNCTION_BINDING )
        if (hNetApi32) {
            FreeLibrary( hNetApi32 );
            hNetApi32 = NULL;
        }

        if (hWLdap32) {
            FreeLibrary( hWLdap32 );
            hWLdap32 = NULL;
        }
#endif // !USE_STATIC_FUNCTION_BINDING
    }

    Unlock();
}

/*++
   Configure the AD_IO object. This method must be called after creation of the object
   and before it can be called for service. The method is also called to reconfigure
   the object.

   AD Access creadential are mandatory arguments.
   anonymous user credentials are optional - if provided, an anonymous user cache object
   is created.

   Arguments:
       strADAccUser,
       strADAccDomain,
       strADAccPass      credentials for the user authenticating access to Active Directory
       strAnonUser,
       strAnonDomain     name and domain of the anonymous user.

   Returns:
       Win32 error.
--*/

DWORD
AD_IO::Configure(
        const STR & strADAccUser,
        const STR & strADAccDomain,
        const STR & strADAccPass,
              PCSTR pszAnonUser,
              PCSTR pszAnonDomain)
{
    DWORD dwError = NO_ERROR;

    //
    // create/reconfigure the LDAP Cache object
    //
    if ( !m_pConnCache ) {
        m_pConnCache = new LDAP_CONN_CACHE;

        if (m_pConnCache == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    dwError = m_pConnCache->Configure(
                                strADAccUser,
                                strADAccDomain,
                                strADAccPass);

    if ( dwError != NO_ERROR ) {
        return dwError;
    }


    //
    // create / reconfigure / delete the anonymous cache object
    //
    if (pszAnonUser == NULL) {
        if ( m_pAnonymCache ) {
            delete m_pAnonymCache;
            m_pAnonymCache = NULL;
        }
    } else {
        if ( !m_pAnonymCache ) {
            m_pAnonymCache = new ADIO_ANONYM_CACHE;
        }

        if (m_pAnonymCache == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        dwError = m_pAnonymCache->Configure(
                                    pszAnonUser,
                                    pszAnonDomain);
    }

    return dwError;
}


/*++
    the main service entry point!
    this routine is called to submit a request to fetch the user home directory

    Arguments:
        strUser,
        strDomain       name and domain of user to get home directory
        pstrTarget,     pointer for storing the home directory path
        ppadioReqCtx,   Request handle for leter reference if needed
        pfnCallback,    Callback function for the AD_IO to notify the caller when results are ready
        hCLientCtx      caller context to be used when calling callback function

    Returns:
        ERROR_IO_PENDING on success, other Win32 error on failure
--*/

DWORD
AD_IO::GetUserHomeDir(
    const STR               & strUser,
    const STR               & strDomain,
          STR               * pstrTarget,
          ADIO_ASYNC       ** ppadioReqCtx,
          tpAdioAsyncCallback pfnCallback,
          HANDLE              hCLientCtx)
{
    if (!m_pConnCache) {
        return ERROR_BAD_CONFIGURATION;
    }

    return ADIO_ASYNC::QueryRootDir(
                              strUser,
                              strDomain,
                              m_pConnCache,
                              pstrTarget,
                              ppadioReqCtx,
                              pfnCallback,
                              hCLientCtx);
}

//---------------------------------------------------------------------------------------
//
// implementation of the ADIO_ANONYM_CACHE class
//
//---------------------------------------------------------------------------------------

/*++
    constructor of the ADIO_ANONYM_CACHE object

    Arguments:
        None.

    Returns:
        None.
--*/

ADIO_ANONYM_CACHE::ADIO_ANONYM_CACHE() :
               m_Valid( FALSE )
{
    INITIALIZE_CRITICAL_SECTION( &m_cs );

    m_Reference = 1;
}


/*++
    destructor of the ADIO_ANONYM_CACHE object

    Arguments:
        None.

    Returns:
        None.
--*/

ADIO_ANONYM_CACHE::~ADIO_ANONYM_CACHE()
{
    DeleteCriticalSection( &m_cs );
}


/*++
    Configure the ADIO_ANONYM_CACHE object. Must be called immediately after creating the
    instance. Also called to reconfigure the user name and domain.

    Arguments:
        strUser - user name that impersonates the anonymous user
        strDomain - user domain that impersonates the anonymous user

    Returns:
        NO_ERROR or Win32 error.
--*/

DWORD
ADIO_ANONYM_CACHE::Configure(
    IN  PCSTR pszUser,
    IN  PCSTR pszDomain)
{
    DWORD err;

    Lock();

    m_TimeStamp = 0;

    if ( m_User.Copy( pszUser ) &&
         m_Domain.Copy( pszDomain )) {

        m_Valid = TRUE;
        err = NO_ERROR;
    } else {

        m_Valid = FALSE;
        err = ERROR_INVALID_PARAMETER;
    }

    Unlock();

    return err;
}


/*++
    increase ref count of the object. If shuting down, or object not initialized (!m_Valid)
    ref count not incremented, and returning error.

    Argunents:
        None.

    Returns:
        TRUE if object is valid and ref count incremented.
        FALSE if object not valid and no ref count incremented
--*/

BOOL
ADIO_ANONYM_CACHE::Reference()
{
    BOOL Valid;

    Lock();

    Valid = m_Valid;

    if (Valid) {
        m_Reference++;
    }

    Unlock();

    return Valid;
}


/*++
    Release reference to the instance. Will decrement the current reference count and delete
    the instance when ref count reaches zero.

    Arguments:
        Shutdown - TRUE on shutdown to indicate m_Valid should be changed to FALSE

    Returns:
        None.
--*/

VOID
ADIO_ANONYM_CACHE::Release(BOOL Shutdown)
{
    BOOL DoDelete = FALSE;

    Lock();

    if ( Shutdown ) {

        m_Valid = FALSE;
    }

    DBG_ASSERT( m_Reference > 0 );

    if ( (m_Reference > 0) && (--m_Reference == 0) ) {

        m_Valid = FALSE;
        DoDelete = TRUE;
    }

    Unlock();

    if ( DoDelete ) {
        delete this;
    }
}

/*++
    Returns the cahced path for the anonymous user, as previously obtained from AD.
    If the cache has not been populated yet, or the refresh interval has elapsed, the
    cache is refreshed and the fresh information returned.

    Arguments:
        TargetPath - reference to buffer where the path is stored
        pConnCache - pointer to the ldap connection cache

    returns:
        NO_ERROR on success, Win32 error on failure.
--*/

DWORD
ADIO_ANONYM_CACHE::GetCachedPath(
    STR & TargetPath,
    PLDAP_CONN_CACHE pConnCache
    )
{
    ULONGLONG CurrentTime;
    DWORD err = NO_ERROR;

    DBG_ASSERT( TargetPath.QuerySize() >= m_Path.QuerySize() );

    //
    // reference the object so it does not get invalidated while we use it.
    // if the object is already invalid, return now.
    //

    if ( !Reference() ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    // first, check if our cached data is up-to-date
    //

    GetSystemTimeAsFileTime( (PFILETIME)&CurrentTime );

    if ( (CurrentTime - m_TimeStamp) < g_MaxAdPropCacheTime ) {
        //
        // fresh data - return to caller
        //

        Lock();

        if ( !TargetPath.Copy( m_Path )) {
            err = ERROR_INSUFFICIENT_BUFFER;
        }

        Unlock();

        goto GetCachedPath_Exit;
    }

    //
    // old data, need to update. Use caller buffer to avoid overrun by another thread
    // that may be refreshing simultaneously.
    //
    err = ADIO_ASYNC::QueryRootDir_Sync(
                            m_User,
                            m_Domain,
                            pConnCache,
                            TargetPath);

    if (err != NO_ERROR) {
        goto GetCachedPath_Exit;
    }

    //
    // now update our cache copy. another thread may be doing this in paralel, but that's OK.
    //
    GetSystemTimeAsFileTime( (PFILETIME)&CurrentTime );

    Lock();

    if ( m_Path.Copy( TargetPath )) {

        m_TimeStamp = CurrentTime;
    }

    Unlock();

GetCachedPath_Exit:

    Release();

    return err;
}

//========================================================================================

CRITICAL_SECTION   ADIO_ASYNC::m_cs;
LONG               ADIO_ASYNC::m_ActiveThreads = 0;
HANDLE             ADIO_ASYNC::m_Threads[32];
HANDLE             ADIO_ASYNC::m_Events[2] = { NULL, NULL };
const DWORD   WaitEventShutdown = 0;
const DWORD   WaitEventNotEmpty = 1;

volatile LONG      ADIO_ASYNC::m_NumTotalAlloc;
volatile LONG      ADIO_ASYNC::m_NumTotalFree;
LIST_ENTRY         ADIO_ASYNC::m_WorkListHead;
LIST_ENTRY         ADIO_ASYNC::m_FreeListHead;

/*++
    Initialize the async request service component. create shutdown event and the
    service threads, and init all the static data.

    Arguments:
        None.

    Returns:
        None.

--*/
BOOL
ADIO_ASYNC::Initialize()
{
    SYSTEM_INFO SysInfo;

    INITIALIZE_CRITICAL_SECTION( &m_cs );

    m_NumTotalAlloc = 0;
    m_NumTotalFree = 0;
    InitializeListHead( &m_WorkListHead );
    InitializeListHead( &m_FreeListHead );

    m_ActiveThreads = 0;

    m_Events[ WaitEventShutdown ] = CreateEvent(
                                        NULL,   // security
                                        TRUE,   // manual reset
                                        FALSE,  // initial state non-signaled
                                        NULL);  // name

    if ( m_Events[ WaitEventShutdown ] == NULL ) {
        return FALSE;
    }

    m_Events[ WaitEventNotEmpty ] = CreateEvent(
                                        NULL,   // security
                                        FALSE,  // auto reset
                                        FALSE,  // initial state non-signaled
                                        NULL);  // name

    if ( m_Events[ WaitEventNotEmpty ] == NULL ) {
        return FALSE;
    }

    GetSystemInfo( &SysInfo );

    //
    // start ADIO_ASYNC threads
    //

    DWORD NumThreads = SysInfo.dwNumberOfProcessors;
    if (NumThreads > 4) {
        NumThreads = (NumThreads >> 1) + 2;
    }
    if (NumThreads > 25) {
        NumThreads = 25;
    }

    for (DWORD i = 0; i < NumThreads; i++) {
        m_Threads[i] = CreateThread(
                                    NULL,          // SecAttribs
                                    0,             // stack size
                                    &WorkerThread,
                                    NULL,          // param to thread
                                    0,             // flags
                                    NULL);         // ThreadID

        if (m_Threads[i] == NULL) {
            return FALSE;
        }

        m_ActiveThreads++;
    }

    return TRUE;
}


/*++
    Terminates the threads serving the asynchronous requests, and cleans up the request objects

    Arguments:
        None.

    Returns:
        TRUE.

--*/

BOOL
ADIO_ASYNC::Terminate()
{
    PADIO_ASYNC pReq;

    //
    // if the object was initialized, the shutdown event exists
    //

    if (m_Events[ WaitEventShutdown ]) {

        //
        // signal to the threads it's time to bail out
        //

        SetEvent( m_Events[ WaitEventShutdown ] );

        //
        // wait for all threads to get the message
        //

        if (m_ActiveThreads) {
            DWORD dwError = WaitForMultipleObjects(
                                   m_ActiveThreads,
                                   m_Threads,
                                   TRUE,
                                   6000);

            DBG_ASSERT( dwError != WAIT_TIMEOUT && dwError != WAIT_FAILED);

            while (m_ActiveThreads > 0) {
                CloseHandle(m_Threads[ --m_ActiveThreads ]);
            }
        }


        CloseHandle( m_Events[ WaitEventShutdown ] );
        m_Events[ WaitEventShutdown ] = NULL;

        //
        // at this point, all async threads are gone, so we don't need to worry about
        // locking any shared resource.
        //

        //
        // complete all requests and free the work list objects
        //
        while( !IsListEmpty( &m_WorkListHead ) ) {

            pReq = CONTAINING_RECORD( RemoveHeadList( &m_WorkListHead ), ADIO_ASYNC, m_Link);

            if (pReq->m_State == RequestStateRetrieve) {
                //
                // we have pending async operation - terminate it
                //
                pfn_ldap_abandon(
                     pReq->m_pLdapCacheItem->QueryConnection(),
                     pReq->m_AsyncMsgNum);
            }

            pReq->ProcessComplete();

            Free( pReq );
        }

        //
        // free the free list objects
        //
        while( !IsListEmpty( &m_FreeListHead ) ) {
            delete CONTAINING_RECORD( RemoveHeadList( &m_FreeListHead ), ADIO_ASYNC, m_Link);
        }

        if (m_Events[ WaitEventNotEmpty ]) {
            CloseHandle( m_Events[ WaitEventNotEmpty ] );
            m_Events[ WaitEventNotEmpty ] = NULL;
        }
    }

    DeleteCriticalSection( &m_cs );

    return TRUE;
}


/*++
    Initiate an LDAP search for the ftproot and ftpdir properties of a user

    Arguments:
        fSyncSearch - boolean flag indicating whether or not to start a synchronous
                      search. By default, the search is asynchronous.

    Returns:
       TRUE / FALSE to indicate Success / Failure.

--*/

BOOL
ADIO_ASYNC::ProcessSearch(BOOL fSyncSearch)
{
    ULONG    err = LDAP_SUCCESS;
    CHAR     szSearchQuery[ MAX_PATH ];
    INT      iWritten;

    //
    // get a cached connection handle. if this is not yet cached, the call will
    // block until the connection is bound.
    //
    m_pLdapCacheItem = m_pConnCache->QueryLdapConnection( m_strDomain );

    if ( !m_pLdapCacheItem ) {
        m_Status = GetLastError();
        return FALSE;
    }

    //
    // format the query string and run the query
    //

    iWritten = _snprintf( szSearchQuery,
                          sizeof( szSearchQuery ),
                          pszQueryFormatString,
                          m_strUser.QueryStr());
    if ((iWritten <= 0) || (iWritten >= sizeof( szSearchQuery ))) {
        m_Status = ERROR_INSUFFICIENT_BUFFER;
        return FALSE;
    }


    if (fSyncSearch) {
        //
        // do a synchronous search
        //
        err = pfn_ldap_search_s(
                        m_pLdapCacheItem->QueryConnection(),
                        m_pLdapCacheItem->QueryForestDN(),
                        LDAP_SCOPE_SUBTREE,
                        szSearchQuery,
                        aszRetAttribs,
                        FALSE,            // attribute type & values
                        &m_pLdapMsg);
    } else {
        //
        // initiate an asynchronous search
        //
        m_AsyncMsgNum = pfn_ldap_search(
                               m_pLdapCacheItem->QueryConnection(),
                               m_pLdapCacheItem->QueryForestDN(),
                               LDAP_SCOPE_SUBTREE,
                               szSearchQuery,
                               aszRetAttribs,
                               FALSE);            // attribute type & values
        if (m_AsyncMsgNum == -1) {
            err = pfn_LdapGetLastError();
            if (err == LDAP_SUCCESS) {
                err = LDAP_OPERATIONS_ERROR;
            }
        } else {
            err = LDAP_SUCCESS;
        }
    }

 	 if ( err != LDAP_SUCCESS ) {
 		  DBGPRINTF((DBG_CONTEXT, "ldap_search%s() failed (0x%X)\n",
                                fSyncSearch ? "_s" : "", err));
        m_Status = err;
        return FALSE;
 	 }

    m_Status = ERROR_IO_PENDING;
    return TRUE;
}


/*++
    after an LDAP query (search) has compleeted, this routine extracts the results
    and constructs the user home directory

    Arguments:
        None.

    Returns:
        TRUE on success, FALSE on failure.

--*/

BOOL
ADIO_ASYNC::ProcessRetrieve()
{
    ULONG                     err = LDAP_SUCCESS;
    LDAPMessage               *pLdapEntry = NULL;
    PCHAR                     *ppszAttribValRoot = NULL, *ppszAttribValDir = NULL;

    //
    // retrieve the first (and only) result entry
    //

 	 pLdapEntry = pfn_ldap_first_entry( m_pLdapCacheItem->QueryConnection(), m_pLdapMsg );

 	 if ( pLdapEntry == NULL ) {
 	     err = pfn_LdapGetLastError();
         if (err == LDAP_SUCCESS) {
             // no entry exists, map to an appropriate error
             err = LDAP_NO_RESULTS_RETURNED;
         }
 	     DBGPRINTF((DBG_CONTEXT, "ldap_first_entry() failed (0x%X)\n", err));
         m_Status = err;
         return FALSE;
 	 }

    //
    // we currently do not allow more than one value, but this could become a feature
    // to support alternate share points...
    //

    ppszAttribValRoot = pfn_ldap_get_values(
                                     m_pLdapCacheItem->QueryConnection(),
                                     pLdapEntry,
                                     pszFtpRoot );
    ppszAttribValDir  = pfn_ldap_get_values(
                                     m_pLdapCacheItem->QueryConnection(),
                                     pLdapEntry,
                                     pszFtpDir );

    if ( ppszAttribValRoot          &&  // attribute not found
         *ppszAttribValRoot         &&  // no value for attribute
         **ppszAttribValRoot        &&  // empty value for attribute
         !*(ppszAttribValRoot + 1)  &&  // more than one value
         ppszAttribValDir           &&  // attribute not found
         *ppszAttribValDir          &&  // no value for attribute
         **ppszAttribValDir         &&  // empty value for attribute
         !*(ppszAttribValDir + 1))      // more than one value
    {
        BOOL fOk = TRUE;

        //
        // construct the combined path
        //

        //
        // copy the root part first
        //
        fOk = fOk && m_pstrTarget->Copy( *ppszAttribValRoot );

        //
        // add a path separator if there is not one already
        //
        if ( !IS_PATH_SEP( m_pstrTarget->QueryLastChar() ) ) {
            fOk = fOk && m_pstrTarget->Append( "\\", 1);
        }

        //
        // copy the dir part, skipping the separator if present
        //

        if ( IS_PATH_SEP( **ppszAttribValDir ) ) {
            fOk = fOk && m_pstrTarget->Append( *ppszAttribValDir + 1 );
        } else {
            fOk = fOk && m_pstrTarget->Append( *ppszAttribValDir );
        }

        if ( !fOk ) {
            err = LDAP_NO_RESULTS_RETURNED;
        }
    } else {
        err = LDAP_NO_RESULTS_RETURNED;
    }

    if ( ppszAttribValRoot ) {
        pfn_ldap_value_free( ppszAttribValRoot );
    }

    if ( ppszAttribValDir ) {
        pfn_ldap_value_free( ppszAttribValDir );
    }

    m_Status = err;
    return err == LDAP_SUCCESS;
}


/*++
    Complete the processing of an asynchronous request. Notify the client.

    Arguments:
        None.

    Returns:
        None.

--*/

VOID
ADIO_ASYNC::ProcessComplete()
{
    Lock();
    if ( m_pfnClientCallback ) {
        m_pfnClientCallback( m_hClientCtx, m_Status );
    } // else, the request may have been canceled.
    Unlock();
}


/*++
    Checks if the object is ready for processing. Either a newly submitted object, or one for
    which the LDAP processing has completed.

    Arguments:
        None.

    Returns:
        TRUE if object is ready.

--*/

BOOL
ADIO_ASYNC::IsResultReady()
{
    static LDAP_TIMEVAL sZero = {0,0};
    ULONG ResType;
    BOOL fRet;

    if (m_State == RequestStateInitial) {
        return TRUE;
    }

    ResType = pfn_ldap_result(
                    m_pLdapCacheItem->QueryConnection(),
                    m_AsyncMsgNum,
                    LDAP_MSG_ALL,
                    &sZero,
                    &m_pLdapMsg);

    if (ResType == 0) {
        //
        // no result yet
        //

        fRet = FALSE;

    } else {
        //
        // it's either a valid completion (>0) or a failure (-1). (yes, I know this is ULONG,
        // but I did not write the MSDN documentation). If it is a failure, no matter why this
        // failed, we can't recover. So just let it be handled as an error.
        //

        m_LdapMsgType = ResType;
        fRet = TRUE;
    }

    return fRet;
}


/*++
    Find the next request object that is ready for processing. It's either a new request
    or one that and async LDAP call has completed. Removes the object from the work list.

    Arguments:
        ppReq   - will be set to point to the ready request object.

    Returns:
        TRUE if ready object found.

--*/

BOOL
ADIO_ASYNC::FetchRequest(
    ADIO_ASYNC **ppReq)
{
    BOOL fFound = FALSE;
    ADIO_ASYNC *pReq;
    LIST_ENTRY *pEntry;

    Lock();
    for( pEntry = m_WorkListHead.Flink;
         pEntry != &m_WorkListHead;
         pEntry = pEntry->Flink) {

        pReq = CONTAINING_RECORD( pEntry, ADIO_ASYNC, m_Link);
        if ( pReq->IsResultReady() ) {
            *ppReq = pReq;
            RemoveEntryList( pEntry );
            fFound = TRUE;
            break;
        }
    }
    Unlock();
    return fFound;
}


/*++
    Terminate a pending asynchronous LDAP operation

    Arguments:
        None.

    Returns:
        None.

--*/

VOID
ADIO_ASYNC::EndRequest()
{
    BOOL fFound = FALSE;
    LIST_ENTRY *pEntry;

    Lock();
    for( pEntry = m_WorkListHead.Flink;
         pEntry != &m_WorkListHead;
         pEntry = pEntry->Flink) {

        if (pEntry == &m_Link) {
            RemoveEntryList( pEntry );
            fFound = TRUE;
            break;
        }
    }

    //
    // make sure we do not callback the user object. even if the request is being processed
    // and we do not cancel it, at least we will not call the user object if it is no longer
    // around
    //

    m_pfnClientCallback = NULL;
    m_hClientCtx = NULL;

    Unlock();

    if ( fFound ) {

        //
        // it was on the work list. stop the operation and free the object.
        // if the object was not found, it may be in some transient state, or processed
        // if so, the processing will complete.
        //

        DBG_ASSERT( this == CONTAINING_RECORD( pEntry, ADIO_ASYNC, m_Link) );

        if (m_State == RequestStateRetrieve) {
            pfn_ldap_abandon(
                        m_pLdapCacheItem->QueryConnection(),
                        m_AsyncMsgNum);
        }

        //
        // note! we delete the object here! no code after this point
        //

        Free( this );
    }
}

/*++
    Allocate a request object either from the free cache or from system memory

    Arguments:
        None.

    Returns:
        pointer to allocated object, or NULL on error.

--*/

PADIO_ASYNC
ADIO_ASYNC::Alloc()
{
    PADIO_ASYNC pReq = NULL;

    Lock();
    if ( !IsListEmpty( &m_FreeListHead ) ) {
        pReq = CONTAINING_RECORD( RemoveHeadList( &m_FreeListHead ), ADIO_ASYNC, m_Link);
        m_NumTotalFree--;
    }
    Unlock();

    if (pReq == NULL) {
        pReq = new ADIO_ASYNC;
        if (pReq != NULL) {
            InterlockedIncrement( &m_NumTotalAlloc );
        }
    }

    return pReq;
}


/*++
    Cleanup a request that has completed, and return the object to a cache of free objects.
    If we have too many free objects, free up memory.

    Assume the object is *NOT* on any list.

    Arguments:
        pReq - pointer to the instance (this is a static method)

    Returns:
        None.

--*/

VOID
ADIO_ASYNC::Free(PADIO_ASYNC pReq)
{
    //
    // cleanup the object, free resources
    //

 	 if ( pReq->m_pLdapMsg ) {
 	     pfn_ldap_msgfree( pReq->m_pLdapMsg );
        pReq->m_pLdapMsg = NULL;
  	 }

    if ( pReq->m_pLdapCacheItem ) {
        pReq->m_pLdapCacheItem->Release();
        pReq->m_pLdapCacheItem = NULL;
    }

    //
    // if we are shuting down, don't bother returning this to the free list
    //

    if (m_Events[ WaitEventShutdown ] == NULL) {
        delete pReq;
        return;
    }


    Lock();

    //
    // add the object to the list of free
    //

    InsertHeadList( &m_FreeListHead, &pReq->m_Link);
    m_NumTotalFree++;

    //
    // is it time for cleanup? (are we over the high threshold)
    //
    if ((m_NumTotalFree > AsyncMinFreeReqObjs) &&
        (m_NumTotalFree > AsyncMaxFreeReqRate * m_NumTotalAlloc / 100 ) ) {

        LONG NumToFree;

        //
        // delete objects until we hit the percentage or numeric threshold
        //

        NumToFree = m_NumTotalFree - (AsyncMinFreeReqRate * m_NumTotalAlloc / 100);
        if (NumToFree > (m_NumTotalFree - AsyncMinFreeReqObjs) ) {
            NumToFree = (m_NumTotalFree - AsyncMinFreeReqObjs);
        }

        m_NumTotalFree -= NumToFree;
        m_NumTotalAlloc -= NumToFree;

        while ( NumToFree ) {
            delete CONTAINING_RECORD( RemoveHeadList( &m_FreeListHead ), ADIO_ASYNC, m_Link );
        }
    }
    Unlock();
}


/*++
    Work thread for processing asynchronous requests to fetch user properties from AD.
    Loop until shutdown, fetch requests ready for processing, process, then either complete
    the request and free the object or return to the work queue for further processing.

    Arguments:
        None.

    Returns:
        None.

--*/

DWORD WINAPI
ADIO_ASYNC::WorkerThread(
    LPVOID pParam)
{
    DWORD resWait;
    PADIO_ASYNC pReq;

    //
    // we loop in here until shutdown. the inner loop runs as long as there
    // are request objects ready to be serviced. The outer loop will go to sleep
    // when there are no ready requests, and wake up after a timeout. We do not have
    // LDAP notifications, so this is the best we can do.
    //
    while(1) {

        while (FetchRequest( &pReq )) {

            if ( pReq->m_LdapMsgType == ~0 ) { // MSDN says this ULONG is -1 on error
                //
                // the call to ldap_result failed, so we can't do anything about it.
                //

                pReq->m_Status = pfn_LdapGetLastError();
                pReq->ProcessComplete();
                Free( pReq );
                continue;
            }

            switch (pReq->m_State) {

            case RequestStateInitial:

                pReq->ProcessSearch();

                pReq->m_State = RequestStateRetrieve;

                break;

            case RequestStateRetrieve:

                if (pReq->m_LdapMsgType != LDAP_RES_SEARCH_RESULT) {

                    DBG_ASSERT( FALSE );
                    pReq->m_Status = LDAP_LOCAL_ERROR;
                    break;
                }

                pfn_ldap_parse_result(
                            pReq->m_pLdapCacheItem->QueryConnection(),
                            pReq->m_pLdapMsg,
                            &(pReq->m_Status),
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            FALSE); // don't free the message

                if (pReq->m_Status != LDAP_SUCCESS) {
                    break;
                }

                pReq->ProcessRetrieve();

                pReq->m_State = RequestStateDone;

                break;

            default:

                DBG_ASSERT( FALSE );

                pReq->m_Status = LDAP_LOCAL_ERROR;

                break;
            }

            if (pReq->m_Status == ERROR_IO_PENDING) {
                //
                // just queue the request. no need to signal the NotEmpty event, as this thread
                // will only go for a short nap as the queue is not empty.
                //
                pReq->QueueWork();
            } else {
                //
                // processing of this request is complete.
                //
                pReq->ProcessComplete();
                Free( pReq );
            }
        }

        if ( IsListEmpty( &m_WorkListHead ) ) {
        //
        // there is no critical section around testing the above condition and determining
        // the wait method. Any thread that just inserted a request to the queue, will likely
        // find it not-empty (unless it has been picked up by another thread.
        //
            //
            // nothing in the queue (or another thread is handling it), go for a long sleep
            // only wake up if a new request comes in, or shutdown.
            //

            resWait = WaitForMultipleObjects( 2, m_Events, FALSE, INFINITE );

        } else {
            //
            // there is something in the queue, but results are not ready yet. go take a nap
            // and see if the results are ready then.
            //

            resWait = WaitForSingleObject( m_Events[ WaitEventShutdown ], AsyncPollXval);
        }

        if (resWait == WaitEventShutdown) {
            //
            // Shutdown.
            //
            break;
        }

        DBG_ASSERT( (resWait == WAIT_TIMEOUT ) || (resWait == WaitEventNotEmpty ) );
    }

    return ERROR_SUCCESS;
}

/*++
    Submit a request to fetch AD properties for a user logging in. This is an asynchronous call,

    Arguments:
        strUser,
        strDomain      name and domain of user logging in
        pConnCache     Connection cache list for obtaining a cached LDAP connection
        pstrTarget     points to output buffer where results are stored
        ppadioReqCtx   on return, contains request context, so the request can be reerenced by the caller
        pfnCallback    callback function to notify caller when results are available
        hClientCtx     client context to use when calling callback function

    Returns:
        Upon successful submition, return ERROR_IO_PENDING. otherwise, Win32 error.

--*/
DWORD
ADIO_ASYNC::QueryRootDir(
    const STR               & strUser,
    const STR               & strDomain,
          PLDAP_CONN_CACHE    pConnCache,
          STR               * pstrTarget,
          ADIO_ASYNC       ** ppadioReqCtx,
          tpAdioAsyncCallback pfnCallback,
          HANDLE              hClientCtx)
{
    DBG_ASSERT( pConnCache != NULL );
    DBG_ASSERT( pstrTarget != NULL );
    DBG_ASSERT( ppadioReqCtx != NULL );
    DBG_ASSERT( pfnCallback != NULL );
    DBG_ASSERT( hClientCtx != NULL );

    PADIO_ASYNC pReq = Alloc();

    if (pReq == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pReq->m_Status = NO_ERROR;
    pReq->m_State = RequestStateInitial;
    pReq->m_pConnCache = pConnCache;
    pReq->m_pLdapCacheItem = NULL;
    pReq->m_strDomain.Copy( strDomain );
    pReq->m_strUser.Copy( strUser );
    pReq->m_pstrTarget = pstrTarget;
    pReq->m_pLdapMsg = NULL;
    pReq->m_LdapMsgType = 0;
    pReq->m_pfnClientCallback = pfnCallback;
    pReq->m_hClientCtx = hClientCtx;

    *ppadioReqCtx = pReq;

    //
    // submit the request for processing, and wake up a thread to handle it.
    //

    pReq->QueueWork();
    SetEvent( m_Events[ WaitEventNotEmpty ] );

    return ERROR_IO_PENDING;
}


/*++
    Fetch user properties from AD. this is a synchronous (blocking) call, used for the
    anonymous user properties.

    Arguments
        strUser,
        strDomain      name and domain of user logging in
        pConnCache     Connection cache list for obtaining a cached LDAP connection
        pstrTarget     points to output buffer where results are stored

    Returns:
        Win32 Error.
--*/

DWORD
ADIO_ASYNC::QueryRootDir_Sync(
    const STR               & strUser,
    const STR               & strDomain,
          PLDAP_CONN_CACHE    pConnCache,
          STR               & strTarget)
{
    DBG_ASSERT( pConnCache != NULL );

    PADIO_ASYNC pReq = Alloc();

    if (pReq == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    pReq->m_Status = NO_ERROR;
    pReq->m_pConnCache = pConnCache;
    pReq->m_pLdapCacheItem = NULL;
    pReq->m_strDomain.Copy( strDomain );
    pReq->m_strUser.Copy( strUser );
    pReq->m_pstrTarget = &strTarget;
    pReq->m_pLdapMsg = NULL;

    DWORD err = NO_ERROR;
    if (!pReq->ProcessSearch( TRUE ) || !pReq->ProcessRetrieve()) {
        err = pReq->m_Status;
        DBG_ASSERT( err );
        if (err == NO_ERROR) {
            err = LDAP_OPERATIONS_ERROR;
        }
    }

    Free( pReq );

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for FTP server

   Author:

       Murali R. Krishnan    ( MuraliK )    06-Feb-1996

   Environment:

       Windows NT - User Mode

   Project:

       FTP Server DLL

   Revision History:

--*/

# ifndef _FTP_AUX_COUNTERS_HXX_
# define _FTP_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

typedef enum  {   // Fac - stands for Ftp Aux Counters

    FacUnknownCommands = 0,           // cumulative counter
    CacTimeoutWhenProcessing,         // cumulative
    CacTimeoutInDisconnect,           // cumulative
    FacPassiveDataListens,            // active counter
    FacSimulatedAborts,               // cumulative counter
    FacPassiveDataConnections,        // cumulative counter
    FacActiveDataConnections,         // cumulative counter
    FacFilesOpened,                   // cumulative counter
    FacFilesClosed,                   // cumulative counter
    FacFilesInvalid,                  // cumulative counter

    FacMaxCounters
} ENUM_FTP_AUX_COUNTER;



#ifdef FTP_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (FacMaxCounters)

//
// Macros for operating on these counters
//

# define FacIncrement( facCounter)   \
 (((facCounter) < FacMaxCounters) ?  \
  InterlockedIncrement( g_AuxCounters+(facCounter)) : \
  0)

# define FacDecrement( facCounter)   \
 (((facCounter) < FacMaxCounters) ?  \
  InterlockedDecrement( g_AuxCounters+(facCounter)) : \
  0)

# define FacCounter( facCounter)   \
 (((facCounter) < FacMaxCounters) ? g_AuxCounters[facCounter] : 0)


extern LONG g_AuxCounters[];


# else // FTP_AUX_COUNTERS

# define NUM_AUX_COUNTERS          (0)

# define FacIncrement( facCounter)       (0)    /* do nothing */
# define FacDecrement( facCounter)       (0)    /* do nothing */
# define FacCounter(facCounter)          (0)    /* do nothing */

#endif // FTP_AUX_COUNTERS


# endif // _FTP_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\asyncio.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

       asyncio.cxx

   Abstract:

       This module implements functions for ASYNC_IO_CONNECTION Object.

   Author:

       Murali R. Krishnan    ( MuraliK )    27-March-1995

   Environment:

      User Mode -- Win32

   Project:

      Internet Services DLL

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
// need to include ftpdp.hxx here since precompiled header used.
# include "ftpdp.hxx"

# include "dbgutil.h"
# include "asyncio.hxx"
# include "..\..\infocomm\atq\atqtypes.hxx"


/************************************************************
 *   Functions
 ************************************************************/



ASYNC_IO_CONNECTION::ASYNC_IO_CONNECTION(
   IN  PFN_ASYNC_IO_COMPLETION  pfnAioCompletion,
   IN  SOCKET sClient OPTIONAL
   )
:   m_pAioContext      ( NULL),
    m_pfnAioCompletion ( pfnAioCompletion),
    m_sClient          ( sClient),
    m_fFileIO          ( FALSE),
    m_sTimeout         ( DEFAULT_CONNECTION_IO_TIMEOUT),
    m_pAtqContext      ( NULL),
    m_endpointObject   ( NULL)
{
    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Created a new ASYNC_IO_CONNECTION object ( %08x)\n",
                    this
                    ));
    }

} // ASYNC_IO_CONNECTION::ASYNC_IO_CONNECTION()




ASYNC_IO_CONNECTION::~ASYNC_IO_CONNECTION( VOID)
/*++
  This function cleans up the ASYNC_IO_CONNECTION object. It also frees
  up sockets and ATQ context embedded in this object.

  THIS IS NOT MULTI_THREAD safe!

--*/
{

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Deleting the ASYNC_IO_CONNECTION object ( %08x) \n",
                    this
                    ));
    }

    if ( (!m_fFileIO && m_sClient != INVALID_SOCKET) ||
         ( m_fFileIO && m_sClient != (SOCKET)INVALID_HANDLE_VALUE) ) {

        //
        // Shut and Close the socket. This can fail, if the socket is already
        //  closed by some other thread before this operation completes
        //

        StopIo( NO_ERROR);
    }

    if ( m_pAtqContext != NULL) {

       AtqFreeContext( m_pAtqContext, TRUE );
       m_pAtqContext = NULL;
    }

    DBG_ASSERT( m_sClient == INVALID_SOCKET);

} // ASYNC_IO_CONNECTION::~ASYN_IO_CONNECTION()





BOOL
ASYNC_IO_CONNECTION::ReadFile(
    OUT LPVOID   pvBuffer,
    IN DWORD     cbSize,
    IN LONGLONG  liOffset
    )
/*++
  This starts off an Asynchronous read operation for data from client
   into the supplied buffer.

  Arguments:
     pvBuffer         pointer to byte buffer which on successful
                        return will contain the data read from client
     cbSize           count of bytes of data available in the buffer.
                        ( limits the size of data that can be read)
     liOffset         When writing to file, use this offset to initialize the ATQ
                        overlapped structure

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL fReturn = TRUE;

    DBG_ASSERT( pvBuffer != NULL);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "ReadFile( %08x, %u)\n",
                    this, pvBuffer, cbSize
                    ));
    }

    //
    // if no ATQ context yet, create one.
    // set offset in ATQ overlapped structure
    // initiate the async read
    //

    if ( (m_pAtqContext == NULL && !AddToAtqHandles()) ||
         (m_fFileIO && AtqContextSetInfo(
                           QueryAtqContext(),
                           ATQ_INFO_SET_OVL_OFFSET,
                           (ULONG_PTR)&liOffset)) ||
        !AtqReadFile( m_pAtqContext, pvBuffer, cbSize, NULL )) {

        IF_DEBUG( ASYNC_IO) {

            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::ReadFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::ReadFile()





BOOL
ASYNC_IO_CONNECTION::WriteFile(
    OUT LPVOID   pvBuffer,
    IN DWORD     cbSize,
    IN LONGLONG  liOffset
    )
/*++
  This starts off an Asynchronous write operation to send data to the client
    sending data from the supplied buffer. The buffer may not be freed
    until the data is sent out.

  Arguments:
     pvBuffer         pointer to byte buffer which contains the data to be sent
                       to the client.
     cbSize           count of bytes of data to be sent.
     liOffset         When writing to file, use this offset to initialize the ATQ
                       overlapped structure

  Returns:
    TRUE on success and FALSE if there is a failure in setting up write.
--*/
{
    BOOL fReturn = TRUE;
    DBG_ASSERT( pvBuffer != NULL);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "WriteFile( %08x, %u)\n",
                    this, pvBuffer, cbSize
                    ));
    }

    //
    // Check and add to create an atq context as well as perform
    //  the write operation.
    //
    // set offset in ATQ overlapped structure
    //

    if ( (m_pAtqContext == NULL && !AddToAtqHandles()) ||
         (m_fFileIO && AtqContextSetInfo(
                           QueryAtqContext(),
                           ATQ_INFO_SET_OVL_OFFSET,
                           (ULONG_PTR)&liOffset)) ||
        !AtqWriteFile( m_pAtqContext, pvBuffer, cbSize, NULL )) {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::WriteFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::WriteFile()





BOOL
ASYNC_IO_CONNECTION::TransmitFile(
    IN HANDLE  hFile,
    IN LARGE_INTEGER & liSize,
    IN LONGLONG        llOffset,
    IN LPTRANSMIT_FILE_BUFFERS   lpTransmitBuffers OPTIONAL
    )
/*++
  This starts off an Asynchronous TransmitFile operation to send file data
   to the client.

  Arguments:
    hFile            handle for the file to be transmitted.
    liSize           large integer containing size of file to be sent.
    Offset           Offset within the file to begin transmitting.
    lpTransmitBuffers pointer to File Transmit Buffers

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL fReturn = TRUE;
    DBG_ASSERT( hFile != INVALID_HANDLE_VALUE);

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "TransmitFile( %08x, %l, %ul, %08x)\n",
                    this, hFile, liSize.HighPart, liSize.LowPart,
                    lpTransmitBuffers
                    ));
    }

    if ( m_pAtqContext == NULL )
    {
        if (!AddToAtqHandles())
        {
            IF_DEBUG( ASYNC_IO)
            {
                DWORD dwError = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "ASYNC_IO_CONNECTION(%08x)::AddToAtqHandles() failed."
                           " Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }

            return FALSE;
        }
    }

    AtqContextSetInfo( QueryAtqContext(),
                       ATQ_INFO_SET_OVL_OFFSET,
                       (ULONG_PTR)&llOffset);

    if (!AtqTransmitFile( m_pAtqContext,
                          hFile,
                          ((liSize.HighPart == 0) ? liSize.LowPart : 0),
                          lpTransmitBuffers,
                          TF_DISCONNECT )
        )
    {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::TransmitFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::TransmitFile()



BOOL
ASYNC_IO_CONNECTION::TransmitFileTs(
    IN TS_OPEN_FILE_INFO * pOpenFile,
    IN LARGE_INTEGER &     liSize,
    IN LONGLONG            llOffset,
    IN BOOL                fDisconnectSocket
    )
/*++
  This starts off an Asynchronous TransmitFile operation to send file data
   to the client.

  Arguments:
    hFile             handle for the file to be transmitted.
    liSize            large integer containing size of file to be sent.
    Offset            Offset within the file to begin transmitting.
    fDisconnectSocket is the socket getting disconnected after this transmit,
                      or this is a part of a large file, so keep socket open.

  Returns:
    TRUE on success and FALSE if there is a failure in setting up read.
--*/
{
    BOOL   fReturn = TRUE;
    PBYTE  pFileBuffer = NULL;
    HANDLE hFile = NULL;
    TRANSMIT_FILE_BUFFERS TransmitBuffers;

    DBG_ASSERT( pOpenFile );

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering ASYNC_IO_CONNECTION( %08x)::"
                    "TransmitFile( %p, %p, %ul, %08x)\n",
                    this, pOpenFile, liSize.HighPart, liSize.LowPart
                    ));
    }

    if ( m_pAtqContext == NULL )
    {
        if (!AddToAtqHandles())
        {
            IF_DEBUG( ASYNC_IO)
            {
                DWORD dwError = GetLastError();
                DBGPRINTF(( DBG_CONTEXT,
                           "ASYNC_IO_CONNECTION(%08x)::AddToAtqHandles() failed."
                           " Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }

            return FALSE;
        }
    }

    pFileBuffer = pOpenFile->QueryFileBuffer();
    if (pFileBuffer) {
        //
        // Transmit from memory
        //

        DBG_ASSERT( liSize.HighPart == 0 );

        TransmitBuffers.Head       = pFileBuffer + (DWORD)llOffset;
        TransmitBuffers.HeadLength = liSize.LowPart;
        TransmitBuffers.Tail       = NULL;
        TransmitBuffers.TailLength = 0;
    } else {
        //
        // Transmit from a file
        //
        hFile = pOpenFile->QueryFileHandle();

        AtqContextSetInfo( QueryAtqContext(),
                           ATQ_INFO_SET_OVL_OFFSET,
                           (ULONG_PTR)&llOffset);


        if (liSize.HighPart != 0)
        {
            LARGE_INTEGER liTimeOut;
            ULONG Remainder;

            liTimeOut =
                RtlExtendedLargeIntegerDivide(
                liSize,
                (ULONG) 1024,
                &Remainder);

            if (liTimeOut.HighPart != 0)
            {
                ((PATQ_CONT) m_pAtqContext)->TimeOut = ATQ_INFINITE;
            } else
            {
                ((PATQ_CONT) m_pAtqContext)->TimeOut = liTimeOut.LowPart;
            }
        }
    }

    if (!AtqTransmitFile( m_pAtqContext,
                          hFile,
                          ((liSize.HighPart == 0) ? liSize.LowPart : 0),
                          pFileBuffer ? &TransmitBuffers : NULL,
                          fDisconnectSocket ? TF_DISCONNECT : 0)
        )
    {

        IF_DEBUG( ASYNC_IO) {
            DWORD dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "ASYNC_IO_CONNECTION(%08x)::TransmitFile() failed."
                       " Error = %u\n",
                       this, dwError));
            SetLastError( dwError);
        }

        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::TransmitFile()




BOOL
ASYNC_IO_CONNECTION::StopIo( IN DWORD  dwErrorCode OPTIONAL)
/*++
  This function stops the io connection by performing a hard close on
  the socket that is used for IO. that is the only way one can easily kill the
  IO that is in progress.

  Arguments:
    dwErrorCode   DWORD containing the error code for stopping IO

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    INT serr = 0;
    SOCKET sOld = m_sClient;

    m_sClient = INVALID_SOCKET;

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " ASYNC_IO_CONNECTION( %08x)::StopIo( %u)\n",
                    this, dwErrorCode
                    ));
    }

    //
    // nothing to do if the m_sClient not valid
    //

    if ( !m_fFileIO && (sOld == INVALID_SOCKET) ) {
        goto StopIo_exit;
    }

    //
    // NYI! dwErrorCode is not at present used.
    //

    if ( m_fFileIO ) {

        HANDLE hHandle = (HANDLE)sOld;

        m_fFileIO = FALSE;

        DBG_ASSERT( hHandle != INVALID_HANDLE_VALUE );

        if (m_pAtqContext != NULL) {

            if (!AtqCloseFileHandle( m_pAtqContext)) {

                serr = GetLastError();
            }
        } else {

            if ( !CloseHandle( hHandle)) {

                serr = GetLastError();
            }
        }

    } else {

        if (m_pAtqContext != NULL) {

            //
            // per the FTP RFC, the server must close the socket when killing a data
            // channel.
            //

            if (!AtqCloseSocket( m_pAtqContext, TRUE)) {

                serr = GetLastError();
            }
        } else {

            // Ignore failures in Shutdown and close socket.
            if (closesocket( sOld) == SOCKET_ERROR) {

                serr = WSAGetLastError();
            }
        }

        if ( serr != 0 ) {

            SetLastError( serr);
        }
    }

StopIo_exit:
    return ( serr == 0);
} // ASYNC_IO_CONNECTION::StopIo()




BOOL
ASYNC_IO_CONNECTION::SetNewSocket(IN SOCKET sNewSocket,
                                  IN PATQ_CONTEXT pNewAtqContext, // = NULL
                                  IN PVOID EndpointObject )
/*++

  This function changes the socket maintained for given ASYNC_IO_CONNECTION
  object. It changes it only if the current socket in the object is already
   freed (by calling StopIo()).

  If the Atq Context in this object is a valid one corresponding to old
   socket, it is also freed. So any new operation will create a new AtqContext.
  (This is essential, since there is a one-to-one-relationship between socket
   and ATQ context)


  Arguments:
    sNewSocket   new socket for the connection
     If sNewSocket == INVALID_SOCKET then this function does
       cleanup of old information.

    pNewAtqContext  new ATQ Context for the socket

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn = TRUE;

    DBG_ASSERT( !m_fFileIO);

    if (m_sClient == INVALID_SOCKET) {

        //
        // Free the Atq Context if one already exists.
        //  ==> Reason: There is a one-to-one correspondence b/w ATQ Context
        //               and socket. The atq context if valid was created
        //               for old connection.
        //

        // To avoid race conditions, we exchange pointer with NULL
        //  and later on free the object as need be.
        // Should we necessarily use InterlockedExchange() ???
        //  Isn't it costly? NYI

        PATQ_CONTEXT pAtqContext =
          (PATQ_CONTEXT ) InterlockedExchangePointer( (PVOID *) &m_pAtqContext,
                                              (PVOID) pNewAtqContext);

        if ( pAtqContext != NULL) {

            AtqFreeContext( pAtqContext, TRUE );
        }

        m_sClient = sNewSocket;
        m_endpointObject = EndpointObject;

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        fReturn = FALSE;
    }

    return ( fReturn);

} // ASYNC_IO_CONNECTION::SetNewSocket()



BOOL
ASYNC_IO_CONNECTION::SetNewFile(IN HANDLE hNewFile)
/*++

  Similar to SetNewSocket above.


  Arguments:
    hNewFile   new file handle
     If hNewFile == INVALID_HANDLE_VALUE then this function does
       cleanup of old information.

    pNewAtqContext  new ATQ Context for the socket

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    BOOL fReturn;

    fReturn = SetNewSocket( NULL);

    if ( fReturn) {
        m_fFileIO = TRUE;
        m_sClient = (SOCKET)hNewFile;
    }

    return fReturn;

} // ASYNC_IO_CONNECTION::SetNewFile()



# if DBG

VOID ASYNC_IO_CONNECTION::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing ASYNC_IO_CONNECTION( %08x)\n"
                " CallBackFunction = %08x; Context = %08x\n"
                " Client Socket = %u; AtqContext = %08x;"
                " Timeout = %u sec; \n",
                this, m_pfnAioCompletion, m_pAioContext,
                m_sClient, m_pAtqContext, m_sTimeout));

    return;
} // ASYNC_IO_CONNECTION::Print()


# endif // DBG





VOID
ProcessAtqCompletion(IN LPVOID       pContext,
                     IN DWORD        cbIo,
                     IN DWORD        dwCompletionStatus,
                     IN OVERLAPPED * lpo
                     )
/*++

  This function processes the completion of an atq operation.
  It also sends a call back to the owner of this object ( ASYNC_IO_CONNECTION)
    object, once the operation is completed or if it is in error.

  ATQ module sends 2 messages whenever there is a timeout.
  Reason: The timeout itself is sent by a separate thread and completion port
   API does not support removal of a socket from the completion port. Combining
   these together, ATQ sends a separate timeout message and then when the
   application blows off the socket/handle, ATQ sends another error message
   implying failure of the connection.
    We handle this as follows:
      At timeout ATQ sends fIOCompletion == FALSE and
         dwCompletionStatus == ERROR_SEM_TIMEOUT.
      We send this as fTimedOut in call back.
      The application can check if it is fTimedOut and hence refrain from
       blowing the object completely away.

  Arguments:
     pContext     pointer to User supplied context information
                   ( here: pointer to ASYNC_IO_CONNECTION associated with
                           the IO completed)
     cbIo         count of bytes of IO performed
     dwCompletionStatus  DWORD containing error code if any
     lpo - !NULL if completion from IO

  Returns:
     None
--*/
{
    LPASYNC_IO_CONNECTION   pConn = (LPASYNC_IO_CONNECTION ) pContext;
    BOOL  fTimedOut = FALSE;

    if ( pConn == NULL) {

        // This should not happen....

        SetLastError( ERROR_INVALID_PARAMETER);

        DBG_ASSERT( pConn == NULL);
        return ;
    }

    IF_DEBUG( ASYNC_IO) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "ProcessAtqCompletion(Aio=%08x, cb=%u, Status=%u,"
                    "IO Compltion=%s).\n",
                    pConn,  cbIo, dwCompletionStatus,
                    lpo != NULL ? "TRUE" : "FALSE" ));
    }

    if ( lpo != NULL ||
         (fTimedOut = (
                       lpo == NULL &&
                       dwCompletionStatus == ERROR_SEM_TIMEOUT))
        ) {

        //
        //  This is the right Atq object. Process the response by passing it
        //    to the owner of this object.
        //

        DBG_ASSERT( pConn->QueryPfnAioCompletion() != NULL);

        //
        // Invoke the call back function for completion of IO.
        //

        ( *pConn->QueryPfnAioCompletion())
          (pConn->QueryAioContext(), cbIo, dwCompletionStatus,
           pConn, fTimedOut);

    }

    return;

} // ProcessAtqCompletion()





/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\acptctxt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    acptctxt.cxx

    This file contains the implementations of the PASV_ACCEPT_CONTEXT and ACCEPT_CONTEXT_ENTRY
    classes used to deal with async PASV connections

*/

#include "ftpdp.hxx"
#include "auxctrs.h"
#include "acptctxt.hxx"

LONG g_nAcceptContextEntries = 0;

PASV_ACCEPT_CONTEXT::PASV_ACCEPT_CONTEXT() :
m_dwErr( ERROR_SUCCESS ),
m_dwNumEvents( 0 ),
m_hWatchThread( NULL ),
m_dwThreadId( 0 ),
m_dwSignature( ACCEPT_CONTEXT_GOOD_SIG )
/*++

    Constructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    m_ahEvents[NEEDUPDATE_INDEX] = WSA_INVALID_EVENT;
    m_ahEvents[CANUPDATE_INDEX] = WSA_INVALID_EVENT;
    m_ahEvents[HAVEUPDATED_INDEX] = WSA_INVALID_EVENT;
    m_ahEvents[EXITTHREAD_INDEX] = WSA_INVALID_EVENT;

    if ( ( m_ahEvents[NEEDUPDATE_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT ||
         ( m_ahEvents[CANUPDATE_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT  ||
         ( m_ahEvents[HAVEUPDATED_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT ||
         ( m_ahEvents[EXITTHREAD_INDEX] = WSACreateEvent() ) == WSA_INVALID_EVENT )

    {
        m_dwErr = WSAGetLastError();

        DBGWARN((DBG_CONTEXT,
                   "WSACreateEvent failed : 0x%x\n",
                   m_dwErr));

        return;
    }

    m_dwNumEvents = 4;

    //
    // Create the watching thread
    //
    m_hWatchThread = CreateThread( NULL,
                                   0,
                                   AcceptThreadFunc,
                                   this,
                                   0,
                                   &m_dwThreadId );

    if ( !m_hWatchThread )
    {
        m_dwErr = GetLastError();

        DBGERROR((DBG_CONTEXT,
                   "Failed to create thread to watch for PASV accept events : 0x%x\n",
                   m_dwErr));
    }
}

PASV_ACCEPT_CONTEXT::~PASV_ACCEPT_CONTEXT()
/*++

    Destructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    //
    // Tell watch thread to shut down
    //
    if ( (m_ahEvents[EXITTHREAD_INDEX] != WSA_INVALID_EVENT) &&
         !WSASetEvent( m_ahEvents[EXITTHREAD_INDEX] ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   WSAGetLastError()));
    }

    //
    // wait for thread to shut down
    //
    if ( m_hWatchThread != NULL )
    {
        if ( WaitForSingleObject( m_hWatchThread,
                                  INFINITE ) == WAIT_FAILED )
        {
            DBGWARN((DBG_CONTEXT,
                       "Waiting for thread shutdown failed : 0x%x\n",
                       GetLastError()));
        }

        CloseHandle( m_hWatchThread );
    }


    if ( m_ahEvents[NEEDUPDATE_INDEX] != WSA_INVALID_EVENT )
    {
        WSACloseEvent( m_ahEvents[NEEDUPDATE_INDEX] );
    }
    if ( m_ahEvents[CANUPDATE_INDEX] != WSA_INVALID_EVENT )
    {
        WSACloseEvent( m_ahEvents[CANUPDATE_INDEX] );
    }
    if ( m_ahEvents[HAVEUPDATED_INDEX] != WSA_INVALID_EVENT )
    {
        WSACloseEvent( m_ahEvents[HAVEUPDATED_INDEX] );
    }
    if ( m_ahEvents[EXITTHREAD_INDEX] != WSA_INVALID_EVENT )
    {
        WSACloseEvent( m_ahEvents[EXITTHREAD_INDEX] );
    }

    m_dwSignature = ACCEPT_CONTEXT_BAD_SIG;
}

BOOL PASV_ACCEPT_CONTEXT::RemoveAcceptEvent( IN WSAEVENT hEvent,
                                             IN USER_DATA *pUserData,
                                             OUT PBOOL pfFound )
/*++

   Removes the event to be signalled when a socket is accept()'able

  Arguments:
     hEvent - event to be removed
     pUserData - USER_DATA attached to signalled event
     pfFound - BOOL set to TRUE if event was found, FALSE if not

  Returns:
    BOOL indicating success or failure
--*/
{
    *pfFound = FALSE;
    DWORD dwIndex = 0;
    DWORD dwRet = ERROR_SUCCESS;
    DWORD dwWait = 0;
    BOOL  fRet;

    //
    // Signal that we want to update the list of events
    //
    if ( !WSASetEvent( m_ahEvents[NEEDUPDATE_INDEX] ) )
    {
        dwRet = WSAGetLastError();

        DBGPRINTF((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   dwRet));

        DBG_ASSERT( 0 );  // to catch the cause for 682348

        return FALSE;
    }

    //
    // Wait until we can update the list
    //
    dwWait = WSAWaitForMultipleEvents( 1,
                                       &(m_ahEvents[CANUPDATE_INDEX]),
                                       TRUE,
                                       900000, // 15 minutes should do it....
                                       FALSE );
    switch (dwWait)
    {
    case WSA_WAIT_EVENT_0:

        //
        // Look for the wanted event
        //
        for ( DWORD i = LASTPREALLOC_INDEX; i < m_dwNumEvents; i++ )
        {
            if ( m_ahEvents[i] == hEvent )
            {
                DBG_ASSERT( m_apUserData[i] == pUserData );

                *pfFound = TRUE;
                dwIndex = i;
                break;
            }
        }

        //
        // if found, remove the data associated with the socket
        //
        if ( *pfFound )
        {
            //
            // we're not going to use the context any more, so remove the reference we hold to it
            //
            m_apUserData[dwIndex]->DeReference();

            memmove( (PVOID) (m_ahEvents + dwIndex),
                     (PVOID) (m_ahEvents + (dwIndex + 1) ),
                     sizeof(WSAEVENT) * (m_dwNumEvents - dwIndex - 1) );

            memmove( (PVOID) ( m_apUserData + dwIndex ),
                     (PVOID) (m_apUserData + (dwIndex + 1) ),
                     sizeof(LPUSER_DATA) * (m_dwNumEvents - dwIndex - 1) );

            memmove( (PVOID) (m_adwNumTimeouts + dwIndex),
                     (PVOID) (m_adwNumTimeouts + (dwIndex + 1) ),
                     sizeof(DWORD) * (m_dwNumEvents - dwIndex - 1) );

            m_dwNumEvents--;
        }


        //
        // reset to known state and signal that watch thread can
        // start watching again. make sure both get executed to
        // avoid handing the watch thread
        //

        fRet = WSAResetEvent( m_ahEvents[CANUPDATE_INDEX] );
        fRet = WSASetEvent( m_ahEvents[HAVEUPDATED_INDEX] ) && fRet;
        if ( !fRet )
        {
            dwRet = WSAGetLastError();

            DBGWARN((DBG_CONTEXT,
                       "WSA[Set|Reset]Event failed : 0x%x\n",
                       GetLastError()));
        }

        break;

    case WSA_WAIT_TIMEOUT:

        IF_DEBUG( PASV )
        {
            DBGWARN((DBG_CONTEXT,
                       "Wait timed out ... \n"));
        }

        dwRet = ERROR_TIMEOUT;

        DBG_ASSERT( 0 );  // to catch the cause for 682348

        break;

    default:

        DBGERROR((DBG_CONTEXT,
                   "Invalid return from WSAWaitForMultipleEvents : 0x%x\n",
                   dwWait));

        DBG_ASSERT( 0 );  // to catch the cause for 682348

        dwRet = ERROR_INVALID_PARAMETER;
    }

    return ( dwRet == ERROR_SUCCESS ? TRUE : FALSE );
}

DWORD PASV_ACCEPT_CONTEXT::AddAcceptEvent( WSAEVENT hEvent,
                                           LPUSER_DATA pUserData )
/*++

    Adds an event to be signalled when a socket is accept()'able

  Arguments:
     hEvent - event that will be signalled
     pUserData - USER_DATA context to attach to signalled event

  Returns:
     Error code
--*/
{
    DWORD dwRet = 0;
    DWORD dwWait = 0;
    BOOL fRet;

    if ( m_dwNumEvents == WSA_MAXIMUM_WAIT_EVENTS )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Signal that we want to update the list of events
    //
    if ( !WSASetEvent( m_ahEvents[NEEDUPDATE_INDEX] ) )
    {
        DBGWARN((DBG_CONTEXT,
                   "WSASetEvent failed : 0x%x\n",
                   dwRet));

        return WSAGetLastError();
    }

    //
    // Wait until we can update the list
    //
    dwWait = WSAWaitForMultipleEvents( 1,
                                       &(m_ahEvents[CANUPDATE_INDEX]),
                                       TRUE,
                                       10000, //10 secs seems like a reasonable time to wait
                                       FALSE );
    switch (dwWait)
    {
    case WSA_WAIT_EVENT_0:

        //
        // cool, we can update the list
        //
        m_ahEvents[m_dwNumEvents] = hEvent;

        //
        // add a reference to make sure nobody deletes the context out from under us
        //
        pUserData->Reference();
        m_apUserData[m_dwNumEvents] = pUserData;

        m_adwNumTimeouts[m_dwNumEvents] = 0;
        m_dwNumEvents++;


        //
        // reset to known state and signal that watch thread can
        // start watching again. make sure both get executed to
        // avoid handing the watch thread
        //

        fRet = WSAResetEvent( m_ahEvents[CANUPDATE_INDEX] );
        fRet = WSASetEvent( m_ahEvents[HAVEUPDATED_INDEX] ) && fRet;
        if (!fRet)
        {
            pUserData->DeReference();

            m_dwNumEvents--; //make sure event isn't still seen as valid

            dwRet = WSAGetLastError();


            DBGWARN((DBG_CONTEXT,
                       "WSA[Set|Reset]Event failed : 0x%x\n",
                       GetLastError()));

            break;
        }

        IF_DEBUG ( PASV )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Added event for context 0x%x at index %d\n",
                       pUserData, m_dwNumEvents - 1));
        }

        break;

    case WSA_WAIT_TIMEOUT:

        IF_DEBUG( PASV )
        {
            DBGWARN((DBG_CONTEXT,
                       "Timed out waiting for permission to update PASV event list ... \n"));
        }

        dwRet = ERROR_TIMEOUT;

        break;

    default:

        DBGERROR((DBG_CONTEXT,
                   "Invalid return from WSAWaitForMultipleEvents : 0x%x\n",
                   dwWait));

        dwRet = ERROR_INVALID_PARAMETER;

    }

    return dwRet;
}



ACCEPT_CONTEXT_ENTRY::ACCEPT_CONTEXT_ENTRY() : m_pAcceptContext( NULL)
/*++

    Constructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    if (InterlockedIncrement( &g_nAcceptContextEntries) > g_dwMaxAcceptContextEntries) {
        return;
    }

    m_pAcceptContext = new PASV_ACCEPT_CONTEXT();

    if ( !m_pAcceptContext )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new PASV_ACCEPT_CONTEXT !\n"));
    }
}

ACCEPT_CONTEXT_ENTRY::~ACCEPT_CONTEXT_ENTRY()
/*++

    Destructor

  Arguments:
     None

  Returns:
     Nothing
--*/
{
    if ( m_pAcceptContext )
    {
        DBG_ASSERT(m_pAcceptContext->QueryNumEvents() <= LASTPREALLOC_INDEX);
        delete m_pAcceptContext;
    }

    InterlockedDecrement( &g_nAcceptContextEntries);
}



DWORD CreateAcceptContext(PACCEPT_CONTEXT_ENTRY *ppEntry)
/*++

    Creates a PASV_ACCEPT_CONTEXT object and link it to head of list

  Arguments:
     None

  Returns:
     Error indicating success/failure
--*/
{
    ACCEPT_CONTEXT_ENTRY *pEntry =  NULL;
    DWORD dwRet = ERROR_SUCCESS;

    if ( !(pEntry = new ACCEPT_CONTEXT_ENTRY() ) )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new ACCEPT_CONTEXT_ENTRY !\n"));

        return ERROR_OUTOFMEMORY;
    }

    if ( NULL == pEntry->m_pAcceptContext )
    {
        DBGERROR((DBG_CONTEXT,
                   "Failed to allocate new ACCEPT_CONTEXT_ENTRY::m_pAcceptContext !\n"));

        delete pEntry;
        return ERROR_OUTOFMEMORY;
    }
    if ( ( dwRet = pEntry->m_pAcceptContext->ErrorStatus() ) != ERROR_SUCCESS )
    {
        DBGERROR((DBG_CONTEXT,
                   "Error occurred constructing PASV_ACCEPT_CONTEXT : 0x%x\n",
                   pEntry->m_pAcceptContext->ErrorStatus()));

        delete pEntry;
        return dwRet;
    }

    InsertHeadList( &g_AcceptContextList, &pEntry->ListEntry );

    if (ppEntry) {
        *ppEntry = pEntry;
    }

    return dwRet;
}

VOID DeleteAcceptContexts()
/*++

    Deletes all of the PASV_ACCEPT_CONTEXT objects

  Arguments:
     None

  Returns:
     Nothing
--*/

{
    while ( !IsListEmpty( &g_AcceptContextList ) )
    {
        ACCEPT_CONTEXT_ENTRY *pEntry = CONTAINING_RECORD( g_AcceptContextList.Flink,
                                                          ACCEPT_CONTEXT_ENTRY,
                                                          ListEntry );
        RemoveEntryList( &(pEntry->ListEntry) );

        delete pEntry;
    }
}

DWORD AddAcceptEvent( WSAEVENT hEvent,
                      LPUSER_DATA pUserData )
/*++

    Adds an accept event to an available PASV_ACCEPT_CONTEXT

  Arguments:
      hEvent - handle to event to be added
      pUserData - USER_DATA context to attach to event

  Returns:
     Error code indicating success/failure
--*/
{
    LIST_ENTRY *pEntry = NULL;
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    PACCEPT_CONTEXT_ENTRY pContextEntry = NULL;
    DWORD dwRet = ERROR_SUCCESS;
    BOOL fFoundOne = FALSE;

    pUserData->FakeIOTimes = 0;

    //
    // Walk the list of contexts looking for one that can handle an additional
    // event.
    //
    // NB : currently [9/20/98], that list contains only a -single- context, so we can handle
    // up to a maximum of (WSA_MAXIMUM_WAIT_EVENTS - 4) events. If we want to get really
    // fancy, we could add the necessary code to create a new PASV_ACCEPT_CONTEXT as necessary,
    // but that also creates a new thread, and actually opens us up even more to a Denial Of
    // Service attack, which is partly what this code is trying to avoid
    //
    // RobSol Aug 2002: The above comment is no longer relevant, as I added support for multiple
    // containers. I'm leaning the comment here just for historical reasons. Support for multiple
    // containers is added for two reasons:
    // 1. support the test stress tool, that creates clients and requests concurrently, such that
    //    we indeed exhaust one container
    // 2. to allow a hypothetical ISP with half a meg concurrent users to support multiple concurrent
    //    clients performing file transfer stress
    // the number of containers is configurable, and the default is 1.

    LockAcceptContextList();

    for ( pEntry = g_AcceptContextList.Flink;
          pEntry != &g_AcceptContextList;
          pEntry = pEntry->Flink )
    {
        pContextEntry =  CONTAINING_RECORD( pEntry, ACCEPT_CONTEXT_ENTRY , ListEntry );
        pAcceptContext = pContextEntry->m_pAcceptContext;

        if ( pAcceptContext->QueryNumEvents() < WSA_MAXIMUM_WAIT_EVENTS )
        {
            dwRet = pAcceptContext->AddAcceptEvent( hEvent,
                                                    pUserData );

            fFoundOne = TRUE;
        }

        if ( fFoundOne )
            break;
    }

    if (!fFoundOne )
    {
        dwRet = CreateAcceptContext(&pContextEntry);
        if (dwRet == ERROR_SUCCESS) {
            pAcceptContext = pContextEntry->m_pAcceptContext;

            DBG_ASSERT( pAcceptContext->QueryNumEvents() < WSA_MAXIMUM_WAIT_EVENTS );
            dwRet = pAcceptContext->AddAcceptEvent( hEvent,
                                                    pUserData );
        }
    }

    UnlockAcceptContextList();

    return dwRet;
}

BOOL RemoveAcceptEvent( WSAEVENT hEvent,
                        LPUSER_DATA pUserData )
/*++

    Removes an accept event from the appropriate PASV_ACCEPT_CONTEXT

  Arguments:
      hEvent - handle to event to be removed
      pUserData - USER_DATA context attached to event

  Returns:
      BOOL indicating success/failure
--*/
{
    LIST_ENTRY *pEntry = NULL;
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    PACCEPT_CONTEXT_ENTRY pContextEntry = NULL;
    BOOL fFound = FALSE;
    BOOL fSuccess = FALSE;

    //
    // Walk the list of contexts looking for the one that holds the event
    // event.
    //
    LockAcceptContextList();

    for ( pEntry = g_AcceptContextList.Flink;
          pEntry != &g_AcceptContextList;
          pEntry = pEntry->Flink )
    {
        pContextEntry =  CONTAINING_RECORD( pEntry, ACCEPT_CONTEXT_ENTRY , ListEntry );
        pAcceptContext = pContextEntry->m_pAcceptContext;

        fSuccess = pAcceptContext->RemoveAcceptEvent( hEvent,
                                                      pUserData,
                                                      &fFound );

        if ( fFound )
        {
            DBG_ASSERT( fSuccess );  // to catch the cause for 682348
            UnlockAcceptContextList();
            return fSuccess;
        }
    }

    UnlockAcceptContextList();

    DBG_ASSERT( 0 );  // to catch the cause for 682348

    return TRUE;
}

DWORD WINAPI PASV_ACCEPT_CONTEXT::AcceptThreadFunc( LPVOID pvContext )
/*++

      Thread function for the thread that waits on the accept events

  Arguments:
      pvContext - context pointer (pointer to PASV_ACCEPT_CONTEXT object)

  Returns:
     Nothing useful
--*/

{
    PPASV_ACCEPT_CONTEXT pAcceptContext = NULL;
    WSAEVENT *phAcceptEvents = NULL;
    DWORD dwNumEvents = 0;
    DWORD dwRet = 0;
    WSAEVENT *phNeedUpdate = NULL;
    WSAEVENT *phCanUpdate = NULL;
    WSAEVENT *phHaveUpdated = NULL;
    WSAEVENT *phExitThread = NULL;

    DBG_ASSERT( pvContext );

    pAcceptContext = (PPASV_ACCEPT_CONTEXT) pvContext;
    phAcceptEvents = pAcceptContext->m_ahEvents;
    dwNumEvents = pAcceptContext->m_dwNumEvents;
    phNeedUpdate = &phAcceptEvents[NEEDUPDATE_INDEX];
    phCanUpdate = &phAcceptEvents[CANUPDATE_INDEX];
    phHaveUpdated = &phAcceptEvents[HAVEUPDATED_INDEX];
    phExitThread = &phAcceptEvents[EXITTHREAD_INDEX];

loop:

    // wait timeout should be fairly small, so we can go through list and purge all
    // sockets that have been inactive a given # of timeouts

    dwRet = WSAWaitForMultipleEvents( dwNumEvents,
                                      phAcceptEvents,
                                      FALSE,
                                      PASV_TIMEOUT_INTERVAL,
                                      FALSE );

    if ( dwRet <= (WSA_WAIT_EVENT_0 + dwNumEvents - 1) )
    {
        //
        // One of the events was signalled
        //
        DWORD dwIndex = dwRet - WSA_WAIT_EVENT_0;

        switch (dwIndex)
        {
        case (NEEDUPDATE_INDEX):

            //
            // Somebody wants to update the list of events to watch for, so signal that
            // they can do so and wait for them to tell us they're done with the update
            //
            if ( !WSAResetEvent( *phNeedUpdate ) ) //back to known state
            {
                DBGWARN((DBG_CONTEXT,
                           "WSAResetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( !WSASetEvent( *phCanUpdate ) )
            {
                DBGWARN((DBG_CONTEXT,
                           "WSASetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( WSAWaitForMultipleEvents( 1,
                                           phHaveUpdated,
                                           TRUE,
                                           INFINITE,
                                           FALSE )  == WSA_WAIT_FAILED )
            {
                DBGERROR((DBG_CONTEXT,
                           "WSAWaitForMultipleEvents failed : 0x%x\n",
                           WSAGetLastError()));
            }

            if ( !WSAResetEvent( *phHaveUpdated ) ) //back to known state
            {
                DBGWARN((DBG_CONTEXT,
                           "WSAResetEvent failed : 0x%x\n",
                           WSAGetLastError()));
            }

            dwNumEvents = pAcceptContext->m_dwNumEvents;

            break;

        case (CANUPDATE_INDEX):
        case (HAVEUPDATED_INDEX):

            //
            // Should never happen !
            //
            IF_DEBUG ( PASV )
            {
                DBGERROR((DBG_CONTEXT,
                           "Invalid event signalled !\n"));
            }

            break;

        case (EXITTHREAD_INDEX):

            //
            // We're all done
            //
            IF_DEBUG ( PASV )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Exiting thread watching for PASV events....\n"));
            }

            return 0;

        default:
        {
            LPUSER_DATA pUserData = NULL;

            //
            // One of the sockets has become accept()'able.
            //
            IF_DEBUG ( PASV )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Got an acceptable socket, index : %i, context : 0x%x\n",
                           dwIndex, pAcceptContext->m_apUserData[dwIndex]));
            }

            pUserData = pAcceptContext->m_apUserData[dwIndex];

            //
            // Remove the data associated with the socket
            //
            memmove( (PVOID) (pAcceptContext->m_ahEvents + dwIndex),
                     (PVOID) (pAcceptContext->m_ahEvents + (dwIndex + 1) ),
                     sizeof(WSAEVENT) * (dwNumEvents - dwIndex - 1) );

            memmove( (PVOID) ( pAcceptContext->m_apUserData + dwIndex ),
                     (PVOID) (pAcceptContext->m_apUserData + (dwIndex + 1) ),
                     sizeof(LPUSER_DATA) * (dwNumEvents - dwIndex - 1) );

            memmove( (PVOID) (pAcceptContext->m_adwNumTimeouts + dwIndex),
                     (PVOID) (pAcceptContext->m_adwNumTimeouts + (dwIndex + 1) ),
                     sizeof(DWORD) * (dwNumEvents - dwIndex - 1) );

            pAcceptContext->m_dwNumEvents--;

            dwNumEvents = pAcceptContext->m_dwNumEvents;

            //
            // deal with restarting processing
            //
            SignalAcceptableSocket( pUserData );
        }
        }
    }
    else if ( dwRet == WSA_WAIT_TIMEOUT )
    {
        //
        // wait timed out, so go through the list of events and remove those that have
        // timed out too often
        //
        for ( DWORD i = LASTPREALLOC_INDEX;//skip the events that don't have a fixed # of timeouts
              i < dwNumEvents;
              i++ )
        {
            if ( pAcceptContext->m_adwNumTimeouts[i] == MAX_PASV_TIMEOUTS )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "timing out socket at index %i, context 0x%x \n",
                           i,
                           pAcceptContext->m_apUserData[i]));

                CleanupTimedOutSocketContext( pAcceptContext->m_apUserData[i] );

                memmove( (PVOID) (pAcceptContext->m_ahEvents + i),
                         (PVOID) (pAcceptContext->m_ahEvents + (i+1) ),
                         sizeof(WSAEVENT) * (dwNumEvents - i - 1) );

                memmove( (PVOID) ( pAcceptContext->m_apUserData + i ),
                         (PVOID) (pAcceptContext->m_apUserData + (i+1) ),
                         sizeof(LPUSER_DATA) * (dwNumEvents - i - 1) );

                memmove( (PVOID) (pAcceptContext->m_adwNumTimeouts + i),
                         (PVOID) (pAcceptContext->m_adwNumTimeouts + (i+1) ),
                         sizeof(DWORD) * (dwNumEvents - i - 1) );

                //
                // need to readjust the index and number of items in the array
                //
                i--;
                dwNumEvents--;

                pAcceptContext->m_dwNumEvents--;
            }
            else
            {
                pAcceptContext->m_adwNumTimeouts[i]++;
            }
        }

        dwNumEvents = pAcceptContext->m_dwNumEvents;
    }
    else if ( dwRet == WAIT_IO_COMPLETION )
    {
        DBGWARN((DBG_CONTEXT,
                   "Invalid value from WSAWaitForMultipleEvents !\n"));
    }
    else if ( dwRet == WSA_WAIT_FAILED )
    {
        dwRet = WSAGetLastError();

        DBG_ASSERT( dwRet == WSA_INVALID_HANDLE );

        //
        // we could get this error during shutdown if one of the events is
        // invalidated before we get the exit signal. test for it and exit
        // gracefully
        //

        if ( WSAWaitForMultipleEvents(1,
                                      phExitThread,
                                      TRUE,
                                      0,
                                      FALSE ) == WSA_WAIT_EVENT_0) {
            return 0;
        }

        DBG_ASSERT( 0 );
        DBG_ASSERT( WSAGetLastError() );
    }
    else
    {
        DBGERROR((DBG_CONTEXT,
                   "WSAWaitForMultipleEvents returned 0x%x, error : 0x%x\n",
                   dwRet, WSAGetLastError()));
    }

    goto loop;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\connect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    connect.cxx

    This module contains the main function for handling new connections.
    After receiving a new connection this module creates a new USER_DATA
    object to contain the information about a connection for processing.


    Functions exported by this module:

        FtpdNewConnection
        FtpdNewConnectionEx


    FILE HISTORY:
        KeithMo     08-Mar-1993 Created.
        MuraliK     03-April-1995
           Rewrote to separate the notion of one thread/control connection +
           other mods.
        MuraliK    11-Oct-1995
           Completely rewrote to support AcceptEx connections

*/


#include "ftpdp.hxx"


static CHAR PSZ_SERVICE_NOT_AVAILABLE[] =
  "Service not available, closing control connection.";


//
//  Private prototypes.
//



VOID
FtpReqResolveCallback(
    ADDRCHECKARG pArg,
    BOOL fSt,
    LPSTR pName
    )
{
    // ignore fSt : DNS name is simply unavailable

    //((LPUSER_DATA)pArg)->Reference();

    if ( !AtqPostCompletionStatus( ((LPUSER_DATA)pArg)->QueryControlAio()->QueryAtqContext(),
                                   0 ))
    {
        DereferenceUserDataAndKill( ((LPUSER_DATA)pArg) );
    }
}



BOOL
ProcessNewClient(
    IN SOCKET       sNew,
    IN PVOID        EndpointObject,
    IN FTP_SERVER_INSTANCE *pInstance,
    IN BOOL         fMaxConnExceeded,
    IN PSOCKADDR_IN psockAddrRemote,
    IN PSOCKADDR_IN psockAddrLocal = NULL,
    IN PATQ_CONTEXT patqContext    = NULL,
    IN PVOID        pvBuff         = NULL,
    IN DWORD        cbWritten      = 0,
    OUT LPBOOL      pfAtqToBeFreed = NULL
    )
{
    LPUSER_DATA     pUserData = NULL;

    DWORD           err     = NO_ERROR;
    BOOL            fReturn  = FALSE;
    DBG_CODE( CHAR  pchAddr[32];);
    BOOL            fSockToBeFreed = TRUE;
    BOOL            fDereferenceInstance = FALSE;
    AC_RESULT       acIpAccess;
    BOOL            fNeedDnsCheck = FALSE;
    BOOL            fValid;
    BOOL            fUnbindOnFail;

    DBG_CODE( InetNtoa( psockAddrRemote->sin_addr, pchAddr));

    if ( pfAtqToBeFreed != NULL) {
        *pfAtqToBeFreed = TRUE;
    }

    //
    // Create a new connection object
    //

    if ( !fMaxConnExceeded ) {
        pUserData = pInstance->AllocNewConnection();
    }

    if ( pUserData != NULL) {

        pUserData->QueryAccessCheck()->BindAddr( (PSOCKADDR)psockAddrRemote );
        if ( !pUserData->BindInstanceAccessCheck() ) {
            fValid = FALSE;
            fUnbindOnFail = FALSE;
        }
        else {
            fUnbindOnFail = TRUE;
            acIpAccess = pUserData->QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck );

            if ( (acIpAccess == AC_IN_DENY_LIST) ||
                 ((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) ) {

                SockPrintf2(
                    NULL,
                    sNew,
                    "%u Connection refused, unknown IP address.",
                    REPLY_NOT_LOGGED_IN
                    );

                fValid = FALSE;
            }
            else {
                fValid = TRUE;
            }
        }

        //
        // Start off processing this client connection.
        //
        //  Once we make a reset call, the USER_DATA object is created
        //    with the socket and atq context.
        //  From now on USER_DATA will take care of freeing
        // ATQ context & socket
        //


        if (fValid) {

            fSockToBeFreed = FALSE;

            fValid = pUserData->Reset(sNew,
                              EndpointObject,
                              psockAddrRemote->sin_addr,
                              psockAddrLocal,
                              patqContext,
                              pvBuff,
                              cbWritten,
                              acIpAccess );
        }

        if ( fValid ) {

            IF_DEBUG( CLIENT) {

                CHKINFO( ( DBG_CONTEXT,
                            " Established a new connection to %s"
                            " ( Socket = %d)\n",
                            pchAddr,
                            sNew));
            }

            //
            // At this point we have the context for the AcceptExed socket.
            //  Set the context in the AtqContext if need be.
            //

            if ( patqContext != NULL) {

                //
                // Associate client connection object with this control socket
                //  handle for future completions.
                //

                AtqContextSetInfo(patqContext,
                                  ATQ_INFO_COMPLETION_CONTEXT,
                                  (ULONG_PTR) pUserData->QueryControlAio());
            }

            if ( fNeedDnsCheck )
            {
                if ( !pUserData->QueryAccessCheck()->IsDnsResolved() ) {

                    BOOL fSync;
                    LPSTR pDns;

                    pUserData->SetNeedDnsCheck( TRUE );

                    if ( pUserData->QueryAccessCheck()->QueryDnsName( &fSync,
                            (ADDRCHECKFUNCEX)FtpReqResolveCallback,
                            (ADDRCHECKARG)pUserData,
                            &pDns )
                         && !fSync ) {

                        return TRUE;
                    }
                }
            }
            else {
                pUserData->UnbindInstanceAccessCheck();
            }

            DBG_REQUIRE( pUserData->Reference() > 0);

            fReturn = pUserData->ProcessAsyncIoCompletion(0, NO_ERROR,
                                                          pUserData->
                                                          QueryControlAio()
                                                          );

            if ( !fReturn) {

                err = GetLastError();

                IF_DEBUG( ERROR) {

                    CHKINFO(( DBG_CONTEXT,
                               " Unable to start off a read to client(%s,%d)."
                               " Error = %lu\n",
                               pchAddr,
                               sNew,
                               err ));
                }
            }

            //
            // Decrement the ref count and free the connection.
            //

            DBG_ASSERT( (err == NO_ERROR) || pUserData->QueryReference() == 1);

            DereferenceUserDataAndKill( pUserData);

        } else {

            if ( fUnbindOnFail )
            {
                pUserData->UnbindInstanceAccessCheck();
            }

            // reset operation failed. relase memory and exit.
            err = GetLastError();

            pUserData->Cleanup();
            pInstance->RemoveConnection( pUserData);
            pUserData = NULL;
        }

    } else {

        err = GetLastError();
        fDereferenceInstance = TRUE;
    }

    if ( (pUserData == NULL) || (err != NO_ERROR) ) {

        //
        // Failed to allocate new connection
        // Reasons:
        //   1) Max connecitons might have been exceeded.
        //   2) Not enough memory is available.
        //   3) Access check failed
        //
        //  handle the failures and notify client.
        //

        if ( fMaxConnExceeded) {

            CHAR rgchBuffer[MAX_REPLY_LENGTH];
            DWORD len;

            //
            // Unable to insert new connection.
            //  The maxConnections may have exceeded.
            // Destroy the client connection object and return.
            // Possibly need to send an error message.
            //


            IF_DEBUG( ERROR) {

                CHKINFO( ( DBG_CONTEXT,
                            " MaxConnections Exceeded. "
                            " Connection from %s refused at socket %d\n",
                            pchAddr, sNew));
            }

            // Format a message to send for the error case.

            pInstance->LockConfig();

            LPCSTR  pszMsg = pInstance->QueryMaxClientsMsg();
            pszMsg = (pszMsg == NULL) ? PSZ_SERVICE_NOT_AVAILABLE : pszMsg;

            len = FtpFormatResponseMessage(REPLY_SERVICE_NOT_AVAILABLE,
                                           pszMsg,
                                           rgchBuffer,
                                           MAX_REPLY_LENGTH);

            pInstance->UnLockConfig();
            DBG_ASSERT( len < MAX_REPLY_LENGTH);

            // Send the formatted message
            // Ignore error in sending this message.
            SockSend( NULL, sNew, rgchBuffer, len);

        } else {

            // not enough memory for running this client connection

            const CHAR * apszSubStrings[1];
            CHAR pchAddr2[32];

            InetNtoa( psockAddrRemote->sin_addr, pchAddr2 );

            apszSubStrings[0] = pchAddr2;

            g_pInetSvc->LogEvent(FTPD_EVENT_CANNOT_CREATE_CLIENT_THREAD,
                                  1,
                                  apszSubStrings,
                                  err );

            IF_DEBUG( ERROR) {

                CHKINFO(( DBG_CONTEXT,
                           "Cannot create Client Connection for %s,"
                           " Error %lu\n",
                           pchAddr,
                           err ));
            }

            //
            // Send a message to client if the socket is to be freed.
            // If it is already freed, then we cannot send message
            //

            if ( fSockToBeFreed) {

                SockPrintf2(NULL, sNew,
                            "%u Service not available,"
                            " closing control connection.",
                            REPLY_SERVICE_NOT_AVAILABLE );
            } else {

                IF_DEBUG( CLIENT) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                " Unable to send closed error message to "
                                " %s (%d)\n",
                                pchAddr2, sNew
                                ));
                }
            }
        }


        //
        // Unable to create a new connection object.
        //  Report error and shut this.
        //

        IF_DEBUG( ERROR) {

            CHKINFO( ( DBG_CONTEXT,
                        "Cannot create new FTP Request object to %s."
                        " Error= %u\n",
                        pchAddr,
                        err));
        }

        if ( fSockToBeFreed ) {

            if ( patqContext != NULL) {

                // ensure that socket is shut down.
                DBG_REQUIRE( AtqCloseSocket( patqContext, TRUE));
            } else {

                CloseSocket( sNew);
            }
        }

        fReturn = (FALSE);

    }  // if ( pcc == NULL)


    if ( pfAtqToBeFreed != NULL) {

        *pfAtqToBeFreed = fSockToBeFreed;
    }

    if ( fDereferenceInstance ) {

        pInstance->DecrementCurrentConnections();
        pInstance->Dereference();
    }

    return (fReturn);

} // ProcessNewClient()



//
//  Public functions.
//



VOID
FtpdNewConnection(
    IN SOCKET sNew,
    IN SOCKADDR_IN * psockaddr,
    IN PVOID EndpointContext,
    IN PVOID EndpointObject
    )
/*++

  Call back function for processing the connections from clients.
  This function creates a new UserData object if permitted for the new
   client request and starts off a receive for the given connection
   using Async read on control channel established.

  Arguments:
     sNew       control socket for the new client connection
     psockAddr  pointer to the client's address.

  Returns:
     None

  History:
        KeithMo     08-Mar-1993 Created.
        MuraliK     04-April-1995
                         ReCreated for using async Io threading model.
--*/
{
    BOOL            fProcessed;
    BOOL            fMaxConnExceeded;
    INT             cbAddr = sizeof(SOCKADDR);
    SOCKADDR_IN     sockaddr;

    FTP_SERVER_INSTANCE *pInstance;

    DBG_ASSERT( sNew != INVALID_SOCKET );
    DBG_ASSERT( psockaddr != NULL );
    DBG_ASSERT( psockaddr->sin_family == AF_INET );     // temporary

    g_pFTPStats->IncrConnectionAttempts();

    if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {

        IF_DEBUG( ERROR) {

            DBG_CODE( CHAR pchAddr[32];);

            DBG_CODE( InetNtoa(((SOCKADDR_IN *) psockaddr)->sin_addr,
                               pchAddr));

            CHKINFO( ( DBG_CONTEXT,
                        "Service is not running or AccessCheck failed for"
                        " Connection from %s\n",
                        pchAddr));
        }

        SockPrintf2(NULL,
                    sNew,
                    "%u %s",  // the blank after %u is essential
                    REPLY_SERVICE_NOT_AVAILABLE,
                    "Service not available, closing control connection." );

        goto error_exit;

    }

    if (getsockname( sNew, (PSOCKADDR)&sockaddr, &cbAddr ) != 0) {
        goto error_exit;
    }

    //
    // Find Instance
    //

    pInstance = (FTP_SERVER_INSTANCE *)
        ((PIIS_ENDPOINT)EndpointContext)->FindAndReferenceInstance(
                                (LPCSTR)NULL,
                                sockaddr.sin_addr.s_addr,
                                &fMaxConnExceeded
                                );

    if ( pInstance == NULL ) {

        //
        //  Site is not permitted to access this server.
        //  Dont establish this connection. We should send a message.
        //

        SockPrintf2(NULL, sNew,
                    "%u Connection refused, unknown IP address.",
                    REPLY_NOT_LOGGED_IN);

        goto error_exit;
    }

    fProcessed = ProcessNewClient( sNew,
                                   EndpointObject,
                                   pInstance,
                                   fMaxConnExceeded,
                                   psockaddr);

    if ( fProcessed) {
        pInstance->QueryStatsObj()->CheckAndSetMaxConnections();
    }

    return;

error_exit:

    CloseSocket( sNew);
    return;

} // FtpdNewConnection()



VOID
FtpdNewConnectionEx(
   IN VOID *       patqContext,
   IN DWORD        cbWritten,
   IN DWORD        dwError,
   IN OVERLAPPED * lpo
   )
/*++
    Description:

        Callback function for new connections when using AcceptEx.
        This function verifies if this is a valid connection
         ( maybe using IP level authentication)
         and creates a new connection object

        The connection object is added to list of active connections.
        If the max number of connections permitted is exceeded,
          the client connection object is destroyed and
          connection is rejected.

    Arguments:

       patqContext:   pointer to ATQ context for the IO operation
       cbWritten:     count of bytes available from first read operation
       dwError:       error if any from initial operation
       lpo:           indicates if this function was called as a result
                       of IO completion or due to some error.

    Returns:

        None.

--*/
{
    BOOL            fProcessed = FALSE;
    BOOL            fAtqContextToBeFreed = TRUE;
    BOOL            fMaxConnExceeded;
    PSOCKADDR_IN    psockAddrLocal  = NULL;
    PSOCKADDR_IN    psockAddrRemote = NULL;
    SOCKET          sNew   = INVALID_SOCKET;
    PVOID           pvBuff = NULL;
    PIIS_ENDPOINT   pEndpoint;
    FTP_SERVER_INSTANCE *pInstance;

    if ( (dwError != NO_ERROR) || !lpo) {

        DBGPRINTF(( DBG_CONTEXT, "FtpdNewConnectionEx() completion failed."
                   " Error = %d. AtqContext=%08x\n",
                   dwError, patqContext));

        //
        // For now free up the resources.
        //

        goto exit;
    }

    g_pFTPStats->IncrConnectionAttempts();

    DBG_ASSERT( patqContext != NULL);

    AtqGetAcceptExAddrs( (PATQ_CONTEXT ) patqContext,
                         &sNew,
                         &pvBuff,
                         (PVOID*)&pEndpoint,
                         (PSOCKADDR *)&psockAddrLocal,
                         (PSOCKADDR *)&psockAddrRemote);

    DBG_ASSERT( pEndpoint != NULL );
    IF_DEBUG( CONNECTION ) {

        DBGPRINTF(( DBG_CONTEXT,
                   " New connection. AtqCont=%08x, buff=%08x, cb=%d\n",
                   patqContext, pvBuff, cbWritten));
    }

    if ( g_pInetSvc->QueryCurrentServiceState() != SERVICE_RUNNING ) {

        DBGPRINTF((DBG_CONTEXT,"Connection attempt on inactive service\n"));

        SockPrintf2(NULL,
                    sNew,
                    "%u %s",  // the blank after %u is essential
                    REPLY_SERVICE_NOT_AVAILABLE,
                    "Service not available, closing control connection." );

        goto exit;
    }

    //
    // Find Instance
    //

    pInstance = (FTP_SERVER_INSTANCE*)pEndpoint->FindAndReferenceInstance(
                                (LPCSTR)NULL,
                                psockAddrLocal->sin_addr.s_addr,
                                &fMaxConnExceeded
                                );

    if (pInstance == NULL ) {

        //
        //  Site is not permitted to access this server.
        //  Dont establish this connection. We should send a message.
        //

        DBGPRINTF((DBG_CONTEXT,
            "Unable to find instance [err %d]\n",GetLastError()));
        goto exit;
    }

    //
    //  Set the timeout for future IOs on this context
    //

    AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                       ATQ_INFO_TIMEOUT,
                       (ULONG_PTR) pInstance->QueryConnectionTimeout()
                       );

    if ( pInstance->QueryBandwidthInfo() )
    {
        AtqContextSetInfo( (PATQ_CONTEXT) patqContext,
                           ATQ_INFO_BANDWIDTH_INFO,
                           (ULONG_PTR) pInstance->QueryBandwidthInfo() );
    }

    fProcessed = ProcessNewClient( sNew,
                                   NULL,
                                   pInstance,
                                   fMaxConnExceeded,
                                   psockAddrRemote,
                                   psockAddrLocal,
                                   (PATQ_CONTEXT ) patqContext,
                                   pvBuff,
                                   cbWritten,
                                   &fAtqContextToBeFreed);

    if ( fProcessed) {
        pInstance->QueryStatsObj()->CheckAndSetMaxConnections();
    }

exit:

    if ( !fProcessed && fAtqContextToBeFreed ) {

        //
        // We failed to process this connection. Free up resources properly
        //

        DBG_REQUIRE( AtqCloseSocket( (PATQ_CONTEXT )patqContext, FALSE));
        AtqFreeContext( (PATQ_CONTEXT ) patqContext, TRUE );
    }

    return;

} // FtpdNewConnectionEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\dbgutil.h ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

        Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Revision History:

       MuraliK   21-March-1995    Made local copy from template for FTP server
                                     This replaces old "debug.hxx" of FTPsvc.
       MuraliK   1-Npv-1996       Updated dbgutil.h 
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_

/************************************************************
 *     Include Headers
 ************************************************************/

// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

# include <pudebug.h>

//
//  Define the debugging constants
//

# define DEBUG_VIRTUAL_IO                 0x00001000
# define DEBUG_CLIENT                     0x00002000
# define DEBUG_ASYNC_IO                   0x00004000
# define DEBUG_DIR_LIST                   0x00008000

# define DEBUG_SOCKETS                    0x00010000
# define DEBUG_SEND                       0x00020000
# define DEBUG_RECV                       0x00040000
# define DEBUG_CONFIG                     0x00080000

# define DEBUG_INSTANCE                   0x00100000

# define DEBUG_SERVICE_CTRL               0x01000000
# define DEBUG_SECURITY                   0x02000000
# define DEBUG_USER_DATABASE              0x04000000
# define DEBUG_RPC                        0x08000000

# define DEBUG_CONNECTION                 0x10000000
# define DEBUG_PARSING                    0x20000000
# define DEBUG_COMMANDS                   0x40000000
# define DEBUG_CRITICAL_PATH              0x80000000

# define DEBUG_PASV                        0x00200000

# define IF_SPECIAL_DEBUG( arg)      IF_DEBUG( arg)


# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\engine.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993-1995           **/
/**********************************************************************/

/*
    engine.cxx

    Command parser & execution for FTPD Service.  This module parses
    and executes the commands received from the control socket.

    Functions exported by this module:
      All function for processing FTP commands

    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     21-March-1995  Modified to use common TsLogonUser()
                                      supporting anonymous logon.
        MuraliK     27-Mar - April 1995
              Cleaning up FTP server engine for
                 - to support new Internet services interface.
                 - to support Async Io Transfers
                 - split and move the command tables to ftpcmd.cxx
                 - to replace USER_DATA::DataSocket with
                       USER_DATA::m_AioDataConnection
                 - moved SiteSTATS and statistics to ftpcmd.cxx
                 - replaced SockReply2 with ReplyToUser()
                 - modified MainREIN and MainQUIT to use
                       new USER_DATA functions.
                 - modified usage of listing functions.
                 - SendErrorToClient() used for managing and sending
                       error message to client.
                 - message strings removed to be top of the file and defined.
                 - size of file sent along before file is transferred.
        terryk      18-Sep-1996 add MainSize
*/

#include "ftpdp.hxx"
#include "ftpcmd.hxx"
#include <stdlib.h>
#include <limits.h>

//
//  Private constants.
//


//
// Since the default RFC port for ftp is 21, we calculate the Data port
//   value from it.
// However, an admin at a site may change the port number to something else
//  ==> this will create PROBLEMS..... NYI
//

/**************************************************
 *  Constant Message Strings used by this Module
 **************************************************/

//
// Below is a list of strings, which are in
//   CStrM( StringName,  ActualString)  format
// The following table contains globally all strings used within this module
//  Advantage:  One place to look for various strings
//               + possible internationalization
//  Be careful. None of these messages may be modified. Protocol may break.
//  This will be expanded into
//  const char  PSZ_StringName[] = ActualString;   and
//  enumerated value  LEN_StringName = sizeof( ActualString).
//
# define ConstantStringsForThisModule()            \
  CStrM( CANNOT_OPEN_DATA_CONNECTION, "Can't open data connection.")   \
  CStrM( TRANSFER_ABORTED,    "Connection closed; transfer aborted.")  \
  CStrM( USER_NOT_LOGGED_IN,          "User %s cannot log in.")        \
  CStrM( INSUFFICIENT_RESOURCES, "Insufficient system resources.")     \
  CStrM( REQUEST_ID_FOR_ANONYMOUS,                                     \
         "Anonymous access allowed, send identity (e-mail name) as password.")\
  CStrM( REQUEST_PASSWORD_FOR_USER,  "Password required for %s.")      \
  CStrM( COMMAND_NOT_IMPLEMENTED,    "%s command not implemented." )   \
  CStrM( COMMAND_SUCCESSFUL,         "%s command successful." )        \
  CStrM( SERVICE_READY,              "Service ready for new user.")    \
  CStrM( ENTERING_PASSIVE_MODE,      \
        "Entering Passive Mode (%d,%d,%d,%d,%d,%d).")                  \
  CStrM( FORM_MESSAGE,                "Form must be N or T." )         \
  CStrM( TYPE_NOT_IMPLEMENTED,        "Type %c not implemented.")      \
  CStrM( BYTE_SIZE_SPEC,              "Byte size must be 8." )         \
  CStrM( TYPE_SET_TO,                 "Type set to %c.")               \
  CStrM( UNIMPLEMENTED_STRU_TYPE,     "Unimplemented STRU type." )     \
  CStrM( INVALID_STRU_TYPE,           "Invalid STRU type." )     \
  CStrM( STRU_TYPE_OK,                "STRU %c ok.")                   \
  CStrM( UNIMPLEMENTED_MODE,          "Unimplemented MODE type.")      \
  CStrM( MODE_OK,                     "Mode %c ok.")                   \
  CStrM( REPLY_MARKER_SPEC,           "Reply marker is invalid.")       \
  CStrM( REPLY_RESTARTING,            "Restarting at %s." )             \
  CStrM( READY_FOR_DEST_FILE, "File exists, ready for destination name" )   \
  CStrM( BAD_COMMAND_SEQUENCE,        "Bad sequence of commands." )    \
  CStrM( CURRENT_DIRECTORY,           "\"%s\" is current directory.")  \
  CStrM( VERSION_INFO,                "Windows_NT")                    \
  CStrM( SERVER_STATUS_BEGIN,         " %s Windows NT FTP Server status:")  \
  CStrM( SERVER_STATUS_END,           "End of status.")                \
  CStrM( FILE_STATUS,                 "status of %s:")                 \
  CStrM( MSDOS_DIRSTYLE,              "MSDOS-like directory output is %s") \
  CStrM( DIRECTORY_ANNOTATION,        "directory annotation is %s")    \
  CStrM( LOGGED_IN_USER_MESSAGE,      "Anonymous user logged in%s.") \
  CStrM( USER_LOGGED_IN,              "User %s logged in%s.")          \
  CStrM( USER_CANNOT_LOG_IN,          "User %s cannot log in.")        \
  CStrM( INACCESSIBLE_HOME_DIR,                                        \
        "User %s cannot log in, home directory inaccessible.")         \
  CStrM( LICENSE_QUOTA_EXCEEDED,                                       \
        "User %s cannot log in, license quota exceeded.")              \
  CStrM( NO_GUEST_ACCESS,                                              \
        "User %s cannot log in, guest access not allowed.")            \
  CStrM( ANONYMOUS_NAME,              "Anonymous") /* must match userdb.cxx */ \
  CStrM( FTP_NAME,                    "Ftp")                           \
  CStrM( ARGS_DELIMITER,              " \t")                           \
  CStrM( NO_FILE_OR_DIRECTORY,        "No such file or directory.")    \
  CStrM( DIRECTORY_CREATE,            "\"%s\" directory created.")     \
  CStrM( CANNOT_CREATE_FILE,          "Cannot create file.")           \
  CStrM( CANNOT_CREATE_UNIQUE_FILE,   "Cannot create unique file.")    \
  CStrM( INVALID_COMMAND,             "Invalid %s Command.")           \
  CStrM( RESPONSE_ON,                 "on")                            \
  CStrM( RESPONSE_OFF,                "off")                           \
  CStrM( GUEST_ACCESS,                " (guest access)" )              \
  CStrM( CREATE_VERB,                 "created" )                      \
  CStrM( APPEND_VERB,                 "appended" )                     \
  CStrM( USER_VERB,                   "USER" )                         \
  CStrM( PASSWORD_VERB,               "PASS" )                         \
  CStrM( QUIT_VERB,                   "QUIT" )                         \
  CStrM( ABORT_VERB,                  "ABORT" )                        \
  CStrM( REIN_VERB,                   "REIN" )                         \
  CStrM( DESTINATION_FILE_EXISTS,     "Destination file already exists.") \
  CStrM( RNFR_VERB,                   "RNFR" )                         \
  CStrM( RNTO_VERB,                   "RNTO" )                         \
  CStrM( DELE_VERB,                   "DELE" )                         \
  CStrM( RMD_VERB,                    "RMD" )                          \
  CStrM( MKD_VERB,                    "MKD" )                          \
  CStrM( CWD_VERB,                    "CWD" )                          \
  CStrM( DUMMY_END,  "DummyMsg. Add string before this one")


//
// Generate the strings ( these are private globals of this module).
//

# define CStrM( StringName, ActualString)   \
     const char PSZ_ ## StringName[] = ActualString ;

ConstantStringsForThisModule()

# undef CStrM



//
//  Private prototypes.
//

BOOL
ParseStringIntoAddress(
    LPSTR     pszString,
    LPIN_ADDR pinetAddr,
    LPPORT    pport
    );

BOOL
MyLogonUser(
    LPUSER_DATA pUserData,
    LPSTR       pszPassword,
    LPBOOL      pfHomeDirFailure,
    LPBOOL      pfLicenseExceeded
    );

DWORD
DetermineUserAccess(FTP_SERVER_INSTANCE *pInstance);

//
//  Public functions.
//



//
//  Functions Implementing FTP functionality.
//


BOOL
MainUSER(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  Implements the USER command.
  Format:    USER <userName>

  Arguments:
    pUserData  - the user initiating the request.
    pszArg     - Command arguments. Will be NULL if no arguments given.

  Returns:
    BOOL - TRUE if arguments are OK; FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    LPFTP_SERVER_STATISTICS pStatsObj = pUserData->QueryInstance()->QueryStatsObj();

    DBG_ASSERT( pStatsObj != NULL );

    if( pUserData->IsLoggedOn()) {

        if( TEST_UF( pUserData, ANONYMOUS ) ) {
            pStatsObj->DecrCurrentAnonymousUsers();
        } else {
            pStatsObj->DecrCurrentNonAnonymousUsers();
        }

        SET_UF( pUserData, LOGGED_ON);
    }

    //
    //  Squirrel away a copy of the domain\user name for later.
    //  If the name is too long, then don't let them logon.
    //

    if ( strlen( pszArg ) >= ( MAX_USERNAME_LENGTH ) ) {

        ReplyToUser(pUserData,
                    REPLY_NOT_LOGGED_IN,
                    PSZ_USER_NOT_LOGGED_IN,
                    pszArg );

    } else {

        BOOL   fNameIsAnonymous;
        LPCSTR pszReply;

        fNameIsAnonymous = ( ( _stricmp( pszArg, PSZ_ANONYMOUS_NAME ) == 0 ) ||
                            ( _stricmp( pszArg, PSZ_FTP_NAME ) == 0 )
                            );

        pUserData->SetUserName( pszArg );

        if( fNameIsAnonymous ) {

            SET_UF( pUserData, ANONYMOUS );
        } else {

            CLEAR_UF( pUserData, ANONYMOUS );
        }

        //
        // remember that we're waiting for PASS command in case we
        // get disconnected.
        //
        SET_UF( pUserData, WAIT_PASS );

        //
        //  If we already have an impersonation token, then remove it.
        //  This will allow us to impersonate the new user.
        //

        pUserData->FreeUserToken();

        //
        //  Tell the client that we need a password.
        //

        pszReply =(((fNameIsAnonymous) && pUserData->QueryInstance()->AllowAnonymous())
                   ? PSZ_REQUEST_ID_FOR_ANONYMOUS
                   : PSZ_REQUEST_PASSWORD_FOR_USER);

        ReplyToUser( pUserData,
                    REPLY_NEED_PASSWORD,
                    pszReply,
                    pszArg);

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateWaitingForPass);
        }
        pUserData->UnlockUser();
    }

    pUserData->WriteLogRecord( PSZ_USER_VERB, pszArg);

    return TRUE;

}   // MainUSER()



BOOL
MainPASS(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  Implements the PASS command.
  Format:  PASS <password>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DWORD dwError = NO_ERROR;

    DBG_ASSERT( pUserData != NULL );

    //
    //  PASS command only valid in WaitingForPass state.
    //

    DBG_ASSERT( pUserData->QueryState() == UserStateWaitingForPass );

    if( ( pszArg != NULL ) && ( strlen( pszArg ) > PWLEN ) ) {

        return FALSE;
    }

    //
    //  Try to logon the user.
    //
    BOOL   fHomeDirFailure;
    BOOL   fLicenseExceeded;

    DBG_ASSERT( pUserData->QueryUserToken() == NULL || pUserData->QueryInFakeIOCompletion());

    //
    // we got the PASS command we we're waiting for
    //
    CLEAR_UF( pUserData, WAIT_PASS );

    //
    // increment the number of logon attempts, only if we are not reprocessing this command
    // (which happens when an AD async home directory lookup completed)
    //
    if (!pUserData->QueryInFakeIOCompletion()) {
        pUserData->QueryInstance()->QueryStatsObj()->IncrLogonAttempts();
    }

    if (MyLogonUser(pUserData,
                    pszArg,
                    &fHomeDirFailure,
                    &fLicenseExceeded)) {

        const CHAR * pszGuestAccess =
          ( TEST_UF( pUserData, AS_GUEST) ? PSZ_GUEST_ACCESS : "");

        //
        //  Successful logon.
        //

        if( *pUserData->QueryUserName() != '-' )  {

            PCSTR pszMsg;

            pUserData->QueryInstance()->LockConfig();

            pszMsg = pUserData->QueryInstance()->QueryGreetingMsg();

            if( pszMsg && *pszMsg ) {

                pUserData->SendMultilineMessage(
                                             REPLY_USER_LOGGED_IN,
                                             pszMsg,
                                             TRUE,                    // first reply line
                                             FALSE);                  // lst reply line
            }

            pUserData->QueryInstance()->UnLockConfig();

            if( TEST_UF( pUserData, ANNOTATE_DIRS )) {

                pUserData->SendDirectoryAnnotation(
                                             REPLY_USER_LOGGED_IN,
                                             FALSE);                  // first reply line
            }
        }

        LPFTP_SERVER_STATISTICS pStats = pUserData->QueryInstance()->QueryStatsObj();
        DBG_ASSERT( pStats != NULL );

        if( TEST_UF( pUserData, ANONYMOUS ) ) {

            pStats->IncrAnonymousUsers();

            ReplyToUser(pUserData,
                        REPLY_USER_LOGGED_IN,
                        PSZ_LOGGED_IN_USER_MESSAGE,
                        pszGuestAccess );

        } else {

            pStats->IncrNonAnonymousUsers();

            ReplyToUser(pUserData,
                        REPLY_USER_LOGGED_IN,
                        PSZ_USER_LOGGED_IN,
                        pUserData->QueryUserName(),
                        pszGuestAccess );
        }

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateLoggedOn);
            SET_UF( pUserData, LOGGED_ON);
        }
        pUserData->UnlockUser();

    } else {

        dwError = GetLastError();

        if (dwError == ERROR_IO_PENDING) {
            //
            // an asynchronous request for user home directory is in progress
            // restore the state so that next time we get back in here again.
            // return and wait for the completion of the AD query
            //

            SET_UF( pUserData, WAIT_PASS );

            return TRUE;
        }

        const CHAR * pszReply = PSZ_USER_CANNOT_LOG_IN;

        //
        //  Logon failure.
        //

        if( fHomeDirFailure ) {

            pszReply = PSZ_INACCESSIBLE_HOME_DIR;

        } else if ( fLicenseExceeded) {

            pszReply = PSZ_LICENSE_QUOTA_EXCEEDED;

        } else if ( TEST_UF( pUserData, AS_GUEST) && ! pUserData->QueryInstance()->AllowGuestAccess()) {

            pszReply = PSZ_NO_GUEST_ACCESS;
        }

        ReplyToUser(pUserData,
                    REPLY_NOT_LOGGED_IN,
                    pszReply,
                    pUserData->QueryUserName() );

        pUserData->LockUser();
        if( pUserData->QueryState() != UserStateDisconnected ) {
            pUserData->SetState( UserStateWaitingForUser);
            CLEAR_UF( pUserData, LOGGED_ON);
            pUserData->ClearUserName();
        }
        pUserData->UnlockUser();
    }

    pUserData->WriteLogRecord( PSZ_PASSWORD_VERB,
                              (TEST_UF( pUserData, ANONYMOUS)) ? pszArg : NULL,
                              dwError);

    return TRUE;

}   // MainPASS()



BOOL
MainACCT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the ACCT command.
  This is at present not implemented...

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_SUPERFLUOUS,
                PSZ_COMMAND_NOT_IMPLEMENTED,
                "ACCT");

    return TRUE;

}   // MainACCT()




BOOL
MainCWD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the CWD command -- Change Working Directory.
  Format:  CWD <newDirectoryName>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  If argument is NULL or "~", CD to home directory.
    //

    if( ( pszArg == NULL ) || ( strcmp( pszArg, "~" ) == 0 ) ) {

        err = pUserData->CdToUsersHomeDirectory();

    } else {

        err = VirtualChDir( pUserData, pszArg);
    }

    if( err == NO_ERROR ) {

        if( TEST_UF( pUserData, ANNOTATE_DIRS ) &&
           ( *pUserData->QueryUserName() != '-' )
           ) {

            pUserData->SendDirectoryAnnotation(
                                           REPLY_FILE_ACTION_COMPLETED,
                                           TRUE);                        // first reply line
        }

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL,
                    "CWD");
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord(PSZ_CWD_VERB, pszArg, err);

    return TRUE;

}   // MainCWD()



BOOL
MainCDUP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  CDUP -- changes to the parent directory if possible.
--*/
{
    return MainCWD( pUserData, ".." );
}   // MainCDUP


BOOL
MainSIZE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements SIZE command - used for retrieving the size of a file.
  Format:  SIZE pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err = (!NO_ERROR);

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to open the file.
    //

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    if( err == NO_ERROR ) {

        // just return the file size
        err = pUserData->GetFileSize();
    }

    if( err != NO_ERROR ) {

        pUserData->SendErrorToClient(pszArg, err,
                                     PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->CloseFileForSend( err, TRUE);  // close the file, now that we're done. NoLogging
    return TRUE;

}   // MainSIZE()

BOOL
MainMDTM(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the MDTM command - used for retrieving the last
  modified time for a file. We open the file, get the file mod time, format
  it and send it.

  Format:  SIZE pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR      err = (!NO_ERROR);
    SYSTEMTIME  SystemTime;
    CHAR        rgchBuffer[sizeof("YYYYMMDDHHMMSS")];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to open the file.
    //

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    if( err == NO_ERROR ) {

        // Get the last write time.

        err = pUserData->GetFileModTime(&SystemTime);

        if (err == NO_ERROR) {
            // Format the time.
            DBG_REQUIRE(
                _snprintf(rgchBuffer, sizeof( rgchBuffer ),
                        "%.4hu%.2hu%.2hu%.2hu%.2hu%.2hu",
                        SystemTime.wYear & 0xFFF,   // this will give us to year 4095
                        SystemTime.wMonth & 0xF,    // this will let expanding the year into 15 months
                        SystemTime.wDay & 0x1F,     // did they design day of month with 5 bits in mind?
                        SystemTime.wHour & 0x1F,
                        SystemTime.wMinute & 0x3F,
                        SystemTime.wSecond & 0x3F) > 0);

            ReplyToUser( pUserData, REPLY_FILE_STATUS, rgchBuffer );
        }
    }

    if( err != NO_ERROR ) {

        pUserData->SendErrorToClient(pszArg, err,
                                     PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->CloseFileForSend( err, TRUE);  // close the file, now that we're done, NoLogging.
    return TRUE;

}   // MainMDTM()


BOOL
MainSMNT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the SMNT command.
  This is at present not implemented...

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_SUPERFLUOUS,
                PSZ_COMMAND_NOT_IMPLEMENTED,
                "SMNT");

    return TRUE;

}   // MainSMNT()




BOOL
MainQUIT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the QUIT command.
  Format:  QUIT

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    CHAR    rgchBuffer[MAX_REPLY_LENGTH];
    DWORD   len;
    LPCSTR  pszMsg;
    SOCKERR serr;

    DBG_ASSERT( pUserData != NULL );

    SET_UF( pUserData, CONTROL_QUIT);

    //
    //  Reply to the quit command.
    //

    pUserData->QueryInstance()->LockConfig();

    pszMsg = pUserData->QueryInstance()->QueryExitMsg();
    DBG_ASSERT( pszMsg != NULL);

    len = FtpFormatResponseMessage(REPLY_CLOSING_CONTROL,
                                   pszMsg,
                                   rgchBuffer,
                                   MAX_REPLY_LENGTH);
    pUserData->QueryInstance()->UnLockConfig();

    DBG_ASSERT( len <= MAX_REPLY_LENGTH);

    serr = SockSend( pUserData, pUserData->QueryControlSocket(),
                    rgchBuffer, len);

    //
    //  Cause a disconnection of the user.
    //  This will blow away the sockets first. Blowing off sockets
    //    will cause ATQ to wake up for pending data calls
    //    and send a call back indicating failure.
    //  Since we disconnect now, we will not submit any
    //    Reads to control socket ==> no more control calls come back from ATQ.
    //  At the call back processing we will decrement reference counts
    //    appropriate for cleanup.
    //

    pUserData->DisconnectUserWithError( NO_ERROR, FALSE);

    pUserData->WriteLogRecord( PSZ_QUIT_VERB, "");

    return TRUE;

}   // MainQUIT()



BOOL
MainREIN(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function executes REIN command - ReInitialize
  Format:  REIN

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    DBG_ASSERT( pUserData != NULL );

    pUserData->ReInitializeForNewUser();

    ReplyToUser(pUserData,
                REPLY_SERVICE_READY,
                PSZ_SERVICE_READY);

    pUserData->WriteLogRecord( PSZ_REIN_VERB, pszArg);

    return TRUE;

}   // MainREIN()



BOOL
MainPORT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the PORT command.
  Format:  PORT <ipAddress>,<portNumber>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    IN_ADDR DataIpAddress;
    PORT    DataPort;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Parse the string into address/port pair.
    //

    if( !ParseStringIntoAddress( pszArg,
                                 &DataIpAddress,
                                 &DataPort ) )
    {
        return FALSE;
    }

    //
    //  Determine if someone is trying to give us a bogus address/port.
    //  If the port number is less than IPPORT_RESERVED,
    //    then there is a possibility of port attack. Allow this only
    //    if port attack flag is enabled. This flag was renamed to
    //    enable_data_conn_to_3rd_ip
    //

    if (!pUserData->QueryInstance()->IsEnableDataConnTo3rdIP())
    {
	    if ( ( DataIpAddress.s_addr != pUserData->HostIpAddress.s_addr ) ||
    	     ( DataPort != CONN_PORT_TO_DATA_PORT(pUserData->LocalIpPort) &&
        	   ntohs( DataPort ) < IPPORT_RESERVED) )
        	{

            ReplyToUser(pUserData,
                        REPLY_UNRECOGNIZED_COMMAND,
                        PSZ_INVALID_COMMAND,
                        "PORT");

            return TRUE;
        }
    }


    //
    //  Save the address/port pair into per-user data.
    //

    pUserData->DataIpAddress = DataIpAddress;
    pUserData->DataPort = DataPort;

    //
    //  Disable passive mode for this user.
    //

    CLEAR_UF( pUserData, PASSIVE );

    //
    // Nuke any open data socket.
    //
    pUserData->CleanupPassiveSocket( TRUE );

    //
    //  Let the client know we accepted the port command.
    //

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL,
                "PORT");

    return TRUE;

}   // MainPORT()



BOOL
MainPASV(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the PASV command - used for setting passive mode.
  Format:  PASV

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.

--*/
{
    SOCKET        DataSocket = INVALID_SOCKET;
    SOCKERR       serr  = 0;
    SOCKADDR_IN   saddrLocal;
    INT           cbLocal;

    DBG_ASSERT( pUserData != NULL );

    //
    // Nuke the old passive socket
    //
    pUserData->CleanupPassiveSocket( TRUE );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Create a new data socket.
    //

    serr = CreateFtpdSocket( &DataSocket,
                             pUserData->LocalIpAddress.s_addr,
                             pUserData->QueryInstance() );

    if( serr == 0 )
    {
        //
        //  Determine the port number for the new socket.
        //

        cbLocal = sizeof(saddrLocal);

        if( getsockname( DataSocket, (SOCKADDR *)&saddrLocal, &cbLocal ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!
        //

        SET_UF( pUserData, PASSIVE );
        pUserData->SetPassiveSocket( DataSocket);
        pUserData->DataIpAddress = saddrLocal.sin_addr;
        pUserData->DataPort = saddrLocal.sin_port;

        ReplyToUser(pUserData,
                    REPLY_PASSIVE_MODE,
                    PSZ_ENTERING_PASSIVE_MODE,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b1,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b2,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b3,
                    saddrLocal.sin_addr.S_un.S_un_b.s_b4,
                    HIBYTE( ntohs( saddrLocal.sin_port ) ),
                    LOBYTE( ntohs( saddrLocal.sin_port ) ) );

    } else {

        //
        //  Failure during data socket creation/setup.  If
        //  we managed to actually create it, nuke it.
        //

        if( DataSocket != INVALID_SOCKET )
        {
            CloseSocket( DataSocket );
            DataSocket = INVALID_SOCKET;
        }

        //
        //  Tell the user the bad news.
        //

        ReplyToUser(pUserData,
                    REPLY_CANNOT_OPEN_CONNECTION,
                    PSZ_CANNOT_OPEN_DATA_CONNECTION);
    }

    return TRUE;

}   // MainPASV()



BOOL
MainTYPE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the TYPE command - used for setting type.
  Format:  TYPE type form <addl arguments>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    XFER_TYPE   newType;
    CHAR        chType;
    CHAR        chForm;
    LPSTR       pszToken;
    BOOL        fValidForm = FALSE;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER);

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid form type
    //  (only type N supported).
    //

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }

    chType = *pszToken;


    pszToken = strtok( NULL, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        chForm     = 'N';       // default
        fValidForm = TRUE;

    } else {

        switch( *pszToken ) {

          case 'n':
          case 'N':
            chForm     = 'N';
            fValidForm = TRUE;
            break;

          case 't':
          case 'T':
            chForm     = 'T';
            fValidForm = TRUE;
            break;

          case 'c':
          case 'C':
            chForm     = 'C';
            fValidForm = TRUE;
            break;

          default:
            fValidForm = FALSE;
            break;
        } // switch

    }

    //
    //  Determine the new transfer type.
    //

    switch( chType ) {

      case 'a':
      case 'A':
        if( !fValidForm ) {

            return FALSE;
        }

        if( ( chForm != 'N' ) && ( chForm != 'T' ) ) {

            ReplyToUser(pUserData,
                        REPLY_PARAMETER_NOT_IMPLEMENTED,
                        PSZ_FORM_MESSAGE);
            return TRUE;
        }

        newType = XferTypeAscii;
        chType  = 'A';
        break;

      case 'e':
      case 'E':
        if( !fValidForm ) {

            return FALSE;
        }

        if( ( chForm != 'N' ) && ( chForm != 'T' ) ) {

            ReplyToUser(pUserData,
                        REPLY_PARAMETER_NOT_IMPLEMENTED,
                        PSZ_FORM_MESSAGE);
            return TRUE;
        }

        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_TYPE_NOT_IMPLEMENTED, 'E');
        return TRUE;

      case 'i':
      case 'I':
        if( pszToken != NULL ) {

            return FALSE;
        }

        newType = XferTypeBinary;
        chType  = 'I';
        break;

    case 'l':
    case 'L':
        if( pszToken == NULL ) {

            return FALSE;
        }

        if( strcmp( pszToken, "8" ) != 0 ) {

            if( IsDecimalNumber( pszToken ) ) {

                ReplyToUser(pUserData,
                            REPLY_PARAMETER_NOT_IMPLEMENTED,
                            PSZ_BYTE_SIZE_SPEC);

                return TRUE;
            } else {

                return FALSE;
            }
        }

        newType = XferTypeBinary;
        chType  = 'L';
        break;

      default:
        return FALSE;
    } // switch (chType)

    IF_DEBUG( COMMANDS ) {

        DBGPRINTF(( DBG_CONTEXT,
                    "setting transfer type to %s\n",
                    TransferType( newType ) ));
    }

    pUserData->SetXferType( newType);

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_TYPE_SET_TO,
                chType);

    return TRUE;

}   // MainTYPE()




BOOL
MainSTRU(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the STRU command - structure information
  Format:  STRU fileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR     chStruct;
    CHAR   * pszToken;

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid structure type
    //  (only type F supported).
    //

    chStruct = *pszToken;

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }

    switch( chStruct ) {

      case 'f':
      case 'F':
        chStruct = 'F';
        break;

      case 'r':
      case 'R':
      case 'p':
      case 'P':
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_UNIMPLEMENTED_STRU_TYPE);
        return TRUE;

      default:

        return FALSE;
    }

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_STRU_TYPE_OK,
                chStruct );

    return TRUE;

}   // MainSTRU()



BOOL
MainMODE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements the MODE command - to set mode of tfr.
  Format:  MODE newMode

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    XFER_MODE   newMode;
    CHAR        chMode;
    LPSTR       pszToken;

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg != NULL );

    pszToken = strtok( pszArg, PSZ_ARGS_DELIMITER );

    if( pszToken == NULL ) {

        return FALSE;
    }

    //
    //  Ensure we got a valid mode type
    //  (only type S supported).
    //

    if( pszToken[1] != '\0' ) {

        return FALSE;
    }
    chMode = *pszToken;


    switch( chMode )
    {
    case 's' :
    case 'S' :
        newMode = XferModeStream;
        chMode  = 'S';
        break;

    case 'b' :
    case 'B' :
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_NOT_IMPLEMENTED,
                    PSZ_UNIMPLEMENTED_MODE );
        return TRUE;

    default :
        return FALSE;
    }

    IF_DEBUG( COMMANDS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "setting transfer mode to %s\n",
                    TransferMode( newMode ) ));
    }

    pUserData->SetXferMode(newMode);

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_MODE_OK,
                chMode );

    return TRUE;

}   // MainMODE()



BOOL
MainRETR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RETR command - used for retrieving a file.
  Format:  RETR pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
#define MAX_FILE_SIZE_SPEC (32)

    APIERR err = (!NO_ERROR);
    BOOL   fErrorSent = FALSE;
    BOOL   fTriedToOpenFile = FALSE;
    LARGE_INTEGER FileSize;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];
    CHAR rgchBuffer[MAX_FILE_SIZE_SPEC + 10];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn() );

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    if (pUserData->ImpersonateUser()){
	    err = pUserData->OpenFileForSend( pszArg );
		pUserData->RevertToSelf();
	}
	else
	{
		err = GetLastError();
    }

    fTriedToOpenFile = TRUE;

    if ( err != NO_ERROR ) {
        goto retr_exit;
    }

    pOpenFileInfo = pUserData->QueryOpenFileInfo();

    if ( pOpenFileInfo == NULL )
    {
        err = ERROR_FILE_NOT_FOUND;
        goto retr_exit;
    }

    //
    // Get the file size
    //

    if ( !pOpenFileInfo->QuerySize(FileSize) )
    {
        err = GetLastError();

        if ( err != NO_ERROR ) {
            goto retr_exit;
        }
    }

    // removed to fix copatibility problem with cute ftp
    // when FTP service should report always a total size of file to be
    // transfered not a remainder like it was before
    //FileSize.QuadPart -= (LONGLONG)pUserData->QueryCurrentOffset();

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);
    DBG_REQUIRE( _snprintf( rgchBuffer, sizeof( rgchBuffer ), "(%s bytes)", rgchSize) > 0);

    //
    // Establish a data connection
    //
    err = pUserData->EstablishDataConnection( pszArg, rgchBuffer );

    if ( err != NO_ERROR )
    {
        if ( err == ERROR_IO_PENDING )
        {
            //
            // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
            // client to establish a data connection - it takes care of setting up an event that
            // allows us to deal asynchronously with the client connecting [or failing to do so].
            // It indicates this asynchrony by returning ERROR_IO_PENDING
            //

            DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                        !pUserData->QueryHavePASVConn() );

            if ( fTriedToOpenFile )
            {
                pUserData->CloseFileForSend( err);  // close it always on error
            }

            return TRUE;
        }

        fErrorSent = TRUE;

        goto retr_exit;
    }


    err = pUserData->SendFileToUser( pszArg, &fErrorSent);

    if ( err != NO_ERROR)
    {
        //
        // Disconnect connection, since we are in error.
        //
        DBG_REQUIRE( pUserData->DestroyDataConnection( err ));

        // since there was a failure we will close the handle right away.

        IF_DEBUG( ASYNC_IO) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "SendFileToUser ( %s) failed"
                        " err = %u\n",
                        pszArg, err));
        }
    }

retr_exit:

    if( err != NO_ERROR )
    {
        //
        // This command failed, so drop out of PASV mode
        //
        CLEAR_UF( pUserData, PASSIVE );

        //
        // Clean up the PASV flags if necessary
        //
        if ( pUserData->QueryInFakeIOCompletion() )
        {
            pUserData->CleanupPASVFlags();
        }

        if ( !fErrorSent)
        {
            pUserData->SendErrorToClient(pszArg, err,
                                         PSZ_NO_FILE_OR_DIRECTORY);
        }

        pUserData->WriteLogRecordForSendError( err );

        if ( fTriedToOpenFile )
        {
            pUserData->CloseFileForSend( err);  // close it always on error
        }
    }

    return TRUE;

}   // MainRETR()




BOOL
MainSTOR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STOR command - used for storing a file.
  Format:  STOR pathForFile

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to create the file.
    //

    err = VirtualCreateFile( pUserData,
                             &hFile,
                             pszArg,
                             FALSE );

    if( err != NO_ERROR )
    {
        pUserData->SendErrorToClient(pszArg, err, PSZ_CANNOT_CREATE_FILE);
        goto stor_exit;
    }

    //
    // Establish a connection to the user
    //
    err = pUserData->EstablishDataConnection( pszArg );

    if ( err != NO_ERROR )
    {
        CloseHandle( hFile );

        if ( err == ERROR_IO_PENDING )
        {
            //
            // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
            // client to establish a data connection - it takes care of setting up an event that
            // allows us to deal asynchronously with the client connecting [or failing to do so].
            // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
            // any further processing
            //

            DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                        !pUserData->QueryHavePASVConn() );


            return TRUE;
        }

        goto stor_exit;
    }

    pUserData->SetCommandVerb( PSZ_CREATE_VERB);

    //
    //  Let the worker do the dirty work.
    //

    err = pUserData->ReceiveFileFromUser( pszArg, &hFile );

    if( err != NO_ERROR )
    {
        VirtualDeleteFile( pUserData,
            pszArg );

        IF_DEBUG( ASYNC_IO) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "ReceiveFileFromUser ( %s) failed"
                        " err = %u\n",
                        pszArg, err));
        }
    }

stor_exit:

    if ( err != NO_ERROR )
    {
        pUserData->WriteLogRecord(PSZ_CREATE_VERB, pszArg, err);
    }

    return TRUE;

}   // MainSTOR()



BOOL
MainSTOU(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STOU command - used for storing in unique file.
  Format:  STOU <noArgs>

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile;
    CHAR   szTmpFile[MAX_PATH]; // contains entire path
    CHAR * pszTmpFileName;  // contains only the file name

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg == NULL );

    //
    //  Try to create the file.
    //

    szTmpFile[0] = '\0';
    err = VirtualCreateUniqueFile( pUserData,
                                   &hFile,
                                   szTmpFile );


    //
    // extract the file name alone
    //

    pszTmpFileName = strrchr( szTmpFile, '\\');
    if (NULL == pszTmpFileName)
      {  pszTmpFileName = szTmpFile; }
    else
      { pszTmpFileName++; }

    if( err != NO_ERROR )
    {

        pUserData->SendErrorToClient(pszTmpFileName, err,
                                     PSZ_CANNOT_CREATE_UNIQUE_FILE);
        goto stou_exit;
    }

    //
    // Establish a connection to the user
    //
    err = pUserData->EstablishDataConnection( pszTmpFileName );

    if ( err != NO_ERROR )
    {
        CloseHandle( hFile );

        if ( err == ERROR_IO_PENDING )
        {
            //
            // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
            // client to establish a data connection - it takes care of setting up an event that
            // allows us to deal asynchronously with the client connecting [or failing to do so].
            // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
            // any further processign

            DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                        !pUserData->QueryHavePASVConn() );

            return TRUE;
        }

        goto stou_exit;
    }

    pUserData->SetCommandVerb( PSZ_CREATE_VERB);

    //
    //  Let the worker do the dirty work.
    //

    err = pUserData->ReceiveFileFromUser( pszTmpFileName, &hFile );

    if( err != NO_ERROR ) {
        //
        // Note that VirtualCreateUniqueFile() returns a fully
        // qualified physical path to the temporary file. Because
        // of this, we cannot call VirtualDeleteFile(), as that will
        // attempt to "re-canonicalize" the file, which will fail.
        // So, we'll just call the DeleteFile() Win32 API directly.
        //

        DeleteFile( szTmpFile );

        IF_DEBUG( ASYNC_IO) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "ReceiveFileFromUser ( %s) failed"
                        " err = %u\n",
                        pszArg, err));
        }
    }

stou_exit:

    if( err != NO_ERROR ) {
        pUserData->WriteLogRecord(PSZ_CREATE_VERB, szTmpFile, err);
    }

    return TRUE;

}   // MainSTOU()



BOOL
MainAPPE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements APPE command - used for appending to a file.
  Format:  APPE filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    HANDLE hFile = INVALID_HANDLE_VALUE;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Try to create the file.
    //

    err = VirtualCreateFile( pUserData,
                             &hFile,
                             pszArg,
                             TRUE );



    if( err != NO_ERROR )
    {
        pUserData->SendErrorToClient(pszArg, err, PSZ_CANNOT_CREATE_FILE);
        goto appe_exit;
    }

    //
    // Establish a connection to the user
    //
    err = pUserData->EstablishDataConnection( pszArg );

    if ( err != NO_ERROR )
    {

        CloseHandle(hFile);

        if ( err == ERROR_IO_PENDING )
        {
            //
            // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
            // client to establish a data connection - it takes care of setting up an event that
            // allows us to deal asynchronously with the client connecting [or failing to do so].
            // It indicates this asynchrony by returning ERROR_IO_PENDING and we don't do
            // any further processing
            //

            DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                        !pUserData->QueryHavePASVConn() );

            return TRUE;
        }

        goto appe_exit;
    }

    pUserData->SetCommandVerb( PSZ_APPEND_VERB);

    //
    //  Let the worker do the dirty work.
    //

    err = pUserData->ReceiveFileFromUser( pszArg, &hFile );

appe_exit:

    if ( err != NO_ERROR ) {
        pUserData->WriteLogRecord( PSZ_APPEND_VERB, pszArg, err);
    }

    return TRUE;

}   // MainAPPE()




BOOL
MainALLO(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements ALLO command - used for allocating space for file.
  Format:  ALLO filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    //
    //  Since we don't need to pre-reserve storage space for
    //  files, we'll treat this command as a noop.
    //

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL,
                "ALLO");

    return TRUE;

}   // MainALLO()



BOOL
MainREST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements REST command - used for restarting file write
  Format:  REST offset

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    LPSTR       pszEndPtr;
    DWORD       dwOffset;

    DBG_ASSERT( pUserData != NULL );

    DBG_ASSERT( pszArg != NULL );

    // Convert the input parameter to a number, and save it for the next command.

    dwOffset = strtoul(pszArg, &pszEndPtr, 10);

    if( (pszEndPtr == pszArg) || (*pszEndPtr != '\0') ||
        (*pszArg == '-') ||
        (dwOffset == ULONG_MAX && strcmp(pszArg, "4294967295")) )
    {
        ReplyToUser(pUserData,
                    REPLY_PARAMETER_SYNTAX_ERROR,
                    PSZ_REPLY_MARKER_SPEC );
    } else {

        pUserData->SetNextOffset( dwOffset );

        ReplyToUser(pUserData,
                    REPLY_NEED_MORE_INFO,
                    PSZ_REPLY_RESTARTING,
                    pszArg);
    }

    return TRUE;

}   // MainREST()



BOOL
MainRNFR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RNFR command - rename from filename
  Format:  RNFR FromFileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;
    CHAR   szCanon[MAX_PATH+1];
    DWORD  cbSize = sizeof(szCanon);

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Ensure file/directory exists.
    //

    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        err = pUserData->VirtualCanonicalize(szCanon,
                                             &cbSize,
                                             pszArg,
                                             AccessTypeDelete );
    }

    if( err == NO_ERROR ) {


        if ( pUserData->ImpersonateUser() ) {
            if( GetFileAttributes( szCanon ) == (DWORD)-1L ) {

                err = GetLastError();
            }

            pUserData->RevertToSelf();
        } else {
            err = ERROR_ACCESS_DENIED;
        }

        if(( err == NO_ERROR ) && ( pUserData->RenameSourceBuffer == NULL )){

            pUserData->RenameSourceBuffer = (CHAR *)TCP_ALLOC( MAX_PATH );

            if( pUserData->RenameSourceBuffer == NULL ) {

                err = GetLastError();
            }
        }

        if( err == NO_ERROR ) {

            P_strncpy( pUserData->RenameSourceBuffer, pszArg, MAX_PATH );
            SET_UF( pUserData, RENAME );
        }
    }

    if( err == NO_ERROR )
    {
        ReplyToUser(pUserData,
                    REPLY_NEED_MORE_INFO,
                    PSZ_READY_FOR_DEST_FILE);
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }


    pUserData->WriteLogRecord( PSZ_RNFR_VERB, pszArg, err);

    return TRUE;

}   // MainRNFR()



BOOL
MainRNTO(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RNTO command - rename to filename
  Format:  RNTO ToFileName

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Sanity check the parameters.
    //

    DBG_ASSERT( pszArg != NULL );

    //
    //  Ensure previous command was a RNFR.
    //

    if( !TEST_UF( pUserData, RENAME ) )
    {
        ReplyToUser(pUserData,
                    REPLY_BAD_COMMAND_SEQUENCE,
                    PSZ_BAD_COMMAND_SEQUENCE);
    } else {

        CLEAR_UF( pUserData, RENAME );

        //
        //  Rename the file.
        //

        err = VirtualRenameFile( pUserData,
                                pUserData->RenameSourceBuffer,
                                pszArg );

        if( err == NO_ERROR ) {

            ReplyToUser(pUserData,
                        REPLY_FILE_ACTION_COMPLETED,
                        PSZ_COMMAND_SUCCESSFUL, "RNTO");

        } else if( err == ERROR_FILE_EXISTS ) {

            pUserData->SendErrorToClient(
                pszArg,
                err,
                PSZ_DESTINATION_FILE_EXISTS,
                REPLY_FILE_NOT_ALLOWED
                );

        } else {

            pUserData->SendErrorToClient(
                pszArg,
                err,
                PSZ_NO_FILE_OR_DIRECTORY,
                REPLY_FILE_NOT_FOUND
                );

        }
    }

    pUserData->WriteLogRecord( PSZ_RNTO_VERB, pszArg, err);

    return TRUE;

}   // MainRNTO()



BOOL
MainABOR(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements ABOR command - abort any ongoing data transfer
  Format:  ABOR

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                TEST_UF( pUserData, OOB_DATA )
                    ? REPLY_TRANSFER_OK
                    : REPLY_CONNECTION_OPEN,
                PSZ_COMMAND_SUCCESSFUL, "ABOR");

    //
    //  Clear any remaining oob flag.
    //

    CLEAR_UF( pUserData, OOB_DATA );

    pUserData->WriteLogRecord(PSZ_ABORT_VERB, "");

    return TRUE;

}   // MainABOR()



BOOL
MainDELE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements DELE command - used to delete a file
  Format:  DELE filename

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());


    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        err = VirtualDeleteFile( pUserData, pszArg );
    }

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL, "DELE");

    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_DELE_VERB, pszArg, err);

    return TRUE;

}   // MainDELE()



BOOL
MainRMD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements RMD command - used to delete a directory
  Format:  RMD directory

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    if (pUserData->IsFileNameShort(pszArg))
    {
        err = ERROR_PATH_NOT_FOUND;
    }
    else
    {
        err = VirtualRmDir( pUserData, pszArg );
    }

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_ACTION_COMPLETED,
                    PSZ_COMMAND_SUCCESSFUL, "RMD");
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_RMD_VERB, pszArg, err);

    return TRUE;

}   // MainRMD()



BOOL
MainMKD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements MKD command - used to create a directory
  Format:  MKD directory

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR err;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    err = VirtualMkDir( pUserData, pszArg );

    if( err == NO_ERROR ) {

        ReplyToUser(pUserData,
                    REPLY_FILE_CREATED,
                    PSZ_DIRECTORY_CREATE, pszArg);
    } else {

        pUserData->SendErrorToClient(pszArg, err, PSZ_NO_FILE_OR_DIRECTORY);
    }

    pUserData->WriteLogRecord( PSZ_MKD_VERB, pszArg, err);

    return TRUE;

}   // MainMKD()



BOOL
MainPWD(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements PWD command - used to query path to working dir.
  Format:  PWD

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR     szDir[MAX_PATH];

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    // We will be sending back the current directory in virtual form
    // Ofcourse the client should/need not worry about the exact path info.
    //
    P_strncpy( szDir, pUserData->QueryCurrentDirectory().QueryStr(), MAX_PATH);

    if( !TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) ) {

        FlipSlashes( szDir, FLIP_SLASHES_TO_UNIX );
    }

    ReplyToUser(pUserData,
                REPLY_FILE_CREATED,
                PSZ_CURRENT_DIRECTORY,
                szDir );

    return TRUE;

}   // MainPWD()





/*******************************************************************

    NAME:       MainLIST

    SYNOPSIS:   Implementation for the LIST command.  Similar to NLST,
                except defaults to long format display.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainLIST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements LIST command - used for getting dir list.
    It is similar to NLST, only that this defaults to long format.
  Format:  LIST [options]* [path]*

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    APIERR serr = 0;
    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  Let the worker do the dirty work.
    //

    serr = pUserData->EstablishDataConnection("/bin/ls");

    //
    // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
    // client to establish a data connection - it takes care of setting up an event that
    // allows us to deal asynchronously with the client connecting [or failing to do so].
    // It indicates this asynchrony by returning ERROR_IO_PENDING
    //
    if ( serr == ERROR_IO_PENDING )
    {
        DBG_ASSERT( TEST_UF( pUserData, PASSIVE ) );
        DBG_ASSERT( pUserData->QueryWaitingForPASVConn() );
        DBG_ASSERT( !pUserData->QueryHavePASVConn() );

        return TRUE;
    }

    if ( serr == 0) {

        DWORD dwError;

        serr = SimulateLs(pUserData,
                          pszArg,   // switches for path
                          TRUE,     // use data socket
                          TRUE);    // generate default long format

        dwError = ( (!TEST_UF(pUserData, OOB_ABORT) && (serr == 0))
                   ? NO_ERROR : serr);

        if ( dwError != NO_ERROR) {

            //
            // Send a soft error message indicating failure
            //

            pUserData->SendErrorToClient((pszArg != NULL) ? pszArg : ".",
                                         dwError,
                                         PSZ_NO_FILE_OR_DIRECTORY);

            // since we already reported error, now just reset transfer.
            CLEAR_UF( pUserData, TRANSFER);
        }

        DBG_REQUIRE( pUserData->DestroyDataConnection(dwError));

    } else {

        //
        // could not establish a connection send error!
        //  Error is already sent by EstablishDataConnection()
        //

        IF_DEBUG( ERROR) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "EstablishDataConnection( %08x) failed for LIST\n",
                        pUserData));
        }
    }

    return TRUE;

}   // MainLIST()



BOOL
MainNLST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements NLST command - used for getting dir list.
    generates a short form of dir listing.
  Format:  NLST [options]* [path]*

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    BOOL fSpecialLs;
    APIERR serr;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    //
    //  If any switches are present, use the simulated "ls"
    //  command.  Otherwise (no switches) use the special
    //  file list.
    //

    // Estabalish a data connection for transfer of data and simulate Ls.

    fSpecialLs = ( ( pszArg == NULL) || ( *pszArg != '-')); // no switches

    serr = pUserData->EstablishDataConnection( (fSpecialLs)
                                              ? "file list" : "/bin/ls"
                                              );

    //
    // if we're in PASV mode, EstablishDataConnection() doesn't actually wait for the
    // client to establish a data connection - it takes care of setting up an event that
    // allows us to deal asynchronously with the client connecting [or failing to do so].
    // It indicates this asynchrony by returning ERROR_IO_PENDING
    //
    if ( serr == ERROR_IO_PENDING )
    {
        DBG_ASSERT( pUserData->QueryWaitingForPASVConn() &&
                    !pUserData->QueryHavePASVConn() );

        return TRUE;
    }

    if ( serr == 0) {

        DWORD  dwError;

        serr = ( ( fSpecialLs) ?
                SpecialLs(pUserData,
                          pszArg,
                          TRUE)
                : SimulateLs(pUserData,
                             pszArg,      // switches & search path
                             TRUE)
                );

        dwError = ((!TEST_UF(pUserData, OOB_DATA) && (serr == 0))
                   ?NO_ERROR: serr);

        if ( dwError != NO_ERROR) {

            //
            // Send a soft error message indicating failure
            //

            pUserData->SendErrorToClient((pszArg != NULL) ? pszArg : ".",
                                         dwError,
                                         PSZ_NO_FILE_OR_DIRECTORY);

            // since we already reported error, now just reset transfer.
            CLEAR_UF( pUserData, TRANSFER);
        }

        DBG_REQUIRE(pUserData->DestroyDataConnection( dwError));

    } else {

        //
        // could not establish a connection send error!
        //  Error is already sent by EstablishDataConnection()
        //

        IF_DEBUG( ERROR) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "EstablishDataConnection( %08x) failed for LIST\n",
                        pUserData));
        }
    }

    return TRUE;

}   // MainNLST()



BOOL
MainSYST(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements SYST command - used for getting system info.
  Format:  SYST

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_SYSTEM_TYPE,
                PSZ_VERSION_INFO );

    return TRUE;

}   // MainSYST()




# define MAX_STAT_BUFFER_SIZE        (900)

BOOL
MainSTAT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements STAT command - used for getting system stats.
  Format:  STAT

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    CHAR rgchBuffer[MAX_STAT_BUFFER_SIZE];
    INT cchBuf;
    DWORD dwError;

    DBG_ASSERT( pUserData != NULL );

    //
    //  Ensure user is logged on properly.
    //

    DBG_ASSERT( pUserData->IsLoggedOn());

    if( pszArg == NULL )
    {
        HOSTENT * pHost;

        //
        //  Determine the name of the user's host machine.
        //

        pHost = gethostbyaddr((CHAR *)&pUserData->HostIpAddress.s_addr,
                              4,        // size of the s_addr structure
                              PF_INET ) ;

        //
        //  Just dump connection info.
        //

        cchBuf = _snprintf( rgchBuffer, sizeof( rgchBuffer ),
                           "%u-%s status:\r\n"
                           "     Connected to %s\r\n"
                           "     Logged in as %s\r\n"
                           "     TYPE: %s, FORM: %s; STRUcture: %s;"
                           " transfer MODE: %s\r\n"
                           "     %s\r\n"
                           ,
                           REPLY_SYSTEM_STATUS,
                           g_FtpServiceNameString,
                           ( ( pHost != NULL )
                            ? pHost->h_name
                            : inet_ntoa( pUserData->HostIpAddress)),
                           pUserData->QueryUserName(),
                           TransferType( pUserData->QueryXferType() ),
                           "Nonprint",
                           "File",
                           TransferMode( pUserData->QueryXferMode()),
                           ( ( pUserData->QueryDataSocket() == INVALID_SOCKET )
                            ? "No data connection"
                            : "Data connection established")
                           );

        if ( (cchBuf > 0) && (cchBuf < sizeof( rgchBuffer )) &&
             (pUserData->QueryControlSocket() != INVALID_SOCKET) ) {

            dwError = SockSend(pUserData,
                               pUserData->QueryControlSocket(),
                               rgchBuffer,
                               cchBuf);

            IF_DEBUG( SOCKETS) {

                DBGPRINTF((DBG_CONTEXT,
                           " Sending STAT results %d bytes [%s]. Error= %u\n",
                           cchBuf, rgchBuffer, dwError));
            }

        } else {

            dwError = ERROR_INSUFFICIENT_BUFFER;
        }

        ReplyToUser(pUserData,
                    REPLY_SYSTEM_STATUS,
                    PSZ_SERVER_STATUS_END );
    } else {

        //
        //  This should be similar to LIST, except it sends data
        //  over the control socket, not a data socket.
        //

        cchBuf = _snprintf( rgchBuffer, sizeof( rgchBuffer ),
                           "%u-status of %s:\r\n",
                           REPLY_FILE_STATUS,
                           pszArg );

        if ( (cchBuf > 0) && (cchBuf < sizeof( rgchBuffer )) &&
             (pUserData->QueryControlSocket() != INVALID_SOCKET) ) {

            dwError = SockSend(pUserData,
                               pUserData->QueryControlSocket(),
                               rgchBuffer,
                               cchBuf);

            // Error code is ignored after this point!
        }

        SimulateLs(pUserData,
                   pszArg,
                   FALSE,   // use control socket
                   TRUE);   // generate default long format

        ReplyToUser(pUserData,
                    REPLY_FILE_STATUS,
                    PSZ_SERVER_STATUS_END);
    }

    return TRUE;

}   // MainSTAT()



BOOL
MainNOOP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  The DO Nothing  NOOP command.
--*/
{

    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_COMMAND_SUCCESSFUL, "NOOP");

    return TRUE;

}   // MainNOOP()



BOOL
SiteDIRSTYLE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements DIRSTYLE command - used for getting site specific
     directory style. It also toggles the style
  Format:  DIRSTYLE

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    const CHAR *   pszResponse = NULL;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg == NULL );

    //
    //  Toggle the dir output flag.
    //

    if( TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) )
    {
        CLEAR_UF( pUserData, MSDOS_DIR_OUTPUT );
        pszResponse = PSZ_RESPONSE_OFF;
    }
    else
    {
        SET_UF( pUserData, MSDOS_DIR_OUTPUT );
        pszResponse = PSZ_RESPONSE_ON;
    }

    DBG_ASSERT( pszResponse != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_MSDOS_DIRSTYLE,
                pszResponse );

    return TRUE;

}   // SiteDIRSTYLE()




BOOL
SiteCKM(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
/*++
  This function implements CKM command - used for getting site specific
     Annotate Directories flag. It also toggles the flag.
  Format:  CKM

  Arguments:
    pUserData - the user initiating the request.
    pszArg    - command arguments. Will be NULL if no arguments present.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    const CHAR   * pszResponse = NULL;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszArg == NULL );

    //
    //  Toggle the directory annotation flag.
    //

    if( TEST_UF( pUserData, ANNOTATE_DIRS ) )
    {
        CLEAR_UF( pUserData, ANNOTATE_DIRS );
        pszResponse = PSZ_RESPONSE_OFF;
    }
    else
    {
        SET_UF( pUserData, ANNOTATE_DIRS );
        pszResponse = PSZ_RESPONSE_ON;
    }

    DBG_ASSERT( pszResponse != NULL );

    ReplyToUser(pUserData,
                REPLY_COMMAND_OK,
                PSZ_DIRECTORY_ANNOTATION,
                pszResponse );

    return TRUE;

}   // SiteCKM()




BOOL
ParseStringIntoAddress(
    LPSTR     pszString,
    LPIN_ADDR pinetAddr,
    LPPORT    pport
    )
/*++
  Parse a comma-separated list of six decimal numbers
   into an IP address and a port number. The address and the port are
   in network byte order ( most significant bytes first).

  Arguments:
    pszString - string to be parsed. Should be of the form:
                 dd,dd,dd,dd,dd,dd where 'dd' us the decimal representation
                 of a byte (0-255)
    pinetAddr - will receive the IP Address
    pport     - will receive the port.

  Returns:
    BOOL - TRUE if arguments are OK. FALSE if syntax error.
--*/
{
    INT     i;
    UCHAR   chBytes[6];
    UCHAR   chSum;

    chSum = 0;
    i     = 0;

    while( *pszString != '\0' )
    {
        UCHAR chCurrent = (UCHAR)*pszString++;

        if( ( chCurrent >= '0' ) && ( chCurrent <= '9' ) )
        {
            chSum = ( chSum * 10 ) + chCurrent - '0';
        }
        else
        if( ( chCurrent == ',' ) && ( i < 5 ) )
        {
            chBytes[i++] = chSum;
            chSum = 0;
        }
        else
        {
            return FALSE;
        }
    }

    chBytes[i] = chSum;

    if( i != 5 )
    {
        return FALSE;
    }

    pinetAddr->S_un.S_un_b.s_b1 = chBytes[0];
    pinetAddr->S_un.S_un_b.s_b2 = chBytes[1];
    pinetAddr->S_un.S_un_b.s_b3 = chBytes[2];
    pinetAddr->S_un.S_un_b.s_b4 = chBytes[3];

    *pport = (PORT)( chBytes[4] + ( chBytes[5] << 8 ) );

    return TRUE;

}   // ParseStringIntoAddress()


/*******************************************************************

    NAME:       MyLogonUser

    SYNOPSIS:   Validates a user's credentials, then sets the
                impersonation for the current thread.  In effect,
                the current thread "becomes" the user.

    ENTRY:      pUserData - The user initiating the request.

                pszPassword - The user's password.  May be NULL.

                pfHomeDirFailure - Will receive TRUE if the user failed
                    to logon because the home directory was inaccessible.

                pfLicenseExceeded - Will receive TRUE if the logon
                    was denied due to license restrictions.

    RETURNS:    BOOL - If user validated & impersonation was
                    successful, returns TRUE.  Otherwise returns
                    TRUE.

    HISTORY:
        KeithMo     18-Mar-1993 Created.

********************************************************************/
BOOL
MyLogonUser(
    LPUSER_DATA pUserData,
    LPSTR       pszPassword,
    LPBOOL      pfHomeDirFailure,
    LPBOOL      pfLicenseExceeded
    )
{
    //
    //  Validate parameters & state.
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pUserData->UserToken == NULL || pUserData->QueryInFakeIOCompletion());
    DBG_ASSERT( pfHomeDirFailure != NULL );
    DBG_ASSERT( pfLicenseExceeded != NULL );

    BOOL     fReturn = TRUE;
    TS_TOKEN UserToken = NULL;
    BOOL     fAsAnonymous = TEST_UF( pUserData, ANONYMOUS);
    BOOL     fAsAnonymous2 = FALSE;
    BOOL     fEmptyPassword = ( pszPassword == NULL ) || ( *pszPassword == '\0' );
    DWORD    dwError = ERROR_ACCESS_DENIED;

    PCSTR    pszUser = pUserData->QueryUserName();
    DBG_ASSERT( pszUser != NULL );
    DBG_ASSERT( *pszUser != '\0' );

    //
    //  Setup.
    //

    *pfHomeDirFailure  = FALSE;
    *pfLicenseExceeded = FALSE; // NOT YET SUPPORTED IN GHIA APIS!

    if (pUserData->QueryInFakeIOCompletion()) {
        //
        // came back after an async query to obtain the home directory from AD completed.
        // Clean up, and pick up where we left off.
        //

        pUserData->CleanupAsyncADIOFlags();

        goto after_set_root_dir;
    }

    //
    //  Check for invalid logon type.
    //

    if( !pUserData->QueryInstance()->IsAllowedUser(fAsAnonymous)) {

        // conflict between what is allowed and type of the client.
        dwError = ERROR_LOGON_FAILURE;
        goto FailureExitPoint;
    }

    //
    //  Check for anonymous logon.
    //

    if( fAsAnonymous )
    {
        //
        //  At this point, we could copy the password specified by the
        //  user into the pUserData->UserName field.  There's a convention
        //  among Internetters that the password specified for anonymous
        //  logon should actually be your login name.  So, if we wanted
        //  honor this convention, we could copy the password into the
        //  pUserData->UserName field so the Administration UI
        //  could display it.
        //
        //  If the user didn't enter a password, we'll just copy over
        //  "Anonymous" so we'll have SOMETHING to display...
        //

        pUserData->SetUserName( fEmptyPassword ? PSZ_ANONYMOUS_NAME : pszPassword);

        //
        // TsLogon User will logon as anonymous only when we specify the
        //  UserName == NULL and pszPassword == NULL.
        //
        pszUser = NULL;
        pszPassword = NULL;
    }

    //
    //  Do that logon thang. make local copy of authentication info, so that we
    //  don't need to lock
    //

    BOOL     fAsGuest = FALSE;

    { // to set scope for TAI
    TCP_AUTHENT_INFO TAI( pUserData->QueryInstance()->QueryAuthentInfo());

    // dumb TsLogonUser() does not take const CHAR * for pszUser :(
    UserToken = TsLogonUser( (CHAR *) pszUser,
                            pszPassword,
                            &fAsGuest,
                            &fAsAnonymous2,
                            pUserData->QueryInstance(),
                            &TAI );
    }

    if (fAsGuest) {
        SET_UF(pUserData, AS_GUEST);
    } else {
        CLEAR_UF(pUserData, AS_GUEST);
    }

    if (UserToken == NULL) {
        dwError = GetLastError();
        goto FailureExitPoint;
    }

    //
    // Recheck the logon requirements, just in case the user is trying
    // to do something tricky, like logon with the special IUSR_xxx
    // account name.
    //

    if( !pUserData->QueryInstance()->IsAllowedUser(fAsAnonymous2) ) {

        dwError = ERROR_LOGON_FAILURE;
        goto FailureExitPoint;
    }

    //
    //  Determine if we logged in with guest access, and
    //  if so, if guest access is allowed in our server.
    //

    if( TEST_UF(pUserData, AS_GUEST) && !pUserData->QueryInstance()->AllowGuestAccess() ) {

        dwError = ERROR_LOGON_FAILURE;
        goto FailureExitPoint;
    }

    // reset it again even if it was anonymous
    pszUser = pUserData->QueryUserName();

    //
    //  Save away the impersonation token so we can delete
    //  it when the user disconnects or this client thread
    //  otherwise terminates.
    //

    pUserData->UserToken = UserToken;
    UserToken = NULL;

    //
    // go set the user's root directory.
    //

    if ( pUserData->SetRootDirectory( pszPassword ) == ERROR_IO_PENDING ) {
        //
        // we are in enterprise isolation mode, and an asynchronous fetch from active directory
        // was initiated. we'll get back in here when it is complete.
        //
        dwError = ERROR_IO_PENDING;
        goto FailureExitPoint;
    }

after_set_root_dir:

    //
    //  User validated, now impersonate.
    //

    if( !pUserData->ImpersonateUser()) {

        //
        //  Impersonation failure.
        //

        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "Impersonate User %08x failed. Error=%lu\n",
                       UserToken, GetLastError()));
        }

        fReturn = FALSE;

    } else {

        //
        //  We're now running in the context of the connected user.
        //  Check the user's access to the FTP Server.
        //

        DWORD dwUserAccess = DetermineUserAccess(pUserData->QueryInstance());

        if( dwUserAccess == 0 ) {

            //
            //  User cannot access the FTP Server.
            //

            IF_DEBUG( SECURITY ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "user %s denied FTP access\n",
                           pszUser ));
            }

            fReturn = FALSE;

        } else {

            const CHAR * apszSubStrings[2];
            DWORD  eventId = 0;

            apszSubStrings[0] = pszUser;

            pUserData->Flags &= ~( UF_READ_ACCESS | UF_WRITE_ACCESS );
            pUserData->Flags |= dwUserAccess;

            IF_DEBUG( SECURITY ) {

                CHAR * pszTmp = NULL;

                if( TEST_UF( pUserData, READ_ACCESS ) ) {

                    pszTmp = ( TEST_UF( pUserData, WRITE_ACCESS )
                              ? "read and write"
                              : "read"
                              );
                } else {

                    DBG_ASSERT( TEST_UF( pUserData, WRITE_ACCESS ) );

                    pszTmp = "write";
                }

                DBG_ASSERT( pszTmp != NULL );

                DBGPRINTF(( DBG_CONTEXT,
                           "user %s granted %s FTP access\n",
                           pszUser,
                           pszTmp ));
            }

            //
            //  has the user home directory been properly initialized?
            //

            if( pUserData->QueryRootDirStatus() != NO_ERROR ) {

                //
                //  Failed to determine home directory.
                //

                eventId = FTPD_EVENT_BAD_HOME_DIRECTORY;
            }

            //
            //  Try to CD to the user's home directory.  Note that
            //  this is VERY important for setting up some of the
            //  "virtual current directory" structures properly.
            //

            else if( pUserData->CdToUsersHomeDirectory() != NO_ERROR ) {

                //
                //  Home directory inaccessible.
                //

                eventId = FTPD_EVENT_BAD_HOME_DIRECTORY;

            } else if (fAsAnonymous &&
                      pUserData->QueryInstance()->QueryLogAnonymous() &&
                      !fEmptyPassword ) {

                //
                //  If this is an anonymous user, and we're to log
                //  anonymous logons, OR if this is not an anonymous
                //  user, and we're to log nonanonymous logons, then
                //  do it.
                //
                //  Note that we DON'T log the logon if the user is
                //  anonymous but specified no password.
                //

                eventId =  FTPD_EVENT_ANONYMOUS_LOGON;

            } else if (!fAsAnonymous &&
                      pUserData->QueryInstance()->QueryLogNonAnonymous()
                      ) {

                DBG_ASSERT( *pszUser != '\0');
                eventId = FTPD_EVENT_NONANONYMOUS_LOGON;
            }

            //
            //  Log an event so the poor admin can figure out
            //  what's going on.
            //

            switch ( eventId) {

              case FTPD_EVENT_ANONYMOUS_LOGON:
              case FTPD_EVENT_NONANONYMOUS_LOGON:
                apszSubStrings[1] = inet_ntoa( pUserData->HostIpAddress);

                g_pInetSvc->LogEvent( eventId,
                                      2,
                                      apszSubStrings,
                                      0 );
                break;

              case FTPD_EVENT_BAD_HOME_DIRECTORY:

                pUserData->QueryInstance()->LockThisForRead();

                apszSubStrings[1] = pUserData->QueryInstance()->QueryRoot();

                *pfHomeDirFailure = TRUE;
                g_pInetSvc->LogEvent( eventId,
                                      2,
                                      apszSubStrings,
                                      0 );

                pUserData->QueryInstance()->UnlockThis();

                fReturn = FALSE;  // bad directory is a failure.
                break;

              default:
                // do nothing
                break;
            } // switch
        } // user Access Succeeded

        pUserData->RevertToSelf();  // get out the impersonation

    } // Impersonation succeeded.

    //
    //  Success!
    //

    SetLastError( fReturn ? ERROR_SUCCESS : ERROR_ACCESS_DENIED );
    return fReturn;

FailureExitPoint:

    if (UserToken != NULL) {
        TsDeleteUserToken( UserToken );
    }

    SetLastError( dwError );
    return FALSE;

}   // MyLogonUser()



DWORD
DetermineUserAccess(FTP_SERVER_INSTANCE *pInstance)
/*++
  This function determines the current user's access to FTP server.
  This is done by testing different RegOpenKey APIs against
  the FTPD_ACCESS_KEY. This key (if it exists) will be "under" the
  FTPD_PARAMETERS_KEY key.

  Arguments:
    None

  Returns:
    DWORD -- will be an OR Combination of UF_READ_ACCESS and UF_WRITE_ACCESS.
    IF this is zero, then the user cannot access FTP server.

  History:
    KeithMo     06-May-1993 Created.
    MuraliK     24-July-1995  Call this function with Impersonation.

  NYI:  Improve performance by avoiding reg opens per connection....
--*/
{
    DWORD  dwAccess = 0;
    HKEY   hkey;
    APIERR err;

    //
    //  Test for read access.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_ACCESS_KEY,
                        0,
                        KEY_READ,
                        &hkey );

    if( err == NO_ERROR )
    {
        //
        //  Success.
        //

        dwAccess |= UF_READ_ACCESS;
        RegCloseKey( hkey );
    }
    else
    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  Key doesn't exist.
        //

        dwAccess |= UF_READ_ACCESS;
    }

    //
    //  Test for write access.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_ACCESS_KEY,
                        0,
                        KEY_WRITE,
                        &hkey );

    if( err == NO_ERROR )
    {
        //
        //  Success.
        //

        dwAccess |= UF_WRITE_ACCESS;
        RegCloseKey( hkey );
    }
    else
    if( err == ERROR_FILE_NOT_FOUND )
    {
        //
        //  Key doesn't exist.
        //

        dwAccess |= UF_WRITE_ACCESS;
    }

    return dwAccess;
} // DetermineUserAccess()


/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\ftpcmd.cxx ===
/*++


   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      ftpcmd.cxx

   Abstract:

      This module defines the FTP commands supported by this FTP server
        and provides a table of functions to be called for processing
        such command requests.
      ( Some parts of the code are from old engine.cxx ( KeithMo's FTP server))

   Author:

       Murali R. Krishnan    ( MuraliK )     28-Mar-1995

   Environment:

       User Mode -- Win32

   Project:

       FTP Server DLL

   Functions Exported:

       ParseCommand
       ()

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <ftpdp.hxx>
# include "ftpcmd.hxx"
# include "lsaux.hxx"
# include "auxctrs.h"

#define MAX_COMMAND_NAME_LEN    ( 30)
# define MAX_HELP_LINE_SIZE     ( 80)
# define MAX_HELP_AUX_SIZE      (100) // fixed sized aux info with HELP
# define HelpMsgSize( nCommands)   ((1 + nCommands) * MAX_HELP_LINE_SIZE + \
                                    MAX_HELP_AUX_SIZE)

#define IS_7BIT_ASCII(c)   ((UINT)(c) <= 127)


/************************************************************
 *    Static Data containing command lookups
 ************************************************************/



# define UsP           ( UserStateWaitingForPass)
# define UsUP          ( UserStateWaitingForUser | UsP)
# define UsL           ( UserStateLoggedOn)
# define UsUPL         ( UsL | UsUP)

//
// Store the commands in alphabetical order ( manually stored so!)
//   to enable faster search.
//
// Format is:
//  Name   Help Information   FunctionToCall  ArgumentType  ValidStates
//

FTPD_COMMAND MainCommands[] ={

    { "ABOR", "(abort operation)",            MainABOR, ArgTypeNone,    UsL},
    { "ACCT", "(specify account)",            MainACCT, ArgTypeRequired,UsL},
    { "ALLO", "(allocate storage vacuously)", MainALLO, ArgTypeRequired,UsL},
    { "APPE", "<sp> file-name",               MainAPPE, ArgTypeRequired,UsL},
    { "CDUP", "change to parent directory",   MainCDUP, ArgTypeNone,    UsL},
    { "CWD",  "[ <sp> directory-name ]",      MainCWD , ArgTypeOptional,UsL},
    { "DELE", "<sp> file-name",               MainDELE, ArgTypeRequired,UsL},
    { "FEAT", "list feature extensions",      MainFEAT, ArgTypeNone,    UsL},
    { "HELP", "[ <sp> <string>]",             MainHELP, ArgTypeOptional,UsUPL},
    { "LIST", "[ <sp> path-name ]",           MainLIST, ArgTypeOptional,UsL},
    { "MDTM", "(sp) file-name",               MainMDTM, ArgTypeRequired,UsL },
    { "MKD",  "<sp> path-name",               MainMKD , ArgTypeRequired,UsL},
    { "MODE", "(specify transfer mode)",      MainMODE, ArgTypeRequired,UsUPL},
    { "NLST", "[ <sp> path-name ]",           MainNLST, ArgTypeOptional,UsL},
    { "NOOP", "",                             MainNOOP, ArgTypeNone,    UsUPL},
    { "OPTS", "<sp> command <sp> options",    MainOPTS, ArgTypeRequired,UsL},
    { "PASS", "<sp> password",                MainPASS, ArgTypeOptional, UsP},
    { "PASV", "(set server in passive mode)", MainPASV, ArgTypeNone,    UsL},
    { "PORT", "<sp> b0,b1,b2,b3,b4,b5",       MainPORT, ArgTypeRequired,UsL},
    { "PWD",  "(return current directory)",   MainPWD , ArgTypeNone,    UsL},
    { "QUIT", "(terminate service)",          MainQUIT, ArgTypeNone,    UsUPL},
    { "REIN", "(reinitialize server state)",  MainREIN, ArgTypeNone,    UsL},
    { "REST", "<sp> marker",                  MainREST, ArgTypeRequired,UsL},
    { "RETR", "<sp> file-name",               MainRETR, ArgTypeRequired,UsL},
    { "RMD",  "<sp> path-name",               MainRMD , ArgTypeRequired,UsL },
    { "RNFR", "<sp> file-name",               MainRNFR, ArgTypeRequired,UsL},
    { "RNTO", "<sp> file-name",               MainRNTO, ArgTypeRequired,UsL },
    { "SITE", "(site-specific commands)",     MainSITE, ArgTypeOptional,UsL },
    { "SIZE", "(sp) file-name",               MainSIZE, ArgTypeRequired,UsL },
    { "SMNT", "<sp> pathname",                MainSMNT, ArgTypeRequired,UsL },
    { "STAT", "(get server status)",          MainSTAT, ArgTypeOptional,UsL },
    { "STOR", "<sp> file-name",               MainSTOR, ArgTypeRequired,UsL },
    { "STOU", "(store unique file)",          MainSTOU, ArgTypeNone,    UsL},
    { "STRU", "(specify file structure)",     MainSTRU, ArgTypeRequired,UsUPL},
    { "SYST", "(get operating system type)",  MainSYST, ArgTypeNone,    UsL },
    { "TYPE", "<sp> [ A | E | I | L ]",       MainTYPE, ArgTypeRequired,UsL },
    { "USER", "<sp> username",                MainUSER, ArgTypeRequired,UsUPL},
    { "XCUP", "change to parent directory",   MainCDUP, ArgTypeNone,    UsL},
    { "XCWD", "[ <sp> directory-name ]",      MainCWD , ArgTypeOptional,UsL },
    { "XMKD", "<sp> path-name",               MainMKD , ArgTypeRequired,UsL },
    { "XPWD", "(return current directory)",   MainPWD , ArgTypeNone,    UsL },
    { "XRMD", "<sp> path-name",               MainRMD , ArgTypeRequired,UsL }
};

#define NUM_MAIN_COMMANDS ( sizeof(MainCommands) / sizeof(MainCommands[0]) )




FTPD_COMMAND SiteCommands[] = {

    { "CKM",      "(toggle directory comments)", SiteCKM    , ArgTypeNone,UsL},
    { "DIRSTYLE", "(toggle directory format)",  SiteDIRSTYLE, ArgTypeNone,UsL},
    { "HELP",     "[ <sp> <string>]",           SiteHELP    , ArgTypeOptional,
                                                                     UsL}

#ifdef KEEP_COMMAND_STATS

    ,{ "STATS",    "(display per-command stats)", SiteSTATS , ArgTypeNone, UsL}

#endif  // KEEP_COMMAND_STATS

    };


#define NUM_SITE_COMMANDS ( sizeof(SiteCommands) / sizeof(SiteCommands[0]) )



#ifdef KEEP_COMMAND_STATS
extern CRITICAL_SECTION g_CommandStatisticsLock;
#endif  // KEEP_COMMAND_STATS


#ifdef FTP_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // FTP_AUX_COUNTERS

//
// Following is the reply string for the FEAT command. this is a MultiLine reply, where each
// line is terminated by a '\0', and the string is terminated by '\0\0'. First and last verbs
// must not change.
//
char  PSZ_FEAT_REPLY[] =
   "FEAT\0"
   "SIZE\0"
   "MDTM\0"
   "END\0";


char  PSZ_COMMAND_NOT_UNDERSTOOD[] = "'%s': command not understood";
char  PSZ_INVALID_PARAMS_TO_COMMAND[] = "'%s': Invalid number of parameters";
char  PSZ_ILLEGAL_PARAMS[] = "'%s': illegal parameters";
char  PSZ_UNSUPPORTED_OPTION[] = "option not supported";



/************************************************************
 *    Functions
 ************************************************************/



LPFTPD_COMMAND
FindCommandByName(
    LPSTR          pszCommandName,
    LPFTPD_COMMAND pCommandTable,
    INT            cCommands
    );


VOID
HelpWorker(
    LPUSER_DATA    pUserData,
    LPSTR          pszSource,
    LPSTR          pszCommand,
    LPFTPD_COMMAND pCommandTable,
    INT            cCommands,
    INT            cchMaxCmd
    );


/*******************************************************************

    NAME:       ParseCommand

    SYNOPSIS:   Parses a command string, dispatching to the
                appropriate implementation function.

    ENTRY:      pUserData - The user initiating  the request.

                pszCommandText - pointer to command text. This array of
                 characters will be munged while parsing.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     08-18-1995  Eliminated local copy of the command text

********************************************************************/
VOID
ParseCommand(
    LPUSER_DATA pUserData,
    LPSTR       pszCommandText
    )
{
    LPFTPD_COMMAND pcmd;
    LPFN_COMMAND   pfnCmd;
    LPSTR          pszSeparator;
    LPSTR          pszInvalidCommandText = PSZ_INVALID_PARAMS_TO_COMMAND;
    CHAR           chSeparator;
    BOOL           fValidArguments;
    BOOL           fReturn = FALSE;

    DBG_ASSERT( pszCommandText != NULL );
    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );
    DBG_ASSERT( IS_VALID_USER_STATE( pUserData->UserState ) );

    IF_DEBUG( PARSING) {

        DBGPRINTF( ( DBG_CONTEXT, "ParseCommand( %08x, %s)\n",
                    pUserData, pszCommandText));
    }

    //
    //  Ensure we didn't get entered in an invalid state.
    //


//BOGUS:    DBG_ASSERT( ( pUserData->UserState != UserStateEmbryonic ) &&
//BOGUS:                 ( pUserData->UserState != UserStateDisconnected ) );

    pUserData->UpdateOffsets();

    //
    //  The command will be terminated by either a space or a '\0'.
    //

    pszSeparator = strchr( pszCommandText, ' ' );

    if( pszSeparator == NULL )
    {
        pszSeparator = pszCommandText + strlen( pszCommandText );
    }

    //
    //  Try to find the command in the command table.
    //

    chSeparator   = *pszSeparator;
    *pszSeparator = '\0';

    pcmd = FindCommandByName( pszCommandText,
                              MainCommands,
                              NUM_MAIN_COMMANDS );

    if( chSeparator != '\0' )
    {
        *pszSeparator++ = chSeparator;
    }

    //
    //  If this is an unknown command, reply accordingly.
    //

    if( pcmd == NULL )
    {
        FacIncrement( FacUnknownCommands);

        ReplyToUser( pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    PSZ_COMMAND_NOT_UNDERSTOOD,
                    pszCommandText );
        return;
    }

    //
    //  Retrieve the implementation routine.
    //

    pfnCmd = pcmd->Implementation;

    //
    //  If this is an unimplemented command, reply accordingly.
    //

    if( pfnCmd == NULL )
    {
        ReplyToUser( pUserData,
                    REPLY_COMMAND_NOT_IMPLEMENTED,
                    PSZ_COMMAND_NOT_UNDERSTOOD,
                    pcmd->CommandName );

        return;
    }


    //
    //  Ensure we're in a valid state for the specified command.
    //

    if ( ( pcmd->dwUserState & pUserData->UserState) == 0) {

        if( pfnCmd == MainPASS ) {

            ReplyToUser( pUserData,
                        REPLY_BAD_COMMAND_SEQUENCE,
                        "Login with USER first." );
        } else {

            ReplyToUser( pUserData,
                        REPLY_NOT_LOGGED_IN,
                        "Please login with USER and PASS." );
        }

        return;
    }

    //
    //  Do a quick & dirty preliminary check of the argument(s).
    //

    fValidArguments = FALSE;

    switch( pcmd->ArgumentType ) {

      case ArgTypeNone :
        fValidArguments = ( *pszSeparator == '\0' );
        break;

      case ArgTypeOptional :
        fValidArguments = TRUE;
        break;

      case ArgTypeRequired :
        fValidArguments = ( *pszSeparator != '\0' );
        break;

      default:
        DBGPRINTF(( DBG_CONTEXT,
                   "ParseCommand - invalid argtype %d\n",
                   pcmd->ArgumentType ));
        DBG_ASSERT( FALSE );
        break;
    }


    //
    // check we did not get extended chars if we are configured not to allow that
    //

    if( g_fNoExtendedChars /* && !pUserDate->QueryUTF8Option() */) {

        LPSTR pszCh = pszSeparator;

        while( *pszCh ) {

            if( !IS_7BIT_ASCII( *pszCh++ ) ) {

               fValidArguments = FALSE;
               pszInvalidCommandText = PSZ_ILLEGAL_PARAMS;
               break;
            }
        }
    }

    if( fValidArguments ) {

        //
        //  Invoke the implementation routine.
        //

        if( *pszSeparator == '\0' )
        {
            pszSeparator = NULL;
        }

        IF_DEBUG( PARSING )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "invoking %s command, args = %s\n",
                        pcmd->CommandName,
                        _strnicmp( pcmd->CommandName, "PASS", 4 )
                            ? pszSeparator
                            : "{secret...}" ));
        }

#ifdef KEEP_COMMAND_STATS
        EnterCriticalSection( &g_CommandStatisticsLock );

        //
        // only increment the count if we're not re-processing a command
        //
        if ( !pUserData->QueryInFakeIOCompletion() )
        {
            pcmd->UsageCount++;
        }
        LeaveCriticalSection( &g_CommandStatisticsLock );
#endif  // KEEP_COMMAND_STATS

        //
        // Keep track of what command is being executed, in case command processing doesn't
        // complete in this thread and another thread has to finish processing it
        // [can happen if we're in PASV mode and doing async accept on the data connection]
        // Only need to do this if this thread isn't handling an IO completion we generated
        // ourselves because a PASV socket became accept()'able - if it is, we've already
        // set the command.
        //
        if ( !pUserData->QueryInFakeIOCompletion() )
        {
            if ( !pUserData->SetCommand( pszCommandText ) )
            {
                ReplyToUser( pUserData,
                             REPLY_LOCAL_ERROR,
                             "Failed to allocate necessary memory.");
                return;
            }
        }
        fReturn = (pfnCmd)( pUserData, pszSeparator );

        if ( !fReturn) {

            //
            // Invalid number of arguments. Inform the client.
            //
            ReplyToUser(pUserData,
                        REPLY_UNRECOGNIZED_COMMAND,
                        PSZ_COMMAND_NOT_UNDERSTOOD,
                        pszCommandText);
        }

    } else {

        // Invalid # of arguments

        ReplyToUser(pUserData,
                    REPLY_PARAMETER_SYNTAX_ERROR,
                    pszInvalidCommandText,
                    pszCommandText);
    }

    return;
}   // ParseCommand()






/*******************************************************************

    NAME:       MainFEAT

    SYNOPSIS:   Implementation for the FEAT command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        RobSol     22-May-2001 Created.

********************************************************************/
BOOL
MainFEAT(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    DBG_ASSERT( pUserData != NULL );

    pUserData->SendMultilineMessage(
                       REPLY_SYSTEM_STATUS,
                       PSZ_FEAT_REPLY,
                       TRUE,   // is first line
                       TRUE);  // is last line

    return TRUE;

}   // MainFEAT






/*******************************************************************

    NAME:       MainOPTS

    SYNOPSIS:   Implementation for the OPTS command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        RobSol     22-May-2001 Created.

********************************************************************/
BOOL
MainOPTS(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    DBG_ASSERT( pUserData != NULL );

    ReplyToUser(pUserData,
               REPLY_PARAMETER_SYNTAX_ERROR,
               PSZ_UNSUPPORTED_OPTION);

    return TRUE;

}   // MainOPTS






/*******************************************************************

    NAME:       MainSITE

    SYNOPSIS:   Implementation for the SITE command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainSITE(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    LPFTPD_COMMAND pcmd;
    LPFN_COMMAND   pfnCmd;
    LPSTR          pszSeparator;
    CHAR           chSeparator;
    BOOL           fValidArguments;
    CHAR           szParsedCommand[MAX_COMMAND_LENGTH+1];

    DBG_ASSERT( pUserData != NULL );


    //
    //  If no arguments were given, just return the help text.
    //

    if( pszArg == NULL )
    {
        SiteHELP( pUserData, NULL );
        return TRUE;
    }

    //
    //  Save a copy of the command so we can muck around with it.
    //

    P_strncpy( szParsedCommand, pszArg, MAX_COMMAND_LENGTH );

    //
    //  The command will be terminated by either a space or a '\0'.
    //

    pszSeparator = strchr( szParsedCommand, ' ' );

    if( pszSeparator == NULL )
    {
        pszSeparator = szParsedCommand + strlen( szParsedCommand );
    }

    //
    //  Try to find the command in the command table.
    //

    chSeparator   = *pszSeparator;
    *pszSeparator = '\0';

    pcmd = FindCommandByName( szParsedCommand,
                              SiteCommands,
                              NUM_SITE_COMMANDS );

    if( chSeparator != '\0' )
    {
        *pszSeparator++ = chSeparator;
    }

    //
    //  If this is an unknown command, reply accordingly.
    //

    if( pcmd == NULL ) {

        //
        //  Syntax error in command.
        //

        ReplyToUser( pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    "'SITE %s': command not understood",
                    pszArg );

        return (TRUE);
    }

    //
    //  Retrieve the implementation routine.
    //

    pfnCmd = pcmd->Implementation;

    //
    //  If this is an unimplemented command, reply accordingly.
    //

    if( pfnCmd == NULL )
    {
        ReplyToUser( pUserData,
                    REPLY_COMMAND_NOT_IMPLEMENTED,
                    "SITE %s command not implemented.",
                    pcmd->CommandName );

        return TRUE;
    }


    //
    //  Ensure we're in a valid state for the specified command.
    //

    if ( ( pcmd->dwUserState & pUserData->UserState) == 0) {

        ReplyToUser( pUserData,
                    REPLY_NOT_LOGGED_IN,
                    "Please login with USER and PASS." );
        return (FALSE);
    }

    //
    //  Do a quick & dirty preliminary check of the argument(s).
    //

    fValidArguments = FALSE;

    while( ( *pszSeparator == ' ' ) && ( *pszSeparator != '\0' ) )
    {

        pszSeparator++;
    }

    switch( pcmd->ArgumentType ) {

      case ArgTypeNone:
        fValidArguments = ( *pszSeparator == '\0' );
        break;

      case ArgTypeOptional:
        fValidArguments = TRUE;
        break;

      case ArgTypeRequired:
        fValidArguments = ( *pszSeparator != '\0' );
        break;

      default:
        DBGPRINTF(( DBG_CONTEXT,
                    "MainSite - invalid argtype %d\n",
                   pcmd->ArgumentType ));
        DBG_ASSERT( FALSE );
        break;
    }

    if( fValidArguments ) {

        //
        //  Invoke the implementation routine.
        //

        if( *pszSeparator == '\0' )
        {
            pszSeparator = NULL;
        }

        IF_DEBUG( PARSING )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "invoking SITE %s command, args = %s\n",
                       pcmd->CommandName,
                       pszSeparator ));
        }

        if( (pfnCmd)( pUserData, pszSeparator ) )
        {
            return TRUE;
        }
    } else {

        // Invalid # of arguments

        ReplyToUser(pUserData,
                    REPLY_UNRECOGNIZED_COMMAND,
                    PSZ_INVALID_PARAMS_TO_COMMAND,
                    pszArg);
    }

    return TRUE;

}   // MainSITE()





/*******************************************************************

    NAME:       MainHELP

    SYNOPSIS:   Implementation for the HELP command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
BOOL
MainHELP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    DBG_ASSERT( pUserData != NULL );

    HelpWorker(pUserData,
               "",
               pszArg,
               MainCommands,
               NUM_MAIN_COMMANDS,
               4 );

    return TRUE;

}   // MainHELP







/*******************************************************************

    NAME:       SiteHELP

    SYNOPSIS:   Implementation for the site-specific HELP command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     09-May-1993 Created.

********************************************************************/
BOOL
SiteHELP(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    DBG_ASSERT( pUserData != NULL );

    HelpWorker(pUserData,
               "SITE ",
               pszArg,
               SiteCommands,
               NUM_SITE_COMMANDS,
               8 );

    return TRUE;

}   // SiteHELP






#ifdef KEEP_COMMAND_STATS
/*******************************************************************

    NAME:       SiteSTATS

    SYNOPSIS:   Implementation for the site-specific STATS command.

    ENTRY:      pUserData - The user initiating the request.

                pszArg - Command arguments.  Will be NULL if no
                    arguments given.

    RETURNS:    BOOL - TRUE if arguments OK, FALSE if syntax error.

    HISTORY:
        KeithMo     26-Sep-1994 Created.

********************************************************************/
BOOL
SiteSTATS(
    LPUSER_DATA pUserData,
    LPSTR       pszArg
    )
{
    LPFTPD_COMMAND pCmd;
    INT            i;
    CHAR    rgchUsageStats[NUM_MAIN_COMMANDS * 25]; //  25 chars per command
    CHAR *  pszStats;
    INT     cch, cch2;

    pCmd   = MainCommands;

    // Print the stats for first command.
    EnterCriticalSection( &g_CommandStatisticsLock );

    // Find first non-zero entry.
    for( i = 0; i < NUM_MAIN_COMMANDS && pCmd->UsageCount <= 0; i++, pCmd++)
      ;

    if ( i < NUM_MAIN_COMMANDS) {

        // There is some non-zero entry.
        pszStats = rgchUsageStats;

        // print the stats for first command
        cch = _snprintf( pszStats, sizeof( rgchUsageStats ),
                                "%u-%-4s : %lu\r\n",
                                REPLY_COMMAND_OK,
                                pCmd->CommandName,
                                pCmd->UsageCount);
        // static output, sufficient to validate in checked build
        DBG_ASSERT( (cch > 0) && (cch < sizeof( rgchUsageStats )) );

        for( i++, pCmd++ ; i < NUM_MAIN_COMMANDS ; i++, pCmd++) {

            if( pCmd->UsageCount > 0 ) {

                cch2 = _snprintf( pszStats + cch, sizeof( rgchUsageStats ) - cch,
                                 "    %-4s : %lu\r\n",
                                 pCmd->CommandName,
                                 pCmd->UsageCount );

                DBG_ASSERT( cch2 > 0 );

                cch += cch2;

                DBG_ASSERT( cch < sizeof( rgchUsageStats ));
            }

        } // for

        // Ignoring the error code here! probably socket closed
        SockSend( pUserData, pUserData->QueryControlSocket(),
                         rgchUsageStats, cch);
    }

    LeaveCriticalSection( &g_CommandStatisticsLock );

#ifdef  FTP_AUX_COUNTERS

    pszStats = rgchUsageStats;

    // print the stats for first counter
    cch = _snprintf( pszStats, sizeof( rgchUsageStats ),
                    "%u-Aux[%d] : %lu\r\n",
                    REPLY_COMMAND_OK,
                    0,
                    FacCounter(0));

    DBG_ASSERT( (cch > 0) && (cch < sizeof( rgchUsageStats )) );

    for( i = 1; i < NUM_AUX_COUNTERS; i++) {

        cch2 = _snprintf( pszStats + cch, sizeof( rgchUsageStats ) - cch,
                         "    Aux[%d] : %lu\r\n",
                         i,
                         FacCounter(i));

        DBG_ASSERT( cch2 > 0 );

        cch += cch2;

        DBG_ASSERT( cch < sizeof( rgchUsageStats ));
      }

    if ( cch > 0) {

        SockSend( pUserData, pUserData->QueryControlSocket(),
                 rgchUsageStats, cch);
    }

# endif // FTP_AUX_COUNTERS

    ReplyToUser( pUserData,
                REPLY_COMMAND_OK,
                "End of stats." );

    return TRUE;

}   // SiteSTATS
#endif KEEP_COMMAND_STATS





/*******************************************************************

    NAME:       FindCommandByName

    SYNOPSIS:   Searches the command table for a command with this
                specified name.

    ENTRY:      pszCommandName - The name of the command to find.

                pCommandTable - An array of FTPD_COMMANDs detailing
                    the available commands.

                cCommands - The number of commands in pCommandTable.

    RETURNS:    LPFTPD_COMMAND - Points to the command entry for
                    the named command.  Will be NULL if command
                    not found.

    HISTORY:
        KeithMo     10-Mar-1993 Created.
        MuraliK     28-Mar-1995 Completely rewrote to support binary search.

********************************************************************/
LPFTPD_COMMAND
FindCommandByName(
                  LPSTR          pszCommandName,
                  LPFTPD_COMMAND pCommandTable,
                  INT            cCommands
                  )
{
    int  iLower = 0;
    int  iHigher = cCommands  - 1; // store the indexes
    LPFTPD_COMMAND pCommandFound = NULL;

    DBG_ASSERT( pszCommandName != NULL );
    DBG_ASSERT( pCommandTable != NULL );
    DBG_ASSERT( cCommands > 0 );

    //
    //  Search for the command in our table.
    //

    _strupr( pszCommandName );


    while ( iLower <= iHigher) {

        int iMid = ( iHigher + iLower) / 2;

        int comp = strcmp( pszCommandName, pCommandTable[ iMid].CommandName);

        if ( comp == 0) {

            pCommandFound = ( pCommandTable + iMid);
            break;

        } else if ( comp < 0) {

            // reset the higher bound
            iHigher = iMid - 1;
        } else {

            // reset the lower bound
            iLower = iMid + 1;
        }
    }

    return ( pCommandFound);

}   // FindCommandByName()





/*******************************************************************

    NAME:       HelpWorker

    SYNOPSIS:   Worker function for HELP & site-specific HELP commands.

    ENTRY:      pUserData - The user initiating the request.

                pszSource - The source of these commands.

                pszCommand - The command to get help for.  If NULL,
                    then send a list of available commands.

                pCommandTable - An array of FTPD_COMMANDs, one for
                    each available command.

                cCommands - The number of commands in pCommandTable.

                cchMaxCmd - Length of the maximum command.

    HISTORY:
        KeithMo     06-May-1993 Created.
        Muralik     08-May-1995 Added Buffering for performance.

********************************************************************/
VOID
HelpWorker(
           LPUSER_DATA    pUserData,
           LPSTR          pszSource,
           LPSTR          pszCommand,
           LPFTPD_COMMAND pCommandTable,
           INT            cCommands,
           INT            cchMaxCmd
           )
{
    LPFTPD_COMMAND pcmd;
    DWORD  dwError;

    //
    // We should cache the following message and use the cached message for
    //  sending purposes ==> improves performance.
    //  MuraliK   NYI
    //

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pCommandTable != NULL );
    DBG_ASSERT( cCommands > 0 );

    if( pszCommand == NULL ) {

        INT            cch;
        LS_BUFFER      lsb;

        if ((dwError = lsb.AllocateBuffer(HelpMsgSize(cCommands)))!= NO_ERROR){

            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Buffer Allocation ( %d bytes) failed.\n",
                           HelpMsgSize(cCommands)));
            }

            ReplyToUser(pUserData,
                        REPLY_HELP_MESSAGE,
                        "HELP command failed." );
            return;
        }

        cch = _snprintf( lsb.QueryAppendPtr(), lsb.QueryRemainingCB(),
                        "%u-The following %s commands are recognized"
                        "(* ==>'s unimplemented).\r\n",
                        REPLY_HELP_MESSAGE,
                        pszSource);

        DBG_ASSERT( (cch > 0) && (cch < (INT)lsb.QueryRemainingCB()) );

        lsb.IncrementCB( cch * sizeof( CHAR));

        for( pcmd = pCommandTable; pcmd < pCommandTable + cCommands; pcmd++) {

            cch = _snprintf( lsb.QueryAppendPtr(), lsb.QueryRemainingCB(),
                          "   %-*s%c\r\n",
                          cchMaxCmd,
                          pcmd->CommandName,
                          pcmd->Implementation == NULL ? '*' : ' ' );

            DBG_ASSERT( (cch > 0) && (cch < (INT)lsb.QueryRemainingCB()) );

            if ( cch < 0 ) {

                // This is added for retail code where ASSERT may fail.

                dwError = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }

            lsb.IncrementCB( cch*sizeof(CHAR));

        } // for ( all commands)

        if ( dwError == NO_ERROR) {

            // Append the ending sequence for success in generating HELP.
            cch = _snprintf( lsb.QueryAppendPtr(), lsb.QueryRemainingCB(),
                          "%u  %s\r\n",
                          REPLY_HELP_MESSAGE,
                          "HELP command successful." );

            DBG_ASSERT( (cch > 0) && (cch < (INT)lsb.QueryRemainingCB()) );

            if ( cch < 0 ) {

                dwError = ERROR_NOT_ENOUGH_MEMORY;
            } else {

                lsb.IncrementCB( cch*sizeof(CHAR));
            }
        }

        if ( dwError == NO_ERROR) {

            // Send the chunk of data

            dwError = SockSend( pUserData,
                               pUserData->QueryControlSocket(),
                               lsb.QueryBuffer(),
                               lsb.QueryCB());
        } else {

            IF_DEBUG( ERROR) {

                DBGPRINTF(( DBG_CONTEXT,
                           "Error = %u. Should Not happen though...\n",
                           dwError));
            }

            ReplyToUser( pUserData,
                        REPLY_HELP_MESSAGE,
                        "HELP command failed.");
        }

        lsb.FreeBuffer();

        // Ignore the errors if any from propagating outside

    } else {

        pcmd = FindCommandByName(pszCommand,
                                 pCommandTable,
                                 cCommands );

        if( pcmd == NULL ) {

            ReplyToUser( pUserData,
                        REPLY_PARAMETER_SYNTAX_ERROR,
                        "Unknown command %s.",
                        pszCommand );
        } else {

            ReplyToUser( pUserData,
                        REPLY_HELP_MESSAGE,
                        "Syntax: %s%s %s",
                        pszSource,
                        pcmd->CommandName,
                        pcmd->HelpText );
        }
    }

    return;

}   // HelpWorker()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\ftpconf.cxx ===
/*++
   Copyright    (c)    1994        Microsoft Corporation

   Module Name:

        ftpconf.cxx

   Abstract:

        This module contains functions for FTP Server configuration
         class (FTP_SERVER_CONFIG).

   Author:

        Murali R. Krishnan    (MuraliK)    21-March-1995

   Project:
        FTP Server DLL

   Functions Exported:

        FTP_SERVER_CONFIG::FTP_SERVER_CONFIG()
        FTP_SERVER_CONFIG::~FTP_SERVER_CONFIG()
        FTP_SERVER_CONFIG::InitFromRegistry()
        FTP_SERVER_CONFIG::GetConfigInformation()
        FTP_SERVER_CONFIG::SetConfigInformation()
        FTP_SERVER_CONFIG::AllocNewConnection()
        FTP_SERVER_CONFIG::RemoveConnection()
        FTP_SERVER_CONFIG::DisconnectAllConnections()

        FTP_SERVER_CONFIG::Print()

   Revisions:

       MuraliK   26-July-1995    Added Allocation caching of client conns.

--*/

# include "ftpdp.hxx"

#include <ole2.h>
#include <imd.h>
#include <iiscnfgp.h>
#include <mb.hxx>

#include <mbstring.h>
# include <tchar.h>
#include <timer.h>

extern "C"
{
    #include "ntlsa.h"

}   // extern "C"



/************************************************************
 *  Symbolic Constants
 ************************************************************/


#define DEFAULT_ALLOW_ANONYMOUS         TRUE
#define DEFAULT_ALLOW_GUEST_ACCESS      TRUE
#define DEFAULT_ANONYMOUS_ONLY          FALSE

#define DEFAULT_READ_ACCESS_MASK        0
#define DEFAULT_WRITE_ACCESS_MASK       0
#define DEFAULT_MSDOS_DIR_OUTPUT        TRUE

#define DEFAULT_USE_SUBAUTH             FALSE
#define DEFAULT_LOGON_METHOD            LOGON32_LOGON_NETWORK_CLEARTEXT
#define DEFAULT_ANONYMOUS_PWD           ""

#define DEFAULT_AD_CONNECTIONS_USERNAME ""
#define DEFAULT_AD_CONNECTIONS_PASSWORD ""

const TCHAR DEFAULT_EXIT_MESSAGE[] = TEXT("Goodbye.");
# define CCH_DEFAULT_EXIT_MESSAGE         (lstrlen( DEFAULT_EXIT_MESSAGE) + 1)

const TCHAR DEFAULT_MAX_CLIENTS_MSG[] =
   TEXT("Maximum clients reached, service unavailable.");

# define CCH_DEFAULT_MAX_CLIENTS_MSG  (lstrlen( DEFAULT_MAX_CLIENTS_MSG) + 1)

// this should be a double null terminated null terminated sequence.
const TCHAR DEFAULT_GREETING_MESSAGE[2] = { '\0', '\0' };
# define CCH_DEFAULT_GREETING_MESSAGE  ( 2)

// this should be a double null terminated null terminated sequence.
const TCHAR DEFAULT_BANNER_MESSAGE[2] = { '\0', '\0' };
# define CCH_DEFAULT_BANNER_MESSAGE  ( 2)


#define DEFAULT_ANNOTATE_DIRS           FALSE
#define DEFAULT_LOWERCASE_FILES         FALSE
#define DEFAULT_LISTEN_BACKLOG          1       /* reduce listen backlog */

#define DEFAULT_ENABLE_LICENSING        FALSE
#define DEFAULT_DEFAULT_LOGON_DOMAIN    NULL    // NULL == use primary domain

#define DEFAULT_ENABLE_CONN_TO_3RDIP    FALSE
#define DEFAULT_ENABLE_PASV_FROM_3RDIP  FALSE
#define DEFAULT_ALLOW_REPLACE_ON_RENAME FALSE
#define DEFAULT_SHOW_4_DIGIT_YEAR       FALSE

#define DEFAULT_USER_ISOLATION          MD_USER_ISOLATION_NONE
#define DEFAULT_LOG_IN_UTF_8            FALSE

# define SC_NOTIFY_INTERVAL      3000    // milliseconds
# define CLEANUP_POLL_INTERVAL   2000    // milliseconds
# define CLEANUP_RETRY_COUNT     12      // iterations

//
//  Private Prototypes
//



APIERR
GetDefaultDomainName(
    CHAR  * pszDomainName,
    DWORD   cchDomainName
    );

BOOL
FtpdReadRegString(
    IN HKEY     hkey,
    OUT TCHAR * * ppchstr,
    IN LPCTSTR  pchValue,
    IN LPCTSTR  pchDefault,
    IN DWORD    cchDefault
    );

BOOL
GenMessageWithLineFeed(IN LPSTR pszzMessage,
                       IN LPSTR * ppszMessageWithLineFeed);


#if DBG

static CHAR * p_AccessTypes[] = { "read",
                                  "write",
                                  "create",
                                  "delete" };

#endif  // DBG


/************************************************************
 *    Member Functions of FTP_SERVER_INSTANCE
 ************************************************************/

FTP_SERVER_INSTANCE::FTP_SERVER_INSTANCE(
        IN PFTP_IIS_SERVICE pService,
        IN DWORD  dwInstanceId,
        IN USHORT sPort,
        IN LPCSTR lpszRegParamKey,
        IN LPWSTR lpwszAnonPasswordSecretName,
        IN LPWSTR lpwszRootPasswordSecretName,
        IN BOOL   fMigrateVroots
        )
/*++

  Description:

    Constructor Function for Ftp server Configuration object
     ( Initializes all members to be NULL)

    The valid flag may be initialized to TRUE only after reading values
      from registry.

--*/
        : IIS_SERVER_INSTANCE(
            pService,
            dwInstanceId,
            sPort,
            lpszRegParamKey,
            lpwszAnonPasswordSecretName,
            lpwszRootPasswordSecretName,
            fMigrateVroots
        ),
    m_cCurrentConnections    ( 0),
    m_cMaxCurrentConnections ( 0),
    m_fValid                 ( FALSE),
    m_fAllowAnonymous        ( TRUE),
    m_fAnonymousOnly         ( FALSE),
    m_fAllowGuestAccess      ( TRUE),
    m_fAnnotateDirectories   ( FALSE),
    m_fLowercaseFiles        ( FALSE),
    m_fMsdosDirOutput        ( FALSE),
    m_fFourDigitYear         ( FALSE),
    m_fEnableLicensing       ( FALSE),
    m_fEnableDataConnTo3rdIP ( FALSE),
    m_fEnablePasvConnFrom3rdIP( FALSE),
    m_pszGreetingMessageWithLineFeed( NULL),
    m_pszBannerMessageWithLineFeed( NULL),
    m_pszLocalHostName       ( NULL),
    m_dwUserFlags            ( 0),
    m_ListenBacklog          ( DEFAULT_LISTEN_BACKLOG),
    m_pFTPStats              ( NULL),
    m_UserIsolationMode      ( DEFAULT_USER_ISOLATION),
    m_fLogInUtf8             ( DEFAULT_LOG_IN_UTF_8),
    m_pAdIo                  ( NULL )
{

   InitializeListHead( &m_ActiveConnectionsList);
   INITIALIZE_CRITICAL_SECTION( &m_csLock);
   InitializeListHead( &m_FreeConnectionsList);
   INITIALIZE_CRITICAL_SECTION( &m_csConnectionsList);

   if( QueryServerState() == MD_SERVER_STATE_INVALID ) {
       return;
   }

   m_pFTPStats = new FTP_SERVER_STATISTICS;

   if ( m_pFTPStats == NULL )
   {
       SetServerState( MD_SERVER_STATE_INVALID, ERROR_NOT_ENOUGH_MEMORY );
       SetLastError( ERROR_NOT_ENOUGH_MEMORY );
   }

   return;

} // FTP_SERVER_INSTANCE::FTP_SERVER_INSTANCE()




FTP_SERVER_INSTANCE::~FTP_SERVER_INSTANCE( VOID)
/*++
     Description:

        Destructor function for server config object.
        ( Frees all dynamically allocated storage space)
--*/
{
    //
    // delete statistics object
    //

    if( m_pFTPStats != NULL )
    {
        delete m_pFTPStats;
        m_pFTPStats = NULL;
    }

    //
    //  The strings are automatically freed by a call to destructor
    //

    if ( m_pszLocalHostName != NULL) {

        delete [] ( m_pszLocalHostName);
    }

    if ( m_pszGreetingMessageWithLineFeed != NULL) {

        TCP_FREE( m_pszGreetingMessageWithLineFeed);
         m_pszGreetingMessageWithLineFeed = NULL;
    }

    if ( m_pszBannerMessageWithLineFeed != NULL) {

        TCP_FREE( m_pszBannerMessageWithLineFeed);
         m_pszBannerMessageWithLineFeed = NULL;
    }

    m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );

    DBG_ASSERT( m_cCurrentConnections == 0);
    DBG_ASSERT( IsListEmpty( &m_ActiveConnectionsList));

    LockConnectionsList();
    DBG_REQUIRE(FreeAllocCachedClientConn());
    UnlockConnectionsList();

    DBG_ASSERT( IsListEmpty( &m_FreeConnectionsList));

    if ( m_pAdIo ) {
        delete m_pAdIo;
        m_pAdIo = NULL;
    }

    //
    // Delete the critical section object
    //

    DeleteCriticalSection( &m_csLock);
    DeleteCriticalSection( &m_csConnectionsList);


} /* FTP_SERVER_INSTANCE::~FTP_SERVER_INSTANCE() */




DWORD
FTP_SERVER_INSTANCE::StartInstance()
{
    IF_DEBUG(INSTANCE) {
        DBGPRINTF((
            DBG_CONTEXT,
            "FTP_SERVER_INSTANCE::StartInstance called for %p. Current state %d\n",
            this,
            QueryServerState()
            ));
    }

    DBG_ASSERT(m_pFTPStats);
    m_pFTPStats->UpdateStopTime();

    DWORD dwError = IIS_SERVER_INSTANCE::StartInstance();

    if ( dwError)
    {
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((
                DBG_CONTEXT,
                "FTO_SERVER_INSTANCE - IIS_SERVER_INSTANCE Failed. StartInstance returned 0x%x",
                dwError
                ));
        }

        return dwError;
    }

    dwError = InitFromRegistry( FC_FTP_ALL );

    if( dwError != NO_ERROR ) {
        goto StartInstance_Exit;
    }

    dwError = ReadAuthentInfo();

    if( dwError != NO_ERROR ) {
        goto StartInstance_Exit;
    }

    dwError = SetAdIoInfo();

    m_pFTPStats->UpdateStartTime();


StartInstance_Exit:

    return dwError;
}



DWORD
FTP_SERVER_INSTANCE::StopInstance()
{
    DBG_ASSERT(m_pFTPStats);

    m_pFTPStats->UpdateStopTime();
    return IIS_SERVER_INSTANCE::StopInstance();
}


DWORD
FTP_SERVER_INSTANCE::SetLocalHostName(IN LPCSTR pszHost)
/*++

  This function copies the host name specified in the given string to
  configuration object.

  Arguments:
     pszHost   pointer to string containing the local host name.

  Returns:
     NO_ERROR on success and ERROR_NOT_ENOUGH_MEMORY when no memory.
     ERROR_ALREADY_ASSIGNED  if value is already present.
--*/
{
    //
    //  if already a host name exists, return error.
    //  otherwise allocate memory and copy the local host name.
    //

    if ( m_pszLocalHostName != NULL) {

        return (ERROR_ALREADY_ASSIGNED);
    } else {
        m_pszLocalHostName = new CHAR[lstrlenA(pszHost) + 1];
        if ( m_pszLocalHostName == NULL) {

            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        lstrcpyA( m_pszLocalHostName, pszHost);
    }

    return (NO_ERROR);

} // FTP_SERVER_INSTANCE::SetLocalHostName()




DWORD
FTP_SERVER_INSTANCE::InitFromRegistry(
    IN FIELD_CONTROL   FieldsToRead)
/*++
    Description:
      Initializes server configuration data from registry.
      Some values are also initialized with constants.
      If invalid registry key or load data from registry fails,
        then use default values.

    Arguments:

      hkeyReg     handle to registry key

      FieldsToRead
        bitmask indicating the fields to read from the registry.
        This is useful when we try to read the new values after
            modifying the registry information as a result of
            SetAdminInfo call from the Admin UI

    Returns:

       NO_ERROR   if there are no errors.
       Win32 error codes otherwise

    Limitations:

        No validity check is performed on the data present in registry.
--*/
{
    BOOL                fSuccess = TRUE;
    DWORD               err = NO_ERROR;
    IMDCOM*             pMBCom;
    METADATA_HANDLE     hMB;
    HRESULT             hRes;
    METADATA_RECORD     mdRecord;
    DWORD               dwRequiredLen;
    HKEY                hkeyReg = NULL;
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    DWORD tmp;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_READ,
                        &hkeyReg );


    if ( hkeyReg == INVALID_HANDLE_VALUE ||
         hkeyReg == NULL) {

       //
       // Invalid Registry handle given
       //

       SetLastError( ERROR_INVALID_PARAMETER);
       return ( FALSE);
    }

    LockConfig();

    //
    //  Read metabase data.
    //

    if( !mb.Open( QueryMDPath() ) ) {

        RegCloseKey( hkeyReg );
        UnLockConfig();
        return FALSE;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_EXIT_MESSAGE ) ) {

        if( !mb.GetStr( "",
                        MD_EXIT_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_ExitMessage,
                        METADATA_INHERIT,
                        DEFAULT_EXIT_MESSAGE ) ) {

            fSuccess = FALSE;
            err = GetLastError();

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_GREETING_MESSAGE ) ) {

        if( !mb.GetMultisz( "",
                        MD_GREETING_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_GreetingMessage ) ) {

            if( !m_GreetingMessage.Copy(
                    DEFAULT_GREETING_MESSAGE,
                    CCH_DEFAULT_GREETING_MESSAGE
                    ) )  {

                fSuccess = FALSE;
                err = GetLastError();

            }

        }

        //
        // The m_pszGreetingMessage as read is a double null terminated
        // seq of strings (with one string per line)
        // A local copy of the string in the form suited for RPC Admin
        //   should be generated.
        //

        if( fSuccess ) {

            fSuccess = GenMessageWithLineFeed( m_GreetingMessage.QueryStr(),
                                               &m_pszGreetingMessageWithLineFeed);

            if( !fSuccess ) {
                err = GetLastError();
            }

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_BANNER_MESSAGE ) ) {

        if( !mb.GetMultisz( "",
                        MD_BANNER_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_BannerMessage ) ) {

            if( !m_BannerMessage.Copy(
                    DEFAULT_BANNER_MESSAGE,
                    CCH_DEFAULT_BANNER_MESSAGE
                    ) )  {

                fSuccess = FALSE;
                err = GetLastError();

            }

        }

        //
        // The m_pszBannerMessage as read is a double null terminated
        // seq of strings (with one string per line)
        // A local copy of the string in the form suited for RPC Admin
        //   should be generated.
        //

        if( fSuccess ) {

            fSuccess = GenMessageWithLineFeed( m_BannerMessage.QueryStr(),
                                               &m_pszBannerMessageWithLineFeed);

            if( !fSuccess ) {
                err = GetLastError();
            }

        }

    }

    if( fSuccess && IsFieldSet( FieldsToRead, FC_FTP_MAX_CLIENTS_MESSAGE ) ) {

        if( !mb.GetStr( "",
                        MD_MAX_CLIENTS_MESSAGE,
                        IIS_MD_UT_SERVER,
                        &m_MaxClientsMessage,
                        METADATA_INHERIT,
                        DEFAULT_MAX_CLIENTS_MSG ) ) {

            fSuccess = FALSE;
            err = GetLastError();

        }

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_MSDOS_DIR_OUTPUT ) ) {

        if( !mb.GetDword( "",
                          MD_MSDOS_DIR_OUTPUT,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_MSDOS_DIR_OUTPUT;

        }

        m_fMsdosDirOutput = !!tmp;
        // clear and then set the MSDOS_DIR_OUTPUT in user flags
        m_dwUserFlags &= ~UF_MSDOS_DIR_OUTPUT;
        m_dwUserFlags |= (m_fMsdosDirOutput) ? UF_MSDOS_DIR_OUTPUT : 0;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_SHOW_4_DIGIT_YEAR) ) {

        if( !mb.GetDword( "",
                          MD_SHOW_4_DIGIT_YEAR,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_SHOW_4_DIGIT_YEAR;

        }

        m_fFourDigitYear = !!tmp;
        // clear and then set the 4_DIGIT_YEAR in user flags
        m_dwUserFlags &= ~UF_4_DIGIT_YEAR;
        m_dwUserFlags |= (m_fFourDigitYear) ? UF_4_DIGIT_YEAR : 0;
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_ANONYMOUS ) ) {

        if( !mb.GetDword( "",
                          MD_ALLOW_ANONYMOUS,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ALLOW_ANONYMOUS;

        }

        m_fAllowAnonymous = !!tmp;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ANONYMOUS_ONLY ) ) {

        if( !mb.GetDword( "",
                          MD_ANONYMOUS_ONLY,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ANONYMOUS_ONLY;

        }

        m_fAnonymousOnly = !!tmp;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_REPLACE_ON_RENAME ) ) {

        if( !mb.GetDword( "",
                          MD_ALLOW_REPLACE_ON_RENAME,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_ALLOW_REPLACE_ON_RENAME;

        }

        m_fAllowReplaceOnRename = !!tmp;

    }

    if( IsFieldSet( FieldsToRead, FC_FTP_USER_ISOLATION ) ) {

        if( !mb.GetDword( "",
                          MD_USER_ISOLATION,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_USER_ISOLATION;
        }

        m_UserIsolationMode = tmp;

        if (m_UserIsolationMode > MD_USER_ISOLATION_LAST) {

           m_UserIsolationMode = DEFAULT_USER_ISOLATION;
        }
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_LOG_IN_UTF_8 ) ) {

        if( !mb.GetDword( "",
                          MD_FTP_LOG_IN_UTF_8,
                          IIS_MD_UT_SERVER,
                          &tmp ) ) {

            tmp = DEFAULT_LOG_IN_UTF_8;
        }

        m_fLogInUtf8 = !!tmp;

    }

    //
    //  Read registry data.
    //

    if( IsFieldSet( FieldsToRead, FC_FTP_LISTEN_BACKLOG ) )
    {
        m_ListenBacklog = ReadRegistryDword( hkeyReg,
                                            FTPD_LISTEN_BACKLOG,
                                            DEFAULT_LISTEN_BACKLOG );
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ALLOW_GUEST_ACCESS ) ) {

        m_fAllowGuestAccess = !!ReadRegistryDword( hkeyReg,
                                                  FTPD_ALLOW_GUEST_ACCESS,
                                                  DEFAULT_ALLOW_GUEST_ACCESS );
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_ANNOTATE_DIRECTORIES ) ) {

        m_fAnnotateDirectories = !!ReadRegistryDword( hkeyReg,
                                                     FTPD_ANNOTATE_DIRS,
                                                     DEFAULT_ANNOTATE_DIRS );

        // clear and then set the ANNOTATE_DIRS in user flags
        m_dwUserFlags &= ~UF_ANNOTATE_DIRS;
        m_dwUserFlags |= (m_fAnnotateDirectories) ? UF_ANNOTATE_DIRS : 0;
    }

    if( IsFieldSet( FieldsToRead, FC_FTP_LOWERCASE_FILES ) ) {

        m_fLowercaseFiles = !!ReadRegistryDword( hkeyReg,
                                                FTPD_LOWERCASE_FILES,
                                                DEFAULT_LOWERCASE_FILES );
    }

    // fEnableDataConnTo3rdIP is not controlled by RPC yet.
    m_fEnableDataConnTo3rdIP = !!ReadRegistryDword(hkeyReg,
                                              FTPD_ENABLE_CONN_TO_3RDIP,
                                              DEFAULT_ENABLE_CONN_TO_3RDIP);

    // fEnablePasvConnFrom3rdIP is not controlled by RPC yet.
    m_fEnablePasvConnFrom3rdIP = !!ReadRegistryDword(hkeyReg,
                                              FTPD_ENABLE_PASV_FROM_3RDIP,
                                              DEFAULT_ENABLE_PASV_FROM_3RDIP);

    if( fSuccess ) {

        //
        //  The following field is not supported in the admin API.
        //

        m_fEnableLicensing = !!ReadRegistryDword( hkeyReg,
                                                 FTPD_ENABLE_LICENSING,
                                                 DEFAULT_ENABLE_LICENSING );

    }

    if ( fSuccess )
    {
        m_rfAccessCheck.Reset( (IMDCOM*)m_Service->QueryMDObject() );

        pMBCom = (IMDCOM*)m_Service->QueryMDObject();
        hRes = pMBCom->ComMDOpenMetaObject( METADATA_MASTER_ROOT_HANDLE,
                                            (BYTE *) QueryMDVRPath(),
                                            METADATA_PERMISSION_READ,
                                            5000,
                                            &hMB );
        if ( SUCCEEDED( hRes ) )
        {
            mdRecord.dwMDIdentifier  = MD_IP_SEC;
            mdRecord.dwMDAttributes  = METADATA_INHERIT | METADATA_REFERENCE;
            mdRecord.dwMDUserType    = IIS_MD_UT_FILE;
            mdRecord.dwMDDataType    = BINARY_METADATA;
            mdRecord.dwMDDataLen     = 0;
            mdRecord.pbMDData        = (PBYTE)NULL;

            hRes = pMBCom->ComMDGetMetaData( hMB,
                                             (LPBYTE)"",
                                             &mdRecord,
                                             &dwRequiredLen );
            if ( SUCCEEDED( hRes ) && mdRecord.dwMDDataTag )
            {
                m_rfAccessCheck.Set( mdRecord.pbMDData,
                                     mdRecord.dwMDDataLen,
                                     mdRecord.dwMDDataTag );
            }

            DBG_REQUIRE( SUCCEEDED(pMBCom->ComMDCloseMetaObject( hMB )) );
        }
        else
        if( HRESULTTOWIN32( hRes ) != ERROR_PATH_NOT_FOUND )
        {
            fSuccess = FALSE;
            err = HRESULTTOWIN32( hRes );
        }
    }

    UnLockConfig();

    IF_DEBUG( CONFIG) {
       Print();
    }

    m_fValid = TRUE;

    RegCloseKey( hkeyReg );
    return ( err);

} // FTP_SERVER_INSTANCE::InitFromRegistry()





VOID
FTP_SERVER_INSTANCE::Print( VOID) const
/*++

    Description:

       Prints the configuration information for this server.
       To be used in debugging mode for verification.


    Returns:

       None.

--*/
{
    DBGPRINTF(( DBG_CONTEXT,
               "FTP Server Configuration ( %08x).\n", this ));
#if 0
    READ_LOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    AnonymousUser = %s\n",
               g_pInetSvc->QueryAnonUserName() ));

    UNLOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n"
               "    %s = %d\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n"
               "    %s = %u\n",
               FTPD_ALLOW_ANONYMOUS,
               m_fAllowAnonymous,
               FTPD_ALLOW_GUEST_ACCESS,
               m_fAllowGuestAccess,
               FTPD_ANONYMOUS_ONLY,
               m_fAnonymousOnly,
               FTPD_ENABLE_CONN_TO_3RDIP,
               m_fEnableDtaConnTo3rdIP,
               FTPD_ENABLE_PASV_FROM_3RDIP,
               m_fEnablePasvConnFrom3rdIP,
               "LogAnonymous",
               g_pInetSvc->QueryLogAnonymous(),
               "LogNonAnonymous",
               g_pInetSvc->QueryLogNonAnonymous()
               ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_ENABLE_LICENSING,
               m_fEnableLicensing  ));

    DBGPRINTF(( DBG_CONTEXT,
               "    MaxConnections = %lu\n",
               g_pInetSvc->QueryMaxConnections() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    ConnectionTimeout = %lu\n",
               g_pInetSvc->QueryConnectionTimeout() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_MSDOS_DIR_OUTPUT,
               m_fMsdosDirOutput ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_4_DIGIT_YEAR,
               m_f4DigitYear ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %d\n",
               FTPD_ANNOTATE_DIRS,
               m_fAnnotateDirectories  ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %08lX\n",
               FTPD_DEBUG_FLAGS,
               GET_DEBUG_FLAGS()));

    READ_LOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    LogFileDirectory = %s\n",
               g_pInetSvc->QueryLogFileDirectory() ));

    UNLOCK_INST();

    DBGPRINTF(( DBG_CONTEXT,
               "    LogFileAccess = %lu\n",
               g_pInetSvc->QueryLogFileType() ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %u\n",
               FTPD_LISTEN_BACKLOG,
               m_ListenBacklog ));

    DBGPRINTF(( DBG_CONTEXT,
               "    DefaultLogonDomain = %s\n",
               m_DefaultLogonDomain ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %u\n",
               FTPD_USER_ISOLATION,
               m_UserIsolation ));

    DBGPRINTF(( DBG_CONTEXT,
               "    %s = %u\n",
               FTPD_LOG_IN_UTF_8,
               m_fLogInUtf8 ));
#endif
    return;

} // FTP_SERVER_INSTANCE::Print()




PICLIENT_CONNECTION
FTP_SERVER_INSTANCE::AllocNewConnection()
/*++

  This function first checks that there is room for more connections
  as per the configured max connections.

  If there is no more connections allowed, it returns NULL
    with *pfMaxExceeded = TRUE

  Otherwise:
  This function creates a new CLIENT_CONNECTION (USER_DATA) object.
       The creation maybe fresh from heap or from cached free list.

  It increments the counter of currnet connections and returns
   the allocated object (if non NULL).


  We enter a critical section to avoid race condition
    among different threads. (this can be improved NYI).

  Returns:
      pointer to new connection object on success and
      NULL if there is max Connections exceeded.
--*/
{
    PICLIENT_CONNECTION pConn = NULL;

    LockConnectionsList();

    //
    // We can add this new connection
    //

    pConn = AllocClientConnFromAllocCache();

    if ( pConn != NULL) {

        //
        //  Increment the count of connected users
        //
        m_cCurrentConnections++;

        IF_DEBUG( CLIENT) {
            DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                   m_cCurrentConnections));
        }

        //
        // Update the current maximum connections
        //

        if ( m_cCurrentConnections > m_cMaxCurrentConnections) {

            m_cMaxCurrentConnections = m_cCurrentConnections;
        }

        //
        // Insert into the list of connected users.
        //

        DBG_ASSERT( !pConn->IsOnActiveConnectionList() );

        InsertTailList( &m_ActiveConnectionsList, &pConn->QueryListEntry());

        pConn->SetOnActiveConnectionList();
    }

   UnlockConnectionsList();

   return ( pConn);

} // FTP_SERVER_INSTANCE::AllocNewConnection()



VOID
FTP_SERVER_INSTANCE::RemoveConnection(
            IN OUT PICLIENT_CONNECTION  pcc
            )
/*++

--*/
{

    LockConnectionsList();

    //
    // this assert is here just to see if we ever get in here with the connection not on the list
    // if we do, then checking for this condition was not in vein...
    //

    DBG_ASSERT( pcc->IsOnActiveConnectionList() );

    if (pcc->IsOnActiveConnectionList()) {
        //
        // Remove from list of connections
        //
        RemoveEntryList( &pcc->QueryListEntry());

        pcc->ResetOnActiveConnectionList();

        //
        // Decrement count of current users
        //
        m_cCurrentConnections--;

        IF_DEBUG( CLIENT) {
            DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                       m_cCurrentConnections));
        }

        //
        // move the free connection to free list
        //

        FreeClientConnToAllocCache( pcc);
    }

    UnlockConnectionsList();

} // FTP_SERVER_INSTANCE::RemoveConnection()





VOID
FTP_SERVER_INSTANCE::DisconnectAllConnections( VOID)
/*++

   Disconnects all user connections.

   Arguments:

     Instance - If NULL, then all users are disconnected. If !NULL, then
         only those users associated with the specified instance are
         disconnected.

--*/
{
#ifdef CHECK_DBG
    CHAR rgchBuffer[90];
#endif // CHECK_DBG

    DWORD        dwLastTick = GetTickCount();
    DWORD        dwCurrentTick;
    PLIST_ENTRY  pEntry;
    PLIST_ENTRY  pEntryNext;

    DBGPRINTF( ( DBG_CONTEXT,
                "Entering  FTP_SERVER_INSTANCE::DisconnectAllConnections()\n"));


    //
    // Let's empty the connection list immediately while in the lock to avoid a
    // shutdown deadlock
    //

    LockConnectionsList();

    pEntry = m_ActiveConnectionsList.Flink;

    InitializeListHead( &m_ActiveConnectionsList);

    UnlockConnectionsList();

    //
    //  close down all the active sockets.
    //
    for( ;
         pEntry != &m_ActiveConnectionsList;
         pEntry = pEntryNext) {

        PICLIENT_CONNECTION  pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        ASSERT( pConn != NULL);

# ifdef CHECK_DBG
        DBG_REQUIRE( _snprintf( rgchBuffer, sizeof( rgcBuffer ), "Kill UID=%u. Ref=%u\n",
                  pConn->QueryId(), pConn->QueryReference()) > 0);
        rgchBuffer[ sizeof( rgcBuffer ) - 1 ] = '\0';

        OutputDebugString( rgchBuffer);
# endif // CHECK_DBG

        dwCurrentTick = GetTickCount();

        if ( (dwCurrentTick - dwLastTick) >= ( SC_NOTIFY_INTERVAL)) {

            //
            // We seem to take longer time for cleaning up than
            //  expected. Let us ask service controller to wait for us.
            //

            g_pInetSvc->
              DelayCurrentServiceCtrlOperation(SC_NOTIFY_INTERVAL * 2);

            dwLastTick = dwCurrentTick;
        }

        pConn->Reference();
        pConn->DisconnectUserWithError( ERROR_SERVER_DISABLED, TRUE);
        DBG_REQUIRE( pConn->DeReference() > 0 );   // remove ref added above
        if( pConn->RemoveActiveReference() ) {

            //
            // take the lock, as we are messing with the lists. The FreeList is still live,
            // and the connection may also be terminating spontaneously, so that remove can
            // occur concurrently.
            //

            LockConnectionsList();

            if (pConn->IsOnActiveConnectionList()) {

                //
                // This connection is due for deletion. Kill it.
                //
                // Remove from list of connections
                //

                pConn->Cleanup();
                RemoveEntryList( &pConn->QueryListEntry());

                pConn->ResetOnActiveConnectionList();

                //
                // Decrement count of current users
                //
                m_cCurrentConnections--;

                // move the connection to free list
                FreeClientConnToAllocCache( pConn);
            }

            UnlockConnectionsList();
        }
    } // for

    //
    //  Wait for the users to die.
    //  The connection objects should be automatically freed because the
    //   socket has been closed. Subsequent requests will fail
    //   and cause a blowaway of the connection objects.
    //

    //
    //  Wait for the users to die.
    //

    for( int i = 0 ;
        ( i < CLEANUP_RETRY_COUNT ) && ( m_cCurrentConnections > 0);
        i++ )
    {

        DBGPRINTF(( DBG_CONTEXT, "Sleep Iteration %d; Time=%u millisecs."
                   " CurrentConn=%d.\n",
                   i,  CLEANUP_POLL_INTERVAL, m_cCurrentConnections));

        g_pInetSvc->
          DelayCurrentServiceCtrlOperation( CLEANUP_POLL_INTERVAL * 2);
        Sleep( CLEANUP_POLL_INTERVAL );
    }

    return;

} // FTP_SERVER_INSTANCE::DisconnectAllConnections()



BOOL
FTP_SERVER_INSTANCE::EnumerateConnection(
   IN PFN_CLIENT_CONNECTION_ENUM  pfnConnEnum,
   IN LPVOID  pContext,
   IN DWORD   dwConnectionId)
/*++
  This function iterates through all the connections in the current connected
   users list and enumerates each of them. If the connectionId matches then
   given callback function is called. If the ConnectionId is 0, then the
   callback is called for each and every connection active currently.

  During such a call the reference count of the connection is bumped up.
  Call this function after obtaining the ConnectionsList Lock.

  Arguments:
     pfnConnEnum      pointer to function to be called when a match is found.
     pContext         pointer to context information to be passed in
                       for callback
     dwConnectionId   DWORD containing the Connection Id. IF 0 match all the
                        connections.

  Returns:
    FALSE if no match is found
    TRUE if atleast one match is found.
--*/
{
    BOOL fReturn = FALSE;
    BOOL fFoundOne  = FALSE;
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pEntryNext;

    DBG_ASSERT( pfnConnEnum != NULL);

    //
    //  Loop through the list of connections and call the callback
    //  for each connection  that matches condition
    //

    for ( pEntry  = m_ActiveConnectionsList.Flink,
              pEntryNext = &m_ActiveConnectionsList;
          pEntry != &m_ActiveConnectionsList;
          pEntry  = pEntryNext
         ) {

        PICLIENT_CONNECTION pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        if ( dwConnectionId == 0 || dwConnectionId == pConn->QueryId()) {

            pConn->Reference();

            fReturn = ( pfnConnEnum)( pConn, pContext);

            if ( !pConn->DeReference()) {

                // Blowaway the connection and update the count of entries.
                //
                // Remove from list of connections
                //

                if (pConn->IsOnActiveConnectionList()) {

                    pConn->Cleanup();
                    RemoveEntryList( &pConn->QueryListEntry());

                    pConn->ResetOnActiveConnectionList();

                    //
                    // Decrement count of current users
                    //
                    m_cCurrentConnections--;

                    IF_DEBUG( CLIENT) {
                        DBGPRINTF((DBG_CONTEXT, " CurrentConnections = %u\n",
                                   m_cCurrentConnections));
                    }

                    // move the free connection to free list
                    FreeClientConnToAllocCache( pConn);
                }
            }

            if (!fReturn) {

                break;
            }

            fFoundOne = TRUE;
        }
    } // for

    //
    //  If we didn't find any, assume that there was no match.
    //

    if ( !fFoundOne ) {

        SetLastError( ERROR_NO_MORE_ITEMS );
        fReturn = FALSE;
    }

    return ( fReturn);
} // FTP_SERVER_INSTANCE::EnumerateConnection()




DWORD
FTP_SERVER_INSTANCE::GetConfigInformation(OUT LPFTP_CONFIG_INFO pConfig)
/*++
  This function copies the ftp server configuration into the given
   structure (pointed to).

  Arguments:
    pConfig -- pointer to FTP_CONFIG_INFO which on success will contain
                 the ftp server configuration

  Returns:
    Win32 error code. NO_ERROR on success.
--*/
{
    DWORD dwError = NO_ERROR;

    memset( pConfig, 0, sizeof(*pConfig) );

    pConfig->FieldControl = FC_FTP_ALL;

    LockConfig();

    pConfig->fAllowAnonymous            = m_fAllowAnonymous;
    pConfig->fAllowGuestAccess          = m_fAllowGuestAccess;
    pConfig->fAnnotateDirectories       = m_fAnnotateDirectories;
    pConfig->fAnonymousOnly             = m_fAnonymousOnly;
    pConfig->dwListenBacklog            = m_ListenBacklog;
    pConfig->fLowercaseFiles            = m_fLowercaseFiles;
    pConfig->fMsdosDirOutput            = m_fMsdosDirOutput;
    pConfig->dwUserIsolationMode        = m_UserIsolationMode;
    pConfig->fLogInUtf8                 = m_fLogInUtf8;

    if( !ConvertStringToRpc( &pConfig->lpszExitMessage,
                             QueryExitMsg() ) ||
        !ConvertStringToRpc( &pConfig->lpszGreetingMessage,
                             m_pszGreetingMessageWithLineFeed ) ||
        !ConvertStringToRpc( &pConfig->lpszBannerMessage,
                             m_pszBannerMessageWithLineFeed ) ||
        !ConvertStringToRpc( &pConfig->lpszMaxClientsMessage,
                             QueryMaxClientsMsg() ) )
    {
        dwError = GetLastError();
    }

    UnLockConfig();

    if ( dwError == NO_ERROR) {

        pConfig->lpszHomeDirectory  = NULL;  // use query virtual roots.
    }

    if ( dwError != NO_ERROR) {

        FreeRpcString( pConfig->lpszExitMessage );
        FreeRpcString( pConfig->lpszGreetingMessage );
        FreeRpcString( pConfig->lpszBannerMessage );
        FreeRpcString( pConfig->lpszHomeDirectory );
        FreeRpcString( pConfig->lpszMaxClientsMessage );
    }

    return (dwError);

} // FTP_SERVER_INSTANCE::GetConfigurationInformation()





// Private Functions ...


BOOL
FTP_SERVER_INSTANCE::FreeAllocCachedClientConn( VOID)
/*++
  This function frees all the alloc cached client connections
  It walks through the list of alloc cached entries and frees them.

  This function should be called when Server module is terminated and when
   no other thread can interfere in processing a shared object.

  Arguments:
    NONE

  Returns:
    TRUE on success and FALSE on failure.

--*/
{
    register PLIST_ENTRY  pEntry;
    register PLIST_ENTRY  pEntryNext;

    for( pEntry = m_FreeConnectionsList.Flink;
         pEntry != &m_FreeConnectionsList; ) {


        PICLIENT_CONNECTION  pConn =
          GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        pEntryNext = pEntry->Flink; // cache next entry since pConn may die

        DBG_ASSERT( pConn->QueryReference() == 0);

        RemoveEntryList( pEntry );        // Remove this context from list

        // delete the object itself
        delete pConn;

        pEntry = pEntryNext;

    } // for

    return (TRUE);

} // USER_DATA::FreeAllocCachedClientConn()



PICLIENT_CONNECTION
FTP_SERVER_INSTANCE::AllocClientConnFromAllocCache(
                        VOID
                        )
/*++
  This function attempts to allocate a client connection object from
  the allocation cache, using the free list of connections available.

  If none is available, then a new object is allocated using new ()
   and returned to the caller.
  Eventually the object will enter free list and will be available
   for free use.

  Arguments:
     None

  Returns:
    On success a valid pointer to client connection object.

  Issues:
     This function should be called while holding the ConnectionsLock.
--*/
{
    PLIST_ENTRY pEntry  = m_FreeConnectionsList.Flink;
    PICLIENT_CONNECTION pConn;

    if ( pEntry != &m_FreeConnectionsList) {

        pConn = GET_USER_DATA_FROM_LIST_ENTRY( pEntry);
        DBG_ASSERT( pConn != NULL);
        RemoveEntryList( pEntry);  // remove entry from free list

        DBG_ASSERT( pConn->QueryInstance() == NULL );
        pConn->SetInstance( this );

    } else {

        //
        // create a new object, since allocation cache is empty
        //

        pConn = new USER_DATA( this );
    }

    return (pConn);

} // FTP_SERVER_INSTANCE::AllocClientConnFromAllocCache()



VOID
FTP_SERVER_INSTANCE::FreeClientConnToAllocCache(
                        IN PICLIENT_CONNECTION pClient
                        )
/*++
  This function releases the given Client connection to the allocation cache.
  It adds the given object to allocation cache.

  Arguments:
    pClient  pointer to client connection object which needs to be freed.

  Returns:
    None

  Issues:
    This function should be called after holding the ConnectionsList
     critical section.

    Should we limit the number of items that can be on free list and
      to release the remaining to global pool?  NYI (depends on # CPUs)
--*/
{
    PLIST_ENTRY pEntry = &pClient->QueryListEntry();

    //
    // empty out instance pointer
    //

    pClient->QueryInstance()->DecrementCurrentConnections();
    pClient->QueryInstance()->Dereference( );
    pClient->SetInstance( NULL );

    InsertHeadList( &m_FreeConnectionsList, pEntry);
    return;

} // FTP_SERVER_INSTANCE::FreeClientConnToAllocCache()



DWORD
FTP_SERVER_INSTANCE::SetAdIoInfo()
/*++
  Create, update or delete the AD IO related objects when starting the service or when
  configuration parameters change

  Arguments:
    None.

  Returns:
    NO_ERROR on success, WinError on failure.
--*/
{
    DWORD dwError = NO_ERROR;

    //
    // ADIO is needed in AD Isolation mode
    //
    BOOL Need_ADIO = (QueryIsolationMode() == MD_USER_ISOLATION_AD);

    //
    // Anonym Cache is needed in AD isolation, if anonymous access is allowed
    //
    BOOL Need_AnonymCache = Need_ADIO && IsAllowedUser( TRUE );

    //
    // we are checking if the relevant configuration changed, to determine if we need to delete,
    // create, or update either of the AD access objects
    //

    switch ( (m_pAdIo ? 1 : 0) + (Need_ADIO ? 2 : 0) ) {
    case 0: // No ADIO before or after
        break;

    case 1: // We had ADIO, no longer need it (isolation mode changed from enterprise)
        delete m_pAdIo;
        m_pAdIo = NULL;
        break;

    case 2: // we didn't have ADIO, now we need it. Startup in enterprise iolation
        m_pAdIo = new AD_IO;
        if (m_pAdIo == NULL) {

            dwError = ERROR_NOT_ENOUGH_MEMORY;

        } else {
            //
            // allocated OK. check for init errors
            //

            dwError = GetLastError();
        }

        if( dwError != NO_ERROR ) {
            break;
        }

        // fall through to configuring the object

    case 3: // AD or anonymous user credentials changed
    {
        PSTR pszUser = NULL, pszDomain = NULL;

        //
        // if we need it, get the anonymous user details
        //
        if (Need_AnonymCache) {
            BOOL fIsLocalUser;
            CHAR szDomainAndUser[ UNLEN + DNLEN + 2 ];

            if (
                (QueryAuthentInfo()->strAnonUserName.QueryCCH() >= sizeof(szDomainAndUser)) ||
                !strcpy( szDomainAndUser, QueryAuthentInfo()->strAnonUserName.QueryStr())   ||  // this is always false
                !ParseUserName( szDomainAndUser, &pszUser, &pszDomain,
                                QueryLocalHostName(), &fIsLocalUser)                        ||
                fIsLocalUser ) {

                dwError = ERROR_INVALID_PARAMETER;
                break;
            }
        }

        dwError = m_pAdIo->Configure(
                                QueryADConnAuthentInfo()->strName,
                                QueryADConnAuthentInfo()->strDomain,
                                QueryADConnAuthentInfo()->strPassword,
                                pszUser,
                                pszDomain);

        break;
    }

    default:
        DBG_ASSERT( FALSE );
        dwError = ERROR_INTERNAL_ERROR;
    }

    return dwError;

} // FTP_SERVER_INSTANCE::SetAdIoInfo()


/*******************************************************************

    NAME:       GetDefaultDomainName

    SYNOPSIS:   Fills in the given array with the name of the default
                domain to use for logon validation.

    ENTRY:      pszDomainName - Pointer to a buffer that will receive
                    the default domain name.

                cchDomainName - The size (in charactesr) of the domain
                    name buffer.

    RETURNS:    APIERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     05-Dec-1994 Created.

********************************************************************/

APIERR
GetDefaultDomainName(
    STR * pstrDomainName
    )
{

    OBJECT_ATTRIBUTES           ObjectAttributes;
    NTSTATUS                    NtStatus;
    INT                         Result;
    APIERR                      err             = 0;
    LSA_HANDLE                  LsaPolicyHandle = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo      = NULL;

    //
    //  Open a handle to the local machine's LSA policy object.
    //

    InitializeObjectAttributes( &ObjectAttributes,  // object attributes
                                NULL,               // name
                                0L,                 // attributes
                                NULL,               // root directory
                                NULL );             // security descriptor

    NtStatus = LsaOpenPolicy( NULL,                 // system name
                              &ObjectAttributes,    // object attributes
                              POLICY_EXECUTE,       // access mask
                              &LsaPolicyHandle );   // policy handle

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot open lsa policy, error %08lX\n",
                    NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Query the domain information from the policy object.
    //

    NtStatus = LsaQueryInformationPolicy( LsaPolicyHandle,
                                          PolicyAccountDomainInformation,
                                          (PVOID *)&DomainInfo );

    if( !NT_SUCCESS( NtStatus ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot query lsa policy info, error %08lX\n",
                    NtStatus ));

        err = LsaNtStatusToWinError( NtStatus );
        goto Cleanup;
    }

    //
    //  Compute the required length of the ANSI name.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // dwFlags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  NULL,                 // lpMultiByteStr
                                  0,                    // cchMultiByte
                                  NULL,                 // lpDefaultChar
                                  NULL                  // lpUsedDefaultChar
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Resize the output string as appropriate, including room for the
    //  terminating '\0'.
    //

    if( !pstrDomainName->Resize( (UINT)Result + 1 ) )
    {
        err = GetLastError();
        goto Cleanup;
    }

    //
    //  Convert the name from UNICODE to ANSI.
    //

    Result = WideCharToMultiByte( CP_ACP,
                                  0,                    // flags
                                  (LPCWSTR)DomainInfo->DomainName.Buffer,
                                  DomainInfo->DomainName.Length /sizeof(WCHAR),
                                  pstrDomainName->QueryStr(),
                                  pstrDomainName->QuerySize() - 1,  // for '\0'
                                  NULL,
                                  NULL
                                  );

    if( Result <= 0 )
    {
        err = GetLastError();

        DBGPRINTF(( DBG_CONTEXT,
                    "cannot convert domain name to ANSI, error %d\n",
                    err ));

        goto Cleanup;
    }

    //
    //  Ensure the ANSI string is zero terminated.
    //

    DBG_ASSERT( (DWORD)Result < pstrDomainName->QuerySize() );

    pstrDomainName->QueryStr()[Result] = '\0';

    //
    //  Success!
    //

    DBG_ASSERT( err == 0 );

    IF_DEBUG( CONFIG )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "GetDefaultDomainName: default domain = %s\n",
                    pstrDomainName->QueryStr() ));
    }

Cleanup:

    if( DomainInfo != NULL )
    {
        LsaFreeMemory( (PVOID)DomainInfo );
    }

    if( LsaPolicyHandle != NULL )
    {
        LsaClose( LsaPolicyHandle );
    }

    return err;

}   // GetDefaultDomainName()



BOOL
GenMessageWithLineFeed(IN LPTSTR pszzMessage,
                       IN LPTSTR * ppszMessageWithLineFeed)
{
    DWORD   cbLen;
    TCHAR   *pszDst;

    DBG_ASSERT( ppszMessageWithLineFeed != NULL);

    //
    // 1. Find the length of the complete message. Each itteration adds
    //    the length of the string plus one, which is either a \n or a \0
    //    at the end
    //

    for ( cbLen = 0;
          *(pszzMessage + cbLen) != TEXT('\0');
          cbLen +=  _tcslen( pszzMessage + cbLen) + 1 )
      ;

    //
    // 2. Allocate sufficient space to hold the data
    //

    if ( *ppszMessageWithLineFeed != NULL) {

        TCP_FREE( *ppszMessageWithLineFeed);
    }


    *ppszMessageWithLineFeed = (TCHAR *) TCP_ALLOC((cbLen) * sizeof(TCHAR));


    if ( *ppszMessageWithLineFeed == NULL) {


        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        return (FALSE);
    }

    //
    // 3.
    // Copy the entire message, then going backword (skipping the last \0)
    // replace all \0's with \n's
    //

    CopyMemory( *ppszMessageWithLineFeed, pszzMessage, cbLen);

    for(pszDst = *ppszMessageWithLineFeed + cbLen - 2;
        pszDst > *ppszMessageWithLineFeed;
        pszDst--) {

        if (*pszDst == '\0') {
            *pszDst = '\n';
        }
    }

    return ( TRUE);
} // GenMessageWithLineFeed()




TCHAR *
FtpdReadRegistryString(IN HKEY     hkey,
                       IN LPCTSTR  pszValueName,
                       IN LPCTSTR  pchDefaultValue,
                       IN DWORD    cbDefaultValue)
/*++
  This function reads a string (REG_SZ/REG_MULTI_SZ/REG_EXPAND_SZ) without
   expanding the same. It allocates memory for reading the data from registry.

  Arguments:
    hkey    handle for the registry key.
    pszValueName   pointer to string containing the name of value to be read.
    pchDefaultValue pointer to default value to be used for reading the string
                   this may be double null terminated sequence of string for
                    REG_MULTI_SZ strings
    cchDefaultValue  count of characters in default value string,
                     including double null characters.

  Return:
    pointer to newly allocated string containing the data read from registry
      or the default string.

--*/
{
    TCHAR   * pszBuffer1 = NULL;
    DWORD     err;


    if( hkey == NULL ) {

        //
        //  Pretend the key wasn't found.
        //

        err = ERROR_FILE_NOT_FOUND;

    } else {

        DWORD     cbBuffer = 0;
        DWORD     dwType;

        //
        //  Determine the buffer size.
        //

        err = RegQueryValueEx( hkey,
                              pszValueName,
                              NULL,
                              &dwType,
                              NULL,
                              &cbBuffer );

        if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) ) {

            if(( dwType != REG_SZ ) &&
               ( dwType != REG_MULTI_SZ ) &&
               ( dwType != REG_EXPAND_SZ )
               ) {

                //
                //  Type mismatch, registry data NOT a string.
                //  Use default.
                //

                err = ERROR_FILE_NOT_FOUND;

            } else {

                //
                //  Item found, allocate a buffer.
                //

                pszBuffer1 = (TCHAR *) TCP_ALLOC( cbBuffer+sizeof(TCHAR) );

                if( pszBuffer1 == NULL ) {

                    err = GetLastError();
                } else {

                    //
                    //  Now read the value into the buffer.
                    //

                    err = RegQueryValueEx( hkey,
                                           pszValueName,
                                           NULL,
                                           NULL,
                                           (LPBYTE)pszBuffer1,
                                           &cbBuffer );
                }
            }
        }
    }

    if( err == ERROR_FILE_NOT_FOUND ) {

        //
        //  Item not found, use default value.
        //

        err = NO_ERROR;

        if( pchDefaultValue != NULL ) {

            if ( pszBuffer1 != NULL) {

                TCP_FREE( pszBuffer1);
            }

            pszBuffer1 = (TCHAR *)TCP_ALLOC((cbDefaultValue) *
                                            sizeof(TCHAR));

            if( pszBuffer1 == NULL ) {

                err = GetLastError();
            } else {

                memcpy(pszBuffer1, pchDefaultValue,
                       cbDefaultValue*sizeof(TCHAR) );
            }
        }
    }

    if( err != NO_ERROR ) {

        //
        //  Something tragic happend; free any allocated buffers
        //  and return NULL to the caller, indicating failure.
        //

        if( pszBuffer1 != NULL ) {

            TCP_FREE( pszBuffer1 );
            pszBuffer1 = NULL;
          }

        SetLastError( err);
    }


    return pszBuffer1;

} // FtpdReadRegistryString()




BOOL
FtpdReadRegString(
    IN HKEY     hkey,
    OUT TCHAR * * ppchstr,
    IN LPCTSTR  pchValue,
    IN LPCTSTR  pchDefault,
    IN DWORD    cchDefault
    )
/*++

   Description

     Gets the specified string from the registry.  If *ppchstr is not NULL,
     then the value is freed.  If the registry call fails, *ppchstr is
     restored to its previous value.

   Arguments:

      hkey - Handle to open key
      ppchstr - Receives pointer of allocated memory of the new value of the
        string
      pchValue - Which registry value to retrieve
      pchDefault - Default string if value isn't found
      cchDefault - count of characters in default value

   Note:

--*/
{
    CHAR * pch = *ppchstr;

    *ppchstr = FtpdReadRegistryString(hkey,
                                      pchValue,
                                      pchDefault,
                                      cchDefault);

    if ( !*ppchstr )
    {
        *ppchstr = pch;
        return FALSE;
    }

    if ( pch ) {

        //
        // use TCP_FREE since FtpdReadRegistryString() uses TCP_ALLOC
        //  to allocate the chunk of memory
        //

        TCP_FREE( pch );
    }

    return TRUE;

} // FtpdReadRegString()


BOOL
FTP_IIS_SERVICE::AddInstanceInfo(
    IN DWORD dwInstance,
    IN BOOL fMigrateRoots
    )
{
    PFTP_SERVER_INSTANCE pInstance;
    CHAR                 szHost[MAXGETHOSTSTRUCT];

    IF_DEBUG(SERVICE_CTRL) {
        DBGPRINTF(( DBG_CONTEXT,
            "AddInstanceInfo: instance %d reg %s\n", dwInstance, QueryRegParamKey() ));
    }

    // Guard against startup race where another thread might be adding
    // instances before the MSFTPSVC thread is finished with initializing
    // the g_pInetSvc pointer.

    if ( g_pInetSvc == NULL )
    {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    // Get the current host name.
    //

    if( gethostname( szHost, sizeof(szHost) ) < 0 ) {

        return FALSE;

    }

    //
    // Create the new instance
    //

    pInstance = new FTP_SERVER_INSTANCE(
                                this,
                                dwInstance,
                                IPPORT_FTP,
                                QueryRegParamKey(),
                                FTPD_ANONYMOUS_SECRET_W,
                                FTPD_ROOT_SECRET_W,
                                fMigrateRoots
                                );

    if (pInstance == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    //
    // must be before AddInstanceInfoHelper() as the local host name
    // is needed when initializing the authentication info under AD isolation
    //
    if( pInstance->SetLocalHostName( szHost ) != NO_ERROR ) {
        return FALSE;
    }

    if( !AddInstanceInfoHelper( pInstance ) ) {
        return FALSE;
    }

    return TRUE;

}   // FTP_IIS_SERVICE::AddInstanceInfo

DWORD
FTP_IIS_SERVICE::DisconnectUsersByInstance(
    IN IIS_SERVER_INSTANCE * pInstance
    )
/*++

    Virtual callback invoked by IIS_SERVER_INSTANCE::StopInstance() to
    disconnect all users associated with the given instance.

    Arguments:

        pInstance - All users associated with this instance will be
            forcibly disconnected.

--*/
{

    ((FTP_SERVER_INSTANCE *)pInstance)->DisconnectAllConnections();
    return NO_ERROR;

}   // FTP_IIS_SERVICE::DisconnectUsersByInstance

VOID
FTP_SERVER_INSTANCE::MDChangeNotify(
    MD_CHANGE_OBJECT * pco
    )
/*++

    Handles metabase change notifications.

    Arguments:

        pco - Path and ID that changed.

--*/
{

    FIELD_CONTROL control = 0;
    DWORD i;
    DWORD err;
    DWORD id;
    PCSTR pszURL;
    DWORD dwURLLength;

    //
    // Let the parent deal with it.
    //

    IIS_SERVER_INSTANCE::MDChangeNotify( pco );

    //
    // Now flush the metacache and relevant file handle cache entries.
    //

    TsFlushMetaCache(METACACHE_FTP_SERVER_ID, FALSE);

    if ( !_mbsnbicmp((PUCHAR)pco->pszMDPath, (PUCHAR)QueryMDVRPath(),
                     _mbslen( (PUCHAR)QueryMDVRPath() )) )
    {
        pszURL = (CHAR *)pco->pszMDPath + QueryMDVRPathLen() - 1;

        //
        // Figure out the length of the URL. Unless this is the root,
        // we want to strip the trailing slash.

        if (memcmp(pszURL, "/", sizeof("/")) != 0)
        {
            dwURLLength = strlen(pszURL) - 1;
        }
        else
        {
            dwURLLength = sizeof("/") - 1;
        }

    }
    else
    {
        //
        // Presumably this is for a change above the root URL level, i.e. a
        // change of a property at the service level. Since this affects
        // everything, flush starting at the root.
        //

        pszURL = "/";
        dwURLLength = sizeof("/") - 1;
    }

    DBG_ASSERT(pszURL != NULL);
    DBG_ASSERT(*pszURL != '\0');

    TsFlushURL(GetTsvcCache(), pszURL, dwURLLength, RESERVED_DEMUX_URI_INFO);

    //
    // Interpret the changes.
    //

    for( i = 0 ; i < pco->dwMDNumDataIDs ; i++ ) {

        id = pco->pdwMDDataIDs[i];

        switch( id ) {

        case MD_EXIT_MESSAGE :
            control |= FC_FTP_EXIT_MESSAGE;
            break;

        case MD_GREETING_MESSAGE :
            control |= FC_FTP_GREETING_MESSAGE;
            break;

        case MD_BANNER_MESSAGE :
            control |= FC_FTP_BANNER_MESSAGE;
            break;

        case MD_MAX_CLIENTS_MESSAGE :
            control |= FC_FTP_MAX_CLIENTS_MESSAGE;
            break;

        case MD_MSDOS_DIR_OUTPUT :
            control |= FC_FTP_MSDOS_DIR_OUTPUT;
            break;

        case MD_ALLOW_ANONYMOUS :
            control |= FC_FTP_ALLOW_ANONYMOUS;
            break;

        case MD_ANONYMOUS_ONLY :
            control |= FC_FTP_ANONYMOUS_ONLY;
            break;

        case MD_ALLOW_REPLACE_ON_RENAME :
            control |= FC_FTP_ALLOW_REPLACE_ON_RENAME;
            break;

        case MD_SHOW_4_DIGIT_YEAR :
            control |= FC_FTP_SHOW_4_DIGIT_YEAR;
            break;

        case MD_USER_ISOLATION :
            // Don't do this --- control |= FC_FTP_USER_ISOLATION;
            // UserIsolation cannot change on the fly, so do not update this field
            break;

        case MD_FTP_LOG_IN_UTF_8 :
            control |= FC_FTP_LOG_IN_UTF_8;
            break;

        case MD_ANONYMOUS_USER_NAME :
        case MD_ANONYMOUS_PWD :
        case MD_ANONYMOUS_USE_SUBAUTH :
        case MD_AD_CONNECTIONS_USERNAME:
        case MD_AD_CONNECTIONS_PASSWORD:
        case MD_DEFAULT_LOGON_DOMAIN :
        case MD_LOGON_METHOD :
            err = ReadAuthentInfo( FALSE, id );

            if( err != NO_ERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "FTP_SERVER_INSTANCE::MDChangeNotify() cannot read authentication info, error %d\n",
                    err
                    ));

            }
            break;

        }

    }

    if( control != 0 ) {

        err = InitFromRegistry( control );

        if( err != NO_ERROR ) {

            DBGPRINTF((
                DBG_CONTEXT,
                "FTP_SERVER_INSTANCE::MDChangeNotify() cannot read config, error %lx\n",
                err
                ));

        }

    }

}   // FTP_SERVER_INSTANCE::MDChangeNotify


DWORD
FTP_SERVER_INSTANCE::ReadAuthentInfo(
    IN BOOL ReadAll,
    IN DWORD SingleItemToRead
    )
/*++

    Reads per-instance authentication info from the metabase.

    Arguments:

        ReadAll - If TRUE, then all authentication related items are
            read from the metabase. If FALSE, then only a single item
            is read.

        SingleItemToRead - The single authentication item to read if
            ReadAll is FALSE. Ignored if ReadAll is TRUE.

    Returns:

        DWORD - 0 if successful, !0 otherwise.

--*/
{

    DWORD tmp;
    DWORD err = NO_ERROR;
    BOOL rebuildAcctDesc = FALSE;
    STACK_STATSTR  (strADConn, MAX_PATH + 1);
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );

    //
    // Lock our configuration (since we'll presumably be making changes)
    // and open the metabase.
    //

    LockConfig();

    if( !mb.Open( QueryMDPath() ) ) {

        err = GetLastError();

        DBGPRINTF((
            DBG_CONTEXT,
            "ReadAuthentInfo: cannot open metabase, error %lx\n",
            err
            ));

    }

    //
    // Read the anonymous username if necessary. Note this is a REQUIRED
    // property. If it is missing from the metabase, bail.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_USER_NAME ) ) {

        if( mb.GetStr(
                "",
                MD_ANONYMOUS_USER_NAME,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strAnonUserName
                ) ) {

            rebuildAcctDesc = TRUE;

        } else {

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: cannot read MD_ANONYMOUS_USER_NAME, error %lx\n",
                err
                ));

        }

    }

    //
    // Read the "use subauthenticator" flag if necessary. This is an
    // optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_USE_SUBAUTH ) ) {

        if( !mb.GetDword(
                "",
                MD_ANONYMOUS_USE_SUBAUTH,
                IIS_MD_UT_SERVER,
                &tmp
                ) ) {

            tmp = DEFAULT_USE_SUBAUTH;

        }

        m_TcpAuthentInfo.fDontUseAnonSubAuth = !tmp;

    }

    //
    // Read the anonymous password if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_ANONYMOUS_PWD ) ) {

        if( mb.GetStr(
                "",
                MD_ANONYMOUS_PWD,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strAnonUserPassword,
                METADATA_INHERIT,
                DEFAULT_ANONYMOUS_PWD
                ) ) {

            //
            // hide this from curious memory dump analizers
            //

            m_TcpAuthentInfo.strAnonUserPassword.Hash();
            m_TcpAuthentInfo.fPwdIsHashed = TRUE;

            rebuildAcctDesc = TRUE;

        } else {

            //
            // Since we provided a default value to mb.GetStr(), it should
            // only fail if something catastrophic occurred, such as an
            // out of memory condition.
            //

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: cannot read MD_ANONYMOUS_PWD, error %lx\n",
                err
                ));

        }

    }

    //
    // Read the AD Access username if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_AD_CONNECTIONS_USERNAME ) ) {

        if( mb.GetStr(
                "",
                MD_AD_CONNECTIONS_USERNAME,
                IIS_MD_UT_SERVER,
                &strADConn,
                METADATA_INHERIT,
                DEFAULT_AD_CONNECTIONS_USERNAME
                ) ) {

            //
            // if a property exists, parse it into separat username and domain tokens
            //

            if (strADConn.IsEmpty()) {

                m_ADConnAuthentInfo.strName.Reset();
                m_ADConnAuthentInfo.strDomain.Reset();

            } else {

                BOOL fIsLocalUser;
                CHAR szDomainAndUser[ UNLEN + DNLEN + 2 ];
                PSTR pszUser = NULL, pszDomain = NULL;

                if (
                    (strADConn.QueryCCH() >= sizeof(szDomainAndUser))     ||
                    !strcpy( szDomainAndUser, strADConn.QueryStr())       ||  // this is always false
                    !ParseUserName( szDomainAndUser, &pszUser, &pszDomain,
                                    QueryLocalHostName(), &fIsLocalUser)  ||
                    fIsLocalUser ) {

                    err = ERROR_INVALID_PARAMETER;

                } else {

                    m_ADConnAuthentInfo.strName.Copy( pszUser);
                    m_ADConnAuthentInfo.strDomain.Copy( pszDomain);
                }
            }

        } else {

            //
            // Since we provided a default value to mb.GetStr(), it should
            // only fail if something catastrophic occurred, such as an
            // out of memory condition.
            //

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: cannot read MD_AD_CONNECTIONS_USERNAME, error %lx\n",
                err
                ));
        }
    }

    //
    // Read the AD Access password if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_AD_CONNECTIONS_PASSWORD ) ) {

        if( mb.GetStr(
                "",
                MD_AD_CONNECTIONS_PASSWORD,
                IIS_MD_UT_SERVER,
                &m_ADConnAuthentInfo.strPassword,
                METADATA_INHERIT,
                DEFAULT_AD_CONNECTIONS_PASSWORD
                ) ) {

            //
            // hide this from curious memory dump analizers
            //

            m_ADConnAuthentInfo.strPassword.Hash();

        } else {

            //
            // Since we provided a default value to mb.GetStr(), it should
            // only fail if something catastrophic occurred, such as an
            // out of memory condition.
            //

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: cannot read MD_AD_CONNECTIONS_PASSWORD, error %lx\n",
                err
                ));

        }

    }

    //
    // Read the default logon domain if necessary. This is an optional
    // property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_DEFAULT_LOGON_DOMAIN ) ) {

        if( !mb.GetStr(
                "",
                MD_DEFAULT_LOGON_DOMAIN,
                IIS_MD_UT_SERVER,
                &m_TcpAuthentInfo.strDefaultLogonDomain
                ) ) {

            //
            // Generate a default domain name.
            //

            err = GetDefaultDomainName( &m_TcpAuthentInfo.strDefaultLogonDomain );

            if( err != NO_ERROR ) {

                DBGPRINTF((
                    DBG_CONTEXT,
                    "ReadAuthentInfo: cannot get default domain name, error %d\n",
                    err
                    ));

            }

        }

    }

    //
    // Read the logon method if necessary. This is an optional property.
    //

    if( err == NO_ERROR &&
        ( ReadAll || SingleItemToRead == MD_LOGON_METHOD ) ) {

        if( !mb.GetDword(
                "",
                MD_LOGON_METHOD,
                IIS_MD_UT_SERVER,
                &tmp
                ) ) {

            tmp = DEFAULT_LOGON_METHOD;
        }

        m_TcpAuthentInfo.dwLogonMethod = tmp;

    }

    //
    // If anything changed that could affect the anonymous account
    // descriptor, then rebuild the descriptor.
    //

    if( err == NO_ERROR && rebuildAcctDesc ) {

        if( !BuildAnonymousAcctDesc( &m_TcpAuthentInfo ) ) {

            DBGPRINTF((
                DBG_CONTEXT,
                "ReadAuthentInfo: BuildAnonymousAcctDesc() failed\n"
                ));

            err = ERROR_NOT_ENOUGH_MEMORY;  // SWAG

        }

    }

    UnLockConfig();
    return err;

}   // FTP_SERVER_INSTANCE::ReadAuthentInfo

BOOL
FTP_IIS_SERVICE::GetGlobalStatistics(
    IN DWORD dwLevel,
    OUT PCHAR *pBuffer
    )
{
    APIERR err = NO_ERROR;


    switch( dwLevel ) {
        case 0 : {

            LPFTP_STATISTICS_0 pstats0;

            pstats0 = (LPFTP_STATISTICS_0)
                       MIDL_user_allocate(sizeof(FTP_STATISTICS_0));

            if( pstats0 == NULL ) {

                err = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                ZeroMemory( pstats0, sizeof( *pstats0 ) );

                g_pFTPStats->CopyToStatsBuffer( pstats0 );

                *pBuffer = (PCHAR)pstats0;
            }

        }

        break;

     default :
        err = ERROR_INVALID_LEVEL;
        break;
    }



    SetLastError(err);
    return(err == NO_ERROR);
}   // FTP_IIS_SERVICE::GetGlobalStatistics


BOOL
FTP_IIS_SERVICE::AggregateStatistics(
        IN PCHAR    pDestination,
        IN PCHAR    pSource
        )
{
    LPFTP_STATISTICS_0   pStatDest = (LPFTP_STATISTICS_0) pDestination;
    LPFTP_STATISTICS_0   pStatSrc  = (LPFTP_STATISTICS_0) pSource;

    if ((NULL == pDestination) || (NULL == pSource))
    {
        return FALSE;
    }

    pStatDest->TotalBytesSent.QuadPart      += pStatSrc->TotalBytesSent.QuadPart;
    pStatDest->TotalBytesReceived.QuadPart  += pStatSrc->TotalBytesReceived.QuadPart;

    pStatDest->TotalFilesSent               += pStatSrc->TotalFilesSent;
    pStatDest->TotalFilesReceived           += pStatSrc->TotalFilesReceived;
    pStatDest->CurrentAnonymousUsers        += pStatSrc->CurrentAnonymousUsers;
    pStatDest->CurrentNonAnonymousUsers     += pStatSrc->CurrentNonAnonymousUsers;
    pStatDest->TotalAnonymousUsers          += pStatSrc->TotalAnonymousUsers;
    pStatDest->MaxAnonymousUsers            += pStatSrc->MaxAnonymousUsers;
    pStatDest->MaxNonAnonymousUsers         += pStatSrc->MaxNonAnonymousUsers;

    pStatDest->CurrentConnections           += pStatSrc->CurrentConnections;
    pStatDest->MaxConnections               += pStatSrc->MaxConnections;
    pStatDest->ConnectionAttempts           += pStatSrc->ConnectionAttempts;
    pStatDest->LogonAttempts                += pStatSrc->LogonAttempts;
    pStatDest->ServiceUptime                = pStatSrc->ServiceUptime;


    // bandwidth throttling info. Not relevant for FTP

    /*
    pStatDest->CurrentBlockedRequests       += pStatSrc->CurrentBlockedRequests;
    pStatDest->TotalBlockedRequests         += pStatSrc->TotalBlockedRequests;
    pStatDest->TotalAllowedRequests         += pStatSrc->TotalAllowedRequests;
    pStatDest->TotalRejectedRequests        += pStatSrc->TotalRejectedRequests;
    pStatDest->MeasuredBandwidth            += pStatSrc->MeasuredBandwidth;
    */

    return TRUE;
}

////////////////////////////////////////////////////
//
// FTP_PASV_PORT
// Site level configuration of passive data port range
//
////////////////////////////////////////////////////

CRITICAL_SECTION  FTP_PASV_PORT::m_csPasvPortRange;
PORT              FTP_PASV_PORT::m_dwPasvPortRangeStart = 0;
PORT              FTP_PASV_PORT::m_dwPasvPortRangeEnd = 0;
LONG              FTP_PASV_PORT::m_dwNextPasvPort = 0;

BOOL
FTP_PASV_PORT::Configure()
{
    MB mb( (IMDCOM*)g_pInetSvc->QueryMDObject() );
    STACK_STR(strPortRange, 16);
    ULONG RangeStart, RangeEnd;
    PSTR pCh;
    const CHAR * sz[1];

    if( !mb.Open( g_pInetSvc->QueryMDPath() ) ||
        !mb.GetStr( "",
                    MD_PASSIVE_PORT_RANGE,
                    IIS_MD_UT_SERVER,
                    &strPortRange,
                    METADATA_INHERIT,
                    "" ) ) {

        sz[0] = g_pInetSvc->QueryMDPath();
        g_pInetSvc->LogEvent( FTP_PASVPORT_MB_ACCESS_FAILED,
                              1,
                              sz,
                              GetLastError() );
        return FALSE;
    }

    // empty value is OK - it's the default
    if (strPortRange.IsEmpty()) {
        return TRUE;
    }

    RangeStart = strtoul(strPortRange.QueryStr(), &pCh, 10);
    if (*pCh == '-') {
        RangeEnd = strtoul(pCh+1, &pCh, 10);
    } else {
        RangeEnd = RangeStart;
    }

    // validate the range: over 5000, under 64K, and start <= end
    if ((RangeStart <= 5000)    || (RangeEnd <= 5000) ||
        (RangeStart > 0xFFFF)   || (RangeEnd > 0xFFFF) ||
        (RangeStart > RangeEnd) ||
        (*pCh != '\0')   ) {

        sz[0] = strPortRange.QueryStr();
        g_pInetSvc->LogEvent( FTP_PASVPORT_INVALID_VALUE,
                              1,
                              sz,
                              ERROR_INVALID_DATA );
        return FALSE;
    }

    m_dwPasvPortRangeStart = (PORT)RangeStart;
    m_dwPasvPortRangeEnd   = (PORT)RangeEnd;
    m_dwNextPasvPort       = RangeStart;

    return TRUE;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\main.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    main.cxx

    This module contains the main startup code for the FTPD Service.

    Functions exported by this module:

        ServiceEntry


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        KeithMo     07-Jan-1994 Made it a DLL (part of TCPSVCS.EXE).
        MuraliK     21-March-1995 Modified it to use InternetServices
                                        common dll ( tcpsvcs.dll)
        MuraliK     11-April-1995 Added global ftp server config objects etc.
                       ( removed usage of Init and Terminate UserDatabase)

*/


#include <ftpdp.hxx>
#include <apiutil.h>
#include <inetsvcs.h>

//
//  Private constants.
//

#define FTPD_MODULE_NAME_A          "ftpsvc2.dll"
#define DEFAULT_RECV_BUFFER_SIZE    (8192)

//
// Global variables for service info and debug variables.
//

DEFINE_TSVC_INFO_INTERFACE( );
DECLARE_DEBUG_PRINTS_OBJECT();

//
// The following critical section synchronizes execution in ServiceEntry().
// This is necessary because the NT Service Controller may reissue a service
// start notification immediately after we have set our status to stopped.
// This can lead to an unpleasant race condition in ServiceEntry() as one
// thread cleans up global state as another thread is initializing it.
//

CRITICAL_SECTION g_csServiceEntryLock;

//
//  Private prototypes.
//

APIERR
InitializeService(
    LPVOID lpContext
    );

APIERR
TerminateService(
    LPVOID lpContext
    );

extern
VOID
FtpdNewConnection(
    IN SOCKET sNew,
    IN SOCKADDR_IN * psockaddr,
    IN PVOID EndpointContext,
    IN PVOID EndpointObject
    );


extern
VOID
FtpdNewConnectionEx(
    IN PVOID        patqContext,
    IN DWORD        cbWritten,
    IN DWORD        dwError,
    IN OVERLAPPED * lpo
    );


DWORD
PrintOutCurrentTime(
            IN CHAR * pszFile,
            IN int lineNum
            );

# ifdef CHECK_DBG
# define PRINT_CURRENT_TIME_TO_DBG()  PrintOutCurrentTime( __FILE__, __LINE__)
# else
# define PRINT_CURRENT_TIME_TO_DBG()  ( NO_ERROR)
# endif // CHECK_DBG



VOID
ServiceEntry(
    DWORD                   cArgs,
    LPSTR                   pArgs[],
    PTCPSVCS_GLOBAL_DATA    pGlobalData     // unused
    )
/*++

    Routine:
        This is the "real" entrypoint for the service.  When
                the Service Controller dispatcher is requested to
                start a service, it creates a thread that will begin
                executing this routine.

    Arguments:
        cArgs - Number of command line arguments to this service.

        pArgs - Pointers to the command line arguments.

    Returns:
        None.  Does not return until service is stopped.

--*/
{
    APIERR err = NO_ERROR;
    BOOL fInitSvcObject = FALSE;

    EnterCriticalSection( &g_csServiceEntryLock );

    if ( !InitCommonDlls() )
    {
        err = GetLastError();
        LeaveCriticalSection( &g_csServiceEntryLock );
        goto notify_scm;
    }

    //
    //  Initialize the service status structure.
    //

    g_pInetSvc = new FTP_IIS_SERVICE(
                            FTPD_SERVICE_NAME,
                            FTPD_MODULE_NAME_A,
                            FTPD_PARAMETERS_KEY_A,
                            INET_FTP_SVC_ID,
                            INET_FTP_SVCLOC_ID,
                            FALSE,
                            0,
                            FtpdNewConnection,
                            FtpdNewConnectionEx,
                            ProcessAtqCompletion
                            );

    //
    //  If we couldn't allocate memory for the service info structure,
    //  then we're totally hozed.
    //

    if( (g_pInetSvc != NULL) && g_pInetSvc->IsActive()) {
        fInitSvcObject = TRUE;

        //
        //  Start the service. This blocks until the service is shutdown.
        //

        err = g_pInetSvc->StartServiceOperation(
                                    SERVICE_CTRL_HANDLER(),
                                    InitializeService,
                                    TerminateService
                                    );

        if( err != NO_ERROR) {

            //
            //  The event has already been logged.
            //

            DBGPRINTF(( DBG_CONTEXT,
                       "FTP ServiceEntry: StartServiceOperation returned %d\n",
                       err ));
        }

    } else {

        if ( g_pInetSvc ) {
            err = g_pInetSvc->QueryCurrentServiceError();
        } else {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }


    if( g_pInetSvc != NULL ) {

        //
        // delete the service object
        //

        g_pInetSvc->CloseService( );
        g_pInetSvc = NULL;
    }

    TerminateCommonDlls();
    LeaveCriticalSection( &g_csServiceEntryLock );

notify_scm:
    //
    // We need to tell the Service Control Manager that the service
    // is stopped if we haven't called g_pInetSvc->StartServiceOperation.
    //  1) InitCommonDlls fails, or
    //  2) new operator failed, or
    //  3) FTP_IIS_SERVICE constructor couldn't initialize properly
    //

    if ( !fInitSvcObject ) {
        SERVICE_STATUS_HANDLE hsvcStatus;
        SERVICE_STATUS svcStatus;

        hsvcStatus = RegisterServiceCtrlHandler( FTPD_SERVICE_NAME,
                                                 SERVICE_CTRL_HANDLER() );


        if ( hsvcStatus != NULL_SERVICE_STATUS_HANDLE ) {
            svcStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
            svcStatus.dwCurrentState = SERVICE_STOPPED;
            svcStatus.dwWin32ExitCode = err;
            svcStatus.dwServiceSpecificExitCode = err;
            svcStatus.dwControlsAccepted = 0;
            svcStatus.dwCheckPoint = 0;
            svcStatus.dwWaitHint = 0;

            SetServiceStatus( hsvcStatus, (LPSERVICE_STATUS) &svcStatus );
        }
    }

} // ServiceEntry()




//
//  Private functions.
//

DWORD
InitializeInstances(
    PFTP_IIS_SERVICE pService
    )
/*++

Routine Description:

    Read the instances from the registry

Arguments:

    pService - Server instance added to.

Return Value:

    Win32

--*/
{
    DWORD                err = NO_ERROR;
    DWORD                i;
    DWORD                cInstances = 0;
    MB                   mb( (IMDCOM*) pService->QueryMDObject() );
    BUFFER               buff;
    CHAR                 szKeyName[MAX_PATH+1];
    BOOL                 fMigrateRoots = FALSE;

    //
    //  Open the metabase for write to get an atomic snapshot
    //

    if ( !mb.Open( "/LM/MSFTPSVC/",
                   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ))
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "InitializeInstances: Cannot open path %s, error %lu\n",
                    "/LM/MSFTPSVC/", GetLastError() ));

#if 1 // Temporary until setup is modified to create the instances in the metabase
        if ( !mb.Open( METADATA_MASTER_ROOT_HANDLE,
               METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) ||
             !mb.AddObject( "/LM/MSFTPSVC/" ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create service, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }
#else
        return GetLastError();
#endif
    }

TryAgain:
    i = 0;
    while ( mb.EnumObjects( "",
                            szKeyName,
                            i++ ))
    {
        DWORD dwInstance;

        //
        // Get the instance id
        //

        dwInstance = atoi( szKeyName );
        if ( dwInstance == 0 ) {
            continue;
        }

        if ( buff.QuerySize() < (cInstances + 1) * sizeof(DWORD) )
        {
            if ( !buff.Resize( (cInstances + 10) * sizeof(DWORD)) )
            {
                return GetLastError();
            }
        }

        ((DWORD *) buff.QueryPtr())[cInstances++] = dwInstance;
    }

    if ( cInstances == 0 )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "No defined instances\n" ));

        if ( !mb.AddObject( "1" ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Unable to create first instance, error %d\n",
                        GetLastError() ));

            return GetLastError();
        }

        fMigrateRoots = TRUE; // Force reg->metabase migration of virtual directories
        goto TryAgain;
    }

    DBG_REQUIRE( mb.Close() );

    for ( i = 0; i < cInstances; i++ )
    {
        DWORD dwInstance = ((DWORD *)buff.QueryPtr())[i];

        if( !g_pInetSvc->AddInstanceInfo( dwInstance, fMigrateRoots ) ) {

            err = GetLastError();

            DBGPRINTF((
                DBG_CONTEXT,
                "InitializeInstances: cannot create instance %lu, error %lu\n",
                dwInstance,
                err
                ));

            break;

        }

    }

    return err;

}   // InitializeInstances


APIERR
InitializeService(
    LPVOID lpContext
    )
/*++

    Routine:
        This function initializes the various FTPD Service components.

    Arguments:
        lpContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err = NO_ERROR;
    PFTP_IIS_SERVICE  pInetSvc = (PFTP_IIS_SERVICE)lpContext;

    DBG_ASSERT( lpContext == g_pInetSvc);

    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT,"Initializing ftp service\n" ));
    }

    //
    //  Initialize various components.  The ordering of the
    //  components is somewhat limited.
    //  We should initialize connections as the last item,
    //   since it kicks off the connection thread.
    //

    err = PRINT_CURRENT_TIME_TO_DBG();

    if(( err = InitializeGlobals() )          != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ||
       ( err = pInetSvc->InitializeSockets()) != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ||
       ( err = pInetSvc->InitializeDiscovery( )) != NO_ERROR ||
       ( err = PRINT_CURRENT_TIME_TO_DBG())   != NO_ERROR ) {

       DBGPRINTF(( DBG_CONTEXT,
                     "cannot initialize ftp service, error %lu\n",err ));

        goto exit;

    }

    //
    //  Success!
    //

    DBG_ASSERT( err == NO_ERROR);

    //
    // From discusssions with KeithMo, we decided to punt on the
    //   default buffer size for now. Later on if performance is
    //   critical, we will try to improve on this by proper values
    //   for listen socket.
    //

    g_SocketBufferSize = DEFAULT_RECV_BUFFER_SIZE;

    IF_DEBUG( SERVICE_CTRL )  {

        DBGPRINTF(( DBG_CONTEXT, " %s service initialized\n",
                   pInetSvc->QueryServiceName())
                  );
    }

    //
    // Initialize all instances
    //
    InitializeInstances(pInetSvc);


    g_pFTPStats->UpdateStartTime();

exit:

    PRINT_CURRENT_TIME_TO_DBG();

    return ( err);

} // InitializeService()





APIERR
TerminateService(
    LPVOID lpContext
    )
/*++

    Routine:
        This function cleans up the various FTPD Service components.

    Arguments:
        lpContext - Pointer to the service object

    Returns:
        NO_ERROR if successful, otherwise a Win32
                    status code.

--*/
{
    APIERR err = NO_ERROR;
    PFTP_IIS_SERVICE pInetSvc = (PFTP_IIS_SERVICE)lpContext;

    DBG_ASSERT( lpContext == g_pInetSvc);


    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT, "terminating service\n" ));
    }

    PRINT_CURRENT_TIME_TO_DBG();

    if (g_pFTPStats) {
        g_pFTPStats->UpdateStopTime();
    }

    //
    //  Components should be terminated in reverse
    //  initialization order.
    //

    g_pInetSvc->ShutdownService( );

    PRINT_CURRENT_TIME_TO_DBG();
    IF_DEBUG( SERVICE_CTRL ) {
        DBGPRINTF(( DBG_CONTEXT, "Ftp service terminated\n" ));
    }

    PRINT_CURRENT_TIME_TO_DBG();
    err = pInetSvc->TerminateDiscovery();

    if ( err != NO_ERROR) {
        DBGPRINTF( ( DBG_CONTEXT,
                    "CleanupService( %s):"
                    " TerminateDiscovery failed, err=%lu\n",
                    pInetSvc->QueryServiceName(),
                    err));
    }

    PRINT_CURRENT_TIME_TO_DBG();
    pInetSvc->CleanupSockets();

    PRINT_CURRENT_TIME_TO_DBG();

    TsCacheFlush( INET_FTP_SVC_ID );
    TsFlushMetaCache(METACACHE_FTP_SERVER_ID, TRUE);
    TerminateGlobals();

    return ( err);

} // TerminateService()



# ifdef CHECK_DBG
DWORD PrintOutCurrentTime(IN CHAR * pszFile, IN int lineNum)
/*++
  This function generates the current time and prints it out to debugger
   for tracing out the path traversed, if need be.

  Arguments:
      pszFile    pointer to string containing the name of the file
      lineNum    line number within the file where this function is called.

  Returns:
      NO_ERROR always.
--*/
{
    CHAR    szBuffer[1000];

    DBG_REQUIRE( _snprintf( szBuffer, sizeof( szBuffer ),
            "[%u]( %40s, %10d) TickCount = %u\n",
            GetCurrentThreadId(),
            pszFile,
            lineNum,
            GetTickCount()
            ) > 0);

    OutputDebugString( szBuffer);

    return ( NO_ERROR);

} // PrintOutCurrentTime()

# endif // CHECK_DBG

extern "C" {

BOOL
WINAPI
DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpvReserved
    )
{


    switch ( dwReason ) {

    case DLL_PROCESS_ATTACH:
        CREATE_DEBUG_PRINT_OBJECT( FTPD_SERVICE_NAME);
        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return FALSE;  // Nothing can be done. Debug Print object failed!
        }
        LOAD_DEBUG_FLAGS_FROM_REG_STR(FTPD_PARAMETERS_KEY_A, 0);

        DBG_REQUIRE( DisableThreadLibraryCalls( hDll ) );
        INITIALIZE_CRITICAL_SECTION( &g_csServiceEntryLock );
        break;

    case DLL_PROCESS_DETACH:
        DELETE_DEBUG_PRINT_OBJECT();
        DeleteCriticalSection( &g_csServiceEntryLock );
        break;

    }

    return TRUE;

}   // DLLEntry

}   // extern "C"

/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\globals.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    globals.cxx

    This module contains global variable definitions shared by the
    various FTPD Service components.

    Functions exported by this module:

        InitializeGlobals
        TerminateGlobals
        ReadParamsFromRegistry
        WriteParamsToRegistry


    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     11-April-1995 Created new global ftp server config object

*/


#include "ftpdp.hxx"
#include "acptctxt.hxx"

#include <timer.h>

//
//  Private constants.
//

#define DEFAULT_TRACE_FLAGS             0

#define DEFAULT_NO_EXTENDED_FILENAME    0

#define DEFAULT_MAX_AD_CACHE_TIME       (60*10)    // in seconds

#define ACCEPT_CONTEXTS_PER_ENTRY       60
#define DEFAULT_MAX_ACCEPT_ENTRIES      (1*ACCEPT_CONTEXTS_PER_ENTRY)



//
//  Socket transfer buffer size.
//

DWORD                   g_SocketBufferSize = 0;

//
//  Statistics.
//

//
//  FTP Statistics structure.
//

LPFTP_SERVER_STATISTICS g_pFTPStats = NULL;

//
//  Miscellaneous data.
//

//
//  The FTP Server sign-on string.
//

LPSTR                   g_FtpServiceNameString = NULL;

//
//  key for the registry to read parameters
//
HKEY        g_hkeyParams = NULL;


//
// List holding all the PASV accept context entries
//
LIST_ENTRY g_AcceptContextList;

//
// CS to guard manipulation of the accept context list
//
CRITICAL_SECTION g_AcceptContextCS;

//
// maximum number of passive accept context containers (60 events per container)
//
DWORD g_dwMaxAcceptContextEntries = 1;

//
//  The number of threads currently blocked in Synchronous sockets
//  calls, like recv()
//

DWORD       g_ThreadsBlockedInSyncCalls = 0;

//
//  The maximum number of threads that will be allowed to block in
//  Synchronous sockets calls. Magic # that will be changed if the max # of
//  pool threads is less than 100.
//

DWORD       g_MaxThreadsBlockedInSyncCalls = 100;

#ifdef KEEP_COMMAND_STATS

//
//  Lock protecting per-command statistics.
//

CRITICAL_SECTION        g_CommandStatisticsLock;

#endif  // KEEP_COMMAND_STATS


//
//  By default, extended characters are allowed for file/directory names
//  in the data transfer commands. Reg key can disable this.
//

DWORD       g_fNoExtendedChars = FALSE;

//
//  The maximum time in seconds to use a cached DS property before mandatory refresh
//

ULONGLONG   g_MaxAdPropCacheTime = (ULONGLONG)DEFAULT_MAX_AD_CACHE_TIME*10000000;

#if DBG

//
//  Debug-specific data.
//

//
//  Debug output control flags.
//

#endif  // DBG


//
//  Public functions.
//

/*******************************************************************

    NAME:       InitializeGlobals

    SYNOPSIS:   Initializes global shared variables.  Some values are
                initialized with constants, others are read from the
                configuration registry.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

                Also, this routine is called before the event logging
                routines have been initialized.  Therefore, event
                logging is not available.

    HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     05-April-1995 Added FTP server config object

********************************************************************/
APIERR
InitializeGlobals(
    VOID
    )
{
    APIERR      err = NO_ERROR;
    UINT_PTR dwMaxThreads = 0;

#ifdef KEEP_COMMAND_STATS

    INITIALIZE_CRITICAL_SECTION( &g_CommandStatisticsLock );

#endif  // KEEP_COMMAND_STATS

    //
    //  Setup the service sign-on string.
    //

    g_FtpServiceNameString = "Microsoft FTP Service\0";  // must be double \0 terminated


    //
    // Set up PASV accept event variables
    //
    InitializeListHead( &g_AcceptContextList );

    INITIALIZE_CRITICAL_SECTION( &g_AcceptContextCS );

    if ( err = CreateAcceptContext() )
    {
        return err;
    }


    //
    // configure the PassivePortRange object
    //

    if ( !FTP_PASV_PORT::Configure() )
    {
        return ERROR_DLL_INIT_FAILED;
    }

    //
    // Create an FTP server object and load values from registry.
    //

    //
    //  Connect to the registry.
    //

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        FTPD_PARAMETERS_KEY,
                        0,
                        KEY_READ,
                        &g_hkeyParams );

    if( err != NO_ERROR )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "cannot open registry key %s, error %lu\n",
                   FTPD_PARAMETERS_KEY,
                    err ));

        //
        // Load Default values
        //
        err = NO_ERROR;
    }

    //
    // Figure out how many pool threads we can create maximally - if less than built-in
    // number, adjust accordingly
    //

    dwMaxThreads = AtqGetInfo( AtqMaxThreadLimit );

    if ( dwMaxThreads/2 < (UINT_PTR)g_MaxThreadsBlockedInSyncCalls )
    {
        g_MaxThreadsBlockedInSyncCalls = (DWORD)(dwMaxThreads/2);
    }

    DBGPRINTF((DBG_CONTEXT,
               "Max # of threads allowed to be blocked in sync calls : %d\n",
               g_MaxThreadsBlockedInSyncCalls));

    g_fNoExtendedChars = ReadRegistryDword( g_hkeyParams,
                                      FTPD_NO_EXTENDED_FILENAME,
                                      DEFAULT_NO_EXTENDED_FILENAME );

    g_MaxAdPropCacheTime = (ULONGLONG) ReadRegistryDword( g_hkeyParams,
                                      FTPD_DS_CACHE_REFRESH,
                                      DEFAULT_MAX_AD_CACHE_TIME ) * 10000000;

    DWORD dwVal = ReadRegistryDword( g_hkeyParams,
                                      FTPD_MAX_ACCEPT_EVENTS,
                                      DEFAULT_MAX_ACCEPT_ENTRIES ) ;

    // round it up to nearest multiple of events per entry, between 1 and 5.
    dwVal = (dwVal + ACCEPT_CONTEXTS_PER_ENTRY - 1) / ACCEPT_CONTEXTS_PER_ENTRY;
    if (dwVal < 1) {
        dwVal = 1;
    }
    if (dwVal > 5) {
        dwVal = 5;
    }
    g_dwMaxAcceptContextEntries = dwVal;

    g_pFTPStats = new FTP_SERVER_STATISTICS;
    if ( g_pFTPStats == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    FTP_PASV_PORT::Init();

    AD_IO::Initialize();

    return ( err);

}   // InitializeGlobals()







/*******************************************************************

    NAME:       TerminateGlobals

    SYNOPSIS:   Terminate global shared variables.

    NOTES:      This routine may only be called by a single thread
                of execution; it is not necessarily multi-thread safe.

                Also, this routine is called after the event logging
                routines have been terminated.  Therefore, event
                logging is not available.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID
TerminateGlobals(
    VOID
    )
{

    if ( g_hkeyParams != NULL) {

        RegCloseKey( g_hkeyParams);
        g_hkeyParams = NULL;
    }

    if ( g_pFTPStats )
    {
        delete g_pFTPStats;
        g_pFTPStats = NULL;
    }

    AD_IO::Terminate();

    FTP_PASV_PORT::Terminate();

    DeleteAcceptContexts();

    DeleteCriticalSection( &g_AcceptContextCS );

#ifdef KEEP_COMMAND_STATS

    DeleteCriticalSection( &g_CommandStatisticsLock );

#endif  // KEEP_COMMAND_STATS

}   // TerminateGlobals


/************************ End Of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\lsaux.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :
      lsaux.cxx

   Abstract:
      This modules defines the functions supporting list processing.

   Author:

       Murali R. Krishnan    ( MuraliK )     2-May-1995

   Environment:
       User Mode -- Win32

   Project:

       FTP Server DLL

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
# include "ftpdp.hxx"
# include "lsaux.hxx"

/************************************************************
 *    Functions
 ************************************************************/


const FILETIME *
PickFileTime(IN const WIN32_FIND_DATA * pfdInfo,
             IN const LS_OPTIONS  * pOptions)
/*++

  This function selects and returns proper FILETIME structure
   to display based on the current sort method and filesystem
   capabilities.

  Arguments:
    pfdInfo   pointer to file information for a directory entry.
    pOptions  the current ls options

  Returns:
    FILETIME   -- pointer to proper time required

  History:
    MuraliK      25-Apr-1995

   This is a costly operation too. Given that this one is called once every
     directory entry is getting formatted. Can we avoid the cost ?
    YES, if we can use the offsets in the pfdInfo to chose the time object.
    NYI
--*/
{
    const FILETIME *  pliTime;

    switch ( pOptions->SortMethod) {

      case LsSortByName:
      case LsSortByWriteTime:
        pliTime = &pfdInfo->ftLastWriteTime;
        break;

      case LsSortByCreationTime:
        pliTime = &pfdInfo->ftCreationTime;
        break;

      case LsSortByAccessTime:
        pliTime = &pfdInfo->ftLastAccessTime;
        break;

      default:
        IF_DEBUG( ERROR) {
            DBGPRINTF(( DBG_CONTEXT,
                       "Invalid Sort %d!\n", pOptions->SortMethod ));
        }
        DBG_ASSERT( FALSE );
        pliTime = &pfdInfo->ftLastWriteTime;
        break;

    } // switch()

    //
    //  If the selected time field is not supported on
    //  the current filesystem, default to ftLastWriteTime
    //  (all filesystems support this field).
    //

    if( NULL_FILE_TIME( *pliTime ) ) {

        pliTime = &pfdInfo->ftLastWriteTime;
    }

    return ( pliTime);
} // PickFileTime()




BOOL __cdecl
FtpFilterFileInfo(
    IN const WIN32_FIND_DATA * pfdInfo,
    IN LPVOID  pContext
    )
/*++
  This function tries to filter out the file information using
   Ftp service "ls" specific filter.

  Arguments:
    pfdInfo   pointer to file information that contains the current
               file information object for filtering.
    pContext  pointer to FTP_LS_FILTER_INFO  used for filtering.

  Returns:
    TRUE if there is a match and that this file info should not be
      eliminated.
    FALSE if this file info object can be dropped out of generated list.
--*/
{
    register FTP_LS_FILTER_INFO * pfls = (FTP_LS_FILTER_INFO *) pContext;
    DWORD dwAttribs;

    if ( pfdInfo == NULL ||
        pfdInfo->dwFileAttributes == INVALID_FILE_ATTRIBUTES) {

        return ( FALSE);
    }

    //
    // We dont need to expose hidden/system files unless necessary.
    //

    dwAttribs = pfdInfo->dwFileAttributes;

    if (pfls->fFilterHidden && IS_HIDDEN( dwAttribs) ||
        pfls->fFilterSystem && IS_SYSTEM( dwAttribs)) {

        return ( FALSE);       // unwanted files.
    }

    // Always filter away "." and ".."
    const CHAR * pszFileName = ( pfdInfo->cFileName);

    if (pfls->fFilterDotDot && pszFileName[0] == '.' ||
        strcmp( pszFileName, ".") == 0 ||
        strcmp( pszFileName, "..") == 0) {

        return ( FALSE);
    }

    DBG_ASSERT( pfls->pszExpression == NULL || *pfls->pszExpression != '\0');

    //
    // Check about the file name.
    //  If the expression is not a regular expression, use simple StringCompare
    //  else  use a regular expression comparison.
    //  Return TRUE if there is a match else return FALSE.
    //

    return ( pfls->pszExpression == NULL ||  // null-expr ==> all match.
            (( pfls->fRegExpression)
             ? IsNameInRegExpressionA(pfls->pszExpression, pszFileName,
                                      pfls->fIgnoreCase)
             : !strcmp(pszFileName, pfls->pszExpression)
             ));

} // FtpFilterFileInfo()



APIERR
GetDirectoryInfo(
    IN LPUSER_DATA pUserData,
    OUT TS_DIRECTORY_INFO   * pTsDirInfo,
    IN CHAR     *  pszSearchPath,
    IN const FTP_LS_FILTER_INFO * pfls,
    IN PFN_CMP_WIN32_FIND_DATA pfnCompare
    )
/*++
  This function creates a directory listing for given directory,
    filters out unmatched files and sorts the resulting elements
    using the sort function.

  Arguments:
    pUserData    pointer to UserData structure.
    pTsDirInfo   pointer to Directory Information object that will be
                   filled in with the directory information.

    pszSearchPath  pointer to null-terminated string containing
                     the absolute path for directory along with
                     the possible filter specification.
                     eg: d:\foo\bar

    pfls         pointer to filter information used for filtering.

    pfnCompare   pointer to function used for sorting.

  Returns:
    NO_ERROR on success and Win32 error code if there are any failure.

  History:
      MuraliK      25-Apr-1995
--*/
{
    DWORD dwError = NO_ERROR;

    DBG_ASSERT( pTsDirInfo != NULL && pszSearchPath != NULL);
    DBG_ASSERT( !pTsDirInfo->IsValid());  // no dir list yet.

    IF_DEBUG(DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "GetDirListing( dir=%s, Filter=%08x (Sz=%s), "
                   "user=%08x, cmp=%08x)\n",
                   pszSearchPath, pfls, pfls->pszExpression,
                   pUserData->QueryUserToken(), pfnCompare));
    }

    CHAR  rgDirPath[MAX_PATH+10];
    CHAR * pszDirPath;
    DWORD len = strlen( pszSearchPath);

    // check to see if the last character is a "\" in the dir path
    // if not append one to make sure GetDirectoryListing works fine.
    if ( *CharPrev( pszSearchPath, pszSearchPath + len ) != '\\') {
        DBG_ASSERT( len < sizeof(rgDirPath) - 2);
        DBG_REQUIRE( _snprintf( rgDirPath, sizeof( rgDirPath ) - 1, "%s\\", pszSearchPath) > 0);
        rgDirPath[ sizeof( rgDirPath ) - 1] = '\0';
        pszDirPath = rgDirPath;
    } else {

        pszDirPath = pszSearchPath;
    }

    if ( !pTsDirInfo->GetDirectoryListingA(pszDirPath,
                                           pUserData->QueryUserToken())
        ) {

        dwError = GetLastError();
    }


    if ( dwError == NO_ERROR) {

        //
        //  we got the directory listing.
        //  We need to apply filters to restrict the directory listing.
        //  Next we need to sort the resulting mix based on the
        //    sorting options requested by the list command.
        //

        //
        // We need to identify the appropriate filter
        //   file spec to be applied. For present use *.*
        // Filtering should not fail unless tsDirInfo is invalid.
        //

        if ( pfls != NULL) {

            DBG_REQUIRE(pTsDirInfo->FilterFiles(FtpFilterFileInfo,
                                                (LPVOID )pfls)
                        );
        }

        //
        // Sort only if sort function specified
        //

        if ( pfnCompare != NULL) {

            DBG_REQUIRE( pTsDirInfo->SortFileInfoPointers( pfnCompare));
        }
    }

    return ( dwError);
} // GetDirectoryInfo()




/**************************************************
 *   Comparison Functions
 **************************************************/


int __cdecl
CompareNamesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the two directory entries by name of the files.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmpi((LPCSTR )pFileInfo1->cFileName,
                      (LPCSTR )pFileInfo2->cFileName));

} // CompareNamesInFileInfo()



int __cdecl
CompareNamesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the two directory entries by name of the files.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     -1 if pvFileInfo1 > pvFileInfo2
     +1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
}   // CompareNamesRevInFileInfo()





int __cdecl
CompareWriteTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the write times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                              &pFileInfo2->ftLastWriteTime );

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareWriteTimesInFileInfo()





int __cdecl
CompareWriteTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the write times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     -1 if pvFileInfo1 > pvFileInfo2
     +1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareWriteTimesInFileInfo( pvFileInfo1, pvFileInfo2);

}   // CompareWriteTimesRevInFileInfo()



int __cdecl
CompareCreationTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the creation times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    if ( NULL_FILE_TIME( pFileInfo1->ftCreationTime)) {

        nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                                  &pFileInfo2->ftLastWriteTime );
    } else {

        nResult = CompareFileTime(&pFileInfo1->ftCreationTime,
                                  &pFileInfo2->ftCreationTime );
    }

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareCreationTimesInFileInfo()



int __cdecl
CompareCreationTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the creation times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareCreationTimesInFileInfo( pvFileInfo1, pvFileInfo2 );

}   // CompareCreationTimesRevInFileInfo()



int __cdecl
CompareAccessTimesInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++
  Compares the last access times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);


    INT nResult;

    if ( NULL_FILE_TIME( pFileInfo1->ftLastAccessTime)) {

        nResult = CompareFileTime(&pFileInfo1->ftLastWriteTime,
                                  &pFileInfo2->ftLastWriteTime );
    } else {

        nResult = CompareFileTime(&pFileInfo1->ftLastAccessTime,
                                  &pFileInfo2->ftLastAccessTime );
    }

    if( nResult == 0 ) {

        nResult = CompareNamesInFileInfo( pvFileInfo1, pvFileInfo2);
    }

    return nResult;

}   // CompareAccessTimesInFileInfo()



int __cdecl
CompareAccessTimesRevInFileInfo(
    IN  const void * pvFileInfo1,
    IN  const void * pvFileInfo2)
/*++

  Compares the last access times of two directory entries.

  Arguments:

    pvFileInfo1    pointer to FileBothDirInfo object 1.
    pvFileInfo2    pointer to FileBothDirInfo object 2.

  Returns:
     0 if they are same
     +1 if pvFileInfo1 > pvFileInfo2
     -1 if pvFileInfo1 < pvFileInfo2

   History:
      MuraliK         25-Apr-1995
--*/
{
    return -CompareAccessTimesInFileInfo( pvFileInfo1, pvFileInfo2 );

}   // CompareAccessTimesRevInFileInfo()






DWORD
ComputeModeBits(
    IN HANDLE            hUserToken,
    IN const CHAR *      pszPathPart,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN DWORD           * pcLinks,
    IN BOOL              fVolumeReadable,
    IN BOOL              fVolumeWritable
    )
/*++
  This function computes the mode buts r-w-x for a specific file.

  Arguments:
    hUserToken   - The security token of the user that initiated the request.
    pszPathPart  - contains the search path for this directory.
    pfdInfo      - pointer to File information
    pcLinks      - will receive the count of symbolic links to this file.
    fVolumeReadable - TRUE if volume is readable
    fVolumeWritable - TRUE if volume is writable

  Returns:
    DWORD - A combination of FILE_MODE_R, FILE_MODE_W, and FILE_MODE_X bits.

  HISTORY:
    KeithMo     01-Jun-1993 Created.
    MuraliK     26-Apr-1995 Modified to support new pfdInfo
--*/
{
    APIERR err;
    DWORD  dwAccess;
    DWORD  dwMode = 0;

    DBG_ASSERT( hUserToken != NULL );
    DBG_ASSERT( pszPathPart != NULL );
    DBG_ASSERT( pfdInfo != NULL );
    DBG_ASSERT( pcLinks != NULL );
    DBG_ASSERT( pszPathPart[1] == ':' );
    DBG_ASSERT( pszPathPart[2] == '\\' );

    if( !( GetFsFlags( *pszPathPart ) & FS_PERSISTENT_ACLS ) )
    {
        //
        //  Short-circuit if on a non-NTFS partition.
        //

        *pcLinks = 1;
        dwAccess = FILE_ALL_ACCESS;

        err = NO_ERROR;
    }
    else
    {
        CHAR   szPath[MAX_PATH*2];
        CHAR * pszEnd;
        INT    len1 = strlen( pszPathPart );
        INT    len2 = strlen( pfdInfo->cFileName);

        //
        //  Determine the maximum file access allowed.
        //

        DBG_ASSERT( strlen( pszPathPart) +
                   strlen( pfdInfo->cFileName) < MAX_PATH * 2);

        if ((len1 + len2 + 2) <= sizeof(szPath)) {
            memcpy( szPath, pszPathPart, len1+1 );
            pszEnd = CharPrev( szPath, szPath + len1 );
            if( *pszEnd != '\\' && *pszEnd != '/' ) {
                pszEnd = szPath + len1;
                *pszEnd = '\\';
            }
            memcpy( pszEnd + 1, pfdInfo->cFileName, len2+1 );

            err = ComputeFileInfo( hUserToken,
                                   szPath,
                                   &dwAccess,
                                   pcLinks );
        } else {
            err = ERROR_INSUFFICIENT_BUFFER;
        }
    }

    if( err == NO_ERROR )
    {
        //
        //  Map various NT access to unix-like mode bits.
        //

        if( fVolumeReadable && ( dwAccess & FILE_READ_DATA ) )
        {
            dwMode |= FILE_MODE_R;
        }

        if( fVolumeReadable && ( dwAccess & FILE_EXECUTE ) )
        {
            dwMode |= FILE_MODE_X;
        }

        if( fVolumeWritable &&
            !( pfdInfo->dwFileAttributes & FILE_ATTRIBUTE_READONLY ) &&
            ( dwAccess & FILE_WRITE_DATA  ) &&
            ( dwAccess & FILE_APPEND_DATA ) )
        {
            dwMode |= FILE_MODE_W;
        }
    }

    return dwMode;

}   // ComputeModeBits()




#define DEFAULT_SECURITY_DESC_SIZE ( 2048)
#define DEFAULT_PRIV_SET_SIZE      ( 1024)


APIERR
ComputeFileInfo(
    HANDLE   hUserToken,
    CHAR   * pszFile,
    DWORD  * pdwAccessGranted,
    DWORD  * pcLinks
    )
/*++
  This function uses internal Nt security api's to determine if the
   valid access is granted.

  BEWARE: this function is extremely costly! We need to simplify the cost.
  ==>> NYI

  Arguments:
    hUserToken - handle for the user, for whom we are determining the
                    access and links
    pszFile  - full path for the file.
    pdwAccessGranted - pointer to DWORD which will receive the granted access.
    pcLinks - pointer to count of links for the file.

  Returns:
    Win32 Error code if there is any failure.
    NO_ERROR on success.
--*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    APIERR                      err;
    SECURITY_DESCRIPTOR       * psd      = NULL;
    PRIVILEGE_SET             * pps      = NULL;
    DWORD                       cbsd;
    DWORD                       cbps;
    GENERIC_MAPPING             mapping  = { 0, 0, 0, FILE_ALL_ACCESS };
    HANDLE                      hFile    = INVALID_HANDLE_VALUE;
    BOOL                        fStatus;

    DBG_ASSERT( hUserToken != NULL );
    DBG_ASSERT( pszFile != NULL );
    DBG_ASSERT( pdwAccessGranted != NULL );
    DBG_ASSERT( pcLinks != NULL );

    //
    //  Setup.
    //

    *pdwAccessGranted = 0;
    *pcLinks          = 1;

    //
    //  Open the target file/directory.
    //

    err = OpenPathForAccess( &hFile,
                            pszFile,
                            GENERIC_READ,
                            ( FILE_SHARE_READ | FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE),
                            hUserToken
                            );

    if( err != NO_ERROR )
    {
        return err;
    }

    //
    //  Determine the number of symbolic links.
    //

    if ( GetFileInformationByHandle( hFile,
                                     &FileInfo)
        ) {

        *pcLinks = FileInfo.nNumberOfLinks;
    } else {

        //
        //  We won't let this be serious enough to abort
        //  the entire operation.
        //

        *pcLinks = 1;
    }

    //
    //  Get the file's security descriptor.
    //

    cbsd = DEFAULT_SECURITY_DESC_SIZE;
    psd  = (SECURITY_DESCRIPTOR *)TCP_ALLOC( cbsd );

    if( psd == NULL )
    {
        err = GetLastError();
        goto Cleanup;
    }

    do
    {
        err = NO_ERROR;

        //
        // Replace NtQuerySecurityObject() by GetFileSecurity()
        //

        if (!GetFileSecurity( pszFile,
                             OWNER_SECURITY_INFORMATION
                             | GROUP_SECURITY_INFORMATION
                             | DACL_SECURITY_INFORMATION,
                             psd,
                             cbsd,
                             &cbsd )
            ) {

            err = GetLastError();
        }

        if( err == ERROR_INSUFFICIENT_BUFFER )
        {
            TCP_FREE( psd );
            psd = (SECURITY_DESCRIPTOR *)TCP_ALLOC( cbsd );

            if( psd == NULL )
            {
                err = GetLastError();
                break;
            }
        }

    } while( err == ERROR_INSUFFICIENT_BUFFER );

    if( err != NO_ERROR ) {

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot get security for %s, error %lu\n",
                       pszFile,
                       err ));
        }

        goto Cleanup;
    }

    //
    //  Check access.
    //

    cbps = DEFAULT_PRIV_SET_SIZE;
    pps  = (PRIVILEGE_SET *)TCP_ALLOC( cbps );

    if( pps == NULL )
    {
        err = GetLastError();
        goto Cleanup;
    }

    do
    {
        if( AccessCheck( psd,
                         hUserToken,
                         MAXIMUM_ALLOWED,
                         &mapping,
                         pps,
                         &cbps,
                         pdwAccessGranted,
                         &fStatus ) )
        {
            err = fStatus ? NO_ERROR : GetLastError();

            if( err != NO_ERROR )
            {
                IF_DEBUG( DIR_LIST) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "AccessCheck() failure. Error=%d\n", err ));
                }
                break;
            }
        }
        else
        {
            err = GetLastError();

            if( err == ERROR_INSUFFICIENT_BUFFER )
            {
                TCP_FREE( pps );
                pps = (PRIVILEGE_SET *)TCP_ALLOC( cbps );

                if( pps == NULL )
                {
                    err = GetLastError();
                    break;
                }
            }
        }

    } while( err == ERROR_INSUFFICIENT_BUFFER );

    if( err != NO_ERROR )
    {
        IF_DEBUG(DIR_LIST) {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot get check access for %s, error %lu\n",
                       pszFile,
                       err ));
        }

        goto Cleanup;
    }

Cleanup:

    if( psd != NULL )
    {
        TCP_FREE( psd );
    }

    if( pps != NULL )
    {
        TCP_FREE( pps );
    }

    if( hFile != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hFile );
    }

    return err;

}   // ComputeFileInfo()





# define INVALID_FS_FLAGS        ((DWORD ) -1L)


DWORD
GetFsFlags( IN CHAR chDrive)
/*++

  This function uses GetVolumeInformation to retrieve the file system
    flags for the given drive.

  Arguments:
    chDrive   the drive letter to check for. Must be A-Z.

  Returns:
    DWORD containing the FS flags. 0 if unknown.

  History:
    MuraliK   25-Apr-1995
--*/
{
    INT      iDrive;
    DWORD    Flags = INVALID_FS_FLAGS;

    static DWORD  p_FsFlags[26] = {
        // One per DOS drive (A - Z).
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS, INVALID_FS_FLAGS,
        INVALID_FS_FLAGS, INVALID_FS_FLAGS
      };

    //
    //  Validate the parameter & map to uppercase.
    //

    chDrive = (INT)toupper( chDrive );
    DBG_ASSERT( ( chDrive >= 'A' ) && ( chDrive <= 'Z' ) );

    iDrive = (INT)( chDrive - 'A' );

    //
    //  If we've already touched this drive, use the
    //  cached value.
    //

    Flags = p_FsFlags[iDrive];

    if( Flags == INVALID_FS_FLAGS )
    {
        CHAR  szRoot[] = "d:\\";

        //
        //  Retrieve the flags.
        //

        szRoot[0] = chDrive;

        GetVolumeInformation( szRoot,       // lpRootPathName
                              NULL,         // lpVolumeNameBuffer
                              0,            // nVolumeNameSize
                              NULL,         // lpVolumeSerialNumber
                              NULL,         // lpMaximumComponentLength
                              &Flags,       // lpFileSystemFlags
                              NULL,         // lpFileSYstemNameBuffer,
                              0 );          // nFileSystemNameSize

        p_FsFlags[iDrive] = Flags;
    }

    return ( Flags == INVALID_FS_FLAGS ) ? 0 : Flags;

}   // GetFsFlags()

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\newls.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1995                **/
/**********************************************************************/
/*
   newls.cxx

    Implements a simulated "ls" command for the FTP Server service,
     with buffering and possibly caching of the results generated.

    Functions exported by this module:

        SimulateLs()
        SpecialLs()

    FILE HISTORY:
        MuraliK     19-April-1995  Created.
*/

# include "ftpdp.hxx"
# include "tsunami.hxx"
# include "lsaux.hxx"
# include <mbstring.h>


/**********************************************************************
 *  Private Globals
 **********************************************************************/

// Following message is required to send error msg when the file
//  or directory is absent.
extern CHAR * p_NoFileOrDirectory;              // This lives in engine.c.

static const char * PSZ_DEFAULT_SEARCH_PATH = "";

static const char * PSZ_WILD_CHARACTERS = "*?<>";  // include DOS wilds!


/**********************************************************************
 *  Prototypes of Functions
 **********************************************************************/

DWORD
FormatFileInfoLikeMsdos(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO  * pFormatInfo
    );

DWORD
FormatFileInfoLikeUnix(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO *  pFormatInfo
    );


APIERR
SimulateLsWorker(
    IN USER_DATA * pUserData,
    IN BOOL       fUseDataSocket,
    IN CHAR *     pszSearchPath,
    IN const LS_OPTIONS * pOptions,
    IN BOOL       fSendHeader = FALSE,
    IN BOOL       fSendBlank  = FALSE
    );


APIERR
SpecialLsWorker(
    IN USER_DATA *pUserData,
    IN BOOL       fUseDataSocket,
    CHAR *        pszSearchPath,
    BOOL          fShowDirectories,
    IN OUT LS_BUFFER * plsb
    );


//
//  The following is a table consisting of the sort methods used
//   for generating various dir listing. The table is indexed by LS_SORT.
//  This is used for finding the appropriate compare function for
//   any given sort method.
//  THE ORDER OF FUNCTIONS IN THIS ARRAY MUST MATCH THE ORDER IN LS_SORT!
//

static PFN_CMP_WIN32_FIND_DATA CompareRoutines[] = {

    CompareNamesInFileInfo,              // Normal sort order.
    CompareWriteTimesInFileInfo,
    CompareCreationTimesInFileInfo,
    CompareAccessTimesInFileInfo,

    CompareNamesRevInFileInfo,           // Reversed sort order.
    CompareWriteTimesRevInFileInfo,
    CompareCreationTimesRevInFileInfo,
    CompareAccessTimesRevInFileInfo
  };

// method,direction are used for indexing.
#define SORT_INDEX(method, dirn)   ((INT)(method) + \
                                    ((dirn) ? (INT)MaxLsSort : 0))


// constants and literals
#define ILLEGAL_FILE_CHARS (UCHAR*)"*?<>/\\\"|:"


/**********************************************************************
 *  Functions
 **********************************************************************/

static
BOOL
SeparateOutFilterSpec( IN OUT CHAR * szPath, IN BOOL fHasWildCards,
                       OUT LPCSTR * ppszFilterSpec)
/*++
  The path has the form  c:\ftppath\foo\bar\*.*
  Check to see if the path is already a directory.
  If so set filter as nothing.
  This function identifies the last "\" and terminates the
   path at that point. The remaining forms a filter (here: *.*)
--*/
{
    char * pszFilter;
    BOOL fDir = FALSE;

    IF_DEBUG( DIR_LIST) {
        DBGPRINTF((DBG_CONTEXT, "SeparateOutFilter( %s, %d)\n",
                   szPath, fHasWildCards));
    }

    DBG_ASSERT( ppszFilterSpec != NULL);
    *ppszFilterSpec = NULL;  // initialize.

    if ( !fHasWildCards) {

        // Identify if the path is a directory

        DWORD dwAttribs = GetFileAttributes( szPath);

        if ( dwAttribs == INVALID_FILE_ATTRIBUTES) {

            return ( FALSE);
        } else {

            fDir = ( IS_DIR(dwAttribs));
        }
    }

    if ( !fDir ) {
        pszFilter = (PCHAR)_mbsrchr( (PUCHAR)szPath, '\\');

        //This has to exist, since valid path was supplied.
        DBG_ASSERT( pszFilter != NULL);
        *pszFilter = '\0';  // terminate the old path.
        pszFilter++;        // skip past the terminating null character.

        *ppszFilterSpec = (*pszFilter == '\0') ? NULL : pszFilter;

        IF_DEBUG(DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, "Path = %s; Filter = %s\n",
                       szPath, *ppszFilterSpec));
        }
    }

    return (TRUE);

} // SeparateOutFilterSpec()




APIERR
SimulateLs(
    IN USER_DATA * pUserData,
    IN OUT CHAR *  pszArg,
    IN BOOL        fUseDataSocket,
    IN BOOL        fDefaultLong
    )
/*++
  This function simulates an LS command. This simulated ls command supports
    the following switches:

                    -C  = Multi column, sorted down.
                    -l  = Long format output.
                    -1  = One entry per line (default).
                    -F  = Directories have '/' appended.
                    -t  = Sort by time of last write.
                    -c  = Sort by time of creation.
                    -u  = Sort by time of last access.
                    -r  = Reverse sort direction.
                    -a  = Show all files (including .*).
                    -A  = Show all files (except . and ..).
                    -R  = Recursive listing.

  Arguments:
    pUserData  --  the user initiating the request.
    pszArg     --  contains the search path, preceded by switches.
      Note: The argument is destroyed during processing!!!!
    fUseDataSocket -- if TRUE use Data socket, else use control socket.
    fDefaultLong  -- should the default be long ? ( if TRUE)

  Returns:
    APIERR,   0 on success.
--*/
{
    APIERR      serr = 0;
    LS_OPTIONS   options;
    CHAR       * pszToken = pszArg;
    CHAR       * pszDelimiters = " \t";

    DBG_ASSERT( pUserData != NULL );

    //
    //  Setup default ls options.
    //

    options.OutputFormat  = (( fDefaultLong) ?
                             LsOutputLongFormat : LsOutputSingleColumn);
    options.SortMethod    = LsSortByName;
    options.fReverseSort  = FALSE;
    options.fDecorate     = FALSE;
    options.fShowAll      = FALSE;
    options.fShowDotDot   = FALSE;
    options.fRecursive    = FALSE;
    options.lsStyle       = ( TEST_UF( pUserData, MSDOS_DIR_OUTPUT)
                             ? LsStyleMsDos
                             : LsStyleUnix
                             );
    options.fFourDigitYear= TEST_UF( pUserData, 4_DIGIT_YEAR);

    //
    //  Process switches in the input, if any
    //

    // simplify things by skipping whitespace...

    if (pszArg && isspace(*pszArg)) {
        while (isspace(*pszArg))
            pszArg++;
    }

    // now we should be pointing to the options, or the filename

    if (pszArg && (*pszArg == '-')) {

        for( pszToken = strtok( pszArg, pszDelimiters ); // getfirst Tok.
            ( ( pszToken != NULL ) && ( *pszToken == '-' ) );
            pszToken  = strtok( NULL, pszDelimiters)     // get next token
            ) {

            DBG_ASSERT( *pszToken == '-' );

            // process all the switches in single token

            //  for( pszToken++; *pszToken;  pszToken++)  is written as follows
            while ( *++pszToken) {

                switch( *pszToken ) {

                  case 'C' :
                  case '1' :
                    options.OutputFormat = LsOutputSingleColumn;
                    break;

                  case 'l' :
                    options.OutputFormat = LsOutputLongFormat;
                    break;

                  case 'F' :
                    options.fDecorate = TRUE;
                    break;

                  case 'r' :
                    options.fReverseSort = TRUE;
                    break;

                  case 't' :
                    options.SortMethod = LsSortByWriteTime;
                    break;

                  case 'c' :
                    options.SortMethod = LsSortByCreationTime;
                    break;

                  case 'u' :
                    options.SortMethod = LsSortByAccessTime;
                    break;

                  case 'a' :
                    options.fShowAll    = TRUE;
                    options.fShowDotDot = TRUE;
                    break;

                  case 'A' :
                    options.fShowAll    = TRUE;
                    options.fShowDotDot = FALSE;
                    break;

                  case 'R' :
                    options.fRecursive = TRUE;
                    break;

                  default:
                    IF_DEBUG( COMMANDS ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "ls: skipping unsupported option '%c'\n",
                                   *pszToken ));
                    }
                    break;
                } // switch()
            } // process all switches in a token

        } // for
    }

    //
    //  If the user is requesting an MSDOS-style long-format listing,
    //  then enable display of "." and "..".  This will make the MSDOS-style
    //  long-format output look a little more like MSDOS.
    //

    options.fShowDotDot = ( options.fShowDotDot ||
                           ( options.lsStyle == LsStyleMsDos &&
                            ( options.OutputFormat == LsOutputLongFormat ))
                           );


    //
    // since LIST is sent out synchronously, bump up thread count
    //  before beginning to send out the response for LIST
    //
    // A better method:
    //   Make LIST generate response in a buffer and use async IO
    //   operations for sending response.
    //   TBD (To Be Done)
    //
    AtqSetInfo( AtqIncMaxPoolThreads, 0);


    //
    //  At this point, pszToken is either NULL or points
    //  to the first (of potentially many) LS search paths.
    //

    serr = SimulateLsWorker(pUserData, fUseDataSocket, pszToken, &options);

    //
    // bring down the thread count when response is completed
    // TBD: Use Async send reponse()
    //

    AtqSetInfo( AtqDecMaxPoolThreads, 0);


    return ( serr);
}   // SimulateLs()




APIERR
SpecialLs(
    USER_DATA * pUserData,
    CHAR      * pszArg,
    IN BOOL     fUseDataSocket
    )
/*++
  This produces a special form of the directory listing that is required
    when an NLST command is received with no switches. Most of the FTP clients
    require this special form in order to get the MGET and MDEL commands
    to work. This produces atmost one level of directory information.

  Arguments:
    pUserData  - the user initiating the request.
    pszArg     - pointer to null-terminated string containing the argument.
                  NULL=current directory for UserData.
    fUseDataSocket - if TRUE use Data Socket, else use the ContorlSocket.

  Returns:
    APIERR   - 0 if successful, !0 if not.
--*/
{
    APIERR     dwError = 0;
    LS_BUFFER   lsb;

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( ( pszArg == NULL ) || ( *pszArg != '-' ) ); // No options



    if ((dwError = lsb.AllocateBuffer( DEFAULT_LS_BUFFER_ALLOC_SIZE))
        != NO_ERROR) {

        IF_DEBUG(ERROR) {

            DBGPRINTF((DBG_CONTEXT, "Buffer allocation(%d bytes) failed.\n",
                       DEFAULT_LS_BUFFER_ALLOC_SIZE));
        }

        return (dwError);
    }



    //
    // since LIST is sent out synchronously, bump up thread count
    //  before beginning to send out the response for LIST
    //
    // A better method:
    //   Make LIST generate response in a buffer and use async IO
    //   operations for sending response.
    //   TBD (To Be Done)
    //
    AtqSetInfo( AtqIncMaxPoolThreads, 0);


    //
    //  Let the worker do the dirty work.
    //
    dwError = SpecialLsWorker(pUserData,
                              fUseDataSocket,
                              pszArg,         // search path (no switches)
                              TRUE,           // show directories
                              &lsb);

    if ( dwError == NO_ERROR) {

        // send all the remaining bytes in the buffer and then free memory.

        if ( lsb.QueryCB() != 0) {

            SOCKET sock = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
                           pUserData->QueryControlSocket());

            dwError = SockSend(pUserData, sock,
                               lsb.QueryBuffer(),
                               lsb.QueryCB()/sizeof(CHAR));
        }

        lsb.FreeBuffer();
    }


    //
    // bring down the thread count when response is completed
    // TBD: Use Async send reponse()
    //

    AtqSetInfo( AtqDecMaxPoolThreads, 0);

    return ( dwError);

}   // SpecialLs()





//
//  Private functions.
//
APIERR
SimulateLsWorker(
    USER_DATA  * pUserData,
    IN BOOL      fUseDataSocket,
    IN CHAR    * pszSearchPath,
    IN const LS_OPTIONS * pOptions,
    IN BOOL      fSendHeader,
    IN BOOL      fSendBlank
    )
/*++
   Worker function for SimulateLs function, forms directory listing
    for requested directory, formats the directory listing and
    sends it to the client.

   Arguments:
      pUserData - The user initiating the request.

      pszSearchPath - Search directory, NULL = current dir.

      pOptions - LS options set by command line switches.

      fSendHeader - if TRUE send header with directory name in it.
      fSendBlank  - also add a blank if there is one that has to be sent.

  Returns:
     APIERR - 0 if successful, !0 if not.

  HISTORY:
     MuraliK     24-Apr-1995 ReCreated.
--*/
{
    SOCKET        sock;
    BOOL          fLikeMsdos;
    CHAR          szSearch[MAX_PATH+1];
    CHAR          rgchLowFileName[MAX_PATH+1];  // used for lower casing filename
    BOOL          fMapToLowerCase = FALSE;
    DWORD         dwAccessMask = 0;
    BOOL          fImpersonated = FALSE;

    LS_BUFFER     lsb;
    LS_FORMAT_INFO lsfi;        // required only for long formatting.

    BOOL          fHasWildCards   = FALSE;
    DWORD         dwError         = NO_ERROR;
    APIERR        serr            = 0;
    TS_DIRECTORY_INFO   tsDirInfo( pUserData->QueryInstance()->GetTsvcCache());


    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT, " SimulateLsWorker( %08x, %d, %s)\n",
                   pUserData, fUseDataSocket, pszSearchPath));
    }

    DBG_ASSERT( pUserData != NULL && pOptions != NULL);

    //
    // Check for emptiness of path or wildcards in search path.
    // We are only concerned about wild cards in user input. The reason
    //   is all trailing '.' will be removed when we canonicalize
    //   the path ( which user may not appreciate).
    //

    if ( IS_EMPTY_PATH(pszSearchPath)) {

        // we know pszSearchPath will not change the buffer!
        pszSearchPath = (char *) PSZ_DEFAULT_SEARCH_PATH;

    } else if (strpbrk( pszSearchPath, PSZ_WILD_CHARACTERS ) != NULL) {

        //
        //  Search path contains wildcards.
        //

        fHasWildCards = TRUE;
    }

    //
    //  Canonicalize the search path.
    //

    DWORD cbSize = sizeof(szSearch) - 1; // save space for '.' we add later
    dwError = pUserData->VirtualCanonicalize(szSearch, &cbSize,
                                             pszSearchPath,
                                             AccessTypeRead,
                                             &dwAccessMask);

    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);

    if( dwError == NO_ERROR ) {

        FTP_LS_FILTER_INFO  fls;  // required for generating directory listing
        PFN_CMP_WIN32_FIND_DATA  pfnCompare;

        //
        //  VirtualCanonicalize() when sanitizing the path removes
        //     trailing dots from the path. Replace them here
        //
        DBG_ASSERT( !fHasWildCards || strlen(pszSearchPath) >= 1);

        if( fHasWildCards && (pszSearchPath[strlen(pszSearchPath)-1] == '.')) {

            DBG_ASSERT( strlen(szSearch) < MAX_PATH);
            strcat( szSearch, "." );
        }

        //
        //  Build the directory list.
        //

        pfnCompare = CompareRoutines[SORT_INDEX(pOptions->SortMethod,
                                                pOptions->fReverseSort)
                                     ];

        // Separate the filter out ( that is the last component)

        if (pUserData->ImpersonateUser()) {

            if (SeparateOutFilterSpec( szSearch,
                                       fHasWildCards,
                                       &fls.pszExpression) ) {

                fls.fFilterHidden = !pOptions->fShowAll;
                fls.fFilterSystem = !pOptions->fShowAll;
                fls.fFilterDotDot = !pOptions->fShowDotDot;

                fls.fRegExpression = ( fls.pszExpression != NULL && fHasWildCards);
                fls.fIgnoreCase    = pUserData->QueryInstance()->QueryLowercaseFiles();

                dwError = GetDirectoryInfo(pUserData,
                                           &tsDirInfo,
                                           szSearch,
                                           &fls,
                                           pfnCompare);
            } else {

                dwError = GetLastError();
            }

            pUserData->RevertToSelf();

        } else {

            dwError = GetLastError();
        }
    }

    //
    //  If there were any errors, tell them the bad news now.
    //

    if( dwError != NO_ERROR ) {

        return  (dwError);
    }

    sock  = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
             pUserData->QueryControlSocket());

    DBG_ASSERT( tsDirInfo.IsValid());

    int cDirEntries = tsDirInfo.QueryFilesCount();

    if ( cDirEntries > 0) {

        //
        // put out the header block before starting dir listing
        //

        if( fSendHeader ) {

            serr = SockPrintf2( pUserData, sock,
                               "%s%s:",
                               (fSendBlank)? "\r\n" : "",  // send \r\n
                               pszSearchPath);

            if ( serr != 0) {

                return (serr);
            }
        }
    }

    fLikeMsdos  = (pOptions->lsStyle == LsStyleMsDos);

    lsfi.fFourDigitYear = pOptions->fFourDigitYear;

    if( !fLikeMsdos ) {

        //
        //  Initialize the information in lsfi if we are doing
        //   long format output.
        //

        if ( pOptions->OutputFormat == LsOutputLongFormat) {

            SYSTEMTIME    timeNow;
            BOOL fUserRead, fUserWrite;

            //
            //  Obtain the current time.
            //  The Unix-like output requires current year
            //

            GetLocalTime( &timeNow );

            lsfi.wCurrentYear = timeNow.wYear;
            lsfi.hUserToken   = TsTokenToImpHandle(pUserData->QueryUserToken());

            //
            // Since szSearch contains the complete path, we call
            //  PathAccessCheck directly without resolving
            //    from absolute to virtual
            //

            fUserRead  = TEST_UF( pUserData, READ_ACCESS);
            fUserWrite = TEST_UF( pUserData, WRITE_ACCESS);

            lsfi.fVolumeReadable =
              PathAccessCheck(AccessTypeRead,
                              dwAccessMask,
                              fUserRead,
                              fUserWrite);

            lsfi.fVolumeWritable =
              PathAccessCheck(AccessTypeWrite,
                              dwAccessMask,
                              fUserRead,
                              fUserWrite);


            lsfi.pszPathPart = szSearch;
            lsfi.pszFileName = NULL;
            lsfi.pszDecorate = NULL;
        } // if ( long format output)

        //
        // We need to be impersonated only for UNIX-style listing.
        //  For UNIX style listing, we make some NTsecurity queries
        //   and they work only under the context of an impersonation.
        //

        if ( !(fImpersonated = pUserData->ImpersonateUser())) {

            dwError = GetLastError();
        }
    }

    //
    //  Loop for each directory entry
    //

    if (dwError != NO_ERROR ||
        (dwError = lsb.AllocateBuffer( DEFAULT_LS_BUFFER_ALLOC_SIZE))
        != NO_ERROR) {

        IF_DEBUG(ERROR) {

            DBGPRINTF((DBG_CONTEXT,
                       "Impersonation or Buffer allocation(%d bytes)",
                       " failed.\n",
                       DEFAULT_LS_BUFFER_ALLOC_SIZE));
        }

        if ( fImpersonated) {

            pUserData->RevertToSelf();
        }

        return (dwError);
    }

    //
    //  Only map to lower case if not a remote drive AND the lower-case file
    //  names flag is set AND this is not a case perserving file system.
    //

    if (*szSearch != '\\') {
        fMapToLowerCase = pUserData->QueryInstance()->QueryLowercaseFiles();
    }

    for( int idx = 0; serr == 0 && idx < cDirEntries; idx++) {

        const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
        DBG_ASSERT( pfdInfo != NULL);
        const CHAR * pszFileName = pfdInfo->cFileName;
        DWORD dwAttribs = pfdInfo->dwFileAttributes;

        //
        //  Dump it.
        //

        // We may need to convert all filenames to lower case if so desired!!
        // Also, if the filename was converted from UNICODE and ended up having
        // characters such as '/' or '\' that can be harmful on the client, sanitize.

        BOOL fHasSlash = !!_mbspbrk((UCHAR*)pszFileName, ILLEGAL_FILE_CHARS);

        if( fMapToLowerCase || fHasSlash) {

            //
            // copy file name to local scratch and change the ptr pszFileName
            // because we cannot destroy pfdInfo->cFileName
            //
            P_strncpy( rgchLowFileName, pszFileName, sizeof(rgchLowFileName));
            pszFileName = rgchLowFileName;

            // lowercase if needed
            if( fMapToLowerCase ) {
                CharLower( rgchLowFileName);
            }

            // sanitize if need to
            if( fHasSlash ) {
                for( UCHAR *pch = (UCHAR*)rgchLowFileName;
                     (pch = _mbspbrk(pch, ILLEGAL_FILE_CHARS)) != NULL;
                     *pch++ = '^')
                     ;
            }
        }

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF((DBG_CONTEXT, "Dir list for %s\n",
                       pszFileName));
        }

        //
        // Send the partial data obtained so far.
        //  Use buffering to minimize number of sends occuring
        //

        if ( dwError == NO_ERROR) {

            if ( lsb.QueryRemainingCB() < MIN_LS_BUFFER_SIZE) {

                // send the bytes available in buffer and reset the buffer
                serr = SockSend(pUserData, sock,
                                lsb.QueryBuffer(), lsb.QueryCB()/sizeof(CHAR));
                lsb.ResetAppendPtr();
            }

        } else {

            serr = dwError;
        }

        //
        //  Check for socket errors on send or pending OOB data.
        //

        if( TEST_UF( pUserData, OOB_DATA ) || ( serr != 0 ) )
        {
            break;
        }


        CHAR * pszDecorate = ( (pOptions->fDecorate && IS_DIR(dwAttribs) )
                            ? "/" : "");

        if( pOptions->OutputFormat == LsOutputLongFormat )
        {
            FILETIME ftLocal;

            //
            //  Long format output.  Just send the file/dir info.
            //

            //
            //  Map the file's last write time to (local) system time.
            //
            if ( !FileTimeToLocalFileTime(
                     PickFileTime( pfdInfo, pOptions),
                     &ftLocal) ||
                 ! FileTimeToSystemTime(
                                       &ftLocal,
                                       &lsfi.stFile)
                ) {

                dwError = GetLastError();

                IF_DEBUG( ERROR) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "Error in converting largeintger time %lu\n",
                               dwError));
                }
            } else {

                lsfi.pszDecorate = pszDecorate;
                lsfi.pszFileName = pszFileName;

                if( fLikeMsdos ) {

                    dwError = FormatFileInfoLikeMsdos(&lsb,
                                                      pfdInfo,
                                                      &lsfi);

                    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);
                } else {

                    dwError = FormatFileInfoLikeUnix(&lsb,
                                                     pfdInfo,
                                                     &lsfi);

                    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);
                }
            }

        } else {

            //
            //  Short format output.
            //

            INT cchSize = _snprintf(lsb.QueryAppendPtr(), lsb.QueryRemainingCB(),
                                      "%s%s\r\n", pszFileName, pszDecorate);

            DBG_ASSERT( cchSize > 0 );

            if ((cchSize < 0) || (cchSize >= (INT)lsb.QueryRemainingCB()) ) {
                dwError = ERROR_INSUFFICIENT_BUFFER;
            } else {
                lsb.IncrementCB( cchSize * sizeof(CHAR));
            }
        }

    } // for()

    //
    // Get out of being impersonated.
    //
    if ( fImpersonated) {

        pUserData->RevertToSelf();
    }

    if ( dwError == NO_ERROR) {

        // send all the remaining bytes in the buffer and then free memory.

        if ( lsb.QueryCB() != 0) {

            serr = SockSend(pUserData, sock,
                            lsb.QueryBuffer(), lsb.QueryCB()/sizeof(CHAR));
        }

        lsb.FreeBuffer();
    } else {

        return ( dwError);  // an error has occured. stop processing
    }


    if( serr == 0 && !TEST_UF( pUserData, OOB_DATA) && pOptions->fRecursive )
    {
        //
        //  The user want's a recursive directory search...
        //

        CHAR   szOriginal[ MAX_PATH*2];
        CHAR * pszOriginalFilePart;


        // Obtain a copy of the path in the szOriginal so that we
        //  can change it while recursively calling ourselves.

        if ( pszSearchPath == PSZ_DEFAULT_SEARCH_PATH) {

            // means that we had all files/dir of current directory.

            strcpy( szOriginal, fLikeMsdos ? ".\\" : "./" );

        } else {

            DBG_ASSERT( strlen(pszSearchPath) < MAX_PATH);
            P_strncpy( szOriginal, pszSearchPath, MAX_PATH );

            // strip off the wild cards if any present
            if( fHasWildCards )
              {
                  CHAR * pszTmp;

                  pszTmp = (PCHAR)_mbsrchr( (PUCHAR)szOriginal, '\\');

                  pszTmp = pszTmp ? pszTmp : strrchr( szOriginal, '/' );
                  pszTmp = pszTmp ? pszTmp : strrchr( szOriginal, ':' );

                  pszTmp = ( pszTmp) ? pszTmp+1 : szOriginal;

                  *pszTmp = '\0';
              } else {
                  CHAR ch;
                  int cb = strlen( szOriginal);

                  DBG_ASSERT( cb > 0);
                  ch = *CharPrev( szOriginal, szOriginal + cb );
                  if( !IS_PATH_SEP( ch ) ) {

                      // to add "/"
                      DBG_ASSERT( strlen( szOriginal) + 2 < MAX_PATH);
                      strcat( szOriginal, fLikeMsdos ? "\\" : "/" );
                  }
              }
        }

        DWORD szOriginalLen = strlen(szOriginal);
        DWORD MaxFilePartLen = sizeof(szOriginal) - szOriginalLen;
        pszOriginalFilePart = szOriginal + szOriginalLen;

        DBG_ASSERT( tsDirInfo.IsValid());
        DBG_ASSERT( cDirEntries == tsDirInfo.QueryFilesCount());

        for( int idx = 0; serr == 0 && idx < cDirEntries; idx++) {

            const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
            DBG_ASSERT( pfdInfo != NULL);
            const char * pszFileName = pfdInfo->cFileName;
            DWORD dwAttribs = pfdInfo->dwFileAttributes;

            //
            //  Filter out non-directories.
            //

            if( !IS_DIR( dwAttribs) ) {

                continue;
            }

            //
            // Also filter out directories with names containing illegal characters
            //

            if( _mbspbrk((UCHAR*)pszFileName, ILLEGAL_FILE_CHARS) ) {

                continue;
            }

            //
            //  Dump it.
            //

            DBG_ASSERT( strlen( pszOriginalFilePart) + strlen(pszFileName)
                       < MAX_PATH + 2);
            P_strncpy( pszOriginalFilePart, pszFileName, MaxFilePartLen);

            serr = SimulateLsWorker(pUserData,
                                    fUseDataSocket,
                                    szOriginal,
                                    pOptions,
                                    TRUE, TRUE);

            //
            //  Check for socket errors on send or pending OOB data.
            //

            if( TEST_UF( pUserData, OOB_DATA ) || ( serr != 0 ) )
              {
                  break;
              }

        } // for( directory looping)

    } // if ( fRecursive)


    // At the end of directory listing. Return back.

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "SimulateLsWorker() for User %08x, Dir %s returns %d\n",
                   pUserData, pszSearchPath, serr));
    }


    return serr;
}   // SimulateLsWorker()




APIERR
SpecialLsWorker(
    USER_DATA * pUserData,
    IN BOOL     fUseDataSocket,
    CHAR      * pszSearchPath,
    BOOL        fShowDirectories,
    IN OUT LS_BUFFER * plsb
    )
/*++
  This is the worker function for Special Ls function. It is similar to
   the the SimulateLsWorker, only in that it shows directory if the
   fShowDirectories flag is set.

  The reason for this comes from a special FTP command which inquires about
    all the files in the first level and second level of current directory,
    which is not a recursive listing at all. This function when it recursively
    calls itself, always sets the fShowDirectories as FALSE.

  Arguments:
    pUserData     pointer to user data object that initiated the request.
    fUseDataSocket  if TRUE use DataSocket of UserData else
                       use the control socket of UserData.
    pszSearchPath  pointer to null-terminated string for requested directory.
                       NULL means use current directory.
    fShowDirectories  only show directories if TRUE.
    plsb          pointer to buffer to accumulate the data generated and send
                     it out in a single bulk.

  Returns:
    APIERR   0  if successful.

  History:
     KeithMo     17-Mar-1993 Created.
     MuraliK     26-Apr-1995 ReCreated to use new way of generation.
--*/
{
    CHAR        chSeparator;
    CHAR  *     pszRecurse;
    SOCKET      sock;
    BOOL        fHasWildCards = FALSE;
    DWORD       dwError       = NO_ERROR;
    TS_DIRECTORY_INFO  tsDirInfo( pUserData->QueryInstance()->GetTsvcCache());
    CHAR        szSearch[MAX_PATH+1];
    CHAR        szRecurse[MAX_PATH+1];
    BOOL        fMapToLowerCase = FALSE;
    CHAR        rgchLowFileName[MAX_PATH+1];  // used for lower casing filename
    BOOL        fHadOneComponent = FALSE;

    DBG_ASSERT( pUserData != NULL);

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "Entering SpecialLsWorker( %08x, %s)\n",
                   pUserData, pszSearchPath));
    }


    chSeparator = TEST_UF( pUserData, MSDOS_DIR_OUTPUT ) ? '\\' : '/';

    //
    //  Check for wildcards in search path.
    //

    if( ( pszSearchPath != NULL ) && ( *pszSearchPath != '\0' ) )
    {
        //
        //  Setup for recursive directory search.  We'll set things up
        //  so we can strcpy a new directory to pszRecurse, then
        //  recursively call ourselves with szRecurse as the search
        //  path.
        //
        //  We also use szRecurse as a "prefix" to display before each
        //  file/directory.  The FTP Client software needs this for the
        //  MDEL & MGET commands.
        //
        if ( strlen(pszSearchPath) > sizeof(szRecurse) - 1 )
        {
            return ERROR_BUFFER_OVERFLOW;
        }

        strcpy( szRecurse, pszSearchPath);

        // get slash.
        pszRecurse = (PCHAR)_mbsrchr( (PUCHAR)szRecurse, '\\');
        pszRecurse = pszRecurse ? pszRecurse : strrchr( szRecurse, '/');
        fHadOneComponent = (pszRecurse == NULL);

        if( strpbrk( szRecurse, PSZ_WILD_CHARACTERS) != NULL )
        {
            //
            //  Search path contains wildcards.
            //

            fHasWildCards = TRUE;

            // we do not care about components when wild card is present
            fHadOneComponent = FALSE;

            //
            //  Strip the wildcard pattern from the search path.
            // look for both kind of slashes ( since precanonicalized)
            //

            //
            // If we found right-most dir component, skip path separator
            //  else set it to start of search path.
            //
            pszRecurse = pszRecurse ? pszRecurse + 1 : szRecurse;
        } else {

            //
            //  No wildcards, so the argument must be a path.
            //  Ensure it is terminated with a path separator.
            //

            pszRecurse = CharPrev( szRecurse, szRecurse + strlen(szRecurse) );

            if( !IS_PATH_SEP( *pszRecurse ) )
            {
                *++pszRecurse = chSeparator;
            }

            pszRecurse++;  // skip the path separator
        }
    } else {

        //
        //  No arguments.
        //

        pszRecurse = szRecurse;


        //
        //  Munge the arguments around a bit.  NULL = *.* in current
        //  directory.  If the user specified a directory (like d:\foo)
        //  then append *.*.
        //

        pszSearchPath = (char *) PSZ_DEFAULT_SEARCH_PATH;
    }

    *pszRecurse = '\0';

    //
    //  Canonicalize the search path.
    //
    DWORD cbSize = sizeof(szSearch) - 1; // save space for '.' we may need to add
    dwError = pUserData->VirtualCanonicalize(szSearch, &cbSize,
                                             pszSearchPath,
                                             AccessTypeRead);

    DBG_ASSERT( dwError != ERROR_INSUFFICIENT_BUFFER);

    if( dwError == NO_ERROR ) {

        FTP_LS_FILTER_INFO  fls;  // required for generating directory listing

        //
        //  VirtualCanonicalize() when sanitizing the path removes
        //     trailing dots from the path. Replace them here
        //

        if( fHasWildCards && (pszSearchPath[strlen(pszSearchPath)-1] == '.')) {

            strcat( szSearch, "." );
        }

        //
        //  Build the directory list.
        //

        if (pUserData->ImpersonateUser()) {

            if (SeparateOutFilterSpec( szSearch,
                                       fHasWildCards,
                                       &fls.pszExpression) ) {

                fls.fFilterHidden = TRUE;
                fls.fFilterSystem = TRUE;
                fls.fFilterDotDot = TRUE;

                fls.fRegExpression = ( fls.pszExpression != NULL && fHasWildCards);
                fls.fIgnoreCase    = pUserData->QueryInstance()->QueryLowercaseFiles();


                dwError = GetDirectoryInfo(pUserData,
                                           &tsDirInfo,
                                           szSearch,
                                           &fls,
                                           NULL);  // unsorted list
            } else {

                dwError = GetLastError();
            }

            pUserData->RevertToSelf();

        } else {

            dwError = GetLastError();
        }
    }

    //
    //  If there were any errors, tell them the bad news now.
    //

    if( dwError != NO_ERROR ) {

        return  ( dwError);
    }

    if ( fHadOneComponent) {

        // HARD CODE! Spend some time and understand this....

        //
        // Adjust the szRecurse buffer to contain appropriate path
        //  such that in presence of one component we generate proper
        //  result.
        //

        // the given path is either invalid or non-directory
        //  so reset the string stored in szRecurse.
        szRecurse[0] = '\0';
        pszRecurse = szRecurse;
    }


    //
    //  Only map to lower case if not a remote drive AND the lower-case file
    //  names flag is set AND this is not a case perserving file system.
    //

    if (*szSearch != '\\') {
        fMapToLowerCase = pUserData->QueryInstance()->QueryLowercaseFiles();
    }

    //
    //  Loop until we're out of files to find.
    //

    sock = ((fUseDataSocket) ? pUserData->QueryDataSocket() :
            pUserData->QueryControlSocket());

    int cDirEntries = tsDirInfo.QueryFilesCount();

    for( int idx = 0; dwError == NO_ERROR && idx < cDirEntries; idx++) {

        const WIN32_FIND_DATA * pfdInfo = tsDirInfo[idx];
        DBG_ASSERT( pfdInfo != NULL);
        const CHAR * pszFileName = pfdInfo->cFileName;
        DWORD dwAttribs = pfdInfo->dwFileAttributes;

        if ( !fShowDirectories && IS_DIR( dwAttribs)) {

            continue;
        }

        //
        //  Dump it.
        //

        // We may need to convert all filenames to lower case if so desired!!
        // Also, if the filename was converted from UNICODE and ended up having
        // characters such as '/' or '\' that can be harmful on the client, sanitize.

        BOOL fHasSlash = !!_mbspbrk((UCHAR*)pszFileName, ILLEGAL_FILE_CHARS);

        if( fMapToLowerCase || fHasSlash) {

            //
            // copy file name to local scratch and change the ptr pszFileName
            // because we cannot destroy pfdInfo->cFileName
            //
            P_strncpy( rgchLowFileName, pszFileName, sizeof(rgchLowFileName));
            pszFileName = rgchLowFileName;

            // lowercase if needed
            if( fMapToLowerCase ) {
                CharLower( rgchLowFileName);
            }

            // sanitize if need to
            if( fHasSlash ) {
                for( UCHAR *pch = (UCHAR*)rgchLowFileName;
                     (pch = _mbspbrk(pch, ILLEGAL_FILE_CHARS)) != NULL;
                     *pch++ = '^')
                     ;
            }
        }

        //
        // Send the partial data obtained so far.
        //  Use buffering to minimize number of sends occuring
        //

        if ( dwError == NO_ERROR) {

            if ( plsb->QueryRemainingCB() < MIN_LS_BUFFER_SIZE) {

                // send the bytes available in buffer and reset the buffer
                dwError = SockSend(pUserData, sock,
                                   plsb->QueryBuffer(),
                                   plsb->QueryCB()/sizeof(CHAR));
                plsb->ResetAppendPtr();
            }

        }

        //
        //  Test for aborted directory listing or socket error.
        //

        if( TEST_UF( pUserData, OOB_DATA ) || ( dwError != NO_ERROR ) )
        {
            break;
        }

        //
        //  If no wildcards were given, then just dump out the
        //  file/directory.  If wildcards were given, AND this
        //  is a directory, then recurse (one level only) into
        //  the directory.  The mere fact that we don't append
        //  any wildcards to the recursed search path will
        //  prevent a full depth-first recursion of the file system.
        //  Do not recurse if directory name contains illegal characters (converted from Unicode)
        //

        if( fHasWildCards && IS_DIR(dwAttribs) && !_mbspbrk((UCHAR*)pszFileName, ILLEGAL_FILE_CHARS) ) {

            DBG_ASSERT(strcmp( pszFileName, "." ) != 0);
            DBG_ASSERT(strcmp( pszFileName, "..") != 0);

            DBG_ASSERT(strlen(szRecurse)+strlen( pszFileName) < MAX_PATH);
            // BUGBUG: need to understand this better and ensure this does not overflow
            strcpy( pszRecurse, pszFileName );
            strcat( pszRecurse, "/"); // indicating this is a directory

            dwError = SpecialLsWorker(pUserData,
                                      fUseDataSocket,
                                      szRecurse,
                                      FALSE,
                                      plsb);
        } else {

            INT cchSize;

            *pszRecurse = '\0';  // as a side effect this terminates szRecurse.

            //
            //  Short format output.
            //

            cchSize = _snprintf(plsb->QueryAppendPtr(), plsb->QueryRemainingCB(),
                                "%s%s\r\n",
                                szRecurse,
                                pszFileName);

            DBG_ASSERT( cchSize > 0 );

            if ( (cchSize < 0) || (cchSize >= (INT)plsb->QueryRemainingCB()) ) {
                dwError = ERROR_INSUFFICIENT_BUFFER;
            } else {
                plsb->IncrementCB( cchSize*sizeof(CHAR));
            }

        }

    } // for


    IF_DEBUG( DIR_LIST) {

        DBGPRINTF((DBG_CONTEXT,
                   "Leaving SpecialLsWorker() with Error = %d\n",
                   dwError));
    }

    return (dwError);

}   // SpecialLsWorker()




/**************************************************
 *   Formatting functions.
 **************************************************/



DWORD
FormatFileInfoLikeMsdos(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO  * pFormatInfo
    )
/*++

  Forms an MSDOS like directory entry for the given dir info object.

  Arguments:

    plsb    pointer to buffer into which the dir line is generated.

    pfdInfo    pointer to dir information element.
    pFormatInfo pointer to information required for formatting.
     ( use the file name in pFormatInfo, becauze it may have been
       made into lower case if necessary)

  Returns:
    Win32 error code and NO_ERROR on success.

  History:
    MuraliK      25-Apr-1995
--*/
{
    DWORD        dwError = NO_ERROR;
    CHAR         szSizeOrDir[32];
    DWORD        cbReqd;

    DBG_ASSERT(plsb != NULL && pfdInfo != NULL   && pFormatInfo != NULL);

    if ( IS_DIR( pfdInfo->dwFileAttributes)) {

        strcpy( szSizeOrDir, "<DIR>         " );
    } else {

        LARGE_INTEGER li;
        li.HighPart = pfdInfo->nFileSizeHigh;
        li.LowPart  = pfdInfo->nFileSizeLow;

        IsLargeIntegerToDecimalChar( &li, szSizeOrDir);
    }

    DBG_ASSERT( strlen(szSizeOrDir) <= 20);

    cbReqd = ( 10       // size for the date field
              + 10      // size for time field
              + 20      // space for size/dir
              + strlen( pFormatInfo->pszFileName)
              + 8       // addl space + decoration ...
              ) * sizeof(CHAR);

    DBG_ASSERT( cbReqd <= MIN_LS_BUFFER_SIZE);

    if ( cbReqd < plsb->QueryRemainingCB()) {

        register const SYSTEMTIME * pst = &pFormatInfo->stFile;
        WORD   wHour;
        char * pszAmPm;
        DWORD  cchUsed;

        wHour   = pst->wHour;
        pszAmPm = ( wHour < 12 ) ? "AM" : "PM";

        if ( wHour == 0 ) {            wHour = 12;  }
        else if ( wHour > 12) {        wHour -= 12; }

        if (pFormatInfo->fFourDigitYear) {
            cchUsed = wsprintfA(plsb->QueryAppendPtr(),
                           "%02u-%02u-%04u  %02u:%02u%s %20s %s%s\r\n",
                           pst->wMonth,
                           pst->wDay,
                           pst->wYear,
                           wHour,
                           pst->wMinute,
                           pszAmPm,
                           szSizeOrDir,
                           pFormatInfo->pszFileName,
                           pFormatInfo->pszDecorate);
        }
        else {
            cchUsed = wsprintfA(plsb->QueryAppendPtr(),
                           "%02u-%02u-%02u  %02u:%02u%s %20s %s%s\r\n",
                           pst->wMonth,
                           pst->wDay,
                           pst->wYear%100,  //instead of wYear - 1900
                           wHour,
                           pst->wMinute,
                           pszAmPm,
                           szSizeOrDir,
                           pFormatInfo->pszFileName,
                           pFormatInfo->pszDecorate);
        }

        DBG_ASSERT( cchUsed * sizeof(CHAR) <= cbReqd);
        plsb->IncrementCB(cchUsed * sizeof(CHAR));

    } else {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    }


    return ( dwError);

}   // FormatFileInfoLikeMsdos()




DWORD
FormatFileInfoLikeUnix(
    IN OUT LS_BUFFER * plsb,
    IN const WIN32_FIND_DATA * pfdInfo,
    IN const LS_FORMAT_INFO * pFormatInfo
    )
/*++
  This function formats file information for a UNIX stle client.

  Arguments:

    plsb        pointer to buffer into which the dir line is generated.
    pfdInfo     pointer to dir information element.
    pFormatInfo pointer to information required for long formatting.

  Returns:
    Win32 error code and NO_ERROR on success.

  History:
    MuraliK      25-Apr-1995
--*/
{
    DWORD         dwError = NO_ERROR;
    CHAR        * pszFileOwner;
    CHAR        * pszFileGroup;
    const SYSTEMTIME * pst;
    DWORD         dwMode;
    DWORD         cLinks;
    LARGE_INTEGER li;
    CHAR          attrib[4];
    CHAR          szTimeOrYear[12];
    CHAR          szSize[32];

    DWORD         cbReqd;

    static CHAR * apszMonths[] = { "   ", "Jan", "Feb", "Mar", "Apr",
                                   "May", "Jun", "Jul", "Aug", "Sep",
                                   "Oct", "Nov", "Dec" };

    DBG_ASSERT( plsb != NULL);
    DBG_ASSERT( pFormatInfo != NULL );
    DBG_ASSERT( pFormatInfo->hUserToken != NULL );
    DBG_ASSERT( pFormatInfo->pszPathPart != NULL );
    DBG_ASSERT( pfdInfo != NULL );


    //
    //  Build the attribute triple.  Note that we only build one,
    //  and replicate it three times for the owner/group/other fields.
    //

    dwMode = ComputeModeBits( pFormatInfo->hUserToken,
                              pFormatInfo->pszPathPart,
                              pfdInfo,
                              &cLinks,
                              pFormatInfo->fVolumeReadable,
                              pFormatInfo->fVolumeWritable );

    attrib[0] = ( dwMode & FILE_MODE_R ) ? 'r' : '-';
    attrib[1] = ( dwMode & FILE_MODE_W ) ? 'w' : '-';
    attrib[2] = ( dwMode & FILE_MODE_X ) ? 'x' : '-';
    attrib[3] = '\0';

    pst = &pFormatInfo->stFile;

    // NYI: can we make the following a single wsprintf call ??
    if( pst->wYear == pFormatInfo->wCurrentYear ) {

        //
        //  The file's year matches the current year, so
        //  display the hour & minute of the last write.
        //

        wsprintfA( szTimeOrYear, "%2u:%02u", pst->wHour, pst->wMinute );
    } else {

        //
        //  The file's year does not match the current
        //  year, so display the year of the last write.
        //

        wsprintfA( szTimeOrYear, "%4u", pst->wYear );
    }

    //
    //  CODEWORK:  How expensive would it be do
    //  get the proper owner & group names?
    //

    pszFileOwner = "owner";
    pszFileGroup = "group";

    //
    //  Get the size in a displayable form.
    //

    li.HighPart = pfdInfo->nFileSizeHigh;
    li.LowPart  = pfdInfo->nFileSizeLow;

    IsLargeIntegerToDecimalChar( &li, szSize);

    //
    //  Dump it.
    //
    DBG_ASSERT( strlen(szSize) <= 12);
    cbReqd = ( 3*strlen(attrib) + strlen( pszFileOwner)
              + strlen( pszFileGroup) + 12 + 20 // date
              + strlen( pFormatInfo->pszFileName)
              + strlen( pFormatInfo->pszDecorate) + 20 // 20 for spaces etc.
              ) * sizeof(CHAR);
    DBG_ASSERT( cbReqd < MIN_LS_BUFFER_SIZE);

    if ( cbReqd < plsb->QueryRemainingCB()) {

        DWORD cchUsed = wsprintfA( plsb->QueryAppendPtr(),
                          "%c%s%s%s %3lu %-8s %-8s %12s %s %2u %5s %s%s\r\n",
                          (IS_DIR(pfdInfo->dwFileAttributes) ? 'd' : '-'),
                          attrib,
                          attrib,
                          attrib,
                          cLinks,
                          pszFileOwner,
                          pszFileGroup,
                          szSize,
                          apszMonths[pst->wMonth],
                          pst->wDay,
                          szTimeOrYear,
                          pFormatInfo->pszFileName,
                          pFormatInfo->pszDecorate);

        DBG_ASSERT( cchUsed * sizeof(CHAR) <= cbReqd);
        plsb->IncrementCB( cchUsed*sizeof(CHAR));

    } else {

        dwError = ERROR_INSUFFICIENT_BUFFER;
    }

    return ( dwError);

}   // FormatFileInfoLikeUnix()

/************************ End of File ************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\sockutil.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    sockutil.cxx

    This module contains utility routines for managing & manipulating
    sockets.

    Functions exported by this module:

        CreateDataSocket
        CreateFtpdSocket
        CloseSocket
        ResetSocket
        AcceptSocket
        SockSend
        SockPrintf2
        ReplyToUser()
        SockReadLine
        SockMultilineMessage2



    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     April-1995 Misc modifications (removed usage of various
                                  socket functions/modified them)

*/


#include "ftpdp.hxx"


//
//  Private constants.
//

#define DEFAULT_BUFFER_SIZE     4096    // bytes

//
//  Private globals.
//


//
//  Private prototypes.
//

SOCKERR
vSockPrintf(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    va_list     args
    );

SOCKERR
vSockReply(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    UINT        ReplyCode,
    CHAR        chSeparator,
    LPCSTR      pszFormat,
    va_list     args
    );

BOOL
vTelnetEscapeIAC(
    PCHAR       pszBuffer,
    PINT        pcchBufChars,
    INT         ccbMaxLen
    );

//
//  Public functions.
//


/*******************************************************************

    NAME:       CreateDataSocket

    SYNOPSIS:   Creates a data socket for the specified address & port.

    ENTRY:      psock - Will receive the new socket ID if successful.

                addrLocal - The local Internet address for the socket
                    in network byte order.

                portLocal - The local port for the socket in network
                    byte order.

                addrRemote - The remote Internet address for the socket
                    in network byte order.

                portRemote - The remote port for the socket in network
                    byte order.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     10-Mar-1993 Created.
        KeithMo     07-Sep-1993 Enable SO_REUSEADDR.

********************************************************************/
SOCKERR
CreateDataSocket(
    SOCKET * psock,
    ULONG    addrLocal,
    PORT     portLocal,
    ULONG    addrRemote,
    PORT     portRemote
    )
{
    SOCKET      sNew = INVALID_SOCKET;
    SOCKERR     serr = 0;
    SOCKADDR_IN sockAddr;

    //
    //  Just to be paranoid...
    //

    DBG_ASSERT( psock != NULL );
    *psock = INVALID_SOCKET;

    //
    //  Create the socket.
    //

    sNew = WSASocketW(AF_INET,
                      SOCK_STREAM,
                      IPPROTO_TCP,
                      NULL,
                      0,
                      WSA_FLAG_OVERLAPPED);

    serr = ( sNew == INVALID_SOCKET ) ? WSAGetLastError() : 0;

    if( serr == 0 )
    {
        BOOL fReuseAddr = TRUE;

        //
        //  Since we always bind to the same local port,
        //  allow the reuse of address/port pairs.
        //

        if( setsockopt( sNew,
                        SOL_SOCKET,
                        SO_REUSEADDR,
                        (CHAR *)&fReuseAddr,
                        sizeof(fReuseAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Bind the local internet address & port to the socket.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrLocal;
        sockAddr.sin_port        = portLocal;

        if( bind( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Connect to the remote internet address & port.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrRemote;
        sockAddr.sin_port        = portRemote;

        if( connect( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!  Return the socket to the caller.
        //

        DBG_ASSERT( sNew != INVALID_SOCKET );
        *psock = sNew;

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "data socket %d connected from (%08lX,%04X) to (%08lX,%04X)\n",
                        sNew,
                        ntohl( addrLocal ),
                        ntohs( portLocal ),
                        ntohl( addrRemote ),
                        ntohs( portRemote ) ));
        }
    }
    else
    {
        //
        //  Something fatal happened.  Close the socket if
        //  managed to actually open it.
        //

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "no data socket from (%08lX,%04X) to (%08lX, %04X), error %d\n",
                        ntohl( addrLocal ),
                        ntohs( portLocal ),
                        ntohl( addrRemote ),
                        ntohs( portRemote ),
                        serr ));

        }

        if( sNew != INVALID_SOCKET )
        {
            ResetSocket( sNew );
        }
    }

    return serr;

}   // CreateDataSocket




/*******************************************************************

    NAME:       CreateFtpdSocket

    SYNOPSIS:   Creates a new socket at the FTPD port.
                  This will be used by the passive data transfer.

    ENTRY:      psock - Will receive the new socket ID if successful.

                addrLocal - The lcoal Internet address for the socket
                    in network byte order.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     08-Mar-1993 Created.

********************************************************************/
SOCKERR
CreateFtpdSocket(
    SOCKET * psock,
    ULONG    addrLocal,
    FTP_SERVER_INSTANCE *pInstance
    )
{
    SOCKET  sNew = INVALID_SOCKET;
    SOCKERR serr = 0;
    PORT    DbgBindPort = 0;

    //
    //  Just to be paranoid...
    //

    DBG_ASSERT( psock != NULL );
    *psock = INVALID_SOCKET;

    //
    //  Create the connection socket.
    //

    sNew = WSASocketW(AF_INET,
                      SOCK_STREAM,
                      IPPROTO_TCP,
                      NULL,
                      0,
                      WSA_FLAG_OVERLAPPED);


    serr = ( sNew == INVALID_SOCKET ) ? WSAGetLastError() : 0;

    if( serr == 0 )
    {
        BOOL fReuseAddr = FALSE;

        //
        //  Muck around with the socket options a bit.
        //  Berkeley FTPD does this.
        //

        if( setsockopt( sNew,
                        SOL_SOCKET,
                        SO_REUSEADDR,
                        (CHAR *)&fReuseAddr,
                        sizeof(fReuseAddr) ) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        FTP_PASV_PORT PasvPort;
        SOCKADDR_IN sockAddr;

        //
        //  Bind an address to the socket.
        //

        sockAddr.sin_family      = AF_INET;
        sockAddr.sin_addr.s_addr = addrLocal;
        sockAddr.sin_port        = htons(PasvPort.GetPort());

        //
        // either we bind to a port in the dynamic range (1024-5000), or itterate
        // through the range of configured ports. If we are using the default
        // system managed range, then GetPort() will always return 0, and we only
        // run through the loop once. otherwise, GetPort() will return different ports
        // scanning the port range.
        //
        do {
            if (bind( sNew, (SOCKADDR *)&sockAddr, sizeof(sockAddr) ) == 0) {
                serr = 0;
                DbgBindPort = sockAddr.sin_port;
                break;
            }

        } while( ((serr = WSAGetLastError()) == WSAEADDRINUSE) &&
                  (sockAddr.sin_port = htons(PasvPort.GetPort())) != 0);
    }

    if( serr == 0 )
    {
        //
        //  Put the socket into listen mode.
        //

        if( listen( sNew, (INT)pInstance->NumListenBacklog()) != 0 )
        {
            serr = WSAGetLastError();
        }
    }

    if( serr == 0 )
    {
        //
        //  Success!  Return the socket to the caller.
        //

        DBG_ASSERT( sNew != INVALID_SOCKET );
        *psock = sNew;

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "connection socket %d created at (%08lX,%04X)\n",
                        sNew,
                        ntohl( addrLocal ),
                        ntohs( DbgBindPort ) ));
        }
    }
    else
    {
        //
        //  Something fatal happened.  Close the socket if
        //  managed to actually open it.
        //

        IF_DEBUG( SOCKETS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "no connection socket at (%08lX, %04X), error %d\n",
                        ntohl( addrLocal ),
                        ntohs( DbgBindPort ),
                        serr ));

        }

        if( sNew != INVALID_SOCKET )
        {
            ResetSocket( sNew );
        }
    }

    return serr;

}   // CreateFtpdSocket



/*******************************************************************

    NAME:       CloseSocket

    SYNOPSIS:   Closes the specified socket.  This is just a thin
                wrapper around the "real" closesocket() API.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     26-Apr-1993 Created.

********************************************************************/
SOCKERR
CloseSocket(
    SOCKET sock
    )
{
    SOCKERR serr = 0;

    //
    //  Close the socket.
    //

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    IF_DEBUG( SOCKETS )
    {
        if( serr == 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closed socket %d\n",
                        sock ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot close socket %d, error %d\n",
                        sock,
                        serr ));
        }
    }

    return serr;

}   // CloseSocket


/*******************************************************************

    NAME:       ResetSocket

    SYNOPSIS:   Performs a "hard" close on the given socket.

    ENTRY:      sock - The socket to close.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     08-Mar-1993 Created.

********************************************************************/
SOCKERR
ResetSocket(
    SOCKET sock
    )
{
    SOCKERR serr = 0;
    LINGER  linger;

    //
    //  Enable linger with a timeout of zero.  This will
    //  force the hard close when we call closesocket().
    //
    //  We ignore the error return from setsockopt.  If it
    //  fails, we'll just try to close the socket anyway.
    //

    linger.l_onoff  = TRUE;
    linger.l_linger = 0;

    setsockopt( sock,
                SOL_SOCKET,
                SO_LINGER,
                (CHAR *)&linger,
                sizeof(linger) );

    //
    //  Close the socket.
    //

    if( closesocket( sock ) != 0 )
    {
        serr = WSAGetLastError();
    }

    IF_DEBUG( SOCKETS )
    {
        if( serr == 0 )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "reset socket %d\n",
                        sock ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot reset socket %d, error %d\n",
                        sock,
                        serr ));
        }
    }

    return serr;

}   // ResetSocket



/*******************************************************************

    NAME:       AcceptSocket

    SYNOPSIS:   Waits for a connection to the specified socket.
                The socket is assumed to be "listening".

    ENTRY:      sockListen - The socket to accept on.

                psockNew - Will receive the newly "accepted" socket
                    if successful.

                paddr - Will receive the client's network address.

                fEnforceTimeout - If TRUE, this routine will enforce
                    the idle-client timeout.  If FALSE, no timeouts
                    are enforced (and this routine may block
                    indefinitely).

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
SOCKERR
AcceptSocket(
    SOCKET          sockListen,
    SOCKET *        psockNew,
    LPSOCKADDR_IN   paddr,
    BOOL            fEnforceTimeout,
    FTP_SERVER_INSTANCE *pInstance
    )
{
    SOCKERR serr    = 0;
    SOCKET  sockNew = INVALID_SOCKET;
    BOOL    fRead = FALSE;

    DBG_ASSERT( psockNew != NULL );
    DBG_ASSERT( paddr != NULL );

    if( fEnforceTimeout ) {

        //
        //  Timeouts are to be enforced, so wait for a connection
        //  to the socket.
        //

        serr = WaitForSocketWorker(
                            sockListen,
                            INVALID_SOCKET,
                            &fRead,
                            NULL,
                            pInstance->QueryConnectionTimeout()
                            );
    }

    if( serr == 0 )
    {
        INT cbAddr = sizeof(SOCKADDR_IN);

        //
        //  Wait for the actual connection.
        //

        sockNew = accept( sockListen, (SOCKADDR *)paddr, &cbAddr );

        if( sockNew == INVALID_SOCKET )
        {
            serr = WSAGetLastError();
        }
    }

    //
    //  Return the (potentially invalid) socket to the caller.
    //

    *psockNew = sockNew;

    return serr;

}   // AcceptSocket



/*******************************************************************

    NAME:       SockSend

    SYNOPSIS:   Sends a block of bytes to a specified socket.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pBuffer - Contains the data to send.

                cbBuffer - The size (in bytes) of the buffer.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     13-Mar-1993 Created.

********************************************************************/
SOCKERR
SockSend(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPVOID      pBuffer,
    DWORD       cbBuffer
    )
{
    SOCKERR     serr = 0;
    INT         cbSent;
    DWORD       dwBytesSent = 0;

    DBG_ASSERT( pBuffer != NULL );

    //
    //  Loop until there's no more data to send.
    //

    while( cbBuffer > 0 ) {

        //
        //  Wait for the socket to become writeable.
        //
        BOOL  fWrite = FALSE;

        serr = WaitForSocketWorker(
                        INVALID_SOCKET,
                        sock,
                        NULL,
                        &fWrite,
                        (pUserData != NULL) ?
                            pUserData->QueryInstance()->QueryConnectionTimeout():
                            FTP_DEF_SEND_TIMEOUT
                        );

        if( serr == 0 )
        {
            //
            //  Write a block to the socket.
            //

            cbSent = send( sock, (CHAR *)pBuffer, (INT)cbBuffer, 0 );

            if( cbSent < 0 )
            {
                //
                //  Socket error.
                //

                serr = WSAGetLastError();
            }
            else
            {
                dwBytesSent += (DWORD)cbSent;

                IF_DEBUG( SEND )
                {
                    if( pUserData && TEST_UF( pUserData, TRANSFER ) )
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                                    "send %d bytes @%p to socket %d\n",
                                    cbSent,
                                    pBuffer,
                                    sock ));
                    }
                }
            }
        }


        // added a check for special case when we are sending and thinking that we are sending
        // synchronoulsy on socket which was set to non blocking mode. In that case when buffer space
        // in winsock becomes exhausted send return WSAEWOULDBLOCK. So then we just retry.

        if ( serr != WSAEWOULDBLOCK )
        {
            if( serr != 0 )
            {
                break;
            }

            pBuffer   = (LPVOID)( (LPBYTE)pBuffer + cbSent );
            cbBuffer -= (DWORD)cbSent;
        }
    }

    if( serr != 0 )
    {
        IF_DEBUG( SEND )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "socket error %d during send on socket %d.\n",
                        serr,
                        sock));
        }
    }

    if( pUserData != NULL ) {
        pUserData->QueryInstance()->QueryStatsObj()->UpdateTotalBytesSent(
                                                                dwBytesSent );
    }

    return serr;

}   // SockSend



/*******************************************************************

    NAME:       SockPrintf2

    SYNOPSIS:   Send a formatted string to a specific socket.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pszFormat - A printf-style format string.

                ... - Any other parameters needed by the format string.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     10-Mar-1993 Created.

********************************************************************/
SOCKERR
__cdecl
SockPrintf2(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    ...
    )
{
    va_list ArgPtr;
    SOCKERR serr;

    //
    //  Let the worker do the dirty work.
    //

    va_start( ArgPtr, pszFormat );

    serr = vSockPrintf( pUserData,
                        sock,
                        pszFormat,
                        ArgPtr );

    va_end( ArgPtr );

    return serr;

}   // SockPrintf2



SOCKERR
__cdecl
ReplyToUser(
    IN LPUSER_DATA pUserData,
    IN UINT        ReplyCode,
    IN LPCSTR      pszFormat,
    ...
    )
/*++

  This function sends an FTP reply to the user data object. The reply
   is usually sent over the control socket.

  Arguments:
     pUserData    pointer to UserData object initiating the reply
     ReplyCode    One of the REPLY_* manifests.
     pszFormat    pointer to null-terminated string containing the format
     ...          additional paramters if any required.

  Returns:
     SOCKET error code. 0 on success and !0 on failure.

  History:
     MuraliK
--*/
{
    va_list ArgPtr;
    SOCKERR serr;

    DBG_ASSERT( pUserData != NULL);

    pUserData->SetLastReplyCode( ReplyCode );

    if ( pUserData->QueryControlSocket() != INVALID_SOCKET) {

        //
        //  Let the worker do the dirty work.
        //

        va_start( ArgPtr, pszFormat );

        serr = vSockReply( pUserData,
                          pUserData->QueryControlSocket(),
                          ReplyCode,
                          ' ',
                          pszFormat,
                          ArgPtr );

        va_end( ArgPtr );
    } else {

        serr = WSAECONNABORTED;
    }


    return serr;

}   // ReplyToUser()


// Private functions

/*******************************************************************

    NAME:       vSockPrintf

    SYNOPSIS:   Worker function for printf-to-socket functions.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                pszFormat - The format string.

                args - Variable number of arguments.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
SOCKERR
vSockPrintf(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    LPCSTR      pszFormat,
    va_list     args
    )
{
    INT     cchBuffer = 0;
    INT     buffMaxLen;
    SOCKERR serr = 0;
    CHAR    szBuffer[MAX_REPLY_LENGTH];

    DBG_ASSERT( pszFormat != NULL );

    //
    //  Render the format into our local buffer.
    //


    DBG_ASSERT( MAX_REPLY_LENGTH > 3);
    buffMaxLen = sizeof(szBuffer) - 3;
    cchBuffer = _vsnprintf( szBuffer,
                           buffMaxLen,
                           pszFormat, args );
    //
    // The string length is long, we get back -1.
    //   so we get the string length for partial data.
    //

    if ( (cchBuffer < 0) || (cchBuffer >= buffMaxLen) ) {

        //
        // terminate the string properly,
        //   since _vsnprintf() does not terminate properly on failure.
        //
        cchBuffer = buffMaxLen;
        szBuffer[ buffMaxLen] = '\0';
    }

    IF_DEBUG( SOCKETS ) {
        DBGPRINTF(( DBG_CONTEXT, "sending '%s'\n", szBuffer ));
    }

    //
    // Escape all telnet IAC bytes with a second IAC
    //
    vTelnetEscapeIAC( szBuffer, &cchBuffer, MAX_REPLY_LENGTH - 3 );

    strcpy( szBuffer + cchBuffer, "\r\n" );
    cchBuffer += 2;

    //
    //  Blast it out to the client.
    //

    serr = SockSend( pUserData, sock, szBuffer, cchBuffer );
    return serr;

} // vSockPrintf



/*******************************************************************

    NAME:       vSockReply

    SYNOPSIS:   Worker function for reply functions.

    ENTRY:      pUserData - The user initiating the request.

                sock - The target socket.

                ReplyCode - A three digit reply code from RFC 959.

                chSeparator - Should be either ' ' (normal reply) or
                    '-' (first line of multi-line reply).

                pszFormat - The format string.

                args - Variable number of arguments.

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
SOCKERR
vSockReply(
    LPUSER_DATA pUserData,
    SOCKET      sock,
    UINT        ReplyCode,
    CHAR        chSeparator,
    LPCSTR      pszFormat,
    va_list     args
    )
{
    INT     cchBuffer;
    INT     cchBuffer1;
    INT     buffMaxLen;
    SOCKERR serr = 0;
    CHAR    szBuffer[MAX_REPLY_LENGTH];

    DBG_ASSERT( ( ReplyCode >= 100 ) && ( ReplyCode < 600 ) );

    //
    //  Render the format into our local buffer.
    //

    cchBuffer = _snprintf( szBuffer, sizeof( szBuffer ),
                          "%u%c",
                          ReplyCode,
                          chSeparator );
    DBG_ASSERT( cchBuffer > 0);

    DBG_ASSERT( MAX_REPLY_LENGTH > cchBuffer + 3);
    buffMaxLen = MAX_REPLY_LENGTH - cchBuffer - 3;
    cchBuffer1 = _vsnprintf( szBuffer + cchBuffer,
                            buffMaxLen,
                            pszFormat, args );
    //
    // The string length is long, we get back -1.
    //   so we get the string length for partial data.
    //

    if ( (cchBuffer1 < 0) || (cchBuffer1 > buffMaxLen) ) {

        //
        // terminate the string properly,
        //   since _vsnprintf() does not terminate properly on failure.
        //
        cchBuffer = buffMaxLen;
        szBuffer[ buffMaxLen] = '\0';
    } else {

        cchBuffer += cchBuffer1;
    }

    IF_DEBUG( SOCKETS ) {
        DBGPRINTF(( DBG_CONTEXT, "sending '%s'\n",szBuffer ));
    }

    //
    // Escape all telnet IAC bytes with a second IAC
    //
    vTelnetEscapeIAC( szBuffer, &cchBuffer, MAX_REPLY_LENGTH - 3 );

    strcpy( szBuffer + cchBuffer, "\r\n" );
    cchBuffer += 2;

    //
    //  Blast it out to the client.
    //

    serr = SockSend( pUserData, sock, szBuffer, cchBuffer );

    return serr;

}   // vSockReply


DWORD
FtpFormatResponseMessage( IN UINT     uiReplyCode,
                          IN LPCTSTR  pszReplyMsg,
                          OUT LPTSTR  pszReplyBuffer,
                          IN INT      cchReplyBuffer)
/*++
  This function formats the message to be sent to the client,
    given the reply code and the message to be sent.

  The formatting function takes care of the reply buffer length
    and ensures the safe write of data. If the reply buffer is
    not sufficient to hold the entire message, the reply msg is trunctaed.

  Arguments:
    uiReplyCode   reply code to be used.
    pszReplyMsg   pointer to string containing the reply message
    pszReplyBuffer pointer to character buffer where the reply message
                   can be sent.
    cchReplyBuffer length of reply buffer.

  Returns:
    length of the data written to the reply buffer.

--*/
{
    DBG_ASSERT( pszReplyMsg != NULL && pszReplyBuffer != NULL);
    DBG_ASSERT( cchReplyBuffer > sizeof("NNN \r\n"));

    INT len, pos, maxlen;

    pos = _snprintf( pszReplyBuffer, cchReplyBuffer,
                    "%u ",
                    uiReplyCode);

    DBG_ASSERT( pos >= 4);

    len = lstrlen( pszReplyMsg);
    maxlen = cchReplyBuffer - pos - sizeof("\r\n");

    if (len > maxlen) {
        len = maxlen;
    }

    strncpy(pszReplyBuffer + pos, pszReplyMsg, len);
    strcpy(pszReplyBuffer + pos + len, "\r\n");

    len += pos + 2;

    DBG_ASSERT( len == lstrlen(pszReplyBuffer) );
    DBG_ASSERT( len <= cchReplyBuffer );

    return (len);
} // FtpFormatResponseMessage()


/*******************************************************************

    NAME:       vTelnetEscapeIAC

    SYNOPSIS:   replace (in place) all 0xFF bytes in a buffer with 0xFF 0xFF.
                This is the TELNET escape sequence for an IAC value data byte.

    ENTRY:      pszBuffer - data buffer.

                pcchBufChars - on entry, current number of chars in buffer.
                               on return, number of chars in buffer.

                cchMaxLen - maximum characters in the output buffer

    RETURNS:    TRUE - success, FALSE - overflow.

    HISTORY:
        RobSol     25-April-2001 Created.

********************************************************************/
BOOL
vTelnetEscapeIAC( IN OUT PCHAR pszBuffer,
                  IN OUT PINT  pcchBufChars,
                  IN     INT   cchMaxLen)
{

#   define CHAR_IAC ((CHAR)(-1))

    PCHAR  pszFirstIAC;
    PCHAR  pSrc, pDst;
    BOOL   fReturn = TRUE;
    CHAR   szBuf[MAX_REPLY_LENGTH];
    INT    cCharsInDst;

    DBG_ASSERT( pszBuffer );
    DBG_ASSERT( pcchBufChars );
    DBG_ASSERT( cchMaxLen <= MAX_REPLY_LENGTH );

    if ((pszFirstIAC = strchr( pszBuffer, CHAR_IAC)) == NULL) {

        //
        // no IAC - return.
        //

        return TRUE;
    }

    //
    // we'll expand the string into a temp buffer, then copy back.
    //

    pSrc = pszFirstIAC;
    pDst = szBuf;
    cCharsInDst = DIFF(pszFirstIAC - pszBuffer);

    do {
       if (*pSrc == CHAR_IAC) {

          //
          // this is a char to escape
          //

          if ((cCharsInDst + 1) < cchMaxLen) {

              //
              // we have space to escape the char, so do it.
              //

              cCharsInDst++;
              *pDst++ = CHAR_IAC;
          } else {

              //
              // overflow.
              //

              fReturn = FALSE;
              break;
          }
       }

       *pDst++ = *pSrc++;

    } while ((++cCharsInDst < cchMaxLen) && (*pSrc != '\0'));

    //
    // copy the expanded data back into the input buffer and terminate the string
    //

    memcpy( pszFirstIAC, szBuf, pDst - szBuf);
    pszBuffer[ cCharsInDst ] = '\0';

    *pcchBufChars = cCharsInDst;

    return fReturn;
}

/************************ End of File ******************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\rpcex.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        rpcex.cxx

   Abstract:

        This module defines K2 rpc support.

   Author:

        Johnson Apacible    (JohnsonA)      June-19-1996

--*/

#include "ftpdp.hxx"
#include "time.h"
#include "timer.h"

# define ASSUMED_AVERAGE_USER_NAME_LEN         ( 40)
# define CONN_LEEWAY                           ( 3)

//
//  Private functions.
//

BOOL
GenDoubleNullStringFromMultiLine( IN LPCWSTR lpsz,
                                  IN OUT LPWSTR * ppszz,
                                  IN OUT LPDWORD  pcchLen)
{
    DWORD cchLen;
    DWORD nLines;
    LPCWSTR pszSrc;

    DBG_ASSERT( lpsz != NULL && ppszz != NULL && pcchLen != NULL);

    // Initialize
    *ppszz = NULL;
    *pcchLen = 0;

    //
    // 1. Find the length of the the complete message including new lines
    //  For each new line we may potentially need an extra blank char
    //  So allocate space = nLines + length + 2 terminating null chars.
    //

    cchLen = lstrlenW( lpsz);

    for ( pszSrc = lpsz, nLines = 0;  *pszSrc != L'\0'; pszSrc++) {

        if ( *pszSrc == L'\n')   { nLines++; }
    } // for


    // Allocate sufficient space for the string.
    *ppszz = (LPWSTR ) TCP_ALLOC( (cchLen + nLines + 3) * sizeof(WCHAR));
    if ( *ppszz == NULL) {

        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (FALSE);
    }


    //
    // walk down the local copy and convert all the line feed characters to
    //   be null char
    //

    //
    // Since the MULTI_SZ string cannot contain empty strings
    //  we convert empty lines (ones with just \n into " \0"
    //  i.e.  with a blank character.
    //

    pszSrc = lpsz;
    LPWSTR pszDst = *ppszz;

    if ( *pszSrc == L'\n') {

        // first line is a linefeed. insert a blank and proceed to next line.
        *pszDst = L' ';
        *(pszDst + 1) = L'\0';

        // move forward
        pszDst += 2;
        pszSrc++;
    }

    for( ; *pszSrc != L'\0';  pszSrc++, pszDst++) {

        if ( *pszSrc == L'\n') {

            // we are at boundary of new line.

            if ( pszSrc > lpsz && *(pszSrc - 1) == L'\n') {

                // we detected an empty line. Store an additional blank.

                *pszDst++ = L' ';
            }

            *pszDst = L'\0';  // put null char in place of line feed.

        } else {

            *pszDst = *pszSrc;
        }
    } // for

    *pszDst++   = L'\0';  // terminate with 1st null chars.
    *pszDst++ = L'\0';  // terminate with 2nd null chars.

    *pcchLen = DIFF(pszDst - *ppszz);

    DBG_ASSERT( *pcchLen <= cchLen + nLines + 3);

    return ( TRUE);
} // GenDoubleNullStringFromMultiline()


BOOL
FTP_SERVER_INSTANCE::WriteParamsToRegistry(
    LPFTP_CONFIG_INFO pConfig
    )
/*++
  This function writes parameters to the registry

  Arguments:
    hkey         HKEY for registry entry of parameters of FTP server.
    pConfig      pointer to configuration information.

  Returns:
    TRUE on success and FALSE if there is any failure.
--*/
{
    DWORD   err = NO_ERROR;

    HKEY    hkey = NULL;

    err = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        QueryRegParamKey(),
                        0,
                        KEY_WRITE,
                        &hkey );

    if( hkey == NULL )
    {
        err = ERROR_INVALID_HANDLE;
        SetLastError( err);
        DBGPRINTF(( DBG_CONTEXT,
                    "Invalid Registry key given. error %lu\n",
                    err ));

        return FALSE;
    }

    //
    //  Write the registry data.
    //

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ALLOW_ANONYMOUS ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ALLOW_ANONYMOUS,
                                  pConfig->fAllowAnonymous );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ALLOW_GUEST_ACCESS ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ALLOW_GUEST_ACCESS,
                                  pConfig->fAllowGuestAccess );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ANNOTATE_DIRECTORIES ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ANNOTATE_DIRS,
                                  pConfig->fAnnotateDirectories );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_ANONYMOUS_ONLY ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_ANONYMOUS_ONLY,
                                  pConfig->fAnonymousOnly );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_LISTEN_BACKLOG ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_LISTEN_BACKLOG,
                                  pConfig->dwListenBacklog );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_LOWERCASE_FILES ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_LOWERCASE_FILES,
                                  pConfig->fLowercaseFiles );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_MSDOS_DIR_OUTPUT ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_MSDOS_DIR_OUTPUT,
                                  pConfig->fMsdosDirOutput );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_SHOW_4_DIGIT_YEAR ) )
    {
        err = WriteRegistryDword( hkey,
                                  FTPD_SHOW_4_DIGIT_YEAR,
                                  pConfig->fFourDigitYear );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_EXIT_MESSAGE ) )
    {
        err = RegSetValueExW( hkey,
                              FTPD_EXIT_MESSAGE_W,
                              0,
                              REG_SZ,
                              (BYTE *)pConfig->lpszExitMessage,
                              ( wcslen( pConfig->lpszExitMessage ) + 1 ) *
                                  sizeof(WCHAR) );
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_GREETING_MESSAGE ) )
    {

        LPWSTR pszzGreetingMessage = NULL;
        DWORD   cchLen = 0;

        if (GenDoubleNullStringFromMultiLine( pConfig->lpszGreetingMessage,
                                             &pszzGreetingMessage,
                                             &cchLen)
            ) {

            DBG_ASSERT( pszzGreetingMessage != NULL);

            err = RegSetValueExW( hkey,
                                 FTPD_GREETING_MESSAGE_W,
                                 0,
                                 REG_MULTI_SZ,
                                 (BYTE *) pszzGreetingMessage,
                                 cchLen * sizeof(WCHAR));

            TCP_FREE( pszzGreetingMessage);
        } else {

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_BANNER_MESSAGE ) )
    {

        LPWSTR pszzBannerMessage = NULL;
        DWORD   cchLen = 0;

        if (GenDoubleNullStringFromMultiLine( pConfig->lpszBannerMessage,
                                             &pszzBannerMessage,
                                             &cchLen)
            ) {

            DBG_ASSERT( pszzBannerMessage != NULL);

            err = RegSetValueExW( hkey,
                                 FTPD_BANNER_MESSAGE_W,
                                 0,
                                 REG_MULTI_SZ,
                                 (BYTE *) pszzBannerMessage,
                                 cchLen * sizeof(WCHAR));

            TCP_FREE( pszzBannerMessage);
        } else {

            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }


    if( !err && IsFieldSet( pConfig->FieldControl, FC_FTP_MAX_CLIENTS_MESSAGE ) )
    {
        err = RegSetValueExW( hkey,
                              FTPD_MAX_CLIENTS_MSG_W,
                              0,
                              REG_SZ,
                              (BYTE *)pConfig->lpszMaxClientsMessage,
                              ( wcslen( pConfig->lpszMaxClientsMessage ) + 1 ) *
                                  sizeof(WCHAR) );
    }

    RegCloseKey( hkey);

    if( err )
    {
        SetLastError( err );
        return FALSE;
    }

    return TRUE;

}   // WriteParamsToRegistry



DWORD
FTP_IIS_SERVICE::GetServiceConfigInfoSize(
                    IN DWORD dwLevel
                    )
{
    switch (dwLevel) {
    case 1:
        return sizeof(FTP_CONFIG_INFO);
    }

    return 0;

} // FTP_IIS_SERVICE::GetServerConfigInfoSize


BOOL
FTP_SERVER_INSTANCE::SetServiceConfig(
    IN PCHAR pBuffer
    )
/*++

   Description

       Sets the common service admin information for the servers specified
       in dwServerMask.

   Arguments:

       pConfig - Admin information to set

   Note:

--*/
{
    LPFTP_CONFIG_INFO pConfig = (LPFTP_CONFIG_INFO)pBuffer;
    DWORD err = NO_ERROR;

    //
    //  If success, then Write the new info to the registry, then read it back.
    //

    if( WriteParamsToRegistry( pConfig )) {

        err = InitFromRegistry( pConfig->FieldControl);
    } else {

        err = GetLastError();
    }

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpSetServiceConfig returns with %d %lu\n",
                   err ));
    }

    return(err == NO_ERROR);

} // FTP_SERVER_INSTANCE::SetServiceConfig



BOOL
FTP_SERVER_INSTANCE::GetServiceConfig(
    IN  PCHAR   pBuffer,
    IN  DWORD   dwLevel
    )
/*++

   Description

       Retrieves the admin information

   Arguments:

       pBuffer - Buffer to fill up.
       dwLevel - info level of information to return.

   Note:

--*/
{

    LPFTP_CONFIG_INFO pConfig = (LPFTP_CONFIG_INFO)pBuffer;
    DWORD err = NO_ERROR;

    ZeroMemory( pConfig, sizeof(*pConfig) );

    //
    //  Obtain and Return the admin information.
    //

    err = GetConfigInformation( pConfig);

    IF_DEBUG( RPC) {

        DBGPRINTF(( DBG_CONTEXT,
                   "FtprGetAdminInformation() returns Error=%u\n",
                   err));
    }

    return (err == NO_ERROR);

} // FTP_SERVER_INSTANCE::GetServiceConfig


BOOL
FTP_SERVER_INSTANCE::EnumerateUsers(
    OUT PCHAR * pBuffer,
    OUT PDWORD  nRead
    )
/*++

   Description

       Enumerates the connected users.

   Arguments:

       pBuffer - Buffer to fill up.
       nRead - number of entries filled

--*/
{
    DWORD err;
    DWORD cbBuffer;
    LPIIS_USER_INFO_1 pInfo;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,"Entering FtpEnumerateUsers\n"));
    }

    //
    //  Determine the necessary buffer size.
    //

    cbBuffer = (GetCurrentConnectionsCount() + CONN_LEEWAY)
                * sizeof( IIS_USER_INFO_1 );

    *nRead = 0;

    pInfo = (LPIIS_USER_INFO_1)MIDL_user_allocate( cbBuffer);

    if (pInfo == NULL) {

        err = ERROR_NOT_ENOUGH_MEMORY;
    } else {

        //
        // Make a first attempt at enumerating the user info
        //

        err = NO_ERROR;
        if ( !::EnumerateUsers( (PCHAR)pInfo, &cbBuffer, nRead, this )) {

            //
            // Free up old buffer and allocate big one now.
            // We will try once more to get the data again
            //   with a larger buffer.
            //

            if ( cbBuffer > 0) {

                MIDL_user_free( pInfo );
                pInfo = (LPIIS_USER_INFO_1)MIDL_user_allocate(cbBuffer);

                if( pInfo == NULL ) {

                    err = ERROR_NOT_ENOUGH_MEMORY;
                } else {

                    //
                    // Since we do not lock the active connections list
                    // it is possible some one came in now and hence the
                    //  buffer is insufficient to hold all people.
                    // Ignore this case, as we are never
                    //  going to be accurate
                    //

                    ::EnumerateUsers( (PCHAR)pInfo, &cbBuffer, nRead, this );
                    if ( *nRead == 0 ) {
                        MIDL_user_free(pInfo);
                        pInfo = NULL;
                    }
                }

            } // cbBuffer > 0

        } // if unsuccessful at first attempt
    }

    if( err != NO_ERROR ) {

        IF_DEBUG( RPC ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "I_FtprEnumerateUsers failed. Error = %lu\n",
                       err ));
        }
        SetLastError(err);
        return(FALSE);
    }

    *pBuffer = (PCHAR)pInfo;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpEnumerateUsers returns %d entries, buffer [%x]\n",
                   *nRead, *pBuffer ));
    }
    return TRUE;

} // EnumerateUsers


BOOL
FTP_SERVER_INSTANCE::DisconnectUser(
                        IN DWORD dwIdUser
                        )
/*++

   Description

       Disconnect the user

   Arguments:

       dwIdUser - Identifies the user to disconnect.  If 0,
           then disconnect ALL users.

--*/
{
    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
            "Entering FtpDisconnectUsers with id[%d]\n", dwIdUser));
    }

    if ( !::DisconnectUser( dwIdUser, this ) ) {

        IF_DEBUG( RPC ) {
            DBGPRINTF(( DBG_CONTEXT,
                "DisconnectUser failed with %d\n", GetLastError()));
        }
        SetLastError(NERR_UserNotFound);
        return(FALSE);
    }

    return(TRUE);
} // DisconnectUser


BOOL
FTP_SERVER_INSTANCE::GetStatistics(
                        IN DWORD dwLevel,
                        OUT PCHAR* pBuffer
                        )
/*++

   Description

       Disconnect Queries the server statistics

   Arguments:

       dwLevel - Info level.  Currently only level 0 is
           supported.

       pBuffer - Will receive a pointer to the statistics
           structure.

--*/
{
    APIERR err = NO_ERROR;

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "FtpQueryStatistics2, level %lu\n", dwLevel ));
    }

    //
    //  Return the proper statistics based on the infolevel.
    //

    switch( dwLevel ) {
        case 0 : {

            LPFTP_STATISTICS_0 pstats0;

            pstats0 = (LPFTP_STATISTICS_0)
                       MIDL_user_allocate(sizeof(*pstats0));

            if( pstats0 == NULL ) {

                err = ERROR_NOT_ENOUGH_MEMORY;
            } else {
                ATQ_STATISTICS      atqStat;

                ZeroMemory( pstats0, sizeof( *pstats0 ) );

                QueryStatsObj()->CopyToStatsBuffer( pstats0 );

                //
                //  Get instance's bandwidth throttling statistics
                //

                if ( QueryBandwidthInfo() )
                {
                    if ( AtqBandwidthGetInfo( QueryBandwidthInfo(),
                                              ATQ_BW_STATISTICS,
                                              (ULONG_PTR *) &atqStat ) )
                    {
                        pstats0->TotalBlockedRequests = atqStat.cBlockedRequests;
                        pstats0->TotalRejectedRequests = atqStat.cRejectedRequests;
                        pstats0->TotalAllowedRequests = atqStat.cAllowedRequests;
                        pstats0->CurrentBlockedRequests = atqStat.cCurrentBlockedRequests;
                        pstats0->MeasuredBandwidth = atqStat.MeasuredBandwidth;
                    }
                }

                pstats0->TimeOfLastClear = GetCurrentTimeInSeconds() -
                                           pstats0->TimeOfLastClear;

                //
                //  Copy Global statistics counter values
                //

                pstats0->ConnectionAttempts =
                    g_pFTPStats->QueryStatsObj()->ConnectionAttempts;

                *pBuffer = (PCHAR)pstats0;
            }

        }

        break;

     default :
        err = ERROR_INVALID_LEVEL;
        break;
    }

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT,
                   "FtpQueryStatistics2 returns Error = %lu\n",
                   err ));
    }

    SetLastError(err);
    return(err == NO_ERROR);

} // QueryStatistics



BOOL
FTP_SERVER_INSTANCE::ClearStatistics(
                        VOID
                        )
/*++

   Description

       Clears the server statistics

   Arguments:

        None.

--*/
{

    IF_DEBUG( RPC ) {
        DBGPRINTF(( DBG_CONTEXT, "Entering FtpClearStatistics2\n"));
    }

    QueryStatsObj()->ClearStatistics();
    return TRUE;

} // ClearStatistics
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\stats.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module Name :

       stats.cxx

   Abstract:

       Defines functions required for FTP server statistics

   Author:

       Murali R. Krishnan    ( MuraliK )     04-Nov-1994

   Project:

       Web Server DLL

   Functions Exported:

               FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS( VOID)
       VOID    FTP_SERVER_STATISTICS::ClearStatistics( VOID)
       DWORD   CopyToStatsBuffer( LPFTP_STATISTICS_0 lpStat)

   Revision History:

       Sophia Chung ( SophiaC )     20-Nov-1996

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "ftpdp.hxx"
#include <timer.h>
#include <time.h>


/************************************************************
 *    Functions
 ************************************************************/


FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS( VOID)
/*++
     Initializes statistics information for server.
--*/
{
    INITIALIZE_CRITICAL_SECTION( & m_csStatsLock);

    ClearStatistics();

} // FTP_SERVER_STATISTICS::FTP_SERVER_STATISTICS();


VOID
FTP_SERVER_STATISTICS::ClearStatistics( VOID)
/*++

    Clears the counters used for statistics information

--*/
{
    LockStatistics();

    memset( &m_FTPStats, 0, sizeof(m_FTPStats) );
    m_FTPStats.TimeOfLastClear       = GetCurrentTimeInSeconds();

    UnlockStatistics();

} // FTP_SERVER_STATISTICS::ClearStatistics()



DWORD
FTP_SERVER_STATISTICS::CopyToStatsBuffer( LPFTP_STATISTICS_0 lpStat)
/*++
    Description:
        copies the statistics data from the server statistcs structure
        to the FTP_STATISTICS_0 structure for RPC access.

    Arugments:
        lpStat  pointer to FTP_STATISTICS_0 object which contains the
                data on successful return

    Returns:
        Win32 error codes. NO_ERROR on success.

--*/
{

    DBG_ASSERT( lpStat != NULL);

    LockStatistics();

    CopyMemory( lpStat, &m_FTPStats, sizeof(*lpStat) );

    if (lpStat->ServiceUptime)
    {
        lpStat->ServiceUptime = GetCurrentTimeInSeconds() - lpStat->ServiceUptime;
    }

    UnlockStatistics();

    return ( NO_ERROR);

} // CopyToStatsBuffer()


// gets currenttime and stores it inside stats structure
void
FTP_SERVER_STATISTICS::UpdateStartTime()
{
    m_FTPStats.ServiceUptime = GetCurrentTimeInSeconds();
}



void
FTP_SERVER_STATISTICS::UpdateStopTime()
{
    m_FTPStats.ServiceUptime = 0;
}


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\userdb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    userdb.cxx

    This module manages the user database for the FTPD Service.

    Functions exported by this module:


        DisconnectUser()
        DisconnectUsersWithNoAccess()
        EnumerateUsers()

        USER_DATA::USER_DATA()
        USER_DATA::Reset()
        USER_DATA::~USER_DATA()
        USER_DATA::Cleanup()
        USER_DATA::ProcessAsyncIoCompletion()
        USER_DATA::ReInitializeForNewUser()
        USER_DATA::ReadCommand()
        USER_DATA::DisconnectUserWithError()
        USER_DATA::SendMultilineMessage()
        USER_DATA::SendDirectoryAnnotation()
        USER_DATA::GetFileSize();

        ProcessUserAsyncIoCompletion()

    FILE HISTORY:
        KeithMo     07-Mar-1993 Created.
        MuraliK     March-May, 1995
                      Adding support for Async Io/Transfers
                      + new USER_DATA class functions defined.
                      + oob_inline enabled; ReadCommand() issued after
                          data socket is established.
                      + added member functions for common operations
                      + added ProcessAsyncIoCompletion()
                      + added Establish & Destroy of Data connection

       MuraliK   26-July-1995    Added Allocation caching of client conns.
       Terryk    18-Sep-1996     Added GetFileSize
       AMallet   Sep 1998        Added support for AcceptEx() of PASV data connections
*/


#include "ftpdp.hxx"
#include <security.h>
# include "tsunami.hxx"
#include <timer.h>
# include "auxctrs.h"
# include <mbstring.h>
#include "acptctxt.hxx"

#define FIRST_TELNET_COMMAND    240
#define TELNET_DM_COMMAND       242
#define TELNET_IP_COMMAND       244
#define TELNET_SB_CODE          250
#define TELNET_SB_CODE_MIN      251
#define TELNET_SB_CODE_MAX      254
#define TELNET_IAC_CODE         255

# define  MAX_FILE_SIZE_SPEC           ( 32)


//
//  Private globals.
//

//  This will be expanded into
//  static const char  PSZ_StringName[] = ActualString;
//
# define ConstantStringsForThisModule()            \
  CStrM( ANONYMOUS_NAME,              "Anonymous") /* must match engine.cxx */               \
  CStrM( DEFAULT_SUB_DIRECTORY,       "Default"                                            ) \
  CStrM( SENT_VERB,                   "sent"                                               ) \
  CStrM( CONNECTION_CLOSED_VERB,      "closed"                                             ) \
  CStrM( FILE_ERROR,                  "%s: %s"                                             ) \
  CStrM( TRANSFER_COMPLETE,           "Transfer complete."                                 ) \
  CStrM( TRANSFER_ABORTED,            "Connection closed; transfer aborted."               ) \
  CStrM( TRANSFER_STARTING,           "Data connection already open; Transfer starting."   ) \
  CStrM( INSUFFICIENT_RESOURCES,      "Insufficient system resources."                     ) \
  CStrM( TOO_MANY_PASV_USERS,         "Too many passive-mode users."                       ) \
  CStrM( OPENING_DATA_CONNECTION,     "Opening %s mode data connection for %s%s."          ) \
  CStrM( CANNOT_OPEN_DATA_CONNECTION, "Can't open data connection."                        ) \
  CStrM( COMMAND_TOO_LONG,            "Command was too long"                               ) \
  CStrM( LOCALUSER_DIR,               "LocalUser\\"                                        ) \
  CStrM( ANONYMOUS_DIR,               "Public"                                             ) \
  CStrM( DUMMY_END,  "DummyMsg. Add string before this one")


//
// Generate the strings ( these are private globals of this module).
//

# define CStrM( StringName, ActualString)   \
     static const char PSZ_ ## StringName[] = ActualString ;

ConstantStringsForThisModule()

# undef CStrM


static DWORD  p_NextUserId = 0;        // Next available user id.


//
//  Private prototypes.
//

DWORD
UserpGetNextId(
    VOID
    );



inline VOID
StopControlRead( IN LPUSER_DATA pUserData)
/*++
  Stops control read operation, if one is proceeding.
  Resets the CONTROL_READ flag as well as decrements ref count in user data.

--*/
{
    if ( TEST_UF( pUserData, CONTROL_READ)) {

        if ( InterlockedDecrement( &pUserData->m_nControlRead) < 0 ) {
            DBGPRINTF(( DBG_CONTEXT,
                       "StopControLRead: no read active!!!\n"));
            DBG_ASSERT( FALSE);
        }

        DBG_REQUIRE( pUserData->DeReference() > 0);
        CLEAR_UF( pUserData, CONTROL_READ);
    }

} // StopControlRead()

BOOL
FilterTelnetCommands(IN CHAR * pszLine, IN DWORD cchLine,
                     IN LPBOOL pfLineEnded,
                     IN LPDWORD  pcchRequestRecvd)
/*++
  Filters out the Telnet commands and
  terminates the command line with  linefeed.

  Also this function filters out the out of band data.
  This works similar to the Sockutil.cxx::DiscardOutOfBandData().
  We scan for the pattern "ABOR\r\n" and
   set the OOB_DATA flag if it is present.

  Arguments:
   pszLine   pointer to null terminated string containing the input data.
   cchLine   count  of characters of data received
   pfLineEnded  pointer to Boolean flag which is set to true if complete
             line has been received.
   pcchRequestRecvd  pointer to DWORD which on return contains the number
                      of bytes received.

  Returns:
    TRUE if the filtering is successful without any out of band abort request.
    FALSE if there was any abort request in the input.

--*/
{
    BOOL    fDontAbort = TRUE;
    BOOL    fStateTelnetCmd = FALSE;
    BOOL    fStateTelnetSB = FALSE;
    BOOL    fFoundTelnetIP = FALSE;
    CHAR *  pszSrc;
    CHAR *  pszDst;

    LPCSTR  pszAbort = "ABOR\r\n";
    LPCSTR  pszNext  = pszAbort;

    DBG_ASSERT( pszLine != NULL && cchLine > 0 &&
               pfLineEnded != NULL && pcchRequestRecvd != NULL);

    *pfLineEnded = FALSE;

    for( pszSrc = pszDst = pszLine; pszSrc < pszLine + cchLine &&  *pszSrc;
        pszSrc++) {

        CHAR ch = *pszSrc;
        BYTE uch = (BYTE)ch;

        //
        // Filter out TELNET commands. these are of the form: IAC <cmd> or
        // IAC SB <op> (IAC = 255, SB = 250, op 251..254, cmd > 240)
        //

        if( fStateTelnetCmd ) {
            //
            // we are in a Telbent command sequence
            //

            fStateTelnetCmd = FALSE;

            DBG_ASSERT( uch >= FIRST_TELNET_COMMAND );

            if( fStateTelnetSB ) {
                //
                // we are in a Telnet subsequence command
                //

                fStateTelnetSB = FALSE;

                DBG_ASSERT( (uch >= TELNET_SB_CODE_MIN) &&
                            (uch <= TELNET_SB_CODE_MAX) );

                if( uch >= FIRST_TELNET_COMMAND ) {
                    //
                    // consider it a valid Telnet command, as long as it's in
                    // the Telnet range. Filter this char out.
                    //

                    continue;
                }

                //
                // this is a TELNET protocol error, we'll ignore it.
                //
                // fall through with this char
                //

            } else if( uch == TELNET_SB_CODE ) {
                //
                // enter Telnet subsequense command state
                //

                fStateTelnetCmd = fStateTelnetSB = TRUE;
                continue;

            } else if( uch == TELNET_IAC_CODE ) {
                //
                // this is an escape sequence for a 255 data byte
                //
                // let it fall through
                //

            } else if ( uch == TELNET_IP_COMMAND ) {
                //
                // remember this, it is the first in a SYNCH sequence
                //

                fFoundTelnetIP = TRUE;
                continue;

            } else if ( uch == TELNET_DM_COMMAND ) {
                //
                // if in a SYNCH sequence, this resets the input stream
                //

                if( fFoundTelnetIP ) {
                    pszDst = pszLine;
                    fFoundTelnetIP = FALSE; // completed the SYNCH sequence
                }
                continue;

            } else {
                //
                // we expect a Telnet command code here. filter it out
                //

                DBG_ASSERT( uch >= FIRST_TELNET_COMMAND );

                if ( uch >= FIRST_TELNET_COMMAND ) {
                    continue;
                }

                //
                // this is a TELNET protocol error, we'll ignore it.
                //
                // fall through with this char
                //
            }
        } else if( uch == TELNET_IAC_CODE ) {
            //
            // entering Telnet command parsing state
            //

            fStateTelnetCmd = TRUE;
            continue;
        } else if( uch == TELNET_DM_COMMAND ) {
            //
            // FTP.EXE on Win2k is sending an unexpected SYNCH sequence: DM, IAC, IP. See if this is it.
            //

            if( ( pszSrc == pszLine ) &&
                ( cchLine >= 3 ) &&
                ( (UINT)*(pszSrc+1) == TELNET_IAC_CODE ) &&
                ( (UINT)*(pszSrc+2) == TELNET_DM_COMMAND ) ) {
                //
                // just filter the sequence out
                //

                pszSrc += 2;

                continue;

            } else if( fFoundTelnetIP ) {
                //
                // or, it could be a single byte URGENT notification in the telnet Sync
                //

                pszDst = pszLine;

                fFoundTelnetIP = FALSE; // completed the SYNCH sequence

                continue;
            }
        }

        //
        // if we have seen a Telnet IP, then skip everything up to a DM
        //

        if (fFoundTelnetIP) {
            continue;
        }

        //
        // try matching ABOR\r\n
        //

        if ( *pszNext != ch) {

            // the pattern match failed. reset to start at the beginning.

            pszNext = pszAbort;
        }

        if ( *pszNext == ch) {

            // pattern match at this character. move forward
            pszNext++;

            if ( *pszNext == '\0') {   // end of string==> all matched.

                // only consider this an OOB Abort if at the beginning of
                // a (reset) line

                if( (pszDst - pszLine + 2) == (pszNext - pszAbort) ) {
                    fDontAbort = FALSE;
                }

                pszNext = pszAbort;
            }
        }

        //
        //  don't copy <CR> and <LF> to the output
        //

        if ( (ch != '\r') && ( ch != '\n')) {

            *pszDst++ = ch;

        } else if ( ch == '\n') {

            // terminate at the linefeed
            *pfLineEnded = TRUE;
            break;
        }

    } // for

    *pszDst = '\0';

    *pcchRequestRecvd = DIFF(pszDst - pszLine);
    DBG_ASSERT( *pcchRequestRecvd <= cchLine);

    return (fDontAbort);

} // FilterTelnetCommands()



//
//  Public functions.
//





USER_DATA::USER_DATA(
    IN FTP_SERVER_INSTANCE *pInstance
    )
/*++
  This function creates a new UserData object for the information
    required to process requests from a new User connection ( FTP).

  Arguments:
     sControl   Socket used for control channel in FTP connection
     clientIpAddress  strcuture containing the client Ip address

  Returns:
     a newly constructed USER_DATA object.
     Check IsValid() to ensure the object was properly created.

  NOTE:
    This function is to be used for dummy creation of the object so
      allocation cacher can use this object.
    Fields are randomly initialized. Reset() will initialize them properly.

    However when a new effective USER_DATA object is needed, after allocation
     one can call USER_DATA::Reset() to initialize all vars.
--*/
:
  m_References              ( 0),
  m_ActiveRefAdded          ( 0),
  m_cchRecvBuffer           ( 0),
  m_licbRecvd               ( 0),
  m_cchPartialReqRecvd      ( 0),
  m_pOpenFileInfo           ( NULL),
  Flags                     ( 0),
  UserToken                 ( NULL),
  m_UserId                  ( 0),
  DataPort                  ( 0),
  UserState                 ( UserStateEmbryonic),
  m_fOnActiveConnectionList ( FALSE),
  m_AioControlConnection    ( ProcessUserAsyncIoCompletion),
  m_AioDataConnection       ( ProcessUserAsyncIoCompletion),
  m_AioDataFile             ( ProcessUserAsyncIoCompletion),
  m_AsyncTransferBuff       ( NULL),
  m_sPassiveDataListen      ( INVALID_SOCKET),
  CurrentDirHandle          ( INVALID_HANDLE_VALUE),
  RenameSourceBuffer        ( NULL),
  m_fCleanedup              ( TRUE),
  m_pMetaData               ( NULL),
  m_pInstance               ( pInstance ),
  m_acCheck                 ( AC_NOT_CHECKED ),
  m_fNeedDnsCheck           ( FALSE ),
  m_dwLastReplyCode         ( 0 ),
  m_fHavePASVConn           ( FALSE ),
  m_fWaitingForPASVConn     ( FALSE ),
  m_fFakeIOCompletion       ( FALSE ),
  m_pszCmd                  ( NULL ),
  m_dwRootDirStatus         ( ERROR_ACCESS_DENIED ),
  m_pAdioReq                ( NULL ),
  m_hPASVAcceptEvent        ( NULL )
#if DBG
  ,m_RefTraceLog( NULL )
#endif
{
    DWORD dwTimeout = m_pInstance->QueryConnectionTimeout();

    INITIALIZE_CRITICAL_SECTION( &m_UserLock );

    //
    //  Setup the structure signature. Until Reset(), it is invalid.
    //

    KILL_USER_SIG( this );

    m_AioControlConnection.SetAioInformation( this, dwTimeout);
    m_AioDataConnection.SetAioInformation( this, dwTimeout);
    m_AioDataFile.SetAioInformation( this, dwTimeout);

    InitializeListHead( &ListEntry);

    ZeroMemory( m_recvBuffer, sizeof(m_recvBuffer));

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "user_data object created  @ %08lX.\n",
                   this));
    }

    m_licbSent = 0;

#if DBG
    m_RefTraceLog = CreateRefTraceLog( TRACE_LOG_SIZE, 0 );
#endif

        FakeIOTimes = 0;

} // USER_DATA::USER_DATA()



USER_DATA::~USER_DATA(VOID)
{

    Cleanup();

    if( RenameSourceBuffer != NULL ) {
        TCP_FREE( RenameSourceBuffer);
        RenameSourceBuffer = NULL;
    }

    if ( m_pszCmd != NULL )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_hPASVAcceptEvent != NULL )
    {
        RemovePASVAcceptEvent( TRUE );
    }

    if ( m_pInstance != NULL ) {
        m_pInstance->DecrementCurrentConnections();
        m_pInstance->Dereference();
        m_pInstance = NULL;
    }

#if DBG
    if( m_RefTraceLog != NULL ) {
        DestroyRefTraceLog( m_RefTraceLog );
    }
#endif

    DeleteCriticalSection( &m_UserLock );

} // USER_DATA::~USER_DATA()



BOOL
USER_DATA::Reset(IN SOCKET          sControl,
                 IN PVOID           EndpointObject,
                 IN IN_ADDR         clientIpAddress,
                 IN const SOCKADDR_IN * psockAddrLocal /* = NULL */ ,
                 IN PATQ_CONTEXT    pAtqContext         /* = NULL */ ,
                 IN PVOID           pvInitialRequest    /* = NULL */ ,
                 IN DWORD           cbWritten           /* = 0    */ ,
                 IN AC_RESULT       acCheck
                 )
{
    BOOL  fReturn = TRUE;

    //
    //  Setup the structure signature.
    //

    INIT_USER_SIG( this );

    m_References    = 1;  // set to 1 to prevent immediate deletion.
    m_ActiveRefAdded=  1;
    m_fCleanedup    = FALSE;
    Flags           = m_pInstance->QueryUserFlags();
    UserState       = UserStateEmbryonic;

#if DBG
    if( m_RefTraceLog != NULL ) {
        ResetTraceLog( m_RefTraceLog );
    }
#endif

    m_pOpenFileInfo = NULL;
    UserToken       = NULL;
    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }
    m_UserId        = UserpGetNextId();
    m_xferType      = XferTypeAscii;
    m_xferMode      = XferModeStream;
    m_msStartingTime= 0;
    m_acCheck       = acCheck;
    m_fNeedDnsCheck = FALSE;
    m_dwLastReplyCode = 0;

    HostIpAddress   = clientIpAddress;
    DataIpAddress   = clientIpAddress;

    m_licbRecvd     = 0;
    m_cchRecvBuffer = sizeof( m_recvBuffer) - sizeof(m_recvBuffer[0]);
    m_cchPartialReqRecvd = 0;

    CurrentDirHandle   = INVALID_HANDLE_VALUE;
    RenameSourceBuffer = NULL;
    m_TimeAtConnection = GetCurrentTimeInSeconds();
    m_TimeAtLastAccess = m_TimeAtConnection;


    m_pvInitialRequest  = pvInitialRequest;
    m_cbInitialRequest  = cbWritten;

    //
    // clean up the stuff needed to deal async with PASV command
    //
    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_hPASVAcceptEvent )
    {
        RemovePASVAcceptEvent( TRUE );
    }

    CleanupPASVFlags();

    // set up the async io contexts
    m_AioControlConnection.SetNewSocket( sControl, pAtqContext, EndpointObject );
    m_AioDataConnection.SetNewSocket(INVALID_SOCKET);
    m_AioDataFile.SetNewSocket(INVALID_SOCKET);
    m_sPassiveDataListen = ( INVALID_SOCKET);
    if (m_AsyncTransferBuff) {
        TCP_FREE( m_AsyncTransferBuff);
        m_AsyncTransferBuff = NULL;
    }

    m_rgchFile[0] = '\0';
    m_szUserName[0]  = '\0';             // no user name available yet.
    m_szCurrentDirectory.Reset();        // initialize to no virtual dir.
    m_dwRootDirStatus = ERROR_ACCESS_DENIED;
    m_pAdioReq = NULL;
    m_strRootDir.Reset();                 // no root directory known yet

    m_licbSent = 0;

    m_pInstance->QueryStatsObj()->IncrCurrentConnections();

    m_liCurrentOffset = 0;
    m_liNextOffset = 0;


    //
    //  get the local Ip address
    //

    if ( psockAddrLocal != NULL) {

        LocalIpAddress = psockAddrLocal->sin_addr;
        LocalIpPort = psockAddrLocal->sin_port;
    } else {

        SOCKADDR_IN  saddrLocal;
        INT   cbLocal;

        cbLocal = sizeof( saddrLocal);
        if ( getsockname( sControl, (SOCKADDR *) &saddrLocal, &cbLocal) != 0) {

            DWORD err = WSAGetLastError();

            fReturn = FALSE;

            IF_DEBUG( ERROR) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Failure in getsockname( sock=%d). Error = %u\n",
                            sControl, err));
            }

            SetLastError( err);

        } else  {

            LocalIpAddress = saddrLocal.sin_addr;
            LocalIpPort = saddrLocal.sin_port;
        }
    }

    DataPort = CONN_PORT_TO_DATA_PORT(LocalIpPort);

    //
    //  Success!
    //

    IF_DEBUG( CLIENT) {

        time_t now;
        time( & now);
        CHAR pchAddr[32];

        InetNtoa( clientIpAddress, pchAddr);

        DBGPRINTF( ( DBG_CONTEXT,
                    " Client Connection for %s:%d starting @ %s",
                    pchAddr, sControl,
                    asctime( localtime( &now))));
    }

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "user %lu reset @ %08lX.\n",
                   QueryId(), this));
    }

    m_nControlRead = 0;

    FakeIOTimes = 0;

    return (fReturn);

} // USER_DATA::Reset()




VOID
USER_DATA::Cleanup( VOID)
/*++
  This cleans up data stored in the user data object.

 Returns:
    None

--*/
{
    DBG_ASSERT( QueryReference() == 0);

    if ( m_fCleanedup) {
        return;
    }

    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( USER_DATABASE ) {

        DBGPRINTF(( DBG_CONTEXT,
                   " Cleaning up user %lu  @ %08lX.\n",
                   QueryId(), this));
    }

    DBG_ASSERT( m_nControlRead == 0);

    //
    // Clean up stuff needed to deal with PASV connections
    //
    if ( m_hPASVAcceptEvent )
    {
        RemovePASVAcceptEvent( TRUE );
    }


    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    //
    //  Close any open sockets & handles.
    //

    CloseSockets( FALSE );

    // invalidate the connections
    m_AioControlConnection.SetNewSocket(INVALID_SOCKET);
    m_AioDataConnection.SetNewSocket(INVALID_SOCKET);
    m_AioDataFile.SetNewSocket(INVALID_SOCKET);
    if (m_AsyncTransferBuff) {
        TCP_FREE( m_AsyncTransferBuff);
        m_AsyncTransferBuff = NULL;
    }


    //
    //  Update the statistics.
    //

    if( IsLoggedOn()
        && !TEST_UF( this, WAIT_PASS ) )
    {
        if( TEST_UF( this, ANONYMOUS))
        {
            m_pInstance->QueryStatsObj()->DecrCurrentAnonymousUsers();
        }
        else
        {
            m_pInstance->QueryStatsObj()->DecrCurrentNonAnonymousUsers();
        }
    }

    m_pInstance->QueryStatsObj()->DecrCurrentConnections();

    if( UserToken != NULL )
    {
        TsDeleteUserToken( UserToken );
        UserToken = NULL;
    }

    if( CurrentDirHandle != INVALID_HANDLE_VALUE )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closing directory handle %08lX\n",
                        CurrentDirHandle ));
        }

        CloseHandle( CurrentDirHandle );
        CurrentDirHandle = INVALID_HANDLE_VALUE;
    }

    if ( m_pOpenFileInfo != NULL) {

        DBG_REQUIRE( CloseFileForSend());
    }

    DBG_REQUIRE( CloseFileForReceive());

    //
    //  Release the memory attached to this structure.
    //


    if( RenameSourceBuffer != NULL ) {

        // do not free this location until end of usage.
        RenameSourceBuffer[0] = '\0';
    }

    m_UserId        = 0;  // invalid User Id

    //
    //  Kill the structure signature.
    //

    KILL_USER_SIG( this );

    IF_DEBUG( CLIENT) {

        time_t now;
        time( & now);

        DBGPRINTF( ( DBG_CONTEXT,
                    " Client Connection for %s:%d ending @ %s",
                    inet_ntoa( HostIpAddress), QueryControlSocket(),
                    asctime( localtime( &now))));
    }


    //
    // There is a possible race condition. If the socket was abruptly closed
    //   and there was any pending Io, they will get blown away. This will
    //   cause a call-back from the ATQ layer. That is unavoidable.
    //  In such cases it is possible that the object was deleted.
    //   This can lead to problems. We need to be careful.
    //  But Reference Count protects against such disasters. So tread
    //   carefully and use Reference count.
    //

    DBG_ASSERT( m_sPassiveDataListen == INVALID_SOCKET);

    m_fCleanedup = TRUE; // since we  just cleaned up this object

    return;

} // USER_DATA::Cleanup()






VOID
USER_DATA::ReInitializeForNewUser( VOID)
/*++

  This function reinitializes the user data information for a new user to
  communicate with the server using existing control socket connection.

--*/
{

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    //
    //  Update the statistics.
    //

    if( IsLoggedOn())
    {
        if( TEST_UF( this, ANONYMOUS))
        {
            m_pInstance->QueryStatsObj()->DecrCurrentAnonymousUsers();
        }
        else
        {
            m_pInstance->QueryStatsObj()->DecrCurrentNonAnonymousUsers();
        }
    }

    CLEAR_UF_BITS( this, (UF_LOGGED_ON | UF_ANONYMOUS | UF_PASSIVE));

    LockUser();
    if( QueryState() != UserStateDisconnected ) {
        SetState( UserStateWaitingForUser );
    }
    UnlockUser();

    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }
    m_TimeAtConnection= GetCurrentTimeInSeconds();
    m_TimeAtLastAccess= m_TimeAtConnection;
    m_xferType        = XferTypeAscii;
    m_xferMode        = XferModeStream;
    DataIpAddress     = HostIpAddress;
    DataPort          = CONN_PORT_TO_DATA_PORT(LocalIpPort);

    m_szUserName[0] = '\0';
    m_szCurrentDirectory.Reset();
    m_strRootDir.Reset();

    if( UserToken != NULL )
    {
        TsDeleteUserToken( UserToken );
        UserToken = NULL;
    }

    if( CurrentDirHandle != INVALID_HANDLE_VALUE )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "closing directory handle %08lX\n",
                        CurrentDirHandle ));
        }

        CloseHandle( CurrentDirHandle );
        CurrentDirHandle = INVALID_HANDLE_VALUE;
    }

    if ( m_pOpenFileInfo != NULL) {

        DBG_REQUIRE( CloseFileForSend());
    }

    DBG_REQUIRE( CloseFileForReceive());

    m_licbSent = 0;

    m_pvInitialRequest  = NULL;
    m_cbInitialRequest  = 0;

    CleanupPassiveSocket( TRUE );

    return;

} // USER_DATA::ReInitializeForNewUser()






BOOL
USER_DATA::ProcessAsyncIoCompletion(
    IN DWORD cbIo,
    IN DWORD dwError,
    IN LPASYNC_IO_CONNECTION  pAioConn,
    IN BOOL  fTimedOut)
/*++
  This function processes the Async Io completion.
  ( invoked due to a callback from the ASYNC_IO_CONNECTION object)

  Arguments:
     pContext      pointer to the context information ( UserData object).
     cbIo          count of bytes transferred in Io
     dwError       DWORD containing the error code resulting from last tfr.
     pAioConn      pointer to AsyncIo connection object.
     fTimedOut     flag indicating if the current call was made
                     because of timeout.

  Returns:
     None
--*/
{
    BOOL        fReturn = FALSE;
    AC_RESULT   acDnsAccess;
    DWORD       dwOriginalError;

    dwOriginalError = dwError;

    //
    // Special processing if it's an IO completion on the control connection - we might
    // be processing a completion we posted ourselves to signal that the data socket for the PASV
    // data connection is now accept()'able.
    //

    if ( pAioConn == &m_AioControlConnection && QueryInFakeIOCompletion() )
    {
        // Here is a horrible race condition:
        // If the FTP client closes the control socket
        // right after having finished receiving the transmitted file
        // than there may be a thread that enters this
        // code path (because the FakeIO flag is set, and the
        // Control Socket is involved) before the IO completion
        // for the data connection has traveled this same function,
        // cleaning the FakeIO flag
        // Here is the race condition:
        // A thread enter here, and see that the FakeIO is set
        // the normal behavior is reprocessing a command like
        // "RETR foo.txt", while now the command if a zero length string.
        // the Second thread enter this function with the DataConnection
        // it clears the flag (at a non specified point of the
        // processing of the other thread) and it exit.
        // the original thread is now processing a saved string
        // (because of the FakeIO flag) while it is not supposed to.
        // this causes problems to the time-out algorithm, because
        // of a ref-count problem in the USER_DATA

        LONG CurVal = InterlockedIncrement(&(this->FakeIOTimes));
        if (CurVal>1){
            goto NormalProcessing;
        }

        //
        // Remove the reference used to deal with the race condition between an IO
        // thread doing clean-up and the thread watching for the data socket to become
        // accept()'able and holding on to this USER_DATA object
        //
        DeReference();

        //
        // There is a race condition between the thread watching for a socket to become
        // accept()'able and an IO thread being woken up because the client has (unexpectedly)
        // disconnected. The thread watching the socket will post a fake IO completion to
        // indicate that an accept() on the socket will succeed; however, if the client
        // disconnects (the control connection) before the fake completion is processed,
        // we don't want to do any more processing.
        //
        if ( UserState == UserStateDisconnected )
        {
            return TRUE;
        }
        else
        {
            //
            // Fast-path if we know this is the second time around we're trying to process the
            // command, which happens when we're in PASV mode
            //
            DBG_ASSERT( ( UserState == UserStateLoggedOn ) ||
                    (( UserState == UserStateWaitingForPass ) && QueryInFakeIOCompletion()) );
            goto ProcessCommand;
        }
    }

NormalProcessing:

    if( dwError != NO_ERROR &&
        dwError != ERROR_SEM_TIMEOUT )
    {

        //
        // Geezsh, I hate my life.
        //
        // Once upon a time, there was a bug in ATQ that cause it to
        // always pass NO_ERROR as the status to the async completion
        // routine. This bug caused, among other things, FTP to never
        // time out idle connections, because it never saw the
        // ERROR_SEM_TIMEOUT status. So, I fixed the bug in ATQ.
        //
        // Now, this completion routine gets the actual status. Well,
        // that breaks service shutdown when there are connected users.
        // Basically, when a shutdown occurs, the connected sockets are
        // closed, causing the IO to complete with ERROR_NETNAME_DELETED.
        // USER_DATA::ProcessAsyncIoCompletion() is not handling this
        // error properly, which causes 1) an assertion failure because
        // USER_DATA::DisconnectUserWithError() is getting called *twice*
        // and 2) the service never stops because of a dangling reference
        // on the USER_DATA structure.
        //
        // Of course, the proper thing to do would be to fix the offending
        // code in USER_DATA::ProcessAsyncIoCompletion() so that it DID
        // handle the error properly. Unfortunately, that fix requires a
        // nontrivial amount of surgery, and we're a scant three days
        // from releasing K2 Beta 1. So...
        //
        // As a quick & dirty work around for K2 Beta 1, we'll map all
        // errors other than ERROR_SEM_TIMEOUT to NO_ERROR. This should
        // provide the lower software layers with the old ATQ behavior
        // they're expecting.
        //
        // REMOVE THIS POST BETA 1 AND FIX USER_DATA PROPERLY!!!!
        //
        // 3/12/98
        //
        // N.B. The debug output below has been changed to be a little
        // more customer friendly but I hate to prevent future developers
        // for enjoying the original message which read:
        // "Mapping error %d to NO_ERROR to mask FTP bug (FIX!)\n"
        //
        // I'm removing this message because it was the source of some
        // embarrasment, when a checked version of this DLL was sent to
        // Ernst & Young to track the now famous bug #138566.
        //

        DBGPRINTF((
            DBG_CONTEXT,
            "Mapping error %d to NO_ERROR\n",
            dwError
            ));

        dwError = NO_ERROR;

    }

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[%lu] Entering USER_DATA( %08x)::Process( %u, %u, %08x)."
                    " RefCount = %d. State = %d\n",
                    GetTickCount(),
                    this, cbIo, dwError, pAioConn, QueryReference(),
                    QueryState()));
    }

    if ( m_fNeedDnsCheck )
    {
        acDnsAccess = QueryAccessCheck()->CheckDnsAccess();

        UnbindInstanceAccessCheck();

        m_fNeedDnsCheck = FALSE;

        if ( (acDnsAccess == AC_IN_DENY_LIST) ||
             (acDnsAccess == AC_NOT_IN_GRANT_LIST) ||
             ((m_acCheck == AC_NOT_IN_GRANT_LIST) &&
              (acDnsAccess != AC_IN_GRANT_LIST) ) ) {

            ReplyToUser(this,
                        REPLY_NOT_LOGGED_IN,
                        "Connection refused, unknown IP address." );

            DisconnectUserWithError( NO_ERROR );

            return TRUE;
        }
    }

    if ( pAioConn == &m_AioDataConnection || pAioConn == &m_AioDataFile)
    {

        //
        // a Data transfer operation has completed.
        //

        DBG_REQUIRE( IsLoggedOn());

        // Update last access time
        m_TimeAtLastAccess = GetCurrentTimeInSeconds();

        if ( TEST_UF( this, ASYNC_UPLOAD)) {
            //
            // we are in the data pump loop for uploading a file, and have just completed
            // receiving or writing a block of data. If there were no errors, just initiate an
            // asynchronous write or receive for a block of data, and be done. otherwise, fall
            // through to normal error handling.
            //

            BOOL fAsyncOK;

            if ( (dwError != NO_ERROR) || (cbIo == 0)) {

                //
                // Either the transfer is complete, or an error has occured. terminate.
                //

                fAsyncOK = FALSE;

            } else if ( TEST_UF( this, OOB_DATA)) {

                //
                // we got an out-of-band abbort command, so bail out.
                //

                fAsyncOK = FALSE;
                dwOriginalError = ERROR_OPERATION_ABORTED;

            } else if ( pAioConn == &m_AioDataConnection) {

                //
                // received another block. update stats and initiate async write to file
                //

                IncrementCbRecvd( cbIo);

                fAsyncOK = m_AioDataFile.WriteFile( m_AsyncTransferBuff,
                                                    cbIo,
                                                    QueryCurrentOffset());

                dwOriginalError = GetLastError();
            } else {

                //
                // Write completed. update offset & start new receive
                //

                IncCurrentOffset( cbIo);

                fAsyncOK = m_AioDataConnection.ReadFile(m_AsyncTransferBuff,
                                                        g_SocketBufferSize);

                dwOriginalError = GetLastError();
            }

            if (fAsyncOK) {

                //
                // we have successfully initiated the next async operation, so we are done.
                //

                return TRUE;
            }
        } else if ( TEST_UF( this, ASYNC_DOWNLOAD)) {
            //
            // we are in the datapump for downloading a large file. initiate
            // a transmit file for the next chunk.
            //

            BOOL fAsyncOK;
            BOOL fDisconnectSocket;

            if ( (dwError != NO_ERROR) || (cbIo < MAX_TRANSMIT_FILE_DATA_CHUNK)) {

                //
                // Either the transfer is complete, or an error has occured. terminate.
                //

                fAsyncOK = FALSE;

            } else if ( TEST_UF( this, OOB_DATA)) {

                //
                // we got an out-of-band abbort command, so bail out.
                //

                fAsyncOK = FALSE;
                dwOriginalError = ERROR_OPERATION_ABORTED;

            } else {

                LARGE_INTEGER FileSize;

                IncrementCbSent( cbIo);

                IncCurrentOffset( cbIo);

                m_pOpenFileInfo->QuerySize( FileSize);

                if (FileSize.QuadPart > QueryCurrentOffset()) {

                    //
                    // prepare to send the next chunk
                    //

                    FileSize.QuadPart -= QueryCurrentOffset();

                    if (FileSize.QuadPart > MAX_TRANSMIT_FILE_DATA_CHUNK) {

                        FileSize.QuadPart = MAX_TRANSMIT_FILE_DATA_CHUNK;

                        fDisconnectSocket = FALSE;

                    } else {
                        //
                        // there is nothing left to send after this chunk, so go through
                        // normal path at next completion. Also disconnect socket after
                        // this transmit
                        //

                        CLEAR_UF( this, ASYNC_DOWNLOAD);

                        fDisconnectSocket = TRUE;
                    }

                    fAsyncOK = m_AioDataConnection.TransmitFileTs( m_pOpenFileInfo,
                                                                   FileSize,
                                                                   QueryCurrentOffset(),
                                                                   fDisconnectSocket);

                    dwOriginalError = GetLastError();

                } else if (FileSize.QuadPart == QueryCurrentOffset()) {

                    //
                    // we have sent the entire file, done.
                    //

                    fAsyncOK = FALSE;

                } else {

                    //
                    // the offset is larger than the file, this is an internal error condition
                    //

                    DBG_ASSERT( FileSize.QuadPart >= QueryCurrentOffset());

                    fAsyncOK = FALSE;
                    dwOriginalError = ERROR_INTERNAL_ERROR;
                }
            }

            if (fAsyncOK) {

                //
                // we have successfully initiated the next async operation, so we are done.
                //

                return TRUE;
            }
        }

        if ( dwError == NO_ERROR || !fTimedOut)
        {

            // dwError == NO_ERROR  ==> No error in transmitting data
            //   so decrease ref count and blow away the sockets.

            // if dwError != NO_ERROR then
            //    if timeout occured ==> ATQ will send another callback
            //                      so do not decrease ref count now.
            //    if no timeout ==> then decrement ref count now.

            DBG_REQUIRE( DeReference() > 0);
        }
        else
        {
            // RobSol: 8/20/01: this looks like a faulty statement. fTimeOut must be TRUE, or the
            // previous "if" would be true. I am leaving this dead code commented out, in case we
            // find it was supposed to exist within some other logic.
            // if ( fTimedOut)
            // {
            //     SET_UF( this, DATA_TIMEDOUT);
            // }
            // else
            // {
            //     SET_UF( this, DATA_ERROR);
            // }
            SET_UF( this, DATA_TIMEDOUT);
        }

# ifdef CHECK_DBG
        if ( dwError != NO_ERROR)
        {

            CHAR szBuffer[100];
            DBG_REQUIRE( _snprintf( szBuffer, sizeof( szBuffer ),
                                    " Data Socket Error = %u ", dwError) > 0);
            Print( szBuffer);
        }
# endif // CHECK_DBG

        CLEAR_UF( this, ASYNC_TRANSFER);
        CLEAR_UF( this, ASYNC_DOWNLOAD);

        //
        // Destroy the data connection.
        //  Send message accordingly to indicate if this was a failure/success
        //  That is done by DestroyDataConnection.
        //
        DBG_REQUIRE( DestroyDataConnection( dwOriginalError));

        DBG_REQUIRE( CloseFileForReceive( dwOriginalError));

        if ( m_pOpenFileInfo != NULL)
        {
            //
            // set number of bytes actually sent
            //
            m_licbSent += cbIo;

            DBG_REQUIRE( CloseFileForSend( dwOriginalError));
        }

        if ( dwError == NO_ERROR)
        {

            //
            // Process any Pending commands, due to the parallel
            //    control channel operation for this user Connection.
            // For the present, we dont buffer commands ==> No processing
            //   to be done effectively.   NYI
            // Just ensure that there is a read-operation pending on
            //  control channel.
            //

            // BOGUS: DBG_ASSERT( TEST_UF( this, CONTROL_READ));
        }

        fReturn = TRUE;   // since this function went on well.
    }
    else if ( pAioConn == &m_AioControlConnection)
    {

        //
        // a control socket operation has completed.
        //

        if ( dwError != NO_ERROR)
        {

            //
            // There is an error in processing the control connection request.
            // the only ASYNC_IO request we submit on control is:
            //         Read request on control socket
            //

            if ( fTimedOut)
            {

                if ( TEST_UF( this, TRANSFER))
                {

                    // A data transfer is going on.
                    // allow client to send commands later
                    // (client may not be async in control/data io,so allow it)

                    // resubmit the control read operation
                    //  after clearing old one

                    //
                    // Since there is a pending IO in atq.
                    //  Just resume the timeout processing in ATQ for
                    //  this context.
                    //

                    pAioConn->ResumeIoOperation();
                    fReturn = TRUE;
                }
                else
                {

                    // For timeouts, ATQ sends two call backs.
                    //  So be careful to decrement reference count only once.

                    DBG_ASSERT( fReturn == FALSE);

                    DBG_ASSERT( TEST_UF( this, CONTROL_READ));
                    SET_UF( this, CONTROL_TIMEDOUT);
                }

            }
            else
            {

                // Either there should be a control read pending or
                // control socket should have received a timeout.
                DBG_ASSERT( TEST_UF( this, CONTROL_READ) ||
                            TEST_UF( this, CONTROL_TIMEDOUT)
                           );

                // a non-timeout error has occured. ==> stop read operation.
                StopControlRead(this);
                DBG_ASSERT( fReturn == FALSE);
                SET_UF( this, CONTROL_ERROR);
            }

        }
        else
        {

            // If this connection had an outstanding IO on wait queue, it
            //   got completed. Hence get rid of the reference count.
            StopControlRead( this);

            switch ( UserState)
            {

              case UserStateEmbryonic:

                fReturn = StartupSession( m_pvInitialRequest,
                                          m_cbInitialRequest);

                if ( m_pvInitialRequest == NULL)
                {
                    // No initial buffer. Wait for read to complete
                    break;
                }

                cbIo = m_cbInitialRequest;  // fake the bytes read.

                // Fall Through for processing request

              case UserStateWaitingForUser:
              case UserStateWaitingForPass:
              case UserStateLoggedOn:

            ProcessCommand:
                //
                // Input already read. Process request and submit another read.
                //

                fReturn = ParseAndProcessRequest(cbIo/sizeof(CHAR));

                if ( fReturn && IsDisconnected() &&
                     TEST_UF( this, CONTROL_TIMEDOUT))
                {

                    // disconnect only if no pending control read
                    // if there is a pending control read,
                    //  atq will pop this up for cleanup.
                    fReturn = !(TEST_UF( this, CONTROL_READ));

                    IF_DEBUG( ERROR) {
                        DBGPRINTF(( DBG_CONTEXT,
                                   "%08x ::Timeout killed conn while "
                                   " processing!\n State = %d(%x),"
                                   " Ref = %d, Id = %d, fRet=%d\n",
                                   this, QueryState(), Flags,
                                   QueryReference(), QueryId(), fReturn
                               ));
                    }
                    FacIncrement( CacTimeoutWhenProcessing);
                }
                break;

              case UserStateDisconnected:

                fReturn = TRUE;
                if ( TEST_UF( this, CONTROL_TIMEDOUT))
                {

                    // Timeout thread raced against me :(

                    IF_DEBUG( ERROR) {
                        DBGPRINTF(( DBG_CONTEXT,
                                   "%08x :: Conn already Disconnected !!!\n"
                                   " State = %d(%x), Ref = %d, Id = %d\n",
                                   this, QueryState(), Flags,
                                   QueryReference(), QueryId()
                                   ));
                    }
                    FacIncrement( CacTimeoutInDisconnect);
                    fReturn = FALSE;
                }
                break;

              default:

                DBG_ASSERT( !"Invalid UserState for processing\n");
                SetLastError( ERROR_INVALID_PARAMETER);
                break;
            } // switch

            dwError = ( fReturn) ? NO_ERROR : GetLastError();
        }

        if ( !fReturn)
        {
            DisconnectUserWithError( dwError, fTimedOut);
        }
    }
    else
    {

        DBG_ASSERT( !"call to Process() with wrong parameters");
    }

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "[%lu] Leaving USER_DATA( %08x)::Process()."
                    " RefCount = %d. State = %d\n",
                    GetTickCount(),
                    this, QueryReference(), QueryState())
                  );
    }

    return ( fReturn);
} // USER_DATA::ProcessAsyncIoCompletion()






# define  min(a, b)    (((a) < (b)) ? (a) : (b))

BOOL
USER_DATA::StartupSession(IN PVOID  pvInitialRequest,
                          IN DWORD  cbInitialRequest
                          )
/*++
  This function allocates a buffer for receiving request from the client
   and also sets up initial read from the control socket to
   get client requests.

  Arguments:
    pvInitialRequest   pointer to initial request buffer
    cbInitialRequest   count of bytes of data in the initial request

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    SOCKERR serr;
    BOOL fReturn = FALSE;
    PCSTR pszBanner;

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    DBG_ASSERT( QueryState() == UserStateEmbryonic);

    //
    //  Reply to the initial connection message. ( Greet the new user).
    //

    pszBanner = QueryInstance()->QueryBannerMsg();

    if( pszBanner && *pszBanner ) {
        serr = SendMultilineMessage(
                                   REPLY_SERVICE_READY,
                                   g_FtpServiceNameString,
                                   TRUE,
                                   FALSE);

        serr = serr || SendMultilineMessage(
                                   REPLY_SERVICE_READY,
                                   pszBanner,
                                   FALSE,
                                   TRUE);
    } else {
        serr = ReplyToUser( this,
                           REPLY_SERVICE_READY,
                           "%s",
                           g_FtpServiceNameString );
    }

    if ( serr != 0) {

        IF_DEBUG( ERROR) {
            DBGPRINTF( ( DBG_CONTEXT,
                        " Cannot reply with initial connection message."
                        " Error = %lu\n",
                        serr));
        }

    } else {

        //
        //  enable OOB_INLINE since we are using that for our control socket
        //
        BOOL  fOobInline = TRUE;

        serr = setsockopt( QueryControlSocket(), SOL_SOCKET,
                           SO_OOBINLINE, (const char *) &fOobInline,
                          sizeof( fOobInline));

        m_cchPartialReqRecvd = 0;

        if ( serr == 0) {

            //
            // Try to set up the buffer and enter the mode for reading
            //  requests from the client
            //

            LockUser();
            if( QueryState() != UserStateDisconnected ) {
                SetState( UserStateWaitingForUser);
            }
            UnlockUser();

            if ( pvInitialRequest != NULL && cbInitialRequest > 0) {

                //
                // No need to issue a read, since we have the data required.
                // Do a safe copy to the buffer.
                //

                CopyMemory( QueryReceiveBuffer(), pvInitialRequest,
                       min( cbInitialRequest, QueryReceiveBufferSize())
                       );

                fReturn = TRUE;

            } else {

                fReturn = ReadCommand();
            }

        } else {

            IF_DEBUG( ERROR) {
                DBGPRINTF((DBG_CONTEXT,
                           " SetsockOpt( OOB_INLINE) failed. Error = %lu\n",
                           WSAGetLastError()));
            }

        }
    }

    IF_DEBUG( CLIENT) {

        DWORD  dwError = (fReturn) ? NO_ERROR : GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " connection ( %08x)::StartupSession() returns %d."
                    " Error = %lu\n",
                    this, fReturn,
                    dwError));

        if (fReturn)    {   SetLastError( dwError); }
    }

    return ( fReturn);

} // USER_DATA::StartupSession()



VOID
CheckAndProcessAbortOperation( IN LPUSER_DATA pUserData)
{
    if ( TEST_UF( pUserData, OOB_ABORT)) {

        //
        // An abort was requested by client. So our processing
        // has unwound and we are supposed to send some message
        //  to the client. ==> simulate processing ABOR command
        // ABORT was not processed yet; so process now.
        //

        DBGPRINTF((DBG_CONTEXT,
                   "Executing simulated Abort for %08x\n",
                   pUserData));

        FacIncrement( FacSimulatedAborts);

        // To avoid thread races, check twice.

        if ( TEST_UF( pUserData, OOB_ABORT)) {

          //
          // we need this stack variable (szAbort), so that
          //  ParseCommand() can freely modify the string!
          CHAR szAbort[10];

          CLEAR_UF( pUserData, OOB_ABORT);

          CopyMemory( szAbort, "ABOR", sizeof("ABOR"));
          ParseCommand( pUserData, szAbort);
        }
    }

    return;

} // CheckAndProcessAbortOperation()



BOOL
USER_DATA::ParseAndProcessRequest(IN DWORD cchRequest)
/*++
  This function parses the incoming request from client, identifies the
   command to execute and executes the same.
  Before parsing, the input is pre-processed to remove any of telnet commands
   or OOB_inlined data.

  Arguments:
    cchRequest         count of characters of request received.

--*/
{
    BOOL fLineEnded = FALSE;
    DWORD cchRequestRecvd = 0;
    CHAR szCommandLine[ MAX_COMMAND_LENGTH + 1];

# if DBG

    if ( !IS_VALID_USER_DATA( this))
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG


    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG( CLIENT)
    {

        DBGPRINTF( ( DBG_CONTEXT,
                    "UserData(%08x)::ParseAndProcessRequest( %d chars)\n",
                    this, cchRequest));
    }


    //
    // Fast-path if we're re-processing this command, which happens in PASV mode
    //
    if ( QueryInFakeIOCompletion() )
    {
        goto FastPathLabel;
    }


    if ( cchRequest > 0)
    {
        // We have a valid request. Process it

        // Update last access time
        m_TimeAtLastAccess = GetCurrentTimeInSeconds();

        m_pInstance->QueryStatsObj()->UpdateTotalBytesReceived(
                                                cchRequest*sizeof(CHAR));

        if ( m_cchPartialReqRecvd + cchRequest >=  MAX_COMMAND_LENGTH)
        {
#if DBG
            CHAR  szCmdFailed[600];
            DBG_REQUIRE( _snprintf( szCmdFailed, sizeof( szCmdFailed ),
                      " Command is too long:  Partial=%d bytes. Now=%d \n"
                      "  UserDb(%08p) = %s from Host: %s\n",
                      m_cchPartialReqRecvd, cchRequest,
                      this, QueryUserName(), QueryClientHostName()) > 0);

            DBGPRINTF((DBG_CONTEXT, szCmdFailed));
#endif

            DisconnectUserWithError( ERROR_BUSY);

            return ( TRUE);  // we are done with this connection.
        }

        CopyMemory(szCommandLine, m_recvBuffer,
               m_cchPartialReqRecvd + cchRequest);
        szCommandLine[m_cchPartialReqRecvd + cchRequest] = '\0';

        if ( !::FilterTelnetCommands(szCommandLine,
                                     m_cchPartialReqRecvd + cchRequest,
                                     &fLineEnded,    &cchRequestRecvd))
        {

            if ( TEST_UF( this, TRANSFER))
            {

                //
                // I am in data transfer mode. Some other thread is sending
                //  data for this client. Just post a OOB_DATA and OOB_ABORT
                // OOB_DATA will cause the call-stack of other thread to unwind
                //   and get out of the command.
                // Then check if any async transfer was occuring. If so
                //  process abort with disconnect now.
                //

                SET_UF_BITS( this, (UF_OOB_DATA | UF_OOB_ABORT));

                if ( TEST_UF( this, ASYNC_TRANSFER))
                {

                    //
                    // An async transfer is occuring. Stop it
                    //
                    DestroyDataConnection( ERROR_OPERATION_ABORTED);

                    CheckAndProcessAbortOperation( this);
                }

# ifdef CHECK_DBG

                Print( " OOB_ABORT ");

# endif // CHECK_DBG

                IF_DEBUG( CLIENT) {

                    DBGPRINTF((DBG_CONTEXT,
                               "[%08x]Set up the implied ABORT command\n",
                               this));
                }

                IF_DEBUG( COMMANDS) {

                    DBGPRINTF((DBG_CONTEXT, " ***** [%08x] OOB_ABORT Set \n",
                               this));
                }

                // Ignore the rest of the commands that may have come in.
            }
            else
            {

                //
                // Since no command is getting processed.
                //   atleast process the abort command, otherwise clients hang.
                //

                //
                // we need this stack variable (szAbort), so that
                //  ParseCommand() can freely modify the string!
                CHAR szAbort[10];

                CopyMemory( szAbort, "ABOR", sizeof("ABOR"));
                ParseCommand( this, szAbort);
                CLEAR_UF( this, OOB_ABORT);  // clear the abort flag!
            }

        }
        else
        {

            if ( TEST_UF( this, TRANSFER))
            {

                //
                // we are transferring data, sorry no more commands accepted.
                // This could hang clients. Hey! they asked for it :( NYI
                //

                // Do nothing
                IF_DEBUG( COMMANDS) {

                    DBGPRINTF((DBG_CONTEXT,
                               "***** [%08x] Received Request %s during"
                               " transfer in progress\n",
                               this, szCommandLine));
                }

            }
            else
            {
                //
                //  Let ParseCommand do the dirty work.
                //


                // Remember the count of partial bytes received.
                m_cchPartialReqRecvd = cchRequestRecvd;

                if ( !fLineEnded)
                {

                    // In case if command was long enough to fill all buffer but
                    // we haven't found new line  simply tell to user about the error
                    // and disconnect. Some ftp clients will not see that msg, becuase
                    // connection was disconnected, but thats a bug in client code

                    if ( m_cchPartialReqRecvd >=  MAX_COMMAND_LENGTH - 1)
                    {
                        ReplyToUser( this,
                                     REPLY_UNRECOGNIZED_COMMAND,
                                     PSZ_COMMAND_TOO_LONG);
                        DisconnectUserWithError( ERROR_BUSY );

                        return ( TRUE);  // we are done with this connection.
                    }


                    //
                    // Complete line is not received. Continue reading
                    //   the requests, till we receive the complete request
                    //

                }
                else
                {

                    StartProcessingTimer();

                    //
                    // set the partial received byte count to zero.
                    //  we will not use this value till next incomplete request
                    //

                    m_cchPartialReqRecvd = 0;

FastPathLabel:
                    ParseCommand( this, ( QueryInFakeIOCompletion() ? QueryCmdString() :
                                                                      szCommandLine ) );

                    CheckAndProcessAbortOperation( this);

                } // if TRANSFER is not there...

            } //Parse if complete

        } // if FilterTelnetCommands()
    }
    else
    {
        // if (cchRequest <= 0)

        SET_UF( this, CONTROL_ZERO);

        //
        // after a quit a client is expected to wait for quit message from
        //  the server. if the client prematurely closes connection, then
        //  the server receives it as a receive with zero byte read.
        //  since, we should not be having outstanding read at this time,
        //   atq should not be calling us. On the contrary we are getting
        //  called by ATQ. Let us track this down.
        //

        if ( !TEST_UF( this, CONTROL_QUIT))
        {
            DisconnectUserWithError( NO_ERROR);
        }
        else
        {

            // Quit message is received and then ZeroBytes Received!!
            DBGPRINTF((DBG_CONTEXT,
                       " (%08x)::ZeroBytes recvd after QUIT message!!."
                       " State = %d(%x), Ref = %d\n",
                       this,
                       QueryState(), Flags,
                       QueryReference()
                       ));
            // Do nothing. Since Quit will take care of cleanup
            return (TRUE);
        }
    }

    //
    // If the connection is not yet disconnected, submit a read command.
    //  else return that everything is fine (someone had disconnected it).
    //

    return ( IsDisconnected() ? TRUE : ReadCommand());
} // USER_DATA::ParseAndProcessRequest()





BOOL
USER_DATA::ReadCommand( VOID)
{
    BOOL fReturn = TRUE;

    DBG_CODE(
             if ( !IS_VALID_USER_DATA( this)) {

                 DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                             this));
                 Print();
             }
             );

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );
    if ( TEST_UF( this, CONTROL_TIMEDOUT) || IsDisconnected()) {

        SetLastError( ERROR_SEM_TIMEOUT);
        return (FALSE);
    }

    //
    // Submit a read on control socket only if there is none pending!
    // Otherwise, behave in idempotent manner.
    //

    if ( !TEST_UF( this, CONTROL_READ)) {

        Reference();         // since we are going to set up async read.

        InterlockedIncrement( &m_nControlRead);

        DBG_ASSERT( m_nControlRead <= 1);

        SET_UF( this, CONTROL_READ);  // a read will be pending

        if ( !m_AioControlConnection.ReadFile(QueryReceiveBuffer(),
                                              QueryReceiveBufferSize())
            ) {

            CLEAR_UF( this, CONTROL_READ);  // since read failed.

            DBG_REQUIRE( DeReference() > 0);
            InterlockedDecrement( &m_nControlRead);

            DWORD dwError = GetLastError();

            IF_DEBUG( ERROR) {
                DBGPRINTF( ( DBG_CONTEXT,
                            " User( %08x)::ReadCommand() failed. Ref = %d."
                            " Error = %d\n",
                            this, QueryReference(), dwError));
            }

            SetLastError( dwError);
            fReturn = FALSE;
        }

    }

    return ( fReturn);
} // USER_DATA::ReadCommand()




BOOL
USER_DATA::DisconnectUserWithError(IN DWORD dwError,
                                   IN BOOL fNextMsg OPTIONAL)
/*++
  This function disconnects a user with the error code provided.
  It closes down the control connection by stopping ASYNC_IO.
  If the fNextMsg is not set, then it also decrements the reference count
    for the user data object, to be freed soon.

--*/
{
    CHAR   szBuffer[120];

# if DBG

    if ( !IS_VALID_USER_DATA( this)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    this));
        Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    IF_DEBUG ( CLIENT) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " USER_DATA( %08x)::DisconnectUserWithError( %lu, %d)."
                    " RefCount = %d\n",
                    this, dwError, fNextMsg, QueryReference()));
    }


    if (!fNextMsg) {
        RemoveActiveReference();
    }

    LockUser();

    if ( QueryState() == UserStateDisconnected) {

        //
        // It is already in disconnected state. Do nothing for disconnect.
        //

        UnlockUser();

    } else {

        SetState( UserStateDisconnected );
        UnlockUser();

        //
        // terminate outstanding asynchronous AD IO queries for root directory
        //

        if ( m_pAdioReq != NULL) {
            m_pAdioReq->EndRequest();
            m_pAdioReq = NULL;
        }

        if( dwError == ERROR_SEM_TIMEOUT) {

            const CHAR * apszSubStrings[3];

            IF_DEBUG( CLIENT )
              {
                  DBGPRINTF(( DBG_CONTEXT,
                             "client (%08x) timed-out\n", this ));
              }

            DBG_REQUIRE( _snprintf( szBuffer, sizeof( szBuffer ),
                                    "%lu", m_pInstance->QueryConnectionTimeout() ) > 0);

            apszSubStrings[0] = QueryUserName();
            apszSubStrings[1] = inet_ntoa( HostIpAddress );
            apszSubStrings[2] = szBuffer;

            g_pInetSvc->LogEvent( FTPD_EVENT_CLIENT_TIMEOUT,
                                  3,
                                  apszSubStrings,
                                  0 );

            ReplyToUser(this,
                        REPLY_SERVICE_NOT_AVAILABLE,
                        "Timeout (%lu seconds): closing control connection.",
                        m_pInstance->QueryConnectionTimeout() );
        }

        if ( dwError != NO_ERROR) {

# ifdef CHECK_DBG
            DBG_REQUIRE( _snprintf( szBuffer, sizeof( szBuffer ),
                                    " Control Socket Error=%u ", dwError) > 0);
            Print( szBuffer);
# endif // CHECK_DBG

            if( dwError != ERROR_SEM_TIMEOUT ) {
                SetLastReplyCode( REPLY_TRANSFER_ABORTED );
            }

            // Produce a log record indicating the cause for failure.
            WriteLogRecord( PSZ_CONNECTION_CLOSED_VERB, "", dwError);
        }

        //
        //  Force close the connection's sockets.  This will cause the
        //  thread to awaken from any blocked socket operation.  It
        //  is the destructor's responsibility to do any further cleanup.
        //  (such as calling UserDereference()).
        //

        CloseSockets(dwError != NO_ERROR);
    }

    return ( TRUE);

} // USER_DATA::DisconnectUserWithError()






static BOOL
DisconnectUserWorker( IN LPUSER_DATA  pUserData, IN LPVOID pContext)
/*++
  This disconnects (logically) a user connection, by resetting the
   control connection and stopping IO. Later on the blown away socket
   will cause an ATQ relinquish to occur to blow away of this connection.

  Arguments:
    pUserData   pointer to User data object for connection to be disconnected.
    pContext    pointer to context information
    ( in this case to DWORD containing error code indicating reasong for
         disconnect).

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DWORD  dwError;
    BOOL   retVal;
    DBG_ASSERT( pContext != NULL && pUserData != NULL);
    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );


    dwError = *(LPDWORD ) pContext;


    retVal = pUserData->DisconnectUserWithError( dwError, TRUE);

    // fix for bug 268175 : if we disconnected user we need to do normal cleanup
    // for that connection

    // this check is not very necessary but I leave it for future
    // DisconnectUserWithError always returns TRUE

    if (retVal)
    {
        DereferenceUserDataAndKill(pUserData);
    }


    return retVal;
} // DisconnectUserWorker()




BOOL
DisconnectUser( IN DWORD UserId, FTP_SERVER_INSTANCE *pInstance )
/*++
  This function disconnects a specified user identified using the UserId.
  If UserId specified == 0, then all the users will be disconnected.

  Arguments:
     UserId   user id for the connection to be disconnected.

  Returns:
     TRUE if atleast one of the connections is disconnected.
     FALSE if no user connetion found.

  History:
     06-April-1995 Created.
--*/
{
    BOOL   fFound;
    DWORD  dwContext = ERROR_SERVER_DISABLED;

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fFound = ( pInstance->
               EnumerateConnection( DisconnectUserWorker,
                                   (LPVOID ) &dwContext,
                                   UserId));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fFound) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                     " DisconnectUser( %d) returns %d. Error = %lu\n",
                    UserId, fFound, dwError));

        if (fFound)   { SetLastError( dwError); }
    }

    return ( fFound);
}   // DisconnectUser()





static BOOL
DisconnectUserWithNoAccessWorker( IN LPUSER_DATA  pUserData,
                                  IN LPVOID pContext)
/*++
  This disconnects (logically) a user connection with no access.
  This occurs by resetting the control connection and stopping IO.
  Later on the blown away thread
   will cause an ATQ relinquish to occur to blow away of this connection.

  Arguments:
    pUserData   pointer to User data object for connection to be disconnected.
    pContext    pointer to context information
    ( in this case to DWORD containing error code indicating reasong for
         disconnect).

  Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    BOOL fSuccess = TRUE;
    DBG_ASSERT( pUserData != NULL);

    // Ignode the pContext information.

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    //
    //  We're only interested in connected users.
    //

    if( pUserData->IsLoggedOn()) {

        //
        //  If this user no longer has access to their
        //  current directory, blow them away.
        //

        if( !pUserData->VirtualPathAccessCheck(AccessTypeRead )) {

            const CHAR * apszSubStrings[2];

            IF_DEBUG( SECURITY ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "User %s (%lu) @ %08lX retroactively"
                           " denied access to %s\n",
                           pUserData->QueryUserName(),
                           pUserData->QueryId(),
                           pUserData,
                           pUserData->QueryCurrentDirectory().QueryStr() ));
            }


            fSuccess = ( pUserData->
                           DisconnectUserWithError(ERROR_ACCESS_DENIED,
                                                   TRUE)
                        );

            //
            //  Log an event to tell the admin what happened.
            //

            apszSubStrings[0] = pUserData->QueryUserName();
            apszSubStrings[1] = pUserData->QueryCurrentDirectory().QueryStr();

            g_pInetSvc->LogEvent( FTPD_EVENT_RETRO_ACCESS_DENIED,
                                  2,
                                  apszSubStrings,
                                  0 );
        } // no access

    } // logged on user

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fSuccess) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " DisconnectUsersWithNoAccessWorker( %d) returns %d."
                    " Error = %lu\n",
                    pUserData->QueryId(), fSuccess,
                    dwError)
                  );

        if (fSuccess)   { SetLastError( dwError); }
    }

    return ( fSuccess);
} // DisconnectUserWithNoAccessWorker()



VOID
DisconnectUsersWithNoAccess(FTP_SERVER_INSTANCE *pInstance )
/*++
  This function disconnects all users who do not have read access to
  their current directory. This is typically called when the access masks
  have been changed.

  Arguments:
    None

  Returns:
    None.
--*/
{
    BOOL   fFound;
    DWORD  dwContext = ERROR_ACCESS_DENIED;

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fFound = ( pInstance->
               EnumerateConnection( DisconnectUserWithNoAccessWorker,
                                   (LPVOID ) &dwContext,
                                   0));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    IF_DEBUG( CLIENT) {

        DWORD dwError = (fFound) ? NO_ERROR: GetLastError();

        DBGPRINTF( ( DBG_CONTEXT,
                    " DisconnectUsersWithNoAccess() returns %d."
                    " Error = %lu\n",
                    fFound, dwError)
                  );

        if (fFound)   { SetLastError( dwError); }
    }


}   // DisconnectUsersWithNoAccess




/*++
  The following structure UserEnumBuffer is required to carry the context
  information for enumerating the users currently connected.
  It contains a pointer to array of USER_INFO structures which contain the
   specific information for the user. The user name is stored in the buffer
   from the end ( so that null terminated strings are formed back to back.
   This permits efficient storage of variable length strings.

   The member fResult is used to carry forward the partial result of
    success/failure from one user to another ( since the enumeration has
    to walk through all the elements to find out all user information).


  History: MuraliK ( 12-April-1995)

--*/
struct  USER_ENUM_BUFFER {

    DWORD   cbSize;                   // pointer to dword containing size of
    IIS_USER_INFO_1 * pUserInfo;      // pointer to start of array of USER_INFO
    DWORD   cbRequired;               // incremental count of bytes required.
    DWORD   nEntry;      // number of current entry ( index into  pUserInfo)
    DWORD   dwCurrentTime;            // current time
    WCHAR * pszNext;                  // pointer to next string location.
    BOOL    fResult;             // boolean flag accumulating partial results
};

typedef USER_ENUM_BUFFER  * PUSER_ENUM_BUFFER;


BOOL
EnumerateUserInBufferWorker( IN LPUSER_DATA pUserData,
                             IN LPVOID pContext)
{
# ifdef CHECK_DBG
    CHAR   szBuffer[400];
# endif // CHECK_DBG

    PUSER_ENUM_BUFFER  pUserEnumBuffer = (PUSER_ENUM_BUFFER ) pContext;
    DWORD     tConnect;
    DWORD     cbUserName;

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    //
    //  We're only interested in connected users.
    //

    if( pUserData->IsDisconnected()) {

        return ( TRUE);
    }

    //
    //  Determine required buffer size for current user.
    //

    cbUserName  = ( strlen( pUserData->QueryUserName() ) + 1 ) * sizeof(WCHAR);
    pUserEnumBuffer->cbRequired += sizeof(IIS_USER_INFO_1);

    //
    //  If there's room for the user data, store it.
    //

    tConnect = ( pUserEnumBuffer->dwCurrentTime -
                pUserData->QueryTimeAtConnection());

    if( pUserEnumBuffer->fResult &&
       ( pUserEnumBuffer->cbRequired <= pUserEnumBuffer->cbSize)
       ) {

        LPIIS_USER_INFO_1 pUserInfo =
          &pUserEnumBuffer->pUserInfo[ pUserEnumBuffer->nEntry];

        pUserInfo->idUser     = pUserData->QueryId();
        pUserInfo->pszUser    = (WCHAR *)MIDL_user_allocate( cbUserName );

        if( pUserInfo->pszUser ) {

            pUserInfo->fAnonymous = ( pUserData->Flags & UF_ANONYMOUS ) != 0;
            pUserInfo->inetHost   = (DWORD)pUserData->HostIpAddress.s_addr;
            pUserInfo->tConnect   = tConnect;

            if( !MultiByteToWideChar( CP_OEMCP,
                                     0,
                                     pUserData->QueryUserName(),
                                     -1,
                                     pUserInfo->pszUser,
                                     (int)cbUserName )
               ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "MultiByteToWideChar failed???\n" ));

                pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
            } else {
                pUserEnumBuffer->nEntry++;
            }
        }
        else {

            //
            // Unable to allocate memory
            //
            pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
        }

    } else {

        pUserEnumBuffer->fResult = ( pUserEnumBuffer->fResult && FALSE);
    }

# ifdef CHECK_DBG

    DBG_REQUIRE( _snprintf( szBuffer, sizeof( szBuffer ),
            " Enum  tLastAction=%u;  tConnect=%u. " ,
            ( pUserEnumBuffer->dwCurrentTime -
             pUserData->QueryTimeAtLastAccess()),
            tConnect
            ) > 0);

    pUserData->Print( szBuffer);

# endif // CHECK_DBG

    return ( TRUE);
} // EnumerateUserInBufferWorker()



BOOL
EnumerateUsers(
    PCHAR   pBuffer,
    PDWORD  pcbBuffer,
    PDWORD  nRead,
    FTP_SERVER_INSTANCE *pInstance
    )
/*++
  Enumerates the current active users into the specified buffer.

  Arguments:
    pvEnum   pointer to enumeration buffer which will receive the number of
                   entries and the user information.
    pcbBuffer  pointer to count of bytes. On entry this contains the size in
                   bytes of the enumeration buffer. It receives the count
                   of bytes for enumerating all the users.
    nRead - pointer to a DWORD to return the number of user entries filled.

  Returns:
    TRUE  if enumeration is successful ( all connected users accounted for)
    FALSE  otherwise

--*/
{
    USER_ENUM_BUFFER       userEnumBuffer;
    BOOL   fSuccess;

    DBG_ASSERT( pcbBuffer != NULL );

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering EnumerateUsers( %08x, %08x[%d]).\n",
                    pBuffer, pcbBuffer, *pcbBuffer));
    }

    //
    //  Setup the data in user enumeration buffer.
    //

    userEnumBuffer.cbSize     = *pcbBuffer;
    userEnumBuffer.cbRequired = 0;
    userEnumBuffer.pUserInfo  = (LPIIS_USER_INFO_1)pBuffer;
    userEnumBuffer.nEntry     = 0;
    userEnumBuffer.dwCurrentTime = GetCurrentTimeInSeconds();
    userEnumBuffer.fResult    = TRUE;

    //
    // CODEWORK
    // This field is obsolete it now points to the extra CONN_LEEWAY
    // buffer.
    //
    userEnumBuffer.pszNext    = ((WCHAR *)( pBuffer + *pcbBuffer));


    //
    //  Scan the users and get the information required.
    //

    pInstance->Reference();
    pInstance->LockConnectionsList();

    fSuccess = (pInstance->
                EnumerateConnection( EnumerateUserInBufferWorker,
                                    (LPVOID ) &userEnumBuffer,
                                    0));

    pInstance->UnlockConnectionsList();
    pInstance->Dereference();

    //
    //  Update enum buffer header.
    //

    *nRead             = userEnumBuffer.nEntry;
    *pcbBuffer         = userEnumBuffer.cbRequired;

    IF_DEBUG( USER_DATABASE) {

        DBGPRINTF((DBG_CONTEXT,
                   " Leaving EnumerateUsers() with %d."
                   " Entries read =%d. BufferSize required = %d\n",
                   userEnumBuffer.fResult,
                   userEnumBuffer.nEntry, userEnumBuffer.cbRequired));
    }

    return ( userEnumBuffer.fResult);

}   // EnumerateUsers




SOCKERR
USER_DATA::SendMultilineMessage(
    IN UINT  nReplyCode,
    IN LPCSTR pszzMessage,
    IN BOOL fIsFirst,
    IN BOOL fIsLast)
/*++
  Sends a multiline message to the control socket of the client.

  Arguments:
    nReplyCode   the reply code to use for the first line of the multi-line
                  message.
    pszzMessage  pointer to double null terminated sequence of strings
                  containing the message to be sent.
    fIsFirst     flag to indicate we are starting the multiline reply. if FALSE,
                  don't print the code for the first line, as it was already emmited elsewhere
    fIsLast      flag to indicate we are finishing the multiline reply. if FALSE,
                  don't print the code for the first line, as it was already emmited elsewhere

    If the message is empty, we do not print anything. If there is only one line, then if
    fIsLast is TRUE, we only print the terminating line, otherwise we do print the openning
    line if fIsFirst is TRUE.

  Returns:
    SOCKERR  - 0 if successful, !0 if not.

  History:
    MuraliK    12-April-1995
--*/
{
    SOCKERR   serr = 0;
    LPCSTR    pszMsg, pszNext;

    //
    // return if there is nothing to send
    //

    if ( pszzMessage == NULL || *pszzMessage == '\0') {
        return serr;
    }


    for ( pszMsg = pszzMessage;  serr == 0 && *pszMsg != '\0';  pszMsg = pszNext) {

        //
        // find next message so that we can check of pszMsg is the last line
        //

        pszNext = pszMsg + strlen( pszMsg) + 1;

        if( fIsLast && *pszNext == '\0' ) {
            //
            // This is globally the last line. Print it pefixed with the reply code.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "%u %s",
                               nReplyCode,
                               pszMsg);

        } else if( fIsFirst ) {
            //
            // this is globally the first line of reply, and it is not globally the last one.
            // print it with '-'.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "%u-%s",
                               nReplyCode,
                               pszMsg);

            fIsFirst = FALSE;
        } else {
            //
            // this is either an intermediate line, or the last line in this batch (but
            // not globally), so print it idented without the reply code.
            //
            serr = SockPrintf2(this, QueryControlSocket(),
                               "    %s",
                               pszMsg);
        }
    } // for

    return ( serr);

} // USER_DATA::SendMultilineMessge()






SOCKERR
USER_DATA::SendDirectoryAnnotation( IN UINT ReplyCode, IN BOOL fIsFirst)
/*++
    SYNOPSIS:   Tries to open the FTPD_ANNOTATION_FILE (~~ftpsvc~~.ckm)
                file in the user's current directory.  If it can be
                opened, it is sent to the user over the command socket
                as a multi-line reply.

    ENTRY:
                ReplyCode - The reply code to send as the first line
                    of this multi-line reply.

                fIsFirst - flag to indicate if this is the first line in the multi-line
                    reply. If not, the ReplyCode is not shown

    RETURNS:    SOCKERR - 0 if successful, !0 if not.

    HISTORY:
        KeithMo     06-May-1993 Created.
        MuraliK     12-Apr-1995 Made it to be part of USER_DATA
--*/
{
    FILE    * pfile;
    SOCKERR   serr = 0;
    CHAR      szLine[MAX_REPLY_LENGTH+1];


    //
    //  Try to open the annotation file.
    //

    pfile = Virtual_fopen( this,
                           FTPD_ANNOTATION_FILE,
                           "r" );

    if( pfile == NULL )
    {
        //
        //  File not found.  Blow it off.
        //

        return 0;
    }


    // protection agians attack when CKM file islarge, somebody is downloading it
    // slowly on many connections and uses all ATQ threads. Note that attack is still possible
    // but much more difficult to achieve

    AtqSetInfo( AtqIncMaxPoolThreads, 0);

    //
    //  While there's more text in the file, blast
    //  it to the user.
    //

    while( fgets( szLine, MAX_REPLY_LENGTH, pfile ) != NULL )
    {
        CHAR * pszTmp = szLine + strlen(szLine) - 1;

        //
        //  Remove any trailing CR/LFs in the string.
        //

        while( ( pszTmp >= szLine ) &&
               ( ( *pszTmp == '\n' ) || ( *pszTmp == '\r' ) ) )
        {
            *pszTmp-- = '\0';
        }

        //
        //  Ensure we send the proper prefix for the
        //  very *first* line of the file.
        //

        if( fIsFirst )
        {
            serr = SockPrintf2(this,
                               QueryControlSocket(),
                               "%u-%s",
                               ReplyCode,
                               szLine );

            fIsFirst = FALSE;
        }
        else
        {
            serr = SockPrintf2(this,
                               QueryControlSocket(),
                               "   %s",
                               szLine );
        }

        if( serr != 0 )
        {
            //
            //  Socket error sending file.
            //

            break;
        }
    }

    AtqSetInfo( AtqDecMaxPoolThreads, 0);

    //
    //  Cleanup.
    //

    if ( 0 != fclose( pfile )) {

        IF_DEBUG( ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       "[%08x]::SendAnnotationFile() file close failed. "
                       " Error = %d\n",
                       this,
                       GetLastError()
                       ));
        }
    }

    return serr;

}   // USER_DATA::SendDirectoryAnnotation()




SOCKERR
USER_DATA::SendErrorToClient(
   IN LPCSTR pszPath,
   IN DWORD  dwError,
   IN LPCSTR pszDefaultErrorMsg,
   IN UINT nReplyCode
   )
/*++
  Send an error message indicating that the path is not found or
   a particular error occured in a path.

  Arguments:
    sock       socket to be used for synchronously sending message
    pszPath    pointer to path to be used.
    dwError    DWORD containing the error code, used for getting error text.
    pszDefaultErrorMsg  pointer to null-terminated string containing the
                     error message to be used if we can't alloc error text.
    nReplyCode UINT containing the FTP reply code.

  Returns:
    SOCKERR.  0 if successful and !0 if failure.
--*/
{
    BOOL    fDelete = TRUE;
    LPCSTR  pszText;
    APIERR serr;

    DBG_ASSERT( pszPath != NULL);
    pszText = AllocErrorText( dwError );

    if( pszText == NULL ) {

        pszText = pszDefaultErrorMsg;
        fDelete = FALSE;
    }

    serr = ReplyToUser( this,
                        nReplyCode,
                        PSZ_FILE_ERROR,
                        pszPath,
                        pszText );

    if( fDelete ) {

        FreeErrorText( (char *) pszText );
    }

    return ( serr);
} // USER_DATA::SendErrorToClient()





BOOL
USER_DATA::FreeUserToken( VOID)
/*++

   This function frees the user token if present already.
   Otherwise does nothing.
--*/
{
    BOOL fReturn = TRUE;

    if( UserToken != NULL ) {

        fReturn = TsDeleteUserToken( UserToken );

        UserToken = NULL;
        ::RevertToSelf();
    }

    return ( fReturn);
} // USER_DATA::FreeUserToken()


APIERR
USER_DATA::CdToUsersHomeDirectory()
/*++
  This function changes user's home directory.
  First, a CD to the virtual root is attempted.
  If this succeeds, a CD to pszUser is attempted.
  If this fails, a CD to DEFAULT_SUB_DIRECTORY is attempted.

  Returns:
    APIERR.  NO_ERROR on success.
--*/
{
    APIERR   err;
    CHAR     rgchRoot[MAX_PATH];

    //
    //  Try the top-level home directory.  If this fails, bag out.
    //   Set and try to change directory to symbolic root.
    //

    m_szCurrentDirectory.Reset(); // initially nothing.

    m_pInstance->LockThisForRead();
    DBG_ASSERT( strlen( m_pInstance->QueryRoot()) < MAX_PATH);
    P_strncpy( rgchRoot, m_pInstance->QueryRoot(), MAX_PATH);
    m_pInstance->UnlockThis();

    err = VirtualChDir( this, rgchRoot); // change to default dir.

    if ( (err == NO_ERROR) &&
         (m_pInstance->QueryIsolationMode() == MD_USER_ISOLATION_NONE) ) {

        //
        //  We successfully CD'd into the top-level home
        //  directory.  Now see if we can CD into pszUser.
        //

        P_strncpy( rgchRoot, QueryRootDirectory().QueryStr(), MAX_PATH);
        if ( !VirtualChDir( this, rgchRoot ) ) {

            //
            //  Nope, try DEFAULT_SUB_DIRECTORY. If this fails, just
            //  hang-out at the top-level home directory.
            //

            P_strncpy( rgchRoot, PSZ_DEFAULT_SUB_DIRECTORY, MAX_PATH);
            VirtualChDir( this, rgchRoot );
        }
    }

    return ( err);

}   // USER_DATA::CdToUsersHomeDirectory()


VOID
USER_DATA::SignalRootDirReady(
    HANDLE hUserData,
    DWORD dwResult)
/*++

      Function that restarts processing the original command when a PASV data socket becomes
      accept()'able [ie the client has made the connection]

  Arguments:
      pUserData - USER_DATA context attached to socket

  Returns:
     Nothing
--*/
{
    LPUSER_DATA  pUserData = (LPUSER_DATA)hUserData;

    PATQ_CONTEXT pAtqContext = pUserData->QueryControlAio()->QueryAtqContext();

    pUserData->SetRootDirStatus( dwResult );

    pUserData->SetInFakeIOCompletion( TRUE );

    pUserData->m_pAdioReq = NULL; // we no longer need this

    //
    // do a scary thing - fake an IO completion, to trigger re-processing of the FTP command
    //
    if ( !AtqPostCompletionStatus( pAtqContext,
                                   strlen( pUserData->QueryCmdString() ) + 1 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to post fake completion status to deal with async ADIO : 0x%x\n",
                   GetLastError()));
    }
}




APIERR
USER_DATA::SetRootDirectory(
    LPSTR pszCmd)
/*++
  this function sets the home directory for the logging in user,
  based on the current isolation mode. If we are in no-isolation mode,
  the user name excluding domain name is used. In basic isolation mode <domain>\<user>
  is used for domain users, and local\<user> for local domain users. The
  anonymous user gets 'LocalUser\public' in the isolation mode, and pszAnonymousName in
  the no-isolation mode. For AD isolatin mode, the home directory is
  retrieved from the AD

  Arguments:
      pszCmd   Pointer to command line. we need to preserve it for an asynchronous call

  Returns:
  NO_ERROR on success, WinError otherwise.
--*/
{
    APIERR RetVal = NO_ERROR;
    PSTR   pszUser;
    PSTR   pszDomain;
    BOOL   fIsLocalUser;
    CHAR   szDomainAndUser[ UNLEN + DNLEN + 2 ];

    //
    // handle anonymous users first
    //

    if( TEST_UF( this, ANONYMOUS ) ) {
        switch (m_pInstance->QueryIsolationMode()) {

        case MD_USER_ISOLATION_NONE:
            //
            // Anonymous users are mapped to a static name directory.
            //

            m_strRootDir.Copy( '\\' );

            m_strRootDir.Append( PSZ_ANONYMOUS_NAME);

            break;

        case MD_USER_ISOLATION_BASIC:
            //
            // Anonymous users are mapped to a static named directory
            // under the local accounts directory.
            //

            m_strRootDir.Copy( '\\' );

            m_strRootDir.Append( PSZ_LOCALUSER_DIR, sizeof( PSZ_LOCALUSER_DIR ) - 1 );

            m_strRootDir.Append( PSZ_ANONYMOUS_DIR, sizeof( PSZ_ANONYMOUS_DIR ) - 1 );

            break;

        case MD_USER_ISOLATION_AD:

            DBG_ASSERT( m_pInstance->QueryAdIo() != NULL );

            RetVal = m_pInstance->QueryAnonymousHomeDir( m_strRootDir );

            break;

        default:

            DBG_ASSERT( FALSE );
            RetVal = ERROR_INTERNAL_ERROR;
        }

        goto ExitPoint;
    }

    //
    // now, on to authenticated users. find the logged on user full name
    //
    if( !ImpersonateUser()) {

        //
        //  Impersonation failure.
        //

        RetVal = ERROR_ACCESS_DENIED;
        goto ExitPoint;

    } else {
        DWORD dwSize = sizeof(szDomainAndUser);
        if (!GetUserNameEx(NameSamCompatible,
                        szDomainAndUser,
                        &dwSize)) {

            RetVal = GetLastError();
        }


        RevertToSelf();

        if (RetVal != ERROR_SUCCESS) {
            goto ExitPoint;
        }
    }


    if (!ParseUserName(
            szDomainAndUser,
            &pszUser,
            &pszDomain,
            m_pInstance->QueryLocalHostName(),
            &fIsLocalUser)) {

        RetVal = ERROR_INVALID_PARAMETER;
        goto ExitPoint;
    }

    switch (m_pInstance->QueryIsolationMode()) {

    case MD_USER_ISOLATION_NONE:
        //
        // in the MD_USER_ISOLATION_NONE mode, compatible with pre 6.0 functionality, we set
        // the root directory to the user name, excluding the domain (if provided).
        //

        m_strRootDir.Copy( '\\' );

        m_strRootDir.Append( pszUser );

        break;

    case MD_USER_ISOLATION_BASIC:
        //
        // in the MD_USER_ISOLATION_BASIC mode, users logging in without specifying a domain
        // are mapped to their user name under a static local directory name, while users
        // logging in with a domain name are mapped to their user name directory under the
        // domain name directory.
        //

        m_strRootDir.Copy( '\\' );

        if ( fIsLocalUser ) {
            //
            // local user
            //
            m_strRootDir.Append( PSZ_LOCALUSER_DIR, sizeof( PSZ_LOCALUSER_DIR ) - 1 );

            m_strRootDir.Append( pszUser );

        } else {

            //
            // domain user
            //
            m_strRootDir.Append( pszDomain );
            m_strRootDir.Append( "\\", 1 );
            m_strRootDir.Append( pszUser );
        }

        break;

    case MD_USER_ISOLATION_AD:

        DBG_ASSERT( m_pInstance->QueryAdIo() != NULL );

        if ( fIsLocalUser) {
            //
            // we don't allow local user in this isolation mode
            //

            RetVal = ERROR_INVALID_PARAMETER;
            break;
        }

        //
        // make a async call to retrieve the properties from AD
        //

        Reference(); // ++ reference before issuing an async call

        RetVal = m_pInstance->QueryUserHomeDir(
                                    pszUser,
                                    pszDomain,
                                    &m_strRootDir,
                                    &m_pAdioReq,
                                    &SignalRootDirReady,
                                    (HANDLE)this);

        if (RetVal != ERROR_IO_PENDING) {
            //
            // remove the reference as the async call failed
            //

            DBG_REQUIRE( DeReference() > 0 );
        }

        break;

    default:

        DBG_ASSERT( FALSE );
        RetVal = ERROR_INTERNAL_ERROR;
    }

ExitPoint:
    SetRootDirStatus( RetVal );

    return RetVal;
}



APIERR
USER_DATA::OpenFileForSend( IN LPSTR pszFile)
/*++
  Open an existing file for transmission using TransmitFile.
  This function converts the given relative path into canonicalized full
    path and opens the file through the cached file handles manager.

  Arguments:
    pszFile   pointer to null-terminated string containing the file name

  Returns:
    TRUE on success and FALSE if any failure.
--*/
{
    APIERR  err;
    CHAR   szCanonPath[MAX_PATH+1];
    DWORD  cbSize = sizeof(szCanonPath);
    CHAR   szVirtualPath[MAX_PATH+1];
    DWORD  ccbVirtualPath = sizeof(szVirtualPath);

    DBG_ASSERT( pszFile != NULL );

    //
    // Close any file we might have open now
    // N.B. There shouldn't be an open file; we're just
    // being careful here.
    //

    if (m_pOpenFileInfo) {
        DBGPRINTF(( DBG_CONTEXT,
                   "WARNING!! Closing [%08x], before opening %s\n",
                   pszFile
                   ));
        DBG_REQUIRE( CloseFileForSend() );
    }

    //
    // Open the requested file
    //
    err = VirtualCanonicalize(szCanonPath,
                              &cbSize,
                              pszFile,
                              AccessTypeRead,
                              NULL,
                              szVirtualPath,
                              &ccbVirtualPath);

    if( err == NO_ERROR ) {

        DWORD                   dwCreateFlags = 0;

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "Opening File: %s\n", szCanonPath ));
        }

        // store the virtual path name of file.
        SetVirtualFileName( szVirtualPath );

        dwCreateFlags = TS_FORBID_SHORT_NAMES | TS_NOT_IMPERSONATED ;


        if ( !m_pMetaData || m_pMetaData->QueryDoCache() )
        {
            dwCreateFlags |= TS_CACHING_DESIRED;
        }

        m_pOpenFileInfo = TsCreateFile( m_pInstance->GetTsvcCache(),
                                szCanonPath,
                                QueryImpersonationToken(),
                                dwCreateFlags
                                );
                                // caching desired.

        if( m_pOpenFileInfo == NULL ) {

            err = GetLastError();

        } else {

            DWORD dwAttrib = m_pOpenFileInfo->QueryAttributes();

            FacIncrement( FacFilesOpened);

            DBG_ASSERT( dwAttrib != 0xffffffff);

            if (dwAttrib == 0xFFFFFFFF ||   // invalid attributes
                dwAttrib & (FILE_ATTRIBUTE_DIRECTORY |
                            FILE_ATTRIBUTE_HIDDEN |
                            FILE_ATTRIBUTE_SYSTEM)
                ) {

                FacIncrement( FacFilesInvalid);

                err =  ERROR_FILE_NOT_FOUND;
            }

        }
    }

    if( err != NO_ERROR ) {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot open %s, error %lu\n",
                       pszFile,
                       err ));
        }
    }

    return ( err);
} // USER_DATA::OpenFileForSend()





BOOL
USER_DATA::CloseFileForSend( IN DWORD dwError, IN BOOL NoLog)
{
    BOOL fReturn = TRUE;
    TS_OPEN_FILE_INFO * pOpenFileInfo;

    // make sure it includes the full path
    DBG_ASSERT( m_rgchFile[0] == '/');

    pOpenFileInfo = (TS_OPEN_FILE_INFO *) InterlockedExchangePointer(
                                              (PVOID *) &m_pOpenFileInfo,
                                              NULL
                                              );

    if ( pOpenFileInfo != NULL) {

        //
        // Fabricate an appropriate reply code based on the incoming
        // error code. WriteLogRecord() will pick up this reply code
        // and use it in the activity log.
        //

        SetLastReplyCode(
            ( dwError == NO_ERROR )
                ? REPLY_TRANSFER_OK
                : REPLY_TRANSFER_ABORTED
                );

        FacIncrement( FacFilesClosed);
        TsCloseHandle( m_pInstance->GetTsvcCache(), pOpenFileInfo);
        if ( !NoLog) {
            WriteLogRecord( PSZ_SENT_VERB, m_rgchFile, dwError);
        }
    }

    return ( fReturn);
} // USER_DATA::CloseFileForSend()




BOOL
USER_DATA::CloseFileForReceive( IN DWORD dwError, IN BOOL NoLog)
{

    BOOL   fAsyncFileOp;
    fAsyncFileOp = TEST_UF( this, ASYNC_UPLOAD);
    CLEAR_UF( this, ASYNC_UPLOAD );

    if ( fAsyncFileOp) {

        m_AioDataFile.StopIo(dwError);

        //
        // Fabricate an appropriate reply code based on the incoming
        // error code. WriteLogRecord() will pick up this reply code
        // and use it in the activity log.
        //

        if ( !NoLog) {
            SetLastReplyCode(
                ( dwError == NO_ERROR )
                    ? REPLY_TRANSFER_OK
                    : REPLY_TRANSFER_ABORTED
                    );

            WriteLogRecord( m_pszCmdVerb, m_rgchFile, dwError);
        }
    }

    return TRUE;
} // USER_DATA::CloseFileForReceive()






# define MAX_ERROR_MESSAGE_LEN   ( 500)
VOID
USER_DATA::WriteLogRecord( IN LPCSTR  pszVerb,
                           IN LPCSTR  pszPath,
                           IN DWORD   dwError)
/*++
  This function writes the log record for current request made to the
   Ftp server by the client.

  Arguments:
    pszVerb    - pointer to null-terminated string containing the verb
                 of operation done
    pszPath    - pointer to string containing the path for the verb
    dwError    - DWORD containing the error code for operation

  Returns:
    None.
--*/
{
    INETLOG_INFORMATION   ilRequest;
    DWORD dwLog;
    CHAR  pszClientHostName[50];
    CHAR  pszServerIpAddress[50];
    CHAR  rgchRequest[MAX_PATH + 20];
    INT   cch;
    static CHAR szFTPVersion[]="FTP";

    BOOL  fDontLog = m_pMetaData && m_pMetaData->DontLog();

    if (!fDontLog)
    {

                //
                // Fill in the information that needs to be logged.
                //

                ZeroMemory(&ilRequest, sizeof(ilRequest));

                P_strncpy( pszClientHostName, (char *)QueryClientHostName(), 50);
                ilRequest.pszClientHostName       = pszClientHostName;
                ilRequest.cbClientHostName       = strlen(pszClientHostName);

                ilRequest.pszClientUserName       = (char *)QueryUserName();
                P_strncpy( pszServerIpAddress, inet_ntoa( LocalIpAddress ), 50);
                ilRequest.pszServerAddress        = pszServerIpAddress;

                ilRequest.msTimeForProcessing     = QueryProcessingTime();
                ilRequest.dwBytesSent             = (DWORD)m_licbSent;  // BUGBUG: need to log 64 bit
                ilRequest.dwBytesRecvd            = (DWORD)m_licbRecvd; // BUGBUG: need to log 64 bit
                ilRequest.dwProtocolStatus        = GetLastReplyCode();
                ilRequest.dwWin32Status           = dwError;
                ilRequest.dwPort                  = ntohs ((WORD)LocalIpPort);

                cch = _snprintf( rgchRequest, sizeof( rgchRequest ), "[%d]%s", QueryId(), pszVerb);
                rgchRequest[ sizeof( rgchRequest) - 1] = '\0';
                DBG_ASSERT( cch > 0 );
                DBG_ASSERT( cch < MAX_PATH + 20);

                ilRequest.pszOperation            = rgchRequest;
                if ( rgchRequest != NULL ) {
                        ilRequest.cbOperation            = strlen(rgchRequest);
                } else {
                        ilRequest.cbOperation            = 0;
                }

                ilRequest.pszTarget               = (char *)pszPath;
                if ( pszPath != NULL ) {
                        ilRequest.cbTarget               = strlen((char *)pszPath);
                } else {
                        ilRequest.cbTarget               = 0;
                }

                ilRequest.pszParameters             = "";
                ilRequest.pszVersion                = szFTPVersion;

                dwLog = m_pInstance->m_Logging.LogInformation( &ilRequest);

                if ( dwLog != NO_ERROR) {
                        IF_DEBUG( ERROR) {

                                DBGPRINTF((DBG_CONTEXT,
                                                   " Unable to log information to logger. Error = %u\n",
                                                   dwLog));

                                DBGPRINTF((DBG_CONTEXT,
                                                   " Request From %s, User %s. Request = %s %s\n",
                                                   ilRequest.pszClientHostName,
                                                   ilRequest.pszClientUserName,
                                                   ilRequest.pszOperation,
                                                   ilRequest.pszTarget));
                        }
                }

                //
                // LogInformation() should not fail.
                //  If it does fail, the TsvcInfo will gracefully suspend logging
                //    for now.
                //  We may want to gracefully handle the same.
        //
    }

    m_licbRecvd = 0;        // reset since we wrote the record

    m_pInstance->QueryStatsObj()->UpdateTotalBytesSent( m_licbSent );
    m_licbSent = 0;

    return;
} // USER_DATA::WriteLogRecord()

VOID
USER_DATA::WriteLogRecordForSendError( DWORD dwError )
{
    //
    // We put this into its own method in this file so it can access
    // the common PSZ_SENT_VERB global.
    //

    WriteLogRecord(
        PSZ_SENT_VERB,
        m_rgchFile,
        dwError
        );

}   // USER_DATA::WriteLogRecordForSendError



//
//  Private functions.
//

VOID
USER_DATA::CloseSockets(IN BOOL fWarnUser)
/*++
  Closes sockets (data and control) opened by the user for this session.

  Arguments:
    fWarnUser  - If TRUE, send the user a warning shot before closing
                   the sockets.
--*/
{
    SOCKET ControlSocket;

    DBG_ASSERT( IS_VALID_USER_DATA( this ) );

    //
    //  Close any open sockets.  It is very important to set
    //  PassiveDataListen socket & ControlSocket to INVALID_SOCKET
    //   *before* we actually close the sockets.
    //  Since this routine is called to
    //  disconnect a user, and may be called from the RPC thread,
    //  closing one of the sockets may cause the client thread
    //  to unblock and try to access the socket.  Setting the
    //  values in the per-user area to INVALID_SOCKET before
    //  closing the sockets keeps this from being a problem.
    //
    //  This was a problem created by the Select or WaitForMultipleObjects()
    //   Investigate if such race conditions occur with   Asynchronous IO?
    //      NYI
    //

    CleanupPassiveSocket( TRUE );

    //
    // Get rid of the async io connection used for data transfer.
    //

    m_AioDataConnection.StopIo( NO_ERROR);

    ControlSocket = QueryControlSocket();

    if( ControlSocket != INVALID_SOCKET )
    {
        if( fWarnUser )
        {
            //
            //  Since this may be called in a context other than
            //  the user we're disconnecting, we cannot rely
            //  on the USER_DATA fields.  So, we cannot call
            //  SockReply, so we'll kludge one together with
            //  SockPrintf2.
            //

            SockPrintf2( this,
                         ControlSocket,
                         "%d Terminating connection.",
                         REPLY_SERVICE_NOT_AVAILABLE );
        }

        StopControlIo(); // to stop the io on control socket.
    }

    return;

}   // USER_DATA::CloseSockets()


/*******************************************************************

    NAME:       UserpGetNextId

    SYNOPSIS:   Returns the next available user id.

    RETURNS:    DWORD - The user id.

    HISTORY:
        KeithMo     23-Mar-1993 Created.

********************************************************************/
DWORD
UserpGetNextId(
    VOID
    )
{
    DWORD userId;

    // Increment the global counter, avoiding it from becoming 0.
    InterlockedIncrement( (LPLONG ) &p_NextUserId);

    if ((userId = p_NextUserId) == 0) {

        InterlockedIncrement( (LPLONG ) &p_NextUserId);
        userId = p_NextUserId;
    }

    DBG_ASSERT( userId != 0);

    return userId;

}   // UserpGetNextId





VOID
USER_DATA::Print( IN LPCSTR pszMsg) const
/*++

  Prints the UserData object in debug mode.

  History:
     MuraliK  28-March-1995  Created.
--*/
{

# ifdef CHECK_DBG
    CHAR   szBuffer[1000];

    DBG_REQUIRE( _snprintf( szBuffer, sizeof( szBuffer ),
            "[%d] %s: {%u} \"%s\" State=%u. Ref=%u.\n"
            "    Ctrl sock=%u; Atq=%x. Data sock=%u; Atq=%x. CtrlRead=%u\n"
            "    LastCmd= \"%s\"\n",
            GetCurrentThreadId(), pszMsg,
            QueryId(), QueryUserName(),
            QueryState(), QueryReference(),
            QueryControlSocket(), m_AioControlConnection.QueryAtqContext(),
            QueryDataSocket(), m_AioDataConnection.QueryAtqContext(),
            TEST_UF( this, CONTROL_READ), m_recvBuffer
            ) > 0);

    OutputDebugString( szBuffer);

# endif // CHECK_DBG

    CHKINFO( ( DBG_CONTEXT,
                " Printing USER_DATA( %08x)   Signature: %08x\n"
                " RefCount  = %08x;  UserState = %08x;\n"
                " ControlSocket = %08x; PassiveL = %08x\n"
                " FileInfo@ = %08x; CurDir( %s) Handle = %08x\n"
                " UserName = %s; UserToken = %08x; UserId = %u\n"
                " Behaviour Flags = %08x; XferType = %d; XferMode = %d\n",
                this, Signature, m_References, UserState,
                QueryControlSocket(), m_sPassiveDataListen,
                m_pOpenFileInfo, QueryCurrentDirectory().QueryStr(), CurrentDirHandle,
                QueryUserName(), UserToken, QueryId(),
                Flags, m_xferType, m_xferMode));

    DBGPRINTF( ( DBG_CONTEXT,
                " Local IpAddr = %s; HostIpAddr = %s; DataIpAddr = %s;\n"
                " Port = %d; TimeAtConnection = %08x;\n",
                inet_ntoa( LocalIpAddress), inet_ntoa( HostIpAddress),
                inet_ntoa( DataIpAddress),
                DataPort,
                m_TimeAtConnection));

    DBGPRINTF(( DBG_CONTEXT, " ASYNC_IO_CONN Control=%08x; Data=%08x\n",
               &m_AioControlConnection, m_AioDataConnection));

    IF_DEBUG( ASYNC_IO) {

# if DBG
        m_AioControlConnection.Print();
        m_AioDataConnection.Print();
# endif // DBG
    }

    return;
} // USER_DATA::Print()




BOOL
USER_DATA::VirtualPathAccessCheck(IN ACCESS_TYPE  _access, IN  char * pszPath)
/*++
  checks to see if the access is allowed for accessing the path
    using pszPath after canonicalizing it.

 Arguments:
    access     the access desired
    pszPath    pointer to string containing the path

 Returns:
    TRUE on success and FALSE if there is any failure.

--*/
{
    DWORD  dwError;
    CHAR   rgchPath[MAX_PATH+1];
    DWORD  dwSize = sizeof(rgchPath);


    // this following call converts the symbolic path into absolute
    //  and also does path access check.
    dwError = VirtualCanonicalize(rgchPath, &dwSize,
                                  pszPath, _access);

    return ( dwError);

} // USER_DATA::VirtualPathAccessCheck()





APIERR
USER_DATA::VirtualCanonicalize(
    OUT CHAR *   pszDest,
    IN OUT LPDWORD  lpdwSize,
    IN OUT CHAR *   pszSearchPath,
    IN ACCESS_TYPE  _access,
    OUT LPDWORD     pdwAccessMask,
    OUT CHAR *      pchVirtualPath,             /* OPTIONAL */
    IN OUT LPDWORD  lpccbVirtualPath            /* OPTIONAL */
    )
/*++
  This function canonicalizes the path, taking into account the current
    user's current directory value.

  Arguments:
     pszDest   string that will on return contain the complete
                      canonicalized path. This buffer will be of size
                      specified in *lpdwSize.

     lpdwSize  Contains the size of the buffer pszDest on entry.
                  On return contains the number of bytes written
                   into the buffer or number of bytes required (incl. \0).

     pszSearchPath  pointer to string containing the path to be converted.
       IF NULL, use the current directory only

     accesss   Access type for this path ( read, write, etc.)

     pdwAccessMask  pointer to DWORD which on succesful deciphering
                     will contain the  access mask.

     pchVirtualPath  pointer to string which will contain the sanitized
                     virtual path on return (on success)
     lpccbVirtualPath  pointer to DWORD containing the length of buffer
                     (contains the length on return) incl. \0.

  Returns:

     Win32 Error Code - NO_ERROR on success

     MuraliK   24-Apr-1995   Created.

--*/
{
    DWORD dwError = NO_ERROR;
    CHAR  rgchVirtual[MAX_PATH+1];

    DBG_ASSERT( pszDest != NULL);
    DBG_ASSERT( lpdwSize != NULL);
    DBG_ASSERT( pszSearchPath != NULL);

    IF_DEBUG( VIRTUAL_IO) {

        DBGPRINTF(( DBG_CONTEXT,
                   "UserData(%08x)::VirtualCanonicalize(%08x, %08x[%u],"
                   " %s, %d)\n",
                   this, pszDest, lpdwSize, *lpdwSize, pszSearchPath, _access));
    }

    if ( pdwAccessMask != NULL) {

        *pdwAccessMask = 0;
    }

    //
    // Form the virtual path for the given path.
    //

    if ( !IS_PATH_SEP( *pszSearchPath)) {

        const CHAR * pszNewDir = QueryCurrentDirectory().QueryStr(); // get virtual dir.

        //
        // This is a relative path. append it to currrent directory
        //

        if ( _snprintf( rgchVirtual, sizeof(rgchVirtual) - 1, "%s/%s",
                      pszNewDir, pszSearchPath) < 0) {

            // long path --> is not supported.
            DBGPRINTF((DBG_CONTEXT, "Long Virtual Path %s---%s\n",
                       pszNewDir, pszSearchPath));

            dwError = ERROR_PATH_NOT_FOUND;
        } else {

            rgchVirtual[ sizeof(rgchVirtual) - 1 ] = '\0';
            pszSearchPath = rgchVirtual;
        }
    } else {

        // This is an absolute virtual path.
        // need to overwrite this virtual path with absolute
        // path of the root.  Do nothing.
    }

    if ( dwError == NO_ERROR) {

        DWORD dwAccessMask = 0;
        DBG_ASSERT( IS_PATH_SEP(*pszSearchPath));

        //
        // Now we have the complete symbolic path to the target file.
        //  Translate it into the absolute path
        //

        VirtualpSanitizePath( pszSearchPath);

        if ( !LookupVirtualRoot( pszSearchPath,
                                 pszDest,
                                 lpdwSize,
                                 &dwAccessMask ) ) {

            dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "LookupVirtualRoot Failed. Error = %d. pszDest = %s. BReq=%d\n",
                       dwError, pszDest, *lpdwSize));

        } else if ( !PathAccessCheck( _access, dwAccessMask,
                                     TEST_UF( this, READ_ACCESS),
                                     TEST_UF( this, WRITE_ACCESS))
                   ) {

            dwError = GetLastError();
            DBGPRINTF(( DBG_CONTEXT,
                       "PathAccessCheck Failed. Error = %d. pszDest = %s\n",
                       dwError, pszDest));
        } else if ( lpccbVirtualPath != NULL) {

            // successful in getting the path.

            DWORD cchVPath = strlen( pszSearchPath);

            *lpccbVirtualPath = cchVPath + 1;   // set the length to required size.

            if ( *lpccbVirtualPath > cchVPath && pchVirtualPath != NULL) {

                // copy the virtual path, since we have space.
                CopyMemory( pchVirtualPath, pszSearchPath, cchVPath + 1);
            } else {
                dwError = ERROR_INSUFFICIENT_BUFFER;
            }

        }

        if ( dwError == NO_ERROR ) {
            // IP check

            AC_RESULT       acIpAccess;
            AC_RESULT       acDnsAccess;
            BOOL            fNeedDnsCheck;

            BindPathAccessCheck();
            acIpAccess = QueryAccessCheck()->CheckIpAccess( &fNeedDnsCheck );

            if ( (acIpAccess == AC_IN_DENY_LIST) ||
                 ((acIpAccess == AC_NOT_IN_GRANT_LIST) && !fNeedDnsCheck) ) {
                dwError = ERROR_INCORRECT_ADDRESS;
            }
            else if ( fNeedDnsCheck ) {
                if ( !QueryAccessCheck()->IsDnsResolved() ) {
                    BOOL fSync;
                    LPSTR pDns;

                    if ( !QueryAccessCheck()->QueryDnsName( &fSync,
                            (ADDRCHECKFUNCEX)NULL,
                            (ADDRCHECKARG)NULL,
                            &pDns ) ) {
                        dwError = ERROR_INCORRECT_ADDRESS;
                    }
                }
                if ( dwError == NO_ERROR ) {
                    acDnsAccess = QueryAccessCheck()->CheckDnsAccess();

                    if ( (acDnsAccess == AC_IN_DENY_LIST) ||
                         (acDnsAccess == AC_NOT_IN_GRANT_LIST) ||
                         ((m_acCheck == AC_NOT_IN_GRANT_LIST) &&
                          (acDnsAccess != AC_IN_GRANT_LIST) ) ) {
                        dwError = ERROR_INCORRECT_ADDRESS;
                    }
                }
            }
            UnbindPathAccessCheck();
        }

        if ( pdwAccessMask != NULL) {

            *pdwAccessMask = dwAccessMask;
        }
    }


    IF_DEBUG( VIRTUAL_IO) {

        if ( dwError != NO_ERROR) {

            DBGPRINTF(( DBG_CONTEXT,
                       " Cannot Canonicalize %s -- %s, Error = %lu\n",
                       QueryCurrentDirectory().QueryStr(),
                       pszSearchPath,
                       dwError));
        } else {

            DBGPRINTF(( DBG_CONTEXT,
                       "Canonicalized path is: %s\n",
                       pszDest));
        }
    }

    if ( dwError != NO_ERROR ) {
        SetLastError( dwError );
    }

    return ( dwError);
} // USER_DATA::VirtualCanonicalize()





/*******************************************************************

********************************************************************/
SOCKERR
USER_DATA::EstablishDataConnection(
    IN LPCSTR   pszReason,
    IN LPCSTR   pszSize
    )
/*++

  Connects to the client's data socket.

  Arguments:
     pszReason - The reason for the transfer (file list, get, put, etc).
     pszSize   - size of data being transferred.

  Returns:
    socket error code on any error.
--*/
{
    SOCKERR     serr  = 0;
    SOCKET      DataSocket = INVALID_SOCKET;
    BOOL        fPassive;
    BOOL        fAcceptableSocket = FALSE;

    //
    // if we're in passive mode and aren't dealing with a fake IO completion [ie reprocessing
    // the command], we just set up the event that will get signalled when the client
    // actually connects.
    //

    if ( TEST_UF( this, PASSIVE ) &&
         !QueryInFakeIOCompletion() )
    {
        //
        //  Ensure we actually created a passive listen data socket.
        //    no data transfer socket is in AsyncIo object.
        //

        DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

        //
        // To avoid blocking while waiting for the client to connect, we're going to use
        // WSAEventSelect() to wait for the socket to be accept()'able.
        //
        //

        if ( ( serr = AddPASVAcceptEvent( &fAcceptableSocket ) ) != 0 )
        {
            ReplyToUser( this,
                         REPLY_LOCAL_ERROR,
                         PSZ_TOO_MANY_PASV_USERS );

            return ( serr );
        }

        //
        // No need to wait around, we can call accept() on the socket right now
        //
        if ( fAcceptableSocket )
        {
            goto continue_label;
        }

        m_fWaitingForPASVConn = TRUE;
        m_fHavePASVConn = FALSE;

        return ERROR_IO_PENDING;
    }

    DBG_ASSERT( !TEST_UF(this, PASSIVE) || QueryInFakeIOCompletion() );


continue_label:
    //
    //  Reset any oob flag.
    //

    CLEAR_UF( this, OOB_DATA );

    //
    //  Capture the user's passive flag, then reset to FALSE.
    //

    fPassive = TEST_UF( this, PASSIVE );
    CLEAR_UF( this, PASSIVE );

    //
    //  If we're in passive mode, then accept a connection to
    //  the data socket.
    //
    //  Calling accept() on this socket should -not- block because shouldn't get this
    //  far without being sure that calling accept() won't block - that's the point of
    //  jumping through the WSAEventSelect() hoops mentioned above
    //

    if( fPassive )
    {

        SOCKADDR_IN saddrClient;

        //
        //  Ensure we actually created a passive listen data socket.
        //    no data transfer socket is in AsyncIo object.
        //

        DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

        //
        //  Wait for a connection.
        //

        IF_DEBUG( CLIENT )
        {

            DBGPRINTF(( DBG_CONTEXT,
                        "waiting for passive connection on socket %d\n",
                       m_sPassiveDataListen ));
        }

        serr = AcceptSocket( m_sPassiveDataListen,
                             &DataSocket,
                             &saddrClient,
                             TRUE,
                             m_pInstance );            // enforce timeouts


        //
        //  We can kill m_sPassiveDataListen now.
        //  We only allow one connection in passive mode.
        //

        CleanupPassiveSocket( TRUE );

        // PASV Theft is disabled, so you MUST have the same IP
        // address ad the Control Connection. The flag is renamed to
        // enable_pasv_conn_from_3rdip
        if (!(QueryInstance()->IsEnablePasvConnFrom3rdIP()))
        {
            if (!(HostIpAddress.S_un.S_addr == saddrClient.sin_addr.S_un.S_addr))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "Unmatching IP - Control: %d.%d.%d.%d Data: %d.%d.%d.%d \n",
                           HostIpAddress.S_un.S_un_b.s_b1,
                           HostIpAddress.S_un.S_un_b.s_b2,
                           HostIpAddress.S_un.S_un_b.s_b3,
                           HostIpAddress.S_un.S_un_b.s_b4,
                           saddrClient.sin_addr.S_un.S_un_b.s_b1,
                           saddrClient.sin_addr.S_un.S_un_b.s_b2,
                           saddrClient.sin_addr.S_un.S_un_b.s_b3,
                           saddrClient.sin_addr.S_un.S_un_b.s_b4));

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;
                serr = WSA_OPERATION_ABORTED;
            };
        };

        if( serr == 0 )
        {

            //
            //  Got one.
            //

            DBG_ASSERT( DataSocket != INVALID_SOCKET );

            m_fHavePASVConn = TRUE;
            m_fWaitingForPASVConn = FALSE;

            FacIncrement( FacPassiveDataConnections);

            if ( m_AioDataConnection.SetNewSocket( DataSocket))
            {

                ReplyToUser(this,
                            REPLY_TRANSFER_STARTING,
                            PSZ_TRANSFER_STARTING);
            }
            else
            {

                //
                // We are possibly running low on resources. Send error.
                //

                ReplyToUser( this,
                            REPLY_LOCAL_ERROR,
                            PSZ_INSUFFICIENT_RESOURCES);

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;
                serr = WSAENOBUFS;
            }
        }
        else
        {

            IF_DEBUG( CLIENT )
            {

                DBGPRINTF(( DBG_CONTEXT,
                            "cannot wait for connection, error %d\n",
                            serr ));
            }

            ReplyToUser(this,
                        REPLY_TRANSFER_ABORTED,
                        PSZ_TRANSFER_ABORTED);
        }

    }
    else
    {

        //
        //  Announce our intentions of establishing a connection.
        //

        ReplyToUser(this,
                    REPLY_OPENING_CONNECTION,
                    PSZ_OPENING_DATA_CONNECTION,
                    TransferType(m_xferType ),
                    pszReason,
                    pszSize);

        //
        //  Open data socket.
        //

        serr = CreateDataSocket(&DataSocket,           // Will receive socket
                                LocalIpAddress.s_addr, // Local address
                                CONN_PORT_TO_DATA_PORT(LocalIpPort),
                                DataIpAddress.s_addr,// RemoteAddr
                                DataPort ); // Remote port

        if ( serr == 0 )
        {

            DBG_ASSERT( DataSocket != INVALID_SOCKET );

            FacIncrement( FacActiveDataConnections);

            if ( !m_AioDataConnection.SetNewSocket( DataSocket))
            {

                CloseSocket( DataSocket);
                DataSocket = INVALID_SOCKET;

                serr = WSAENOBUFS;
            }
        }

        if ( serr != 0)
        {

            ReplyToUser(this,
                        REPLY_CANNOT_OPEN_CONNECTION,
                        PSZ_CANNOT_OPEN_DATA_CONNECTION);

            IF_DEBUG( COMMANDS )
            {

                DBGPRINTF(( DBG_CONTEXT,
                           "could not create data socket, error %d\n",
                           serr ));
            }
        }
    }


    if( serr == 0 )
    {

        // set this to indicate a transfer might start
        SET_UF( this, TRANSFER );

        //
        // Submit a read command on control socket, since we
        //  have to await possibility of an abort on OOB_INLINE.
        // Can we ignore possibility of an error on read request?
        //

        if ( !ReadCommand())
        {

            DWORD  dwError = GetLastError();

# ifdef CHECK_DBG
            CHAR   szBuffer[100];
            DBG_REQUIRE( _snprintf( szBuffer, sizeof( szBuffer ),
                             " Read while DataTfr failed Error = %u. ", dwError) > 0);
            Print( szBuffer);
# endif // CHECK_DBG

            IF_DEBUG(CLIENT) {

                DBGPRINTF((DBG_CONTEXT,
                           " %08x::ReadCommand() failed. Error = %u\n",
                           this, dwError));
                SetLastError( dwError);
            }
        }

    }

    return ( serr);

}   // USER_DATA::EstablishDataConnection()






BOOL
USER_DATA::DestroyDataConnection( IN DWORD dwError)
/*++
  Tears down the connection to the client's data socket that was created
    using EstablishDataConnection()

  Arguments:
    dwError      = NO_ERROR if data is transferred successfully.
                 Win32 error code otherwise

--*/
{
    UINT   replyCode;
    LPCSTR pszReply;
    BOOL   fTransfer;

    fTransfer = TEST_UF( this, TRANSFER);
    CLEAR_UF( this, TRANSFER );

    CleanupPASVFlags();

    //
    //  Close the data socket.
    //

    DBG_ASSERT( m_sPassiveDataListen == INVALID_SOCKET);


    // Stop Io occuring on data connection
    m_AioDataConnection.StopIo(dwError);

    if ( fTransfer) {

        //
        //  Tell the client we're done with the transfer.
        //

        if ( dwError == NO_ERROR) {

            replyCode = REPLY_TRANSFER_OK;
            pszReply  = PSZ_TRANSFER_COMPLETE;
        } else {

            replyCode = REPLY_TRANSFER_ABORTED;
            pszReply  = PSZ_TRANSFER_ABORTED;
        }

        ReplyToUser(this, replyCode, pszReply);
    }

    return (TRUE);
} // USER_DATA::DestroyDataConnection()


APIERR
USER_DATA::GetFileSize()
{
    LARGE_INTEGER FileSize;
    DWORD         dwError = NO_ERROR;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];

    pOpenFileInfo = m_pOpenFileInfo;


    if ( pOpenFileInfo == NULL) {

        return ( ERROR_FILE_NOT_FOUND);
    }

    if ( !pOpenFileInfo->QuerySize(FileSize)) {

        dwError = GetLastError();

        if( dwError != NO_ERROR ) {

            return ( dwError);
        }
    }

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);

    ReplyToUser( this, REPLY_FILE_STATUS, rgchSize );
    return(dwError);
}

APIERR
USER_DATA::GetFileModTime(LPSYSTEMTIME lpSystemTime)
{
    DWORD         dwError = NO_ERROR;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    FILETIME      FileTime;

    pOpenFileInfo = m_pOpenFileInfo;

    DBG_ASSERT( pOpenFileInfo != NULL );

    if ( !pOpenFileInfo->QueryLastWriteTime(&FileTime)) {

        dwError = GetLastError();
        return ( dwError);
    }

    if (!FileTimeToSystemTime(&FileTime, lpSystemTime)) {

        return GetLastError();
    }

    return NO_ERROR;
}


APIERR
USER_DATA::SendFileToUser( IN LPSTR  pszFileName,
                          IN OUT LPBOOL pfErrorSent)
/*++
  This is a worker function for RETR command of FTP. It will establish
  connection via the ( new ) data socket, then send a file over that
   socket. This uses Async io for transmitting the file.

  Arguments:
     pszFileName    pointer to null-terminated string containing the filename
     pfErrorSent    pointer to boolean flag indicating if an error has
                       been already sent to client.
                    The flag should be used only when return value is error.

  Returns:
     NO_ERROR on success and Win32 error code if error.

  History:
     30-April-1995   MuraliK
--*/
{
    LARGE_INTEGER FileSize;
    DWORD         dwError = NO_ERROR;
    BOOL          fTransmit;
    TS_OPEN_FILE_INFO * pOpenFileInfo;
    CHAR rgchSize[MAX_FILE_SIZE_SPEC];
    CHAR rgchBuffer[MAX_FILE_SIZE_SPEC + 10];
    BOOL fDisconnectSocket = TRUE;


    DBG_ASSERT( pszFileName != NULL && pfErrorSent != NULL);

    *pfErrorSent = FALSE;

    IF_DEBUG( SEND) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " USER_DATA ( %08x)::SendFileToUser( %s,"
                    " pfErrorSent = %08x).\n",
                    this, pszFileName, pfErrorSent));
    }

    //
    //  Get file size.
    //
    pOpenFileInfo = m_pOpenFileInfo;

    if ( pOpenFileInfo == NULL) {

        return ( ERROR_FILE_NOT_FOUND);
    }

    // Get the file size

    if ( !pOpenFileInfo->QuerySize(FileSize)) {

        dwError = GetLastError();

        if( dwError != NO_ERROR ) {

            return ( dwError);
        }
    }

    FileSize.QuadPart -= QueryCurrentOffset();

    IsLargeIntegerToDecimalChar( &FileSize, rgchSize);
    DBG_REQUIRE( _snprintf( rgchBuffer, sizeof( rgchBuffer ), "(%s bytes)", rgchSize) > 0);

    m_pInstance->QueryStatsObj()->IncrTotalFilesSent();

    //
    //  Blast the file from a local file to the user.
    //

    Reference();       // incr ref since async data transfer is started
    SET_UF( this, ASYNC_TRANSFER);

    if (FileSize.QuadPart > MAX_TRANSMIT_FILE_DATA_CHUNK) {
        //
        // TransmitFile does not handle more than 2GB very well, so we'll break it into
        // 2GB chunks
        //

        FileSize.QuadPart = MAX_TRANSMIT_FILE_DATA_CHUNK;
        SET_UF( this, ASYNC_DOWNLOAD);
        fDisconnectSocket = FALSE;
    }

    fTransmit = ( m_AioDataConnection.
                 TransmitFileTs( pOpenFileInfo,
                                 FileSize, // cbToSend ( send entire file)
                                 QueryCurrentOffset(),
                                 fDisconnectSocket)
                 );

    if ( !fTransmit) {

        dwError = GetLastError();

        IF_DEBUG( SEND) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " Unable to transmit file ( %s) (pOpenFile = %p)."
                        " Error = %u\n",
                        pszFileName,
                        pOpenFileInfo,
                        dwError));
        }

        // decr refcount since async tfr failed.
        DBG_REQUIRE( DeReference() > 0);
    }

    //
    //  Disconnect from client.
    //  ( will be done at the call back after completion of IO).
    //

    return ( dwError);

}   // USER_DATA::SendFileToUser()



APIERR
USER_DATA::ReceiveFileFromUser(
    LPSTR       pszFileName,
    LPHANDLE    phFile
    )
/*++

    NAME:       ReceiveFileFromUser

    SYNOPSIS:   Worker function for STOR, STOU, and APPE commands.
                Will establish a connection via the (new) data
                socket, then initiate asynchronous receive a file.

    ENTRY:      pszFileName - The name of the file to receive.

                phFile - An handle to the file being received.
                    This handle is closed before this
                    routine returns.

    Returns:
       Win32 Error codes (or socket errors) as DWORD

    HISTORY:
        KeithMo     16-Mar-1993 Created.
        MuraliK     05-April-1995 Dont free hFile here +
                                    Alloc IoTransBuffer locally
        RobSol      04-September-2001 convert file upload to be asynchronous

--*/
{
    BOOL    fCloseFileOnError = TRUE;
    DWORD   dwError = NO_ERROR;

    DBG_ASSERT( pszFileName != NULL );
    DBG_ASSERT( *phFile != INVALID_HANDLE_VALUE );

    //
    //  Allocate an i/o buffer if not already allocated.
    //

    if (m_AsyncTransferBuff == NULL) {
        m_AsyncTransferBuff = TCP_ALLOC( g_SocketBufferSize );
    }

    if( m_AsyncTransferBuff == NULL ) {

        ReplyToUser(this,
                    REPLY_LOCAL_ERROR,
                    PSZ_INSUFFICIENT_RESOURCES);

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto ReceiveFileFromUser_exit;
    }

    if ( !m_AioDataFile.SetNewFile( *phFile)) {
        ReplyToUser(this,
                    REPLY_LOCAL_ERROR,
                    PSZ_INSUFFICIENT_RESOURCES);

        dwError = GetLastError();
        goto ReceiveFileFromUser_exit;
    }

    //
    // after setting the file handle in m_AioDataFile, it will be closed by DestroyDataConnection
    // so we no longer close it.
    //
    fCloseFileOnError = FALSE;

    Reference();       // incr ref since async data transfer is started
    SET_UF( this, ASYNC_TRANSFER);
    SET_UF( this, ASYNC_UPLOAD);

    //
    // kick of the data pump by initiating read of the first data block.
    //

    if ( !m_AioDataConnection.ReadFile(m_AsyncTransferBuff,
                                       g_SocketBufferSize) ) {

        dwError = GetLastError();

        DBG_ASSERT( dwError != NO_ERROR );

        DBGPRINTF( ( DBG_CONTEXT,
                    " Unable to receive file ( %s)."
                    " Error = %u\n",
                    pszFileName,
                    dwError));

        // decr refcount since async recv failed.
        DBG_REQUIRE( DeReference() > 0);
    }

ReceiveFileFromUser_exit:

    if (dwError != NO_ERROR) {

        //
        // Close file handle before disconnecting from client. This is to serialize
        // requests. If we disconnect first, then an append to this file may follow
        // which may result in a sharing violation of the file (if this write has
        // not been flushed and closed yet).
        //

        if( *phFile != INVALID_HANDLE_VALUE ) {

            if ( fCloseFileOnError ) {

                DBG_REQUIRE( CloseHandle( *phFile ) );
            }

            *phFile = INVALID_HANDLE_VALUE;
        }

        //
        //  Disconnect from client.
        //

        DBG_REQUIRE( DestroyDataConnection( dwError));
        DBG_REQUIRE( CloseFileForReceive( dwError));

    } else {

        QueryInstance()->QueryStatsObj()->IncrTotalFilesReceived();
    }

    return (dwError);
}   // ReceiveFileFromUser()




VOID
USER_DATA::SetPassiveSocket( IN SOCKET sPassive )
/*++

  This function frees up an old Passive socket and resets the
    passive socket to the new Passive socket.

Arguments:
    sPassive - new passive socket to use

--*/
{

    SOCKET sPassiveOld;

    sPassiveOld = (SOCKET) InterlockedExchangePointer ( (PVOID *) &m_sPassiveDataListen,
                                                        (PVOID) sPassive);

    if ( sPassiveOld != INVALID_SOCKET) {

        FacDecrement( FacPassiveDataListens);
        DBG_REQUIRE( CloseSocket( sPassiveOld) == 0);
    }

    if ( sPassive != INVALID_SOCKET) {

        FacIncrement(FacPassiveDataListens);
    }


    return;
} // USER_DATA::SetPassiveSocket()

VOID
USER_DATA::CleanupPassiveSocket( BOOL fTellWatchThread )
/*++

  This function cleans up the resources associated with the current passive socket

Arguments:
   fTellWatchThread - flag indicating whether to tell thread waiting for an event on
   the current passive socket to clean up as well

Returns:
   Nothing
--*/
{
    LockUser();

    if ( m_sPassiveDataListen == INVALID_SOCKET )
    {
        UnlockUser();

        return;
    }

    RemovePASVAcceptEvent( fTellWatchThread );

    DBG_REQUIRE( CloseSocket( m_sPassiveDataListen ) == 0 );

    m_sPassiveDataListen = INVALID_SOCKET;

    UnlockUser();
}


BOOL
USER_DATA::SetCommand( IN LPSTR pszCmd )
/*++

Routine Description:
     Used to set pointer to FTP cmd

Arguments :
     pszArgs - pointer to command to execute

Returns :
     BOOL indicating success/failure to set values
--*/
{
    BOOL fReturn = TRUE;

    if ( !pszCmd )
    {
        return FALSE;
    }

    //
    // Free any previous allocations
    //
    if ( m_pszCmd )
    {
        TCP_FREE( m_pszCmd );
        m_pszCmd = NULL;
    }

    if ( m_pszCmd = ( LPSTR ) TCP_ALLOC( strlen(pszCmd) +  1 ) )
    {
        strcpy( m_pszCmd, pszCmd );
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to allocate memory for command args !\n"));

        fReturn = FALSE;
    }

    return fReturn;
}

/************************************************************
 *  Auxiliary Functions
 ************************************************************/


VOID
ProcessUserAsyncIoCompletion(IN LPVOID pContext,
                             IN DWORD  cbIo,
                             IN DWORD  dwError,
                             IN LPASYNC_IO_CONNECTION pAioConn,
                             IN BOOL   fTimedOut
                             )
/*++
  This function processes the Async Io completion ( invoked as
    a callback from the ASYNC_IO_CONNECTION object).

  Arguments:
     pContext      pointer to the context information ( UserData object).
     cbIo          count of bytes transferred in Io
     dwError       DWORD containing the error code resulting from last tfr.
     pAioConn      pointer to AsyncIo connection object.

  Returns:
     None
--*/
{

    LPUSER_DATA   pUserData = (LPUSER_DATA ) pContext;

    DBG_ASSERT( pUserData != NULL);
    DBG_ASSERT( pAioConn  != NULL);

    IF_SPECIAL_DEBUG( CRITICAL_PATH) {

        CHAR    rgchBuffer[100];

        DBG_REQUIRE( _snprintf( rgchBuffer, sizeof( rgchBuffer ),
                  " ProcessAio( cb=%u, err=%u, Aio=%p). ",
                  cbIo, dwError, pAioConn) > 0);

        pUserData->Print( rgchBuffer);
    }

    DBG_REQUIRE( pUserData->Reference()  > 0);

# if DBG

    if ( !IS_VALID_USER_DATA( pUserData)) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Encountering an invalid user data ( %08x)\n",
                    pUserData));
        pUserData->Print();
    }
# endif // DBG

    DBG_ASSERT( IS_VALID_USER_DATA( pUserData ) );

    pUserData->ProcessAsyncIoCompletion( cbIo, dwError, pAioConn, fTimedOut);

    DereferenceUserDataAndKill(pUserData);

    return;

} // ProcessUserAsyncIoCompletion()


VOID
USER_DATA::RemovePASVAcceptEvent( BOOL fTellWatchThread )
/*++

Routine Description:

    Routine that cleans up the state associated with a PASV accept event

Arguments:

    fTellWatchThread - BOOL indicating whether or not to inform the thread waiting on
    the event to stop waiting on it

Returns:

    Nothing
--*/
{
    DBG_ASSERT( m_sPassiveDataListen != INVALID_SOCKET );

    if ( m_hPASVAcceptEvent == NULL )
    {
        return;
    }

    //
    // Remove all network notifications for the PASV socket
    //
    if ( WSAEventSelect( m_sPassiveDataListen,
                         m_hPASVAcceptEvent,
                         0 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSAEventSelect on socket %d failed : 0x%x\n",
                   m_sPassiveDataListen, WSAGetLastError()));
    }

    //
    // Stop watching for the event
    //
    if ( fTellWatchThread )
    {
        RemoveAcceptEvent( m_hPASVAcceptEvent,
                           this );
    }

    WSACloseEvent( m_hPASVAcceptEvent );

    m_hPASVAcceptEvent = NULL;
}

SOCKERR
USER_DATA::AddPASVAcceptEvent( BOOL *pfAcceptableSocket )
/*++

Routine Description:

    Routine that sets up the event to signal that the PASV socket is an accept()'able
    state

Arguments:

    pfAcceptableSocket - BOOL set to TRUE if socket can be accept()'ed at once, FALSE if
    NOT

Returns:

    Error code indicating success/failure

--*/
{
    DWORD dwRet = 0;
    SOCKERR serr = 0;
    BOOL fRegistered = FALSE;

    *pfAcceptableSocket = FALSE;

    if ( ( m_hPASVAcceptEvent = WSACreateEvent() ) == WSA_INVALID_EVENT )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to create event to wait for accept() : 0x%x\n",
                   WSAGetLastError()));

        return WSAGetLastError();
    }

    //
    // specify that we want to be alerted when the socket is accept()'able =)
    //
    if ( WSAEventSelect( m_sPassiveDataListen,
                         m_hPASVAcceptEvent,
                         FD_ACCEPT ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WSAEventSelect failed : 0x%x\n",
                   WSAGetLastError()));

        serr = WSAGetLastError();

        goto exit;
    }
    else
    {
        fRegistered = TRUE;
    }

    //
    // In order to deal as quickly as possible with legitimate clients and avoid rejecting them
    // because the queue is full, we'll wait for 0.1 sec to see whether the socket becomes
    // accept()'able before queueing it
    //
    dwRet = WSAWaitForMultipleEvents( 1,
                                      &m_hPASVAcceptEvent,
                                      FALSE,
                                      100,
                                      FALSE );

    switch ( dwRet )
    {
    case WSA_WAIT_EVENT_0:
        //
        // we can call accept() at once on the socket, no need to muck around with waiting
        // for it
        //

        *pfAcceptableSocket = TRUE;

        break;

    case WSA_WAIT_TIMEOUT:
        //
        // Need to queue the socket
        //
        serr = AddAcceptEvent( m_hPASVAcceptEvent,
                               this );

        break;

    default:
        serr = WSAGetLastError();

        break;
    }

exit:

    //
    // clean up if something failed or the socket is acceptible
    //
    if ( (serr != 0) || *pfAcceptableSocket )
    {
        if ( m_hPASVAcceptEvent )
        {
            if ( fRegistered )
            {
                WSAEventSelect( m_sPassiveDataListen,
                                m_hPASVAcceptEvent,
                                0 );
            }

            WSACloseEvent( m_hPASVAcceptEvent );

            m_hPASVAcceptEvent = NULL;
        }
    }

    return serr;
}




VOID
DereferenceUserDataAndKill(IN OUT LPUSER_DATA pUserData)
/*++
  This function dereferences User data and kills the UserData object if the
    reference count hits 0. Before killing the user data, it also removes
    the connection from the list of active connections.

--*/
{

    FTP_SERVER_INSTANCE * pinstance;

    IF_SPECIAL_DEBUG( CRITICAL_PATH) {

        pUserData->Print( " Deref ");
    }

    //
    // We must capture the instance pointer from the user data, as
    // USER_DATA::RemoveConnection() will set the pointer to NULL.
    // We must also reference the instance before locking it, as
    // removing the last user from the instance will cause the instance
    // to be destroyed. We'll defer this destruction until we're done
    // with the instance.
    //

    pinstance = pUserData->QueryInstance();

    pinstance->Reference();
    pinstance->LockConnectionsList();

    if ( !pUserData->DeReference())  {

        //
        // Deletion of the object USER_DATA is required.
        //

        IF_DEBUG( USER_DATABASE) {

            DBGPRINTF( ( DBG_CONTEXT,
                        " UserData( %08x) is being deleted.\n",
                        pUserData));
        }

        pinstance->UnlockConnectionsList();

        pUserData->Cleanup();

        DBG_ASSERT( pUserData->QueryControlSocket() == INVALID_SOCKET );
        DBG_ASSERT( pUserData->QueryDataSocket() == INVALID_SOCKET );

        pinstance->RemoveConnection( pUserData);
    }
    else {

        pinstance->UnlockConnectionsList();
    }

    pinstance->Dereference();

} // DereferenceUserDataAndKill()




BOOL
PathAccessCheck(IN ACCESS_TYPE _access,
                IN DWORD       dwVrootAccessMask,
                IN BOOL        fUserRead,
                IN BOOL        fUserWrite
                )
/*++
  This function determines if the required privilege to access the specified
   virtual root with a given access mask exists.

  Arguments:

    access     - specifies type of acces desired.
    dwVrootAccessMask - DWORD containing the access mask for the virtual root.
    fUserRead  - user's permission to read  (general)
    fUserWrite - user's permission to write (general)

  Returns:
    BOOL  - TRUE if access is to be granted, else FALSE.

  History:
    MuraliK   20-Sept-1995

--*/
{
    BOOL        fAccessGranted = FALSE;

    DBG_ASSERT( IS_VALID_ACCESS_TYPE( _access ) );

    //
    //  Perform the actual access check.
    //

    switch( _access ) {

      case AccessTypeRead :

        fAccessGranted = (fUserRead &&
                          ((dwVrootAccessMask & VROOT_MASK_READ)
                           == VROOT_MASK_READ)
                          );
        break;

    case AccessTypeWrite :
    case AccessTypeCreate :
    case AccessTypeDelete :

        fAccessGranted = (fUserWrite &&
                          ((dwVrootAccessMask & VROOT_MASK_WRITE)
                           == VROOT_MASK_WRITE)
                          );
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                   "PathAccessCheck - invalid access type %d\n",
                   _access ));
        DBG_ASSERT( FALSE );
        break;
    }

    if (!fAccessGranted) {

        SetLastError( ERROR_ACCESS_DENIED);
    }

    return ( fAccessGranted);
} // PathAccessCheck()


VOID SignalAcceptableSocket( LPUSER_DATA pUserData )
/*++

      Function that restarts processing the original command when a PASV data socket becomes
      accept()'able [ie the client has made the connection]

  Arguments:
      pUserData - USER_DATA context attached to socket

  Returns:
     Nothing
--*/
{
    PATQ_CONTEXT pAtqContext = pUserData->QueryControlAio()->QueryAtqContext();

    //
    // Stop waiting for events on this socket
    //
    pUserData->RemovePASVAcceptEvent( FALSE );

    pUserData->SetInFakeIOCompletion( TRUE );

    //
    // do a scary thing - fake an IO completion, to trigger re-processing of the FTP command
    //
    if ( !AtqPostCompletionStatus( pAtqContext,
                                   strlen( pUserData->QueryCmdString() ) + 1 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to post fake completion status to deal with PASV event : 0x%x\n",
                   GetLastError()));

        return;
    }
}


VOID CleanupTimedOutSocketContext( LPUSER_DATA pUserData )
/*++

      Function used to do cleanup when timeout for waiting for a PASV connection expires

  Arguments:
      pUserData - context pointer

  Returns:
     Nothing
--*/
{
    DBG_ASSERT( pUserData );

    pUserData->LockUser();

    pUserData->CleanupPassiveSocket( FALSE );

    CLEAR_UF( pUserData, PASSIVE );

    pUserData->SetHavePASVConn( FALSE );

    pUserData->SetWaitingForPASVConn( FALSE );

    ReplyToUser( pUserData,
                 REPLY_CANNOT_OPEN_CONNECTION,
                 PSZ_CANNOT_OPEN_DATA_CONNECTION );
    //
    // Remove our reference to this USER_DATA object
    //
    pUserData->DeReference();

    pUserData->UnlockUser();
}

/*******************************************************************

    NAME:       FtpMetaDataFree

    SYNOPSIS:   Frees a formatted meta data object when it's not in use.

    ENTRY:      pObject - Pointer to the meta data object.

    RETURNS:


    NOTES:


********************************************************************/

VOID
FtpMetaDataFree(
    PVOID       pObject
)
{
    PFTP_METADATA        pMD;

    pMD = (PFTP_METADATA)pObject;

    delete pMD;
}


BOOL
FTP_METADATA::HandlePrivateProperty(
    LPSTR                   pszURL,
    PIIS_SERVER_INSTANCE    pInstance,
    METADATA_GETALL_INTERNAL_RECORD  *pMDRecord,
    LPVOID                  pDataPointer,
    BUFFER                  *pBuffer,
    DWORD                   *pdwBytesUsed,
    PMETADATA_ERROR_INFO    pMDErrorInfo
    )
/*++

Routine Description:

    Handle metabase properties private to FTP service

Arguments:

    pszURL - URL of the requested object
    pInstance - FTP server instance
    pMDRecord - metadata record
    pDataPointer - pointer to metabase data
    pBuffer - Buffer available for storage space
    pdwBytesUsed - Pointer to bytes used in *pBuffer

Returns:

    BOOL  - TRUE success ( or not handled ), otherwise FALSE.

--*/
{
    return TRUE;
}

BOOL
FTP_METADATA::FinishPrivateProperties(
    BUFFER                  *pBuffer,
    DWORD                   dwBytesUsed,
    BOOL                    bSucceeded
    )
/*++

Routine Description:

    Handles completion of reading metabase properties private to FTP.

Arguments:

    pBuffer - Buffer previously used for storage space
    dwBytesUsed - bytes used in *pBuffer

Returns:

    BOOL  - TRUE success ( or not handled ), otherwise FALSE.

--*/
{
    return TRUE;
}


BOOL
USER_DATA::LookupVirtualRoot(
    IN  const CHAR * pszURL,
    OUT CHAR *       pszPath,
    OUT DWORD *      pccbDirRoot,
    OUT DWORD *      pdwAccessMask
    )
/*++

Routine Description:

    Looks up the virtual root to find the physical drive mapping.  If an
    Accept-Language header was sent by the client, we look for a virtual
    root prefixed by the language tag

Arguments:

    pstrPath - Receives physical drive path
    pszURL - URL to look for
    pccbDirRoot - On entry, size of pstrPath buffer in bytes. On return,
                  Number of characters in the found physical path (incl. \0)
    pdwMask - Access mask for the specified URL

  Returns:
    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
    PFTP_METADATA       pMD;
    DWORD               dwDataSetNumber;
    PVOID               pCacheInfo;
    MB                  mb( (IMDCOM*) g_pInetSvc->QueryMDObject() );
    STACK_STR(          strFullPath, MAX_PATH );
    METADATA_ERROR_INFO MDErrorInfo;
    BOOL                fOk;
    DWORD               dwError = NO_ERROR;



    if ( m_pMetaData != NULL )
    {
        TsFreeMetaData( m_pMetaData->QueryCacheInfo() );
        m_pMetaData = NULL;
    }

    // First read the data set number, and see if we already have it
    // cached.  We don't do a full open in this case.

    if ( !strFullPath.Copy( m_pInstance->QueryMDVRPath() ) ||
         !strFullPath.Append( ( *pszURL == '/' ) ? pszURL + 1 : pszURL ) )
    {
        goto LookupVirtualRoot_Error;
    }

    if (!mb.GetDataSetNumber( strFullPath.QueryStr(),
                              &dwDataSetNumber ))
    {
        goto LookupVirtualRoot_Error;
    }

    // See if we can find a matching data set already formatted.
    pMD = (PFTP_METADATA)TsFindMetaData(dwDataSetNumber, METACACHE_FTP_SERVER_ID);

    if (pMD == NULL)
    {
        pMD = new FTP_METADATA;

        if (pMD == NULL)
        {
            goto LookupVirtualRoot_Error;
        }

        if ( !pMD->ReadMetaData( m_pInstance,
                                 &mb,
                                 (LPSTR)pszURL,
                                 &MDErrorInfo) )
        {
            delete pMD;
            goto LookupVirtualRoot_Error;
        }

        // We were succesfull, so try and add this metadata. There is a race
        // condition where someone else could have added it while we were
        // formatting. This is OK - we'll have two cached, but they should be
        // consistent, and one of them will eventually time out. We could have
        // AddMetaData check for this, and free the new one while returning a
        // pointer to the old one if it finds one, but that isn't worthwhile
        // now.

        pCacheInfo = TsAddMetaData(pMD, FtpMetaDataFree,
                            dwDataSetNumber, METACACHE_FTP_SERVER_ID);

    }

    m_pMetaData = pMD;

    if ( m_pMetaData->QueryVrError() )
    {
        dwError =  m_pMetaData->QueryVrError();
        goto LookupVirtualRoot_Error;
    }

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //

    //
    // for URLs containing a Virtual Root, as well as MD_USER_ISOLATION_NONE mode, and StandAlone
    // mode, concatenate the VR physical path and the URL to form a full physical path. In
    // StandAlone where the path does not contain a VR alias, contatenate the physical root path,
    // the user home directory, and the URL. In MD_USER_ISOLATION_AD mode (with no VR prefix),
    // concatenate the user physical home directory (in the USER_DATA objcet) and the relative
    // path.
    //

    if (( m_pInstance->QueryIsolationMode() == MD_USER_ISOLATION_AD ) &&
        ( m_pMetaData->QueryVrLevel() == 0 )) {
        //
        // we get here in AD isolation mode, where the VR has no path mapping
        //

        if ( !strFullPath.Copy( QueryRootDirectory().QueryStr(),
                                QueryRootDirectory().QueryCCH() ) ||
             !strFullPath.Append( pszURL ) )
        {
            goto LookupVirtualRoot_Error;
        }

        FlipSlashes( strFullPath.QueryStr(), FLIP_SLASHES_TO_DOS );

        fOk = TRUE;
    } else {
        //
        // for stand-alone UIM (no VROOT), we use the homeDirectory as a relative path prefix.
        // no-isolation and all VROOTs use the VR lookup path.
        //

        PCSTR pszHomeDir = NULL;

        if ((m_pMetaData->QueryVrLevel() == 0) &&
            (m_pInstance->QueryIsolationMode() == MD_USER_ISOLATION_BASIC) ) {
            pszHomeDir = m_strRootDir.QueryStr();
        }

        fOk = pMD->BuildPhysicalPathWithAltRoot( (LPSTR)pszURL, &strFullPath, pszHomeDir );
    }

    if ( fOk ) {
        if ( *pccbDirRoot > strFullPath.QueryCCH() )
        {
            memcpy( pszPath, strFullPath.QueryStr(), strFullPath.QueryCCH()+1 );
            *pccbDirRoot = strFullPath.QueryCCH()+1;
            if ( pdwAccessMask )
            {
                *pdwAccessMask = m_pMetaData->QueryAccessPerms();
            }

            return TRUE;
        }
    }

LookupVirtualRoot_Error:

    if (dwError == NO_ERROR) {
        //
        // best error message to send to client
        //
        dwError = ERROR_FILE_NOT_FOUND;
    }

    SetLastError( dwError );

    return FALSE;
}


BOOL
USER_DATA::BindInstanceAccessCheck(
    )
/*++

Routine Description:

    Bind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    BOOL  - TRUE if success, otherwise FALSE.

--*/
{
    if ( m_rfAccessCheck.CopyFrom( m_pInstance->QueryMetaDataRefHandler() ) )
    {
        m_acAccessCheck.BindCheckList( (LPBYTE)m_rfAccessCheck.GetPtr(), m_rfAccessCheck.GetSize() );
        return TRUE;
    }
    return FALSE;
}


VOID
USER_DATA::UnbindInstanceAccessCheck()
/*++

Routine Description:

    Unbind IP/DNS access check for this request to instance data

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_acAccessCheck.UnbindCheckList();
    m_rfAccessCheck.Reset( (IMDCOM*) g_pInetSvc->QueryMDObject() );
}


BOOL
USER_DATA::IsFileNameShort( IN LPSTR pszFile)
/*++

  Check file name beeing short or not.

  Arguments:
    pszFile   pointer to null-terminated string containing the file name

  Returns:
    TRUE if filename is short.
--*/
{
    APIERR err;
    CHAR   szCanonPath[MAX_PATH+1];
    DWORD  cbSize = sizeof(szCanonPath);
    BOOL   fShort;
    BOOL   fRet = FALSE;

    DBG_ASSERT( pszFile != NULL );

    //
    // Close any file we might have open now
    // N.B. There shouldn't be an open file; we're just
    // being careful here.
    //

    if (m_pOpenFileInfo) {
        DBGPRINTF(( DBG_CONTEXT,
            "WARNING!! Closing [%08x], before opening %s\n",
            pszFile
            ));
        DBG_REQUIRE( CloseFileForSend() );
    }

    //
    // Open the requested file
    //
    err = VirtualCanonicalize(szCanonPath,
                              &cbSize,
                              pszFile,
                              AccessTypeRead);

    if( err == NO_ERROR )
    {

        if ( strchr( szCanonPath, '~' ))
        {

            err = CheckIfShortFileName( (UCHAR *) szCanonPath, TsTokenToImpHandle( QueryUserToken()), &fShort );

            if ( !err  && fShort)
            {
                DBGPRINTF(( DBG_CONTEXT,
                    "Short filename being rejected \"%s\"\n",
                    szCanonPath ));
                fRet = TRUE;

            }

        }
    }



    return fRet;
} // USER_DATA::IsFileNameShort()



DWORD
USER_DATA::CheckIfShortFileName(
    IN  CONST UCHAR * pszPath,
    IN  HANDLE        hImpersonation,
    OUT BOOL *        pfShort
    )
/*++
    Description:

        This function takes a suspected NT/Win95 short filename and checks if there's
        an equivalent long filename.  For example, c:\foobar\ABCDEF~1.ABC is the same
        as c:\foobar\abcdefghijklmnop.abc.

        NOTE: This function should be called unimpersonated - the FindFirstFile() must
        be called in the system context since most systems have traverse checking turned
        off - except for the UNC case where we must be impersonated to get network access.

    Arguments:

        pszPath - Path to check
        hImpersonation - Impersonation handle if this is a UNC path - can be NULL if not UNC
        pfShort - Set to TRUE if an equivalent long filename is found

    Returns:

        Win32 error on failure
--*/
{
    DWORD              err = NO_ERROR;
    WIN32_FIND_DATA    FindData;
    UCHAR *            psz;
    BOOL               fUNC;

    psz      = _mbschr( (UCHAR *) pszPath, '~' );
    *pfShort = FALSE;
    fUNC     = (*pszPath == '\\');

    //
    //  Loop for multiple tildas - watch for a # after the tilda
    //

    while ( psz++ )
    {
        if ( *psz >= '0' && *psz <= '9' )
        {
            UCHAR achTmp[MAX_PATH];
            UCHAR * pchEndSeg;
            UCHAR * pchBeginSeg;
            HANDLE  hFind;

            //
            //  Isolate the path up to the segment with the
            //  '~' and do the FindFirst with that path
            //

            pchEndSeg = _mbschr( psz, '\\' );

            if ( !pchEndSeg )
            {
                pchEndSeg = psz + _mbslen( psz );
            }

            //
            //  If the string is beyond MAX_PATH then we allow it through
            //

            if ( ((INT) (pchEndSeg - pszPath)) >= sizeof( achTmp ))
            {
                return NO_ERROR;
            }

            memcpy( achTmp, pszPath, (INT) (pchEndSeg - pszPath) );
            achTmp[pchEndSeg - pszPath] = '\0';

            if ( fUNC && hImpersonation )
            {
                if ( !ImpersonateLoggedOnUser( hImpersonation ))
                {
                    return GetLastError();
                }
            }

            hFind = FindFirstFile( (CHAR *) achTmp, &FindData );

            if ( fUNC && hImpersonation )
            {
                RevertToSelf();
            }

            if ( hFind == INVALID_HANDLE_VALUE )
            {
                err = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                            "FindFirst failed!! - \"%s\", error %d\n",
                            achTmp,
                            GetLastError() ));

                //
                //  If the FindFirstFile() fails to find the file then return
                //  success - the path doesn't appear to be a valid path which
                //  is ok.
                //

                if ( err == ERROR_FILE_NOT_FOUND ||
                     err == ERROR_PATH_NOT_FOUND )
                {
                    return NO_ERROR;
                }

                return err;
            }

            DBG_REQUIRE( FindClose( hFind ));

            //
            //  Isolate the last segment of the string which should be
            //  the potential short name equivalency
            //

            pchBeginSeg = _mbsrchr( achTmp, '\\' );
            DBG_ASSERT( pchBeginSeg );
            pchBeginSeg++;

            //
            //  If the last segment doesn't match the long name then this is
            //  the short name version of the path
            //

            if ( _mbsicmp( (UCHAR *) FindData.cFileName, pchBeginSeg ))
            {
                *pfShort = TRUE;
                return NO_ERROR;
            }
        }

        psz = _mbschr( psz, '~' );
    }

    return err;
}

/******************************* End Of File *************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\virtual.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    virtual.cxx

    This module contains the virtual I/O package.

    Under Win32, the "current directory" is an attribute of a process,
    not a thread.  This causes some grief for the FTPD service, since
    it is impersonating users on the server side.  The users must
    "think" they can change current directory at will.  We'll provide
    this behaviour in this package.

    Functions exported by this module:

        VirtualCreateFile
        VirtualCreateUniqueFile
        Virtual_fopen

        VirtualDeleteFile
        VirtualRenameFile
        VirtualChDir
        VirtualRmDir
        VirtualMkDir


    FILE HISTORY:
        KeithMo     09-Mar-1993 Created.

        MuraliK     28-Mar-1995 Enabled FILE_FLAG_OVERLAPPED in OpenFile()
        MuraliK     28-Apr-1995 modified to use new canonicalization
                    11-May-1995 made parameters to be const unless otherwise
                                required.
                    12-May-1995 eliminated the old log file access

*/


#include "ftpdp.hxx"


//
//  Private prototypes.
//

VOID
VirtualpSanitizePath(
    CHAR * pszPath
    );



//
//  Public functions.
//



/*******************************************************************

    NAME:       VirtualCreateFile

    SYNOPSIS:   Creates a new (or overwrites an existing) file.
                Also handles moving the file pointer and truncating the
                file in the case of a REST command sequence.

    ENTRY:      pUserData - The user initiating the request.

                phFile - Will receive the file handle.  Will be
                    INVALID_HANDLE_VALUE if an error occurs.

                pszFile - The name of the new file.

                fAppend - If TRUE, and pszFile already exists, then
                    append to the existing file.  Otherwise, create
                    a new file.  Note that FALSE will ALWAYS create
                    a new file, potentially overwriting an existing
                    file.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
APIERR
VirtualCreateFile(
    USER_DATA * pUserData,
    HANDLE    * phFile,
    LPSTR       pszFile,
    BOOL        fAppend
    )
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    APIERR err;
    CHAR   szCanonPath[MAX_PATH+1];
    DWORD  cbSize = sizeof(szCanonPath);
    LARGE_INTEGER  liOffset, liZero;
    CHAR   szVirtualPath[MAX_PATH+1];
    DWORD  ccbVirtualPath = sizeof(szVirtualPath);

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( phFile != NULL );
    DBG_ASSERT( pszFile != NULL );

    liZero.QuadPart = 0;
    liOffset.QuadPart = pUserData->QueryCurrentOffset();

    // We'll want to do pretty much the same thing whether we're
    // actually appending or just starting at an offset due to a REST
    // command, so combine them here.

    fAppend = fAppend || (liOffset.QuadPart != 0);

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         AccessTypeCreate,
                                         NULL,
                                         szVirtualPath,
                                         &ccbVirtualPath);

    if( err == NO_ERROR ) {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "creating %s\n", szCanonPath ));
        }

        // store the virtual file name for logging
        pUserData->SetVirtualFileName( szVirtualPath );

        if ( pUserData->ImpersonateUser()) {

            WCHAR  awchPath[MAX_PATH+8+1];

            if (TsMakeWidePath( szCanonPath, awchPath, MAX_PATH+8+1)) {

                hFile = CreateFileW( awchPath,
                                   GENERIC_WRITE,
                                   FILE_SHARE_READ,
                                   NULL,
                                   fAppend ? OPEN_ALWAYS : CREATE_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                   NULL );
            }

            //
            //  Disallow usage of short names
            //

            pUserData->RevertToSelf();

            if ( hFile != INVALID_HANDLE_VALUE )
            {
                if ( GetFileType( hFile ) != FILE_TYPE_DISK )
                {
                    DBG_REQUIRE( CloseHandle( hFile ) );
                    SetLastError( ERROR_ACCESS_DENIED );
                    hFile = INVALID_HANDLE_VALUE;
                }
                else if ( strchr( szCanonPath, '~' )) {

                    BOOL  fShort;
                    DWORD err;

                    err = CheckIfShortFileName( (UCHAR *) szCanonPath,
                                                pUserData->QueryImpersonationToken(),
                                                &fShort );

                    if ( !err && fShort ) {

                        err = ERROR_FILE_NOT_FOUND;
                    }

                    if ( err ) {

                        DBG_REQUIRE( CloseHandle( hFile ));
                        hFile = INVALID_HANDLE_VALUE;
                        SetLastError( err );
                    }
                }
            }
        }

        if( hFile == INVALID_HANDLE_VALUE ) {

            err = GetLastError();
        }

        if( fAppend && ( err == NO_ERROR ) ) {

            if (liOffset.QuadPart == 0) {
                // This is a real append, not a restart sequence.
                // set Offset to the file size
                if( !SetFilePointerEx( hFile,
                                    liZero,
                                    &liOffset,
                                    FILE_END ) ) {

                    err = GetLastError();
                }
            } else {

                // We're in part of a restart sequence. Set the file pointer
                // to the offset, and truncate the file there.

                if ( !SetFilePointerEx( hFile,
                                    liOffset,
                                    NULL,
                                    FILE_BEGIN)
                            ||
                     !SetEndOfFile( hFile) ) {

                    err = GetLastError();
                }

            }

            if (err != NO_ERROR ) {

                CloseHandle( hFile );
                hFile = INVALID_HANDLE_VALUE;

            }
        }
    }

    if ( err != NO_ERROR) {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot create %s, error %lu\n",
                        szCanonPath,
                        err ));
        }
    }

    if ( err == NO_ERROR) {

        pUserData->SetCurrentOffset( liOffset.QuadPart );
    }

    *phFile = hFile;

    return err;

}   // VirtualCreateFile


/*******************************************************************

    NAME:       VirtualCreateUniqueFile

    SYNOPSIS:   Creates a new unique (temporary) file in the current
                    virtual directory.

    ENTRY:      pUserData - The user initiating the request.

                phFile - Will receive the file handle.  Will be
                    INVALID_HANDLE_VALUE if an error occurs.

                pszTmpFile - Will receive the name of the temporary
                    file.  This buffer MUST be at least MAX_PATH
                    characters long.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     16-Mar-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
APIERR
VirtualCreateUniqueFile(
    USER_DATA * pUserData,
    HANDLE    * phFile,
    LPSTR       pszTmpFile
    )
{
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    APIERR      err   = NO_ERROR;
    CHAR        szCanon[MAX_PATH+1];
    DWORD       cbSize = sizeof(szCanon);
    CHAR        szVirtualPath[MAX_PATH+1];
    DWORD       ccbVirtualPath = sizeof(szVirtualPath);

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( phFile != NULL );
    DBG_ASSERT( pszTmpFile != NULL );

    //
    // Obtain the virtual to real path conversion.
    //

    err = pUserData->VirtualCanonicalize(szCanon,
                                         &cbSize,
                                         "", // current directory
                                         AccessTypeCreate,
                                         NULL,
                                         szVirtualPath,
                                         &ccbVirtualPath);

    if( err == NO_ERROR ) {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                      "creating unique file %s\n", pszTmpFile ));
        }

        // store the virtual file name for logging
        pUserData->SetVirtualFileName( szVirtualPath );

        if ( pUserData->ImpersonateUser()) {

            if ( GetTempFileName(szCanon,
                                 "FTPD",
                                 0, pszTmpFile ) != 0
                ) {

                WCHAR  awchPath[MAX_PATH+8+1];

                if (TsMakeWidePath( pszTmpFile, awchPath, MAX_PATH+8+1)) {

                    hFile = CreateFileW( awchPath,
                                       GENERIC_WRITE,
                                       FILE_SHARE_READ,
                                       NULL,
                                       CREATE_ALWAYS,
                                       FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED,
                                       NULL );
                }
            }

            pUserData->RevertToSelf();
        }

        if( hFile == INVALID_HANDLE_VALUE ) {

            err = GetLastError();
        }
    }

    if( err != NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot create unique file, error %lu\n",
                        err ));
        }
    }

    if ( err == NO_ERROR) {

        pUserData->SetCurrentOffset( 0 );
    }

    *phFile = hFile;

    return err;

}   // VirtualCreateUniqueFile()



/*******************************************************************

    NAME:       Virtual_fopen

    SYNOPSIS:   Opens an file stream.

    ENTRY:      pUserData - The user initiating the request.

                pszFile - The name of the file to open.

                pszMode - The type of access required.

    RETURNS:    FILE * - The open file stream, NULL if file cannot
                    be opened.

    NOTES:      Since this is only used for accessing the ~FTPSVC~.CKM
                    annotation files, we don't log file accesses here.

    HISTORY:
        KeithMo     07-May-1993 Created.
        MuraliK     28-Apr-1995 modified to use new canonicalization

********************************************************************/
FILE *
Virtual_fopen(
    USER_DATA * pUserData,
    LPSTR       pszFile,
    LPSTR       pszMode
    )
{
    FILE   * pfile = NULL;
    APIERR   err;
    CHAR     szCanonPath[MAX_PATH+1];
    DWORD    cbSize = sizeof(szCanonPath);

    DBG_ASSERT( pUserData != NULL );
    DBG_ASSERT( pszFile != NULL );
    DBG_ASSERT( pszMode != NULL );

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         *pszMode == 'r'
                                         ? AccessTypeRead
                                         : AccessTypeWrite );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "opening %s\n", szCanonPath ));
        }

        if ( pUserData->ImpersonateUser()) {

            pfile = fopen( szCanonPath, pszMode );

            pUserData->RevertToSelf();
        }

        if( pfile == NULL )
        {
            err = ERROR_FILE_NOT_FOUND; // best guess
        }
    }

    IF_DEBUG( VIRTUAL_IO )
    {
        if( err != NO_ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot open %s, error %lu\n",
                        pszFile,
                        err ));
        }
    }

    return pfile;

}   // Virtual_fopen




/*******************************************************************

    NAME:       VirtualDeleteFile

    SYNOPSIS:   Deletes an existing file.

    ENTRY:      pUserData - The user initiating the request.

                pszFile - The name of the file.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualDeleteFile(
    USER_DATA * pUserData,
    LPSTR       pszFile
    )
{
    APIERR err;
    CHAR   szCanonPath[MAX_PATH+1];
    DWORD  cbSize = sizeof(szCanonPath);
    DWORD  dwAccessMask = 0;

    DBG_ASSERT( pUserData != NULL );

    //
    //  We'll canonicalize the path, asking for *read* access.  If
    //  the path canonicalizes correctly, we'll then try to open the
    //  file to ensure it exists.  Only then will we check for delete
    //  access to the path.  This mumbo-jumbo is necessary to get the
    //  proper error codes if someone trys to delete a nonexistent
    //  file on a read-only volume.
    //

    err = pUserData->VirtualCanonicalize(szCanonPath,
                                         &cbSize,
                                         pszFile,
                                         AccessTypeRead,
                                         &dwAccessMask);

    if( err == NO_ERROR )
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;

        if ( pUserData->ImpersonateUser()) {

            WCHAR  awchPath[MAX_PATH+8+1];

            if (TsMakeWidePath( szCanonPath, awchPath, MAX_PATH+8+1)) {

                hFile = CreateFileW( awchPath,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   NULL,
                                   OPEN_EXISTING,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL );
            }

            pUserData->RevertToSelf();
        }

        if( hFile == INVALID_HANDLE_VALUE )
        {
            err = GetLastError();
        }
        else
        {
            //
            //  The file DOES exist.  Close the handle, then check
            //  to ensure we really have delete access.
            //

            CloseHandle( hFile );

            if( !PathAccessCheck( AccessTypeDelete,
                                 dwAccessMask,
                                 TEST_UF(pUserData, READ_ACCESS),
                                 TEST_UF(pUserData, WRITE_ACCESS)
                                 )
               ) {

                err = ERROR_ACCESS_DENIED;
            }
        }
    }

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "deleting %s\n", szCanonPath ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !DeleteFile( szCanonPath ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO ) {

                    DBGPRINTF(( DBG_CONTEXT,
                               "cannot delete %s, error %lu\n",
                               szCanonPath,
                               err ));
                }
            }

            pUserData->RevertToSelf();
        } else {

            err = GetLastError();
        }
    }
    else
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                        pUserData->QueryCurrentDirectory().QueryStr(),
                        pszFile,
                        err ));
        }
    }

    return err;

}   // VirtualDeleteFile()



/*******************************************************************

    NAME:       VirtualRenameFile

    SYNOPSIS:   Renames an existing file or directory.

    ENTRY:      pUserData - The user initiating the request.

                pszExisting - The name of an existing file or directory.

                pszNew - The new name for the file or directory.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     10-Mar-1993 Created.

********************************************************************/
APIERR
VirtualRenameFile(
    USER_DATA * pUserData,
    LPSTR       pszExisting,
    LPSTR       pszNew
    )
{
    APIERR err;
    CHAR   szCanonExisting[MAX_PATH+1];
    DWORD  cbSize = sizeof(szCanonExisting);

    DBG_ASSERT( pUserData != NULL );

    err = pUserData->VirtualCanonicalize(szCanonExisting,
                                         &cbSize,
                                         pszExisting,
                                         AccessTypeDelete );

    if( err == NO_ERROR ) {

        CHAR   szCanonNew[MAX_PATH+1];
        cbSize = sizeof(szCanonNew);

        err = pUserData->VirtualCanonicalize(szCanonNew,
                                             &cbSize,
                                             pszNew,
                                             AccessTypeCreate );

        if( err == NO_ERROR ) {

            IF_DEBUG( VIRTUAL_IO ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "renaming %s to %s\n",
                           szCanonExisting,
                           szCanonNew ));
            }

            if ( pUserData->ImpersonateUser()) {

                if( !MoveFileEx( szCanonExisting,
                                 szCanonNew,
                                 pUserData->QueryInstance()->AllowReplaceOnRename()
                                     ? MOVEFILE_REPLACE_EXISTING
                                     : 0 )
                   ){

                    err = GetLastError();

                    IF_DEBUG( VIRTUAL_IO ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "cannot rename %s to %s, error %lu\n",
                                   szCanonExisting,
                                   szCanonNew,
                                   err ));
                    }
                }

                pUserData->RevertToSelf();

            } else {
                err = GetLastError();
            }

        } else  {

            IF_DEBUG( VIRTUAL_IO ) {

                DBGPRINTF(( DBG_CONTEXT,
                           "cannot canonicalize %s - %s, error %lu\n",
                           pUserData->QueryCurrentDirectory().QueryStr(),
                           pszExisting,
                           err ));
            }
        }
    } else {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory().QueryStr(),
                       pszExisting,
                       err ));
        }
    }

    return err;

}   // VirtualRenameFile()




APIERR
VirtualChDir(
    USER_DATA * pUserData,
    LPSTR       pszDir
    )
/*++
  This function sets the current directory to newly specified directory.

  Arguments:
     pUserData -- the user initiating the request
     pszDir  -- pointer to null-terminated buffer containing the
                   new directory name.

  Returns:
     APIERR  -- NO_ERROR if successful, otherwise a Win32 error code.

  History:
     MuraliK   28-Apr-1995  Modified to use symbolic roots.
--*/
{
    CHAR     rgchVirtual[MAX_PATH+1];
    DWORD    cbVirtSize;
    APIERR   err = NO_ERROR;
    DWORD    cbSize;
    CHAR     szCanonDir[MAX_PATH+1];

    DBG_ASSERT( pUserData != NULL );

    if (pszDir == NULL || *pszDir == '\0') {

        //
        // Nothing new specified.
        //

        return ( NO_ERROR);
    }

    //
    //  Canonicalize the new path.
    //

    cbSize = sizeof(szCanonDir);
    cbVirtSize = sizeof(rgchVirtual);
    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeRead,
                                         NULL,
                                         rgchVirtual,
                                         &cbVirtSize);

    if ( err == ERROR_ACCESS_DENIED) {

        //
        // this maybe a write only virtual root directory.
        // Let us try again to find we have Write access atleast
        //

        cbSize = sizeof(szCanonDir);
        cbVirtSize = sizeof(rgchVirtual);
        err = pUserData->VirtualCanonicalize(szCanonDir,
                                             &cbSize,
                                             pszDir,
                                             AccessTypeWrite,
                                             NULL,
                                             rgchVirtual,
                                             &cbVirtSize);
    }

    if( err != NO_ERROR )
    {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory().QueryStr(),
                       pszDir,
                       err ));
        }

        return err;
    }

    //
    //  Try to open the directory and get a handle for the same.
    //

    // This is possibly a new place to change directory to.

    if ( pUserData->ImpersonateUser()) {

        HANDLE CurrentDirHandle = INVALID_HANDLE_VALUE;

        err = OpenPathForAccess( &CurrentDirHandle,
                                szCanonDir,
                                GENERIC_READ,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                pUserData->QueryImpersonationToken()
                                );

        if( err == ERROR_ACCESS_DENIED ) {
            err = OpenPathForAccess( &CurrentDirHandle,
                                    szCanonDir,
                                    GENERIC_WRITE,
                                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                                    pUserData->QueryImpersonationToken()
                                    );
        }

        if( err == NO_ERROR ) {

            BY_HANDLE_FILE_INFORMATION fileInfo;
            BOOL fRet;

            fRet = GetFileInformationByHandle( CurrentDirHandle,
                                              &fileInfo);

            if ( !fRet) {

                err = GetLastError();

                // Error in getting the file information.
                // close handle and return.

                CloseHandle( CurrentDirHandle);

            } else {

                if ( (fileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    != FILE_ATTRIBUTE_DIRECTORY) {

                    //
                    // this file is not a directory.
                    // Do not change directory. But return error.
                    //

                    err = ERROR_DIRECTORY;
                    CloseHandle( CurrentDirHandle);
                } else {

                    //
                    //  Directory successfully opened.  Save the handle
                    //  in the per-user data. This handle is maintained to
                    //  prevent accidental deletion of the directory.
                    //

                    if( pUserData->CurrentDirHandle != INVALID_HANDLE_VALUE ) {

                        IF_DEBUG( VIRTUAL_IO ) {

                            DBGPRINTF(( DBG_CONTEXT,
                                       "closing dir handle %08lX for %s\n",
                                       pUserData->CurrentDirHandle,
                                       pUserData->QueryCurrentDirectory().QueryStr()));
                        }

                        CloseHandle( pUserData->CurrentDirHandle );
                    }

                    pUserData->CurrentDirHandle = CurrentDirHandle;

                    IF_DEBUG( VIRTUAL_IO ) {

                        DBGPRINTF(( DBG_CONTEXT,
                                   "opened directory %s, handle = %08lX\n",
                                   szCanonDir,
                                   CurrentDirHandle ));
                    }

                    // update the current directory
                    pUserData->SetCurrentDirectory( rgchVirtual );

                }
            }
        }

        pUserData->RevertToSelf();

    } else {

        // Impersonation failed
        err = GetLastError();
    }

    IF_DEBUG( VIRTUAL_IO ) {

        DBGPRINTF(( DBG_CONTEXT,
                   "chdir to %s  returns error = %d\n", szCanonDir, err ));
    }

    return ( err);

}   // VirtualChDir()



/*******************************************************************

    NAME:       VirtualRmDir

    SYNOPSIS:   Removes an existing directory.

    ENTRY:      pUserData - The user initiating the request.

                pszDir - The name of the directory to remove.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualRmDir(
    USER_DATA * pUserData,
    LPSTR      pszDir
    )
{
    APIERR err;
    CHAR   szCanonDir[MAX_PATH+1];
    DWORD  cbSize = sizeof(szCanonDir);

    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeDelete );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "rmdir %s\n", szCanonDir ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !RemoveDirectory( szCanonDir ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO ) {

                    DBGPRINTF(( DBG_CONTEXT,
                               "cannot rmdir %s, error %lu\n",
                               szCanonDir,
                               err ));
                }
            }
            pUserData->RevertToSelf();
        } else {
            err = GetLastError();
        }
    } else {

        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot canonicalize %s - %s, error %lu\n",
                        pUserData->QueryCurrentDirectory().QueryStr(),
                        pszDir,
                        err ));
        }
    }

    return err;

}   // VirtualRmDir



/*******************************************************************

    NAME:       VirtualMkDir

    SYNOPSIS:   Creates a new directory.

    ENTRY:      pUserData - The user initiating the request.

                pszDir - The name of the directory to create.

    RETURNS:    APIERR - NO_ERROR if successful, otherwise a Win32
                    error code.

    HISTORY:
        KeithMo     09-Mar-1993 Created.

********************************************************************/
APIERR
VirtualMkDir(
    USER_DATA * pUserData,
    LPSTR      pszDir
    )
{
    APIERR err;
    CHAR   szCanonDir[MAX_PATH+1];
    DWORD  cbSize = sizeof(szCanonDir);

    DBG_ASSERT( pUserData != NULL );

    err = pUserData->VirtualCanonicalize(szCanonDir,
                                         &cbSize,
                                         pszDir,
                                         AccessTypeCreate );

    if( err == NO_ERROR )
    {
        IF_DEBUG( VIRTUAL_IO )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "mkdir %s\n", szCanonDir ));
        }

        if ( pUserData->ImpersonateUser()) {

            if( !CreateDirectory( szCanonDir, NULL ) ) {

                err = GetLastError();

                IF_DEBUG( VIRTUAL_IO )
                  {
                      DBGPRINTF(( DBG_CONTEXT,
                                 "cannot mkdir %s, error %lu\n",
                                 szCanonDir,
                                 err ));
                  }
            }
            pUserData->RevertToSelf();
        } else {
            err = GetLastError();
        }
    } else {

        IF_DEBUG( VIRTUAL_IO ) {

            DBGPRINTF(( DBG_CONTEXT,
                       "cannot canonicalize %s - %s, error %lu\n",
                       pUserData->QueryCurrentDirectory().QueryStr(),
                       pszDir,
                       err ));
        }
    }

    return err;

}   // VirtualMkDir




//
//  Private constants.
//

#define ACTION_NOTHING              0x00000000
#define ACTION_EMIT_CH              0x00010000
#define ACTION_EMIT_DOT_CH          0x00020000
#define ACTION_EMIT_DOT_DOT_CH      0x00030000
#define ACTION_BACKUP               0x00040000
#define ACTION_MASK                 0xFFFF0000


//
//  Private globals.
//

INT p_StateTable[4][4] =
    {
        {   // state 0
            1 | ACTION_EMIT_CH,             // "\"
            0 | ACTION_EMIT_CH,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_CH              // other
        },

        {   // state 1
            1 | ACTION_NOTHING,             // "\"
            2 | ACTION_NOTHING,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_CH              // other
        },

        {   // state 2
            1 | ACTION_NOTHING,             // "\"
            3 | ACTION_NOTHING,             // "."
            4 | ACTION_EMIT_CH,             // EOS
            0 | ACTION_EMIT_DOT_CH          // other
        },

        {   // state 3
            1 | ACTION_BACKUP,              // "\"
            0 | ACTION_EMIT_DOT_DOT_CH,     // "."
            4 | ACTION_BACKUP,              // EOS
            0 | ACTION_EMIT_DOT_DOT_CH      // other
        }
    };



/*******************************************************************

    NAME:       VirtualpSanitizePath

    SYNOPSIS:   Sanitizes a path by removing bogus path elements.

                As expected, "/./" entries are simply removed, and
                "/../" entries are removed along with the previous
                path element.

                To maintain compatibility with URL path semantics
                 additional transformations are required. All backward
                 slashes "\\" are converted to forward slashes. Any
                 repeated forward slashes (such as "///") are mapped to
                 single backslashes.  Also, any trailing path elements
                 consisting solely of dots "/....." are removed.

                Thus, the path "/foo\./bar/../tar\....\......" is
                mapped to "/foo/tar".

                A state table (see the p_StateTable global at the
                beginning of this file) is used to perform most of
                the transformations.  The table's rows are indexed
                by current state, and the columns are indexed by
                the current character's "class" (either slash, dot,
                NULL, or other).  Each entry in the table consists
                of the new state tagged with an action to perform.
                See the ACTION_* constants for the valid action
                codes.

                After the FSA is finished with the path, we make one
                additional pass through it to remove any trailing
                backslash, and to remove any trailing path elements
                consisting solely of dots.

    ENTRY:      pszPath - The path to sanitize.

    HISTORY:
        KeithMo     07-Sep-1994 Created.
        MuraliK     28-Apr-1995 Adopted this for symbolic paths

********************************************************************/
VOID
VirtualpSanitizePath(
    CHAR * pszPath
    )
{
    CHAR * pszSrc;
    CHAR * pszDest;
    CHAR * pszHead;
    CHAR   ch;
    INT    State;
    INT    Class;
    BOOL   fDBCS = FALSE;

    //
    //  Ensure we got a valid symbolic path (something starting "/"
    //

    DBG_ASSERT( pszPath != NULL );
//     DBG_ASSERT( pszPath[0] == '/');

    //
    //  Start our scan at the first "/.
    //

    pszHead = pszSrc = pszDest = pszPath;

    //
    //  State 0 is the initial state.
    //

    State = 0;

    //
    //  Loop until we enter state 4 (the final, accepting state).
    //

    while( State != 4 )
    {
        //
        //  Grab the next character from the path and compute its
        //  character class.  While we're at it, map any forward
        //  slashes to backward slashes.
        //

        ch = *pszSrc++;

        switch( ch )
        {
        case '\\' :
            //
            //  fDBCS is always false for non-DBCS system
            //

            if ( fDBCS )
            {
                Class = 3;
                break;
            }
            ch = '/';  // convert it to symbolic URL path separator char.
            /* fall through */

        case '/' :
            Class = 0;
            break;

        case '.' :
            Class = 1;
            break;

        case '\0' :
            Class = 2;
            break;

        default :
            Class = 3;
            break;
        }

        //
        //  Advance to the next state.
        //

        State = p_StateTable[State][Class];

        //
        //  Perform the action associated with the state.
        //

        switch( State & ACTION_MASK )
        {
        case ACTION_EMIT_DOT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_DOT_CH :
            *pszDest++ = '.';
            /* fall through */

        case ACTION_EMIT_CH :
            *pszDest++ = ch;
            /* fall through */

        case ACTION_NOTHING :
            break;

        case ACTION_BACKUP :
            if( pszDest > ( pszHead + 1 ) )
            {
                pszDest--;
                DBG_ASSERT( *pszDest == '/' );

                *pszDest = '\0';
                pszDest = strrchr( pszPath, '/') + 1;
            }

            *pszDest = '\0';
            break;

        default :
            DBG_ASSERT( !"Invalid action code in state table!" );
            State = 4;
            *pszDest++ = '\0';
            break;
        }

        State &= ~ACTION_MASK;
        if ( !fDBCS )
        {
            if ( IsDBCSLeadByte( ch ) )
            {
                fDBCS = TRUE;
            }
        }
        else
        {
            fDBCS = FALSE;
        }
    }

    //
    //  Remove any trailing slash.
    //

    pszDest -= 2;

    if( ( strlen( pszPath ) > 3 ) && ( *pszDest == '/' ) )
    {
        *pszDest = '\0';
    }

    //
    //  If the final path elements consists solely of dots and spaces, remove them.
    //

    while( strlen( pszPath ) > 3 )
    {
        pszDest = strrchr( pszPath, '/');
        DBG_ASSERT( pszDest != NULL );

        pszHead = pszDest;
        pszDest++;

        while( ch = *pszDest++ )
        {
            if( (ch != '.') && (ch != ' ') )
            {
                break;
            }
        }

        if( ch == '\0' )
        {
            //
            // this is probably dead code left over from
            // when we used physical paths.
            //
            if( pszHead == ( pszPath + 2 ) )
            {
                pszHead++;
            }
            // end of dead code

            //
            // Don't remove the first '/'
            //
            if ( pszHead == pszPath )
            {
                pszHead++;
            }

            *pszHead = '\0';
        }
        else
        {
            break;
        }
    }

}   // VirtualpSanitizePath
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\iismap\iiscmr.cxx ===
/*++



Copyright (c) 1996  Microsoft Corporation

Module Name:

    iiscmr.cxx

Abstract:

    Classes to handle IIS client cert wildcard mappings

Author:

    Philippe Choquier (phillich)    17-oct-1996

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#define _CRYPT32_
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>

#include <iis64.h>
#include <locks.h>
#define DLL_IMPLEMENTATION
#include <iismap.hxx>
#include "iismaprc.h"
#include "mapmsg.h"
#include <iiscmr.hxx>
#include <icrypt.hxx>
#include <dbgutil.h>

#include <lmcons.h>

typedef
WINCRYPT32API
BOOL
(WINAPI* PFNCryptDecodeObject)(
    IN DWORD        dwCertEncodingType,
    IN LPCSTR       lpszStructType,
    IN const BYTE   *pbEncoded,
    IN DWORD        cbEncoded,
    IN DWORD        dwFlags,
    OUT void        *pvStructInfo,
    IN OUT DWORD    *pcbStructInfo
    );

//
// GLOBALS
//


//
// definition of ASN.1 <> X.509 name conversion
//

MAP_ASN aMapAsn[] = {
    { szOID_COUNTRY_NAME, "", IDS_CMR_ASN_C },
    { szOID_ORGANIZATION_NAME, "", IDS_CMR_ASN_O },
    { szOID_ORGANIZATIONAL_UNIT_NAME, "", IDS_CMR_ASN_OU },
    { szOID_COMMON_NAME, "", IDS_CMR_ASN_CN },
    { szOID_LOCALITY_NAME, "", IDS_CMR_ASN_L },
    { szOID_STATE_OR_PROVINCE_NAME, "", IDS_CMR_ASN_S },
    { szOID_TITLE, "", IDS_CMR_ASN_T },
    { szOID_GIVEN_NAME, "", IDS_CMR_ASN_GN },
    { szOID_INITIALS, "", IDS_CMR_ASN_I },
    { "1.2.840.113549.1.9.1", "", IDS_CMR_ASN_Email },
    { "1.2.840.113549.1.9.8", "", IDS_CMR_ASN_Addr },   // warning: can include CR/LF
} ;

HINSTANCE hCapi2Lib = NULL;

PFNCryptDecodeObject
    pfnCryptDecodeObject = NULL;

char HEXTOA[] = "0123456789abcdef";


MAP_FIELD aMapField[] = {
    { CERT_FIELD_ISSUER, IDS_CMR_X509FLD_IS, "" },
    { CERT_FIELD_SUBJECT, IDS_CMR_X509FLD_SU, "" },
    { CERT_FIELD_SERIAL_NUMBER, IDS_CMR_X509FLD_SN, "" },
} ;


DWORD adwFieldFlags[]={
    CERT_FIELD_FLAG_CONTAINS_SUBFIELDS,
    CERT_FIELD_FLAG_CONTAINS_SUBFIELDS,
    0,
};

//
// Global functions
//

BOOL
Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    LPDWORD pU
    )
/*++

Routine Description:

    Unserialize a DWORD
    pU is updated with DWORD from *ppB, ppB & pC are updated

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    pU - ptr to DWORD where to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD dwTemp; // added to handle 64 bit alignment problems
    if ( *pC >= sizeof( DWORD ) )
    {
        dwTemp = **ppB;
        *pU = dwTemp;
        *ppB += sizeof(DWORD);
        *pC -= sizeof(DWORD);
        return TRUE;
    }

    return FALSE;
}


BOOL
Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    LPBOOL pU
    )
/*++

Routine Description:

    Unserialize a BOOL
    pU is updated with BOOL from *ppB, ppB & pC are updated

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    pU - ptr to BOOL where to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL bTemp; // added to handle 64 bit alignment problems
    if ( *pC >= sizeof( BOOL ) )
    {
        bTemp = **ppB;
        *pU = bTemp;
        *ppB += sizeof(BOOL);
        *pC -= sizeof(BOOL);
        return TRUE;
    }

    return FALSE;
}


//
// Extensible buffer class
//

BOOL
CStoreXBF::Need(
    DWORD dwNeed
    )
/*++

Routine Description:

    Insure that CStoreXBF can store at least dwNeed bytes
    including bytes already stored.

Arguments:

    dwNeed - minimum of bytes available for storage

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( dwNeed > m_cAllocBuff )
    {
        dwNeed = ((dwNeed + m_cGrain)/m_cGrain)*m_cGrain;
        LPBYTE pN = (LPBYTE)LocalAlloc( LMEM_FIXED, dwNeed );
        if ( pN == NULL )
        {
            return FALSE;
        }
        if ( m_cUsedBuff )
        {
            // expanding buffer
            // copy existing data into new buffer
            //
            DBG_ASSERT( m_cUsedBuff <= dwNeed );
            memcpy( pN, m_pBuff, m_cUsedBuff );
        }
        m_cAllocBuff = dwNeed;
        LocalFree( m_pBuff );
        m_pBuff = pN;
    }
    return TRUE;
}

BOOL
CStoreXBF::Save(
    HANDLE hFile
    )
/*++

Routine Description:

    Save to file

Arguments:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD dwWritten;

    return WriteFile( hFile, GetBuff(), GetUsed(), &dwWritten, NULL ) &&
           dwWritten == GetUsed();
}


BOOL
CStoreXBF::Load(
    HANDLE hFile
    )
/*++

Routine Description:

    Load from file

Arguments:

    hFile - file handle

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD   dwS = GetFileSize( hFile, NULL );
    DWORD   dwRead;

    if ( dwS != 0xffffffff &&
         Need( dwS ) &&
         ReadFile( hFile, GetBuff(), dwS, &dwRead, NULL ) &&
         dwRead == dwS )
    {
        m_cUsedBuff = dwRead;

        return TRUE;
    }

    m_cUsedBuff = 0;

    return FALSE;
}



BOOL
Serialize(
    CStoreXBF* pX,
    DWORD dw
    )
/*++

Routine Description:

    Serialize a DWORD in CStoreXBF

Arguments:

    pX - ptr to CStoreXBF where to add serialized DWORD
    dw - DWORD to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return pX->Append( (LPBYTE)&dw, sizeof(dw) );
}

//
// extensible array of LPVOID
//

BOOL
Serialize(
    CStoreXBF* pX,
    BOOL f
    )
/*++

Routine Description:

    Serialize a BOOL in CStoreXBF

Arguments:

    pX - ptr to CStoreXBF where to add serialized BOOL
    f - BOOL to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return pX->Append( (LPBYTE)&f, sizeof(f) );
}


DWORD
CPtrXBF::AddPtr(
    LPVOID pV
    )
/*++

Routine Description:

    Add a ptr to array

Arguments:

    pV - ptr to be added at end of array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i = GetNbPtr();
    if ( Append( (LPBYTE)&pV, sizeof(pV)) )
    {
        return i;
    }
    return INDEX_ERROR;
}


DWORD
CPtrXBF::InsertPtr(
    DWORD iBefore,
    LPVOID pV
    )
/*++

Routine Description:

    Insert a ptr to array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pV - ptr to be inserted

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    if ( iBefore == INDEX_ERROR || iBefore >= GetNbPtr() )
    {
        return AddPtr( pV );
    }
    if ( AddPtr( NULL ) != INDEX_ERROR )
    {
        //
        // AddPtr has taken care of expanding
        // moving all the pointer passed the insertion point
        // using memmove is thus safe
        //
        memmove( GetBuff()+(iBefore+1)*sizeof(LPVOID),
                 GetBuff()+iBefore*sizeof(LPVOID),
                 GetUsed()-(iBefore+1)*sizeof(LPVOID) );

        SetPtr( iBefore, pV );

        return iBefore;
    }
    return INDEX_ERROR;
}


BOOL
CPtrXBF::DeletePtr(
    DWORD i
    )
/*++

Routine Description:

    Delete a ptr from array

Arguments:

    i - index of ptr to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    //
    // shrinking is safe
    //
    
    memmove( GetBuff()+i*sizeof(LPVOID),
             GetBuff()+(i+1)*sizeof(LPVOID),
             GetUsed()-(i+1)*sizeof(LPVOID) );

    DecreaseUse( sizeof(LPVOID) );

    return TRUE;
}


BOOL
CPtrXBF::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    DWORD cNbEntry
    )
/*++

Routine Description:

    Unserialize a ptr array

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer
    cNbEntry - # of ptr to unserialize from buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();
    if ( *pC >= cNbEntry * sizeof(LPVOID) &&
         Append( *ppB, cNbEntry * sizeof(LPVOID) ) )
    {
        *ppB += cNbEntry * sizeof(LPVOID);
        *pC -= cNbEntry * sizeof(LPVOID);

        return TRUE;
    }

    return FALSE;
}


BOOL
CPtrXBF::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a ptr array

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return pX->Append( (LPBYTE)GetBuff(), (DWORD)GetUsed() );
}

//
// extensible array of DWORDS
// Added to make win64 stuff work
//

DWORD
CPtrDwordXBF::AddPtr(
    DWORD pV
    )
/*++

Routine Description:

    Add a ptr to array

Arguments:

    pV - ptr to be added at end of array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i = GetNbPtr();
    if ( Append( (LPBYTE)&pV, sizeof(pV)) )
    {
        return i;
    }
    return INDEX_ERROR;
}


DWORD
CPtrDwordXBF::InsertPtr(
    DWORD iBefore,
    DWORD pV
    )
/*++

Routine Description:

    Insert a ptr to array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pV - ptr to be inserted

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    if ( iBefore == INDEX_ERROR || iBefore >= GetNbPtr() )
    {
        return AddPtr( pV );
    }
    if ( AddPtr( NULL ) != INDEX_ERROR )
    {
        //
        // AddPtr has taken care of adding additional memory
        // It is safe now to shift array passed the insertion point by one
        //
        memmove( GetBuff()+(iBefore+1)*sizeof(DWORD),
                 GetBuff()+iBefore*sizeof(DWORD),
                 GetUsed()-(iBefore+1)*sizeof(DWORD) );

        SetPtr( iBefore, pV );

        return iBefore;
    }
    return INDEX_ERROR;
}


BOOL
CPtrDwordXBF::DeletePtr(
    DWORD i
    )
/*++

Routine Description:

    Delete a ptr from array

Arguments:

    i - index of ptr to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    //
    // shrinking is safe, no risk of buffer overflow
    //
    memmove( GetBuff()+i*sizeof(DWORD),
             GetBuff()+(i+1)*sizeof(DWORD),
             GetUsed()-(i+1)*sizeof(DWORD) );

    DecreaseUse( sizeof(LPVOID) );

    return TRUE;
}


BOOL
CPtrDwordXBF::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    DWORD cNbEntry
    )
/*++

Routine Description:

    Unserialize a ptr array

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer
    cNbEntry - # of ptr to unserialize from buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();
    if ( *pC >= cNbEntry * sizeof(DWORD))
    {
        if (Append( *ppB, cNbEntry * sizeof(DWORD) ))
        {
          *ppB += cNbEntry * sizeof(DWORD);
          *pC -= cNbEntry * sizeof(DWORD);
          return TRUE;
         }
    }

    return FALSE;
}


BOOL
CPtrDwordXBF::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a ptr array

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return pX->Append( (LPBYTE)GetBuff(), (DWORD)GetUsed() );
}

//
// string storage class
//


BOOL
CAllocString::Set(
    LPSTR pS
    )
/*++

Routine Description:

    Set a string content, freeing prior content if any

Arguments:

    pS - string to copy

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    size_t l;
    Reset();
    if ( ( m_pStr = (LPSTR)LocalAlloc( LMEM_FIXED, l = strlen(pS)+1 ) ) != NULL )
    {
        memcpy( m_pStr, pS, l );

        return TRUE;
    }
    return FALSE;
}


BOOL
CAllocString::Append(
    LPSTR pS
    )
/*++

Routine Description:

    Append a string content

Arguments:

    pS - string to append

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    size_t l = m_pStr ? strlen(m_pStr ) : 0;
    size_t nl;
    LPSTR pStr;

    if ( (pStr = (LPSTR)LocalAlloc( LMEM_FIXED, l + (nl = strlen(pS)+1 ))) != NULL )
    {
        memcpy( pStr, m_pStr, l );
        memcpy( pStr+l, pS, nl );

        //
        // Free the old block before we blow it away.
        //

        Reset();

        m_pStr = pStr;

        return TRUE;
    }
    return FALSE;
}


BOOL
CAllocString::Unserialize(
    LPBYTE* ppb,
    LPDWORD pc
    )
/*++

Routine Description:

    Unserialize a string

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD   dwL;

    if ( ::Unserialize( ppb, pc, &dwL ) &&
         (m_pStr = (LPSTR)LocalAlloc( LMEM_FIXED, dwL + 1)) != NULL )
    {
        memcpy( m_pStr, *ppb, dwL );
        m_pStr[dwL] = '\0';

        *ppb += dwL;
        *pc -= dwL;

        return TRUE;
    }
    return FALSE;
}


BOOL
CAllocString::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a string

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPSTR pS = m_pStr ? m_pStr : "";

    return ::Serialize( pX, (DWORD)strlen(pS) ) && pX->Append( pS );
}

//
// binary object, contains ptr & size
//

BOOL
CBlob::Set(
    LPBYTE pStr,
    DWORD cStr
    )
/*++

Routine Description:

    Store a buffer in a blob object
    buffer is copied inside blob
    blob is reset before copy

Arguments:

    pStr - ptr to buffer to copy
    cStr - length of buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();

    return InitSet( pStr, cStr);
}


BOOL
CBlob::InitSet(
    LPBYTE pStr,
    DWORD cStr
    )
/*++

Routine Description:

    Store a buffer in a blob object
    buffer is copied inside blob
    blob is not reset before copy, initial blob content ignored

Arguments:

    pStr - ptr to buffer to copy
    cStr - length of buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( (m_pStr = (LPBYTE)LocalAlloc( LMEM_FIXED, cStr )) != NULL )
    {
        memcpy( m_pStr, pStr, cStr );
        m_cStr = cStr;

        return TRUE;
    }
    return FALSE;
}


BOOL
CBlob::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC
    )
/*++

Routine Description:

    Unserialize a blob

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    Reset();

    if ( ::Unserialize( ppB, pC, &m_cStr ) &&
         *pC >= m_cStr &&
         ( m_pStr = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cStr ) ) != NULL )
    {
        memcpy( m_pStr, *ppB, m_cStr );

        *ppB += m_cStr;
        *pC -= m_cStr;
    }
    else
    {
        m_cStr = 0;
        return FALSE;
    }

    return TRUE;
}


BOOL
CBlob::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a blob

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return ::Serialize( pX, m_cStr ) &&
           pX->Append( m_pStr, m_cStr );
}

//
// extensible array of strings
//

CStrPtrXBF::~CStrPtrXBF(
    )
/*++

Routine Description:

    CStrPtrXBF destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetNbPtr();
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        ((CAllocString*)GetPtrAddr(i))->Reset();
    }
}


DWORD
CStrPtrXBF::AddEntry(
    LPSTR pS
    )
/*++

Routine Description:

    Add a string to array
    string content is copied in array

Arguments:

    pS - string to be added at end of array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( (i = AddPtr( NULL )) != INDEX_ERROR )
    {
        return ((CAllocString*)GetPtrAddr(i))->Set( pS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


DWORD
CStrPtrXBF::InsertEntry(
    DWORD iBefore,
    LPSTR pS
    )
/*++

Routine Description:

    Insert a string in array
    string content is copied in array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pS - string to be inserted in array

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( (i = InsertPtr( iBefore, NULL )) != INDEX_ERROR )
    {
        return ((CAllocString*)GetPtrAddr(i))->Set( pS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


BOOL
CStrPtrXBF::DeleteEntry(
    DWORD i
    )
/*++

Routine Description:

    Delete a string from array

Arguments:

    i - index of string to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( i < GetNbPtr() )
    {
        ((CAllocString*)GetPtrAddr(i))->Reset();
        DeletePtr( i );

        return TRUE;
    }
    return FALSE;
}


BOOL
CStrPtrXBF::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    DWORD cNbEntry
    )
/*++

Routine Description:

    Unserialize a string array

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer
    cNbEntry - # of entry to unserialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    Reset();

    CAllocString empty;
    for ( i = 0 ; i < cNbEntry ; ++i )
    {
        if ( !Append( (LPBYTE)&empty, sizeof(empty)) ||
             !((CAllocString*)GetPtrAddr(i))->Unserialize( ppB, pC ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL
CStrPtrXBF::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a string array

Arguments:

    pX - ptr to CStoreXBF where to add serialized DWORD

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    for ( i = 0 ; i < GetNbEntry() ; ++i )
    {
        if ( !((CAllocString*)GetPtrAddr(i))->Serialize( pX ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}

//
// extensible array of binary object
// ptr & size are stored for each entry
//

CBlobXBF::~CBlobXBF(
    )
/*++

Routine Description:

    CBlobXBF destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetUsed()/sizeof(CBlob);
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        GetBlob(i)->Reset();
    }
}


VOID CBlobXBF::Reset(
    )
/*++

Routine Description:

    Reset the blob content to NULL

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DWORD iM = GetUsed()/sizeof(CBlob);
    UINT i;
    for ( i = 0 ; i < iM ; ++i )
    {
        GetBlob(i)->Reset();
    }
    CStoreXBF::Reset();
}


DWORD
CBlobXBF::AddEntry(
    LPBYTE pS,
    DWORD cS
    )
/*++

Routine Description:

    Add a buffer to blob array
    buffer content is copied in array

Arguments:

    pS - buffer to be added at end of array
    cS - length of buffer

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{
    DWORD i = GetNbEntry();

    if ( Append( (LPBYTE)&pS, sizeof(CBlob) ) )
    {
        return GetBlob(i)->InitSet( pS, cS ) ? i : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


DWORD
CBlobXBF::InsertEntry(
    DWORD iBefore,
    LPSTR pS,
    DWORD cS )
/*++

Routine Description:

    Insert a buffer in blob array
    buffer content is copied in array

Arguments:

    iBefore - index where to insert entry, or 0xffffffff if add to array
    pS - buffer to be inserted in array
    cS - length of buffer

Return Value:

    index ( 0-based ) in array where added or INDEX_ERROR if error

--*/
{

    if ( iBefore == INDEX_ERROR || iBefore >= GetNbEntry() )
    {
        return AddEntry( (LPBYTE)pS, cS );
    }

    if ( iBefore < GetNbEntry() && Append( (LPBYTE)&pS, sizeof(CBlob) ) )
    {
        //
        // Append has taken care of expanding memory
        // safe to memmove by one entry
        //
        memmove( GetBuff()+(iBefore+1)*sizeof(CBlob),
                 GetBuff()+iBefore*sizeof(CBlob),
                 GetUsed()-(iBefore+1)*sizeof(CBlob) );

        return GetBlob(iBefore)->InitSet( (LPBYTE)pS, cS ) ? iBefore : INDEX_ERROR;
    }
    return INDEX_ERROR;
}


BOOL
CBlobXBF::DeleteEntry(
    DWORD i
    )
/*++

Routine Description:

    Delete a entry from blob array

Arguments:

    i - index of string to delete

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( i < GetNbEntry() )
    {
        GetBlob(i)->Reset();

        // shrinking is safe, no risk of buffer overflow
        //
        memmove( GetBuff()+i*sizeof(CBlob),
                 GetBuff()+(i+1)*sizeof(CBlob),
                 GetUsed()-(i+1)*sizeof(CBlob) );

        DecreaseUse( sizeof(CBlob) );

        return TRUE;
    }
    return FALSE;
}


BOOL
CBlobXBF::Unserialize(
    LPBYTE* ppB,
    LPDWORD pC,
    DWORD cNbEntry )
/*++

Routine Description:

    Unserialize a blob array

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer
    cNbEntry - # of ptr to unserialize from buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT i;

    Reset();

    CBlob empty;
    for ( i = 0 ; i < cNbEntry ; ++i )
    {
        if ( !Append( (LPBYTE)&empty, sizeof(empty) ) ||
             !GetBlob(i)->Unserialize( ppB, pC ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


BOOL
CBlobXBF::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a blob array

Arguments:

    pX - ptr to CStoreXBF where to add serialized blob

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT i;

    for ( i = 0 ; i < GetNbEntry() ; ++i )
    {
        if ( !GetBlob(i)->Serialize( pX ) )
        {
            return FALSE;
        }
    }
    return TRUE;
}


CDecodedCert::CDecodedCert(
    PCERT_CONTEXT   pCert
    )
/*++

Routine Description:

    Constructor
    Store a reference to cert ( cert data is NOT copied )

Arguments:

    pCert - cert

Return Value:

    Nothing

--*/
{
    UINT    i;

    for ( i = 0 ; i < CERT_FIELD_LAST ; ++i )
    {
        aniFields[i] = NULL;
    }
    pCertCtx = (PCCERT_CONTEXT)pCert;

}


CDecodedCert::~CDecodedCert(
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    UINT    i;

    for ( i = 0 ; i < CERT_FIELD_LAST ; ++i )
    {
       if ( aniFields[i] != NULL )
       {
           LocalFree( aniFields[i] );
       }
    }
}


BOOL
CDecodedCert::GetIssuer(
    LPVOID* ppCert,
    LPDWORD pcCert
    )
/*++

Routine Description:

    Get the issuer portion of a cert
    Returns a reference : issuer is NOT copied

Arguments:

    ppCert - updated with ptr to issuer
    pcCert - updated with issuer byte count

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( pCertCtx == NULL )
    {
        return FALSE;
    }

    *ppCert = pCertCtx->pCertInfo->Issuer.pbData;
    *pcCert = pCertCtx->pCertInfo->Issuer.cbData;

    return TRUE;
}

PCERT_RDN_ATTR *
CDecodedCert::GetSubField(
    CERT_FIELD_ID fi,
    LPSTR pszAsnName,
    LPDWORD pcElements
    )
/*++

Routine Description:

    Returns a cert sub-field ( e.g. Issuer.O ).  There may be multiple entries
    for a given subfield.  This functions returns an array of attribute values

Arguments:

    fi - cert field where sub-field is located
    pszAsnName - ASN.1 name of sub-field inside fi
    pcElements - Number of elements returned in array

Return Value:

    ptr to array of pointers to attribute blobs if success, otherwise NULL

--*/
{
    CERT_NAME_BLOB* pBlob;
    DWORD           cbNameInfo;
    PCERT_NAME_INFO pNameInfo;
    DWORD           cRDN;
    DWORD           cAttr;
    PCERT_RDN       pRDN;
    PCERT_RDN_ATTR  pAttr;
    PCERT_RDN_ATTR* pAttrValues = NULL;
    DWORD           cRet = 0;
    DWORD           cMaxRet = 0;

    if ( pfnCryptDecodeObject == NULL )
    {
        SetLastError(ERROR_PROC_NOT_FOUND);
        return NULL;
    }

    *pcElements = 0;

    switch( fi )
    {
        case CERT_FIELD_ISSUER:
            pBlob = &pCertCtx->pCertInfo->Issuer;
            break;

        case CERT_FIELD_SUBJECT:
            pBlob = &pCertCtx->pCertInfo->Subject;
            break;

        case CERT_FIELD_SERIAL_NUMBER:
            pAttrValues = (PCERT_RDN_ATTR*)
                         LocalAlloc( LPTR, sizeof( PCERT_RDN_ATTR ) );
            if ( pAttrValues == NULL )
            {
                return NULL;
            }
            *pcElements = 1;

            //
            // Setup a CERT_RDN_ATTR so that GetSubField() can always return a 
            // pointer to an array of CERT_RDN_ATTRs
            //
    
            SerialNumber.dwValueType = CERT_RDN_OCTET_STRING;
            SerialNumber.Value = pCertCtx->pCertInfo->SerialNumber;
        
            pAttrValues[ 0 ] = &SerialNumber;
            return pAttrValues;

        default:
            return NULL;
    }

    if ( pszAsnName == NULL )
    {
        return NULL;
    }

    if ( (pNameInfo = aniFields[fi]) == NULL )
    {
        if (!(*pfnCryptDecodeObject)(X509_ASN_ENCODING,
                          (LPCSTR)X509_NAME,
                          pBlob->pbData,
                          pBlob->cbData,
                          0,
                          NULL,
                          &cbNameInfo))
        {
            return NULL;
        }

        if (NULL == (pNameInfo = (PCERT_NAME_INFO)LocalAlloc(LMEM_FIXED,cbNameInfo)))
        {
            return NULL;
        }

        if (!(*pfnCryptDecodeObject)(X509_ASN_ENCODING,
                            (LPCSTR)X509_NAME,
                            pBlob->pbData,
                            pBlob->cbData,
                            0,
                            pNameInfo,
                            &cbNameInfo))
        {
            LocalFree( pNameInfo );

            return NULL;
        }

        aniFields[fi] = pNameInfo;
    }

    for (cRDN = pNameInfo->cRDN, pRDN = pNameInfo->rgRDN; cRDN > 0; cRDN--, pRDN++)
    {
        for ( cAttr = pRDN->cRDNAttr, pAttr = pRDN->rgRDNAttr ; cAttr > 0 ; cAttr--, ++pAttr )
        {
            if ( !strcmp( pAttr->pszObjId, pszAsnName ) )
            {
                if ( ( cRet + 1 ) > cMaxRet )
                {
                    cMaxRet += 10;

                    if ( pAttrValues )
                    {
                        PCERT_RDN_ATTR* pReallocatedAttrValues = (PCERT_RDN_ATTR*)
                                                                        LocalReAlloc( pAttrValues,
                                                                                      sizeof( PCERT_RDN_ATTR ) * cMaxRet,
                                                                                      LMEM_MOVEABLE );
                        if ( pReallocatedAttrValues == NULL )
                        {
                            LocalFree( pAttrValues );
                            return NULL;
                        }
                        pAttrValues = pReallocatedAttrValues;

                    }
                    else
                    {
                        pAttrValues = (PCERT_RDN_ATTR*)
                                        LocalAlloc( LPTR,
                                                    sizeof( PCERT_RDN_ATTR ) * cMaxRet );
                        if ( pAttrValues == NULL )
                        {
                            return NULL;
                        }
                    }

                }

                pAttrValues[ cRet ] = pAttr;

                cRet++;

            }
        }
    }

    *pcElements = cRet;

    return pAttrValues;
}


CIssuerStore::CIssuerStore(
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{

    m_fValid = TRUE;
}


CIssuerStore::~CIssuerStore(
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{

}


VOID
CIssuerStore::Reset(
    )
/*++

Routine Description:

    Reset issuer list

Arguments:

    None

Return Value:

    None

--*/
{
    m_pIssuerNames.Reset();
    m_IssuerCerts.Reset();

    m_fValid = TRUE;
}


BOOL
CIssuerStore::Unserialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Unserialize issuer list

Arguments:

    pX - CStoreXBF to unserialize from

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}


BOOL
CIssuerStore::Unserialize(
    LPBYTE* ppb,
    LPDWORD pc
    )
/*++

Routine Description:

    Unserialize issuer list

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD dwC;

    Reset();

    if ( ::Unserialize( ppb, pc, &dwC ) &&
         m_pIssuerNames.Unserialize( ppb, pc, dwC ) &&
         m_IssuerCerts.Unserialize( ppb, pc, dwC ) )
    {
        return TRUE;
    }

    m_fValid = FALSE;
    return FALSE;
}


BOOL
CIssuerStore::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize issuer list

Arguments:

    pX - CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( !m_fValid )
    {
        return FALSE;
    }

    return ::Serialize( pX, (DWORD)GetNbIssuers() ) &&
           m_pIssuerNames.Serialize( pX ) &&
           m_IssuerCerts.Serialize( pX );
}


CCertGlobalRuleInfo::CCertGlobalRuleInfo(
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_fValid    = TRUE;
    m_fEnabled  = TRUE;
}


CCertGlobalRuleInfo::~CCertGlobalRuleInfo(
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


BOOL
CCertGlobalRuleInfo::Reset(
    )
/*++

Routine Description:

    Reset to default values

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_Order.Reset();

    m_fValid    = TRUE;
    m_fEnabled  = TRUE;

    return TRUE;
}

BOOL
CCertGlobalRuleInfo::AddRuleOrder(
    )
/*++

Routine Description:

    Add a rule at end of rule order array

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD i;
    if ( (i = m_Order.AddPtr( NULL )) != INDEX_ERROR )
    {
//          m_Order.SetPtr( i, (LPVOID) i );
        m_Order.SetPtr( i, i );


        return TRUE;
    }
    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertGlobalRuleInfo::DeleteRuleById(
    DWORD dwId,
    BOOL DecrementAbove
    )
/*++

Routine Description:

    Delete a rule based on index in rules array

Arguments:

    dwId - index in rules array
    DecrementAbove - flag indicating if items with a index above dwID need
        to be decremented. This is usually caused by the item being removed
        from the main array.

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    UINT iO;
    UINT iMax = m_Order.GetNbPtr();
    DWORD id;

    for ( iO = 0 ; iO < iMax ; ++iO )
    {
        // if it equals dwID, remove it
        if ( (DWORD_PTR)m_Order.GetPtr( iO ) == dwId )
        {
            m_Order.DeletePtr( iO );

            if ( DecrementAbove )
            {
                // if we have been asked to decrement the remaining items,
                // need to do this in another loop here. Yuck. - Boyd
                iMax = m_Order.GetNbPtr();
                for ( iO = 0 ; iO < iMax ; ++iO )
                {
                    // the id in question
                    id = (DWORD)((DWORD_PTR)m_Order.GetPtr( iO ));

                    // if it is bigger, decrement by one
                    if ( id > dwId )
                    {
                        id--;
                        // put it back in place
//                        m_Order.SetPtr( iO, (LPVOID) id );        //SUNDOWN ALERT
                        m_Order.SetPtr( iO, id );        //SUNDOWN ALERT
                    }
                }
            }


            // return early
            return TRUE;
        }
    }
    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertGlobalRuleInfo::SerializeGlobalRuleInfo(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize mapper global information

Arguments:

    pX - ptr to CStoreXBF to serialize to

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return ::Serialize( pX, GetRuleOrderCount() ) &&
           pX->Append( (LPBYTE)GetRuleOrderArray(),
                sizeof(DWORD)*GetRuleOrderCount() ) &&
           ::Serialize( pX, m_fEnabled );
}


BOOL
CCertGlobalRuleInfo::UnserializeGlobalRuleInfo(
    LPBYTE* ppB,
    LPDWORD pC
    )
/*++

Routine Description:

    Unserialize mapper global info

Arguments:

    ppB - ptr to addr of buffer to unserialize from
    pC - ptr to count of bytes in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD dwO;

    Reset();

    return ::Unserialize( ppB, pC, &dwO ) &&
           m_Order.Unserialize( ppB, pC, dwO ) &&
           ::Unserialize( ppB, pC, &m_fEnabled );
}


CCertMapRule::CCertMapRule(
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_fEnabled          = TRUE;
    m_fDenyAccess       = FALSE;
    m_fMatchAllIssuers  = TRUE;
    m_fValid            = TRUE;
}


CCertMapRule::~CCertMapRule(
    )
/*++

Routine Description:

    Desctructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


VOID
CCertMapRule::Reset(
    )
/*++

Routine Description:

    Reset to default values

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_fEnabled          = TRUE;
    m_fDenyAccess       = FALSE;
    m_fMatchAllIssuers  = TRUE;
    m_fValid            = TRUE;
    m_asRuleName.Reset();
    m_asAccount.Reset();
    m_asPassword.Reset();
    m_ElemsContent.Reset();
    m_ElemsSubfield.Reset();
    m_ElemsField.Reset();
    m_ElemsFlags.Reset();
    m_Issuers.Reset();
    m_IssuersAcceptStatus.Reset();
}


BOOL
CCertMapRule::Unserialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Unserialize a mapping rule

Arguments:

    pX - ptr to CStoreXBF to unserialize from

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}




BOOL
CCertMapRule::Unserialize(
    LPBYTE* ppb,
    LPDWORD pc
    )
/*++

Routine Description:

    Unserialize a mapping rule

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    DWORD   dwEl;
    DWORD   dwIs;

    Reset();

    if ( m_asRuleName.Unserialize( ppb, pc ) &&
         m_asAccount.Unserialize( ppb, pc ) &&
         m_asPassword.Unserialize( ppb, pc ) &&
         ::Unserialize( ppb, pc, &m_fEnabled ) &&
         ::Unserialize( ppb, pc, &m_fDenyAccess ) &&
         ::Unserialize( ppb, pc, &dwEl ) &&
         m_ElemsContent.Unserialize( ppb, pc, dwEl ) &&
         m_ElemsSubfield.Unserialize( ppb, pc, dwEl ) &&
         m_ElemsField.Unserialize( ppb, pc, dwEl ) &&
         m_ElemsFlags.Unserialize( ppb, pc, dwEl ) &&
        ::Unserialize( ppb, pc, &dwIs ) &&
        m_Issuers.Unserialize( ppb, pc, dwIs ) &&
        m_IssuersAcceptStatus.Unserialize( ppb, pc, dwIs ) &&
        ::Unserialize( ppb, pc, &m_fMatchAllIssuers ) )
    {
        return TRUE;
    }

    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertMapRule::Serialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Serialize a rule mapping in CStoreXBF

Arguments:

    pX - ptr to CStoreXBF where to add serialized DWORD

Return Value:

    TRUE if successful, FALSE on error

--*/
{

    if ( m_fValid &&
         m_asRuleName.Serialize( pX ) &&
         m_asAccount.Serialize( pX ) &&
         m_asPassword.Serialize( pX ) &&
         ::Serialize( pX, m_fEnabled ) &&
         ::Serialize( pX, m_fDenyAccess ) &&
         ::Serialize( pX, GetRuleElemCount() ) &&
         m_ElemsContent.Serialize( pX ) &&
         m_ElemsSubfield.Serialize( pX ) &&
         m_ElemsField.Serialize( pX ) &&
         m_ElemsFlags.Serialize( pX ) &&
         ::Serialize( pX, m_Issuers.GetNbEntry() ) &&
        m_Issuers.Serialize( pX ) &&
        m_IssuersAcceptStatus.Serialize( pX ) &&
        ::Serialize( pX, m_fMatchAllIssuers ) )
    {
        return TRUE;
    }
    return FALSE;
}


BOOL
CCertMapRule::SetRuleAccount(
    LPSTR pszAcct
    )
/*++

Routine Description:

    Set NT account returned by this rule if match

Arguments:

    pszAcct - NT account to use

Return Value:

    TRUE if successful, FALSE on error
    error ERROR_INVALID_NAME if replacement name ( %subfield% ) invalid

--*/
{
    LPSTR pR;
    LPSTR pD;

    //
    // Check replacement field valid
    //

    if ( ( pR = strchr( pszAcct, '%' ) ) != NULL )
    {
        ++pR;

        if ( (pD = strchr( pR, '%' )) == NULL )
        {
            SetLastError( ERROR_INVALID_NAME );

            return FALSE;
        }
        *pD = '\0';
        if ( !MapSubFieldToAsn1( pR ) )
        {
            *pD = '%';

            SetLastError( ERROR_INVALID_NAME );

            return FALSE;
        }
        *pD = '%';
    }

    return m_asAccount.Set( pszAcct );
}

//static
LPBYTE
CCertMapRule::CertMapMemstr(
    LPBYTE  pStr,
    UINT    cStr,
    LPBYTE  pSub,
    UINT    cSub,
    BOOL    fCaseInsensitive
    )
/*++

Routine Description:

    Find 1st occurence of block of memory inside buffer

Arguments:

    pStr - buffer where to search
    cStr - length of pStr
    pSub - buffer to search for in pStr
    cSub - length of pSub
    fCaseInsensitive - TRUE is case insensitive search

Return Value:

    Ptr to 1st occurence of pSub in pStr or NULL if not found

--*/
{
    LPBYTE      p;
    LPBYTE      pN;

    if ( cSub > cStr )
    {
        return NULL;
    }

    UINT    ch = *pSub;

    if ( fCaseInsensitive )
    {
        if ( cStr >= cSub &&
             cSub )
        {
            cStr -= cSub - 1;

            for ( p = pStr ; cStr ; ++p, --cStr )
            {
                if ( !_memicmp( p, pSub, cSub ) )
                {
                    return p;
                }
            }
        }
    }
    else
    {
        for ( p = pStr ; ( pN = (LPBYTE)memchr( p, ch, cStr ) ) != NULL ; )
        {
            if ( !memcmp( pN, pSub, cSub ) )
            {
                return pN;
            }
            cStr -= (UINT)(pN - p + 1);
            p = pN + 1;
        }
    }

    return NULL;
}



// return ERROR_INVALID_NAME if no match
BOOL
CCertMapRule::Match(
    CDecodedCert*   pC,
    CDecodedCert*   /*pAuth*/,
    LPSTR           pszAcct,
    LPSTR           pszPwd,
    LPBOOL          pfDenied
    )
/*++

Routine Description:

    Check if rule match certificate

Arguments:

    pC - client certificate
    pAuth - certifying authority (not used),
    pszAcct - updated with NT account on success,
        assumed to be at longer then UNLEN+IIS_DNLEN+1
    pszPwd - updated with NT password on success,
        assumed to be longer then PWLEN long
    pfDenied - updated with deny access status for this match on success
        TRUE if access is denied for this match, otherwise FALSE

Return Value:

    TRUE if successful, FALSE on error
    Errors:
        ERROR_ARENA_TRASHED if rule internal state is invalid
        ERROR_INVALID_NAME if no match

--*/
{
    UINT    i;
    UINT    iMax;
    DWORD   cObjLen;
    DWORD   cMatch = 0;
    BOOL    fSt = FALSE;
    LPBYTE  pMatch = NULL;
    INT     iRet;
    BOOL    fCaseInsensitive;
    PCERT_RDN_ATTR * pAttrValues;
    DWORD   cAttrValues;
    DWORD   cAttr;
    PBYTE   pContent;
    BOOL    fConverted = FALSE;
    PBYTE   pConverted = NULL;

    if ( !m_fEnabled )
    {
        return FALSE;
    }

    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );

        return FALSE;
    }

    iMax = GetRuleElemCount();

    for ( i = 0 ; i < iMax ; ++i )
    {
        m_ElemsContent.GetEntry( i, &pMatch, &cMatch );
        --cMatch;
        
        if( ( pAttrValues = pC->GetSubField(
                (CERT_FIELD_ID)((UINT_PTR)m_ElemsField.GetPtr(i)),
                m_ElemsSubfield.GetEntry( i ), &cAttrValues ) ) != NULL )
        {
            fCaseInsensitive = (DWORD)((DWORD_PTR)m_ElemsFlags.GetPtr(i) & CMR_FLAGS_CASE_INSENSITIVE);

            for ( cAttr = 0;
                  cAttr < cAttrValues;
                  cAttr++ )
            {
                fConverted = FALSE;
            
                pContent = pAttrValues[ cAttr ]->Value.pbData;
                cObjLen = pAttrValues[ cAttr ]->Value.cbData;

                if ( pAttrValues[ cAttr ]->dwValueType == CERT_RDN_UNICODE_STRING )
                {
                    
                    cObjLen /= sizeof( WCHAR );
                    
                    //
                    // Convert UNICODE cert value to multibyte
                    //
                    
                    iRet = WideCharToMultiByte( CP_ACP,
                                                0,
                                                (WCHAR*) pContent,
                                                cObjLen,
                                                NULL,
                                                0,
                                                NULL,
                                                NULL );
                    if ( !iRet )
                    {
                        fSt = FALSE;
                        break;
                    }
                    
                    pConverted = (PBYTE) LocalAlloc( LPTR, iRet );
                    if ( pConverted == NULL )
                    {
                        fSt = FALSE;
                        break;
                    }
                    
                    iRet = WideCharToMultiByte( CP_ACP,
                                                0,
                                                (WCHAR*) pContent,
                                                cObjLen,
                                                (CHAR*) pConverted,
                                                iRet,
                                                NULL,
                                                NULL );
                    if ( !iRet )
                    {
                        fSt = FALSE;
                        LocalFree( pConverted );
                        break;
                    }
                    
                    fConverted = TRUE;
                    pContent = (PBYTE) pConverted;
                    cObjLen = iRet;
                }
                    
                switch ( pMatch[0] )
                {
                    case MATCH_ALL:
                        fSt = cObjLen == cMatch &&
                                ( fCaseInsensitive ?
                                    !_memicmp( pMatch+1, pContent, cObjLen ) :
                                    !memcmp( pMatch+1, pContent, cObjLen ) );
                        break;

                    case MATCH_FIRST:
                        fSt = cObjLen >= cMatch &&
                                ( fCaseInsensitive ?
                                    !_memicmp( pMatch+1, pContent, cMatch ) :
                                    !memcmp( pMatch+1, pContent, cMatch ) );
                        break;

                    case MATCH_LAST:
                        fSt = cObjLen >= cMatch &&
                                ( fCaseInsensitive ?
                                    !_memicmp( pMatch+1, pContent+cObjLen-cMatch, cMatch ) :
                                    !memcmp( pMatch+1, pContent+cObjLen-cMatch, cMatch ) );
                        break;

                    case MATCH_IN:
                        fSt = CertMapMemstr( pContent, cObjLen, pMatch + 1, cMatch, fCaseInsensitive ) != NULL;
                        break;

                    default:
                        fSt = FALSE;
                }
                
                if ( fConverted )
                {
                    LocalFree( pConverted );
                    pConverted = NULL;
                }

                if ( fSt )
                {
                    break;
                }
            }

            LocalFree( pAttrValues );
            pAttrValues = NULL;

            if ( !fSt )
            {
                break;
            }
        }
        else if ( cMatch )
        {
            // non empty rule on n/a subfield : stop looking other matches

            break;
        }
    }


    //
    // if client cert match, check issuers
    //

    if ( i == iMax )
    {
        fSt = TRUE;

        if ( fSt )
        {
            *pfDenied = m_fDenyAccess;

            if ( GetRuleAccount() != NULL && 
                 GetRulePassword() != NULL )
            {
                //
                // Truncate account and password
                // if they don't fit.
                // It will render the output data useless
                // but will prevent buffer overflow
                // if invalid too long accounts and pwds
                // happen to be stored in mappings
                strncpy( pszAcct, 
                         GetRuleAccount(),
                         UNLEN + IIS_DNLEN + 1 );
                pszAcct[ UNLEN + IIS_DNLEN + 1 ] =  '\0';
                strncpy( pszPwd, 
                         GetRulePassword(),
                         PWLEN );
                pszAcct[ PWLEN ] = '\0';
                
            }
            else
            {
                SetLastError( ERROR_INVALID_PARAMETER );
                fSt = FALSE;
            }
        }

        return fSt;
    }

    SetLastError( ERROR_INVALID_NAME );

    return FALSE;
}


BOOL
CCertMapRule::GetRuleElem(
    DWORD           i,
    CERT_FIELD_ID*  pfiField,
    LPSTR*          ppContent,
    LPDWORD         pcContent,
    LPSTR*          ppSubField,
    LPDWORD         pdwFlags
    )
/*++

Routine Description:

    Access a rule element

Arguments:

    i - index ( 0-based ) of element to access
    pfiField - updated with CERT_FIELD_ID of this element
    ppContent - updated with ptr to match binary form
    pcContent - updated with length of match binary form
    ppSubField - updated with ASN.1 name of cert sub-field for match
    pdwFlags - updated with flags

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );

        return FALSE;
    }

    if ( (*ppSubField = m_ElemsSubfield.GetEntry( i )) != NULL &&
         m_ElemsContent.GetEntry( i, (LPBYTE*)ppContent, pcContent ) )
    {
        *pfiField = (CERT_FIELD_ID)((UINT_PTR)m_ElemsField.GetPtr( i ));
        if ( pdwFlags )
        {
            *pdwFlags = (DWORD)((DWORD_PTR)m_ElemsFlags.GetPtr( i ));
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
CCertMapRule::DeleteRuleElem(
    DWORD i
    )
/*++

Routine Description:

    Delete a rule element

Arguments:

    i - index ( 0-based ) of element to delete

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );
        return FALSE;
    }

    if ( m_ElemsContent.DeleteEntry( i ) &&
         m_ElemsSubfield.DeleteEntry( i ) &&
         m_ElemsField.DeletePtr( i ) &&
         m_ElemsFlags.DeletePtr( i ) )
    {
        return TRUE;
    }

    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertMapRule::DeleteRuleElemsByField(
    CERT_FIELD_ID fiField
    )
/*++

Routine Description:

    Delete rule elements based on CERT_FIELD_ID

Arguments:

    fiField - CERT_FIELD_ID of elements to delete

Return Value:

    TRUE if successful ( even if no element deleted ), FALSE on error

--*/
{
    UINT    i;
    UINT    iMax;

    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );

        return FALSE;
    }

    iMax = GetRuleElemCount();

    for ( i = 0 ; i < iMax ; ++i )
    {
        if ( fiField == (CERT_FIELD_ID)((UINT_PTR)m_ElemsField.GetPtr(i) ))
        {
            if ( !DeleteRuleElem( i ) )
            {
                m_fValid = FALSE;

                return FALSE;
            }
            --i;
        }
    }

    return TRUE;
}


DWORD
CCertMapRule::AddRuleElem(
    DWORD           iBefore,
    CERT_FIELD_ID   fiField,
    LPSTR           pszSubField,
    LPBYTE          pContent,
    DWORD           cContent,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Add a rule element

Arguments:

    iBefore - index ( 0-based ) of where to insert in list,
        0xffffffff to append to list
    fiField - CERT_FIELD_ID of this element
    pSubField - ASN.1 name of cert sub-field for match
    pContent - ptr to match binary form
    cContent - length of match binary form
    dwFlags - flags ( CMR_FLAGS_* )

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( !m_fValid )
    {
        SetLastError( ERROR_ARENA_TRASHED );
        return FALSE;
    }

    if ( m_ElemsContent.InsertEntry( iBefore, (LPSTR)pContent, cContent ) != INDEX_ERROR &&
         m_ElemsSubfield.InsertEntry( iBefore, pszSubField )  != INDEX_ERROR &&
         m_ElemsField.InsertPtr( iBefore, (LPVOID)fiField ) != INDEX_ERROR &&
         m_ElemsFlags.InsertPtr( iBefore, ULongToPtr(dwFlags) ) != INDEX_ERROR )
    {
        return TRUE;
    }

    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertMapRule::GetIssuerEntry(
    DWORD   i,
    LPBOOL  pfS,
    LPSTR*  ppszI
    )
/*++

Routine Description:

    Get issuer entry from issuer list

Arguments:

    i - index ( 0-based ) of element to delete
    pfS - updated with issuer accept status
    ppszI - updated with ptr to issuer ID

Return Value:

    TRUE if successful ( even if no element deleted ), FALSE on error

--*/
{
    if ( i < m_Issuers.GetNbEntry() )
    {
        *ppszI = m_Issuers.GetEntry( i );
        *pfS = (BOOL) ((DWORD_PTR)m_IssuersAcceptStatus.GetPtr( i ));

        return TRUE;
    }

    return FALSE;
}


BOOL
CCertMapRule::GetIssuerEntryByName(
    LPSTR pszName,
    LPBOOL pfS
    )
/*++

Routine Description:

    Get issuer entry from issuer list

Arguments:

    pszName - issuer ID
    pfS - updated with issuer accept status

Return Value:

    TRUE if successful ( even if no element deleted ), FALSE on error

--*/
{
    UINT i;
    UINT iMx = m_Issuers.GetNbEntry();

    for ( i = 0 ; i < iMx ; ++i )
    {
        if ( !strcmp( m_Issuers.GetEntry( i ), pszName ) )
        {
            *pfS = (BOOL) ((DWORD_PTR)m_IssuersAcceptStatus.GetPtr( i ));

            return TRUE;
        }
    }

    return FALSE;
}


BOOL
CCertMapRule::SetIssuerEntryAcceptStatus(
    DWORD i,
    BOOL fAcceptStatus
    )
/*++

Routine Description:

    Set issuer entry accept status

Arguments:

    i - index ( 0-based ) of element to update
    fAcceptStatus - issuer accept status

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    return m_IssuersAcceptStatus.SetPtr( i, ULongToPtr(fAcceptStatus) );
}


BOOL
CCertMapRule::AddIssuerEntry(
    LPSTR pszName,
    BOOL fAcceptStatus
    )
/*++

Routine Description:

    Add issuer entry to issuer list

Arguments:

    pszName - issuer ID
    fAcceptStatus - issuer accept status

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    if ( m_Issuers.AddEntry( pszName ) != INDEX_ERROR &&
         m_IssuersAcceptStatus.AddPtr( ULongToPtr((ULONG)fAcceptStatus) ) != INDEX_ERROR )
    {
        return TRUE;
    }

    m_fValid = FALSE;

    return FALSE;
}


BOOL
CCertMapRule::DeleteIssuerEntry(
    DWORD i
    )
/*++

Routine Description:

    Delete an issuer entry

Arguments:

    i - index ( 0-based ) of element to delete

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( m_Issuers.DeleteEntry( i ) &&
         m_IssuersAcceptStatus.DeletePtr( i ) )
    {
        return TRUE;
    }

    return FALSE;
}


CIisRuleMapper::CIisRuleMapper(
    )
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_pRWLock = new CReaderWriterLock3();
    m_fValid = ( m_pRWLock != NULL );
}


CIisRuleMapper::~CIisRuleMapper(
    )
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    UINT i;
    UINT iMax = GetRuleCount();

    for ( i = 0 ; i < iMax ; ++i )
    {
        delete (CCertMapRule*)GetRule( i );
    }
    
    if ( m_pRWLock != NULL )
    {
        delete m_pRWLock;
        m_pRWLock = NULL;
    }
}


BOOL
CIisRuleMapper::Reset(
    )
/*++

Routine Description:

    Reset to default values

Arguments:

    None

Return Value:

    Nothing

--*/
{
    m_GlobalRuleInfo.Reset();

    UINT i;
    UINT iMax = GetRuleCount();

    for ( i = 0 ; i < iMax ; ++i )
    {
        delete (CCertMapRule*)GetRule( i );
    }

    m_Rules.Reset();

    m_fValid = TRUE;

    return TRUE;
}


VOID 
CIisRuleMapper::WriteLockRules()
{
    m_pRWLock->WriteLock();
}

VOID 
CIisRuleMapper::ReadLockRules()
{
    m_pRWLock->ReadLock();
}

VOID 
CIisRuleMapper::WriteUnlockRules()
{
    m_pRWLock->WriteUnlock();
}

VOID 
CIisRuleMapper::ReadUnlockRules()
{
    m_pRWLock->ReadUnlock();
}

BOOL
CIisRuleMapper::Unserialize(
    CStoreXBF* pX
    )
/*++

Routine Description:

    Unserialize rule mapper

Arguments:

    pX - CStoreXBF to unserialize from

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPBYTE pb = pX->GetBuff();
    DWORD  dw = pX->GetUsed();

    return Unserialize( &pb, &dw );
}


BOOL
CIisRuleMapper::Unserialize(
    LPBYTE*         ppb,
    LPDWORD         pc
    )
/*++

Routine Description:

    Unserialize rule mapper

Arguments:

    ppB - ptr to addr of buffer
    pC - ptr to byte count in buffer

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    DWORD           dwMx;
    CCertMapRule *  pR;
    DWORD           ir;
    UINT            i;
    BOOL            fSt = FALSE;

    WriteLockRules();
    Reset();

    if ( m_GlobalRuleInfo.UnserializeGlobalRuleInfo( ppb, pc ) &&
         ::Unserialize( ppb, pc, &dwMx ) )
    {
        fSt = TRUE;
        for ( i = 0 ; i < dwMx ; ++i )
        {
            if ( (pR = new CCertMapRule()) == NULL ||
                 (ir = m_Rules.AddPtr( (LPVOID)pR )) == INDEX_ERROR ||
                 !pR->Unserialize( ppb, pc ) )
            {
                fSt = FALSE;
                m_fValid = FALSE;
                if ( pR != NULL )
                {
                    delete pR;
                }
                break;
            }
        }
    }
    else
    {
        m_fValid = FALSE;
    }

    WriteUnlockRules();

    return fSt;
}

BOOL
CIisRuleMapper::Serialize(
    CStoreXBF*  psxSer
    )
/*++

Routine Description:

    Serialize all rules

Arguments:

    psxSer - ptr to CStoreXBF where to serialize

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    BOOL        fSt = FALSE;
    UINT        i;
    DWORD       dwMx;

    ReadLockRules();
    if ( m_fValid )
    {
        dwMx = m_Rules.GetNbPtr();
        if ( m_GlobalRuleInfo.SerializeGlobalRuleInfo( psxSer ) &&
             ::Serialize( psxSer, dwMx ) )
        {
            fSt = TRUE;
            for ( i = 0 ; i < dwMx ; ++i )
            {
                if ( !GetRule(i)->Serialize( psxSer ) )
                {
                    fSt = FALSE;

                    break;
                }
            }
        }
    }
    ReadUnlockRules();

    return fSt;
}



BOOL
CIisRuleMapper::DeleteRule(
    DWORD dwI
    )
/*++

Routine Description:

    Delete a rule

Arguments:

    dwI - index ( 0-based ) of rule to delete

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    if ( dwI < GetRuleCount() )
    {
        if ( m_Rules.DeletePtr( dwI ) &&
             m_GlobalRuleInfo.DeleteRuleById( dwI, TRUE ) )
        {
            return TRUE;
        }

        m_fValid = FALSE;
    }

    return FALSE;
}


DWORD
CIisRuleMapper::AddRule(
    )
/*++

Routine Description:

    Add an empty rule

Arguments:

    None

Return Value:

    index of added rule or INDEX_ERROR if error

--*/
{
    CCertMapRule *pR;
    DWORD i;

    if ( ( pR = new CCertMapRule() ) != NULL )
    {
        if ( (i = m_Rules.AddPtr( (LPVOID)pR )) != INDEX_ERROR )
        {
            if ( m_GlobalRuleInfo.AddRuleOrder() )
            {
                return i;
            }

            m_fValid = FALSE;

            /* INTRINSA suppress = leaks */
            return INDEX_ERROR;
        }

        m_fValid = FALSE;
        delete pR;
    }

    return INDEX_ERROR;
}


DWORD
CIisRuleMapper::AddRule(
    CCertMapRule *pR
    )
/*++

Routine Description:

    Add a rule

Arguments:

    pR - rule to add

Return Value:

    index of added rule or INDEX_ERROR if error

--*/
{
    DWORD i;

    if ( (i = m_Rules.AddPtr( (LPVOID)pR )) != INDEX_ERROR )
    {
        if ( m_GlobalRuleInfo.AddRuleOrder() )
        {
            return i;
        }
    }

    m_fValid = FALSE;

    return INDEX_ERROR;
}


BOOL
CIisRuleMapper::Match(
    PCERT_CONTEXT pCert,
    PCERT_CONTEXT pAuth,
    LPWSTR pszAcctW,
    LPWSTR pszPwdW
    )
/*++

Routine Description:

    Check if rule match certificate

    WARNING: must be called inside lock

Arguments:

    pCert - client cert
    pAuth - Certifying Authority or NULL if not recognized
    cbLen - ptr to DER encoded cert
    pszAcctW - updated with NT account on success,
        assumed to be at least UNLEN+IIS_DNLEN+1+1 long
    pszPwdW - updated with NT password on success,
        assumed to be at least PWLEN+1 long

Return Value:

    TRUE if successful, FALSE on error
    Errors:
        ERROR_ARENA_TRASHED if rule internal state is invalid
        ERROR_INVALID_NAME if no match
        ERROR_ACCESS_DENIED if match and denied access

--*/
{
    UINT            iR;
    UINT            iMax;
    LPDWORD         pdwOrder;
    CDecodedCert    dcCert( pCert );
    CDecodedCert    dcAuth( pAuth );
    BOOL            fSt = FALSE;
    BOOL            fDenied;
    CHAR            achAcct[ UNLEN + IIS_DNLEN + 1 + 1 ];
    CHAR            achPwd[ PWLEN + 1 ];

    ReadLockRules();

    if ( !IsValid() || !m_GlobalRuleInfo.IsValid() )
    {
        SetLastError( ERROR_ARENA_TRASHED );
        goto ex;
    }

    if ( !m_GlobalRuleInfo.GetRulesEnabled() )
    {
        SetLastError( ERROR_INVALID_NAME );
        goto ex;
    }

    iMax = GetRuleCount();

    if ( iMax == 0 )
    {
        SetLastError( ERROR_INVALID_NAME );
        goto ex;
    }

    pdwOrder = m_GlobalRuleInfo.GetRuleOrderArray();

    for ( iR = 0 ; iR < iMax ; ++iR )
    {
        if ( ((CCertMapRule*)m_Rules.GetPtr(pdwOrder[iR]))->Match(
                &dcCert, &dcAuth, achAcct, achPwd, &fDenied ) )
        {
            if ( fDenied )
            {
                SetLastError( ERROR_ACCESS_DENIED );
                fSt = FALSE;
            }
            else
            {
                fSt = TRUE;
            }

            break;
        }
    }
ex:
    ReadUnlockRules();

    if ( fSt )
    {

        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   achAcct,
                                   -1,
                                   pszAcctW,
                                   UNLEN+IIS_DNLEN+1+1 ) )
        {
            return FALSE;
        }

        if ( !MultiByteToWideChar( CP_ACP,
                                   MB_PRECOMPOSED,
                                   achPwd,
                                   -1,
                                   pszPwdW,
                                   PWLEN+1 ) )
        {
            return FALSE;
        }
    }

    return fSt;
}


CERT_FIELD_ID
MapFieldToId(
    LPSTR pField
    )
/*++

Routine Description:

    Map field name ( "Issuer", ... ) to ID

Arguments:

    pField - field name

Return Value:

    CERT_FIELD_ID of field or CERT_FIELD_ERROR if error

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapField)/sizeof(MAP_FIELD) ; ++x )
    {
        if ( !_stricmp( pField, aMapField[x].pTextName ) )
        {
            return aMapField[x].dwId;
        }
    }

    return CERT_FIELD_ERROR;
}


LPSTR
MapIdToField(
    CERT_FIELD_ID   dwId
    )
/*++

Routine Description:

    Map ID to field name ( "Issuer", ... )

Arguments:

    dwId - field ID

Return Value:

    TRUE if successful, FALSE on error

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapField)/sizeof(MAP_FIELD) ; ++x )
    {
        if ( dwId == aMapField[x].dwId )
        {
            return aMapField[x].pTextName;
        }
    }

    return NULL;
}


DWORD
GetIdFlags(
    CERT_FIELD_ID   dwId
    )
/*++

Routine Description:

    Get flags for specified ID

Arguments:

    dwId - field ID

Return Value:

    ID flags if success, otherwise 0xffffffff

--*/
{
    if ( dwId < CERT_FIELD_LAST )
    {
        return adwFieldFlags[dwId];
    }

    return 0xffffffff;
}


LPSTR
MapSubFieldToAsn1(
    LPSTR pszSubField
    )
/*++

Routine Description:

    Map field name ( "OU", ... ) to ASN.1 name

Arguments:

    pszSubField - subfield name

Return Value:

    ptr to ASN.1 name or NULL if error

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++x )
    {
        if ( !strcmp( pszSubField, aMapAsn[x].pTextName ) )
        {
            return aMapAsn[x].pAsnName;
        }
    }

    return NULL;
}


LPSTR
MapAsn1ToSubField(
    LPSTR pszAsn1
    )
/*++

Routine Description:

    Map ID to field name ( "OU", ... )

Arguments:

    pszAsn1 - ASN.1 name

Return Value:

    sub field name or ASN.1 name if conversion not found

--*/
{
    UINT x;
    for ( x = 0 ; x < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++x )
    {
        if ( !strcmp( pszAsn1, aMapAsn[x].pAsnName ) )
        {
            return aMapAsn[x].pTextName;
        }
    }

    return pszAsn1;
}


LPSTR
EnumerateKnownSubFields(
    DWORD dwIndex
    )
/*++

Routine Description:

    Get subfield name from index (0-based )

Arguments:

    dwIndex - enumerator ( 0-based )

Return Value:

    sub field name or NULL if no more subfields

--*/
{
    if ( dwIndex < sizeof(aMapAsn)/sizeof(MAP_ASN) )
    {
        return aMapAsn[dwIndex].pTextName;
    }

    return NULL;
}


VOID
InitializeWildcardMapping(
    HANDLE hModule
    )
/*++

Routine Description:

    Initialize wildcard mapping

Arguments:

    hModule - module handle of this DLL

Return Value:

    Nothing

--*/
{
    if ( ( hCapi2Lib = LoadLibrary("crypt32.dll") ) != NULL )
    {
        pfnCryptDecodeObject = (PFNCryptDecodeObject)GetProcAddress(hCapi2Lib, "CryptDecodeObject");
    }

    LPVOID  p;
    UINT    i;
    UINT    l;
    CHAR    achTmp[128];

    for ( i = 0 ; i < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++ i )
    {
        if ( (l = LoadString( (HINSTANCE)hModule, aMapAsn[i].dwResId, achTmp, sizeof(achTmp) )) == NULL ||
             (p = LocalAlloc( LMEM_FIXED, l+1 )) == NULL )
        {
            p = (LPVOID)"";
        }
        else
        {
            memcpy( p, achTmp, l+1 );
        }

        aMapAsn[i].pTextName = (LPSTR)p;
    }

    for ( i = 0 ; i < sizeof(aMapField)/sizeof(MAP_FIELD) ; ++ i )
    {
        if ( (l = LoadString( (HINSTANCE)hModule, aMapField[i].dwResId, achTmp, sizeof(achTmp) )) == NULL ||
             (p = LocalAlloc( LMEM_FIXED, l+1 )) == NULL )
        {
            p = (LPVOID)"";
        }
        else
        {
            memcpy( p, achTmp, l+1 );
        }

        aMapField[i].pTextName = (LPSTR)p;
    }
}


VOID
TerminateWildcardMapping(
    )
/*++

Routine Description:

    Terminate wildcard mapping

Arguments:

    None

Return Value:

    Nothing

--*/
{
    UINT    i;

    if ( hCapi2Lib != NULL )
    {
        FreeLibrary( hCapi2Lib );
    }

    for ( i = 0 ; i < sizeof(aMapAsn)/sizeof(MAP_ASN) ; ++ i )
    {
        if ( aMapAsn[i].pTextName[0] )
        {
            LocalFree( aMapAsn[i].pTextName );
        }
    }

    for ( i = 0 ; i < sizeof(aMapField)/sizeof(MAP_FIELD) ; ++ i )
    {
        if ( aMapField[i].pTextName[0] )
        {
            LocalFree( aMapField[i].pTextName );
        }
    }
}


BOOL
MatchRequestToBinary(
    LPSTR pszReq,
    LPBYTE* ppbBin,
    LPDWORD pdwBin )
/*++

Routine Description:

    Convert from match request user format ( e.g. "*msft*"
    to internal binary format

Arguments:

    pszReq - match in user format
    ppbBin - updated with ptr to alloced binary format,
        to be freed by calling FreeMatchConversion()
    pdwBin - updated with binary format length

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    LPSTR       pReq;
    DWORD       cReq;
    LPBYTE      pBin;
    MATCH_TYPES mt;

    if ( !pszReq)
    {
        *ppbBin = NULL;
        *pdwBin = 0;

        return FALSE;
    }

    pReq = pszReq;
    cReq = (DWORD) strlen( pReq );

    if ( !cReq )
    {
        mt = MATCH_ALL;
    }
    else
    {
        if ( pReq[0] == '*' )
        {
            if ( pReq[cReq-1] == '*' && cReq > 1 )
            {
                mt = MATCH_IN;
                cReq -= 2;
            }
            else
            {
                mt = MATCH_LAST;
                cReq -= 1;
            }
            ++pReq;
        }
        else if ( pReq[cReq-1] == '*' )
        {
            mt = MATCH_FIRST;
            cReq -= 1;
        }
        else
        {
            mt = MATCH_ALL;
        }
    }

    if ( (pBin = (LPBYTE)LocalAlloc( LMEM_FIXED, cReq + 1 )) == NULL )
    {
        return FALSE;
    }

    pBin[0] = (BYTE)mt;
    memcpy( pBin+1, pReq, cReq );

    *ppbBin = pBin;
    *pdwBin = cReq + 1;

    return TRUE;
}


BOOL
BinaryToMatchRequest(
    LPBYTE pbBin,
    DWORD dwBin,
    LPSTR* ppszReq
    )
/*++

Routine Description:

    Convert from internal binary format to
    match request user format ( e.g. "*msft*"

Arguments:

    pbBin - ptr to binary format,
    dwBin - binary format length
    ppszReq - updated with ptr to alloced match in user format
        to be freed by calling FreeMatchConversion()

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    BOOL    fPre;
    BOOL    fPost;
    UINT    cMatch = dwBin + 1;
    LPSTR   pMatch;

    if ( !pbBin || !dwBin )
    {
        *ppszReq = NULL;

        return FALSE;
    }

    switch ( (MATCH_TYPES)(UINT)pbBin[0] )
    {
        case MATCH_ALL:
            fPre = FALSE;
            fPost = FALSE;
            break;

        case MATCH_LAST:
            fPre = TRUE;
            fPost = FALSE;
            ++cMatch;
            break;

        case MATCH_FIRST:
            fPre = FALSE;
            fPost = TRUE;
            ++cMatch;
            break;

        case MATCH_IN:
            fPre = TRUE;
            fPost = TRUE;
            cMatch += 2;
            break;

        default:
            return FALSE;
    }

    if ( (pMatch = (LPSTR)LocalAlloc( LMEM_FIXED, cMatch )) == NULL )
    {
        return FALSE;
    }

    *ppszReq = pMatch;

    if ( fPre )
    {
        *pMatch++ = '*';
    }

    DBG_ASSERT( cMatch >= dwBin - 1 );
    memcpy( pMatch, pbBin + 1, dwBin - 1 );
    pMatch += dwBin - 1;

    if ( fPost )
    {
        *pMatch++ = '*';
    }

    *pMatch = '\0';

    return TRUE;
}


VOID
FreeMatchConversion(
    LPVOID pvFree
    )
/*++

Routine Description:

    Free result of binary to/from user format conversion

Arguments:

    pvFree - buffer to free

Return Value:

    Nothing

--*/
{
    if ( pvFree != NULL )
    {
        LocalFree( pvFree );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\iismap\iismap.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    iismap.cxx

Abstract:

    Classes implementing IIS 1to1 Client Certificate Mapping

Author:

    Philippe Choquier (phillich)    17-may-1996

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wincrypt.h>


#include <iis64.h>
#include <buffer.hxx>
#define DLL_IMPLEMENTATION
#include <iismap.hxx>
#include "iismaprc.h"
#include "mapmsg.h"
#include "iiscmr.hxx"

#include <icrypt.hxx>
#include "dbgutil.h"

#define INITGUID
#include <ole2.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include <iiscnfgp.h>
#include "simplemb.hxx"

#include <stringau.hxx>

//
// static vars
//

//
// Guid that is part of the *.MP file name
// MP file stores 1to1 mappings information
//
DWORD s_dwFileGuid = 0;

//
// Install path of IIS -> *.MP file is placed in the same directory
// as IIS files
//
LPSTR s_pszIisInstallPath = NULL;

DECLARE_DEBUG_PRINTS_OBJECT();

//
// global functions
//


HRESULT
GetSecurityDescriptorForMetabaseExtensionFile( 
    PSECURITY_DESCRIPTOR * ppsdStorage 
    )
/*++

Routine Description:

    Build security descriptor that will be set for the extension file
    *.mp (includes Administrators and System )
    
Arguments:

    ppsdStorage - Security Descriptor to be set for extension file

Returns:
    HRESULT
--*/

{
    HRESULT                  hr = ERROR_SUCCESS;
    BOOL                     fRet = FALSE;
    DWORD                    dwDaclSize = 0;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;
    
    PSID                     psidSystem = NULL;
    PSID                     psidAdmin = NULL;
    PACL                     paclDiscretionary = NULL;
    
    DBG_ASSERT( ppsdStorage != NULL );
    
        *ppsdStorage = (PSECURITY_DESCRIPTOR) LocalAlloc(LPTR, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if ( *ppsdStorage == NULL ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        //
        // Initialize the security descriptor.
        //

        fRet = InitializeSecurityDescriptor(
                     *ppsdStorage,
                     SECURITY_DESCRIPTOR_REVISION
                     );

        if( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        //
        // Create the SIDs for the local system and admin group.
        //

        fRet = AllocateAndInitializeSid(
                     &ntAuthority,
                     1,
                     SECURITY_LOCAL_SYSTEM_RID,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &psidSystem
                     );

        if( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }
        
        fRet=  AllocateAndInitializeSid(
                     &ntAuthority,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0,
                     0,
                     0,
                     0,
                     0,
                     0,
                     &psidAdmin
                     );

        if( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        //
        // Create the DACL containing an access-allowed ACE
        // for the local system and admin SIDs.
        //

        dwDaclSize = sizeof(ACL)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(psidAdmin)
                       + sizeof(ACCESS_ALLOWED_ACE)
                       + GetLengthSid(psidSystem)
                       - sizeof(DWORD);

        paclDiscretionary = (PACL)LocalAlloc(LPTR, dwDaclSize );

        if ( paclDiscretionary == NULL ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        fRet = InitializeAcl(
                     paclDiscretionary,
                     dwDaclSize,
                     ACL_REVISION
                     );

        if( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        fRet = AddAccessAllowedAce(
                     paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     psidSystem
                     );

        if ( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        fRet = AddAccessAllowedAce(
                     paclDiscretionary,
                     ACL_REVISION,
                     FILE_ALL_ACCESS,
                     psidAdmin
                     );

        if ( !fRet ) 
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;
        }

        //
        // Set the DACL into the security descriptor.
        //

        fRet = SetSecurityDescriptorDacl(
                     *ppsdStorage,
                     TRUE,
                     paclDiscretionary,
                     FALSE
                     );

        if ( !fRet ) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto exit;

        }

    hr = S_OK;
    
exit:

    if ( psidAdmin != NULL ) 
    {
        FreeSid( psidAdmin );
        psidAdmin = NULL;
    }

    if ( psidSystem != NULL ) 
    {
        FreeSid( psidSystem );
        psidSystem = NULL;
    }

    if ( FAILED( hr ) ) {
        if ( paclDiscretionary != NULL ) 
        {
            LocalFree( paclDiscretionary );
            paclDiscretionary = NULL;
        }

        if ( *ppsdStorage != NULL ) 
        {
            LocalFree( *ppsdStorage );
            *ppsdStorage = NULL;
        }
    }

    return hr;

}

HRESULT
FreeSecurityDescriptorForMetabaseExtensionFile(
    PSECURITY_DESCRIPTOR psdStorage 
    )
/*++

Routine Description:

    Free security descriptor generated by
        GetSecurityDescriptorForMetabaseExtentionFile()
    
Arguments:

    psdStorage - Security Descriptor to be freed

Returns:
    HRESULT
--*/
    
{
    HRESULT     hr = ERROR_SUCCESS;
    BOOL        fRet = FALSE;
    BOOL        fDaclPresent;
    PACL        paclDiscretionary = NULL;
    BOOL        fDaclDefaulted;
        
    //
    // Get the DACL from the security descriptor.
    //

    if ( psdStorage == NULL )
    {
        hr = S_OK;
        goto exit;
    }

    fRet = GetSecurityDescriptorDacl(
                 psdStorage,
                 &fDaclPresent,
                 &paclDiscretionary,
                 &fDaclDefaulted
                 );

    if ( !fRet ) 
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto exit;
    }
        
    if ( fDaclPresent && paclDiscretionary != NULL )
    {
        LocalFree( paclDiscretionary );
        paclDiscretionary = NULL;
    }

    LocalFree( psdStorage );

    hr = S_OK;
    
exit:

    return hr;
}


//
// Fields for the Certificate 1:1 mapper
//

IISMDB_Fields IisCert11MappingFields[] = {
    // certificate blob
    {IISMDB_INDEX_CERT11_CERT, NULL, IDS_IISMAP11_FLDC, 40 },
    // NT account name
    {IISMDB_INDEX_CERT11_NT_ACCT, NULL, IDS_IISMAP11_FLDA, 40 },
    // mapping name    
    {IISMDB_INDEX_CERT11_NAME, NULL, IDS_IISMAP11_FLDN, 40 },
    // mapping enabled    
    {IISMDB_INDEX_CERT11_ENABLED, NULL, IDS_IISMAP11_FLDE, 40 },
    // NT account password
    {IISMDB_INDEX_CERT11_NT_PWD, NULL, IDS_IISMAP11_FLDP, 40 },
} ;

//
// default hierarchy for the Certificate 1:1 mapper
// This is basically list of fields that are used for
// mapping comparison
// 1 to 1 mapper uses only CERTIFICATE BLOB
//

IISMDB_HEntry IisCert11MappingHierarchy[] = {
    {IISMDB_INDEX_CERT11_CERT, TRUE},
} ;


HINSTANCE s_hIISMapDll = (HINSTANCE)INVALID_HANDLE_VALUE;

// CIisAcctMapper

CIisAcctMapper::CIisAcctMapper(
    )
/*++

Routine Description:

    Constructor for CIisAcctMapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_cInit = -1;

    m_pMapping = NULL;
    m_cMapping = 0;

    m_pAltMapping = NULL;
    m_cAltMapping = 0;

    m_pHierarchy = NULL;
    m_cHierarchy = 0;

    m_achFileName[0] = '\0';

    m_pClasses = NULL;
    m_pSesKey = NULL;
    m_dwSesKey = 0;

    m_hNotifyEvent = NULL;
    m_fRequestTerminate = FALSE;

    INITIALIZE_CRITICAL_SECTION( &csLock );
}


CIisAcctMapper::~CIisAcctMapper(
    )
/*++

Routine Description:

    Destructor for CIisAcctMapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    Reset();

    if ( m_pHierarchy != NULL )
    {
        LocalFree( m_pHierarchy );
    }

    if ( m_pSesKey != NULL )
    {
        LocalFree( m_pSesKey );
    }

    DeleteCriticalSection( &csLock );
}

BOOL
CIisAcctMapper::Create(
    VOID
    )
/*++

Routine Description:

    Create file for CIisAcctMapper with proper SD

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    // create file name, store in m_achFileName
    // from s_dwFileGuid
    // and s_pszIisInstallPath

    UINT    cLen;
    HANDLE  hF;
    HRESULT hr = E_FAIL;
    BOOL    fRet = FALSE;
    PSECURITY_DESCRIPTOR psdForMetabaseExtensionFile = NULL;
    SECURITY_ATTRIBUTES  saStorage;

    // calculate the max # of characters that m_achFileName can take
    DWORD cchMaxFileName = sizeof ( m_achFileName ) / sizeof (CHAR)  - 1;

    Reset();

    if ( s_pszIisInstallPath )
    {
        cLen = (DWORD) strlen(s_pszIisInstallPath);
        
        if ( cchMaxFileName < cLen )
        {
            return FALSE;
        }            
        memcpy( m_achFileName, s_pszIisInstallPath, cLen );

        // if path is not terminated by "\" then add one
        if ( cLen && m_achFileName[cLen-1] != '\\' )
        {
            if ( cchMaxFileName < cLen + 1 )
            {
                return FALSE;
            }
            m_achFileName[cLen++] = '\\';
        }
    }
    else
    {
        cLen = 0;
    }


    if( sizeof(m_achFileName) - cLen > 8 + 3 /*%08x.mp*/ )
    {
        wsprintf( m_achFileName+cLen, 
                  "%08x.mp", 
                  s_dwFileGuid );
    }
    else
    {
        //
        // buffer m_achFileName is not sufficiently big
        //
        return FALSE;
    }
    
    //
    // build security descriptor (Administrators and SYSTEM)
    // to be set on metabase extension file
    //
    
    hr = GetSecurityDescriptorForMetabaseExtensionFile( 
                    &psdForMetabaseExtensionFile );
    
    if ( SUCCEEDED(hr) && psdForMetabaseExtensionFile != NULL ) 
    {
        saStorage.nLength = sizeof(SECURITY_ATTRIBUTES);
        saStorage.lpSecurityDescriptor = psdForMetabaseExtensionFile;
        saStorage.bInheritHandle = FALSE;
    }
    else
    {
        return FALSE;
    }
    //
    // Open file and close it right away
    // If file didn't exist, then empty file with good SD (Security Descriptor)
    // will be created. That will later be opened using C runtime (fopen) 
    // in Save() method and good SD will persist.
    // Ideally Save() should be using Win32 CreateFile()
    // instead fopen and it could set SD itself. But since this is legacy
    // source file and rather unsafe for making too many changes, pragmatic
    // approach was chosen to set SD here in Create() method
    //
    
    if ( (hF = CreateFile( m_achFileName,
                           GENERIC_READ,
                           FILE_SHARE_READ|FILE_SHARE_WRITE,
                           &saStorage,
                           OPEN_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL ) ) != INVALID_HANDLE_VALUE )
    {
        CloseHandle( hF );
        fRet = TRUE;
    }
    else
    {
        fRet = FALSE;
    }

    if ( psdForMetabaseExtensionFile != NULL ) 
    {
        FreeSecurityDescriptorForMetabaseExtensionFile( 
                psdForMetabaseExtensionFile );
        psdForMetabaseExtensionFile = NULL;
    }
    return fRet;

}


BOOL
CIisAcctMapper::Delete(
    VOID
    )
/*++

Routine Description:

    Delete external storage used by this mapper ( i.e. file )

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;

    Lock();

    if ( m_achFileName[0] )
    {
        fSt = DeleteFile( m_achFileName );
        m_achFileName[0] = '\0';
    }

    Unlock();

    return fSt;
}


BOOL
CIisAcctMapper::Serialize(
    CStoreXBF* pXbf
    )
/*++

Routine Description:

    Serialize mapper reference ( NOT mapping info ) to buffer
    Save() must be called to save mapping info before calling Serialize()

Arguments:

    pXbf - ptr to extensible buffer to serialize to

Returns:

    TRUE if success, FALSE if error

--*/
{
    return pXbf->Append( (DWORD)strlen(m_achFileName) ) &&
           pXbf->Append( (LPBYTE)m_achFileName, (DWORD)strlen(m_achFileName) ) &&
           pXbf->Append( (LPBYTE)m_md5.digest, (DWORD)sizeof(m_md5.digest) ) &&
           pXbf->Append( (DWORD)m_dwSesKey ) &&
           pXbf->Append( (LPBYTE)m_pSesKey, (DWORD)m_dwSesKey ) ;
}


BOOL
CIisAcctMapper::Unserialize(
    CStoreXBF* pXBF
    )
/*++

Routine Description:

    Unserialize mapper reference ( NOT mapping info ) from extensible buffer
    Load() must be called to load mapping info

Arguments:

    pXBF - ptr to extensible buffer

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPBYTE pb = pXBF->GetBuff();
    DWORD c = pXBF->GetUsed();

    return Unserialize( &pb, &c );
}


BOOL
CIisAcctMapper::Unserialize(
    LPBYTE* ppb,
    LPDWORD pc
    )
/*++

Routine Description:

    Unserialize mapper reference ( NOT mapping info ) from buffer
    Load() must be called to load mapping info

Arguments:

    ppb - ptr to buffer
    pc - ptr to buffer length

Returns:

    TRUE if success, FALSE if error

--*/
{
    DWORD cName;

    

    if ( ::Unserialize( ppb, pc, &cName ) &&
         cName <= *pc )
    {
        // calculate the max # of characters that m_achFileName can take
        DWORD cchMaxFileName = sizeof ( m_achFileName ) / sizeof (CHAR) - 1;

        if ( cchMaxFileName < cName )
        {
            return FALSE;
        }
        memcpy( m_achFileName, *ppb, cName );
        m_achFileName[ cName ] = '\0';
        *ppb += cName;
        *pc -= cName;
        if ( sizeof(m_md5.digest) <= *pc )
        {
            memcpy( m_md5.digest, *ppb, sizeof(m_md5.digest) );
            *ppb += sizeof(m_md5.digest);
            *pc -= sizeof(m_md5.digest);

            if ( ::Unserialize( ppb, pc, &m_dwSesKey ) &&
                 cName <= *pc )
            {
                if ( m_pSesKey != NULL )
                {
                    LocalFree( m_pSesKey );
                }

                if ( (m_pSesKey = (LPBYTE)LocalAlloc( LMEM_FIXED, m_dwSesKey )) == NULL )
                {
                    m_dwSesKey = 0;
                    return FALSE;
                }
                memcpy( m_pSesKey, *ppb, m_dwSesKey );
                *ppb += m_dwSesKey;
                *pc -= m_dwSesKey;

                return TRUE;
            }
        }
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Serialize(
    VOID
    )
/*++

Routine Description:

    Serialize mapper reference ( NOT mapping info ) to registry
    Save() must be called to save mapping info before calling Serialize()
    Warning : this allow only 1 instance

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL    fSt = TRUE;
    HKEY    hKey;
    LONG    st;

    if ( (st = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
            GetRegKeyName(),
            0,
            KEY_WRITE,
            &hKey )) != ERROR_SUCCESS )
    {
        SetLastError( st );
        return FALSE;
    }

    if ( RegSetValueEx( hKey,
                         FILE_VALIDATOR,
                         NULL,
                         REG_BINARY,
                         (LPBYTE)m_md5.digest,
                         sizeof(m_md5.digest) ) != ERROR_SUCCESS ||
         RegSetValueEx( hKey,
                         FILE_LOCATION,
                         NULL,
                         REG_SZ,
                         (LPBYTE)m_achFileName,
                         (DWORD) strlen(m_achFileName) ) != ERROR_SUCCESS )
    {
        fSt = FALSE;
    }

    RegCloseKey( hKey );

    return fSt;
}


BOOL
CIisAcctMapper::Unserialize(
    VOID
    )
/*++

Routine Description:

    Unserialize mapper reference ( NOT mapping info ) From registry
    Load() must be called to load mapping info
    Warning : this allow only 1 instance

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL    fSt = FALSE;
    HKEY    hKey;
    DWORD   dwLen;
    DWORD   dwType;
    LONG    st;

    // Check registry

    if ( (st = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
            GetRegKeyName(),
            0,
            KEY_READ,
            &hKey )) != ERROR_SUCCESS )
    {
        SetLastError( st );
        return FALSE;
    }

    dwLen = sizeof(m_md5.digest);

    if ( RegQueryValueEx( hKey,
                          FILE_VALIDATOR,
                          NULL,
                          &dwType,
                          (LPBYTE)m_md5.digest,
                          &dwLen ) == ERROR_SUCCESS &&
         dwType == REG_BINARY &&
         (( dwLen = sizeof(m_achFileName) ), TRUE ) &&
         RegQueryValueEx( hKey,
                          FILE_LOCATION,
                          NULL,
                          &dwType,
                          (LPBYTE)m_achFileName,
                          &dwLen ) == ERROR_SUCCESS &&
         dwType == REG_SZ )
    {
        fSt = TRUE;
    }

    RegCloseKey( hKey );

    return fSt;
}


BOOL
CIisAcctMapper::UpdateClasses(
    BOOL fComputeMask
    )
/*++

Routine Description:

    Constructor for CIisAcctMapper

Arguments:

    fComputeMask -- TRUE if mask to be recomputed

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;
    UINT mx = 1 << m_cHierarchy;

    if ( fComputeMask )
    {
        for ( x = 0 ; x < m_cMapping ; ++x )
        {
            m_pMapping[x]->UpdateMask( m_pHierarchy, m_cHierarchy );
        }
    }

    SortMappings();

    if ( m_pClasses == NULL )
    {
        m_pClasses = (MappingClass*)LocalAlloc(
                LMEM_FIXED,
                sizeof(MappingClass)*(mx+1) );
        if ( m_pClasses == NULL )
        {
            return FALSE;
        }
    }

    DWORD dwN = 0;          // current class index in m_pClasses
    DWORD dwLastClass = 0;
    DWORD dwFirst = 0;  // first entry for current dwLastClass
    for ( x = 0 ; x <= m_cMapping ; ++x )
    {
        DWORD dwCur;
        dwCur = (x==m_cMapping) ? dwLastClass+1: m_pMapping[x]->GetMask();
        if ( dwCur > dwLastClass )
        {
            if ( x > dwFirst )
            {
                m_pClasses[dwN].dwClass = dwLastClass;
                m_pClasses[dwN].dwFirst = dwFirst;
                m_pClasses[dwN].dwLast = x - 1;
                ++dwN;
            }
            dwLastClass = dwCur;
            dwFirst = x;
        }
    }

    m_pClasses[dwN].dwClass = 0xffffffff;

    return TRUE;
}


//static
int __cdecl
CIisAcctMapper::QsortIisMappingCmp(
    const void *pA,
    const void *pB )
/*++

Routine Description:

    Compare function for 2 CIisMapping entries
    compare using mask, then all fields as defined in
    the linked CIisAcctMapper hierarchy

Arguments:

    pA -- ptr to 1st element
    pB -- ptr tp 2nd elemet

Returns:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB

--*/
{
    return (*(CIisMapping**)pA)->Cmp( *(CIisMapping**)pB, FALSE );
}


BOOL
CIisAcctMapper::SortMappings(
    )
/*++

Routine Description:

    Sort the mappings. Masks for mapping objects are assumed
    to be already computed.

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    qsort( (LPVOID)m_pMapping,
           m_cMapping,
           sizeof(CIisMapping*),
           QsortIisMappingCmp
           );

    return TRUE;
}

//static
int __cdecl
CIisAcctMapper::MatchIisMappingCmp(
    const void *pA,
    const void *pB 
    )
/*++

Routine Description:

    Compare function for 2 CIisMapping entries
    do not uses mask, uses all fields as defined in
    the linked CIisAcctMapper hierarchy

    (used by CIisAcctMapper::FindMatch() )

Arguments:

    pA -- ptr to 1st element
    pB -- ptr tp 2nd elemet

Returns:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB

--*/
{
    return ( *(CIisMapping**)pA)->Cmp( *(CIisMapping**)pB, TRUE );
}



BOOL
CIisAcctMapper::FindMatch(
    CIisMapping* pQuery,
    CIisMapping** pResult,
    LPDWORD piResult
    )
/*++

Routine Description:

    Find a match base on field contents in CIisMapping

Arguments:

    pQuery -- describe fields to consider for mapping
    pResult -- updated with result if found mapping

Returns:

    TRUE if mapping found, else FALSE

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    // iterate through classes, do bsearch on each

    MappingClass *pH = m_pClasses;

    if ( pH == NULL )
    {
        return FALSE;
    }

    while ( pH->dwClass != 0xffffffff )
    {
        CIisMapping **pRes = (CIisMapping **)bsearch( (LPVOID)&pQuery,
                                     (LPVOID)(m_pMapping+pH->dwFirst),
                                     pH->dwLast - pH->dwFirst + 1,
                                     sizeof(CIisMapping*),
                                     MatchIisMappingCmp );
        if ( piResult != NULL )
        {
            *piResult = (DWORD) DIFF(pRes - m_pMapping);
        }

        if ( pRes != NULL )
        {
            *pResult = *pRes;
            return TRUE;
        }

        ++pH;
    }

    return FALSE;
}




void
CIisAcctMapper::Lock(
    )
/*++

Routine Description:

    Prevent access to mapper from other threads

Arguments:

    None

Returns:

    Nothing

--*/
{
    EnterCriticalSection( &csLock );
}


void
CIisAcctMapper::Unlock(
    )
/*++

Routine Description:

    Re-enabled access to mapper from other threads

Arguments:

    None

Returns:

    Nothing

--*/
{
    LeaveCriticalSection( &csLock );
}


BOOL
CIisAcctMapper::FlushAlternate(
    BOOL    fApply
    )
/*++

Routine Description:

    Flush alternate list, optionaly commiting it to the main list

Arguments:

    fApply -- TRUE to commit changes made in alternate list

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    UINT        i;
    UINT        iM;
    BOOL        fSt = TRUE;

    if ( m_pAltMapping )
    {
        if ( fApply )
        {
            //
            // Transfer non existing objects from regular to alternate list
            //

            iM = min( m_cMapping, m_cAltMapping );

            for ( i = 0 ; i < iM ; ++ i )
            {
                if ( m_pAltMapping[i] == NULL )
                {
                    m_pAltMapping[i] = m_pMapping[i];
                }
                else
                {
                    delete m_pMapping[i];
                }
            }

            //
            // delete extra objects
            //

            if ( m_cMapping > m_cAltMapping )
            {
                for ( i = m_cAltMapping ; i < m_cMapping ; ++i )
                {
                    delete m_pMapping[i];
                }
            }

            if ( m_pMapping )
            {
                LocalFree( m_pMapping );
            }

            m_pMapping = m_pAltMapping;
            m_cMapping = m_cAltMapping;

            fSt = UpdateClasses( TRUE );
        }
        else
        {
            for ( i = 0 ; i < m_cAltMapping ; ++i )
            {
                if ( m_pAltMapping[i] )
                {
                    delete m_pAltMapping[i];
                }
            }
            LocalFree( m_pAltMapping );
        }
    }

    m_pAltMapping = NULL;
    m_cAltMapping = 0;

    return fSt;
}


BOOL
CIisAcctMapper::GetMapping(
    DWORD           iIndex,
    CIisMapping**   pM,
    BOOL            fGetFromAlternate,
    BOOL            fPutOnAlternate
    )
/*++

Routine Description:

    Get mapping entry based on index

Arguments:

    iIndex -- index in mapping array
    pM -- updated with pointer to mapping. mapping object
          still owned by the mapper object.
    fGetFromAlternate -- TRUE if retrieve from alternate list
    fPutOnAlternate -- TRUE if put returned mapping on alternate list

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( fPutOnAlternate )
    {
        // create alternate list if not exist

        if ( !m_pAltMapping && m_cMapping )
        {
            m_pAltMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(m_cMapping) );
            if ( m_pAltMapping == NULL )
            {
                return FALSE;
            }

            ZeroMemory( m_pAltMapping, sizeof(CIisMapping*) * m_cMapping );

            m_cAltMapping = m_cMapping;
        }

        if ( iIndex < m_cAltMapping )
        {
            if ( m_pAltMapping[iIndex] == NULL &&
                 m_pMapping != NULL )   // work-around for compiler bug
            {
                // duplicate mapping to alternate list if not exist
                if ( m_pMapping[iIndex]->Clone( pM ) )
                {
                    m_pAltMapping[iIndex] = *pM;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                *pM = m_pAltMapping[iIndex];
            }
            return TRUE;
        }

        return FALSE;
    }

    if ( fGetFromAlternate &&
         m_pAltMapping &&
         iIndex < m_cAltMapping )
    {
        if ( m_pAltMapping[iIndex] )
        {
            *pM = m_pAltMapping[iIndex];
        }
        else
        {
            *pM = m_pMapping[iIndex];
        }

        return TRUE;
    }

    if ( iIndex < m_cMapping )
    {
        *pM = m_pMapping[iIndex];

        return TRUE;
    }

    return FALSE;
}

BOOL
CIisAcctMapper::Update(
    DWORD iIndex,
    CIisMapping* pM
    )
/*++

Routine Description:

    Update a mapping

Arguments:

    iIndex -- index in mapping array
    pM -- pointer to mapping.

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( iIndex < m_cMapping )
    {
        pM->UpdateMask( m_pHierarchy, m_cHierarchy);

        return m_pMapping[iIndex]->Copy( pM ) && UpdateClasses( FALSE );
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Update(
    DWORD iIndex
    )
/*++

Routine Description:

    Update a mapping

Arguments:

    iIndex -- index in mapping array

Returns:

    TRUE if success, FALSE if error

--*/
{
    if ( iIndex < m_cMapping )
    {
        return m_pMapping[iIndex]->UpdateMask( m_pHierarchy, m_cHierarchy);
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Add(
    CIisMapping*    pM,
    BOOL            fAlternate
    )
/*++

Routine Description:

    Add a mapping entry to mapping array
    Transfer ownership of mapping object to mapper

Arguments:

    pM -- pointer to mapping to be added to mapper
    fAlternate - TRUE if add to alternate list

Returns:

    TRUE if success, FALSE if error

--*/
{
    CIisMapping **pMapping;

    if ( fAlternate )
    {
        DWORD           dwC  = m_pAltMapping ? m_cAltMapping : m_cMapping;
        CIisMapping**   pMap = m_pAltMapping ? m_pAltMapping : m_pMapping;

        pMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(dwC+1) );
        if ( pMapping == NULL )
        {
            return FALSE;
        }

        if ( m_pAltMapping )
        {
            memcpy( pMapping, pMap, sizeof(CIisMapping*) * dwC );
            LocalFree( m_pAltMapping );
        }
        else
        {
            ZeroMemory( pMapping, sizeof(CIisMapping*)*(dwC+1) );
        }
        m_pAltMapping = pMapping;
        m_pAltMapping[dwC] = pM;
        m_cAltMapping = dwC + 1;

        return TRUE;
    }
    else
    {
        pMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(m_cMapping+1) );
        if ( pMapping == NULL )
        {
            return FALSE;
        }

        if ( m_pMapping )
        {
            memcpy( pMapping, m_pMapping, sizeof(CIisMapping*) * m_cMapping );
            LocalFree( m_pMapping );
        }
        m_pMapping = pMapping;
        pM->UpdateMask( m_pHierarchy, m_cHierarchy );
        m_pMapping[m_cMapping] = pM;
        ++m_cMapping;

        SortMappings();

        return UpdateClasses( FALSE );
    }
}


DWORD
CIisAcctMapper::AddEx(
    CIisMapping* pM
    )
/*++

Routine Description:

    Add a mapping entry to mapping array
    Transfer ownership of mapping object to mapper

Arguments:

    pM -- pointer to mapping to be added to mapper

Returns:

    Index of entry if success, otherwise 0xffffffff

--*/
{
    CIisMapping **pMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(m_cMapping+1) );
    if ( pMapping == NULL )
    {
        return 0xffffffff;
    }

    if ( m_pMapping )
    {
        memcpy( pMapping, m_pMapping, sizeof(CIisMapping*) * m_cMapping );
        LocalFree( m_pMapping );
    }
    m_pMapping = pMapping;
    pM->UpdateMask( m_pHierarchy, m_cHierarchy );
    m_pMapping[m_cMapping] = pM;
    ++m_cMapping;

    SortMappings();

    if ( UpdateClasses( FALSE ) )
    {
        return m_cMapping-1;
    }

    return 0xffffffff;
}


BOOL
CIisAcctMapper::Delete(
    DWORD   dwIndex,
    BOOL    fUseAlternate
    )
/*++

Routine Description:

    Delete a mapping entry based on index

Arguments:

    iIndex -- index in mapping array
    fUseAlternate -- TRUE if update alternate list

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT        i;
    UINT        iM;

    if ( fUseAlternate )
    {
        //
        // clone all entries from main to alternate list
        //

        if ( !m_pAltMapping )
        {
            m_pAltMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*(m_cMapping) );
            if ( m_pAltMapping == NULL )
            {
                return FALSE;
            }

            ZeroMemory( m_pAltMapping,  sizeof(CIisMapping*) * m_cMapping );
            m_cAltMapping = m_cMapping;
        }

        iM = min( m_cMapping, m_cAltMapping );

        for ( i = 0 ; i < iM ; ++i )
        {
            if ( m_pAltMapping[i] == NULL )
            {
                if ( !m_pMapping[i]->Clone( &m_pAltMapping[i] ) )
                {
                    return FALSE;
                }
            }
        }

        if ( dwIndex < m_cAltMapping )
        {
            delete m_pAltMapping[dwIndex];

            memmove( m_pAltMapping+dwIndex,
                     m_pAltMapping+dwIndex+1,
                     (m_cAltMapping - dwIndex - 1) * sizeof(CIisMapping*) );

            --m_cAltMapping;

            return TRUE;
        }

        return FALSE;
    }

    if ( dwIndex < m_cMapping )
    {
        delete m_pMapping[dwIndex];

        memmove( m_pMapping+dwIndex,
                 m_pMapping+dwIndex+1,
                 (m_cMapping - dwIndex - 1) * sizeof(CIisMapping*) );

        --m_cMapping;

        return UpdateClasses( FALSE );
    }

    return FALSE;
}


BOOL
CIisAcctMapper::Save(
    )
/*++

Routine Description:

    Save mapper ( mappings, hierarchy, derived class private data )
    to a file, updating registry entry with MD5 signature

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT    x;
    FILE *  fOut = NULL;
    BOOL    fSt = TRUE;
    DWORD   dwVal;
    IIS_CRYPTO_STORAGE  storage;
    PIIS_CRYPTO_BLOB    blob;

    Lock();

    MD5Init( &m_md5 );

    if ( FAILED(storage.Initialize()) )
    {
        fSt = FALSE;
        goto cleanup;
    }

    if ( m_pSesKey != NULL )
    {
        LocalFree( m_pSesKey );
        m_pSesKey = NULL;
        m_dwSesKey = 0;
    }
    if ( FAILED( storage.GetSessionKeyBlob( &blob ) ) ||
         blob == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }
    m_dwSesKey = IISCryptoGetBlobLength( blob );
    if ( (m_pSesKey = (LPBYTE)LocalAlloc( LMEM_FIXED, m_dwSesKey)) == NULL )
    {
        m_dwSesKey = 0;
        fSt = FALSE;
        goto cleanup;
    }
    memcpy( m_pSesKey, (LPBYTE)blob, m_dwSesKey );

    if ( (fOut = fopen( m_achFileName, "wb" )) == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    // magic value & version

    dwVal = IISMDB_FILE_MAGIC_VALUE;
    if( fwrite( (LPVOID)&dwVal, sizeof(dwVal), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }
    MD5Update( &m_md5, (LPBYTE)&dwVal, sizeof(dwVal) );

    dwVal = IISMDB_CURRENT_VERSION;
    if( fwrite( (LPVOID)&dwVal, sizeof(dwVal), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }
    MD5Update( &m_md5, (LPBYTE)&dwVal, sizeof(dwVal) );

    // mappings

    if( fwrite( (LPVOID)&m_cMapping, sizeof(m_cMapping), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &m_md5, (LPBYTE)&m_cMapping, sizeof(m_cMapping) );

    for ( x = 0 ; x < m_cMapping ; ++x )
    {
        if ( !m_pMapping[x]->Serialize( fOut ,(VALID_CTX)&m_md5, (LPVOID)&storage) )
        {
            fSt = FALSE;
            goto cleanup;
        }
    }

    // save hierarchy

    if( fwrite( (LPVOID)&m_cHierarchy, sizeof(m_cHierarchy), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &m_md5, (LPBYTE)&m_cHierarchy, sizeof(m_cHierarchy) );

    if( fwrite( (LPVOID)m_pHierarchy, sizeof(IISMDB_HEntry), m_cHierarchy, fOut ) != m_cHierarchy )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &m_md5, (LPBYTE)m_pHierarchy, sizeof(IISMDB_HEntry)*m_cHierarchy );

    // save private data

    fSt = SavePrivate( fOut, (VALID_CTX)&m_md5 );

    MD5Final( &m_md5 );

cleanup:
    if ( fOut != NULL )
    {
        fclose( fOut );
    }

    // update registry

    if ( !fSt )
    {
        ZeroMemory( m_md5.digest,  sizeof(m_md5.digest) );
    }

    Unlock();

    return fSt;
}


BOOL
CIisAcctMapper::Reset(
    )
/*++

Routine Description:

    Reset mapper to empty state

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    // free all mapping
    if ( m_pMapping != NULL )
    {
        for ( x = 0 ; x < m_cMapping ; ++x )
        {
            delete m_pMapping[x];
        }

        LocalFree( m_pMapping );
        m_pMapping = NULL;
    }
    m_cMapping = 0;

    if ( m_pClasses != NULL )
    {
        LocalFree( m_pClasses );
        m_pClasses = NULL;
    }

    // default hierarchy

    if ( m_pHierarchy == NULL )
    {
        IISMDB_HEntry *pH = GetDefaultHierarchy( &m_cHierarchy );
        m_pHierarchy = (IISMDB_HEntry*)LocalAlloc( LMEM_FIXED, sizeof(IISMDB_HEntry)*m_cHierarchy );
        if ( m_pHierarchy == NULL )
        {
            return FALSE;
        }
        memcpy( m_pHierarchy, pH, m_cHierarchy * sizeof(IISMDB_HEntry) );
    }

    return ResetPrivate();
}


BOOL
CIisAcctMapper::Load(
    )
/*++

Routine Description:

    Load mapper ( mappings, hierarchy, derived class private data )
    from a file, checking registry entry for MD5 signature

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT    x;
    MD5_CTX md5Check;
    FILE *  fIn;
    BOOL    fSt = TRUE;
    DWORD dwVal;
    IIS_CRYPTO_STORAGE  storage;

    Reset();

    MD5Init( &md5Check );
    if ( FAILED( storage.Initialize( (PIIS_CRYPTO_BLOB)m_pSesKey ) ) )
    {
        return FALSE;
    }

    if ( (fIn = fopen( m_achFileName, "rb" )) == NULL )
    {
        return FALSE;
    }

    // magic value & version

    if( fread( (LPVOID)&dwVal, sizeof(dwVal), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }
    if ( dwVal  != IISMDB_FILE_MAGIC_VALUE )
    {
        SetLastError( ERROR_BAD_FORMAT );
        fSt = FALSE;
        goto cleanup;
    }
    MD5Update( &md5Check, (LPBYTE)&dwVal, sizeof(dwVal) );

    if( fread( (LPVOID)&dwVal, sizeof(dwVal), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }
    MD5Update( &md5Check, (LPBYTE)&dwVal, sizeof(dwVal) );

    // mappings

    if( fread( (LPVOID)&m_cMapping, sizeof(m_cMapping), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &md5Check, (LPBYTE)&m_cMapping, sizeof(m_cMapping) );

    m_pMapping = (CIisMapping**)LocalAlloc( LMEM_FIXED, sizeof(CIisMapping*)*m_cMapping );
    if ( m_pMapping == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    for ( x = 0 ; x < m_cMapping ; ++x )
    {
        if ( (m_pMapping[x] = CreateNewMapping()) == NULL )
        {
            m_cMapping = x;
            fSt = FALSE;
            goto cleanup;
        }
        if ( !m_pMapping[x]->Deserialize( fIn ,(VALID_CTX)&md5Check, (LPVOID)&storage ) )
        {
            m_cMapping = x;
            fSt = FALSE;
            goto cleanup;
        }
    }

    // load hierarchy

    if( fread( (LPVOID)&m_cHierarchy, sizeof(m_cHierarchy), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( &md5Check, (LPBYTE)&m_cHierarchy, sizeof(m_cHierarchy) );

    m_pHierarchy = (IISMDB_HEntry*)LocalAlloc( LMEM_FIXED, sizeof(IISMDB_HEntry)*m_cHierarchy );
    if ( m_pHierarchy == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    if( fread( (LPVOID)m_pHierarchy, sizeof(IISMDB_HEntry), m_cHierarchy, fIn ) != m_cHierarchy )
    {
        fSt = FALSE;
        goto cleanup;
    }

    //
    // insure hierarchy correct
    //

    for ( x = 0 ; x < m_cHierarchy; ++x )
    {
        if ( m_pHierarchy[x].m_dwIndex >= m_cFields )
        {
            fSt = FALSE;
            goto cleanup;
        }
    }

    MD5Update( &md5Check, (LPBYTE)m_pHierarchy, sizeof(IISMDB_HEntry)*m_cHierarchy );

    // load private data

    fSt = LoadPrivate( fIn, (VALID_CTX)&md5Check );

    MD5Final( &md5Check );

#if 0
    //
    // Don't use signature for now - a metabase Restore operation
    // may have restored another signature, so metabase and
    // file won't match
    //

    if ( !(fSt = !memcmp( m_md5.digest,
                md5Check.digest,
                sizeof(md5Check.digest) )) )
    {
        SetLastError( ERROR_INVALID_ACCESS );
    }
#endif

cleanup:
    fclose( fIn );

    if ( !fSt && GetLastError() != ERROR_INVALID_ACCESS )
    {
        Reset();
    }
    else
    {
        UpdateClasses();
    }

    if ( !fSt )
    {
        char achErr[32];
        LPCTSTR pA[2];
        pA[0] = m_achFileName;
        pA[1] = achErr;
        _itoa( GetLastError(), achErr, 10 );
        ReportIisMapEvent( EVENTLOG_ERROR_TYPE,
                IISMAP_EVENT_LOAD_ERROR,
                2,
                pA );
    }

    return fSt;
}


// CIisCert11Mapper

CIisCert11Mapper::CIisCert11Mapper(
    )
/*++

Routine Description:

    Constructor for CIisCert11Mapper

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pIssuers = NULL;
    m_cIssuers = 0;

    m_pFields = IisCert11MappingFields;
    m_cFields = sizeof(IisCert11MappingFields)/sizeof(IISMDB_Fields);

    m_dwOptions = IISMDB_CERT11_OPTIONS;

}


CIisCert11Mapper::~CIisCert11Mapper(
    )
/*++

Routine Description:

    Destructor for CIisCert11Mapper

Arguments:

    None

Returns:

    Nothing

--*/
{
}


BOOL
CIisCert11Mapper::Add(
    CIisMapping* pM
    )
/*++

Routine Description:

    Add a mapping entry to mapping array
    Transfer ownership of mapping object to mapper
    Check is mapping to same NT account does not already exist.

Arguments:

    pM -- pointer to mapping to be added to mapper

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    // check if NT acct not already present.
    // if so, return FALSE, SetLastError( ERROR_INVALID_PARAMETER );

    if ( pM == NULL )
    {
        return FALSE;
    }



    LPSTR pCe;
    DWORD dwCe;
    LPSTR pCeIter;
    DWORD dwCeIter;

    if ( !pM->MappingGetField( IISMDB_INDEX_CERT11_CERT, (PBYTE *) &pCe, &dwCe, FALSE )
         || pCe == NULL )
    {
        dwCe = 0;
    }

    for ( x = 0 ; x < m_cMapping ; ++x )
    {
        if ( !m_pMapping[x]->MappingGetField( IISMDB_INDEX_CERT11_CERT, (PBYTE *) &pCeIter, &dwCeIter, FALSE )
             || pCeIter == NULL )
        {
            dwCeIter  = 0;
        }
        if ( dwCe == dwCeIter && !memcmp( pCe, pCeIter, dwCe ) )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }

    return CIisAcctMapper::Add( pM );
}

IISMDB_HEntry*
CIisCert11Mapper::GetDefaultHierarchy(
    LPDWORD pdwN
    )
/*++

Routine Description:

    return ptr to default hierarchy for certificates mapping

Arguments:

    pdwN -- updated with hierarchy entries count

Returns:

    ptr to hierarchy entries or NULL if error

--*/
{
    *pdwN = sizeof(IisCert11MappingHierarchy) / sizeof(IISMDB_HEntry);

    return IisCert11MappingHierarchy;
}

CIisMapping*
CIisCert11Mapper::CreateNewMapping(
    LPBYTE pC,
    DWORD dwC
    )
/*++

Routine Description:

    Create a new mapping from a certificate

Arguments:

    pC -- cert ( ASN.1 format )
    dwC -- length of cert

Returns:

    ptr to mapping. ownership of this object is transfered to caller.
    NULL if error

--*/
{
    CCert11Mapping *pCM = new CCert11Mapping( this );
    if ( pCM == NULL )
    {
        return NULL;
    }

    if ( pCM->Init( pC, dwC, m_pHierarchy, m_cHierarchy ) )
    {
        return (CIisMapping*)pCM;
    }
    delete pCM;

    return NULL;
}

BOOL
CIisCert11Mapper::ResetPrivate(
    )
/*++

Routine Description:

    Reset CIisCert11Mapper issuer list

Arguments:

    None

Returns:

    TRUE if success, FALSE if error

--*/
{
    // free issuer list

    if ( m_pIssuers != NULL )
    {
        for ( UINT x = 0 ; x < m_cIssuers ; ++x )
        {
            LocalFree( m_pIssuers[x].pbIssuer );
        }
        LocalFree( m_pIssuers );
        m_pIssuers = NULL;
    }
    m_cIssuers = 0;
    return TRUE;
}


BOOL
CIisCert11Mapper::LoadPrivate(
    FILE* fIn,
    VALID_CTX pMD5
    )
/*++

Routine Description:

    Load issuer list

Arguments:

    fIn -- file to read from
    pMD5 -- MD5 to update with signature from input byte stream

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL    fSt = TRUE;
    UINT    x;
    UINT    cLen;
    CHAR    achBuf[64];

    if( fread( (LPVOID)&m_cIssuers, sizeof(m_cIssuers), 1, fIn ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_cIssuers, sizeof(m_cIssuers) );

    m_pIssuers = (IssuerAccepted*)LocalAlloc( LMEM_FIXED, sizeof(IssuerAccepted)*m_cIssuers );
    if ( m_pIssuers == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }

    for ( x = 0 ; x < m_cIssuers ; ++x )
    {
        if ( fread( (LPVOID)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen), 1, fIn ) != 1 )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen) );

        if ( (m_pIssuers[x].pbIssuer = (LPBYTE)LocalAlloc( LMEM_FIXED, m_pIssuers[x].cbIssuerLen )) == NULL )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }
        if ( fread( m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen, 1, fIn ) != 1 )
        {
            m_cIssuers = x;
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen );
    }

    //
    // Read subject source (read to comply with legacy format)
    //

    if( Iisfgets( achBuf, sizeof(achBuf), fIn ) == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }
    cLen = (DWORD) strlen(achBuf);
    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)achBuf, cLen );

    //
    // We don't save the "subject source"
    // It is legacy value not used anywhere
    //

    //
    // Read default domain (read to comply with legacy format)
    //

    if( Iisfgets( achBuf, sizeof(achBuf), fIn ) == NULL )
    {
        fSt = FALSE;
        goto cleanup;
    }
    cLen = (DWORD) strlen(achBuf);
    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)achBuf, cLen );

    //
    // We don't save the "default domain"
    // It is legacy value not used anywhere
    //


cleanup:
    return fSt;
}


BOOL
CIisCert11Mapper::SavePrivate(
    FILE* fOut,
    VALID_CTX pMD5
    )
/*++

Routine Description:

    Save issuer list

Arguments:

    fOut -- file to write to
    pMD5 -- MD5 to update with signature of output byte stream

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    UINT x;

    if( fwrite( (LPVOID)&m_cIssuers, sizeof(m_cIssuers), 1, fOut ) != 1 )
    {
        fSt = FALSE;
        goto cleanup;
    }

    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_cIssuers, sizeof(m_cIssuers) );

    for ( x = 0 ; x < m_cIssuers ; ++x )
    {
        if ( fwrite( (LPVOID)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen), 1, fOut ) != 1 )
        {
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, (LPBYTE)&m_pIssuers[x].cbIssuerLen, sizeof(m_pIssuers[x].cbIssuerLen) );

        if ( fwrite( m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen, 1, fOut ) != 1 )
        {
            fSt = FALSE;
            goto cleanup;
        }

        MD5Update( (MD5_CTX*)pMD5, m_pIssuers[x].pbIssuer, m_pIssuers[x].cbIssuerLen );
    }

    //
    // Write subject source
    // legacy value, we don't write it out any more
    // write empty string to avoid potential compatibility issues
    //

    Iisfputs( "", fOut );


    //
    // Write default domain
    // legacy value, we don't write it out any more
    // write empty string to avoid potential compatibility issues
    //

    Iisfputs( "", fOut );


cleanup:
    return fSt;
}

//static
INT
CIisCert11Mapper::Iisfputs(
    const char* pBuf,
    FILE* fOut
    )
/*++

Routine Description:

    write string to the output file
    string will be terminated by new line

Arguments:


Returns:

    TRUE if success, FALSE if error

--*/
    
{
    return (fputs( pBuf, fOut ) == EOF || fputc( '\n', fOut ) == EOF)
        ? EOF
        : 0;
}

//static
LPSTR
CIisCert11Mapper::Iisfgets(
    LPSTR pBuf,
    INT cMax,
    FILE* fIn
    )
/*++

Routine Description:

    Read string from the output file
    string is terminated by new line

Arguments:


Returns:

    TRUE if success, FALSE if error

--*/
    
{
    LPSTR pszWas = pBuf;
    INT ch = 0;

    while ( cMax > 1 && (ch=fgetc(fIn))!= EOF && ch != '\n' )
    {
        *pBuf++ = (CHAR)ch;
        --cMax;
    }

    if ( ch != EOF )
    {
        *pBuf = '\0';
        return pszWas;
    }

    return NULL;
}



// CCert11Mapping

CCert11Mapping::CCert11Mapping(
    CIisAcctMapper* pMap
    )
/*++

Routine Description:

    Constructor for CCert11Mapping

Arguments:

    pMap -- ptr to mapper object linked to this mapping

Returns:

    Nothing

--*/
{
    m_pMapper = (CIisAcctMapper*)pMap;

    for ( int x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_pFields[x] = NULL;
    }
    for ( x = 0 ; x < sizeof(m_pFields)/sizeof(LPSTR) ; ++x )
    {
        m_cFields[x] = 0;
    }
}


CCert11Mapping::~CCert11Mapping(
    )
/*++

Routine Description:

    Destructor for CCert11Mapping

Arguments:

    None

Returns:

    Nothing

--*/
{
}


BOOL
CCert11Mapping::Init(
    LPBYTE pC,
    DWORD dwC,
    IISMDB_HEntry *pH,
    DWORD dwH
)
/*++

Routine Description:

    Constructor for CCert11Mapping

Arguments:

    pC -- cert ( ASN.1 format )
    dwC -- length of cert
    pH -- ptr to hierarchy info
    dwH -- number of hierarchy entries

Returns:

    TRUE if success, FALSE if error

--*/
{
    StoreFieldRef( IISMDB_INDEX_CERT11_CERT, (LPSTR)pC, dwC );

    UpdateMask( pH, dwH );

    return TRUE;
}

BOOL
CCert11Mapping::MappingSetField(
    DWORD dwIndex,
    LPSTR pszNew
    )
/*++

Routine Description:

    Set field in mapping entry to specified content
    data pointed by pszNew is copied inside mapping entry

Arguments:

    dwIndex -- index of field
    pszNew -- data to copy inside field

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    DWORD iMax = GetNbField( &pFields, &pcFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    return StoreField( pFields, pcFields, dwIndex, iMax, pszNew, (DWORD) strlen(pszNew)+1, FALSE );
}




// CIisMapping

CIisMapping::CIisMapping(
    )
/*++

Routine Description:

    Constructor for CIisMapping

Arguments:

    None

Returns:

    Nothing

--*/
{
    m_pBuff = NULL;
    m_cUsedBuff = m_cAllocBuff = 0;
    m_dwMask = 0;
}


BOOL
CIisMapping::CloneEx(
    CIisMapping**   ppM,
    LPSTR*          ppTargetS,
    LPSTR*          ppS,
    LPDWORD         pTargetC,
    LPDWORD         pC,
    UINT            cF
    )
/*++

Routine Description:

    Clone a mapping entry

Arguments:


Returns:

  TRUE if success, otherwise FALSE

--*/
{
    CIisMapping*    pM = *ppM;
    UINT            i;

    if ( ppTargetS && ppS )
    {
        //
        // ppTargetS is already allocated by caller and has cF entries
        //
        memcpy( ppTargetS, ppS, sizeof(LPSTR*) * cF );
    }

    if ( pTargetC && pC )
    {
        //
        // pTargetC is already allocated by caller and has cF entries
        //
        memcpy( pTargetC, pC, sizeof(DWORD) * cF );
    }

    if ( ( pM->m_pBuff = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cAllocBuff ) ) == NULL )
    {
        delete pM;
        *ppM = NULL;
        return FALSE;
    }

    DBG_ASSERT( m_cAllocBuff >= m_cUsedBuff );

    memcpy( pM->m_pBuff, m_pBuff, m_cUsedBuff );

    pM->m_cUsedBuff = m_cUsedBuff;
    pM->m_cAllocBuff = m_cAllocBuff;
    pM->m_pMapper = m_pMapper;
    pM->m_dwMask = m_dwMask;

    //
    // Adjust ptr to point to new buffer
    //

    for ( i = 0 ; i < cF ; ++i )
    {
        if ( ppTargetS[i] )
        {
            ppTargetS[i] += pM->m_pBuff - m_pBuff;
        }
    }

    return TRUE;
}


BOOL
CIisMapping::UpdateMask(
    IISMDB_HEntry* pH,
    DWORD dwI
    )
/*++

Routine Description:

    Update mask of significant fields for a mapping object
    Field is significant if not containing "*"
    mask if bitmask of n bits where n is # of hierarchy entries
    bit of rank m == 0 means field pointed by hierarchy entry n - 1 - m
    is significant. ( i.e. MSB is hierarchy entry 0, the most significant )

Arguments:

    pH -- ptr to hierarchy info
    dwI -- number of hierarchy entries

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    LPSTR pF;
    DWORD dwC;
    int iMax;
    m_dwMask = (1u << dwI)-1;

    iMax = GetNbField( &pFields, &pcFields );

    if ( pcFields )
    {
        for ( UINT x = 0 ; x < dwI ; ++x )
        {
            MappingGetField( pH[x].m_dwIndex, (PBYTE *) &pF, &dwC, FALSE );
            if ( !pF || dwC != 1 || *pF != '*' )
            {
                m_dwMask &= ~(1u << (dwI - 1 - x) );
            }
        }
    }
    else
    {
        for ( UINT x = 0 ; x < dwI ; ++x )
        {
            MappingGetField( pH[x].m_dwIndex, &pF );
            if ( !pF || strcmp( pF, "*" ) )
            {
                m_dwMask &= ~(1u << (dwI - 1 - x) );
            }
        }
    }

    return TRUE;
}


BOOL
CIisMapping::Copy(
    CIisMapping* pM
    )
/*++

Routine Description:

    Copy the specified mapping in this

Arguments:

    pM - ptr to mapping to duplicate

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPSTR *pFields;
    LPSTR pF;
    UINT iMax = GetNbField( &pFields );

    for ( UINT x = 0 ; x < iMax ; ++x )
    {
        if ( pM->MappingGetField( x, &pF ) && *pF )
        {
            if ( !MappingSetField( x, pF ) )
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}


int
CIisMapping::Cmp(
    CIisMapping* pM,
    BOOL fCmpForMatch
    )
/*++

Routine Description:

    Compare 2 mappings, return -1, 0 or 1 as suitable for qsort or bsearch
    Can compare either for full sort order ( using mask & significant fields )
    or for a match ( not using mask )

Arguments:

    pM -- ptr to mapping to compare to. This is to be used as the 2nd
          entry for purpose of lexicographical order.
    fCmpForMatch -- TRUE if comparing for a match inside a given mask class

Returns:

    -1 if *this < *pM, 0 if *this == *pM, 1 if *this > *pM

--*/
{
    DWORD dwCmpMask = 0xffffffff;

    // if not compare for match, consider mask

    if ( !fCmpForMatch )
    {
        if ( m_dwMask < pM->GetMask() )
        {
            return -1;
        }
        else if ( m_dwMask > pM->GetMask() )
        {
            return 1;
        }

        // mask are identical, have to consider fields
    }

    // compute common significant fields : bit is 1 if significant

    dwCmpMask = (~m_dwMask) & (~pM->GetMask());

    DWORD dwH;
    IISMDB_HEntry* pH = m_pMapper->GetHierarchy( &dwH );
    UINT x;
    LPSTR *pFL;
    LPDWORD pcFL;
    GetNbField( &pFL, &pcFL );

    for ( x = 0 ; x < dwH ; ++x )
    {
        if( ! (dwCmpMask & (1u << (dwH - 1 - x) )) )
        {
            continue;
        }

        LPSTR pA;
        LPSTR pB;
        DWORD dwA;
        DWORD dwB;
        int fC;
        if ( pcFL )     // check if length available
        {
            MappingGetField( pH[x].m_dwIndex, (PBYTE *) &pA, &dwA, FALSE );
            pM->MappingGetField( pH[x].m_dwIndex, (PBYTE *) &pB, &dwB, FALSE );
            if ( pA == NULL )
            {
                dwA = 0;
            }
            if ( pB == NULL )
            {
                dwB = 0;
            }
            if ( dwA != dwB )
            {
                return dwA < dwB ? -1 : 1;
            }
            fC = memcmp( pA, pB, dwA );
        }
        else
        {
            MappingGetField( pH[x].m_dwIndex, &pA );
            pM->MappingGetField( pH[x].m_dwIndex, &pB );
            if ( pA == NULL )
            {
                pA = "";
            }
            if ( pB == NULL )
            {
                pB = "";
            }
            fC = strcmp( pA, pB );
        }
        if ( fC )
        {
            return fC;
        }
    }

    return 0;
}


BOOL
CIisMapping::MappingGetField(
    DWORD dwIndex,
    LPSTR *pF
    )
/*++

Routine Description:

    Get ptr to field in mapping entry
    ownership of field remains with mapping entry

Arguments:

    dwIndex -- index of field
    pF -- updated with ptr to field entry. can be NULL if
          field empty.

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    DWORD iMax = GetNbField( &pFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    *pF = pFields[dwIndex];

    return TRUE;
}


BOOL
CIisMapping::MappingGetField(
    DWORD dwIndex,
    PBYTE *ppbF,
    LPDWORD pcbF,
    BOOL fUuEncode
    )
/*++

Routine Description:

    Get ptr to field in mapping entry
    ownership of field remains with mapping entry

Arguments:

    dwIndex -- index of field
    ppbF -- updated with ptr to field entry. can be NULL if
          field empty.
    pcbF -- updated with length of fields, 0 if empty
    fUuEncode -- TRUE if result is to be uuencoded.
                 if TRUE, caller must LocalFree( *pF )

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    DWORD iMax = GetNbField( &pFields, &pcFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    if ( fUuEncode )
    {
        LPSTR pU = (LPSTR)LocalAlloc( LMEM_FIXED, ((pcFields[dwIndex]+3)*4)/3+1 );
        if ( pU == NULL )
        {
            return FALSE;
        }
        IISuuencode( (LPBYTE)pFields[dwIndex], pcFields[dwIndex], (LPBYTE)pU, FALSE );
        *ppbF = (PBYTE) pU;
        *pcbF = (DWORD) strlen(pU);
    }
    else
    {
        *ppbF = (PBYTE) pFields[dwIndex];
        *pcbF = pcFields[dwIndex];
    }

    return TRUE;
}


BOOL
CIisMapping::MappingSetField(
    DWORD dwIndex,
    LPSTR pszNew
    )
/*++

Routine Description:

    Set field in mapping entry to specified content
    data pointed by pszNew is copied inside mapping entry

Arguments:

    dwIndex -- index of field
    pszNew -- data to copy inside field

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    DWORD iMax = GetNbField( &pFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    return StoreField( pFields, dwIndex, iMax, pszNew );
}


BOOL
CIisMapping::MappingSetField(
    DWORD dwIndex,
    PBYTE pbNew,
    DWORD cbNew,
    BOOL fIsUuEncoded
    )
/*++

Routine Description:

    Set field in mapping entry to specified content
    data pointed by pszNew is copied inside mapping entry

Arguments:

    dwIndex -- index of field
    pbNew -- data to copy inside field
    cbNew -- length of data
    fIsUuEncoded -- TRUE if pszNew is UUEncoded

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked for ptr to remain valid

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    DWORD iMax = GetNbField( &pFields, &pcFields );
    if ( dwIndex >= iMax )
    {
        return FALSE;
    }

    return StoreField( pFields, pcFields, dwIndex, iMax, (LPSTR) pbNew, cbNew, fIsUuEncoded );
}


BOOL
CIisMapping::StoreField(
    LPSTR* ppszFields,
    DWORD dwIndex,
    DWORD dwNbIndex,
    LPSTR pszNew
    )
/*++

Routine Description:

    Update field array in mapping entry with new field
    data pointed by pszNew is copied inside mapping entry

Arguments:

    ppszFields -- array of field pointers to be updated
    dwIndex -- index of field
    dwNbIndex -- number of fields in array
    pszNew -- data to copy inside field

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    // pszOld is assumed to point inside m_pBuff if non NULL
    // is has to be removed

    LPSTR pszOld = ppszFields[dwIndex];
    if ( pszOld && m_pBuff && (LPBYTE)pszOld > m_pBuff && (LPBYTE)pszOld < m_pBuff+m_cUsedBuff )
    {
        DWORD lO = (DWORD) strlen( pszOld ) + 1;
        DWORD lM = (DWORD) DIFF((m_pBuff + m_cUsedBuff) - (LPBYTE)pszOld) - lO;
        if ( lM )
        {
            // remove the old field from the middle of the m_pBuff
            // new value will be then appended to the end to the m_pBuff
            memmove( pszOld, pszOld + lO, lM );
            for ( x = 0 ; x < dwNbIndex ; ++x )
            {
                if ( x != dwIndex && ppszFields[x] > pszOld )
                {
                    ppszFields[x] -= lO;
                }
            }
        }
        ppszFields[ dwIndex ] = NULL;
        m_cUsedBuff -= lO;
    }

    // pszNew is to appended to m_pBuff

    DWORD lN = (DWORD) strlen( pszNew ) + 1;

    if ( m_cUsedBuff + lN > m_cAllocBuff )
    {
        UINT cNewBuff = (( m_cUsedBuff + lN + IIS_MAP_BUFF_GRAN ) / IIS_MAP_BUFF_GRAN) * IIS_MAP_BUFF_GRAN;
        LPSTR pNewBuff = (LPSTR)LocalAlloc( LMEM_FIXED, cNewBuff );
        if ( pNewBuff == NULL )
        {
            return FALSE;
        }
        if ( m_pBuff )
        {
            DBG_ASSERT( m_cUsedBuff <= cNewBuff );
            memcpy( pNewBuff, m_pBuff, m_cUsedBuff );
            LocalFree( m_pBuff );
        }
        m_cAllocBuff = cNewBuff;
        // adjust pointers
        for ( x = 0 ; x < dwNbIndex ; ++x )
        {
            if ( x != dwIndex )
            {
                if ( ppszFields[x] != NULL )
                {
                    ppszFields[x] += ((LPBYTE)pNewBuff - m_pBuff);
                }
            }
        }
        m_pBuff = (LPBYTE)pNewBuff;
    }
    DBG_ASSERT( m_cAllocBuff - m_cUsedBuff >= lN );
    memcpy( m_pBuff + m_cUsedBuff, pszNew, lN );

    ppszFields[dwIndex] = (LPSTR)(m_pBuff + m_cUsedBuff);

    m_cUsedBuff += lN;

    return TRUE;
}


BOOL
CIisMapping::StoreField(
    LPSTR* ppszFields,
    LPDWORD ppdwFields,
    DWORD dwIndex,
    DWORD dwNbIndex,
    LPSTR pbNew,
    DWORD cNew,
    BOOL fIsUuEncoded
    )
/*++

Routine Description:

    Update field array in mapping entry with new field
    data pointed by pszNew is copied inside mapping entry

Arguments:

    ppszFields -- array of field pointers to be updated
    ppdwFields -- array of field length to be updated
    dwIndex -- index of field
    dwNbIndex -- number of fields in array
    pbNew -- data to copy inside field
    cNew -- length of data
    fIsUuEncoded -- TRUE if pbNew is UUEncoded

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x;

    // pszOld is assumed to point inside m_pBuff if non NULL
    // it has to be removed

    LPSTR pszOld = ppszFields[dwIndex];
    if ( pszOld && m_pBuff && (LPBYTE)pszOld > m_pBuff && (LPBYTE)pszOld < m_pBuff+m_cUsedBuff )
    {
        DWORD lO = ppdwFields[dwIndex];
        DWORD lM = (DWORD) DIFF((m_pBuff + m_cUsedBuff) - (LPBYTE)pszOld) - lO;
        if ( lM )
        {
            // remove the old field from the middle of the m_pBuff
            // new value will be then appended to the end of m_pBuff
            //
            memmove( pszOld, pszOld + lO, lM );
            for ( x = 0 ; x < dwNbIndex ; ++x )
            {
                if ( x != dwIndex && ppszFields[x] > pszOld )
                {
                    ppszFields[x] -= lO;
                }
            }
        }
        ppszFields[ dwIndex ] = NULL;
        m_cUsedBuff -= lO;
    }

    // pszNew is to appended to m_pBuff

    UINT lN = cNew;
    if ( fIsUuEncoded )
    {
        LPSTR pU = (LPSTR)LocalAlloc( LMEM_FIXED, lN + 3);
        if ( pU == NULL )
        {
            return FALSE;
        }
        DWORD cO;
        IISuudecode( pbNew, (LPBYTE)pU, &cO, FALSE );
        pbNew = pU;
        cNew = lN = cO;
    }

    if ( m_cUsedBuff + lN > m_cAllocBuff )
    {
        UINT cNewBuff = (( m_cUsedBuff + lN + IIS_MAP_BUFF_GRAN ) / IIS_MAP_BUFF_GRAN) * IIS_MAP_BUFF_GRAN;
        LPSTR pNewBuff = (LPSTR)LocalAlloc( LMEM_FIXED, cNewBuff );
        if ( pNewBuff == NULL )
        {
            if ( fIsUuEncoded )
            {
                LocalFree( pbNew );
            }
            return FALSE;
        }
        if ( m_pBuff )
        {
            DBG_ASSERT( cNewBuff >= m_cUsedBuff );
            memcpy( pNewBuff, m_pBuff, m_cUsedBuff );
            LocalFree( m_pBuff );
        }
        m_cAllocBuff = cNewBuff;
        // adjust pointers
        for ( x = 0 ; x < dwNbIndex ; ++x )
        {
            if ( x != dwIndex )
            {
                if ( ppszFields[x] != NULL )
                {
                    ppszFields[x] += ((LPBYTE)pNewBuff - m_pBuff);
                }
            }
        }
        m_pBuff = (LPBYTE)pNewBuff;
    }
    DBG_ASSERT( m_cAllocBuff - m_cUsedBuff >= lN );
    memcpy( m_pBuff + m_cUsedBuff, pbNew, lN );

    ppszFields[dwIndex] = (LPSTR)(m_pBuff + m_cUsedBuff);
    if ( ppdwFields )
    {
        ppdwFields[dwIndex] = cNew;
    }

    m_cUsedBuff += lN;

    if ( fIsUuEncoded )
    {
        LocalFree( pbNew );
    }

    return TRUE;
}


BOOL
CIisMapping::Serialize(
    FILE* pFile,
    VALID_CTX pMD5,
    LPVOID pStorage
    )
/*++

Routine Description:

    Serialize a mapping entry

Arguments:

    pFile -- file to write to
    pMD5 -- MD5 to update with signature of written bytes

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked while serializing

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    LPSTR pO = NULL;
    DWORD dwO = 0;
    UINT iMax = GetNbField( &pFields, &pcFields );
    UINT x;
    LPBYTE pB = NULL;
    BOOL fMustFree = FALSE;

    for ( x = 0 ; x < iMax ; ++x )
    {
        LPSTR pF;
        DWORD dwF;

        fMustFree = FALSE;

        if ( pcFields )
        {
            MappingGetField( x, (PBYTE *) &pF, &dwF, FALSE );
            MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pF, dwF );
store_as_binary:
            if ( IsCrypt( x ) && dwF )
            {
                if ( FAILED(((IIS_CRYPTO_STORAGE*)pStorage)->EncryptData(
                        (PIIS_CRYPTO_BLOB*)&pB,
                        pF,
                        dwF,
                        REG_BINARY )) )
                {
                    return FALSE;
                }
                pF = (LPSTR)pB;
                dwF = IISCryptoGetBlobLength( (PIIS_CRYPTO_BLOB)pB );
                fMustFree = TRUE;
            }

            if ( dwF )
            {
                DWORD dwNeed = ((dwF+2)*4)/3 + 1;
                if ( dwNeed > dwO )
                {
                    if ( pO != NULL )
                    {
                        LocalFree( pO );
                    }
                    dwNeed += 100;  // alloc more than needed
                                    // to minimize # of allocation
                    if ( (pO = (LPSTR)LocalAlloc( LMEM_FIXED, dwNeed )) == NULL )
                    {
                        return FALSE;
                    }
                    dwO = dwNeed;
                }
                /* INTRINSA suppress = null */
                IISuuencode( (LPBYTE)pF, dwF, (LPBYTE)pO, FALSE );
                fputs( pO, pFile );
            }

            if ( fMustFree )
            {
                IISCryptoFreeBlob( (PIIS_CRYPTO_BLOB)pB );
            }
        }
        else
        {
            MappingGetField( x, &pF );
            if ( pF != NULL )
            {
                MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pF, (DWORD)strlen(pF) );
                if ( IsCrypt( x ) )
                {
                    dwF = (DWORD)strlen( pF ) + 1;
                    goto store_as_binary;
                }
                fputs( pF, pFile );
            }
        }
        fputs( "|", pFile );
    }

    fputs( "\r\n", pFile );

    if ( pO != NULL )
    {
        LocalFree( pO );
    }

    return TRUE;
}


BOOL
CIisMapping::Deserialize(
    FILE* pFile,
    VALID_CTX pMD5,
    LPVOID pStorage
    )
/*++

Routine Description:

    Deserialize a mapping entry

Arguments:

    pFile -- file to read from
    pMD5 -- MD5 to update with signature of read bytes

Returns:

    TRUE if success, FALSE if error

Lock:
    mapper must be locked while serializing

--*/
{
    LPSTR *pFields;
    LPDWORD pcFields;
    UINT iMax;
    UINT x;
    int c;
    CHAR achBuf[4096]; // seems to be hardcoded limit on mapping saved
    DWORD dwType;
    LPBYTE pB;

    iMax = GetNbField( &pFields, &pcFields );

    for ( x = 0 ; x < iMax ; ++x )
    {
        StoreFieldRef( x, NULL );
    }

    for ( x =  0 ; x < sizeof(achBuf) && (c=fgetc(pFile))!= EOF ; )
    {
        achBuf[x++] = (CHAR)c;

        if ( c == '\n' )
        {
            break;
        }
    }
    if ( x == sizeof(achBuf ) )
    {
        return FALSE;
    }

    if ( x > 1 )
    {
        achBuf[x-2] = '\0';

        m_cUsedBuff = m_cAllocBuff = x - 1;
        if ( (m_pBuff = (LPBYTE)LocalAlloc( LMEM_FIXED, m_cAllocBuff )) == NULL )
        {
            m_cAllocBuff = m_cUsedBuff = 0;
            return FALSE;
        }
        DBG_ASSERT( m_cAllocBuff >= m_cUsedBuff );
        memcpy( m_pBuff, achBuf, m_cUsedBuff );

        LPSTR pCur = (LPSTR)m_pBuff;
        LPSTR pNext;
        LPSTR pStore = (LPSTR)m_pBuff;
        DWORD dwDec;
        if ( pcFields )
        {
            for ( x = 0 ; x < iMax ; ++x )
            {
                pNext = strchr( pCur, '|' );
                if ( pNext != NULL )
                {
                    *pNext = '\0';
                    ++pNext;
                }
                else
                {
                    pNext = NULL;
                }
                IISuudecode( pCur, (PBYTE)pStore, &dwDec, FALSE );
                if ( IsCrypt( x ) && dwDec )
                {
                    if ( FAILED(((IIS_CRYPTO_STORAGE*)pStorage)->DecryptData(
                            (PVOID*)&pB,
                            &dwDec,
                            &dwType,
                            (PIIS_CRYPTO_BLOB)pStore )) )
                    {
                        return FALSE;
                    }
                    DBG_ASSERT( m_cAllocBuff >= dwDec );
                    memmove( pStore, pB, dwDec );
                }
                MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pStore, dwDec );
                StoreFieldRef( x, pStore, dwDec );
                pCur = pNext;
                pStore += dwDec;
            }
        }
        else
        {
            for ( x = 0 ; x < iMax ; ++x )
            {
                pNext = strchr( pCur, '|' );
                if ( pNext != NULL )
                {
                    *pNext = '\0';
                    ++pNext;
                }
                if ( *pCur && IsCrypt( x ) )
                {
                    IISuudecode( pCur, (PBYTE)pCur, &dwDec, FALSE );

                    if ( FAILED(((IIS_CRYPTO_STORAGE*)pStorage)->DecryptData(
                            (PVOID*)&pB,
                            &dwDec,
                            &dwType,
                            (PIIS_CRYPTO_BLOB)pCur )) )
                    {
                        return FALSE;
                    }

                    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pB, dwDec );
                    StoreFieldRef( x, (LPSTR)pB );
                    pCur = pNext;
                }
                else
                {
                    MD5Update( (MD5_CTX*)pMD5, (LPBYTE)pCur, (DWORD) strlen(pCur) );
                    StoreFieldRef( x, pCur );
                    pCur = pNext;
                }
            }
        }
        return TRUE;
    }

    return FALSE;
}


//


extern "C" BOOL WINAPI
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID /*pV*/
    )
/*++

Routine Description:

    DLL init/terminate notification function

Arguments:

    hModule  - DLL handle
    dwReason - notification type
    LPVOID   - not used

Returns:

    TRUE if success, FALSE if failure

--*/
{
    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
#ifdef _NO_TRACING_
            CREATE_DEBUG_PRINT_OBJECT( "IISMAP" );
#endif
            // record the module handle to access module info later
            s_hIISMapDll = (HINSTANCE)hModule;
            InitializeWildcardMapping( hModule );
            InitializeMapping( hModule );
            if ( IISCryptoInitialize() != NO_ERROR )
            {
                return FALSE;
            }
            return TRUE;

        case DLL_PROCESS_DETACH:
            IISCryptoTerminate();
            TerminateWildcardMapping();
            TerminateMapping();
#ifdef _NO_TRACING_
            DELETE_DEBUG_PRINT_OBJECT( );
#endif
            break;
    }

    return TRUE;
}


static
BOOL
LoadFieldNames(
    IISMDB_Fields* pFields,
    UINT cFields
    )
/*++

Routine Description:

    Load fields names from resource 
    - helper function for InitializeMapping()

Arguments:

    pFields - ptr to array where to store reference to names
    cFields - count of element in array

Return Value:

    TRUE if success, otherwise FALSE

--*/
{

    UINT    x;
    BOOL    fSt = TRUE;

    for ( x = 0 ;
        x < cFields ;
        ++x )
    {
        char achTmp[128];

        if ( LoadString( s_hIISMapDll,
                         pFields[x].m_dwResID,
                         achTmp,
                         sizeof( achTmp ) ) != 0 )
        {
            DWORD lN = (DWORD) strlen( achTmp ) + sizeof(CHAR);
            if ( (pFields[x].m_pszDisplayName = (LPSTR)LocalAlloc( LMEM_FIXED, lN )) == NULL )
            {
                fSt = FALSE;
                break;
            }
            memcpy( pFields[x].m_pszDisplayName, achTmp, lN );
        }
        else
        {
            fSt = FALSE;
            break;
        }
    }

    return fSt;
}


static
VOID
FreeFieldNames(
    IISMDB_Fields* pFields,
    UINT cFields
    )
/*++

Routine Description:

    Free fields names loaded from resource
    - helper function for TerminateMapping()

Arguments:

    pFields - ptr to array where reference to names are stored
    cFields - count of element in array

Return Value:

    Nothing

--*/
{

    UINT    x;

    for ( x = 0 ;
        x < cFields ;
        ++x )
    {
        if ( pFields[x].m_pszDisplayName )
        {
            LocalFree( pFields[x].m_pszDisplayName );
        }
    }
}



BOOL
InitializeMapping(
    HANDLE /*hModule*/
    )
/*++

Routine Description:

    Initialize mapping

Arguments:

    hModule - module handle of this DLL (not used)

Return Value:

    Nothing

--*/
{
    HKEY hKey = NULL;
    // get install path

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMS,
                       0,
                       KEY_READ|KEY_SET_VALUE,
                       &hKey ) == ERROR_SUCCESS )
    {
        DWORD dwLen = 0;
        DWORD dwType;

        if ( RegQueryValueEx( hKey,
                              INSTALL_PATH,
                              NULL,
                              &dwType,
                              NULL,
                              &dwLen ) != ERROR_SUCCESS  ||
              dwType != REG_SZ )
        {
            //
            // Read next value
            //
            goto ReadNext;
        }

        //
        // allocate space for extra terminator
        //
        if ( ( s_pszIisInstallPath = (LPSTR)LocalAlloc( 
                                            LMEM_FIXED, 
                                               dwLen + 
                                               sizeof( s_pszIisInstallPath[0] ) )  )
                                               == NULL )
        {
            //
            // Read next value
            //
            goto ReadNext;
        }

        if ( RegQueryValueEx( hKey,
                              INSTALL_PATH,
                              NULL,
                              &dwType,
                              (LPBYTE)s_pszIisInstallPath,
                              &dwLen ) != ERROR_SUCCESS )
        {
            if ( s_pszIisInstallPath )
            {
                LocalFree( s_pszIisInstallPath );
                s_pszIisInstallPath = NULL;
            }
            //
            // Read next value
            //
            goto ReadNext;
        }
        
        //
        // RegQueryValueEx may not return NULL terminated string
        // To be sure let's add termination (extra space was allocated already) 
        //
        s_pszIisInstallPath[ dwLen ] = '\0';

    ReadNext:
        dwLen = sizeof( s_dwFileGuid );
        if ( RegQueryValueEx( hKey,
                              MAPPER_GUID,
                              NULL,
                              &dwType,
                              (LPBYTE)&s_dwFileGuid,
                              &dwLen ) != ERROR_SUCCESS ||
             dwType != REG_DWORD )
        {
            s_dwFileGuid = 0;
        }

        RegCloseKey( hKey );

        return LoadFieldNames( IisCert11MappingFields,
                               sizeof(IisCert11MappingFields)/sizeof(IISMDB_Fields) );
    }
    else
    {
        hKey = NULL;
    }

    return FALSE;
}


VOID
TerminateMapping(
    )
/*++

Routine Description:

    Terminate mapping

Arguments:

    None

Return Value:

    Nothing

--*/
{
    if ( s_pszIisInstallPath )
    {
        LocalFree( s_pszIisInstallPath );
    }

    FreeFieldNames( IisCert11MappingFields,
                    sizeof(IisCert11MappingFields)/sizeof(IISMDB_Fields) );
}

//


dllexp
BOOL
ReportIisMapEvent(
    WORD wType,
    DWORD dwEventId,
    WORD cNbStr,
    LPCTSTR* pStr
    )
/*++

Routine Description:

    Log an event based on type, ID and insertion strings

Arguments:

    wType -- event type ( error, warning, information )
    dwEventId -- event ID ( as defined by the .mc file )
    cNbStr -- nbr of LPSTR in the pStr array
    pStr -- insertion strings

Returns:

    TRUE if success, FALSE if failure

--*/
{
    BOOL    fSt = TRUE;
    HANDLE  hEventLog = NULL;

    hEventLog = RegisterEventSource(NULL,"IISMAP");

    if ( hEventLog != NULL )
    {
        if (!ReportEvent(hEventLog,             // event log handle
                    wType,                      // event type
                    0,                          // category zero
                    (DWORD) dwEventId,          // event identifier
                    NULL,                       // no user security identifier
                    cNbStr,                     // count of substitution strings (may be no strings)
                                                // less ProgName (argv[0]) and Event ID (argv[1])
                    0,                          // no data
                    (LPCTSTR *) pStr,           // address of string array
                    NULL))                      // address of data
        {
            fSt = FALSE;
        }

        DeregisterEventSource( hEventLog );
    }
    else
    {
        fSt = FALSE;
    }

    return fSt;
}

dllexp
BOOL
ReportIisMapEventW(
    WORD wType,
    DWORD dwEventId,
    WORD cNbStr,
    LPCWSTR* pStr
    )
/*++

Routine Description:

    Log an event based on type, ID and insertion strings

Arguments:

    wType -- event type ( error, warning, information )
    dwEventId -- event ID ( as defined by the .mc file )
    cNbStr -- nbr of LPSTR in the pStr array
    pStr -- insertion strings

Returns:

    TRUE if success, FALSE if failure

--*/
{
    BOOL    fSt = TRUE;
    HANDLE  hEventLog = NULL;

    hEventLog = RegisterEventSource(NULL,"IISMAP");

    if ( hEventLog != NULL )
    {
        if (!ReportEventW(hEventLog,            // event log handle
                    wType,                      // event type
                    0,                          // category zero
                    (DWORD) dwEventId,          // event identifier
                    NULL,                       // no user security identifier
                    cNbStr,                     // count of substitution strings (may be no strings)
                                                // less ProgName (argv[0]) and Event ID (argv[1])
                    0,                          // no data
                    (LPCWSTR *) pStr,           // address of string array
                    NULL))                      // address of data
        {
            fSt = FALSE;
        }

        DeregisterEventSource( hEventLog );
    }
    else
    {
        fSt = FALSE;
    }

    return fSt;
}



/////////////////////////////////////////





///////////////////////

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

BOOL IISuudecode(char   * bufcoded,
              BYTE   * bufout,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);
    int chL = 0;

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = (DWORD) DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin = bufcoded;

    while (nprbytes > 0) {
        chL = bufin[2];
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[chL] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}

//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage of the code that's floating around out there].
//

BOOL IISuuencode( BYTE *   bufin,
               DWORD    nbytes,
               BYTE *   outptr,
               BOOL     fBase64 )
{
   unsigned int i;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;


   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}




const int SHA1_HASH_SIZE = 20;


HRESULT
GetCertificateHashString(
    PBYTE pbCert,
    DWORD cbCert,
    WCHAR *pwszCertHash,
    DWORD cchCertHashBuffer)
/*++

Routine Description:

    verifies validity of cert blob by creating cert context
    and retrieves SHA1 hash and converts it to WCHAR *

Arguments:

    pbCert - X.509 certificate blob
    cbCert - size of the cert blob in bytes
    pwszCertHash - buffer must be big enough to fit SHA1 hash in hex string form
                   (40 WCHAR + terminating 0 )
    cchCertHashBuffer - size of the CertHash buffer in WCHARS (including terminating 0)
Returns:

    HRESULT

--*/
    
{
    HRESULT         hr = E_FAIL;
    BYTE            rgbHash[ SHA1_HASH_SIZE ];
    DWORD           cbSize = SHA1_HASH_SIZE;
    PCCERT_CONTEXT  pCertContext = NULL;

    #ifndef HEX_DIGIT
    #define HEX_DIGIT( nDigit )                            \
    (WCHAR)((nDigit) > 9 ?                              \
          (nDigit) - 10 + L'a'                          \
        : (nDigit) + L'0')
    #endif


    pCertContext = CertCreateCertificateContext(
                                    X509_ASN_ENCODING, 
                                    (const BYTE *)pbCert, 
                                    cbCert );
    
    if ( pCertContext == NULL )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }

    //
    // get hash of the certificate to be verified
    //
    if ( !CertGetCertificateContextProperty( pCertContext,
                                             CERT_SHA1_HASH_PROP_ID,
                                             rgbHash,
                                             &cbSize ) )
    {
        hr = HRESULT_FROM_WIN32( GetLastError() );
        goto ExitPoint;
    }
    
    CertFreeCertificateContext( pCertContext );
    pCertContext = NULL;

    if ( cchCertHashBuffer < SHA1_HASH_SIZE * 2 + 1 )
    {
        // we don't have big enough buffer to store
        // hex string of the SHA1 hash each byte takes 2 chars + terminating 0 
        hr = HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER );
        DBG_ASSERT( cchCertHashBuffer < SHA1_HASH_SIZE * 2 + 1 );
        goto ExitPoint;
    }

    //
    // convert to text
    //
    for (int i = 0; i < sizeof(rgbHash); i ++ )
    {
        *(pwszCertHash++) = HEX_DIGIT( ( rgbHash[ i ] >> 4 ) );
        *(pwszCertHash++) = HEX_DIGIT( ( rgbHash[ i ] & 0x0F ) );
    }
    *(pwszCertHash) = L'\0';
    #undef HEX_DIGIT
    
ExitPoint:
    if ( pCertContext != NULL )
    {
        CertFreeCertificateContext( pCertContext );
        pCertContext = NULL;
    }
    return S_OK;
}


VOID
ReportImportProblem( 
    HRESULT hr 
    )
/*++

Routine Description:

    Utility function for ImportIISCertMappingsToIIS6()
    that reports first problem occured with import to eventlog
    

Arguments:

    hr - hresult to report

Returns:

    VOID

--*/
{
    static BOOL fWasReported = FALSE;

    if ( fWasReported == FALSE )
    {
        fWasReported = TRUE;
        
        char achErr[ 40 ];
        LPCTSTR pA[ 1 ];
        pA[ 0 ] = achErr;
        _ultoa( hr, achErr, 16 );

        
        ReportIisMapEvent( EVENTLOG_ERROR_TYPE,
                IISMAP_EVENT_ERROR_IMPORT,
                1,
                pA );
    }
}

dllexp
VOID
ImportIISCertMappingsToIIS6(
    VOID
    )
/*++

Routine Description:

    IIS6 stores 1to1 certificate in the metabase
    IIS5 used to store MD_SERIAL_CERT11 reference info in the metabase
    but actual mapping details were stored in metabase extension  file 
    *.mp
    This routine will load old (IIS5) style mapping for each site
    into memory, then save it in the metabase and delete old reference 
    info from metabase
    This function should be called only once
    

Arguments:

    None

Returns:

    HRESULT

--*/
    
{
    
    IMSAdminBase *      pMetabase = NULL;
    HRESULT             hr = E_FAIL;
    HKEY                hKey = NULL;
    DWORD               dwLen = 0;
    DWORD               dwType;
    DWORD               dwError;
    BOOL                fCoInitialized = FALSE;
    BOOL                fMBSaved = FALSE;

    if ( ( dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       W3_PARAMS,
                       0,
                       KEY_READ|KEY_SET_VALUE,
                       &hKey ) ) != ERROR_SUCCESS )
    {
        if ( dwError != ERROR_FILE_NOT_FOUND &&
             dwError != ERROR_PATH_NOT_FOUND )
        {
            hr = HRESULT_FROM_WIN32( dwError );
            ReportImportProblem( hr );
            DBGPRINTF(( DBG_CONTEXT,
                        "Error in Opening registry(). hr = %x\n",
                        hr ));
        }
        goto Finished;
    }
    
    
    dwLen = sizeof( s_dwFileGuid );
    if ( RegQueryValueEx( hKey,
                          MAPPER_GUID,
                          NULL,
                          &dwType,
                          (LPBYTE)&s_dwFileGuid,
                          &dwLen ) != ERROR_SUCCESS ||
         dwType != REG_DWORD )
    {
        //
        // If MapperGuid Value doesn't exist 
        // then it means that IIS Cert Mappings 
        // in old format are not present 
        //
        goto Finished;
    }
       
    if ( s_dwFileGuid == 0xffffffff )
    {
        // This flags that import has been already attempted
        // It is valid to run Import only once
        // If Import needs to be rerun then 
        // MAPPER_GUID should be reset to value different from MAX_DWORD
        goto Finished;
    }

    //
    // Write to registry that import of 1to1 certmapping info
    // was invoked (we will do it only once)
    //
    
    s_dwFileGuid = 0xffffffff;
    if( ( dwError = RegSetValueEx( hKey,
                   MAPPER_GUID,
                   NULL,
                   REG_DWORD,
                   (LPBYTE)&s_dwFileGuid,
                   sizeof(s_dwFileGuid) ) ) != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( dwError );
        ReportImportProblem( hr );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in Opening registry(). hr = %x\n",
                    hr ));
        goto Finished;
        
    }
    
    RegCloseKey( hKey );
    hKey = NULL;
    
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    
    if ( hr == RPC_E_CHANGED_MODE )
    {
        // If you get RPC_E_MODE_CHANGE the thread is coinited
        // but don't couninit
    }        
    else if ( FAILED(hr) )
    {
        ReportImportProblem( hr );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error in CoInitializeEx().  hr = %x\n",
                    hr ));
                    
        goto Finished;
    }
    else
    {
        fCoInitialized = TRUE;
        // we will have to couninit
    }
    
    //
    // Initialize the metabase access (ABO)
    //
    
    hr = CoCreateInstance( CLSID_MSAdminBase,
                           NULL,
                           CLSCTX_SERVER,
                           IID_IMSAdminBase,
                           (LPVOID *) &pMetabase 
                           );
    if( FAILED(hr) )
    {
        ReportImportProblem( hr );
        DBGPRINTF(( DBG_CONTEXT,
                    "Error creating ABO object.  hr = %x\n",
                    hr ));
        goto Finished;
    }

    //
    // Instances of 2 services could be using 1to1 certificate mappings
    // one is W3SVC and another one is NNTP

    for ( DWORD dwServiceType = 0; dwServiceType < 2; dwServiceType ++ )
    {
        SimpleMB            mb( pMetabase );
        CIisCert11Mapper    AcctMapper;
        DWORD               dwIndex = 0;
        WCHAR *             pszServicePath = NULL;
        WCHAR               achServiceInstance[ ADMINDATA_MAX_NAME_LEN + 1 ];
        STRAU               strObjectPath;

        BUFFER              buffSerializedCert11Info;
        DWORD               cbSerializedCert11Info;
        
        switch( dwServiceType)
        {
            case 0:
                pszServicePath = L"/LM/W3SVC";
                break;
            case 1:
                pszServicePath = L"/LM/NNTPSVC";
                break;
        }

        // We need access to ServicePath in the metabase

        if ( ! mb.Open( pszServicePath, 
                        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
        {
            hr = HRESULT_FROM_WIN32( GetLastError() );
            if ( hr != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) )
            {
                //
                // Report error if other than ERROR_PATH_NOT_FOUND
                // ERROR_PATH_NOT_FOUND indicates that service (such as w3svc or nntp) 
                // is not installed
                //
                ReportImportProblem( hr );
                DBGPRINTF(( DBG_CONTEXT,
                            "Failed to open metabase path %s (import of 1to1 cert mappings will fail).  hr = %x\n",
                            pszServicePath, hr ));
                // still try another service if there is any left
            }
            continue;
        }    

        //
        // Enumerate service instances (such as w3svc/1, w3svc/2 etc)
        // and upgrade 1to1 mapping info to new format for all of them
        //
        for ( dwIndex = 0; ; dwIndex++ )
        {
            if ( !mb.EnumObjects( L"",
                                  achServiceInstance,
                                  dwIndex ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                if ( hr != HRESULT_FROM_WIN32( ERROR_NO_MORE_ITEMS ) &&
                     hr != HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) )
                {
                    ReportImportProblem( hr );
                    DBGPRINTF(( DBG_CONTEXT,
                        "Failed to enum metabase nodes.  hr = %x\n",
                        hr ));
                }
                else
                {
                    // done enumerating all instances of the service
                    hr = S_OK;
                }
                        
                // Done with enumeration
                // Exit the for loop
                break;
            }
            //
            // Read 1to1 certificate mapping serialized reference info
            // from metabase
            //
                
            if ( !mb.GetBuffer( achServiceInstance, 
                                MD_SERIAL_CERT11, 
                                IIS_MD_UT_SERVER, 
                                &buffSerializedCert11Info,
                                &cbSerializedCert11Info
                                ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                if ( hr != MD_ERROR_DATA_NOT_FOUND )
                {
                    // this service instance may have
                    // and 1to1 certificate mappings configured
                    ReportImportProblem( hr );
                    DBGPRINTF(( DBG_CONTEXT,
                       "Failed to read MD_SERIAL_CERT11 for %s/%s. hr = %x\n",
                        pszServicePath, achServiceInstance, hr ));
                }                    
                // don't take error as fatal move on to another service 
                // instance
                goto EnumNext;
            }

            //
            // Unserialize 1to1 Certificate mapping info
            //

            PBYTE pbSerializedCert11Info = (PBYTE) buffSerializedCert11Info.QueryPtr();
            if ( !AcctMapper.Unserialize( &pbSerializedCert11Info, 
                                          &cbSerializedCert11Info ) || 
                 !AcctMapper.Load() )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                ReportImportProblem( hr );
                DBGPRINTF(( DBG_CONTEXT,
                    "Failed to unserialize mapper for %s/%s.  hr = %x\n",
                    pszServicePath, achServiceInstance, hr ));

                goto EnumNext;
            }

            // walk all the mappings and save them to metabase 
            // in the new format
            //
            for ( DWORD dwMappingIndex = 0; 
                  dwMappingIndex < AcctMapper.GetMappingCount();
                  dwMappingIndex ++ )  
            {

                PBYTE           pbCert = NULL;
                DWORD           cbCert = 0;
                CHAR *          pszPassword;
                DWORD           cbPassword;
                STRAU           strPassword;
                CHAR *          pszAcctName;
                DWORD           cbAcctName;
                STRAU           strAcctName;
                CHAR *          pszMappingName;
                DWORD           cbMappingName;
                STRAU           strMappingName;
                DWORD *         pdwEnabled;
                DWORD           cbEnabled;
                STRAU           strObjectPath;
                WCHAR           achCertHash[ 2*SHA1_HASH_SIZE + 1];
                CIisMapping*    pCurrentMapping;


                if ( !AcctMapper.GetMapping( 
                                        dwMappingIndex, 
                                        &pCurrentMapping ) )
                {
                    hr = E_FAIL;
                    ReportImportProblem( hr );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to read mapping for %s/%s/%d. 0x%x\n", 
                               pszServicePath, achServiceInstance, 
                               dwMappingIndex, hr));
                    // There must be some inconsistency in data
                    // or low memory condition
                    // No hope to process mappings for this Service Site.
                    // Move on to next Service site
                    break;
                }

                if ( !pCurrentMapping->MappingGetField( 
                                        IISMDB_INDEX_CERT11_CERT,
                                        (PBYTE *)&pbCert,
                                        &cbCert,
                                        FALSE ) )
                {
                    hr = E_FAIL;
                    ReportImportProblem( hr );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to read mapping for %s/%s/%d. 0x%x\n", 
                               pszServicePath, achServiceInstance, 
                               dwMappingIndex, hr));
                    // Move on to next Service site
                    break;

                }                
                if ( !pCurrentMapping->MappingGetField( 
                                        IISMDB_INDEX_CERT11_NT_ACCT,
                                        (PBYTE *)&pszAcctName,
                                        &cbAcctName,
                                        FALSE ) )
                {
                    hr = E_FAIL;
                    ReportImportProblem( hr );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to read mapping for %s/%s/%d. 0x%x\n", 
                               pszServicePath, achServiceInstance, 
                               dwMappingIndex, hr));
                    // Move on to next Service site
                    break;
                }
                if ( !pCurrentMapping->MappingGetField( 
                                        IISMDB_INDEX_CERT11_NT_PWD,
                                        (PBYTE *)&pszPassword,
                                        &cbPassword,
                                        FALSE ) )
                {
                    hr = E_FAIL;
                    ReportImportProblem( hr );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to read mapping for %s/%s/%d. 0x%x\n", 
                               pszServicePath, achServiceInstance, 
                               dwMappingIndex, hr));
                    // Move on to next Service site
                    break;
                }
                if ( !pCurrentMapping->MappingGetField( 
                                        IISMDB_INDEX_CERT11_NAME,
                                        (PBYTE *)&pszMappingName,
                                        &cbMappingName,
                                        FALSE ) )
                {
                    hr = E_FAIL;
                    ReportImportProblem( hr );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to read mapping for %s/%s/%d. 0x%x\n", 
                               pszServicePath, achServiceInstance, 
                               dwMappingIndex, hr));
                    // Move on to next Service site
                    break;
                }
                if ( !pCurrentMapping->MappingGetField( 
                                        IISMDB_INDEX_CERT11_ENABLED,
                                        (PBYTE *)&pdwEnabled,
                                        &cbEnabled,
                                        FALSE ) || 
                     cbEnabled != sizeof( DWORD ) )
                {
                    hr = E_FAIL;
                    ReportImportProblem( hr );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to read mapping for %s/%s/%d. 0x%x\n", 
                               pszServicePath, achServiceInstance, 
                               dwMappingIndex, hr));
                    // Move on to next Service site
                    break;
                }

                //
                // Finished reading current mapping details
                // Now convert Mapping Name, AcctName and Password
                // from ANSI to Unicode (the actual conversion may happen later
                // - STRAU class will take care of it)

                if ( !strMappingName.Copy( pszMappingName, 
                                           cbMappingName - sizeof(CHAR) ) ||
                     !strPassword.Copy( pszPassword, 
                                        cbPassword - sizeof(CHAR) ) ||
                     !strAcctName.Copy( pszAcctName, 
                                           cbAcctName - sizeof(CHAR) ) )
                                        
                {
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    ReportImportProblem( hr );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to read mapping for %s/%s/%d. 0x%x\n", 
                               pszServicePath, achServiceInstance, 
                               dwMappingIndex, hr));
                    break;
                }

                
                // Now calculate hex string with current cert's hash
                // it will be used as a unique name for the mapping
                // object in the metabase

                if ( FAILED( hr = GetCertificateHashString( 
                                                        pbCert,
                                                        cbCert, 
                                                        achCertHash,
                                                        sizeof( achCertHash )/sizeof(WCHAR) ) ) )
                {
                    ReportImportProblem( hr );
                    DBGPRINTF((DBG_CONTEXT,
                               "Invalid cert passed to CreateMapping() 0x%x\n", hr));
                    // goto next mapping
                    goto NextMapping;
                }

                if ( ! strObjectPath.Copy( achServiceInstance ) )
                {
                    ReportImportProblem( hr );
                    hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to import mapping. 0x%x\n", hr));
                    goto NextMapping;
                }
                if ( ! strObjectPath.Append( "/Cert11/Mappings/" ) )
                {
                    ReportImportProblem( hr );
                    hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to import mapping. 0x%x\n", hr));
                    goto NextMapping;
                }
                
                if ( ! strObjectPath.Append( achCertHash ) )
                {
                    ReportImportProblem( hr );
                    hr = HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to import mapping. 0x%x\n", hr));
                    goto NextMapping;
                }

                //
                // Add new node for the mapping
                //
                if ( !mb.AddObject( strObjectPath.QueryStrW() ) )
                {
                    // Don't report problem here
                    // Just fall through
                    // Next SetData will fail and report problem
                    // if there is one. 
                }
                
                // 
                // Save 1to1 Certificate mapping info
                // directly to metabase in the new format
                //
                
                // save the certificate
                if ( !mb.SetData( strObjectPath.QueryStrW(), MD_MAPCERT, 
                                  IIS_MD_UT_SERVER, BINARY_METADATA,
                                  pbCert, cbCert, 0 ) )
                {
                     ReportImportProblem( hr );
                     hr = HRESULT_FROM_WIN32( GetLastError() );
                     DBGPRINTF(( DBG_CONTEXT,
                            "Failed to write MD_MAPCERT.  hr = %x\n",
                            hr ));
                     // Don't consider fatal. Move on

                }
                
                // save the NTAccount
                if ( !mb.SetString( strObjectPath.QueryStrW(), 
                                    MD_MAPNTACCT, 
                                    IIS_MD_UT_SERVER, 
                                    strAcctName.QueryStrW(), 
                                    0 ) )
                {
                    ReportImportProblem( hr );
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    DBGPRINTF(( DBG_CONTEXT,
                            "Failed to write MD_MAPNTACCT.  hr = %x\n",
                            hr ));
                    // Don't consider fatal. Move on            }
                }
                
                // save the password - secure
                if ( !mb.SetString( strObjectPath.QueryStrW(), 
                                    MD_MAPNTPWD, 
                                    IIS_MD_UT_SERVER, 
                                    strPassword.QueryStrW(), 
                                    METADATA_SECURE ) )
                {
                    ReportImportProblem( hr );
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    DBGPRINTF(( DBG_CONTEXT,
                            "Failed to write MD_MAPNTPWD.  hr = %x\n",
                            hr ));
                    // Don't consider fatal. Move on            }
                }
                
                // save the map's name
                if ( !mb.SetString( strObjectPath.QueryStrW(), 
                                    MD_MAPNAME, 
                                    IIS_MD_UT_SERVER, 
                                    strMappingName.QueryStrW(), 
                                    0 ) )
                {
                    ReportImportProblem( hr );
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    DBGPRINTF(( DBG_CONTEXT,
                            "Failed to write MD_MAPNAME.  hr = %x\n",
                            hr ));
                    // Don't consider fatal. Move on            }
                }
                
                // save the Enabled flag
                // server reads the flag as the value of the dword
                if ( !mb.SetDword( strObjectPath.QueryStrW(), 
                                   MD_MAPENABLED, 
                                   IIS_MD_UT_SERVER, 
                                   *pdwEnabled, 
                                   0 ) )
                {
                    ReportImportProblem( hr );
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    DBGPRINTF(( DBG_CONTEXT,
                            "Failed to write MD_MAPENABLED.  hr = %x\n",
                            hr ));
                    // Don't consider fatal. Move on            }
                }
                NextMapping:
                ;
            }           

            //
            // Flush metabase changes after each instance
            // we have to close our metabase handles to make Save possible
            mb.Close();
            
            if ( !mb.Save() )
            {
                // we failed to save metabase
                // there is no guarantee that data we converted so far
                // will be persisted safely
                // In this case we rather leave legacy structure around
                hr = HRESULT_FROM_WIN32( GetLastError() );
                ReportImportProblem( hr );
                fMBSaved = FALSE;
            }
            else
            {
                fMBSaved = TRUE;
            }
            // Reopen metabase
            // we had to close it to be able to perform Save
            // Note: This function assumes that nobody is messing with the metabase
            // at this time (should be called only during upgrade) on iisadmin startup
            // If new service instance nodes are added or removed then
            // our site instance enumeration index could be off

            if ( !mb.Open( pszServicePath, 
                            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE ) )
            {
                hr = HRESULT_FROM_WIN32( GetLastError() );
                ReportImportProblem( hr );
                DBGPRINTF(( DBG_CONTEXT,
                       "Failed to open metabase path %s (import of 1to1 cert mappings will fail).  hr = %x\n",
                        pszServicePath, hr ));
                // still try another service if there is any left
                continue;
            } 
            
            if ( fMBSaved )
            {
                //
                // delete external storage - the *.mp file
                // for this mapper
                //
                if ( !AcctMapper.Delete() )
                {
                    //
                    // Unfortunately there will be some legacy data left behind
                    //
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    ReportImportProblem( hr );                    
                    DBGPRINTF(( DBG_CONTEXT,
                           "Failed to delete mp file for %s/%s. hr = %x\n",
                            pszServicePath, achServiceInstance, hr ));
                    // don't take error as fatal and move on
                }
                if ( !mb.DeleteData( achServiceInstance, MD_SERIAL_CERT11, 
                                 IIS_MD_UT_SERVER, BINARY_METADATA ) )
                {
                    //
                    // Unfortunately there will be some legacy data left behind
                    //
                    hr = HRESULT_FROM_WIN32( GetLastError() );
                    ReportImportProblem( hr );
                    DBGPRINTF(( DBG_CONTEXT,
                           "Failed to delete MD_SERIAL_CERT11 for %s/%s. hr = %x\n",
                            pszServicePath, achServiceInstance, hr ));
                    // don't take error as fatal and move on
                }
            }

            
            
        EnumNext:        
        ;
        }

        mb.Close();
    }
 Finished:

    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
        hKey = NULL;
    }
    
    if ( fCoInitialized )
    {
        CoUninitialize();
    }
    
    return;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\ftp\server\utility.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    utility.cxx

    This module contains routines of general utility.

    Functions exported by this module:

        TransferType
        TransferMode
        DisplayBool
        IsDecimalNumber
        AllocErrorText
        FreeErrorText
        OpenDosPath
        FlipSlashes
        OpenLogFile
        P_strncpy
        ParseUserName


    FILE HISTORY:
        KeithMo     17-Mar-1993 Created.

*/


#include "ftpdp.hxx"
#include <mbstring.h>

extern "C" {

    # include <ntlsa.h>
};

//
//  Public functions.
//

/*******************************************************************

    NAME:       TransferType

    SYNOPSIS:   Generates printable form of a transfer type.

    ENTRY:      type - From the XFER_TYPE enumerator.

    RETURNS:    CHAR * - "ASCII", "BINARY", etc.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
CHAR *
TransferType(
    XFER_TYPE type
    )
{
    CHAR * pszResult = NULL;

    switch( type )
    {
    case XferTypeAscii :
        pszResult = "ASCII";
        break;

    case XferTypeBinary :
        pszResult = "BINARY";
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                    "invalid transfer type %d\n",
                    type ));
        DBG_ASSERT( FALSE );
        pszResult = "ASCII";
        break;
    }

    DBG_ASSERT( pszResult != NULL );

    return pszResult;

}   // TransferType

/*******************************************************************

    NAME:       TransferMode

    SYNOPSIS:   Generates printable form of a transfer mode.

    ENTRY:      mode - From the XFER_MODE enumerator.

    RETURNS:    CHAR * - "STREAM", "BLOCK", etc.

    NOTES:      Currently, only the STREAM mode is suppored.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
CHAR *
TransferMode(
    XFER_MODE mode
    )
{
    CHAR * pszResult = NULL;

    switch( mode )
    {
    case XferModeStream :
        pszResult = "STREAM";
        break;

    case XferModeBlock :
        pszResult = "BLOCK";
        break;

    default :
        DBGPRINTF(( DBG_CONTEXT,
                    "invalid transfer mode %d\n",
                    mode ));
        DBG_ASSERT( FALSE );
        pszResult = "STREAM";
        break;
    }

    DBG_ASSERT( pszResult != NULL );

    return pszResult;

}   // TransferMode

/*******************************************************************

    NAME:       DisplayBool

    SYNOPSIS:   Generates printable form of a boolean.

    ENTRY:      fFlag - The BOOL to display.

    RETURNS:    CHAR * - "TRUE" or "FALSE".

    HISTORY:
        KeithMo     17-Mar-1993 Created.

********************************************************************/
CHAR *
DisplayBool(
    BOOL fFlag
    )
{
    return fFlag ? "TRUE" : "FALSE";

}   // DisplayBool

/*******************************************************************

    NAME:       IsDecimalNumber

    SYNOPSIS:   Determines if a given string represents a decimal
                number.

    ENTRY:      psz - The string to scan.

    RETURNS:    BOOL - TRUE if this is a decimal number, FALSE
                    otherwise.

    HISTORY:
        KeithMo     12-Mar-1993 Created.

********************************************************************/
BOOL
IsDecimalNumber(
    CHAR * psz
    )
{
    BOOL fResult = ( *psz != '\0' );
    CHAR ch;

    while( ch = *psz++ )
    {
        if( ( ch < '0' ) || ( ch > '9' ) )
        {
            fResult = FALSE;
            break;
        }
    }

    return fResult;

}   // IsDecimalNumber

/*******************************************************************

    NAME:       AllocErrorText

    SYNOPSIS:   Maps a specified Win32 error code to a textual
                description.  In the interest of multithreaded
                safety, this routine will allocate a block of memory
                to contain the text and return a pointer to that
                block.  It is up to the caller to free the block
                with FreeErrorText.

    ENTRY:      err - The error to map.

    RETURNS:    CHAR * - A textual description of err.  Will be NULL
                    if an error occurred while mapping err to text.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
CHAR *
AllocErrorText(
    APIERR err
    )
{
    APIERR   fmerr   = NO_ERROR;
    CHAR   * pszText = NULL;

    if( FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                           | FORMAT_MESSAGE_IGNORE_INSERTS
                           | FORMAT_MESSAGE_FROM_SYSTEM
                           | FORMAT_MESSAGE_MAX_WIDTH_MASK,
                       NULL,
                       (DWORD)err,
                       g_pInetSvc->IsSystemDBCS()   // always use english for
                           ? 0x409                  // FarEast NT system
                           : 0,
                       (LPTSTR)&pszText,
                       0,
                       NULL ) == 0 )
    {
        fmerr = GetLastError();
    }
    else
    {

    }

    IF_DEBUG( COMMANDS )
    {
        if( fmerr == NO_ERROR )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "mapped error %lu to %s\n",
                        err,
                        pszText ));
        }
        else
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "cannot map error %lu to text, error %lu\n",
                        err,
                        fmerr ));
        }
    }

    return pszText;

}   // AllocErrorText

/*******************************************************************

    NAME:       FreeErrorText

    SYNOPSIS:   Frees the pointer returned by AllocErrorText.

    ENTRY:      pszText - The text to free.  Must be a pointer
                    returned by AllocErrorText.

    HISTORY:
        KeithMo     27-Apr-1993 Created.

********************************************************************/
VOID
FreeErrorText(
    CHAR * pszText
    )
{
    LocalFree( (HLOCAL)pszText );

}   // FreeErrorText




DWORD
OpenPathForAccess(
    LPHANDLE    phFile,
    LPSTR       pszPath,
    ULONG       DesiredAccess,
    ULONG       ShareAccess,
    HANDLE      hImpersonation
    )
/*++
  This function opens a path for access to do some verification
    or holding on to the file/directory when a user is logged on.

  Arguments:
    phFile   - pointer to handle, where a handle is stored on
                successful return.

    pszPath  - pointer to null terminated string containing the path
                for path to be opened.

    DesiredAccess - Access type to the file.

    ShareAccess - access flags for shared opens.

    hImpersonation - Impersonation token for this user - used for
                      long filename check

  Returns:
     Win32 error code - NO_ERROR on success

  Author:
     MuraliK  14-Nov-1995
--*/
{
    WCHAR  awchPath[MAX_PATH+8+1];
    DWORD  dwError = NO_ERROR;

    if ( phFile == NULL) {

        return ( ERROR_INVALID_PARAMETER);
    }

    if (!TsMakeWidePath( pszPath, awchPath, MAX_PATH+8+1)) {

        return GetLastError();
    }

    *phFile = CreateFileW( awchPath,      // path for the file
                         DesiredAccess,   // fdwAccess
                         ShareAccess,     // fdwShareMode
                         NULL,            // Security attributes
                         OPEN_EXISTING,   // fdwCreate
                         FILE_FLAG_BACKUP_SEMANTICS,  // fdwAttrsAndFlags
                         NULL );          // hTemplateFile

    if ( *phFile == INVALID_HANDLE_VALUE) {

        dwError = GetLastError();
    }
    else {

        if ( strchr( pszPath, '~' )) {

            BOOL  fShort;

            RevertToSelf();

            dwError = CheckIfShortFileName( (UCHAR *) pszPath,
                                            hImpersonation,
                                            &fShort );

            if ( !dwError && fShort )
            {
                dwError = ERROR_FILE_NOT_FOUND;
                DBG_REQUIRE( CloseHandle( *phFile ));
                *phFile = INVALID_HANDLE_VALUE;
            }
        }
    }

    return ( dwError);

} // OpenPathForAccess()



/*******************************************************************

    NAME:       FlipSlashes

    SYNOPSIS:   Flips the DOS-ish backslashes ('\') into Unix-ish
                forward slashes ('/').

    ENTRY:      pszPath - The path to munge.
                fDirection - direction of destination. FLIP_SLASHES_TO_UNIX (0) or
                    FLIP_SLASHES_TO_DOS (1)
    RETURNS:    CHAR * - pszPath.

    HISTORY:
        KeithMo     04-Jun-1993 Created.

********************************************************************/
CHAR *
FlipSlashes(
    CHAR * pszPath,
    BOOL   fDirection
    )
{
    CHAR   ch, chSrc, chDst;
    CHAR * pszScan = pszPath;

    if (fDirection == FLIP_SLASHES_TO_UNIX) {
        chSrc = '\\';
        chDst = '/';
    } else {
        chSrc = '/';
        chDst = '\\';
    }

    while( ( ch = *pszScan ) != '\0' )
    {
        //
        //  skip DBCS character
        //
        if ( IsDBCSLeadByte( ch ) && *(pszScan+1) )
        {
            pszScan++;
        }
        else
        if( ch == chSrc )
        {
            *pszScan = chDst;
        }

        pszScan++;
    }

    return pszPath;

}   // FlipSlashes


/*******************************************************************

    NAME:

    SYNOPSIS:   breaks a username into it's domain and account components.
                usernames must be of the form:
                domain\user

    ENTRY:      pszDomainAndUser - input string to parse
                ppszUser         - on exit will point to user part
                ppszDomain       - on exit will point to domain part
                pszLocalHostName - points to local host name to compare to domain
                pfIsLocalHost    - flag returned to indicate the domain is local host

    RETURNS:    TRUE if parsed correctly, FALSE otherwise.

    SIDEEFFECT: modifies the input by adding a \0 to separate domain from user

    HISTORY:
        RobSol     02-Apr-2001 Created.

********************************************************************/
BOOL
ParseUserName(
    IN     PSTR  pszDomainAndUser,
    IN OUT PSTR *ppszUser,
    IN OUT PSTR *ppszDomain,
    IN     PCSTR pszLocalHostName,
    OUT    BOOL *pfIsLocalHost
    )
{
    *ppszUser = (PSTR)_mbschr( (PUCHAR)pszDomainAndUser, '\\' );
    *ppszDomain = pszDomainAndUser;

    if (*ppszUser == NULL) {
        return FALSE;
    } else {
        *(*ppszUser)++ = '\0';
    }

    if (**ppszUser == '\0' || **ppszDomain == '\0') {
        return FALSE;
    }

    *pfIsLocalHost = !_stricmp(*ppszDomain, pszLocalHostName);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\iismap\iismaprc.h ===
#define     IDS_IISMAP_FLD0             200
#define     IDS_IISMAP_FLD1             201
#define     IDS_IISMAP_FLD2             202
#define     IDS_IISMAP_FLD3             203
#define     IDS_IISMAP_FLD4             204
#define     IDS_IISMAP_FLD5             205
#define     IDS_IISMAP_FLD6             206
#define     IDS_IISMAP_FLD7             207

#define     IDS_IISMAP11_FLDS           500
#define     IDS_IISMAP11_FLDI           501
#define     IDS_IISMAP11_FLDA           502
#define     IDS_IISMAP11_FLDC           503
#define     IDS_IISMAP11_FLDN           504
#define     IDS_IISMAP11_FLDE           505
#define     IDS_IISMAP11_FLDP           506

#define     IDS_CMR_ASN_C               600
#define     IDS_CMR_ASN_O               601
#define     IDS_CMR_ASN_OU              602
#define     IDS_CMR_ASN_CN              603
#define     IDS_CMR_ASN_L               604
#define     IDS_CMR_ASN_S               605
#define     IDS_CMR_ASN_T               606
#define     IDS_CMR_ASN_GN              607
#define     IDS_CMR_ASN_I               608
#define     IDS_CMR_ASN_Email           609
#define     IDS_CMR_ASN_Addr            610

#define     IDS_CMR_X509FLD_IS          700
#define     IDS_CMR_X509FLD_SU          701
#define     IDS_CMR_X509FLD_SN          702
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\iismap\memalloc.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    memalloc.c

Abstract:

    Memory allocator for the crypto routines.

        IISCryptoAllocMemory
        IISCryptoFreeMemory

Author:

    Keith Moore (keithmo)        02-Dec-1996

Revision History:

--*/


extern "C" {


#include <iiscrypt.h>



PVOID
WINAPI
IISCryptoAllocMemory(
    IN DWORD Size
    )
{

    return (PVOID)LocalAlloc( LPTR, Size );

}   // IISCryptoAllocateMemory


VOID
WINAPI
IISCryptoFreeMemory(
    IN PVOID Buffer
    )
{

    (VOID)LocalFree( (HLOCAL)Buffer );

}   // IISCryptoFreeMemory


}   // extern "C"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\iismap\simplemb.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    simplemb.cxx

Abstract:

    based on mb.cxx from the iisrearc project

    This module implements the MB class using the DCOM interface.

    The old MB class (IIS4.0) was used internally within the IIS codebase to 
    access the metabase objects locally inprocess. This allowed  access to
    the metabase using the inprocess ANSI/COM interface.
  
    In the current incarnation, MB class attempts to support the following:
    o  Support UNICODE only interface to items
    o  Use only the DCOM interface of the Metabase (IMSAdminBase interface)
    o  Expose similar functionality like the MB class.

    Return Values:
      Almost all MB class members return BOOL values. 
      TRUE indicates success in the operation and FALSE indicates a failure.
      The class is expected to be used in-process for code that is mostly
        reliant on the Win32 style error reporting, it sets the error code in
        the thread and exposes them via GetLastError() interface.
Author:

    Murali Krishnan (MuraliK)        03-Nov-1998

Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <ole2.h>

#include <iadmw.h>
#include <simplemb.hxx>
#include "dbgutil.h"

//
//  Default timeout
//

#define MB_TIMEOUT           (30 * 1000)

//
//  Default timeout for SaveData
//

#define MB_SAVE_TIMEOUT      (10 * 1000)        // milliseconds


/************************************************************
 *     Member Functions of SimpleMB
 ************************************************************/

SimpleMB::SimpleMB( IMSAdminBase * pAdminBase )
    : m_pAdminBase( pAdminBase ),
      m_hMBPath ( NULL)
{
    DBG_ASSERT( m_pAdminBase != NULL);

    //
    // Add ref the admin base object so that we can keep this object around.
    // 
    m_pAdminBase->AddRef();
}

SimpleMB::~SimpleMB( VOID )
{
    //
    // Close the metabase handle if we have it open
    // 
    if ( NULL != m_hMBPath) {
        //
        // Close can sometimes fail with error RPC_E_DISCONNECTED.
        // Do not Assert
        //
        Close();
    }

    //
    // Release the AdminBase object here 
    //
    if ( NULL != m_pAdminBase) {
        m_pAdminBase->Release();
        m_pAdminBase = NULL;
    }
} // SimpleMB::~SimpleMB()




/*********************************************************************++

Routine Description:

    Opens the metabase and saves the metabase handle in the current object.
    Note: If there is already an opened handle, this method will fail.

Arguments:

    hOpenRoot - Relative root or METADATA_MASTER_ROOT_HANDLE
    pwszPath  - Path to open
    dwFlags   - Open flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())
    The handle opened is stored inside the MB object.

--*********************************************************************/
BOOL 
SimpleMB::Open( METADATA_HANDLE hOpenRoot,
          LPCWSTR    pwszPath,
          DWORD      dwFlags )
{
    HRESULT hr;

    if ( m_hMBPath != NULL) {
        SetLastError( ERROR_PATH_NOT_FOUND );
        return (FALSE);
    }

    hr = m_pAdminBase->OpenKey( hOpenRoot,
                                pwszPath,
                                dwFlags,
                                MB_TIMEOUT,
                                &m_hMBPath );
    
    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ) );
    return FALSE;
} // SimpleMB::Open()



/*********************************************************************++
  Routine Descrition:
    This function closes the metabase handle that we have open in 
    this MB object

  Arguments:
    None

  Returns:
    TRUE on success
    FALSE if there are any errors. Use GetLastError() to retrieve the error
      on failure.
--*********************************************************************/

BOOL SimpleMB::Close( VOID )
{
    if ( m_hMBPath )
    {
        HRESULT hr;

        hr = m_pAdminBase->CloseKey( m_hMBPath );

        if (FAILED(hr)) {
            SetLastError( HRESULTTOWIN32( hr));
            return (FALSE);
        }

        m_hMBPath = NULL;
    }

    return TRUE;
} // SimpleMB::Close()



/*********************************************************************++
  Routine Descrition:
    This function saves all the changes that we have made using current
    metabase object.

  Arguments:
    None

  Returns:
    TRUE on success
    FALSE if there are any errors. Use GetLastError() to retrieve the error
      on failure.
--*********************************************************************/
BOOL SimpleMB::Save( VOID )
{
    HRESULT hr;

    if ( NULL != m_pAdminBase) { 
        hr = m_pAdminBase->SaveData();

        if ( FAILED( hr)) {
            SetLastError( HRESULTTOWIN32( hr));
            return (FALSE);
        }
    }
        
    return (TRUE);
} // SimpleMB::Save()




/*********************************************************************++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath    - Path to get the data on
    dwFlags    - Inerhitance flags
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to data
    pcbData    - Size of pvData, receives size of object
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
SimpleMB::GetAll( IN LPCWSTR     pszPath,
            DWORD          dwFlags,
            DWORD          dwUserType,
            BUFFER *       pBuff,
            DWORD *        pcRecords,
            DWORD *        pdwDataSetNumber )
{
    DWORD   RequiredSize;
    HRESULT hr;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    do {

        hr = m_pAdminBase->
            GetAllData( m_hMBPath,
                        pszPath,
                        dwFlags,
                        dwUserType,
                        ALL_METADATA,
                        pcRecords,
                        pdwDataSetNumber,
                        pBuff->QuerySize(),
                        (PBYTE)pBuff->QueryPtr(),
                        &RequiredSize
                        );
        
        // See if we got it, and if we failed because of lack of buffer space
        // try again.
        
        if ( SUCCEEDED(hr) ) {
                return TRUE;
        }
        
        //
        // Some sort of error, most likely not enough buffer space. Keep
        // trying until we get a non-fatal error.
        //
        
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32 &&
            HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
            
            // Not enough buffer space. RequiredSize contains the amount
            // the metabase thinks we need.
            
            if ( !pBuff->Resize(RequiredSize) ) {
                
                // Not enough memory to resize.
                return FALSE;
            }
        } else {
          
            //
            // Some other failure: return the failure to caller
            //

            SetLastError(HRESULTTOWIN32(hr));
            break;
        }
    } while (FAILED(hr));

    return FALSE;
} // SimpleMB::GetAll()



/*********************************************************************++
  Routine Description:
    This function retrieves the data set number from the metabase
     for the given path.

  Arguments:
    pszPath - pointer to string containing the path for metabase item
    pdwDataSetNumber - pointer to DWORD that will contain the dataset
               number on return.

  Returns:
    TRUE on success. FALSE for failure
--*********************************************************************/
BOOL
SimpleMB::GetDataSetNumber(IN LPCWSTR pszPath,
                     OUT DWORD * pdwDataSetNumber)
{
    HRESULT hr;

    DBG_ASSERT ( m_pAdminBase != NULL);

    //
    //  NULL metabase handle is permitted here
    //

    hr = m_pAdminBase->GetDataSetNumber( m_hMBPath, pszPath, pdwDataSetNumber);
    if (FAILED (hr)) {
        SetLastError( HRESULTTOWIN32( hr));
        return (FALSE);
    }

    return (TRUE);
} // SimpleMB::GetDataSetNumber()



/*********************************************************************++
  Routine Description:
    Enumerates and obtain the name of the object at given index position
     within the given path in the tree.

  Arguments:
    pszPath - pointer to string containing the path for metabase item
    pszName - pointer to a buffer that will contain the name of the item
              at index position [dwIndex]. The buffer should at least be
              ADMINDATA_MAX_NAME_LEN+1 character in length
    dwIndex - index for the item to be enumerated.

  Returns:
    TRUE on success. FALSE for failure.
    ERROR_NO_MORE_ITEMS when the end of the list is reached.

  A typical use is to enumerate for all items starting at index 0 and 
   enumerating till the return value is FALSE with error = ERROR_NO_MORE_ITEMS
--*********************************************************************/
BOOL
SimpleMB::EnumObjects( IN LPCWSTR  pszPath,
                 OUT LPWSTR  pszName,
                 IN DWORD    dwIndex )
{
    HRESULT hr = m_pAdminBase->EnumKeys( m_hMBPath,
                                           pszPath,
                                           pszName,
                                           dwIndex );

    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ));
    return FALSE;
} // SimpleMB::EnumObjects()


BOOL
SimpleMB::AddObject( IN LPCWSTR pszPath)
{
    HRESULT hr;
    
    hr = m_pAdminBase->AddKey( m_hMBPath, pszPath);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);

} // SimpleMB::AddObject()


BOOL
SimpleMB::DeleteObject( IN LPCWSTR pszPath)
{
    HRESULT hr;
    
    hr = m_pAdminBase->DeleteKey( m_hMBPath, pszPath);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // SimpleMB::DeleteObject()


BOOL
SimpleMB::DeleteData(
   IN LPCWSTR  pszPath,
   IN DWORD    dwPropID,
   IN DWORD    /*dwUserType*/,
   IN DWORD    dwDataType )
{
    HRESULT hr = m_pAdminBase->DeleteData( m_hMBPath,
                                           pszPath,
                                           dwPropID,
                                           dwDataType
                                           );
    if ( SUCCEEDED( hr ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hr ));
    return(FALSE);
} // SimpleMB::DeleteData()


BOOL
SimpleMB::GetSystemChangeNumber( OUT DWORD * pdwChangeNumber)
{
    HRESULT hr = m_pAdminBase->GetSystemChangeNumber( pdwChangeNumber);
    
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} 


/*********************************************************************++

Routine Description:

    Sets a metadata property on an opened metabase path.

Arguments:

    pszPath    - Path to set data on
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to data buffer containing the data.
    cbData     - Size of data
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
SimpleMB::SetData( IN LPCWSTR pszPath,
             IN DWORD   dwPropID,
             IN DWORD   dwUserType,
             IN DWORD   dwDataType,
             IN VOID *  pvData,
             IN DWORD   cbData,
             IN DWORD   dwFlags )
{
    HRESULT hr;
    METADATA_RECORD mdr;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    mdr.dwMDIdentifier = dwPropID;
    mdr.dwMDAttributes = dwFlags;
    mdr.dwMDUserType   = dwUserType;
    mdr.dwMDDataType   = dwDataType;
    mdr.dwMDDataLen    = cbData;
    mdr.pbMDData       = (BYTE * ) pvData;

    hr = m_pAdminBase->SetData(m_hMBPath, pszPath, &mdr);
    if (SUCCEEDED(hr)) {
        return ( TRUE);
    } 

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);

} // SimpleMB::SetData()




/*********************************************************************++

Routine Description:

    Obtains the metadata requested in the call. 
    It uses the current opened metabase path for getting the data.

Arguments:

    pszPath    - Path to get data on
    dwPropID   - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData     - Pointer to buffer in which the data will be obtained
    pcbData    - Size of data
    dwFlags    - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
SimpleMB::GetData( IN LPCWSTR pszPath,
             IN DWORD   dwPropID,
             IN DWORD   dwUserType,
             IN DWORD   dwDataType,
             OUT VOID * pvData,
             IN OUT DWORD *  pcbData,
             IN DWORD   dwFlags)
{
    HRESULT hr;
    METADATA_RECORD mdr;
    DWORD           dwRequiredDataLen;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    mdr.dwMDIdentifier = dwPropID;
    mdr.dwMDAttributes = dwFlags;
    mdr.dwMDUserType   = dwUserType;
    mdr.dwMDDataType   = dwDataType;
    mdr.dwMDDataLen    = *pcbData;
    mdr.pbMDData       = (BYTE * ) pvData;

    hr = m_pAdminBase->GetData(m_hMBPath, pszPath, &mdr, &dwRequiredDataLen);

    if (SUCCEEDED(hr)) {
        *pcbData = mdr.dwMDDataLen;
        return ( TRUE);
    } 

    *pcbData = dwRequiredDataLen;

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // SimpleMB::GetData()



/*********************************************************************++

Routine Description:

    Obtains the paths beneath the given path in the metadata tree.
    It uses the current opened metabase path for getting the data.

Arguments:

    pszPath - Path to get data on
    dwPropID - Metabase property ID
    dwDataType - Type of data being set (dword, string etc)
    pBuff    - pointer to BUFFER object that will contain the resulting data

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*********************************************************************/
BOOL
SimpleMB::GetDataPaths(IN LPCWSTR   pszPath,
                 IN DWORD     dwPropID,
                 IN DWORD     dwDataType,
                 IN BUFFER *  pBuff )
{
    HRESULT hr;
    DWORD           cchRequiredDataLen;

    DBG_ASSERT( m_pAdminBase != NULL);
    DBG_ASSERT( m_hMBPath != NULL);

    do { 

        hr = m_pAdminBase->GetDataPaths( m_hMBPath, 
                                         pszPath,
                                         dwPropID,
                                         dwDataType,
                                         pBuff->QuerySize() / sizeof(WCHAR),
                                         (LPWSTR ) pBuff->QueryPtr(),
                                         &cchRequiredDataLen
                                         );
        
        if ( SUCCEEDED( hr)) {
            
            return (TRUE);
        }

        // Some sort of error, most likely not enough buffer space. Keep
        // trying until we get a non-fatal error.
        
        if (HRESULT_FACILITY(hr) == FACILITY_WIN32 &&
            HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) 
        {
            
            // Not enough buffer space. 
            // cchRequiredDataLen contains the # of wide chars that metabase
            //    thinks we need.
            
            if ( !pBuff->Resize( (cchRequiredDataLen + 1) * sizeof(WCHAR)) )
            {
                
                // Not enough memory to resize.
                return FALSE;
            }
        } else {

            // unknown failure. return failure
            break;
        }

    } while (FAILED(hr));

    DBG_ASSERT( FAILED(hr));

    SetLastError( HRESULTTOWIN32( hr));
    return (FALSE);
} // SimpleMB::GetDataPaths()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\iismap\sources.inc ===
!IF 0

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Murali R. Krishnan    09-Oct-1995
          This sources.inc file is copied off from original sources file
           to support building two dlls.

Revision History:

!ENDIF

TARGETPATH=obj

MSC_WARNING_LEVEL=/W3 /WX

TARGETTYPE=DYNLINK

USE_MSVCRT=1
DLLENTRY=_DllMainCRTStartup

RAW_TARGETLIBS=\
            $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib    \
            $(SDK_LIB_PATH)\kernel32.lib    \
            $(SDK_LIB_PATH)\advapip.lib     \
            $(SDK_LIB_PATH)\user32.lib

TARGETLIBS=\
           ..\lib\*\iiscrypt.lib \
           ..\lib\*\icrypt.lib \
		   $(RAW_TARGETLIBS)

SOURCES=\
	iismap.cxx \
	iiscmr.cxx \
  memalloc.cxx \
	iismap.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\iissuba\subauth.c ===
/*++


Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    subauth.c

Abstract:

    Sample SubAuthentication Package.

Author:

    Cliff Van Dyke (cliffv) 23-May-1994

Revisions:

    Andy Herron (andyhe)    21-Jun-1994  Added code to read domain/user info
    Philippe Choquier (phillich) 6-Jun-1996 Adapted for IIS

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

--*/


#if ( _MSC_VER >= 800 )
#pragma warning ( 3 : 4100 ) // enable "Unreferenced formal parameter"
#pragma warning ( 3 : 4219 ) // enable "trailing ',' used for variable argument list"
#pragma warning ( disable : 4005 )
#endif

# include <nt.h>
# include <ntrtl.h>
# include <nturtl.h>
#define WIN32_NO_STATUS
#include <windef.h>
#undef WIN32_NO_STATUS
# include <windows.h>

#include <lmcons.h>
#include <lmaccess.h>
#include <lmapibuf.h>
#include <lsarpc.h>
#include <samrpc.h>
#include <crypt.h>
#include <sspi.h>
#include <secpkg.h>
#include <samisrv.h>
#include <debnot.h>
#include "subauth.h"        // local copy :(
#include "md5.h"

UNICODE_STRING EmptyString = { 0, 0, NULL };

BOOLEAN
EqualComputerName(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    );

NTSTATUS
QuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    );


BOOL
GetPasswordExpired(
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    );

NTSTATUS
AccountRestrictions(
    IN ULONG UserRid,
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    );

LARGE_INTEGER
NetpSecondsToDeltaTime(
    IN ULONG Seconds
    );

VOID
InitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    );

VOID
CopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    );

BOOL
SubaAllocateString(
    STRING *pS,
    UINT cS
    )
{
    if ( pS->Buffer = (CHAR*)RtlAllocateHeap( RtlProcessHeap(),
                                  HEAP_ZERO_MEMORY,
                                  cS ) )
    {
        pS->MaximumLength = (USHORT)cS;
        pS->Length = 0;

        return TRUE;
    }

    pS->MaximumLength = 0;
    pS->Length = 0;

    return FALSE;
}



NTSTATUS
ToHex16(
    LPBYTE       pSrc,
    PANSI_STRING pDst
    )
{
    char achH[16*2+1];
    UINT x,y;

#define TOAHEX(a) ((a)>=10 ? 'a'+(a)-10 : '0'+(a))

    for ( x = 0, y = 0 ; x < 16 ; ++x )
    {
        UINT v;
        v = pSrc[x]>>4;
        achH[y++] = TOAHEX( v );
        v = pSrc[x]&0x0f;
        achH[y++] = TOAHEX( v );
    }
    achH[y] = '\0';

    return RtlAppendAsciizToString( (PSTRING)pDst, achH );
}


BOOL Extract(
    CHAR **ppch,
    LPSTR* ppszTok
    )
{
    CHAR *pch = *ppch;

    if ( *pch )
    {
        *ppszTok = pch;
        while ( *pch && *pch != '"' )
        {
            ++pch;
        }
        if ( *pch == '"' )
        {
            *pch++ = '\0';
        }

        *ppch = pch;

        return TRUE;
    }

    return FALSE;
}


BOOL
WINAPI
NetUserCookieW(
    LPWSTR      lpwszUserName,
    UINT        cNameLen,
    DWORD       dwSeed,
    LPWSTR      lpwszCookieBuff,
    DWORD       dwBuffSize
    )
/*++

Routine Description:

    Compute logon validator ( to be used as password )
    for IISSuba

Arguments:

    lpszUsername -- user name
    dwSeed -- start value of cookie

Returns:

    TRUE if success, FALSE if error

--*/
{
    UINT x,y,v;
#define TOHEX(a) ((a)>=10 ? L'a'+(a)-10 : L'0'+(a))


    if ( dwBuffSize < sizeof(dwSeed)*2*sizeof(WCHAR) + sizeof(WCHAR) )
    {
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    while ( cNameLen-- )
    {
        dwSeed = ((dwSeed << 5) | ( dwSeed >> 27 )) ^ ((*lpwszUserName++)&0xff);
    }

    for ( x = 0, y = 0 ; x < sizeof(dwSeed) ; ++x )
    {
        v = ((LPBYTE)&dwSeed)[x]>>4;
        lpwszCookieBuff[y++] = TOHEX( v );
        v = ((LPBYTE)&dwSeed)[x]&0x0f;
        lpwszCookieBuff[y++] = TOHEX( v );
    }
    lpwszCookieBuff[y] = '\0';

    return TRUE;
}

NTSTATUS
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user. The credentials of the user are passed in addition to all the
    information from SAM defining the user. This routine decides whether to
    let the user log on.


Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should log off the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to log on at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to log on to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER PasswordDateSet;
    UNICODE_STRING LocalWorkstation;
    WCHAR achCookie[64];
    ANSI_STRING strA1;
    ANSI_STRING strA2;
    ANSI_STRING strDigest;
    ANSI_STRING AnsiPwd;
    MD5_CTX md5;
    CHAR *pch;
    LPSTR pszRealm;
    LPSTR pszUri;
    LPSTR pszMethod;
    LPSTR pszNonce;
    LPSTR pszServerNonce;
    LPSTR pszDigest;
    LPSTR pszDigestUsername;
    LPSTR pszQOP;
    LPSTR pszCNonce;
    LPSTR pszNC;
    PNETLOGON_NETWORK_INFO LogonNetworkInfo;
    UINT l;
    PUNICODE_STRING pPwd = NULL;
    UNICODE_STRING PackageName;
    UNICODE_STRING UserPwd;
    VOID *pvPlainPwd = NULL;
    ULONG ulLength = 0;
    BOOL fNTDigest = FALSE;
    CHAR achAnsiPwdBuffer[MAX_PASSWD_LEN + 1];
    strA1.Buffer = NULL;
    strA2.Buffer = NULL;
    strDigest.Buffer = NULL;

    AnsiPwd.Buffer = achAnsiPwdBuffer;
    AnsiPwd.Length = AnsiPwd.MaximumLength = MAX_PASSWD_LEN;

    //
    // Check whether the SubAuthentication package supports this type
    //  of logon.
    //

    (VOID) QuerySystemTime( &LogonTime );

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        //
        // This SubAuthentication package only supports network logons.
        //

        return STATUS_INVALID_INFO_CLASS;

    case NetlogonNetworkInformation:

        //
        // This SubAuthentication package doesn't support access via machine
        // accounts.
        //

        UserAccountControl = USER_NORMAL_ACCOUNT;

        //
        // Local user (Temp Duplicate) accounts are only used on the machine
        // being directly logged onto.
        // (Nor are interactive or service logons allowed to them.)
        //

        if ( (Flags & MSV1_0_PASSTHRU) == 0 ) {
            UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
        }

        LogonNetworkInfo = (PNETLOGON_NETWORK_INFO) LogonInformation;

        break;

    default:
        return STATUS_INVALID_INFO_CLASS;
    }


    //
    // Check the password.
    //

#define IIS_SUBAUTH_SEED    0x8467fd31

    switch( ((WCHAR*)(LogonNetworkInfo->NtChallengeResponse.Buffer))[0] )
    {
        case L'0':
            if ( !NetUserCookieW( LogonNetworkInfo->Identity.UserName.Buffer,
                                  LogonNetworkInfo->Identity.UserName.Length/sizeof(WCHAR),
                                  IIS_SUBAUTH_SEED,
                                  achCookie,
                                  sizeof(achCookie ))
                 || memcmp( (LPBYTE)achCookie,
                            ((WCHAR*)LogonNetworkInfo->NtChallengeResponse.Buffer)+2,
                            wcslen(achCookie)*sizeof(WCHAR)
                            ) )
            {
wrong_pwd:
                Status = STATUS_WRONG_PASSWORD;

            }
            else
            {
                Status = STATUS_SUCCESS;
            }

            goto Cleanup;

            break;

        case L'1':
            // NTLM digest authentication
            fNTDigest = TRUE;

            //fall through

        case L'2':
            //"Normal" digest authentication

            // break fields

            pch = LogonNetworkInfo->LmChallengeResponse.Buffer;

            if ( !Extract( &pch, &pszRealm ) || // skip 1st field
                 !Extract( &pch, &pszRealm ) ||
                 !Extract( &pch, &pszUri ) ||
                 !Extract( &pch, &pszMethod ) ||
                 !Extract( &pch, &pszNonce ) ||
                 !Extract( &pch, &pszServerNonce ) ||
                 !Extract( &pch, &pszDigest ) ||
                 !Extract( &pch, &pszDigestUsername ) ||
                 !Extract( &pch, &pszQOP ) ||
                 !Extract( &pch, &pszCNonce ) ||
                 !Extract( &pch, &pszNC ) )
            {
                Status = STATUS_ACCESS_DENIED;
                goto Cleanup;
            }

            //
            // For NTLM Digest, use the NT hash of the password passed in
            // For 'normal' Digest, use the cleartext
            //
            if ( fNTDigest )
            {
                if ( UserAll->NtPasswordPresent )
                {
                    pPwd = &UserAll->NtPassword;
                }
                else if ( UserAll->LmPasswordPresent )
                {
                    pPwd = &UserAll->LmPassword;
                }
                else
                {
                    pPwd = &EmptyString;
                }
            }
            else
            {
                //
                // Retrieve the plaintext password
                //
                // NOTE : On NT 5, this API only works on Domain Controllers !!
                //
                PackageName.Buffer = SAM_CLEARTEXT_CREDENTIAL_NAME;
                PackageName.Length = PackageName.MaximumLength = (USHORT)
                    wcslen( SAM_CLEARTEXT_CREDENTIAL_NAME ) * sizeof(WCHAR);

                Status = SamIRetrievePrimaryCredentials( (SAMPR_HANDLE) UserHandle,
                                                         &PackageName,
                                                         &pvPlainPwd,
                                                         &ulLength );


                if ( !NT_SUCCESS( Status ) )
                {
#if DBG
                    CHAR achErrorString[256];
                    wsprintf(achErrorString, "Failed to retrieve plaintext password, error 0x%x\n",
                             Status);
                    OutputDebugString(achErrorString);
#endif //DBG
                    //
                    // Explicitly set the status to be "wrong password" instead of whatever
                    // is returned by SamIRetrievePrimaryCredentials
                    //
                    Status = STATUS_WRONG_PASSWORD;
                    goto Cleanup;
                }
                else
                {
                    PSAMPR_USER_INFO_BUFFER             pUserInfo = NULL;

                    //
                    // Need to differentiate between an empty password and
                    // a non-existant/unaccessible password
                    //

                    if ( ulLength == 0 )
                    {
                        Status = SamrQueryInformationUser( UserHandle,
                                                           UserAllInformation,
                                                           &pUserInfo );
                        if ( !NT_SUCCESS( Status ) )
                        {
                            Status = STATUS_ACCESS_DENIED;
                            goto Cleanup;
                        }

                        if ( pUserInfo->All.LmPasswordPresent ||
                             pUserInfo->All.NtPasswordPresent )
                        {
                            Status = STATUS_WRONG_PASSWORD;

                            SamIFree_SAMPR_USER_INFO_BUFFER( pUserInfo,
                                                             UserAllInformation );
                            goto Cleanup;
                        }

                        SamIFree_SAMPR_USER_INFO_BUFFER( pUserInfo,
                                                         UserAllInformation );
                    }

                    UserPwd.Buffer = (USHORT *) pvPlainPwd;
                    UserPwd.Length = UserPwd.MaximumLength = (USHORT) ulLength;
                }
                //
                // The unicode password has to be converted to ANSI
                //
                if ( !NT_SUCCESS( Status = RtlUnicodeStringToAnsiString( &AnsiPwd,
                                                                         &UserPwd,
                                                                         FALSE ) ) )
                {
                    goto Cleanup;
                }
            }

            //
            // A1 = username:realm:password
            //
            SubaAllocateString( &strA1, strlen( pszDigestUsername ) +
                                //wcslen(UserAll->UserName.Buffer) +
                                strlen(pszRealm) +
                                ( fNTDigest ? 32 : AnsiPwd.Length ) +
                                +2 +1 +32 );

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, pszDigestUsername ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, pszRealm ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, ":" )) ||
                 (fNTDigest ? !NT_SUCCESS( Status = ToHex16( (LPBYTE)(pPwd->Buffer), &strA1 ) ) :
                              !NT_SUCCESS( Status = RtlAppendAsciizToString( &strA1, AnsiPwd.Buffer ) ) ) )
            {
                goto Cleanup;
            }

            //
            // A2 = Method:URI
            //

            if ( !SubaAllocateString( &strA2, strlen(pszMethod)+1+strlen(pszUri)+1+32 ) )
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, pszMethod ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, pszUri ) ) )
            {
                goto Cleanup;
            }

            if ( !SubaAllocateString( &strDigest, 32 + 1 + strlen(pszNonce) + 1 + 32 +1 +32 + strlen(pszCNonce) + 32) )
            {
                Status = STATUS_NO_MEMORY;
                goto Cleanup;
            }

            //
            // build response digest as per Digest Auth spec
            // Response Digest = KD( H(A1), nonce : H(A2) )
            //                 = H( H(A1) : nonce : H(A2) )
            // In our case, the hash function is MD5
            //

            // H(A1)

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strA1.Buffer, strA1.Length );
            MD5Final( &md5 );
            if ( !NT_SUCCESS( Status = ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            // ":" nonce ":"

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, pszNonce ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, ":" ) ) )
            {
                goto Cleanup;
            }

            if ( strcmp( pszQOP, "none" ) )
            {
                if ( strcmp( pszQOP, "auth" ) )
                {
                    Status = STATUS_ACCESS_DENIED;
                    goto Cleanup;
                }

                if ( !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, pszNC ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, ":" ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, pszCNonce ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, ":" ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, pszQOP ) ) ||
                     !NT_SUCCESS( Status = RtlAppendAsciizToString( &strDigest, ":" ) ) )
                {
                    goto Cleanup;
                }
            }

            // H(A2)

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strA2.Buffer, strA2.Length );
            MD5Final( &md5 );
            if ( !NT_SUCCESS( ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            // H( H(A1) ":" nonce ":" H(A2) ) if QOP not set
            // H( H(A1) ":" nonce ":" nc ":" cnonce ":" qop ":" H(A2) if set

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strDigest.Buffer, strDigest.Length );
            MD5Final( &md5 );

            strDigest.Length = 0;
            if ( !NT_SUCCESS( Status = ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            if ( memcmp( strDigest.Buffer, pszDigest, strDigest.Length ) )
            {
                Status = STATUS_WRONG_PASSWORD;
                goto Cleanup;
            }
            else
            {
                Status = STATUS_SUCCESS;
                goto Cleanup;
            }

            // checking for stalled nonce must be made by caller

            break;

        default:
            goto wrong_pwd;
    }

    //
    // Cleanup up before returning.
    //

Cleanup:

    if ( strA1.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strA1.Buffer );
    }
    if ( strA2.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strA2.Buffer );
    }
    if ( strDigest.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strDigest.Buffer );
    }
    if ( pvPlainPwd )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, pvPlainPwd);
    }


    //
    // the only thing we did was check the password
    //

    ValidationInfo;
    UserHandle;

    *ActionsPerformed = MSV1_0_SUBAUTH_PASSWORD;

    return Status;

}  // Msv1_0SubAuthenticationRoutineEx




BOOL
GetPasswordExpired (
    IN LARGE_INTEGER PasswordLastSet,
    IN LARGE_INTEGER MaxPasswordAge
    )

/*++

Routine Description:

    This routine returns true if the password is expired, false otherwise.

Arguments:

    PasswordLastSet - Time when the password was last set for this user.

    MaxPasswordAge - Maximum password age for any password in the domain.

Return Value:

    Returns true if password is expired.  False if not expired.

--*/
{
    LARGE_INTEGER PasswordMustChange;
    NTSTATUS Status;
    BOOLEAN rc;
    LARGE_INTEGER TimeNow;

    //
    // Compute the expiration time as the time the password was
    // last set plus the maximum age.
    //

    if ( PasswordLastSet.QuadPart < 0 || MaxPasswordAge.QuadPart > 0 ) {

        rc = TRUE;      // default for invalid times is that it is expired.

    } else {

        __try {

            PasswordMustChange.QuadPart =
                PasswordLastSet.QuadPart - MaxPasswordAge.QuadPart;
            //
            // Limit the resultant time to the maximum valid absolute time
            //

            if ( PasswordMustChange.QuadPart < 0 ) {

                rc = FALSE;

            } else {

                Status = QuerySystemTime( &TimeNow );
                if (NT_SUCCESS(Status)) {

                    if ( TimeNow.QuadPart >= PasswordMustChange.QuadPart ) {
                        rc = TRUE;

                    } else {

                        rc = FALSE;
                    }
                } else {
                    rc = FALSE;     // won't fail if QuerySystemTime failed.
                }
            }

        } __except(EXCEPTION_EXECUTE_HANDLER) {

            rc = TRUE;
        }
    }

    return rc;

}  // GetPasswordExpired


NTSTATUS
QuerySystemTime (
    OUT PLARGE_INTEGER SystemTime
    )

/*++

Routine Description:

    This function returns the absolute system time. The time is in units of
    100nsec ticks since the base time which is midnight January 1, 1601.

Arguments:

    SystemTime - Supplies the address of a variable that will receive the
        current system time.

Return Value:

    STATUS_SUCCESS is returned if the service is successfully executed.

    STATUS_ACCESS_VIOLATION is returned if the output parameter for the
        system time cannot be written.

--*/

{
    SYSTEMTIME CurrentTime;

    GetSystemTime( &CurrentTime );

    if ( !SystemTimeToFileTime( &CurrentTime, (LPFILETIME) SystemTime ) ) {
        return STATUS_ACCESS_VIOLATION;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SampMatchworkstation(
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations
    )

/*++

Routine Description:

    Check if the given workstation is a member of the list of workstations
    given.


Arguments:

    LogonWorkStations - UNICODE name of the workstation that the user is
        trying to log into.

    WorkStations - API list of workstations that the user is allowed to
        log into.


Return Value:


    STATUS_SUCCESS - The user is allowed to log into the workstation.



--*/
{
    PWCHAR          WorkStationName;
    UNICODE_STRING  Unicode;
    NTSTATUS        NtStatus;
    WCHAR           Buffer[256];
    USHORT          LocalBufferLength = 256;
    UNICODE_STRING  WorkStationsListCopy;
    BOOLEAN         BufferAllocated = FALSE;
    PWCHAR          TmpBuffer;

    //
    // Local workstation is always allowed
    // If WorkStations field is 0 everybody is allowed
    //

    if ( ( LogonWorkStation == NULL ) ||
        ( LogonWorkStation->Length == 0 ) ||
        ( WorkStations->Length == 0 ) ) {

        return( STATUS_SUCCESS );
    }

    //
    // Assume failure; change status only if we find the string.
    //

    NtStatus = STATUS_INVALID_WORKSTATION;

    //
    // WorkStationApiList points to our current location in the list of
    // WorkStations.
    //

    if ( WorkStations->Length > LocalBufferLength ) {

        WorkStationsListCopy.Buffer = LocalAlloc( 0, WorkStations->Length );
        BufferAllocated = TRUE;

        if ( WorkStationsListCopy.Buffer == NULL ) {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            return( NtStatus );
        }

        WorkStationsListCopy.MaximumLength = WorkStations->Length;

    } else {

        WorkStationsListCopy.Buffer = Buffer;
        WorkStationsListCopy.MaximumLength = LocalBufferLength;
    }

    CopyUnicodeString( &WorkStationsListCopy, WorkStations );

    //
    // wcstok requires a string the first time it's called, and NULL
    // for all subsequent calls.  Use a temporary variable so we
    // can do this.
    //

    TmpBuffer = WorkStationsListCopy.Buffer;

    while( WorkStationName = wcstok(TmpBuffer, L",") ) {

        TmpBuffer = NULL;
        InitUnicodeString( &Unicode, WorkStationName );
        if (EqualComputerName( &Unicode, LogonWorkStation )) {
            NtStatus = STATUS_SUCCESS;
            break;
        }
    }

    if ( BufferAllocated ) {
        LocalFree( WorkStationsListCopy.Buffer );
    }

    return( NtStatus );
}

NTSTATUS
AccountRestrictions(
    IN ULONG UserRid,
    IN PUNICODE_STRING LogonWorkStation,
    IN PUNICODE_STRING WorkStations,
    IN PLOGON_HOURS LogonHours,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
    )

/*++

Routine Description:

    Validate a user's ability to log on at this time and at the workstation
    being logged onto.


Arguments:

    UserRid - The user id of the user to operate on.

    LogonWorkStation - The name of the workstation the logon is being
        attempted at.

    WorkStations - The list of workstations the user may log on to.  This
        information comes from the user's account information.  It must
        be in API list format.

    LogonHours - The times the user may logon.  This information comes
        from the user's account information.

    LogoffTime - Receives the time at which the user should log off the
        system.

    KickoffTime - Receives the time at which the user should be kicked
        off the system.


Return Value:


    STATUS_SUCCESS - Logon is permitted.

    STATUS_INVALID_LOGON_HOURS - The user is not authorized to log on at
        this time.

    STATUS_INVALID_WORKSTATION - The user is not authorized to log on to
        the specified workstation.


--*/
{

    static BOOLEAN GetForceLogoff = TRUE;
    static LARGE_INTEGER ForceLogoff = { 0x7fffffff, 0xFFFFFFF};

#define MILLISECONDS_PER_WEEK 7 * 24 * 60 * 60 * 1000

    SYSTEMTIME              CurrentTimeFields;
    LARGE_INTEGER           CurrentTime, CurrentUTCTime;
    LARGE_INTEGER           MillisecondsIntoWeekXUnitsPerWeek;
    LARGE_INTEGER           LargeUnitsIntoWeek;
    LARGE_INTEGER           Delta100Ns;
    NTSTATUS                NtStatus = STATUS_SUCCESS;
    ULONG                   CurrentMsIntoWeek;
    ULONG                   LogoffMsIntoWeek;
    ULONG                   DeltaMs;
    ULONG                   MillisecondsPerUnit;
    ULONG                   CurrentUnitsIntoWeek;
    ULONG                   LogoffUnitsIntoWeek;
    USHORT                  i;
    TIME_ZONE_INFORMATION   TimeZoneInformation;
    DWORD TimeZoneId;
    LARGE_INTEGER           BiasIn100NsUnits;
    LONG                    BiasInMinutes;



    //
    // Only check for users other than the builtin ADMIN
    //

    if ( UserRid != DOMAIN_USER_RID_ADMIN) {

        //
        // Scan to make sure the workstation being logged into is in the
        // list of valid workstations - or if the list of valid workstations
        // is null, which means that all are valid.
        //

        NtStatus = SampMatchworkstation( LogonWorkStation, WorkStations );

        if ( NT_SUCCESS( NtStatus ) ) {

            //
            // Check to make sure that the current time is a valid time to log
            // on in the LogonHours.
            //
            // We need to validate the time taking into account whether we are
            // in daylight savings time or standard time.  Thus, if the logon
            // hours specify that we are able to log on between 9am and 5pm,
            // this means 9am to 5pm standard time during the standard time
            // period, and 9am to 5pm daylight savings time when in the
            // daylight savings time.  Since the logon hours stored by SAM are
            // independent of daylight savings time, we need to add in the
            // difference between standard time and daylight savings time to
            // the current time before checking whether this time is a valid
            // time to log on.  Since this difference (or bias as it is called)
            // is actually held in the form
            //
            // Standard time = Daylight savings time + Bias
            //
            // the Bias is a negative number.  Thus we actually subtract the
            // signed Bias from the Current Time.

            //
            // First, get the Time Zone Information.
            //

            TimeZoneId = GetTimeZoneInformation(
                             (LPTIME_ZONE_INFORMATION) &TimeZoneInformation
                             );

            //
            // Next, get the appropriate bias (signed integer in minutes) to subtract from
            // the Universal Time Convention (UTC) time returned by NtQuerySystemTime
            // to get the local time.  The bias to be used depends whether we're
            // in Daylight Savings time or Standard Time as indicated by the
            // TimeZoneId parameter.
            //
            // local time  = UTC time - bias in 100Ns units
            //

            switch (TimeZoneId) {

            case TIME_ZONE_ID_UNKNOWN:

                //
                // There is no differentiation between standard and
                // daylight savings time.  Proceed as for Standard Time
                //

                BiasInMinutes = TimeZoneInformation.StandardBias;
                break;

            case TIME_ZONE_ID_STANDARD:

                BiasInMinutes = TimeZoneInformation.StandardBias;
                break;

            case TIME_ZONE_ID_DAYLIGHT:

                BiasInMinutes = TimeZoneInformation.DaylightBias;
                break;

            default:

                //
                // Something is wrong with the time zone information.  Fail
                // the logon request.
                //

                NtStatus = STATUS_INVALID_LOGON_HOURS;
                break;
            }

            if (NT_SUCCESS(NtStatus)) {

                //
                // Convert the Bias from minutes to 100ns units
                //

                BiasIn100NsUnits.QuadPart = ((LONGLONG)BiasInMinutes)
                                            * 60 * 10000000;

                //
                // Get the UTC time in 100Ns units used by Windows Nt.  This
                // time is GMT.
                //

                NtStatus = QuerySystemTime( &CurrentUTCTime );
            }

            if ( NT_SUCCESS( NtStatus ) ) {

                CurrentTime.QuadPart = CurrentUTCTime.QuadPart -
                              BiasIn100NsUnits.QuadPart;

                FileTimeToSystemTime( (PFILETIME)&CurrentTime, &CurrentTimeFields );

                CurrentMsIntoWeek = (((( CurrentTimeFields.wDayOfWeek * 24 ) +
                                       CurrentTimeFields.wHour ) * 60 +
                                       CurrentTimeFields.wMinute ) * 60 +
                                       CurrentTimeFields.wSecond ) * 1000 +
                                       CurrentTimeFields.wMilliseconds;

                MillisecondsIntoWeekXUnitsPerWeek.QuadPart =
                    ((LONGLONG)CurrentMsIntoWeek) *
                    ((LONGLONG)LogonHours->UnitsPerWeek);

                LargeUnitsIntoWeek.QuadPart =
                    MillisecondsIntoWeekXUnitsPerWeek.QuadPart / ((ULONG) MILLISECONDS_PER_WEEK);

                CurrentUnitsIntoWeek = LargeUnitsIntoWeek.LowPart;

                if ( !( LogonHours->LogonHours[ CurrentUnitsIntoWeek / 8] &
                    ( 0x01 << ( CurrentUnitsIntoWeek % 8 ) ) ) ) {

                    NtStatus = STATUS_INVALID_LOGON_HOURS;

                } else {

                    //
                    // Determine the next time that the user is NOT supposed to be logged
                    // in, and return that as LogoffTime.
                    //

                    i = 0;
                    LogoffUnitsIntoWeek = CurrentUnitsIntoWeek;

                    do {

                        i++;

                        LogoffUnitsIntoWeek = ( LogoffUnitsIntoWeek + 1 ) % LogonHours->UnitsPerWeek;

                    } while ( ( i <= LogonHours->UnitsPerWeek ) &&
                        ( LogonHours->LogonHours[ LogoffUnitsIntoWeek / 8 ] &
                        ( 0x01 << ( LogoffUnitsIntoWeek % 8 ) ) ) );

                    if ( i > LogonHours->UnitsPerWeek ) {

                        //
                        // All times are allowed, so there's no logoff
                        // time.  Return forever for both LogoffTime and
                        // KickoffTime.
                        //

                        LogoffTime->HighPart = 0x7FFFFFFF;
                        LogoffTime->LowPart = 0xFFFFFFFF;

                        KickoffTime->HighPart = 0x7FFFFFFF;
                        KickoffTime->LowPart = 0xFFFFFFFF;

                    } else {

                        //
                        // LogoffUnitsIntoWeek points at which time unit the
                        // user is to log off.  Calculate actual time from
                        // the unit, and return it.
                        //
                        // CurrentTimeFields already holds the current
                        // time for some time during this week; just adjust
                        // to the logoff time during this week and convert
                        // to time format.
                        //

                        MillisecondsPerUnit = MILLISECONDS_PER_WEEK / LogonHours->UnitsPerWeek;

                        LogoffMsIntoWeek = MillisecondsPerUnit * LogoffUnitsIntoWeek;

                        if ( LogoffMsIntoWeek < CurrentMsIntoWeek ) {

                            DeltaMs = MILLISECONDS_PER_WEEK - ( CurrentMsIntoWeek - LogoffMsIntoWeek );

                        } else {

                            DeltaMs = LogoffMsIntoWeek - CurrentMsIntoWeek;
                        }

                        Delta100Ns.QuadPart = (LONGLONG) DeltaMs * 10000;

                        LogoffTime->QuadPart = CurrentUTCTime.QuadPart +
                                      Delta100Ns.QuadPart;

                        //
                        // Grab the domain's ForceLogoff time.
                        //

                        if ( GetForceLogoff ) {
                            NET_API_STATUS NetStatus;
                            LPUSER_MODALS_INFO_0 UserModals0;

                            NetStatus = NetUserModalsGet( NULL,
                                                          0,
                                                          (LPBYTE *)&UserModals0 );

                            if ( NetStatus == 0 ) {
                                GetForceLogoff = FALSE;

                                ForceLogoff = NetpSecondsToDeltaTime( UserModals0->usrmod0_force_logoff );

                                NetApiBufferFree( UserModals0 );
                            }
                        }
                        //
                        // Subtract Domain->ForceLogoff from LogoffTime, and return
                        // that as KickoffTime.  Note that Domain->ForceLogoff is a
                        // negative delta.  If its magnitude is sufficiently large
                        // (in fact, larger than the difference between LogoffTime
                        // and the largest positive large integer), we'll get overflow
                        // resulting in a KickOffTime that is negative.  In this
                        // case, reset the KickOffTime to this largest positive
                        // large integer (i.e. "never") value.
                        //


                        KickoffTime->QuadPart = LogoffTime->QuadPart - ForceLogoff.QuadPart;

                        if (KickoffTime->QuadPart < 0) {

                            KickoffTime->HighPart = 0x7FFFFFFF;
                            KickoffTime->LowPart = 0xFFFFFFFF;
                        }
                    }
                }
            }
        }

    } else {

        //
        // Never kick administrators off
        //

        LogoffTime->HighPart  = 0x7FFFFFFF;
        LogoffTime->LowPart   = 0xFFFFFFFF;
        KickoffTime->HighPart = 0x7FFFFFFF;
        KickoffTime->LowPart  = 0xFFFFFFFF;
    }


    return( NtStatus );
}

LARGE_INTEGER
NetpSecondsToDeltaTime(
    IN ULONG Seconds
    )

/*++

Routine Description:

    Convert a number of seconds to an NT delta time specification

Arguments:

    Seconds - a positive number of seconds

Return Value:

    Returns the NT Delta time.  NT delta time is a negative number
        of 100ns units.

--*/

{
    LARGE_INTEGER DeltaTime;
    LARGE_INTEGER LargeSeconds;
    LARGE_INTEGER Answer;

    //
    // Special case TIMEQ_FOREVER (return a full scale negative)
    //

    if ( Seconds == TIMEQ_FOREVER ) {
        DeltaTime.LowPart = 0;
        DeltaTime.HighPart = (LONG) 0x80000000;

    //
    // Convert seconds to 100ns units simply by multiplying by 10000000.
    //
    // Convert to delta time by negating.
    //

    } else {

        LargeSeconds.LowPart = Seconds;
        LargeSeconds.HighPart = 0;

        Answer.QuadPart = LargeSeconds.QuadPart * 10000000;

          if ( Answer.QuadPart < 0 ) {
            DeltaTime.LowPart = 0;
            DeltaTime.HighPart = (LONG) 0x80000000;
        } else {
            DeltaTime.QuadPart = -Answer.QuadPart;
        }

    }

    return DeltaTime;

} // NetpSecondsToDeltaTime


BOOLEAN
EqualComputerName(
    IN PUNICODE_STRING String1,
    IN PUNICODE_STRING String2
    )
/*++

Routine Description:

    Compare two computer names for equality.

Arguments:

    String1 - Name of first computer.
    String2 - Name of second computer.

Return Value:

    TRUE if the names, converted to OEM, compare case-insensitively,
    FALSE if they don't compare or can't be converted to OEM.

--*/
{
    WCHAR Computer1[CNLEN+1];
    WCHAR Computer2[CNLEN+1];
    CHAR OemComputer1[CNLEN+1];
    CHAR OemComputer2[CNLEN+1];

    //
    // Make sure the names are not too long
    //

    if ((String1->Length > CNLEN*sizeof(WCHAR)) ||
        (String2->Length > CNLEN*sizeof(WCHAR))) {
        return(FALSE);

    }

    //
    // Copy them to null terminated strings
    //

    CopyMemory(
        Computer1,
        String1->Buffer,
        String1->Length
        );
    Computer1[String1->Length/sizeof(WCHAR)] = L'\0';

    CopyMemory(
        Computer2,
        String2->Buffer,
        String2->Length
        );
    Computer2[String2->Length/sizeof(WCHAR)] = L'\0';

    //
    // Convert the computer names to OEM
    //

    if (!CharToOemW(
            Computer1,
            OemComputer1
            )) {
        return(FALSE);
    }

    if (!CharToOemW(
            Computer2,
            OemComputer2
            )) {
        return(FALSE);
    }

    //
    // Do a case insensitive comparison of the oem computer names.
    //

    if (lstrcmpiA(OemComputer1, OemComputer2) == 0)
    {
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

VOID
InitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The InitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
        the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (SourceString != NULL) {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
        }
    else {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
        }
}

VOID
CopyUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PUNICODE_STRING SourceString OPTIONAL
    )

/*++

Routine Description:

    The CopyString function copies the SourceString to the
    DestinationString.  If SourceString is not specified, then
    the Length field of DestinationString is set to zero.  The
    MaximumLength and Buffer fields of DestinationString are not
    modified by this function.

    The number of bytes copied from the SourceString is either the
    Length of SourceString or the MaximumLength of DestinationString,
    whichever is smaller.

Arguments:

    DestinationString - Pointer to the destination string.

    SourceString - Optional pointer to the source string.

Return Value:

    None.

--*/

{
    UNALIGNED WCHAR *src, *dst;
    ULONG n;

    if (SourceString != NULL) {
        dst = DestinationString->Buffer;
        src = SourceString->Buffer;
        n = SourceString->Length;
        if ((USHORT)n > DestinationString->MaximumLength) {
            n = DestinationString->MaximumLength;
        }

        DestinationString->Length = (USHORT)n;
        CopyMemory(dst, src, n);
        if (DestinationString->Length < DestinationString->MaximumLength) {
            dst[n / sizeof(WCHAR)] = UNICODE_NULL;
        }

    } else {
        DestinationString->Length = 0;
    }

    return;
}

#if 0

NTSTATUS
Msv1_0SubAuthenticationRoutine (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
/*++

Routine Description:

    The subauthentication routine does client/server specific authentication
    of a user. The credentials of the user are passed in addition to all the
    information from SAM defining the user. This routine decides whether to
    let the user log on.


Arguments:

    LogonLevel -- Specifies the level of information given in
        LogonInformation.

    LogonInformation -- Specifies the description for the user
        logging on.  The LogonDomainName field should be ignored.

    Flags - Flags describing the circumstances of the logon.

        MSV1_0_PASSTHRU -- This is a PassThru authenication.  (i.e., the
            user isn't connecting to this machine.)
        MSV1_0_GUEST_LOGON -- This is a retry of the logon using the GUEST
            user account.

    UserAll -- The description of the user as returned from SAM.

    WhichFields -- Returns which fields from UserAllInfo are to be written
        back to SAM.  The fields will only be written if MSV returns success
        to it's caller.  Only the following bits are valid.

        USER_ALL_PARAMETERS - Write UserAllInfo->Parameters back to SAM.  If
            the size of the buffer is changed, Msv1_0SubAuthenticationRoutine
            must delete the old buffer using MIDL_user_free() and reallocate the
            buffer using MIDL_user_allocate().

    UserFlags -- Returns UserFlags to be returned from LsaLogonUser in the
        LogonProfile.  The following bits are currently defined:


            LOGON_GUEST -- This was a guest logon
            LOGON_NOENCRYPTION -- The caller didn't specify encrypted credentials

        SubAuthentication packages should restrict themselves to returning
        bits in the high order byte of UserFlags.  However, this convention
        isn't enforced giving the SubAuthentication package more flexibility.

    Authoritative -- Returns whether the status returned is an
        authoritative status which should be returned to the original
        caller.  If not, this logon request may be tried again on another
        domain controller.  This parameter is returned regardless of the
        status code.

    LogoffTime - Receives the time at which the user should log off the
        system.  This time is specified as a GMT relative NT system time.

    KickoffTime - Receives the time at which the user should be kicked
        off the system. This time is specified as a GMT relative system
        time.  Specify, a full scale positive number if the user isn't to
        be kicked off.

Return Value:

    STATUS_SUCCESS: if there was no error.

    STATUS_NO_SUCH_USER: The specified user has no account.
    STATUS_WRONG_PASSWORD: The password was invalid.

    STATUS_INVALID_INFO_CLASS: LogonLevel is invalid.
    STATUS_ACCOUNT_LOCKED_OUT: The account is locked out
    STATUS_ACCOUNT_DISABLED: The account is disabled
    STATUS_ACCOUNT_EXPIRED: The account has expired.
    STATUS_PASSWORD_MUST_CHANGE: Account is marked as Password must change
        on next logon.
    STATUS_PASSWORD_EXPIRED: The Password is expired.
    STATUS_INVALID_LOGON_HOURS - The user is not authorized to log on at
        this time.
    STATUS_INVALID_WORKSTATION - The user is not authorized to log on to
        the specified workstation.

--*/
{
    NTSTATUS Status;
    ULONG UserAccountControl;
    LARGE_INTEGER LogonTime;
    LARGE_INTEGER PasswordDateSet;
    UNICODE_STRING LocalWorkstation;
    WCHAR achCookie[64];
    ANSI_STRING strA1;
    ANSI_STRING strA2;
    ANSI_STRING strDigest;
    ANSI_STRING strPassword;
    MD5_CTX md5;
    CHAR *pch;
    LPSTR pszRealm;
    LPSTR pszUri;
    LPSTR pszMethod;
    LPSTR pszNonce;
    LPSTR pszServerNonce;
    LPSTR pszDigest;
    LPSTR pszDigestUsername;
    PNETLOGON_NETWORK_INFO LogonNetworkInfo;
    UINT l;
    PUNICODE_STRING pPwd;

    strA1.Buffer = NULL;
    strA2.Buffer = NULL;
    strDigest.Buffer = NULL;
    strPassword.Buffer = NULL;

    //
    // Check whether the SubAuthentication package supports this type
    //  of logon.
    //

    *Authoritative = TRUE;
    *UserFlags = 0;
    *WhichFields = 0;

    (VOID) QuerySystemTime( &LogonTime );

    switch ( LogonLevel ) {
    case NetlogonInteractiveInformation:
    case NetlogonServiceInformation:

        //
        // This SubAuthentication package only supports network logons.
        //

        return STATUS_INVALID_INFO_CLASS;

    case NetlogonNetworkInformation:

        //
        // This SubAuthentication package doesn't support access via machine
        // accounts.
        //

        UserAccountControl = USER_NORMAL_ACCOUNT;

        //
        // Local user (Temp Duplicate) accounts are only used on the machine
        // being directly logged onto.
        // (Nor are interactive or service logons allowed to them.)
        //

        if ( (Flags & MSV1_0_PASSTHRU) == 0 ) {
            UserAccountControl |= USER_TEMP_DUPLICATE_ACCOUNT;
        }

        LogonNetworkInfo = (PNETLOGON_NETWORK_INFO) LogonInformation;

        break;

    default:
        *Authoritative = TRUE;
        return STATUS_INVALID_INFO_CLASS;
    }




    //
    // If the account type isn't allowed,
    //  Treat this as though the User Account doesn't exist.
    //

    if ( (UserAccountControl & UserAll->UserAccountControl) == 0 ) {
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }

    //
    // This SubAuthentication package doesn't allow guest logons.
    //
    if ( Flags & MSV1_0_GUEST_LOGON ) {
        *Authoritative = FALSE;
        Status = STATUS_NO_SUCH_USER;
        goto Cleanup;
    }



    //
    // Ensure the account isn't locked out.
    //

    if ( UserAll->UserId != DOMAIN_USER_RID_ADMIN &&
         (UserAll->UserAccountControl & USER_ACCOUNT_AUTO_LOCKED) ) {

        //
        // Since the UI strongly encourages admins to disable user
        // accounts rather than delete them.  Treat disabled acccount as
        // non-authoritative allowing the search to continue for other
        // accounts by the same name.
        //
        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
            *Authoritative = FALSE;
        } else {
            *Authoritative = TRUE;
        }
        Status = STATUS_ACCOUNT_LOCKED_OUT;
        goto Cleanup;
    }


    //
    // Check the password.
    //

#define IIS_SUBAUTH_SEED    0x8467fd31

    switch( ((WCHAR*)(LogonNetworkInfo->NtChallengeResponse.Buffer))[0] )
    {
        case L'0':
            if ( !NetUserCookieW( LogonNetworkInfo->Identity.UserName.Buffer,
                                  LogonNetworkInfo->Identity.UserName.Length/sizeof(WCHAR),
                                  IIS_SUBAUTH_SEED,
                                  achCookie,
                                  sizeof(achCookie ))
                 || memcmp( (LPBYTE)achCookie,
                            ((WCHAR*)LogonNetworkInfo->NtChallengeResponse.Buffer)+2,
                            wcslen(achCookie)*sizeof(WCHAR)
                            ) )
            {
wrong_pwd:
                Status = STATUS_WRONG_PASSWORD;

                //
                // Since the UI strongly encourages admins to disable user
                // accounts rather than delete them.  Treat disabled acccount as
                // non-authoritative allowing the search to continue for other
                // accounts by the same name.
                //
                if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
                    *Authoritative = FALSE;
                } else {
                    *Authoritative = TRUE;
                }

                goto Cleanup;
            }
            break;

        case L'1':
            // digest NTLM authentication

            // break fields

            pch = LogonNetworkInfo->LmChallengeResponse.Buffer;

            if ( !Extract( &pch, &pszRealm ) || // skip 1st field
                 !Extract( &pch, &pszRealm ) ||
                 !Extract( &pch, &pszUri ) ||
                 !Extract( &pch, &pszMethod ) ||
                 !Extract( &pch, &pszNonce ) ||
                 !Extract( &pch, &pszServerNonce ) ||
                 !Extract( &pch, &pszDigest ) ||
                 !Extract( &pch, &pszDigestUsername ) )
            {
                Status = STATUS_INVALID_INFO_CLASS;
                goto Cleanup;
            }

            if ( UserAll->NtPasswordPresent )
            {
                pPwd = &UserAll->NtPassword;
            }
            else if ( UserAll->LmPasswordPresent )
            {
                pPwd = &UserAll->LmPassword;
            }
            else
            {
                pPwd = &EmptyString;
            }

            // build A1 & A2 as per Digest-NTLM auth spec

            SubaAllocateString( &strA1, strlen( pszDigestUsername ) +
                    //wcslen(UserAll->UserName.Buffer) +
                    strlen(pszRealm) +
                    32 //wcslen(pPwd)
                    +2 +1 +32
                    );

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, pszDigestUsername ) ) ||
                 //!NT_SUCCESS( Status = RtlUnicodeStringToAnsiString( &strA1, &UserAll->UserName, FALSE )) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, pszRealm ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA1, ":" )) ||
                 !NT_SUCCESS( ToHex16( (LPBYTE)(pPwd->Buffer), &strA1 ) ) )
                 //!NT_SUCCESS( Status = RtlUnicodeStringToAnsiString( &strPassword, pPwd, TRUE ) ) ||
                 //!NT_SUCCESS( Status = RtlAppendStringToString( (PSTRING)&strA1, (PSTRING)&strPassword ) ) )
            {
                goto Cleanup;
            }

            SubaAllocateString( &strA2, strlen(pszMethod)+1+strlen(pszUri)+1+32 );
            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, pszMethod ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strA2, pszUri ) ) )
            {
                goto Cleanup;
            }

            SubaAllocateString( &strDigest, 32 + 1 + strlen(pszNonce) + 1 + 32 +1 +32 );

            // build response digest as per Digest Auth spec

            // H(A1)

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strA1.Buffer, strA1.Length );
            MD5Final( &md5 );
            if ( !NT_SUCCESS( ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            // ":" nonce ":"

            if ( !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, ":" ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, pszNonce ) ) ||
                 !NT_SUCCESS( Status = RtlAppendAsciizToString ( &strDigest, ":" ) ) )
            {
                goto Cleanup;
            }

            // H(A2)

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strA2.Buffer, strA2.Length );
            MD5Final( &md5 );
            if ( !NT_SUCCESS( ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            // H( H(A1) ":" nonce ":" H(A2) )

            MD5Init( &md5 );
            MD5Update( &md5, (LPBYTE)strDigest.Buffer, strDigest.Length );
            MD5Final( &md5 );

            strDigest.Length = 0;
            if ( !NT_SUCCESS( ToHex16( md5.digest, &strDigest ) ) )
            {
                goto Cleanup;
            }

            if ( memcmp( strDigest.Buffer, pszDigest, strDigest.Length ) )
            {
                goto wrong_pwd;
            }

            // checking for stalled nonce must be made by caller

            break;

        default:
            goto wrong_pwd;
    }

    //
    // Prevent some things from effecting the Administrator user
    //

    if (UserAll->UserId == DOMAIN_USER_RID_ADMIN) {

        //
        //  The administrator account doesn't have a forced logoff time.
        //

        LogoffTime->HighPart = 0x7FFFFFFF;
        LogoffTime->LowPart = 0xFFFFFFFF;

        KickoffTime->HighPart = 0x7FFFFFFF;
        KickoffTime->LowPart = 0xFFFFFFFF;

    } else {

        //
        // Check if the account is disabled.
        //

        if ( UserAll->UserAccountControl & USER_ACCOUNT_DISABLED ) {
            //
            // Since the UI strongly encourages admins to disable user
            // accounts rather than delete them.  Treat disabled acccount as
            // non-authoritative allowing the search to continue for other
            // accounts by the same name.
            //
            *Authoritative = FALSE;
            Status = STATUS_ACCOUNT_DISABLED;
            goto Cleanup;
        }

        //
        // Check if the account has expired.
        //

        if ( UserAll->AccountExpires.QuadPart != 0 &&
             LogonTime.QuadPart >= UserAll->AccountExpires.QuadPart ) {
            *Authoritative = TRUE;
            Status = STATUS_ACCOUNT_EXPIRED;
            goto Cleanup;
        }

        //
        //  If your using SAM's password expiration date, use this code, otherwise
        //  use the code below and supply your own password set date...
        //
#if 1
        //
        // The password is valid, check to see if the password is expired.
        //  (SAM will have appropriately set PasswordMustChange to reflect
        //  USER_DONT_EXPIRE_PASSWORD)
        //
        // If the password checked above is not the SAM password, you may
        // want to consider not checking the SAM password expiration times here.
        //

        if ( LogonTime.QuadPart >= UserAll->PasswordMustChange.QuadPart ) {

            if ( UserAll->PasswordLastSet.QuadPart == 0 ) {
                Status = STATUS_PASSWORD_MUST_CHANGE;
            } else {
                Status = STATUS_PASSWORD_EXPIRED;
            }
            *Authoritative = TRUE;
            goto Cleanup;
        }

#elif 0

        //
        // Response is correct. So, check if the password has expired or not
        //

        if (! (UserAll->UserAccountControl & USER_DONT_EXPIRE_PASSWORD)) {
            LARGE_INTEGER MaxPasswordAge;
            MaxPasswordAge.HighPart = 0x7FFFFFFF;
            MaxPasswordAge.LowPart = 0xFFFFFFFF;

            //
            // PasswordDateSet should be modified to hold the last date the
            // user's password was set.
            //

            PasswordDateSet.LowPart = 0;
            PasswordDateSet.HighPart = 0;

            if ( GetPasswordExpired( PasswordDateSet,
                        MaxPasswordAge )) {

                Status = STATUS_PASSWORD_EXPIRED;
                goto Cleanup;
            }
        }

#endif


#if 1

        //
        // Validate the workstation the user logged on from.
        //
        // Ditch leading \\ on workstation name before passing it to SAM.
        //

        LocalWorkstation = LogonNetworkInfo->Identity.Workstation;
        if ( LocalWorkstation.Length > 0 &&
             LocalWorkstation.Buffer[0] == L'\\' &&
             LocalWorkstation.Buffer[1] == L'\\' ) {
            LocalWorkstation.Buffer += 2;
            LocalWorkstation.Length -= 2*sizeof(WCHAR);
            LocalWorkstation.MaximumLength -= 2*sizeof(WCHAR);
        }


        //
        //  To validate the user's logon hours as SAM does it, use this code,
        //  otherwise, supply your own checks below this code.
        //

        Status = AccountRestrictions( UserAll->UserId,
                                      &LocalWorkstation,
                                      (PUNICODE_STRING) &UserAll->WorkStations,
                                      &UserAll->LogonHours,
                                      LogoffTime,
                                      KickoffTime );

        if ( !NT_SUCCESS( Status )) {
            goto Cleanup;
        }

#elif 0

        //
        // Validate the user's logon hours.
        //

        if ( TRUE /* VALIDATE THE LOGON HOURS */ ) {


            //
            // All times are allowed, so there's no logoff
            // time.  Return forever for both logofftime and
            // kickofftime.
            //

            LogoffTime->HighPart = 0x7FFFFFFF;
            LogoffTime->LowPart = 0xFFFFFFFF;

            KickoffTime->HighPart = 0x7FFFFFFF;
            KickoffTime->LowPart = 0xFFFFFFFF;
        } else {
            Status = STATUS_INVALID_LOGON_HOURS;
            *Authoritative = TRUE;
            goto Cleanup;
        }
#endif
#if 0
        //
        // Validate if the user can log on from this workstation.
        //  (Supply subauthentication package specific code here.)

        if ( LogonNetworkInfo->Identity.Workstation.Buffer == NULL ) {
            Status = STATUS_INVALID_WORKSTATION;
            *Authoritative = TRUE;
            goto Cleanup;
        }
#endif
    }


    //
    // The user is valid.
    //

    *Authoritative = TRUE;
    Status = STATUS_SUCCESS;

    //
    // Cleanup up before returning.
    //

Cleanup:

    if ( strA1.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strA1.Buffer );
    }
    if ( strA2.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strA2.Buffer );
    }
    if ( strDigest.Buffer )
    {
        RtlFreeHeap(RtlProcessHeap(), 0, strDigest.Buffer );
    }
    if ( strPassword.Buffer )
    {
        RtlFreeAnsiString( &strPassword );
    }

    return Status;

}  // Msv1_0SubAuthenticationRoutine


NTSTATUS
Msv1_0SubAuthenticationFilter (
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
)
{
    return( Msv1_0SubAuthenticationRoutine(
                LogonLevel,
                LogonInformation,
                Flags,
                UserAll,
                WhichFields,
                UserFlags,
                Authoritative,
                LogoffTime,
                KickoffTime
                ) );
}
#endif

static const CHAR       c_szKeyName[] = "SYSTEM\\CurrentControlSet\\Control\\Lsa\\MSV1_0";
static const CHAR       c_szValueName[] = "Auth132";
static const CHAR       c_szIISSUBA[] = "IISSUBA";

VOID CALLBACK
RegisterIISSUBA(
  HWND                  hwnd,       // handle to owner window
  HINSTANCE             hinst,      // instance handle for the DLL
  LPTSTR                lpCmdLine,  // string the DLL will parse
  int                   nCmdShow     // show state
)
{
    HRESULT             hr = S_OK;
    LONG                lRet;
    HKEY                hKey = NULL;

    UNREFERENCED_PARM(hwnd);
    UNREFERENCED_PARM(hinst);
    UNREFERENCED_PARM(lpCmdLine);
    UNREFERENCED_PARM(nCmdShow);

    // Open the key
    lRet = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                          c_szKeyName,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey );
    if ( lRet != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lRet );
        goto exit;
    }

    // Create Auth132 = IISSUBA
    lRet = RegSetValueEx( hKey,
                          c_szValueName,
                          0,
                          REG_SZ,
                          (BYTE*)c_szIISSUBA,
                          sizeof( c_szIISSUBA ) );
    if ( lRet != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lRet );
        goto exit;
    }

exit:
    // Cleanup
    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
        hKey = NULL;
    }
}

VOID CALLBACK
UnregisterIISSUBA(
  HWND                  hwnd,       // handle to owner window
  HINSTANCE             hinst,      // instance handle for the DLL
  LPTSTR                lpCmdLine,  // string the DLL will parse
  int                   nCmdShow    // show state
)
{
    HRESULT             hr = S_OK;
    LONG                lRet;
    HKEY                hKey = NULL;

    UNREFERENCED_PARM(hwnd);
    UNREFERENCED_PARM(hinst);
    UNREFERENCED_PARM(lpCmdLine);
    UNREFERENCED_PARM(nCmdShow);

    // Open the key
    lRet = RegOpenKeyExA( HKEY_LOCAL_MACHINE,
                          c_szKeyName,
                          0,
                          KEY_ALL_ACCESS,
                          &hKey );
    if ( lRet != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lRet );
        goto exit;
    }

    // Delete Auth132
    lRet = RegDeleteValue( hKey,
                           c_szValueName );
    if ( lRet != ERROR_SUCCESS )
    {
        hr = HRESULT_FROM_WIN32( lRet );
        goto exit;
    }

exit:
    // Cleanup
    if ( hKey != NULL )
    {
        RegCloseKey( hKey );
        hKey = NULL;
    }
}

// subauth.c eof
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\iissuba\subauth.h ===
/*++ BUILD Version: 0005     Increment this if a change has global effects

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    subauth.h

Abstract:

    This module defines types and macros for Subauthentication Packages.

    *******************************NOTE*********************************

    This file is a copy of \nt\public\sdk\inc\subauth.h with a few
    definitions removed?  Why?  Because we need to use some SAM internal
    calls defined with SAMRPC.H, LSARPC.H, SAMISRV.H, etc. and these define
    some types which are redefined in \nt\public\sdk\inc\subauth.h causing
    compile errors.  This hack is temporary until post B3 when SAM adds the
    necessary semantics we need to avoid calling into SamrQueryInformationUser.

    ********************************************************************

Revision History:

--*/

#ifndef _NTSUBAUTH_
#define _NTSUBAUTH_

#ifdef __cplusplus
extern "C" {
#endif

#if (!defined(_NTDEF_)) && (!defined(_NTSECAPI_))
typedef LONG NTSTATUS, *PNTSTATUS;

typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

typedef struct _STRING {
    USHORT Length;
    USHORT MaximumLength;
    PCHAR Buffer;
} STRING, *PSTRING;
#endif

#ifndef _NTDEF_

typedef struct _OLD_LARGE_INTEGER {
    ULONG LowPart;
    LONG HighPart;
} OLD_LARGE_INTEGER, *POLD_LARGE_INTEGER;

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#endif

#ifndef _NTSAM_SAM_HANDLE_
typedef PVOID SAM_HANDLE, *PSAM_HANDLE;
#define _NTSAM_SAM_HANDLE_
#endif
#ifndef _NTSAM_USER_ACCOUNT_FLAGS_

//
// User account control flags...
//

#define USER_ACCOUNT_DISABLED                (0x00000001)
#define USER_HOME_DIRECTORY_REQUIRED         (0x00000002)
#define USER_PASSWORD_NOT_REQUIRED           (0x00000004)
#define USER_TEMP_DUPLICATE_ACCOUNT          (0x00000008)
#define USER_NORMAL_ACCOUNT                  (0x00000010)
#define USER_MNS_LOGON_ACCOUNT               (0x00000020)
#define USER_INTERDOMAIN_TRUST_ACCOUNT       (0x00000040)
#define USER_WORKSTATION_TRUST_ACCOUNT       (0x00000080)
#define USER_SERVER_TRUST_ACCOUNT            (0x00000100)
#define USER_DONT_EXPIRE_PASSWORD            (0x00000200)
#define USER_ACCOUNT_AUTO_LOCKED             (0x00000400)
#define USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED (0x00000800)
#define USER_SMARTCARD_REQUIRED              (0x00001000)
#define USER_TRUSTED_FOR_DELEGATION          (0x00002000)
#define USER_NOT_DELEGATED                   (0x00004000)
#define USER_USE_DES_KEY_ONLY                (0x00008000)
#define USER_DONT_REQUIRE_PREAUTH            (0x00010000)
#define NEXT_FREE_ACCOUNT_CONTROL_BIT (USER_DONT_REQUIRE_PREAUTH << 1)


#define USER_MACHINE_ACCOUNT_MASK      \
            ( USER_INTERDOMAIN_TRUST_ACCOUNT |\
              USER_WORKSTATION_TRUST_ACCOUNT |\
              USER_SERVER_TRUST_ACCOUNT)

#define USER_ACCOUNT_TYPE_MASK         \
            ( USER_TEMP_DUPLICATE_ACCOUNT |\
              USER_NORMAL_ACCOUNT |\
              USER_MACHINE_ACCOUNT_MASK )


//
// Logon times may be expressed in day, hour, or minute granularity.
//
//              Days per week    = 7
//              Hours per week   = 168
//              Minutes per week = 10080
//

#define SAM_DAYS_PER_WEEK    (7)
#define SAM_HOURS_PER_WEEK   (24 * SAM_DAYS_PER_WEEK)
#define SAM_MINUTES_PER_WEEK (60 * SAM_HOURS_PER_WEEK)

#define _NTSAM_USER_ACCOUNT_FLAG_
#endif
#ifndef _NTSAM_USER_ALL_INFO_
#include "pshpack4.h"
typedef struct _USER_ALL_INFORMATION {
    LARGE_INTEGER LastLogon;
    LARGE_INTEGER LastLogoff;
    LARGE_INTEGER PasswordLastSet;
    LARGE_INTEGER AccountExpires;
    LARGE_INTEGER PasswordCanChange;
    LARGE_INTEGER PasswordMustChange;
    UNICODE_STRING UserName;
    UNICODE_STRING FullName;
    UNICODE_STRING HomeDirectory;
    UNICODE_STRING HomeDirectoryDrive;
    UNICODE_STRING ScriptPath;
    UNICODE_STRING ProfilePath;
    UNICODE_STRING AdminComment;
    UNICODE_STRING WorkStations;
    UNICODE_STRING UserComment;
    UNICODE_STRING Parameters;
    UNICODE_STRING LmPassword;
    UNICODE_STRING NtPassword;
    UNICODE_STRING PrivateData;
    SR_SECURITY_DESCRIPTOR SecurityDescriptor;
    ULONG UserId;
    ULONG PrimaryGroupId;
    ULONG UserAccountControl;
    ULONG WhichFields;
    LOGON_HOURS LogonHours;
    USHORT BadPasswordCount;
    USHORT LogonCount;
    USHORT CountryCode;
    USHORT CodePage;
    BOOLEAN LmPasswordPresent;
    BOOLEAN NtPasswordPresent;
    BOOLEAN PasswordExpired;
    BOOLEAN PrivateDataSensitive;
} USER_ALL_INFORMATION,  *PUSER_ALL_INFORMATION;
#include "poppack.h"
#define _NTSAM_USER_ALL_INFO_
#endif
#ifndef _NTSAM_SAM_USER_PARMS_
#define USER_ALL_PARAMETERS         0x00200000
#define _NTSAM_SAM_USER_PARMS_
#endif

#define CLEAR_BLOCK_LENGTH          8

typedef CYPHER_BLOCK *              PCYPHER_BLOCK;
typedef LM_OWF_PASSWORD *           PLM_OWF_PASSWORD;
typedef CLEAR_BLOCK                 LM_CHALLENGE;
typedef LM_CHALLENGE *              PLM_CHALLENGE;
typedef LM_OWF_PASSWORD             NT_OWF_PASSWORD;
typedef NT_OWF_PASSWORD *           PNT_OWF_PASSWORD;
typedef LM_CHALLENGE                NT_CHALLENGE;
typedef NT_CHALLENGE *              PNT_CHALLENGE;
#define USER_SESSION_KEY_LENGTH     (CYPHER_BLOCK_LENGTH * 2)

typedef USER_SESSION_KEY          * PUSER_SESSION_KEY;

typedef enum _NETLOGON_LOGON_INFO_CLASS {
    NetlogonInteractiveInformation = 1,
    NetlogonNetworkInformation,
    NetlogonServiceInformation,
    NetlogonGenericInformation,
    NetlogonInteractiveTransitiveInformation,
    NetlogonNetworkTransitiveInformation,
    NetlogonServiceTransitiveInformation
} NETLOGON_LOGON_INFO_CLASS;

typedef struct _NETLOGON_LOGON_IDENTITY_INFO {
    UNICODE_STRING LogonDomainName;
    ULONG ParameterControl;
    OLD_LARGE_INTEGER  LogonId;
    UNICODE_STRING UserName;
    UNICODE_STRING Workstation;
} NETLOGON_LOGON_IDENTITY_INFO,
 *PNETLOGON_LOGON_IDENTITY_INFO;

typedef struct _NETLOGON_INTERACTIVE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_INTERACTIVE_INFO,
 *PNETLOGON_INTERACTIVE_INFO;

typedef struct _NETLOGON_SERVICE_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_OWF_PASSWORD LmOwfPassword;
    NT_OWF_PASSWORD NtOwfPassword;
} NETLOGON_SERVICE_INFO, *PNETLOGON_SERVICE_INFO;

typedef struct _NETLOGON_NETWORK_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    LM_CHALLENGE LmChallenge;
    STRING NtChallengeResponse;
    STRING LmChallengeResponse;
} NETLOGON_NETWORK_INFO, *PNETLOGON_NETWORK_INFO;

typedef struct _NETLOGON_GENERIC_INFO {
    NETLOGON_LOGON_IDENTITY_INFO Identity;
    UNICODE_STRING PackageName;
    ULONG DataLength;
#ifdef MIDL_PASS
    [size_is(DataLength)]
#endif
    PUCHAR LogonData;
} NETLOGON_GENERIC_INFO, *PNETLOGON_GENERIC_INFO;


// Values for Flags
#define MSV1_0_PASSTHRU     0x01
#define MSV1_0_GUEST_LOGON  0x02

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutine(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

typedef struct _MSV1_0_VALIDATION_INFO {
    LARGE_INTEGER LogoffTime;
    LARGE_INTEGER KickoffTime;
    UNICODE_STRING LogonServer;
    UNICODE_STRING LogonDomainName;
    USER_SESSION_KEY SessionKey;
    BOOLEAN Authoritative;
    ULONG UserFlags;
    ULONG WhichFields;
    ULONG UserId;
} MSV1_0_VALIDATION_INFO, *PMSV1_0_VALIDATION_INFO;

// values for WhichFields

#define MSV1_0_VALIDATION_LOGOFF_TIME          0x00000001
#define MSV1_0_VALIDATION_KICKOFF_TIME         0x00000002
#define MSV1_0_VALIDATION_LOGON_SERVER         0x00000004
#define MSV1_0_VALIDATION_LOGON_DOMAIN         0x00000008
#define MSV1_0_VALIDATION_SESSION_KEY          0x00000010
#define MSV1_0_VALIDATION_USER_FLAGS           0x00000020
#define MSV1_0_VALIDATION_USER_ID              0x00000040

// legal values for ActionsPerformed
#define MSV1_0_SUBAUTH_ACCOUNT_DISABLED        0x00000001
#define MSV1_0_SUBAUTH_PASSWORD                0x00000002
#define MSV1_0_SUBAUTH_WORKSTATIONS            0x00000004
#define MSV1_0_SUBAUTH_LOGON_HOURS             0x00000008
#define MSV1_0_SUBAUTH_ACCOUNT_EXPIRY          0x00000010
#define MSV1_0_SUBAUTH_PASSWORD_EXPIRY         0x00000020
#define MSV1_0_SUBAUTH_ACCOUNT_TYPE            0x00000040
#define MSV1_0_SUBAUTH_LOCKOUT                 0x00000080

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineEx(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    IN SAM_HANDLE UserHandle,
    IN OUT PMSV1_0_VALIDATION_INFO ValidationInfo,
    OUT PULONG ActionsPerformed
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationRoutineGeneric(
    IN PVOID SubmitBuffer,
    IN ULONG SubmitBufferLength,
    OUT PULONG ReturnBufferLength,
    OUT PVOID *ReturnBuffer
);

NTSTATUS NTAPI
Msv1_0SubAuthenticationFilter(
    IN NETLOGON_LOGON_INFO_CLASS LogonLevel,
    IN PVOID LogonInformation,
    IN ULONG Flags,
    IN PUSER_ALL_INFORMATION UserAll,
    OUT PULONG WhichFields,
    OUT PULONG UserFlags,
    OUT PBOOLEAN Authoritative,
    OUT PLARGE_INTEGER LogoffTime,
    OUT PLARGE_INTEGER KickoffTime
);

#define STATUS_SUCCESS                          ((NTSTATUS)0x00000000L)
#define STATUS_INVALID_INFO_CLASS        ((NTSTATUS)0xC0000003L)
#define STATUS_NO_SUCH_USER              ((NTSTATUS)0xC0000064L)
#define STATUS_WRONG_PASSWORD            ((NTSTATUS)0xC000006AL)
#define STATUS_PASSWORD_RESTRICTION      ((NTSTATUS)0xC000006CL)
#define STATUS_LOGON_FAILURE             ((NTSTATUS)0xC000006DL)
#define STATUS_ACCOUNT_RESTRICTION       ((NTSTATUS)0xC000006EL)
#define STATUS_INVALID_LOGON_HOURS       ((NTSTATUS)0xC000006FL)
#define STATUS_INVALID_WORKSTATION       ((NTSTATUS)0xC0000070L)
#define STATUS_PASSWORD_EXPIRED          ((NTSTATUS)0xC0000071L)
#define STATUS_ACCOUNT_DISABLED          ((NTSTATUS)0xC0000072L)
#define STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)
#define STATUS_ACCOUNT_EXPIRED           ((NTSTATUS)0xC0000193L)
#define STATUS_PASSWORD_MUST_CHANGE      ((NTSTATUS)0xC0000224L)
#define STATUS_ACCOUNT_LOCKED_OUT        ((NTSTATUS)0xC0000234L)
#ifdef __cplusplus
}
#endif

#endif /* _NTSUBAUTH_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\atqendp.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      atqendp.cxx

   Abstract:
      This module implements ATQ endpoints

   Author:

       Johnson Apacible    (JohnsonA)     13-May-1996

   Environment:

       User Mode -- Win32

--*/

#include "isatq.hxx"

//
// Forward declarations
//

BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    );

BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    );


# define ATQ_MIN_ACCEPTEX_TIMEOUT    (120)  // 2 minutes = 120 seconds

#define ATQ_CLOSE_ENDPOINT_SLEEP_TIME (200) // 200ms = 1/5 second
#define ATQ_CLOSE_ENDPOINT_TIMEOUT    ((100*1000) / ATQ_CLOSE_ENDPOINT_SLEEP_TIME)
                                            // 100 seconds


PVOID
AtqCreateEndpoint(
    IN PATQ_ENDPOINT_CONFIGURATION Configuration,
    IN PVOID EndpointContext
    )

/*++

Routine Description:

    Creates a server instance.

Arguments:

    Context - Context value returned

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{

    DWORD timeout = Configuration->AcceptExTimeout;
    PATQ_ENDPOINT endpoint;
    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqCreateEndpoint entered\n"));
    }

    //
    // Allocate list
    //

    endpoint = (PATQ_ENDPOINT)LocalAlloc(0,sizeof(ATQ_ENDPOINT));
    if ( endpoint == NULL ) {
        ATQ_PRINTF(( DBG_CONTEXT,"Unable to allocate ATQ Endpoint\n"));
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error;
    }

    //
    // Initialize
    //

    ZeroMemory(endpoint,sizeof(ATQ_ENDPOINT));
    endpoint->Signature = ATQ_ENDPOINT_SIGNATURE;
    endpoint->m_refCount = 1;
    SET_BLOCK_STATE(endpoint, AtqStateActive);

    endpoint->EnableBw = FALSE;
    endpoint->ConnectCompletion = Configuration->pfnConnect;
    endpoint->ConnectExCompletion = Configuration->pfnConnectEx;
    endpoint->UseAcceptEx = (g_fUseAcceptEx) && (endpoint->ConnectExCompletion);
    endpoint->IoCompletion = Configuration->pfnIoCompletion;
    endpoint->ListenSocket = INVALID_SOCKET;
    endpoint->pListenAtqContext = NULL;
    endpoint->nAvailDuringTimeOut = 0;
    endpoint->nSocketsAvail = 0;
    endpoint->Context = EndpointContext;
    endpoint->pBacklogMon = NULL;

    endpoint->InitialRecvSize = Configuration->cbAcceptExRecvBuffer;

    // we need to maintain at least 5 outstanding accept ex sockets
    // for our auto-tune algo to work.
    endpoint->nAcceptExOutstanding =
        ( (Configuration->nAcceptExOutstanding > 4) ?
          Configuration->nAcceptExOutstanding : 5);


    //
    // fAddingSockets prevents two threads from adding AcceptEx sockets
    // at the same time. Since the endpoint isn't ready to have sockets
    // added we'll set this to TRUE until the endpoint is fully initialized
    // in ActivateEndpoint.
    //
    endpoint->fAddingSockets = TRUE;

    //
    // Check and set the timeout to be atleast minimum timeout for AcceptEx
    //
    if ( timeout <= ATQ_MIN_ACCEPTEX_TIMEOUT)  {
        timeout = ATQ_MIN_ACCEPTEX_TIMEOUT;
    }

    endpoint->AcceptExTimeout = CanonTimeout( timeout);

    endpoint->Port = Configuration->ListenPort;
    endpoint->IpAddress = Configuration->IpAddress;

    //endpoint->ContextList.Initialize( );

#if DBG
    endpoint->RefTraceLog = CreateRefTraceLog( TRACE_LOG_SIZE, 0 );
#endif

#if 0
    ATQ_PRINTF(( DBG_CONTEXT,"port %d nAX %d nAT %d nLB %d\n",
        endpoint->Port, endpoint->nAcceptExOutstanding,
        endpoint->AcceptExTimeout, g_cListenBacklog));
#endif

    //
    // Create the socket
    //

    if (!I_CreateListenSocket(endpoint) ) {

        goto error;
    }

    return((PVOID)endpoint);

error:

    if ( endpoint != NULL ) {
#if DBG
        if( endpoint->RefTraceLog != NULL ) {
            DestroyRefTraceLog( endpoint->RefTraceLog );
        }
#endif
        LocalFree( endpoint );
    }

    return(NULL);

} // AtqCreateEndpoint



BOOL
AtqStartEndpoint(
    IN PVOID Endpoint
    )
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL          fReturn;
    DWORD         dwError = NO_ERROR;

    ATQ_ASSERT(IS_BLOCK_ACTIVE(pEndpoint));

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"AtqStartEndpoint called. UseAcceptEx[%d]\n",
            pEndpoint->UseAcceptEx));
    }

    //
    // if AcceptEx is supported, create AcceptEx contexts
    //

    if ( pEndpoint->UseAcceptEx ) {

        //
        // Add AcceptEx sockets
        //

        fReturn = pEndpoint->ActivateEndpoint();

        if ( !fReturn ) {
            dwError = GetLastError();
            
            DBGERROR(( DBG_CONTEXT,"Error %d in %08x::ActivateEndpoint()\n",
                GetLastError(), pEndpoint));
        }

    } else {

        //
        // We need to start a listen thread
        //

        fReturn = StartListenThread( pEndpoint );

        if ( !fReturn ) {
            dwError = GetLastError();
            
            DBGERROR(( DBG_CONTEXT,"Error %d in %08x::StartListenThread()\n",
                GetLastError(), pEndpoint));
        }
    }

    if (!fReturn) {
        AtqStopEndpoint(pEndpoint);
    }

    SetLastError(dwError);

    return (fReturn);

} // AtqStartEndpoint



ULONG_PTR
AtqEndpointGetInfo(
    IN PVOID Endpoint,
    IN ATQ_ENDPOINT_INFO EndpointInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ endpoint

Arguments:

    Endpoint    - endpoint to get data from
    EndpointInfo - type of info to get

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD_PTR     dwVal = 0;

    switch ( EndpointInfo ) {

      case EndpointInfoListenPort:
        dwVal = pEndpoint->Port;
        break;

      case EndpointInfoListenSocket:
        dwVal = pEndpoint->ListenSocket;
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return dwVal;
} // AtqEndpointGetInfo()



ULONG_PTR
AtqEndpointSetInfo(
    IN PVOID                Endpoint,
    IN ATQ_ENDPOINT_INFO    EndpointInfo,
    IN ULONG_PTR             Info
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    Endpoint     - endpoint to set info on
    EndpointInfo - type of info to set
    Info         - info to set

Return Value:

    The old value of the parameter

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    ULONG_PTR  Val = 0;

    switch ( EndpointInfo ) {

        case EndpointInfoAcceptExOutstanding:

        Val = (ULONG_PTR)pEndpoint->nAcceptExOutstanding;

        if ( Val < Info ) {

            //
            // Make up for increased limit
            //

            if ( (DWORD ) pEndpoint->nSocketsAvail < (DWORD)(Info >> 2) ) {
                (VOID ) I_AtqPrepareAcceptExSockets(
                                        pEndpoint,
                                        (DWORD)(Info>>2) - pEndpoint->nSocketsAvail
                                        );
            }
            pEndpoint->nAcceptExOutstanding = (DWORD)Info;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
    }

    return Val;
} // AtqEndpointSetInfo()




BOOL
AtqStopEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Stops the endpoint - marks the Endpoint as to be shutdown and closes
    the listening socket -> forcing new connections to stop for this endpoint

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopEndpoint( %08x)\n", pEndpoint));
    }

    //
    //  Find the listen socket info
    //

    AcquireLock( &AtqEndpointLock );

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Stop Endpoint (%08x) more than once",
                     pEndpoint
                     ));
        ReleaseLock( &AtqEndpointLock );
        return(FALSE);
    }

    //
    //  Mark the listen info as no longer accepting connections
    //

    SET_BLOCK_STATE(pEndpoint, AtqStateClosed);

    //
    //  Remove the entry from the end points list
    //

    RemoveEntryList(&pEndpoint->ListEntry);
    ReleaseLock( &AtqEndpointLock );

    //
    // Remove us from the Backlog Monitor
    //
    DBG_ASSERT( g_pAtqBacklogMonitor );

    if (pEndpoint->pBacklogMon) {
        DBG_REQUIRE( g_pAtqBacklogMonitor->RemoveEntry(pEndpoint->pBacklogMon) );
        delete pEndpoint->pBacklogMon;
        pEndpoint->pBacklogMon = NULL;
    }

    //
    // Close the listen socket which forces the cleanup for all the
    //  pending LISTEN ATQ contexts. We do this early on so that
    //  we can prevent any new entrant connections into the processing code.
    //

    I_CloseListenSocket( pEndpoint );

    //
    // Forcibly close all the pending LISTEN contexts tied to this endpoint
    //

    nClosed = pEndpoint->CloseAtqContexts( TRUE);

    DBGPRINTF(( DBG_CONTEXT,
                "ATQ_ENDPOINT(%08x)::Closed %d pending Listen sockets\n",
                pEndpoint, nClosed));

    //
    // if this is a non-acceptex socket, wait for the listen thread to die
    //

    if ( !pEndpoint->UseAcceptEx ) {
        WaitForSingleObject(pEndpoint->hListenThread, 10*1000);
    }

    return ( TRUE);

} // AtqStopEndpoint()


BOOL
AtqCloseEndpoint(
    IN PVOID     Endpoint
    )
/*++

Routine Description:

    Closes the endpoint - it forcefully fress up all references to the
    endpoint (held by ATQ Contexts) by shutting down the ATQ contexts.
    In the course of this operation if some context does not go away, this
    code will end up looping forever!

    Note: Should be called *after* AtqStopEndpoint()

Arguments:

    Endpoint - endpoint to be stopped

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    DWORD  nClosed;
    DWORD i;

    ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqCloseEndpoint( %08x)\n", pEndpoint));
    }

    if ( pEndpoint->State != AtqStateClosed) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Attempt to Close Endpoint (%08x) when it is "
                     " not stopped yet!\n'",
                     pEndpoint
                     ));

        DBG_ASSERT(pEndpoint->State == AtqStateClosed);
        
        return(FALSE);
    }

    //
    // wait for all the contexts for this endpoint to go away
    // or for about two minutes
    //

    i = 0;
    while (( pEndpoint->m_refCount > 1) && (i < ATQ_CLOSE_ENDPOINT_TIMEOUT)) {

        ATQ_PRINTF(( DBG_CONTEXT, " Endpoint(%08x) has %d refs\n",
                     pEndpoint, pEndpoint->m_refCount));

        //
        // Forcibly close all the contexts tied to this endpoint again!
        // Sometimes for some random reasons ATQ contexts get left out
        //  during the first clean we did above. In such case it is important
        //  to retry again
        // THIS IS UGLY. But if we did not do this then the Endpoint
        //  structure might get freed => ATQ contexts will be hanging on to
        //  dead ATQ endpoint
        //

        nClosed = pEndpoint->CloseAtqContexts();

        DBGPRINTF(( DBG_CONTEXT, " ATQ_ENDPOINT(%08x)::Closed %d sockets\n",
                    pEndpoint, nClosed));

        //
        // NYI: I need to auto-tune this sleep function
        //
        Sleep( ATQ_CLOSE_ENDPOINT_SLEEP_TIME); // sleep and check again.

#if DBG
        //
        // loop forever for checked builds
        //
#else
        //
        // loop until timeout for retail
        //
        i++;
#endif

        // wake up and check again.
    } // while (busy wait)

    //
    //  Undo the reference for being on the listen info list.
    //    decr final ref count => the endpoint will be cleaned up & freed
    //
    //  If we timed out just leak the endpoints!
    //

    if ( pEndpoint->m_refCount == 1 ) {
        pEndpoint->Dereference();

        return TRUE;
    } else {
        return FALSE;
    }

} // AtqCloseEndpoint()



BOOL
AtqStopAndCloseEndpoint(
    IN PVOID                    Endpoint,
    IN LPTHREAD_START_ROUTINE   lpCompletion,
    IN PVOID                    lpCompletionContext
    )
/*++

Routine Description:

    Stops the endpoint and closes it after forcing close of
    associated ATQ contexts.

Arguments:

    Endpoint - endpoint to shutdown.
    lpCompletion - routine to be called when endpoint is completely shutdown.
    lpCompletionContext - Context to be returned with the routine

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    PATQ_ENDPOINT pEndpoint = (PATQ_ENDPOINT)Endpoint;
    BOOL fReturn;

    //
    // Warn all the callers of this to be deprecated API and pray that
    // they will all switch over
    //
#ifndef _NO_TRACING_
    DBGPRINTF( (DBG_CONTEXT, "\n-----------------------------------------------\n"));
    DBGPRINTF( (DBG_CONTEXT, " AtqStopAndCloseEndpoint() should NOT be called\n"));
    DBGPRINTF( (DBG_CONTEXT, "         Call 1) AtqStopEndpoint()  and \n"));
    DBGPRINTF( (DBG_CONTEXT, "              2) AtqCloseEndpoint() instead\n"));
    DBGPRINTF( (DBG_CONTEXT, "   For Now, this call will simulate 1 & 2\n"));
    DBGPRINTF( (DBG_CONTEXT, "-----------------------------------------------\n"));
#else
    OutputDebugStringA( "\n-----------------------------------------------\n");
    OutputDebugStringA( " AtqStopAndCloseEndpoint() should NOT be called\n");
    OutputDebugStringA( "         Call 1) AtqStopEndpoint()  and \n");
    OutputDebugStringA( "              2) AtqCloseEndpoint() instead\n");
    OutputDebugStringA( "   For Now, this call will simulate 1 & 2\n");
    OutputDebugStringA( "-----------------------------------------------\n");
#endif


    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqStopAndCloseEndpoint( %08x)\n", pEndpoint));
    }

    fReturn = AtqStopEndpoint( Endpoint);

    if ( fReturn) {

        //
        // Call any custom shutdown function
        // NYI: Too Bad the Endpoint object is not a base class object
        //

        if ( lpCompletion != NULL ) {
            pEndpoint->ShutdownCallback = lpCompletion;
            pEndpoint->ShutdownCallbackContext = lpCompletionContext;
        }

        //
        // Now that the Endpoint is stopped and callback functions are called,
        //  Let us call the AtqCloseEndpoint() to cleanup the endpoint itself.
        //
        fReturn = AtqCloseEndpoint( Endpoint);
    }

    return (fReturn);

} // AtqStopAndCloseEndpoint()



BOOL
ATQ_ENDPOINT::ActivateEndpoint( VOID)
/*++

Routine Description:


    This function creates the initial listening socket & ATQ context for given
    endpoint. It also adds initial set of AcceptEx Sockets to the ATQ listening
    pool (if we are using the AcceptEx())

Arguments:
    None

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    PATQ_CONT   patqContext = NULL;
    BOOL        fReturn;
    DWORD       cInitial = this->nAcceptExOutstanding;

    //
    //  Add the listen socket
    //
    DBG_ASSERT( this->pListenAtqContext == NULL);

    fReturn =
        I_AtqAddListenEndpointToPort(
                                     (PATQ_CONT*)&this->pListenAtqContext,
                                     this
                                     );

    if ( !fReturn) {

        if ( this->pListenAtqContext ) {
            AtqFreeContext( this->pListenAtqContext, FALSE);
            this->pListenAtqContext = NULL;
        }

        return FALSE;
    }

    cInitial = max(cInitial, 1);

    if ( !TsIsNtServer( ) ) {

        //
        // Limit what a workstation can specify
        //

        cInitial = min(cInitial, ATQ_MIN_CTX_INC);
        this->nAcceptExOutstanding = cInitial;

    }

    //
    // start with 1/4 of the intended
    //

    cInitial = max( cInitial >> 2, 1);

    //
    // Now we're finally ready to add AcceptEx sockets, so we'll
    // reset the flag that was preventing it.
    //
    fAddingSockets = FALSE;

    //
    //  Now add the acceptex sockets for this ListenInfo object
    //

    fReturn = I_AtqPrepareAcceptExSockets(this, cInitial);

    if (fReturn && !g_fDisableBacklogMonitor ) { 
        //
        // Set up the Backlog monitor
        //
        DBG_ASSERT( pBacklogMon == NULL );
        DBG_ASSERT( g_pAtqBacklogMonitor );
        
        pBacklogMon = new ATQ_ENDPOINT_BMON(ListenSocket, this);

        if (pBacklogMon) {

            fReturn = (pBacklogMon->InitEvent()
                        && g_pAtqBacklogMonitor->AddEntry(pBacklogMon));

            if (!fReturn) {
                delete pBacklogMon;
                pBacklogMon = NULL;
            }
        } else {
            fReturn = FALSE;
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    return(fReturn);

} // ATQ_ENDPOINT::ActivateEndpoint()



DWORD
ATQ_ENDPOINT::CloseAtqContexts( IN BOOL fPendingOnly)
/*++
  Description:
    This function searches for all ATQ contexts associated
     with the given endpoint and forcibly closes them all.

  Arguments:
    fPendingOnly - close only the pending sockets

  Returns:
    DWORD containing the number of ATQ contexts closed.
--*/
{
    DWORD  nClosed = 0;
    DWORD  i;
    PLIST_ENTRY   pEntry;
    PATQ_CONT     pContext;

    //
    //  Force a close on all the connected sockets so that all the holders
    //   and use of such contexts will bail out of this endpoint entirely.
    // NYI: We need a way to tag on all these lists on per-endpoint basis
    //

    for ( i = 0; i < g_dwNumContextLists; i++) {

        PLIST_ENTRY pListHead;

        AtqActiveContextList[i].Lock();

        //
        // Hard close sockets in the pending list
        //

        pListHead = &AtqActiveContextList[i].PendingAcceptExListHead;
        for ( pEntry = pListHead->Flink;
             pEntry != pListHead;
             pEntry  = pEntry->Flink ) {

            pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

            ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

            if ( (pContext->pEndpoint == this) &&
                 (pContext->IsState( ACS_SOCK_CONNECTED) ||
                  pContext->IsState( ACS_SOCK_LISTENING)
                  ) &&
                 (pContext->hAsyncIO  != NULL) ) {

                nClosed++;
                pContext->HardCloseSocket();
            }
        } // for items in pending list

        if ( !fPendingOnly) {
            //
            // Hard close sockets in the active list
            // Active list includes sockets in ACS_SOCK_CLOSED state
            //  that ought to be freed up, because we could have reached
            //  this through the optimizations for TransmitFile()
            //

            pListHead = &AtqActiveContextList[i].ActiveListHead;
            for ( pEntry = pListHead->Flink;
                  pEntry != pListHead;
                  pEntry  = pEntry->Flink ) {

                pContext = CONTAINING_RECORD( pEntry, ATQ_CONTEXT,
                                              m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

                if ( (pContext->pEndpoint == this)  &&
                     (pContext->IsState( ACS_SOCK_CONNECTED) ||
                      pContext->IsState( ACS_SOCK_LISTENING) ||
                      pContext->IsState( ACS_SOCK_CLOSED) ||
                      pContext->IsState( ACS_SOCK_UNCONNECTED)
                      ) &&
                     (pContext->hAsyncIO  != NULL) ) {

                    nClosed++;
                    pContext->HardCloseSocket();
                }
            } // for items in active list
        } // if (! fPendingOnly)

        AtqActiveContextList[i].Unlock();

    } // for

    return ( nClosed);

} // ATQ_ENDPOINT::CloseAtqContexts()


/************************************************************
 * Internal Functions
 ************************************************************/


BOOL
I_CreateListenSocket(
    IN PATQ_ENDPOINT pEndpoint
    )
/*++

    Creates a socket for listening to connections on given address.

    Arguments:

       lpSockAddress    pointer to local socket address structure used to bind
                           the given connection.
       lenSockAddress   length of the socket address structure.
       socketType       integer containing the type of the socket ( stream )
       socketProtocol   protocol to be used for the socket.
       nBackLog         Maximum length to which a queue of pending connections
                           may grow.

    Returns:
       NO_ERROR on success; otherwise returns Sockets error code.

--*/
{
    INT serr;
    SOCKET  sNew;
    BOOL  fReuseAddr = FALSE;
    SOCKADDR_IN inAddr;
    PSOCKADDR addr;
    INT addrLength;
    PLIST_ENTRY listEntry;
    PATQ_ENDPOINT scanEndpoint;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CreateListenEndpoint called. \n"));
    }

    //
    // Since we'll be altering our behaviour based on the contents of
    // the endpoint list, we must acquire the endpoint list lock and
    // hold this lock throughout this routine.
    //

    AcquireLock( &AtqEndpointLock);

    //
    // If this is the first endpoint to be bound to this port, then
    // disable SO_REUSEADDR. Otherwise (there are other endpoints already
    // using this port), then enable SO_REUSEADDR.
    //
    // "Why are we doing this" you ask? Since we're binding our listening
    // sockets to specific IP addresses, we must enable SO_REUSEADDR
    // (otherwise, we'd get WSAEADDRINUSE errors). However, in an effort
    // to detect a port conflicts with other (non-IIS) software, we'll
    // disable SO_REUSEADDR the *first* time a particular port is used.
    //

    for( listEntry  = AtqEndpointList.Flink;
         listEntry != &AtqEndpointList;
         listEntry  = listEntry->Flink ) {

        scanEndpoint = CONTAINING_RECORD(
                           listEntry,
                           ATQ_ENDPOINT,
                           ListEntry
                           );

        ATQ_ASSERT( scanEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        if( scanEndpoint->Port == pEndpoint->Port ) {
            fReuseAddr = TRUE;
            break;
        }

    }

    //
    // Create a new socket
    //

#if WINSOCK11
    sNew =  socket(
                AF_INET,
                SOCK_STREAM,
                IPPROTO_TCP
                );
#else
    sNew = WSASocket(
                  AF_INET,
                  SOCK_STREAM,
                  IPPROTO_TCP,
                  NULL,  // protocol info
                  0,     // Group ID = 0 => no constraints
                  WSA_FLAG_OVERLAPPED    // completion port notifications
                  );
# endif // WINSOCK11

    if ( sNew == INVALID_SOCKET ) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,
                    "Error %d in socket( %d, %d, %d)\n",
                    serr,
                    AF_INET,
                    SOCK_STREAM,
                    IPPROTO_TCP
                    ));

        goto cleanup;
    }

    //
    // Set SO_REUSEADDR based on results of the endpoint scan above.
    //

    if ( setsockopt( sNew, SOL_SOCKET, SO_REUSEADDR,
                    (const CHAR *) &fReuseAddr,
                    sizeof( fReuseAddr)) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    " setsockopt( %d, REUSE_ADDR, FALSE) failed."
                    " Error = %d\n",
                    sNew, serr));

        goto cleanup;
    }

    //
    // See which address family we're dealing with
    //

    addr = (PSOCKADDR)&inAddr;
    addrLength = sizeof(inAddr);
    ZeroMemory(addr, addrLength);

    inAddr.sin_family = AF_INET;
    inAddr.sin_port = htons(pEndpoint->Port);
    inAddr.sin_addr.s_addr = pEndpoint->IpAddress;

    //
    // Bind an address to socket
    //

    if ( bind( sNew, addr, addrLength) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    "bind ( socket = %d, Address = %08x, len = %d) "
                    " returns error = %u\n",
                    sNew, addr, addrLength, serr));

        goto cleanup;
    }

    //
    // Put the socket in listen mode
    //

    if ( listen( sNew, g_cListenBacklog) != 0) {

        serr = WSAGetLastError();

        ATQ_PRINTF(( DBG_CONTEXT,
                    " listen( %d, %d) returned %d.\n",
                    sNew, g_cListenBacklog, serr));
        goto cleanup;
    }

    pEndpoint->ListenSocket = sNew;

    //
    // Link to server listen list
    //

    InsertTailList(
                &AtqEndpointList,
                &pEndpoint->ListEntry
                );

    ReleaseLock( &AtqEndpointLock);
    return(TRUE);

cleanup:

    if ( sNew != INVALID_SOCKET) {
        closesocket( sNew);
    }

    ReleaseLock( &AtqEndpointLock);
    SetLastError(serr);
    return(FALSE);

} // I_CreateListenSocket




BOOL
I_CloseListenSocket(
    IN PATQ_ENDPOINT Endpoint
    )
/*++

  Closes the socket on which a listen was possibly established.

  Returns:
    TRUE, if successful,
    FALSE, otherwise

--*/
{
    INT  serr = NO_ERROR;
    LINGER linger;
    SOCKET s;

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF((DBG_CONTEXT,"I_CloseListenSocket called.\n"));
    }

    s = (SOCKET)InterlockedExchangePointer(
                    (PVOID *)&Endpoint->ListenSocket,
                    (PVOID)INVALID_SOCKET
                    );

    if ( s == INVALID_SOCKET) {
        return(TRUE);
    }

    //
    //  Enable linger with timeout of ZERO for "hard" close
    //
    //  Error code from sock option is ignored, since we are
    //   anyway closing the socket
    //

    linger.l_onoff = TRUE;
    linger.l_linger = 0;
    setsockopt( s, SOL_SOCKET, SO_LINGER, (PCHAR)&linger,sizeof(linger));

    //
    // Close the socket
    //

    if (closesocket(s) != 0) {
        serr = WSAGetLastError();
        ATQ_PRINTF(( DBG_CONTEXT,"error %d in closesocket\n",serr));
    } else {

        // Remove the socket from the ListenAtq Context as well
        //  since the socket is now closed here in this function.
        PATQ_CONTEXT patqc = Endpoint->pListenAtqContext;
        if ( patqc != NULL) {
            patqc->hAsyncIO = NULL;
        }
    }

    return (TRUE);
} // I_CloseListenSocket()




DWORD
ListenThreadFunc(
        LPVOID Context
        )
/*++

    Main loop waiting for connections. ( The core of server)
    The thread loops around waiting on an accept() call on
     listenSocket.
    If there is a new message on socket, it invokes the
     callback function for connection.

    NEVER returns untill it is requested to stop by someother
      thread using a call to TS_CONNECTION_INFO::StopConnectionThread().

    Returns:

      0 on success and error code if there is a fatal error.


--*/
{

    INT serr;
    register SOCKET  sNewConnection;
    SOCKADDR_IN sockAddrRemote;
    PATQ_ENDPOINT endpoint = (PATQ_ENDPOINT)Context;

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThreadFunc() running.\n"));
    }

    //
    //  Loop Forever
    //

    for( ; ;) {

        int cbAddr = sizeof( sockAddrRemote);

        //
        //  Wait for a connection
        //

        IF_DEBUG(ENDPOINT) {
            ATQ_PRINTF((DBG_CONTEXT,"Listening for new connection\n"));
        }

        if ((sNewConnection = WSAAccept(
                                    endpoint->ListenSocket,
                                    (LPSOCKADDR ) &sockAddrRemote,
                                    &cbAddr,
                                    NULL,
                                    0)) != INVALID_SOCKET) {

            //
            // Valid Connection has been established.
            // Invoke the callback function to process this connection
            //   and then continue the loop
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Got new connection. sock[%d]\n",
                    sNewConnection));
            }

            (*endpoint->ConnectCompletion)(
                                sNewConnection,
                                &sockAddrRemote,
                                endpoint->Context,
                                (PVOID)endpoint
                                );

        } else {

            //
            // Some low level error has occured.
            //

            serr = WSAGetLastError();
            ATQ_PRINTF((DBG_CONTEXT,"Error %d in accept\n", serr));

            if ( serr == WSAEINTR) {

                //
                // Socket was closed by low-level call. Get out.
                //

                break;
            }

            //
            // Check if we are shutting down and if so QUIT
            //

            if (!IS_BLOCK_ACTIVE(endpoint)) {
                IF_DEBUG(ENDPOINT) {
                    ATQ_PRINTF((DBG_CONTEXT,"ListenThread shutting down\n"));
                }
                break;
            }

            //
            // Perform a graceful recovery from failure. NYI
            //  ( Tricky code). Both FTP and Web server are to test it!
            //    Will add this code later. ( MuraliK)
            //

            IF_DEBUG(ENDPOINT) {
                ATQ_PRINTF((DBG_CONTEXT,"Unexpected error %d on accept\n",
                    serr));
            }
        }
    }

    //
    // Cleanup & Exit. Cleanup is done by the code which called the shut down.
    //

    IF_DEBUG(ENDPOINT) {
        ATQ_PRINTF((DBG_CONTEXT,"ListenThread exiting.\n"));
    }
    return ( 0);  // No errors

} // ListenThreadFunc()



BOOL
StartListenThread(
    IN PATQ_ENDPOINT Endpoint
    )
{
    DWORD  id;

    Endpoint->hListenThread = CreateThread(
                                        NULL,
                                        0,
                                        ListenThreadFunc,
                                        (PVOID )Endpoint,
                                        0,
                                        &id
                                        );

    if ( Endpoint->hListenThread != NULL) {
        return(TRUE);
    }

    return(FALSE);

} // StartListenThread



VOID
ATQ_ENDPOINT::CleanupEndpoint(
    VOID
    )
/*++

  Description:
     This function cleansup the internal state of the object and prepares
     it for the deletion.
     All endpoints should pass through this function when the ref count
     this zero.

--*/
{
    DBG_ASSERT( this->m_refCount == 0);
    ATQ_ASSERT( !IS_BLOCK_ACTIVE( this) );
    ASSERT( this->Signature == ATQ_ENDPOINT_SIGNATURE );

    // the following free will throw away the listen atq context
    if ( this->pListenAtqContext != NULL) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "Endpoint(%08x) frees listen context %08x\n",
                     this, this->pListenAtqContext));
        AtqFreeContext( this->pListenAtqContext, FALSE);
        this->pListenAtqContext = NULL;
    }

    if ( this->ShutdownCallback != NULL ) {
        //
        // This only happens when someone calls AtqStopAndCloseEndpoint which should
        // never happen in K2.
        //
        ASSERT( FALSE );
        this->ShutdownCallback( this->ShutdownCallbackContext);
    }
    
    this->Signature = ATQ_ENDPOINT_SIGNATURE_FREE;

#if DBG
    if( this->RefTraceLog != NULL ) {
        DestroyRefTraceLog( this->RefTraceLog );
    }
#endif

    return;

} // ATQ_ENDPOINT::CleanupEndpoint()


VOID
ATQ_ENDPOINT_BMON::ForceCompletion(
    IN PVOID                pvContext
)
/*++

Routine Description:

    Scheduled timeout of all unconnected sockets
    
Arguments:

    pvContext - Context (ATQ_ENDPOINT_BMON *)

Return Values:

    None
    
--*/
{
    ATQ_ENDPOINT_BMON*          pEndpointBMon;
    PATQ_CONTEXT_LISTHEAD       pACL;
    DWORD                       cForcedTotal = 0;
    DWORD                       cForced = 0;
    
    if ( !pvContext )
    {
        DBG_ASSERT( FALSE );
        return;
    }
    
    pEndpointBMon = (ATQ_ENDPOINT_BMON*) pvContext;
    
    for ( pACL = AtqActiveContextList;
          pACL < (AtqActiveContextList + g_dwNumContextLists);
          pACL++ )
    {
        I_AtqProcessPendingListens( pACL, 
                                    pEndpointBMon->m_pEndpoint, 
                                    &cForced );

        cForcedTotal += cForced;
    }
   
    //
    // Add back any sockets we forced
    //
    
    if ( cForcedTotal )
    {
        I_AtqPrepareAcceptExSockets( pEndpointBMon->m_pEndpoint,
                                     cForcedTotal );
    }

    //
    // Update stats
    //
   
    pEndpointBMon->m_nSocketsReset += cForcedTotal;

    pEndpointBMon->m_dwForceCookie = 0;
}

BOOL
ATQ_ENDPOINT_BMON::Callback(
    VOID
    )
/*++

Routine Description:

    The ATQ_BACKLOG_MONITOR calls this function
    when our listen socket runs out of AccepEx
    sockets.
    
Arguments:

    None

Return Values:

    Return TRUE if successful, else FALSE
--*/
{
    PLIST_ENTRY         pListEntry;

    // How many times were we called?

    m_nActivations++;

    //
    // Inform the set thread to sleep after all notifications
    //
    
    GetContainingBmonSet()->DoSleep( TRUE );    

    //
    // Are there available threads?  If not, then this condition won't be
    // helped by creating more sockets.  Do nothing.
    //
    
    if ( g_cAvailableThreads )
    {
        DBG_ASSERT( m_pEndpoint );
        
        if ( !g_cForceTimeout )
        {
            //
            // No wait period before force.  Just do it.
            //
                
            ForceCompletion( this );
        }
        else if ( !m_dwForceCookie )
        {
            //
            // OK.  Let's do something.  Traverse the list of unconnected
            // sockets and set an <x> second timeout on each
            //
                
            m_dwForceCookie = ScheduleWorkItem( 
                                    ATQ_ENDPOINT_BMON::ForceCompletion,
                                    this,
                                    TimeToWait( g_cForceTimeout ),
                                    FALSE );
        }
    }
    
    return TRUE;
}

ATQ_ENDPOINT_BMON::~ATQ_ENDPOINT_BMON(
    VOID
)
/*++

Routine Description:

    ATQ_ENDPOINT_BMON destructor.  Kill the scheduled work item if there
    
Arguments:

    None

Return Values:

    None

--*/
{
    if ( m_dwForceCookie )
    {
        RemoveWorkItem( m_dwForceCookie );
        m_dwForceCookie = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\abw.cxx ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

      abw2.cxx

   Abstract:
      This module implements functions required for bandwidth throttling
       of network usage by ATQ module.

   Author:

       Murali R. Krishnan    ( MuraliK )     1-June-1995
       Bilal Alam            ( t-bilala )    7-March-1997

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Asynchronous Thread Queue DLL

--*/

#include "isatq.hxx"

//
// Global variables
//

extern PBANDWIDTH_INFO       g_pBandwidthInfo;

//
// Bandwidth Info shared variables
//

CRITICAL_SECTION        BANDWIDTH_INFO::sm_csSharedLock;
LIST_ENTRY              BANDWIDTH_INFO::sm_BornListHead;
LIST_ENTRY              BANDWIDTH_INFO::sm_ActiveListHead;
DWORD                   BANDWIDTH_INFO::sm_cBornList;
DWORD                   BANDWIDTH_INFO::sm_cActiveList;
ALLOC_CACHE_HANDLER*    BANDWIDTH_INFO::sm_pachBWInfos;
BOOL                    BANDWIDTH_INFO::sm_fGlobalEnabled;
BOOL                    BANDWIDTH_INFO::sm_fGlobalActive;
DWORD                   BANDWIDTH_INFO::sm_cNonInfinite;
DWORD                   BANDWIDTH_INFO::sm_cSamplesForTimeout;

//
// BANDWIDTH_INFO methods
//

VOID
BANDWIDTH_INFO::Initialize(
    IN BOOL             fPersistent
)
/*++
  Initialize bandwidth info object.  This is a pseudo-constructor for the
  class.

  Arguments:
    fPersistent - TRUE if this object is destroyed explicitly
                  FALSE if destroyed when refcount hits 0

  Returns:
    None

--*/
{
    _fMemberOfActiveList        = FALSE;
    _bandwidth.dwSpecifiedLevel = INFINITE;
    _bandwidth.dwLowThreshold   = INFINITE;
    _bandwidth.dwHighThreshold  = INFINITE;
    _cMaxBlockedList            = INFINITE;
    _fEnabled                   = FALSE;
    _Signature                  = ATQ_BW_INFO_SIGNATURE;
    _fIsFreed                   = FALSE;
    _fPersistent                = fPersistent;
    _cReference                 = 1;

    INITIALIZE_CRITICAL_SECTION( &_csPrivateLock );
    InitializeListHead( &_BlockedListHead );

    ZeroMemory( _rgBytesXfered, sizeof( _rgBytesXfered ) );

    _pBytesXferCur = _rgBytesXfered;  // points to start of array
    _cbXfered.QuadPart = 0;

    _pStatus = &sm_rgStatus[ ZoneLevelLow ][ 0 ];

    ClearStatistics();

    AddToBornList();

    SetDescription( "Default" );
}

VOID
BANDWIDTH_INFO::Terminate( VOID )
/*++
  Destroys bandwidth info object.  This is a pseudo-destructor.

  Arguments:
    None

  Returns:
    None

--*/
{
    Lock();

    // first prevent any new requests from getting blocked

    InterlockedExchangePointer( (PVOID *) &_pStatus,
                                (PVOID) &sm_rgStatus[ZoneLevelLow][0] );

    // disable the descriptor

    InterlockedExchange( (LPLONG) &_fEnabled, FALSE );

    // now remove any blocked requests

    ATQ_REQUIRE( CheckAndUnblockRequests() );
    ATQ_ASSERT( _cCurrentBlockedRequests == 0 );
    ATQ_ASSERT( IsListEmpty( &_BlockedListHead ) );

    Unlock();

    DeleteCriticalSection( &_csPrivateLock );

    // remove self from shared bandwidth info list

    SharedLock();

    RemoveFromBornList();

    SharedUnlock();

    _Signature = ATQ_BW_INFO_SIGNATURE_FREE;
}

BOOL
BANDWIDTH_INFO::PrepareToFree( VOID )
{
    InterlockedExchange( (LPLONG) &_fIsFreed, TRUE );
    Dereference();
    return TRUE;
}

BOOL
BANDWIDTH_INFO::BlockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Block this request on the queue of requests waiting to be processed.

  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                  to be blocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{
    BOOL            fRet = TRUE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( IsValidAtqOp( pAtqContext->arInfo.atqOp ) );

    Lock();

    if ( _cCurrentBlockedRequests == _cMaxBlockedList )
    {
        fRet = FALSE;
    }
    else
    {
        pAtqContext->SetFlag( ACF_BLOCKED );

        InsertTailList( &_BlockedListHead, &pAtqContext->BlockedListEntry );

        IncCurrentBlockedRequests();
    }

    Unlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::RemoveFromBlockedList(
    IN PATQ_CONT            pAtqContext
)
/*++
  This function forcibly removes an ATQ context from blocked list of requests.

  Argument:
   pAtqContext    pointer to ATQ context whose request is in blocked list.

  Returns:
   TRUE on success and FALSE if there is any error.
--*/
{
    if ( !pAtqContext->IsBlocked() ) {

        // some other thread just removed this request from waiting list.
        return TRUE;
    }

    Lock();

    RemoveEntryList(&pAtqContext->BlockedListEntry);

    DecCurrentBlockedRequests();

    pAtqContext->ResetFlag( ACF_BLOCKED);

    Unlock();

    //
    // On such a forcible removal, we may have to make a callback indicating
    //   failure. Ignored!  To be done by the caller of this API.
    //

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UnblockRequest(
    IN OUT PATQ_CONT        pAtqContext
)
/*++
  Unblocks this request from the queue of requests waiting to be processed.
  Call this function only when
       _pStatus[pAtqContext->atqOp] != StatusBlockOperation.
  First, this function removes the request from queue of requests and processes
   it according to status and operation to be performed.
  If the status is AllowRequest ==> this function restarts the operation.
  If the status is reject operation ==> rejects operation and invokes
                        call back function indicating the error status.

  Call this function after lock()ing


  Arguments:
    pAtqContext   pointer to ATQ context information for request that needs
                     to be unblocked.

  Returns:
    TRUE on success. FALSE if there are any errors.
    (Use GetLastError() for details)

--*/
{
    BOOL fRet = FALSE;

    ATQ_ASSERT( pAtqContext != NULL);
    ATQ_ASSERT( pAtqContext->Signature == ATQ_CONTEXT_SIGNATURE );

    // Remove the request from the blocked list entry
    RemoveEntryList( &pAtqContext->BlockedListEntry);
    DecCurrentBlockedRequests();
    pAtqContext->ResetFlag( ACF_BLOCKED );

    // Check and re enable the operation of pAtqContext

    switch ( _pStatus[ pAtqContext->arInfo.atqOp ] ) {

      case StatusAllowOperation:

        IncTotalAllowedRequests();
        switch ( pAtqContext->arInfo.atqOp) {

          case AtqIoRead:
            {
                DWORD cbRead;  // Discard after calling ReadFile()
                DWORD dwFlags = 0;

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSARecv( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbRead,
                                   &dwFlags,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSARecv( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                       &wsaBuf,
                                       1,
                                       &cbRead,
                                       &dwFlags,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoWrite:
            {
                DWORD cbWrite;  // Discard after calling WriteFile()

                // assume that this is a socket operation!
                if ( pAtqContext->arInfo.uop.opReadWrite.dwBufferCount > 1) {
                    ATQ_ASSERT( NULL !=
                                pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    fRet =
                        ((WSASend( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                   pAtqContext->arInfo.uop.opReadWrite.pBufAll,
                                   pAtqContext->arInfo.uop.opReadWrite.dwBufferCount,
                                   &cbWrite,
                                   0,
                                   pAtqContext->arInfo.lpOverlapped,
                                   NULL
                                   ) == 0)||
                         (WSAGetLastError() == WSA_IO_PENDING)
                         );

                    // free up the socket buffers
                    ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
                    pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
                } else {
                    WSABUF wsaBuf =
                    { pAtqContext->arInfo.uop.opReadWrite.buf1.len,
                      pAtqContext->arInfo.uop.opReadWrite.buf1.buf
                    };
                    fRet = (( WSASend( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                       &wsaBuf,
                                       1,
                                       &cbWrite,
                                       0,
                                       pAtqContext->arInfo.lpOverlapped,
                                       NULL
                                       ) == 0)||
                            (WSAGetLastError() == WSA_IO_PENDING)
                            );
                }
                break;
            }

          case AtqIoXmitFile:
            {
                fRet = g_pfnTransmitFile( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                                     pAtqContext->arInfo.uop.opXmit.hFile,
                                     pAtqContext->arInfo.uop.opXmit.
                                         dwBytesInFile,
                                     0,
                                     pAtqContext->arInfo.lpOverlapped,
                                     pAtqContext->arInfo.uop.
                                           opXmit.lpXmitBuffers,
                                     pAtqContext->arInfo.uop.
                                           opXmit.dwFlags );

                if ( !fRet && (GetLastError() == ERROR_IO_PENDING) ) {
                    fRet = TRUE;
                }
                break;
            }

          default:
            ATQ_ASSERT( FALSE);
            break;
        } // switch

        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since operation done.
        break;

      case StatusRejectOperation:

        IncTotalRejectedRequests();
        if ( ((pAtqContext->arInfo.atqOp == AtqIoRead) ||
             (pAtqContext->arInfo.atqOp == AtqIoRead)) &&
             (pAtqContext->arInfo.uop.opReadWrite.pBufAll != NULL)
             ) {
            ::LocalFree( pAtqContext->arInfo.uop.opReadWrite.pBufAll);
            pAtqContext->arInfo.uop.opReadWrite.pBufAll = NULL;
        }
        pAtqContext->arInfo.atqOp = AtqIoNone; // reset since op rejected.
        SetLastError( ERROR_NETWORK_BUSY);
        fRet = FALSE;
        break;

      case StatusBlockOperation:
        // do nothing. we cannot unblock
        ATQ_ASSERT(FALSE);
        return (TRUE);

      default:
        ATQ_ASSERT( FALSE);
        break;
    } // switch

    if (!fRet) {

        // Call the completion function to signify the error in operation.

        //
        //  Reset the timeout value so requests don't
        //  timeout multiple times
        //

        InterlockedExchange(
                    (LPLONG ) &pAtqContext->NextTimeout,
                    ATQ_INFINITE
                    );

        InterlockedDecrement( &pAtqContext->m_nIO);

        pAtqContext->IOCompletion( 0,
                                   GetLastError(),
                                   pAtqContext->arInfo.lpOverlapped );
    } // on failure.

    return (fRet);
}

BOOL
BANDWIDTH_INFO::CheckAndUnblockRequests( VOID )
/*++
  Checks the list of blocked requests and identifies all operations
  that needs to be unblocked. This function unblocks those requests and
  removes them from blocked list.

  Always call this function after lock()ing

  Returns:
    TRUE on success and FALSE on failure.

--*/
{
    BOOL fRet = TRUE;

    //
    //  If the list is not empty, then check and process blocked requests.
    //

    if ( !IsListEmpty( &_BlockedListHead ) ) {

        PLIST_ENTRY pentry;

        //
        //  Scan the blocked requests list looking for pending requests
        //   that needs to be unblocked and unblock these requests.
        //

        for (pentry  = _BlockedListHead.Flink;
             pentry != &_BlockedListHead;
             pentry  = pentry->Flink )
          {
              PATQ_CONT pContext = CONTAINING_RECORD(pentry,
                                                     ATQ_CONTEXT,
                                                     BlockedListEntry );

              if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE)
                {
                    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                    fRet = FALSE;
                    break;
                }

              if ( !pContext->IsBlocked()) {

                  // This should not happen.
                  ATQ_ASSERT( !pContext->IsBlocked());
                  fRet = FALSE;
                  continue;
              }

              //
              //  Check to see if the status for operation has changed.
              //  If so, unblock the request.
              //

              if ( _pStatus[pContext->arInfo.atqOp] !=
                  StatusBlockOperation) {

                  fRet &= UnblockRequest( pContext );
              }

          } // scan list
    }

    return (fRet);
}

BOOL
BANDWIDTH_INFO::UpdateBandwidth(
    VOID
)
/*++
  This function updates the current bandwidth value using the histogram
   of bytes transferred.
  The histogram maintains a history of bytes transferred over different sample
   periods of a single minute. Each entry in the histogram corresponds to one
   interval of sample. The sum of all entries gives the total bytes transferred
   in a single minute. We divide this measure by 60 to obtain the count of
   bytes transferred over a second. This update bandwidth is used to
   reevalute the tuner of bandwidth throttle based on our throttling policy
   (specified in throttling algorithm). The updated action information is
   used by subsequent requests.
  In addition the _pcbXfered pointer is advanced forward using the
   histogram entries as a circular buffer, to obtain the count of bytes
   for next interval.

  Arguments:
    pdwPrivateBw - Filled with bandwidth for this descriptor

  Returns:
    TRUE on success. FALSE otherwise.

  Note:
   It is recommended that this function be called as infrequently as
    possible, using reasonable sample intervals.

--*/
{
    BOOL fRet = TRUE;
    ZoneLevel zonelevel;

    Lock();

    // accumulate current byte count to global counter, to minimize computation
    _cbXfered.QuadPart = _cbXfered.QuadPart + _pBytesXferCur->QuadPart;

    //
    // Current n/ws support a max of 1 to 100 MB/s. We can represent
    //  4GB/s in a DWORD. Hence the cast is used. This may need revision later.
    // Better yet, later we should store bandwidth as KB/seconds.
    //
    _dwMeasuredBw = (DWORD ) (_cbXfered.QuadPart/ATQ_AVERAGING_PERIOD);

    CIRCULAR_INCREMENT( _pBytesXferCur, _rgBytesXfered, ATQ_HISTOGRAM_SIZE);
    // Adjust the global cumulative bytes sent after increment.
    _cbXfered .QuadPart = _cbXfered.QuadPart - _pBytesXferCur->QuadPart;
    // Reset the counter to start with the new counter value.
    _pBytesXferCur->QuadPart = 0;

    //
    // update the operation status depending upon the bandwidth comparisons.
    // we use band/zone calculations to split the result into 3 zones.
    // Depending upon the zone we update the global status pointer to
    //   appropriate row.
    //

    if ( _dwMeasuredBw < ATQ_LOW_BAND_THRESHOLD(_bandwidth)) {

        //
        // Lower zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelLow;

    } else if ( _dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD(_bandwidth)) {

        //
        // Higher zone. Modify the pointer to OPERATION_STATUS accordingly.
        //

        zonelevel = ZoneLevelHigh;

    } else {

        zonelevel = ZoneLevelMedium;
    }

    /*++
      Above calculation can be implemented as:
      zonelevel = (( sm_dwMeasuredBw > ATQ_LOW_BAND_THRESHOLD( sm_bandwidth)) +
                   ( sm_dwMeasuredBw > ATQ_HIGH_BAND_THRESHOLD( sm_bandwidth)));

      This is based on implicit dependence of ordering of ZoneLevel entries.
      So avoided for present now.
    --*/

    if ( _pStatus != &sm_rgStatus[zonelevel][0]) {

        // Status needs to be changed.
        _pStatus = &sm_rgStatus[zonelevel][0];

        // Examine and reenable blocked operations if any.
        fRet &= CheckAndUnblockRequests();
    }

    // remove the bandwidth info object from the list if it is
    // "inactive" (bandwidth = 0)

    if ( !_dwMeasuredBw )
    {
        // there should be no requests in the blocked queue!

        ATQ_ASSERT( _cCurrentBlockedRequests == 0 );

        RemoveFromActiveList();
    }

    Unlock();

    return fRet;
}

DWORD
BANDWIDTH_INFO::SetBandwidthLevel(
    IN DWORD                    Data
)
/*++
   Sets the bandwidth threshold

   Arguments:
      Data - Bandwidth threshold

   Returns:
      Old bandwidth threshold (DWORD)
--*/
{
    DWORD dwOldVal;
    INT iListDelta = 0;

    Lock();

    dwOldVal = _bandwidth.dwSpecifiedLevel;

    if ( Data != INFINITE) {

        DWORD dwTemp;

        _bandwidth.dwSpecifiedLevel  = ATQ_ROUNDUP_BANDWIDTH( Data );
        dwTemp = ( Data *9)/10;               //low threshold = 0.9*specified
        _bandwidth.dwLowThreshold    = ATQ_ROUNDUP_BANDWIDTH( dwTemp);
        dwTemp = ( Data *11)/10;              //high threshold= 1.1*specified
        _bandwidth.dwHighThreshold   = ATQ_ROUNDUP_BANDWIDTH( dwTemp);

        _fEnabled = TRUE;
        // we should recheck the throttling and blocked requests
        // Will be done when the next timeout occurs in the ATQ Timeout Thread

        if ( dwOldVal == INFINITE )
        {
            iListDelta = 1;
        }

    } else {

        _bandwidth.dwSpecifiedLevel = INFINITE;
        _bandwidth.dwLowThreshold   = INFINITE;
        _bandwidth.dwHighThreshold  = INFINITE;

        _fEnabled = FALSE;

        // enable all operations, since we are in low zone
        _pStatus = &sm_rgStatus[ZoneLevelLow][0];

        // we should recheck and enable all blocked requests.
        if ( _cCurrentBlockedRequests > 0) {
            ATQ_REQUIRE( CheckAndUnblockRequests());
        }

        if ( dwOldVal != INFINITE )
        {
            iListDelta = -1;
        }
    }

    Unlock();

    // update the static counter of how many non-infinite throttles we have

    if ( iListDelta )
    {
        SharedLock();

        if ( iListDelta > 0 )
        {
            sm_cNonInfinite++;
        }
        else
        {
            sm_cNonInfinite--;
        }
        sm_fGlobalEnabled = !!sm_cNonInfinite;

        SharedUnlock();
    }

    return dwOldVal;

}

DWORD
BANDWIDTH_INFO::SetMaxBlockedListSize(
    IN DWORD                    cMaxSize
)
/*++
   Sets the maximum size of blocked request list

   Arguments:
      cMaxSize - maximum size of list

   Returns:
      Old max size (DWORD)
--*/
{
    DWORD           cOldMax;

    Lock();

    cOldMax = _cMaxBlockedList;
    _cMaxBlockedList = cMaxSize;

    Unlock();

    return cOldMax;
}

DWORD
BANDWIDTH_INFO::QueryBandwidthLevel( VOID )
/*++
   Retrieve the current bandwidth level

   Arguments:
      None

   Returns:
      Set Bandwidth level (DWORD)
--*/
{
    DWORD dwBw;

    Lock();

    dwBw = _bandwidth.dwSpecifiedLevel;

    Unlock();

    return dwBw;
}

BOOL
BANDWIDTH_INFO::ClearStatistics( VOID )
{
    Lock();

    _cTotalAllowedRequests = 0;
    _cTotalBlockedRequests = 0;
    _cTotalRejectedRequests = 0;

    Unlock();

    return TRUE;
}

BOOL
BANDWIDTH_INFO::GetStatistics( OUT ATQ_STATISTICS * pAtqStats )
{
    ATQ_ASSERT( pAtqStats != NULL );

    pAtqStats->cRejectedRequests = _cTotalRejectedRequests;
    pAtqStats->cBlockedRequests = _cTotalBlockedRequests;
    pAtqStats->cAllowedRequests = _cTotalAllowedRequests;
    pAtqStats->cCurrentBlockedRequests = _cCurrentBlockedRequests;
    pAtqStats->MeasuredBandwidth = _dwMeasuredBw;

    return TRUE;
}

BOOL
BANDWIDTH_INFO::UpdateAllBandwidths( VOID )
{
    PLIST_ENTRY             pEntry;
    BOOL                    fRet = TRUE;
    DWORD                   dwCounter = 0;

    SharedLock();

    for ( pEntry = sm_ActiveListHead.Flink;
          pEntry != &sm_ActiveListHead; )
    {
        BANDWIDTH_INFO *pBandwidthInfo = CONTAINING_RECORD( pEntry,
                                                            BANDWIDTH_INFO,
                                                            _ActiveListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        // we might be deleting this entry from the list.  Grab the next
        // link now before we do so the traversal can happen smoothly

        pEntry = pEntry->Flink;

        if ( !pBandwidthInfo->Enabled() )
        {
            continue;
        }

        if ( !pBandwidthInfo->UpdateBandwidth() )
        {
            fRet = FALSE;
            break;
        }

#ifndef _NO_TRACING_
        CHKINFO(( DBG_CONTEXT, "pBWInfo =  %p (%s), Bandwidth = %u, Threshold = %d\n",
                     pBandwidthInfo,
                     pBandwidthInfo->_achDescription,
                     pBandwidthInfo->QueryMeasuredBw(),
                     pBandwidthInfo->QueryBandwidthLevel() ) );
#else
        ATQ_PRINTF(( DBG_CONTEXT, "pBWInfo =  %p (%s), Bandwidth = %u, Threshold = %d\n",
                     pBandwidthInfo,
                     pBandwidthInfo->_achDescription,
                     pBandwidthInfo->QueryMeasuredBw(),
                     pBandwidthInfo->QueryBandwidthLevel() ) );
#endif
    }

    SharedUnlock();

    return fRet;
}

BOOL
BANDWIDTH_INFO::AbwInitialize( VOID )
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, 10, sizeof(BANDWIDTH_INFO)};

    ATQ_ASSERT( sm_pachBWInfos == NULL );

    sm_pachBWInfos = new ALLOC_CACHE_HANDLER( "BandwidthInfos",
                                              &acConfig );

    if ( sm_pachBWInfos == NULL )
    {
        return FALSE;
    }

    InitializeListHead( &sm_ActiveListHead );
    InitializeListHead( &sm_BornListHead );
    INITIALIZE_CRITICAL_SECTION( &sm_csSharedLock );

    sm_cActiveList          = 0;
    sm_cBornList            = 0;
    sm_fGlobalEnabled       = FALSE;
    sm_fGlobalActive        = FALSE;
    sm_cNonInfinite         = 0;
    sm_cSamplesForTimeout   = 1;

    g_pBandwidthInfo = new BANDWIDTH_INFO( TRUE );

    if ( !g_pBandwidthInfo )
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
BANDWIDTH_INFO::AbwTerminate( VOID )
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    ATQ_PRINTF(( DBG_CONTEXT,
                 "AbwTerminate() called.  Born List Size = %d\n",
                 sm_cBornList ));

    SharedLock();

    while( !IsListEmpty( &sm_BornListHead ) )
    {
        pBandwidthInfo = CONTAINING_RECORD( sm_BornListHead.Flink,
                                            BANDWIDTH_INFO,
                                            _BornListEntry );

        ATQ_ASSERT( pBandwidthInfo != NULL );

        delete pBandwidthInfo;
    }

    ATQ_ASSERT( sm_cBornList == 0 );
    ATQ_ASSERT( sm_cActiveList == 0 );
    ATQ_ASSERT( IsListEmpty( &sm_BornListHead ) );
    ATQ_ASSERT( IsListEmpty( &sm_ActiveListHead ) );

    SharedUnlock();

    DeleteCriticalSection( &sm_csSharedLock );

    if ( sm_pachBWInfos != NULL )
    {
        delete sm_pachBWInfos;
        sm_pachBWInfos = NULL;
    }

    return TRUE;
}


PVOID
AtqCreateBandwidthInfo( VOID )
/*++

Routine Description:

    Allocate a bandwidth throttling descriptor

Arguments:

    none

Return Value:

    If successful, pointer to allocated descriptor.  Otherwise NULL.

--*/
{
    PBANDWIDTH_INFO         pBandwidthInfo;

    pBandwidthInfo = new BANDWIDTH_INFO( FALSE );
    if ( pBandwidthInfo == NULL )
    {
        return NULL;
    }
    else
    {
        ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
        return pBandwidthInfo;
    }
}


BOOL
AtqFreeBandwidthInfo(
    IN PVOID        pvBandwidthInfo
)
/*++

Routine Description:

    Free bandwidth throttling descriptor

Arguments:

    pBandwidthInfo - Descriptor to destroy

Return Value:

    TRUE If successful, else FALSE.

--*/
{
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    return pBandwidthInfo->PrepareToFree();
}


ULONG_PTR
AtqBandwidthSetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      IN ULONG_PTR              Data
)
/*++

Routine Description:

    Set member of bandwidth descriptor

Arguments:

    pBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    Data - Data to set to

Return Value:

    Previous value of descriptor

--*/
{
    ULONG_PTR        oldVal = 0;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            oldVal = (ULONG_PTR)pBandwidthInfo->QueryBandwidthLevel();
            pBandwidthInfo->SetBandwidthLevel( (DWORD) Data );
            break;
        case ATQ_BW_MAX_BLOCKED:
            oldVal = (ULONG_PTR)pBandwidthInfo->QueryMaxBlockedSize();
            pBandwidthInfo->SetMaxBlockedListSize( (DWORD) Data );
            break;
        case ATQ_BW_DESCRIPTION:
            oldVal = (ULONG_PTR)Data;
            pBandwidthInfo->SetDescription( (CHAR*) Data );
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
    }

    return oldVal;

}


BOOL
AtqBandwidthGetInfo(
      IN PVOID                 pvBandwidthInfo,
      IN ATQ_BANDWIDTH_INFO    BwInfo,
      OUT ULONG_PTR *           pData
)
/*++

Routine Description:

    Get member of bandwidth descriptor

Arguments:

    pvBandwidthInfo - Descriptor to change
    BwInfo - Value of descriptor to set
    pData - Output here

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    BOOL            fRet = TRUE;
    PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) pvBandwidthInfo;

    ATQ_ASSERT( pBandwidthInfo );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );
    ATQ_ASSERT( pData );

    if ( pBandwidthInfo &&
         pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE &&
         pData )
    {
        switch ( BwInfo )
        {
        case ATQ_BW_BANDWIDTH_LEVEL:
            *pData = (ULONG_PTR)pBandwidthInfo->QueryBandwidthLevel();
            break;
        case ATQ_BW_MAX_BLOCKED:
            *pData = (ULONG_PTR)pBandwidthInfo->QueryMaxBlockedSize();
            break;
        case ATQ_BW_STATISTICS:
            fRet = pBandwidthInfo->GetStatistics( (ATQ_STATISTICS*) pData );
            break;
        case ATQ_BW_DESCRIPTION:
            *pData = (ULONG_PTR)pBandwidthInfo->QueryDescription();
            break;
        default:
            SetLastError( ERROR_INVALID_PARAMETER );
            ATQ_ASSERT( FALSE );
            fRet = FALSE;
            break;
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        fRet = FALSE;
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\atqbmon.cxx ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    atqbmon.cxx

Abstract:

    ATQ Backlog Monitor

Author:

    01-Dec-1998  MCourage

Revision History:

--*/

#include "isatq.hxx"

#include "atqbmon.hxx"

ATQ_BACKLOG_MONITOR * g_pAtqBacklogMonitor = NULL;



ATQ_BACKLOG_MONITOR::ATQ_BACKLOG_MONITOR(
    VOID
    )
/*++

Routine Description:

    Constructor sets up the list and the lock.

Arguments:

    None
--*/
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    InitializeListHead( &m_ListHead );
}


ATQ_BACKLOG_MONITOR::~ATQ_BACKLOG_MONITOR(
    VOID
    )
/*++

Routine Description:

    Destructor cleans up the list and the lock.

Arguments:

    None
--*/
{
    LIST_ENTRY *   pEntry;
    ATQ_BMON_SET * pBmonSet;

    //
    // traverse the list and remove all sets
    //
    while (!IsListEmpty( &m_ListHead )) {

        pEntry = RemoveHeadList( &m_ListHead );

        pBmonSet = CONTAINING_RECORD( pEntry, ATQ_BMON_SET, m_SetList );

        DBG_ASSERT( pBmonSet->IsEmpty() );
        DBG_REQUIRE( pBmonSet->Cleanup() );
    }

    DeleteCriticalSection( &m_csLock );
}


BOOL
ATQ_BACKLOG_MONITOR::AddEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Adds an entry to the next available ATQ_BMON_SET.
    Makes a new set if all current sets are full.

Arguments:

    pBmonEntry - The entry to be added

Return Values:

    TRUE on success
--*/
{
    LIST_ENTRY *   pCurrent;
    ATQ_BMON_SET * pBmonSet;
    BOOL           bRetval;

    if (!pBmonEntry) {
        return TRUE;
    }

    bRetval = FALSE;

    Lock();

    for (pCurrent = m_ListHead.Flink;
         pCurrent != &m_ListHead;
         pCurrent = pCurrent->Flink) {

        pBmonSet = CONTAINING_RECORD( pCurrent, ATQ_BMON_SET, m_SetList );

        if (pBmonSet->IsNotFull() && pBmonSet->AddEntry(pBmonEntry)) {
            bRetval = TRUE;
            break;
        }
    }

    if (!bRetval) {
        //
        // Couldn't find a set with space
        // so try to make a new one.
        //
        pBmonSet = new ATQ_BMON_SET;

        if (pBmonSet && pBmonSet->Initialize()) {
            InsertHeadList( &m_ListHead, &pBmonSet->m_SetList );
            bRetval = pBmonSet->AddEntry(pBmonEntry);
        }
    }

    Unlock();

    return bRetval;
}


BOOL
ATQ_BACKLOG_MONITOR::RemoveEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Removes an entry from its containing ATQ_BMON_SET.
    If the set is empty it is removed from the list
    of sets.

Arguments:

    pBmonEntry - The entry to be removed

Return Values:

    TRUE on success
--*/
{
    ATQ_BMON_SET * pBmonSet;

    if (!pBmonEntry) {
        return TRUE;
    }

    DBG_ASSERT( pBmonEntry && pBmonEntry->CheckSignature() );

    pBmonSet = pBmonEntry->GetContainingBmonSet();

    DBG_ASSERT( pBmonSet );

    return pBmonSet->RemoveEntry(pBmonEntry);
}


BOOL
ATQ_BACKLOG_MONITOR::PauseEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Pauses an entry in its containing ATQ_BMON_SET.
    The entry will remain in the set, but will
    not send notifications.

Arguments:

    pBmonEntry - The entry to be paused

Return Values:

    TRUE on success
--*/
{
    ATQ_BMON_SET * pBmonSet;

    if (!pBmonEntry) {
        return TRUE;
    }

    DBG_ASSERT( pBmonEntry && pBmonEntry->CheckSignature() );

    pBmonSet = pBmonEntry->GetContainingBmonSet();

    DBG_ASSERT( pBmonSet );

    return pBmonSet->PauseEntry(pBmonEntry);
}


BOOL
ATQ_BACKLOG_MONITOR::ResumeEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Undoes PauseEntry. The entry in question
    will get notifications again

Arguments:

    pBmonEntry - The entry to be resumed

Return Values:

    TRUE on success
--*/
{
    ATQ_BMON_SET * pBmonSet;

    if (!pBmonEntry) {
        return TRUE;
    }

    DBG_ASSERT( pBmonEntry && pBmonEntry->CheckSignature() );

    pBmonSet = pBmonEntry->GetContainingBmonSet();

    DBG_ASSERT( pBmonSet );

    return pBmonSet->ResumeEntry(pBmonEntry);
}



ATQ_BMON_ENTRY::ATQ_BMON_ENTRY(
    SOCKET s
    )
/*++

Routine Description:

    Constructor sets up signature etc.

Arguments:

    None
--*/
{
    DBG_ASSERT( s );

    m_Signature       = ATQ_BMON_ENTRY_SIGNATURE;
    m_Socket          = s;
    m_hAddRemoveEvent = NULL;
    m_BmonOpcode      = BMON_INVALID;
    m_pBmonSet        = NULL;
    m_dwErr           = NO_ERROR;
}


ATQ_BMON_ENTRY::~ATQ_BMON_ENTRY(
    VOID
    )
/*++

Routine Description:

    Destructor sets up signature and closes event.

Arguments:

    None
--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_Socket );

    m_Signature = ATQ_FREE_BMON_ENTRY_SIGNATURE;

    DBG_REQUIRE( CloseHandle( m_hAddRemoveEvent ) );
}


BOOL
ATQ_BMON_ENTRY::InitEvent(
    VOID
    )
/*++

Routine Description:

    Sets up the AddRemove event that we use
    to synchronise adding and removing of entries.

Arguments:

    None

Return Values:

    TRUE on success
--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_hAddRemoveEvent == NULL );

    m_hAddRemoveEvent = CreateEvent(
                            NULL,    // default security
                            FALSE,   // do auto-reset
                            FALSE,   // init state false
                            NULL     // no name
                            );

    if (m_hAddRemoveEvent == NULL) {
        m_dwErr = GetLastError();
    }

    return (m_hAddRemoveEvent != NULL);
}


VOID
ATQ_BMON_ENTRY::SignalAddRemove(
    DWORD dwError
    )
/*++

Routine Description:

    Signals the AddRemove event. Clients adding or
    removing the entry will be blocked on its event.

Arguments:

    None

Return Values:

    None
--*/
{
    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_hAddRemoveEvent != NULL );

    m_dwErr = dwError;
    DBG_REQUIRE( SetEvent(m_hAddRemoveEvent) );
}



BOOL
ATQ_BMON_ENTRY::WaitForAddRemove(
    VOID
    )
/*++

Routine Description:

    Call this function while waiting for
    the entry to be added to or removed from a set.

Arguments:

    None

Return Values:

    TRUE on success
--*/
{
    DWORD dwResult;

    DBG_ASSERT( CheckSignature() );
    DBG_ASSERT( m_hAddRemoveEvent != NULL );

    //
    // If the monitor thread dies, don't bother waiting for notification from
    // it regarding add/removal.
    //

Retry:

    if ( m_pBmonSet && !m_pBmonSet->ThreadFinished() )
    {
        dwResult = WaitForSingleObject(m_hAddRemoveEvent, 10000 );
        if ( dwResult == WAIT_TIMEOUT )
        {
            goto Retry;
        }
    }
    else
    {
        dwResult = WAIT_OBJECT_0;
    }

    DBG_ASSERT( dwResult == WAIT_OBJECT_0 );

    return (dwResult == WAIT_OBJECT_0);
}


BOOL
BMON_WAKEUP_ENTRY::Callback(
    VOID
    )
/*++

Routine Description:

    The sole purpose of the BMON_WAKEUP_ENTRY is to
    get the main thread to wake up and call
    SynchronizeSets. All we have to do here is
    do a read so that we can wake up again in
    the future.

Arguments:

    None

Return Values:

    TRUE if successful, else FALSE
--*/
{
    INT            err;
    DWORD          dwBuff;
    ATQ_BMON_SET * pBmonSet;

    SOCKADDR_IN    sockAddr;
    int            dwSize = sizeof(sockAddr);

    ZeroMemory( &sockAddr, sizeof(sockAddr) );


    DBG_ASSERT( CheckSignature() );

    //
    // do a read to clear the wakeup signal
    //
    err = recvfrom(
                GetSocket(),     // our socket
                (PCHAR) &dwBuff, // read buffer
                sizeof(dwBuff),  // buffer len
                0,               // flags
                (sockaddr *)&sockAddr, // src addr
                &dwSize                // src addr len
                );

    if ( err == SOCKET_ERROR ) {

        DBGPRINTF((DBG_CONTEXT,
            "Error %d in recvfrom\n", WSAGetLastError()));
        return FALSE;

    } else {
        //
        // We expect 4 bytes representing ATQ_BMON_WAKEUP_MESSAGE
        // However it is possible that someone external
        // has sent datagram to our port
        //

        if ( ( err != sizeof( dwBuff ) ) ||
             ( dwBuff != ATQ_BMON_WAKEUP_MESSAGE) ) {

            //
            // check if returned source address structure is valid
            //
            if ( dwSize != sizeof(sockAddr) )
            {
                DBGPRINTF((DBG_CONTEXT,
                    "Format of source address returned by recvfrom not recognized\n" ));
                DBG_ASSERT( FALSE );
            }
            else  {
                //
                // Backlog monitor is using blocking select() calls and in order to
                // be able to unblock there is a wake up endpoint maintained
                // (listening on loopback address)
                // external programs running on the same computer may eventually
                // send random data to this this backlog monitor wakeup endpoint.
                // That by itself causes no harm, but we should be aware of it
                //

                DBGPRINTF((DBG_CONTEXT,
                    "Warning: external source sent data to the BACKLOG monitor wakeup port\n" ));
            }
        }

        return TRUE;
    }
}



ATQ_BMON_SET::ATQ_BMON_SET(
    VOID
    )
/*++

Routine Description:

    Constructor sets up critsec and sets.

Arguments:

    None
--*/
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );

    memset(m_apEntrySet, 0, sizeof(m_apEntrySet));
    FD_ZERO( &m_ListenSet );

    m_SetSize      = 0;
    m_pWakeupEntry = NULL;
    m_fCleanup     = FALSE;
    m_fDoSleep     = FALSE;
    m_fThreadFinished = FALSE;
    m_dwError      = NO_ERROR;
}


ATQ_BMON_SET::~ATQ_BMON_SET(
    VOID
    )
/*++

Routine Description:

    Destructor cleans up critsec.

Arguments:

    None
--*/
{
    DBG_ASSERT( m_SetSize == 0 );

    //
    // get rid of the wakeup entry
    //
    DBG_REQUIRE( 0 == closesocket(m_pWakeupEntry->GetSocket()) );
    delete m_pWakeupEntry;

    DeleteCriticalSection(&m_csLock);
}


BOOL
ATQ_BMON_SET::Initialize(
    VOID
    )
/*++

Routine Description:

    Sets up the Wakeup entry and starts
    our thread.

Arguments:

    None

Return Values:

    TRUE on success
--*/
{
    BOOL                bRetval;
    SOCKET              s = INVALID_SOCKET;
    SOCKET              s2 = INVALID_SOCKET;
    SOCKADDR_IN         sockAddr;
    BMON_WAKEUP_ENTRY * pWakeup = NULL;
    HANDLE              hThread;
    DWORD               dwError = NO_ERROR;

    bRetval = FALSE;

    ZeroMemory(&sockAddr, sizeof(sockAddr));
    sockAddr.sin_family = AF_INET;

    //
    // set up wakeup entry
    //
    // also create a second socket, bound to the non-loopback interfaces, and shut it down -
    // this will prevent another application from binding to the non-specific interface on
    // the same port.
    // this is done for compatibility with pre-.Net applications (ISA 2000) that
    // are using the same code, but are broken by IIS switching to the loopback address
    // in exclusive mode.
    //

    for (WORD wPort = ATQ_BMON_WAKEUP_PORT; wPort <= ATQ_BMON_WAKEUP_PORT_MAX; wPort++) {
        //
        // start with the non-specific socket
        //
        if (s2 == INVALID_SOCKET) {
            s2 = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

            if (s2 == INVALID_SOCKET)
                goto failsearch;
        }

        sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);
        sockAddr.sin_port = htons(wPort);

        if (bind(s2, (PSOCKADDR)&sockAddr, sizeof(sockAddr)))
        {
            DWORD WsaError = WSAGetLastError();
            if ((WsaError != WSAEADDRINUSE) && (WsaError != WSAEACCES))
                goto failsearch;

            // go try another port
            continue;
        }

        //
        // now to the real wakeup socket
        //

        if (s == INVALID_SOCKET) {
            s = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);

            if (s == INVALID_SOCKET)
                goto failsearch;

            //
            // set socket option for exclusive use of the port
            //

            BOOL bOpt = TRUE;

            if (setsockopt(s, SOL_SOCKET, SO_EXCLUSIVEADDRUSE, (LPCSTR) &bOpt, sizeof(bOpt)))
                goto failsearch;
        }

        sockAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

        if (bind(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr))) {

            DWORD WsaError = WSAGetLastError();
            if ((WsaError != WSAEADDRINUSE) && (WsaError != WSAEACCES))
                goto failsearch;

            //
            // the loopback address is in use. try a new port. just close s2, as it is bound
            //

            closesocket(s2);
            s2 = INVALID_SOCKET;

            continue;
        }

        // connect the sockets to the loopback address so they cannon be hijacked.
        if (connect(s, (PSOCKADDR)&sockAddr, sizeof(sockAddr)))
            goto failsearch;

        if (connect(s2, (PSOCKADDR)&sockAddr, sizeof(sockAddr)))
            goto failsearch;

        //
        // shut down s2 to prevent activity.
        //
        if (shutdown(s2, SD_BOTH))
            goto failsearch;

        // success!
        break;

failsearch:
        dwError = WSAGetLastError();
        goto exit;
    }

    if ( wPort > ATQ_BMON_WAKEUP_PORT_MAX ) {
        dwError = WSAEADDRINUSE;
        DBGERROR((DBG_CONTEXT,"Wakeup port search failed. Error %d\n", dwError));
        goto exit;
    }

    pWakeup = new BMON_WAKEUP_ENTRY(s, s2);
    if ( pWakeup == NULL )
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    s = INVALID_SOCKET;
    s2 = INVALID_SOCKET;

    if (!pWakeup->InitEvent()) {
        dwError = GetLastError();
        goto exit;
    }

    pWakeup->SetContainingBmonSet(this);
    pWakeup->SetOpcode(BMON_WAIT);

    m_pWakeupEntry = pWakeup;
    pWakeup        = NULL;
    m_Port         = wPort;

    //
    // just jam this entry into the lists
    //
    DBG_ASSERT(m_SetSize == 0);

    m_SetSize = 1;
    m_apEntrySet[0] = m_pWakeupEntry;
    FD_SET(m_pWakeupEntry->GetSocket(), &m_ListenSet);

    //
    // now set up our thread. from now on you
    // have to Lock before manipulating the
    // lists
    //
    m_hThread = CreateThread(
                    NULL,               // defualt security
                    0,                  // default stack
                    ::BmonThreadFunc,   // thread func
                    this,               // func parameter
                    0,                  // flags
                    NULL                // discard tid
                    );

    if (m_hThread) {
        //
        // it worked!
        //
        bRetval = TRUE;

    } else {
        //
        // doh! clean up the wakeup entry
        //
        dwError = GetLastError();

        m_SetSize = 0;
    }

exit:
    if (!bRetval) {

        if (s != INVALID_SOCKET) {
            closesocket(s);
        }

        if (s2 != INVALID_SOCKET) {
            closesocket(s2);
        }

        if (pWakeup) {
            delete pWakeup;
        }

        SetLastError(dwError);
    }

    return bRetval;
}


BOOL
ATQ_BMON_SET::Cleanup(
    VOID
    )
/*++

Routine Description:

    Tells the select thread to clean up by
    removing the wakeup entry.

Arguments:

    None

Return Values:

    TRUE on success
--*/
{
    //
    // Cleanup is done when wakup entry
    // is removed.
    //
    // Don't use RemoveEntry, because the
    // other thread will delete the wakeup
    // entry.
    //
    DBG_ASSERT( m_pWakeupEntry && m_pWakeupEntry->CheckSignature() );

    m_pWakeupEntry->SetOpcode(BMON_REMOVE);
    Wakeup();

    //
    // Wait a reasonable amount of time for the thread to go away.
    //

    WaitForSingleObject( m_hThread, 10000 );
    CloseHandle( m_hThread );
    m_hThread = NULL;

    delete this;

    return TRUE;
}


BOOL
ATQ_BMON_SET::IsEmpty(
    VOID
    )
/*++

Routine Description:

    This tells you if there are sockets in the
    set. Note that one socket is the wakeup
    socket, so a count of one means we're empty.

Arguments:

    None

Return Values:

    TRUE on empty
--*/
{
    BOOL bRetval;

    Lock();
    bRetval = (m_SetSize <= 1);
    DBG_ASSERT( m_SetSize <= FD_SETSIZE );
    Unlock();

    return bRetval;
}


BOOL
ATQ_BMON_SET::IsNotFull(
    VOID
    )
/*++

Routine Description:

    This tells you if there is room for more sockets
    in the set. Note that one socket is the wakeup
    socket.

Arguments:

    None

Return Values:

    TRUE when space is available
--*/
{
    BOOL bRetval;

    Lock();
    bRetval = (m_SetSize < FD_SETSIZE);
    DBG_ASSERT( m_SetSize <= FD_SETSIZE );
    Unlock();

    return bRetval;
}


BOOL
ATQ_BMON_SET::AddEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Add an entry to the set

Arguments:

    pBmonEntry - the entry to be added

Return Values:

    TRUE on success
--*/
{
    DWORD i;
    BOOL  bAdded = FALSE;
    DWORD dwError;

    pBmonEntry->SetOpcode(BMON_ADD);

    Lock();

    for (i = 0; i < FD_SETSIZE; i++) {
        if (!m_apEntrySet[i]) {
            m_apEntrySet[i] = pBmonEntry;
            pBmonEntry->SetContainingBmonSet(this);
            bAdded = TRUE;

            m_SetSize++;
            DBG_ASSERT( m_SetSize <= FD_SETSIZE );
            break;
        }
    }

    Unlock();

    if (bAdded) {
        Wakeup();
        pBmonEntry->WaitForAddRemove();

        dwError = pBmonEntry->GetError();

        if (dwError) {
            //
            // other thread will remove from list
            //
            SetLastError(dwError);
            bAdded = FALSE;
        }
    }

    return bAdded;
}


BOOL
ATQ_BMON_SET::RemoveEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Remove an entry from the set

Arguments:

    pBmonEntry - the entry to be removed

Return Values:

    TRUE on success
--*/
{
    DWORD i;
    BOOL  bRemoved = FALSE;

    pBmonEntry->SetOpcode(BMON_REMOVE);
    Wakeup();

    pBmonEntry->WaitForAddRemove();

    return (pBmonEntry->GetError() == NO_ERROR);
}


BOOL
ATQ_BMON_SET::PauseEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Pause an entry in the set. The entry's
    socket will be removed from the FD_SET,
    but the entry will stay.

Arguments:

    pBmonEntry - the entry to be paused

Return Values:

    TRUE on success
--*/
{
    DWORD i;
    BOOL  bRemoved = FALSE;

    DBGPRINTF((DBG_CONTEXT,
               "Pausing backlog monitor entry %p\n",
               pBmonEntry));

    pBmonEntry->SetOpcode(BMON_PAUSE);
    Wakeup();

    //
    // We don't do the event stuff for pause and
    // resume. It's a pain because the client will
    // want to pause from within the callback
    // function.
    //
    return (TRUE);
}


BOOL
ATQ_BMON_SET::ResumeEntry(
    ATQ_BMON_ENTRY * pBmonEntry
    )
/*++

Routine Description:

    Resume an entry in the set. The entry's
    socket will be added back to the FD_SET.

Arguments:

    pBmonEntry - the entry to be resumed

Return Values:

    TRUE on success
--*/
{
    DWORD i;
    BOOL  bRemoved = FALSE;


    if (pBmonEntry->GetOpcode() == BMON_NOWAIT) {
        DBGPRINTF((DBG_CONTEXT,
                   "Resuming backlog monitor entry %p\n",
                   pBmonEntry));

        pBmonEntry->SetOpcode(BMON_RESUME);
        Wakeup();
    }

    //
    // We don't do the event stuff for pause and
    // resume. It's a pain because the client will
    // want to pause from within the callback
    // function.
    //
    return (TRUE);
}



VOID
ATQ_BMON_SET::BmonThreadFunc(
    VOID
    )
/*++

Routine Description:

    This function is for the set's select thread.
    It calls accept with the listen set, and calls
    notification functions for all sockets that
    are ready.

    SynchronizeSets returns false when it's time
    to shut down.

Arguments:

    None

Return Values:

    None
--*/
{
    INT   err;

    while (SynchronizeSets()) {

        err = select(
                    0,              // junk
                    &m_ListenSet,   // readfds
                    NULL,           // writefds
                    NULL,           // exceptfds
                    NULL            // want to block
                    );

        if (err != SOCKET_ERROR) {
            DBG_ASSERT(err > 0);

            if ( !NotifyEntries() )
            {
                //
                // If we couldn't notify the entries, stop doing our thing
                //

                m_dwError = GetLastError();
                m_dwError |= BMON_NOTIFY_ERROR;
                break;
            }
        } else {
            //
            // Actually let's take the general approach that the moment the
            // Backlog monitor sees trouble, it should stop.  This avoids
            // low memory situations where the backlog monitor just spins,
            // thus becoming it's own denial of service attack.
            //

            m_dwError = WSAGetLastError();
            m_dwError |= BMON_SELECT_ERROR;
            break;

            DBGPRINTF(( DBG_CONTEXT,
                        "Select failed with error %d\n",
                        WSAGetLastError()
                        ));


        }

        if ( m_fDoSleep )
        {
            //
            // Now sleep for a while.  It will take time for unconnected to go away.
            // We don't want to spin
            //
            // Of course, this means we don't do useful work on any other endpoints
            // which may also be in trouble.  Oh well.
            //

            Sleep( 5000 );
            m_fDoSleep = FALSE;
        }
    }

    m_fThreadFinished = TRUE;
}


VOID
ATQ_BMON_SET::Wakeup(
    VOID
    )
/*++

Routine Description:

    We call this function when adding or removing
    an entry. Writing to the wakeup socket wakes
    up the select thread.

Arguments:

    None

Return Values:

    None
--*/
{
    SOCKADDR_IN sockAddr;
    INT         err;
    DWORD       dwBuf;

    ZeroMemory(&sockAddr, sizeof(sockAddr));
    sockAddr.sin_family = AF_INET;
    sockAddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    sockAddr.sin_port = htons(m_Port);

    dwBuf = ATQ_BMON_WAKEUP_MESSAGE;

    err = sendto(
            m_pWakeupEntry->GetSocket(),
            (PCHAR)&dwBuf,
            sizeof(dwBuf),
            0,
            (PSOCKADDR)&sockAddr,
            sizeof(sockAddr)
            );

    if ( err == SOCKET_ERROR ) {

        m_dwError = WSAGetLastError();
        m_dwError |= BMON_SENDTO_ERROR;

        DBGPRINTF((DBG_CONTEXT,
            "Error %d in sendto\n",WSAGetLastError()));
    }
}


BOOL
ATQ_BMON_SET::SynchronizeSets(
    VOID
    )
/*++

Routine Description:

    This function updates our FD_SET to reflect
    what's in the entry set, and also notifies
    entries which have been added or removed.

    We also check to see if it's time to shut
    down (as indicated by the removal of the
    wakeup entry.

Arguments:

    None

Return Values:

    TRUE  to continue operating
    FALSE on shutdown
--*/
{
    DWORD            i;
    ATQ_BMON_ENTRY * pBmonEntry;
    BOOL             bRetval;

    bRetval = TRUE;

    Lock();

    //
    // clear out whatever is there now
    //
    FD_ZERO(&m_ListenSet);

    //
    // put in everything we want
    //
    for (i = 0; i < FD_SETSIZE; i++) {
        pBmonEntry = m_apEntrySet[i];

        if (pBmonEntry) {
            DBG_ASSERT( pBmonEntry->CheckSignature() );

            switch(pBmonEntry->GetOpcode()) {
            case BMON_ADD:
                FD_SET(pBmonEntry->GetSocket(), &m_ListenSet);
                pBmonEntry->SetOpcode(BMON_WAIT);
                pBmonEntry->SignalAddRemove(NO_ERROR);
                break;

            case BMON_RESUME:
                FD_SET(pBmonEntry->GetSocket(), &m_ListenSet);
                pBmonEntry->SetOpcode(BMON_WAIT);
                break;

            case BMON_PAUSE:
                pBmonEntry->SetOpcode(BMON_NOWAIT);
                pBmonEntry->SignalAddRemove(NO_ERROR);
                break;

            case BMON_REMOVE:
                if (pBmonEntry == m_pWakeupEntry) {
                    //
                    // this means it's time to shut down
                    //
                    bRetval = FALSE;
                }

                m_apEntrySet[i] = NULL;
                m_SetSize--;
                pBmonEntry->SetContainingBmonSet(NULL);
                pBmonEntry->SignalAddRemove(NO_ERROR);
                break;

            case BMON_WAIT:
                FD_SET(pBmonEntry->GetSocket(), &m_ListenSet);
                break;

            case BMON_NOWAIT:
                //
                // this entry is paused, so don't do
                // anything
                //
                break;


            default:
                //
                // should never get here
                // remove the bad entry
                //
                DBGPRINTF((DBG_CONTEXT,
                           "Invalid opcode in ATQ_BMON_ENTRY %p, %d\n",
                           pBmonEntry, pBmonEntry->GetOpcode()));

                DBG_ASSERT(FALSE);
                m_apEntrySet[i] = NULL;
                break;
            }

        }

    }

    Unlock();

    return bRetval;
}


BOOL
ATQ_BMON_SET::NotifyEntries(
    VOID
    )
/*++

Routine Description:

    This function looks through the entries
    to see who needs to be notified and calls
    their callback function.

Arguments:

    None

Return Values:

    TRUE if successful, else FALSE
--*/
{
    DWORD            i;
    ATQ_BMON_ENTRY * pBmonEntry;
    BOOL             fRet = TRUE;

    Lock();

    for (i = 0; i < FD_SETSIZE; i++) {
        pBmonEntry = m_apEntrySet[i];

        if (pBmonEntry) {
            if (!pBmonEntry->CheckSignature()) {
                DBGPRINTF(( DBG_CONTEXT,
                            "ATQ_BMON_ENTRY(%p)::CheckSignature() failed. index = %d\n",
                            pBmonEntry, i));

                DBG_ASSERT( pBmonEntry->CheckSignature() );
            }

            if ((pBmonEntry->GetOpcode() == BMON_WAIT)
                && (FD_ISSET(pBmonEntry->GetSocket(), &m_ListenSet))) {

                if ( !pBmonEntry->Callback() )
                {
                    fRet = FALSE;
                    break;
                }
            }
        }
    }

    Unlock();

    return fRet;
}


DWORD WINAPI
BmonThreadFunc(
    LPVOID lpBmonSet
    )
/*++

Routine Description:

    This function starts the select thread
    of an ATQ_BMON_SET.

Arguments:

    pBmonSet - the set to call

Return Values:

    0
--*/
{
    ATQ_BMON_SET * pBmonSet = (ATQ_BMON_SET *) lpBmonSet;
    pBmonSet->BmonThreadFunc();
    return 0;
}


//
// atqbmon.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\atqmain.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      atqmain.cxx

   Abstract:
      This module implements entry points for ATQ - Asynchronous Thread Queue.

   Author:

       Murali R. Krishnan    ( MuraliK )     8-Apr-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqInitialize();
       BOOL  AtqTerminate();
       BOOL  AtqGetCompletionPort();

       DWORD AtqSetInfo();
       DWORD AtqGetInfo();
       BOOL  AtqGetStatistics();
       BOOL  AtqClearStatistics();

       BOOL  AtqAddAcceptExSockets();
       BOOL  AtqAddAsyncHandle();
       DWORD AtqContextSetInfo();
       VOID  AtqCloseSocket();
       VOID  AtqFreeContext();

       BOOL  AtqReadFile();
       BOOL  AtqWriteFile();
       BOOL  AtqTransmitFile();
       BOOL  AtqPostCompletionStatus();

       PVOID AtqAllocateBandwidthInfo();
       BOOL  AtqFreeBandwidthInfo();
       DWORD AtqBandwidthSetInfo();
--*/

#include "isatq.hxx"
#include <iscaptrc.h>

# define ATQ_REG_DEF_THREAD_TIMEOUT_PWS    (30*60)  // 30 minutes

/************************************************************
 * Globals
 ************************************************************/

//
// specifies the registry location to use for getting the ATQ Configuration
//   (Global overrides)
//
CHAR g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY[] =
 TEXT("System\\CurrentControlSet\\Services\\InetInfo\\Parameters");

// ----------------------------------------
// # of CPUs in machine (for thread-tuning)
// ----------------------------------------

DWORD g_cCPU = 0;

//
// concurrent # of threads to run per processor
//

DWORD g_cConcurrency = ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY;

//
//  Amount of time (in ms) a worker thread will be idle before suicide
//

DWORD g_msThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT * 1000;

BOOL  g_fUseAcceptEx = TRUE;    // Use AcceptEx if available

//
// The absolute thread limit
//

LONG   g_cMaxThreadLimit = ATQ_REG_DEF_POOL_THREAD_LIMIT;

//
// Assumed minimum file transfer rate
//

DWORD g_cbMinKbSec = ATQ_REG_DEF_MIN_KB_SEC;

//
// number of active context list
//

DWORD g_dwNumContextLists = ATQ_NUM_CONTEXT_LIST;

/*
   g_pfnExitThreadCallback()
    This routine sets the callback routine to be called when one of the
    Atq threads exit so that thread state data can be cleaned up. Currently
    support is for a single routine. One way to support multiple routines would
    be for the caller to save the return value. Such an application would not
    be able to delete the "saved" callback routine.
 */
ATQ_THREAD_EXIT_CALLBACK g_pfnExitThreadCallback = NULL;

//
// mswsock entry points
//

HINSTANCE g_hMSWsock = NULL;
PFN_ACCEPTEX g_pfnAcceptEx = NULL;
PFN_GETACCEPTEXSOCKADDRS g_pfnGetAcceptExSockaddrs = NULL;
PFN_TRANSMITFILE g_pfnTransmitFile = NULL;
PFN_GET_QUEUED_COMPLETION_STATUS g_pfnGetQueuedCompletionStatus = NULL;
PFN_CREATE_COMPLETION_PORT g_pfnCreateCompletionPort = NULL;
PFN_CLOSE_COMPLETION_PORT  g_pfnCloseCompletionPort = NULL;
PFN_POST_COMPLETION_STATUS g_pfnPostCompletionStatus = NULL;

//
// NT specific
//

PFN_READ_DIR_CHANGES_W g_pfnReadDirChangesW = NULL;

// ------------------------------
// Current State Information
// ------------------------------


HANDLE  g_hCompPort = NULL;      // Handle for completion port
LONG    g_cThreads = 0;          // number of thread in the pool
LONG    g_cAvailableThreads = 0; // # of threads waiting on the port.

//
// Should we use the TF_USE_KERNEL_APC flag for TransmitFile
//

BOOL    g_fUseKernelApc = ATQ_REG_DEF_USE_KERNEL_APC;

//
// Current thread limit
//

LONG    g_cMaxThreads = ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS;

DWORD   g_cListenBacklog = ATQ_REG_DEF_LISTEN_BACKLOG;

BOOL    g_fShutdown = FALSE;   // if set, indicates that we are shutting down
                               // in that case, all threads should exit.

HANDLE  g_hShutdownEvent = NULL; // set when all running threads shutdown

BOOL    g_fEnableDebugThreads = FALSE;  // if TRUE, debug IO threads can be
                                       // created

BOOL    g_fCreateDebugThread = FALSE;  // set to TRUE to create a debug thread

// ------------------------------
// Bandwidth Throttling Info
// ------------------------------

PBANDWIDTH_INFO     g_pBandwidthInfo = NULL;

// ------------------------------
// Various State/Object Lists
// ------------------------------

//
// Used to switch context between lists
//

DWORD AtqGlobalContextCount = 0;

//
// List of active context
//

ATQ_CONTEXT_LISTHEAD AtqActiveContextList[ATQ_NUM_CONTEXT_LIST];

//
// List of Endpoints in ATQ - one per listen socket
//

LIST_ENTRY AtqEndpointList;
CRITICAL_SECTION AtqEndpointLock;

PALLOC_CACHE_HANDLER  g_pachAtqContexts;

#ifdef IIS_AUX_COUNTERS

LONG g_AuxCounters[NUM_AUX_COUNTERS];

#endif // IIS_AUX_COUNTERS

//
// Timeout before closing pending listens in case backlog is full
//

DWORD g_cForceTimeout;

//
// Flag enabling/disabling the backlog monitor
//

BOOL g_fDisableBacklogMonitor = FALSE;

// ------------------------------
// local to this module
// ------------------------------

LONG  sg_AtqInitializeCount = -1;
HANDLE g_hCapThread = NULL;

DWORD
I_AtqGetGlobalConfiguration(VOID);

DWORD
I_NumAtqEndpointsOpen(VOID);

DWORD
AtqDebugCreatorThread(
    LPDWORD                 param
);

//
// Capacity Planning variables
//

extern TRACEHANDLE      IISCapTraceRegistrationHandle;

//
// Ensure that initialization/termination don't happen at the same time
//

CRITICAL_SECTION        g_csInitTermLock;

/************************************************************
 * Functions
 ************************************************************/

BOOL
AtqInitialize(
    IN DWORD   dwFlags
    )
/*++
Routine Description:

    Initializes the ATQ package

Arguments:
    dwFlags - DWORD containing the flags for use to initialize ATQ library.
    This dword helps to shut off the unwanted flags.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

Note:
    As of 4/16/97 the pszRegKey that is sent is no more utilized.
    We always load the internal configuration parameters from
     one single registry entry specified by PSZ_ATQ_CONFIG_PARAMS_REG_KEY
    The parameter is left in the command line for compatibility
      with old callers :( - NYI: Need to change this.
--*/
{
    DWORD       i;
    DWORD       dwThreadID;

    DBGPRINTF(( DBG_CONTEXT, "AtqInitialize, %d, %x\n",
                sg_AtqInitializeCount, dwFlags));

    if ( InterlockedIncrement( &sg_AtqInitializeCount) != 0) {

        IF_DEBUG( API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqInitialize( %08x). ATQ is already initialized.\n",
                         dwFlags));
        }

        //
        // we are already initialized. Ignore the new registry settings
        //

        return ( TRUE);
    }

    EnterCriticalSection( &g_csInitTermLock );

    IF_DEBUG( API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize[%08x]. Initializing....\n",
                     dwFlags));
    }

    // get the number of processors for this machine
    // do it only for NT Server only (don't scale workstation)
    if ( TsIsNtServer() ) {
        SYSTEM_INFO si;
        GetSystemInfo( &si );
        g_cCPU = si.dwNumberOfProcessors;
    } else {
        g_cCPU = 1;
    }

    //
    // Initialize context lists and crit sects
    //

    ATQ_CONTEXT_LISTHEAD * pacl;

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        pacl->Initialize();
    }

    InitializeListHead( &AtqEndpointList );

    //
    // init bandwidth throttling
    //

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwInitialize() );

    //
    //  Read registry configurable Atq options.  We have to read these now
    //  because concurrency is set for the completion port at creation time.
    //

    DWORD dwError = I_AtqGetGlobalConfiguration();

    if ( NO_ERROR != dwError) {
        SetLastError( dwError );
        goto cleanup;
    }

    //
    // Setup an allocation cache for the ATQ Contexts
    // NYI: Auto-tune the threshold limit
    //

    {
        ALLOC_CACHE_CONFIGURATION acConfig;

        DWORD nCachedAtq = ATQ_CACHE_LIMIT_NTS;

        acConfig.nConcurrency = 1;
        acConfig.nThreshold = nCachedAtq;
        acConfig.cbSize = sizeof(ATQ_CONTEXT);

        g_pachAtqContexts = new ALLOC_CACHE_HANDLER( "ATQ", &acConfig);

        if ( NULL == g_pachAtqContexts) {
            goto cleanup;
        }
    }


    //
    //  Create the shutdown event
    //

    g_hShutdownEvent = IIS_CREATE_EVENT(
                           "g_hShutdownEvent",
                           &g_hShutdownEvent,
                           TRUE,        // Manual reset
                           FALSE        // Not signalled
                           );

    if ( !g_hShutdownEvent ) {

        DBGERROR(( DBG_CONTEXT, "Create Shutdown event failed. Last Error = 0x%x\n",
                    GetLastError()
                  ));

        goto cleanup;
    }

    //
    //  Create the completion port
    //

    g_hCompPort = g_pfnCreateCompletionPort(INVALID_HANDLE_VALUE,
                                            NULL,
                                            0,
                                            g_cConcurrency
                                            );

    if ( !g_hCompPort ) {

        DBGERROR(( DBG_CONTEXT, "Create IoComp port failed. Last Error = 0x%x\n",
                    GetLastError()
                  ));
        goto cleanup;
    }

    //
    // Initialize Backlog Monitor
    //

    if ( !g_fDisableBacklogMonitor )
    {
        DBG_ASSERT( g_pAtqBacklogMonitor == NULL );
        g_pAtqBacklogMonitor = new ATQ_BACKLOG_MONITOR;
        if (!g_pAtqBacklogMonitor) {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto cleanup;
        }
    }

    //
    // Ensure all other initializations also are done
    //

    g_cThreads  = 0;
    g_fShutdown = FALSE;
    g_cAvailableThreads = 0;

    if ( !I_AtqStartTimeoutProcessing( NULL ) ) {
        goto cleanup;
    }

    IF_DEBUG(INIT_CLEAN) {
        DBGPRINTF(( DBG_CONTEXT,
                    "fUseAcceptEx[%d] NT CompPort[1] Platform[%d]\n",
                    g_fUseAcceptEx,
                    IISPlatformType()
                    ));
    }

    //
    // Create the initial ATQ thread.
    //

    (VOID)I_AtqCheckThreadStatus( (PVOID)ATQ_INITIAL_THREAD );

    //
    // Create a second thread if we are NTS
    //

    if ( TsIsNtServer() ) {
        (VOID)I_AtqCheckThreadStatus( (PVOID)ATQ_INITIAL_THREAD );
    }

    //
    // Initialize Capacity Planning Trace
    //
    // Spawn another thread to do this since IISInitializeCapTrace() can
    // take a while and we are not in a state where SCM is getting
    // SERVICE_STARTING messages
    //

    g_hCapThread = CreateThread( NULL,
                                 0,
                                 IISInitializeCapTrace,
                                 NULL,
                                 0,
                                 &dwThreadID
                                 );

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, TRUE));
    }

    //
    // Create the debug thread starter if necessary
    //

    if ( g_fEnableDebugThreads )
    {
        DWORD                   dwError;
        DWORD                   dwThreadID;
        HANDLE                  hThread;

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqDebugCreatorThread,
                                NULL,
                                0,
                                &dwThreadID );
        if ( !hThread )
        {
            goto cleanup;
        }
        CloseHandle( hThread );
    }

    LeaveCriticalSection( &g_csInitTermLock );

    return TRUE;

cleanup:
    DWORD dwSaveError = GetLastError();

    for (i=0; i<g_dwNumContextLists; i++) {

        AtqActiveContextList[i].Cleanup();
    }

    if ( g_hShutdownEvent != NULL ) {
        CloseHandle( g_hShutdownEvent );
        g_hShutdownEvent = NULL;
    }

    if ( g_hCompPort != NULL ) {
        g_pfnCloseCompletionPort( g_hCompPort );
        g_hCompPort = NULL;
    }

    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    if ( NULL != g_pAtqBacklogMonitor ) {
        delete g_pAtqBacklogMonitor;
        g_pAtqBacklogMonitor = NULL;
    }

    ATQ_REQUIRE( BANDWIDTH_INFO::AbwTerminate());

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqInitialize( %08x) returns %d.\n",
                     dwFlags, FALSE));
    }

    sg_AtqInitializeCount = -1;

    SetLastError(dwSaveError);

    LeaveCriticalSection( &g_csInitTermLock );

    return(FALSE);

} // AtqInitialize()





BOOL
AtqTerminate(
    VOID
    )
/*++

Routine Description:

    Cleans up the ATQ package.  Should only be called after all of the
    clients of ATQ have been shutdown.

Arguments:

    None.

Return Value:

    TRUE, if ATQ was shutdown properly
    FALSE, otherwise

--*/
{
    DBGPRINTF(( DBG_CONTEXT, "AtqTerminate, %d\n", sg_AtqInitializeCount));

    DWORD       currentThreadCount;
    ATQ_CONTEXT_LISTHEAD * pacl;
    BOOL        fRet = TRUE;
    DWORD       dwErr;

    // there are outstanding users, don't fully terminate
    if ( InterlockedDecrement( &sg_AtqInitializeCount) >= 0) {

        /*IF_DEBUG( API_ENTRY)*/ {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqTerminate() - there are other users."
                         " Not terminating now\n"
                         ));
        }
        return (TRUE);
    }

    EnterCriticalSection( &g_csInitTermLock );

    /*IF_DEBUG( API_ENTRY)*/ {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Terminating ATQ ...\n"
                     ));
    }


    //
    // All the ATQ endpoints should have been terminated before calling
    //  this ATQTerminate() function. If not, sorry return failure.
    //
    DWORD nEndpointsToBeClosed = I_NumAtqEndpointsOpen();

    if ( nEndpointsToBeClosed > 0) {

        DBGPRINTF(( DBG_CONTEXT,
                    " There are %d endpoints remaining to be closed."
                    " Somebody above stream did not close endpoints."
                    " BUG IN CODE ABOVE ATQ\n"
                    ,
                    nEndpointsToBeClosed
                    ));
        SetLastError( ERROR_NETWORK_BUSY);
        fRet = FALSE;
        goto Finished;
    }


    if ( (g_hShutdownEvent == NULL) || g_fShutdown ) {

        //
        // We have not been intialized or have already terminated.
        //
        SetLastError( ERROR_NOT_READY );
        fRet = FALSE;
        goto Finished;
    }

    //
    // All clients should have cleaned themselves up before calling us.
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {

        pacl->Lock();

        if ( !IsListEmpty(&pacl->ActiveListHead)) {

            ATQ_ASSERT( IsListEmpty( &pacl->ActiveListHead));
            pacl->Unlock();

            IF_DEBUG( API_EXIT) {
                ATQ_PRINTF(( DBG_CONTEXT,
                             "AtqTerminate() - ContextList(%08x) has "
                             "Active Contexts. Failed Termination.\n",
                             pacl
                             ));
            }

            fRet = FALSE;
            goto Finished;
        }

        pacl->Unlock();
    } // for

    //
    // Note that we are shutting down and prevent any more handles from
    // being added to the completion port.
    //

    g_fShutdown = TRUE;

    //
    // Attempt and remove the TimeOut Context from scheduler queue
    //
    DBG_REQUIRE( I_AtqStopTimeoutProcessing());

    currentThreadCount = g_cThreads;
    if (currentThreadCount > 0) {

        DWORD       i;
        BOOL        fRes;
        OVERLAPPED  overlapped;

        //
        // Post a message to the completion port for each worker thread
        // telling it to exit. The indicator is a NULL context in the
        // completion.
        //

        ZeroMemory( &overlapped, sizeof(OVERLAPPED) );

        for (i=0; i<currentThreadCount; i++) {

            fRes = g_pfnPostCompletionStatus( g_hCompPort,
                                              0,
                                              0,
                                              &overlapped );

            ATQ_ASSERT( (fRes == TRUE) ||
                       ( (fRes == FALSE) &&
                        (GetLastError() == ERROR_IO_PENDING) )
                       );
        }
    }

    //
    // Now wait for the pool threads to shutdown.
    //

    dwErr = WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
#if 0
    DWORD dwWaitCount = 0;
    while ( dwErr == WAIT_TIMEOUT) {

        dwWaitCount++;
        DebugBreak();
        Sleep( 10*1000);  // sleep for some time
        dwErr =
            WaitForSingleObject( g_hShutdownEvent, ATQ_WAIT_FOR_THREAD_DEATH);
    } // while
# endif // 0

    //
    // At this point, no other threads should be left running.
    //
    //
    //  g_cThreads counter is decremented by AtqPoolThread().
    //  AtqTerminate() is called during the DLL termination
    //  But at DLL termination, all ATQ pool threads are killed =>
    //    no one is decrementing the count. Hence this assert will always fail.
    //

    // ATQ_ASSERT( !g_cThreads );

    ATQ_REQUIRE( CloseHandle( g_hShutdownEvent ) );
    g_pfnCloseCompletionPort( g_hCompPort );

    g_hShutdownEvent = NULL;
    g_hCompPort = NULL;

    //
    // Cleanup our synchronization resources
    //

    for ( pacl = AtqActiveContextList;
          pacl < (AtqActiveContextList + g_dwNumContextLists);
          pacl++) {
        PLIST_ENTRY pEntry;

        pacl->Lock();

        if ( !IsListEmpty( &pacl->PendingAcceptExListHead)) {
            for ( pEntry = pacl->PendingAcceptExListHead.Flink;
                  pEntry != &pacl->PendingAcceptExListHead;
                  pEntry  = pEntry->Flink ) {

                PATQ_CONT pContext =
                    CONTAINING_RECORD( pEntry, ATQ_CONTEXT, m_leTimeout );

                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                pContext->Print();
            } // for
        }

        pacl->Unlock();
        pacl->Cleanup();
    }


    //
    // Free all the elements in the Allocation caching list
    //
    if ( NULL != g_pachAtqContexts) {
        delete g_pachAtqContexts;
        g_pachAtqContexts = NULL;
    }

    if ( g_hCapThread )
    {
        WaitForSingleObject( g_hCapThread, INFINITE );
        CloseHandle( g_hCapThread );
        g_hCapThread = NULL;

        if (IISCapTraceRegistrationHandle != (TRACEHANDLE)0)
        {
            UnregisterTraceGuids( IISCapTraceRegistrationHandle );
        }

    }

    //
    // cleanup backlog monitor
    //
    delete g_pAtqBacklogMonitor;
    g_pAtqBacklogMonitor = NULL;

    // Cleanup variables in ATQ Bandwidth throttle module
    if ( !BANDWIDTH_INFO::AbwTerminate()) {

        // there may be a few blocked IO. We should avoid them all.
        // All clients should have cleaned themselves up before coming here.

        fRet = FALSE;
        goto Finished;
    }

    if ( g_hMSWsock != NULL ) {
        FreeLibrary(g_hMSWsock);
        g_hMSWsock = NULL;
    }

    IF_DEBUG( API_EXIT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "AtqTerminate() - Successfully cleaned up.\n"
                     ));
    }

Finished:

    LeaveCriticalSection( &g_csInitTermLock );

    return fRet;
} // AtqTerminate()



HANDLE
AtqGetCompletionPort()
/*++

Routine Description:

    Return the completion port created by ATQ

Arguments:

Return Value:

    Handle to ATQ completion port

--*/
{
    return g_hCompPort;
} // AtqGetCompletionPort()


ULONG_PTR
AtqSetInfo(
    IN ATQ_INFO         atqInfo,
    IN ULONG_PTR         Data
    )
/*++

Routine Description:

    Sets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    ULONG_PTR oldVal = 0;

    switch ( atqInfo ) {

    case AtqBandwidthThrottle:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        oldVal = (ULONG_PTR)g_pBandwidthInfo->SetBandwidthLevel( (DWORD)Data );
        break;

    case AtqBandwidthThrottleMaxBlocked:

        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        oldVal = (ULONG_PTR)g_pBandwidthInfo->SetMaxBlockedListSize( (DWORD)Data );
        break;

    case AtqExitThreadCallback:

        oldVal = (ULONG_PTR)g_pfnExitThreadCallback;
        g_pfnExitThreadCallback =  (ATQ_THREAD_EXIT_CALLBACK ) Data;
        break;

    case AtqMaxPoolThreads:
          // the value is per processor values
        // internally we maintain value for all processors
        oldVal = (ULONG_PTR)( g_cMaxThreads/g_cCPU );
        g_cMaxThreads = (DWORD)Data * g_cCPU;
        break;

      //
      //  Increment or decrement the max thread count.  In this instance, we
      //  do not scale by the number of CPUs
      //

      case AtqIncMaxPoolThreads:
        InterlockedIncrement( (LONG *) &g_cMaxThreads );
        oldVal = TRUE;
        break;

      case AtqDecMaxPoolThreads:
        InterlockedDecrement( (LONG *) &g_cMaxThreads );
        oldVal = TRUE;
        break;

      case AtqMaxConcurrency:
        oldVal = (ULONG_PTR)g_cConcurrency;
        g_cConcurrency = (DWORD)Data;
        break;

      case AtqThreadTimeout:
        oldVal = (ULONG_PTR)(g_msThreadTimeout/1000); // convert back to seconds
        g_msThreadTimeout = (DWORD)Data * 1000;      // convert value to millisecs
        break;

      case AtqUseAcceptEx:
        oldVal = (ULONG_PTR)g_fUseAcceptEx;
        g_fUseAcceptEx = (DWORD)Data;
        break;

      case AtqMinKbSec:

        //
        //  Ignore it if the value is zero
        //

        if ( Data ) {
            oldVal = (ULONG_PTR)g_cbMinKbSec;
            g_cbMinKbSec = (DWORD)Data;
        }
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    }

    return oldVal;

} // AtqSetInfo()





ULONG_PTR
AtqGetInfo(
    IN ATQ_INFO  atqInfo
    )
/*++

Routine Description:

    Gets various bits of information for the ATQ module

Arguments:

    atqInfo     - Data item to set

Return Value:

    The old value of the parameter

--*/
{
    ULONG_PTR dwVal = 0;

    switch ( atqInfo ) {

      case AtqBandwidthThrottle:
        ATQ_ASSERT( g_pBandwidthInfo != NULL );
        dwVal = (ULONG_PTR ) g_pBandwidthInfo->QueryBandwidthLevel();
        break;

      case AtqExitThreadCallback:

        dwVal = (ULONG_PTR ) g_pfnExitThreadCallback;
        break;

      case AtqMaxPoolThreads:
        dwVal = (ULONG_PTR ) (g_cMaxThreads/g_cCPU);
        break;

      case AtqMaxConcurrency:
        dwVal = (ULONG_PTR ) g_cConcurrency;
        break;

      case AtqThreadTimeout:
        dwVal = (ULONG_PTR ) (g_msThreadTimeout/1000); // convert back to seconds
        break;

      case AtqUseAcceptEx:
        dwVal = (ULONG_PTR ) g_fUseAcceptEx;
        break;

      case AtqMinKbSec:
        dwVal = (ULONG_PTR ) g_cbMinKbSec;
        break;

      case AtqMaxThreadLimit:
        dwVal = (ULONG_PTR ) g_cMaxThreadLimit;
        break;

      case AtqAvailableThreads:
        dwVal = (ULONG_PTR)  g_cAvailableThreads;
        break;

      default:
        ATQ_ASSERT( FALSE );
        break;
    } // switch

    return dwVal;
} // AtqGetInfo()





BOOL
AtqGetStatistics(IN OUT ATQ_STATISTICS * pAtqStats)
{
    if ( pAtqStats != NULL) {

        return g_pBandwidthInfo->GetStatistics( pAtqStats );

    } else {

        SetLastError( ERROR_INVALID_PARAMETER);
        return (FALSE);
    }
} // AtqGetStatistics()





BOOL
AtqClearStatistics( VOID)
{
    return g_pBandwidthInfo->ClearStatistics();

} // AtqClearStatistics()





ULONG_PTR
AtqContextSetInfo(
    PATQ_CONTEXT           patqContext,
    enum ATQ_CONTEXT_INFO  atqInfo,
    ULONG_PTR               Data
    )
/*++

Routine Description:

    Sets various bits of information for this context

Arguments:

    patqContext - pointer to ATQ context
    atqInfo     - Data item to set
    data        - New value for item

Return Value:

    The old value of the parameter

--*/
{
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    ULONG_PTR  OldVal = 0;

    ATQ_ASSERT( pContext );
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

    if ( pContext && pContext->Signature == ATQ_CONTEXT_SIGNATURE )
    {
        switch ( atqInfo ) {

        case ATQ_INFO_TIMEOUT:
            OldVal = (ULONG_PTR)pContext->TimeOut;
            pContext->TimeOut = CanonTimeout( (DWORD)Data );
            break;

        case ATQ_INFO_RESUME_IO:

            //
            // set back the max timeout from pContext->TimeOut
            // This will ensure that timeout processing can go on
            //   peacefully.
            //

            {
                DWORD currentTime = AtqGetCurrentTick( );
                DWORD timeout;
                OldVal = (ULONG_PTR)pContext->NextTimeout;
                timeout = pContext->TimeOut;

                //
                // Set the new timeout
                //

                I_SetNextTimeout(pContext);

                //
                // Return the old
                //

                if ( currentTime >= (DWORD)OldVal ) {
                    ATQ_ASSERT((OldVal & ATQ_INFINITE) == 0);
                    OldVal = 0;
                } else if ( (OldVal & ATQ_INFINITE) == 0 ) {
                    OldVal -= currentTime;
                }

                // return correct units
                OldVal = (ULONG_PTR)UndoCanonTimeout( (DWORD)OldVal );
            }
            break;

        case ATQ_INFO_COMPLETION:
            OldVal = (ULONG_PTR)pContext->pfnCompletion;
            pContext->pfnCompletion = (ATQ_COMPLETION) Data;
            break;

        case ATQ_INFO_COMPLETION_CONTEXT:

            ATQ_ASSERT( Data != 0 );        // NULL context not allowed

            OldVal = (ULONG_PTR)pContext->ClientContext;
            pContext->ClientContext = (void *) Data;
            break;

        case ATQ_INFO_BANDWIDTH_INFO:
        {
            ATQ_ASSERT( Data != 0 );

            PBANDWIDTH_INFO pBandwidthInfo = (PBANDWIDTH_INFO) Data;

            ATQ_ASSERT( pBandwidthInfo->QuerySignature() ==
                                                ATQ_BW_INFO_SIGNATURE );

            if ( !pBandwidthInfo->IsFreed() )
            {
                pContext->m_pBandwidthInfo = (PBANDWIDTH_INFO) Data;
                pContext->m_pBandwidthInfo->Reference();
            }
            break;
        }

        case ATQ_INFO_ABORTIVE_CLOSE:
            OldVal = (ULONG_PTR)pContext->IsFlag( ACF_ABORTIVE_CLOSE );
            if ( Data )
            {
                pContext->SetFlag( ACF_ABORTIVE_CLOSE );
            }
            else
            {
                pContext->ResetFlag( ACF_ABORTIVE_CLOSE );
            }
            break;

        case ATQ_INFO_FORCE_CLOSE:
            OldVal = (ULONG_PTR)pContext->ForceClose();
            pContext->SetForceClose( Data ? TRUE : FALSE );
            break;

        case ATQ_INFO_SET_OVL_OFFSET:
            OldVal = 0;
            pContext->Overlapped.Offset = ((LARGE_INTEGER*)Data)->LowPart;
            pContext->Overlapped.OffsetHigh = ((LARGE_INTEGER*)Data)->HighPart;
            break;

        default:
            ATQ_ASSERT( FALSE );
        }
    }

    return OldVal;

} // AtqContextSetInfo()



BOOL
AtqAddAsyncHandle(
    PATQ_CONTEXT * ppatqContext,
    PVOID          EndpointObject,
    PVOID          ClientContext,
    ATQ_COMPLETION pfnCompletion,
    DWORD          TimeOut,
    HANDLE         hAsyncIO
    )
/*++

Routine Description:

    Adds a handle to the thread queue

    The client should call this after the IO handle is opened
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

Arguments:

    ppatqContext - Receives allocated ATQ Context
    Context - Context to call client with
    pfnCompletion - Completion to call when IO completes
    TimeOut - Time to wait (sec) for IO completion (INFINITE is valid)
    hAsyncIO - Handle with pending read or write

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    return ( I_AtqAddAsyncHandle( (PATQ_CONT *) ppatqContext,
                                  (PATQ_ENDPOINT) EndpointObject,
                                  ClientContext,
                                  pfnCompletion,
                                  TimeOut,
                                  hAsyncIO)
             &&
             I_AddAtqContextToPort( *((PATQ_CONT *) ppatqContext))
            );

} // AtqAddAsyncHandle()




VOID
AtqGetAcceptExAddrs(
    IN  PATQ_CONTEXT patqContext,
    OUT SOCKET *     pSock,
    OUT PVOID *      ppvBuff,
    OUT PVOID *      pEndpointContext,
    OUT SOCKADDR * * ppsockaddrLocal,
    OUT SOCKADDR * * ppsockaddrRemote
    )
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    INT       cbsockaddrLocal;
    INT       cbsockaddrRemote;
    DWORD     cb;

    ATQ_ASSERT( g_fUseAcceptEx);
    ATQ_ASSERT( pContext->pEndpoint);

    *pSock   = HANDLE_TO_SOCKET(pContext->hAsyncIO);
    *pEndpointContext = pContext->pEndpoint->Context;

    //
    //  The buffer not only receives the initial received data, it also
    //  gets the sock addrs, which must be at least sockaddr_in + 16 bytes
    //  large
    //

    g_pfnGetAcceptExSockaddrs( pContext->pvBuff,
                               (cb = pContext->pEndpoint->InitialRecvSize),
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               ppsockaddrLocal,
                               &cbsockaddrLocal,
                               ppsockaddrRemote,
                               &cbsockaddrRemote );

    *ppvBuff = ( ( cb == 0) ? NULL : pContext->pvBuff);

    return;
} // AtqGetAcceptExAddrs()




BOOL
AtqCloseSocket(
    PATQ_CONTEXT patqContext,
    BOOL         fShutdown
    )
/*++

  Routine Description:

    Closes the socket in this atq structure if it wasn't
    closed by transmitfile. This function should be called only
    if the embedded handle in AtqContext is a Socket.

  Arguments:

    patqContext - Context whose socket should be closed.
    fShutdown - If TRUE, means we call shutdown and always close the socket.
        Note that if TransmitFile closed the socket, it will have done the
        shutdown for us

  Returns:
    TRUE on success and FALSE if there is a failure.
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        BOOL fAbortiveClose;

        fAbortiveClose = pContext->IsFlag( ACF_ABORTIVE_CLOSE );
        pContext->ResetFlag( ACF_ABORTIVE_CLOSE );

        //
        //  Don't delete the socket if we don't have to
        //

        if ( pContext->IsState( ACS_SOCK_UNCONNECTED |
                                ACS_SOCK_CLOSED) &&
             !pContext->ForceClose()
             ) {

            //
            //  Do nothing
            //

        } else {

            // default:
            // case ACS_SOCK_LISTENING:
            // case ACS_SOCK_CONNECTED: {

            HANDLE hIO;
            PATQ_ENDPOINT pEndpoint;

            pEndpoint = pContext->pEndpoint;

            pContext->MoveState( ACS_SOCK_CLOSED);

            //
            //  During shutdown, the socket may be closed while this thread
            //  is doing processing, so only give a warning if any of the
            //  following fail
            //

            hIO = (HANDLE )InterlockedExchangePointer(
                               (PVOID *)&pContext->hAsyncIO,
                               NULL
                               );

            if ( hIO == NULL ) {

                //
                // No socket - it is already closed - do nothing.
                //

            } else {

                if (fAbortiveClose || fShutdown ) {

                    //
                    //  If this is an AcceptEx socket, we must first force a
                    //  user mode context update before we can call shutdown
                    //

                    if ( (pEndpoint != NULL) && (pEndpoint->UseAcceptEx) ) {

                        if ( setsockopt( HANDLE_TO_SOCKET(hIO),
                                         SOL_SOCKET,
                                         SO_UPDATE_ACCEPT_CONTEXT,
                                         (char *) &pEndpoint->ListenSocket,
                                         sizeof(SOCKET) ) == SOCKET_ERROR ) {

                            ATQ_PRINTF(( DBG_CONTEXT,
                                         "[AtqCloseSocket] Warning- setsockopt "
                                         "failed, error %d, socket = %x,"
                                         " Context= %08x, Listen = %lx\n",
                                         GetLastError(),
                                         hIO,
                                         pContext,
                                         pEndpoint->ListenSocket ));
                        }
                    }
                } // setsock-opt call

                if ( fAbortiveClose ) {
                    LINGER  linger;

                    linger.l_onoff = TRUE;
                    linger.l_linger = 0;

                    if ( setsockopt( HANDLE_TO_SOCKET(hIO),
                                     SOL_SOCKET,
                                     SO_LINGER,
                                     (char *) &linger,
                                     sizeof(linger) ) == SOCKET_ERROR
                         ) {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket] Warning- setsockopt "
                                     "failed, error %d, socket = %x,"
                                     " Context= %08x, Listen = %lx\n",
                                     GetLastError(),
                                     hIO,
                                     pContext,
                                     pEndpoint->ListenSocket ));
                    }
                    else {
                        ATQ_PRINTF(( DBG_CONTEXT,
                                     "[AtqCloseSocket(%08x)] requested"
                                     " abortive close\n",
                                     pContext));
                    }
                } // set up linger

                if ( fShutdown ) {

                    //
                    //  Note that shutdown can fail in instances where the
                    //  client aborts in the middle of a TransmitFile.
                    //  This is an acceptable failure case
                    //

                    shutdown( HANDLE_TO_SOCKET(hIO), 1 );
                }

                DBG_ASSERT( hIO != NULL);

                if ( closesocket( HANDLE_TO_SOCKET(hIO) ) ) {

                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[AtqCloseSocket] Warning- closesocket "
                                 " failed, Context = %08x, error %d,"
                                 " socket = %x\n",
                                 pContext,
                                 GetLastError(),
                                 hIO ));
                }
            } // if (hIO != NULL)
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseSocket()



BOOL
AtqCloseFileHandle(
    PATQ_CONTEXT patqContext
    )
/*++

  Routine Description:

    Closes the file handle in this atq structure.
    This function should be called only if the embedded handle
    in AtqContext is a file handle.

  Arguments:

    patqContext - Context whose file handle should be closed.

  Returns:
    TRUE on success and FALSE if there is a failure.

  Note:
   THIS FUNCTIONALITY IS ADDED TO SERVE A SPECIAL REQUEST!!!
   Most of the ATQ code thinks that the handle here is a socket.
   Except of course this function...
--*/
{
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    if ( pContext != NULL ) {

        HANDLE hIO;

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
        ATQ_ASSERT( !pContext->IsAcceptExRootContext());

        hIO =
          (HANDLE ) InterlockedExchangePointer(
                        (PVOID *)&pContext->hAsyncIO,
                        NULL
                        );

        if ( (hIO == NULL) || !CloseHandle( hIO ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqCloseFileHandle] Warning- CloseHandle failed, "
                        " Context = %08x, error %d, handle = %x\n",
                        pContext,
                        GetLastError(),
                        hIO ));
        }

        return TRUE;
    }

    DBGPRINTF(( DBG_CONTEXT, "[AtqCloseSocket] Warning - NULL Atq context\n"));
    SetLastError( ERROR_INVALID_PARAMETER );
    return FALSE;
} // AtqCloseFileHandle()





VOID
AtqFreeContext(
    PATQ_CONTEXT patqContext,
    BOOL         fReuseContext
    )
/*++

Routine Description:

    Frees the context created in AtqAddAsyncHandle.
    Call this after the async handle has been closed and all outstanding
    IO operations have been completed. The context is invalid after this call.
    Call AtqFreeContext() for same context only ONCE.

Arguments:

    patqContext - Context to free
    fReuseContext - TRUE if this can context can be reused in the context of
        the calling thread.  Should be FALSE if the calling thread will exit
        soon (i.e., isn't an AtqPoolThread).

--*/
{
    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    IF_DEBUG( API_ENTRY) {

        ATQ_PRINTF(( DBG_CONTEXT, "AtqFreeContext( %08x (handle=%08x,"
                     " nIOs = %d), fReuse=%d)\n",
                     patqContext, patqContext->hAsyncIO,
                     pContext->m_nIO,
                     fReuseContext));
    }

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        if ( fReuseContext ) {
            pContext->SetFlag( ACF_REUSE_CONTEXT);
        } else {
            pContext->ResetFlag( ACF_REUSE_CONTEXT);
        }

        if ( InterlockedDecrement(  &pContext->m_nIO) == 0) {

            //
            // The number of outstanding ref holders is ZERO.
            // Free up this ATQ context.
            //
            // We really do not free up the context - but try to reuse
            //  it if possible
            //

            DBG_ASSERT( pContext->lSyncTimeout == 0);
            AtqpReuseOrFreeContext( pContext, fReuseContext);
        }
    }

    return;
} // AtqFreeContext()



BOOL
AtqReadFile(
        IN PATQ_CONTEXT patqContext,
        IN LPVOID       lpBuffer,
        IN DWORD        BytesToRead,
        IN OVERLAPPED * lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async read using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoRead ) ) {

      case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( ReadFile( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          &cbRead,
                          lpo ) ||
                GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

      case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoRead;
        pContext->arInfo.lpOverlapped = lpo;
        pContext->arInfo.uop.opReadWrite.buf1.len = BytesToRead;
        pContext->arInfo.uop.opReadWrite.buf1.buf = (CHAR * ) lpBuffer;
        pContext->arInfo.uop.opReadWrite.dwBufferCount = 1;
        pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext );
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

      default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqReadFile()



BOOL
AtqReadSocket(
        IN PATQ_CONTEXT  patqContext,
        IN LPWSABUF     pwsaBuffers,
        IN DWORD        dwBufferCount,
        IN OVERLAPPED *  lpo OPTIONAL
        )
/*++

  Routine Description:

    Does an async recv using the handle defined in the context
     as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to put read data in
    BytesToRead - number of bytes to read
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqReadSocket(%08lx) called.\n", pContext));
    }

    if (pContext->IsFlag( ACF_RECV_ISSUED)) {
        pContext->BytesSent = 0;
        pContext->SetFlag( ACF_RECV_CALLED);

#if CC_REF_TRACKING
            //
            // ATQ notification trace
            //
            // Notify client context of all non-oplock notification.
            // This is for debugging purpose only.
            //
            // Code 0xf9f9f9f9 indicates a ACF_RECV_CALLED is set in the flags field
            //

            pContext->NotifyIOCompletion( (ULONG_PTR)pContext, pContext->m_acFlags, 0xf9f9f9f9 );
#endif

        return TRUE;
    }

    I_SetNextTimeout(pContext);


    // count the number of bytes
    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    //
    // NYI: Create an optimal function table
    //
    switch ( pBandwidthInfo->QueryStatus( AtqIoRead ) ) {

    case StatusAllowOperation:
        {
            DWORD  dwFlags = 0;

            fRes = ( (WSARecv( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                               pwsaBuffers,
                               dwBufferCount,
                               &cbRead,
                               &dwFlags,  // no flags
                               lpo,
                               NULL       // no completion routine
                               ) == 0) ||
                     (WSAGetLastError() == WSA_IO_PENDING));
            if (!fRes) { InterlockedDecrement( &pContext->m_nIO); }
        }

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoRead;
        pContext->arInfo.lpOverlapped = lpo;

        pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;
        if ( dwBufferCount == 1) {
            pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
            pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
            pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;
        } else {
            DBG_ASSERT( dwBufferCount > 1);

            //
            // Inefficient: But we will burn CPU for b/w throttling.
            //
            WSABUF * pBuf = (WSABUF *)
                ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
                CopyMemory( pBuf, pwsaBuffers,
                            dwBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext );
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;
    } // switch()

    return fRes;
} // AtqReadSocket()



BOOL
AtqWriteFile(
    IN PATQ_CONTEXT patqContext,
    IN LPCVOID      lpBuffer,
    IN DWORD        BytesToWrite,
    IN OVERLAPPED * lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    lpBuffer - Buffer to write
    BytesToWrite - number of bytes to write
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);
    pContext->BytesSent = BytesToWrite;

    if ( !lpo ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoWrite) ) {

      case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( WriteFile( pContext->hAsyncIO,
                            lpBuffer,
                            BytesToWrite,
                            &cbWritten,
                            lpo ) ||
                 GetLastError() == ERROR_IO_PENDING);
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

      case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoWrite;
        pContext->arInfo.lpOverlapped = lpo;

        pContext->arInfo.uop.opReadWrite.buf1.len = BytesToWrite;
        pContext->arInfo.uop.opReadWrite.buf1.buf = (CHAR * ) lpBuffer;
        pContext->arInfo.uop.opReadWrite.dwBufferCount = 1;
        pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext );
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqWriteFile()



BOOL
AtqWriteSocket(
    IN PATQ_CONTEXT  patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    IN OVERLAPPED *  lpo OPTIONAL
    )
/*++

  Routine Description:

    Does an async write using the handle defined in the context as a socket.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    lpo - Overlapped structure to use

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    DWORD cbWritten; // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent = pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf < (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( lpo == NULL ) {
        lpo = &pContext->Overlapped;
    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoWrite ) ) {

    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = ( (WSASend( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                           pwsaBuffers,
                           dwBufferCount,
                           &cbWritten,
                           0,               // no flags
                           lpo,
                           NULL             // no completion routine
                           ) == 0) ||
                 (WSAGetLastError() == WSA_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); }
        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoWrite;
        pContext->arInfo.lpOverlapped = lpo;

        pContext->arInfo.uop.opReadWrite.dwBufferCount = dwBufferCount;
        if ( dwBufferCount == 1) {
            pContext->arInfo.uop.opReadWrite.buf1.len = pwsaBuffers->len;
            pContext->arInfo.uop.opReadWrite.buf1.buf = pwsaBuffers->buf;
            pContext->arInfo.uop.opReadWrite.pBufAll  = NULL;
        } else {
            DBG_ASSERT( dwBufferCount > 1);

            //
            // Inefficient: But we will burn CPU for b/w throttling.
            //
            WSABUF * pBuf = (WSABUF *)
                ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opReadWrite.pBufAll = pBuf;
                CopyMemory( pBuf, pwsaBuffers,
                            dwBufferCount * sizeof(WSABUF));
            } else {
                InterlockedDecrement( &pContext->m_nIO);
                fRes = FALSE;
                break;
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext );
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqWriteSocket()




BOOL
AtqSyncWsaSend(
    IN  PATQ_CONTEXT patqContext,
    IN  LPWSABUF     pwsaBuffers,
    IN  DWORD        dwBufferCount,
    OUT LPDWORD      pcbWritten
    )
/*++

  Routine Description:

    Does a sync write of an array of wsa buffers using WSASend.

  Arguments:

    patqContext - pointer to ATQ context
    pwsaBuffer  - pointer to Winsock Buffers for scatter/gather
    dwBufferCount - DWORD containing the count of buffers pointed
                   to by pwsaBuffer
    pcbWritten - ptr to count of bytes written

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{

    BOOL fRes = FALSE;
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    fRes = ( WSASend(  HANDLE_TO_SOCKET(pContext->hAsyncIO),
                       pwsaBuffers,
                       dwBufferCount,
                       pcbWritten,
                       0,               // no flags
                       NULL,            // lpo == NULL for sync write
                       NULL             // no completion routine
                       ) == 0);

    return fRes;

} // AtqSyncWsaSend()




BOOL
AtqTransmitFile(
    IN PATQ_CONTEXT            patqContext,
    IN HANDLE                  hFile,
    IN DWORD                   dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD                   dwFlags
    )
/*++

  Routine Description:

    Does a TransmitFile  using the handle defined in the context.

  Arguments:

    patqContext - pointer to ATQ context
    hFile - handle of file to read from
    dwBytesInFile - Bytes to transmit
    lpTransmitBuffers - transmit buffer structure
    dwFlags - Transmit file flags

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    //
    //  For large file sends, the client's default timeout may not be
    //  adequte for slow links.  Scale based on bytes being sent
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = dwBytesInFile;

    if ( dwFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwFlags = TF_WRITE_BEHIND;

    } else if ( dwFlags & TF_DISCONNECT ) {

        //
        //  If the socket is getting disconnected, mark it appropriately
        //

        pContext->MoveState( ( ( dwFlags & TF_REUSE_SOCKET )?
                               ACS_SOCK_UNCONNECTED:
                               ACS_SOCK_CLOSED
                               )
                             );
    }

    //
    // Use kernel apc flag unless configured not to
    //
    if ( g_fUseKernelApc ) {
        dwFlags |= TF_USE_KERNEL_APC;
    }


    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFile ) ) {

    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = (g_pfnTransmitFile( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                                hFile,
                                dwBytesInFile,
                                0,
                                &pContext->Overlapped,
                                lpTransmitBuffers,
                                dwFlags ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); }

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoXmitFile;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;
        pContext->arInfo.uop.opXmit.hFile = hFile;
        pContext->arInfo.uop.opXmit.dwBytesInFile = dwBytesInFile;
        pContext->arInfo.uop.opXmit.lpXmitBuffers = lpTransmitBuffers;
        pContext->arInfo.uop.opXmit.dwFlags       = dwFlags;

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        InterlockedDecrement( &pContext->m_nIO);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    //
    //  Restore the socket state if we failed so that the handle gets freed
    //

    if ( !fRes )
    {
        pContext->MoveState( ACS_SOCK_CONNECTED);
    }

    return fRes;

} // AtqTransmitFile()


BOOL
AtqTransmitFileEx(
    IN PATQ_CONTEXT            patqContext,
    IN HANDLE                  hFile,
    IN DWORD                   dwBytesInFile,
    IN LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
    IN DWORD                   dwFlags,
    IN OVERLAPPED *            lpo
    )
/*++

  Routine Description:

    Does a TransmitFile  using the handle defined in the context.
    Uses the parameter lpo instead of the structure in the context.

  Arguments:

    patqContext - pointer to ATQ context
    hFile - handle of file to read from
    dwBytesInFile - Bytes to transmit
    lpTransmitBuffers - transmit buffer structure
    dwFlags - Transmit file flags
    lpo - overlapped structure

  Returns:
    TRUE on success and FALSE if there is a failure.

--*/
{
    BOOL fRes = TRUE;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    //
    //  For large file sends, the client's default timeout may not be
    //  adequte for slow links.  Scale based on bytes being sent
    //

    I_SetNextTimeout(pContext);
    pContext->BytesSent = dwBytesInFile;

    if ( dwFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwFlags = TF_WRITE_BEHIND;

    } else if ( dwFlags & TF_DISCONNECT ) {

        //
        //  If the socket is getting disconnected, mark it appropriately
        //

        pContext->MoveState( ( ( dwFlags & TF_REUSE_SOCKET )?
                               ACS_SOCK_UNCONNECTED:
                               ACS_SOCK_CLOSED
                               )
                             );
    }

    InterlockedIncrement( &pContext->m_nIO);

    if ( (StatusAllowOperation == pBandwidthInfo->QueryStatus( AtqIoXmitFile ) ) ) {

        pBandwidthInfo->IncTotalAllowedRequests();
        fRes = (g_pfnTransmitFile( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                                hFile,
                                dwBytesInFile,
                                0,
                                (lpo == NULL) ? &pContext->Overlapped : lpo,
                                lpTransmitBuffers,
                                dwFlags ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    } else {
        ASSERT(FALSE);
        fRes = FALSE;
    }

    //
    //  Restore the socket state if we failed so that the handle gets freed
    //

    if ( !fRes )
    {
        pContext->MoveState( ACS_SOCK_CONNECTED);
    }

    return fRes;

} // AtqTransmitFileEx()


BOOL
AtqReadDirChanges(IN PATQ_CONTEXT patqContext,
                  IN LPVOID       lpBuffer,
                  IN DWORD        BytesToRead,
                  IN BOOL         fWatchSubDir,
                  IN DWORD        dwNotifyFilter,
                  IN OVERLAPPED * lpo
                  )
/*++
  AtqReadDirChanges()

  Description:
    This function submits an Async ReadDirectoryChanges() call for
    the Async handle in the ATQ context supplied.
    It always requires a non-NULL overlapped pointer for processing
    this call.

  Arguments:
    patqContext  - pointer to ATQ Context
    lpBuffer     - buffer for the data to be read from ReadDirectoryChanges()
    BytesToRead  - count of bytes to read into buffer
    fWatchSubDir - should we watch for sub directory changes
    dwNotifyFilter - DWORD containing the flags for Notification
    lpo          - pointer to overlapped structure.

  Returns:
    TRUE if ReadDirectoryChanges() is successfully submitted.
    FALSE if there is any failure in submitting IO.
--*/
{
    BOOL fRes;
    DWORD cbRead;     // discarded after usage ( since this is Async)
    PATQ_CONT pContext = (PATQ_CONT ) patqContext;
    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);

    if ( g_pfnReadDirChangesW == NULL ) {
        ATQ_PRINTF((DBG_CONTEXT,"ReadDirChanges entry point NULL\n"));
        SetLastError(ERROR_NOT_SUPPORTED);
        return(FALSE);
    }

    if ( lpo == NULL ) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    I_SetNextTimeout(pContext);
    pContext->BytesSent = 0;

    InterlockedIncrement( &pContext->m_nIO);
    fRes = g_pfnReadDirChangesW( pContext->hAsyncIO,
                          lpBuffer,
                          BytesToRead,
                          fWatchSubDir,
                          dwNotifyFilter,
                          &cbRead,
                          lpo,
                          NULL);
    if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };
    return fRes;
} // AtqReadDirChanges()



BOOL
AtqPostCompletionStatus(
        IN PATQ_CONTEXT patqContext,
        IN DWORD        BytesTransferred
        )
/*++

Routine Description:

    Posts a completion status on the completion port queue

    An IO pending error code is treated as a success error code

Arguments:

    patqContext - pointer to ATQ context
    Everything else as in the Win32 API

    NOTES:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/

{
    BOOL fRes;
    PATQ_CONT  pAtqContext = (PATQ_CONT ) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    ATQ_ASSERT( (pAtqContext)->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !pAtqContext->IsBlocked()) {

        InterlockedIncrement( &pAtqContext->m_nIO);

        fRes = ( g_pfnPostCompletionStatus( g_hCompPort,
                                          BytesTransferred,
                                          (ULONG_PTR)patqContext,
                                          &pAtqContext->Overlapped ) ||
                (GetLastError() == ERROR_IO_PENDING));
        if (!fRes) { InterlockedDecrement( &pAtqContext->m_nIO); };
    } else {

        //
        // Forcibly remove the context from blocking list.
        //

        fRes = pBandwidthInfo->RemoveFromBlockedList(pAtqContext);

        // There is a possibility of race conditions!
        //  If we cant remove an item from blocking list before
        //         its IO operation is scheduled.
        // there wont be any call back generated for this case!
    }

    return fRes;

} // AtqPostCompletionStatus



DWORD
I_AtqGetGlobalConfiguration(VOID)
/*++
Description:
   This function sets several global config params for the ATQ package.
   It also reads the global configuration from registry for ATQ.
   The values if present will override the defaults

Returns:
   Win32 Errorcode - NO_ERROR on success and anything else for error
--*/
{
    DWORD       dwError = NO_ERROR;
    DWORD       dwDefaultThreadTimeout = ATQ_REG_DEF_THREAD_TIMEOUT;

    //
    // If this is a NTW, do the right thing
    //

    if ( !TsIsNtServer() ) {
        g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;
    } else {

        MEMORYSTATUS ms;

        //
        // get the memory size
        //

        ms.dwLength = sizeof(MEMORYSTATUS);
        GlobalMemoryStatus( &ms );

        //
        // Alloc two threads per MB of memory.
        //

        g_cMaxThreadLimit = (LONG)((ms.dwTotalPhys >> 19) + 2);

        if ( g_cMaxThreadLimit < ATQ_REG_MIN_POOL_THREAD_LIMIT ) {
            g_cMaxThreadLimit = ATQ_REG_MIN_POOL_THREAD_LIMIT;
        } else if ( g_cMaxThreadLimit > ATQ_REG_MAX_POOL_THREAD_LIMIT ) {
            g_cMaxThreadLimit = ATQ_REG_MAX_POOL_THREAD_LIMIT;
        }
    }

    //
    // Get entry points for NT
    //

    if ( !I_AtqInitializeNtEntryPoints( ) ) {
        dwError = ERROR_MOD_NOT_FOUND;
        return ( dwError);
    }

    g_pfnCreateCompletionPort = CreateIoCompletionPort;
    g_pfnGetQueuedCompletionStatus = GetQueuedCompletionStatus;
    g_pfnCloseCompletionPort = CloseHandle;
    g_pfnPostCompletionStatus = PostQueuedCompletionStatus;


    HKEY        hkey = NULL;
    DWORD       dwVal;

    dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                            g_PSZ_ATQ_CONFIG_PARAMS_REG_KEY,
                            0,
                            KEY_READ,
                            &hkey);

    if ( dwError == NO_ERROR ) {

        //
        // Read the Concurrency factor per processor
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ATQ_REG_PER_PROCESSOR_CONCURRENCY,
                                   ATQ_REG_DEF_PER_PROCESSOR_CONCURRENCY);

        AtqSetInfo( AtqMaxConcurrency, (ULONG_PTR)dwVal);


        //
        // Read the count of threads to be allowed per processor
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ATQ_REG_PER_PROCESSOR_ATQ_THREADS,
                                   ATQ_REG_DEF_PER_PROCESSOR_ATQ_THREADS
                                   );

        if ( dwVal != 0 ) {
            AtqSetInfo( AtqMaxPoolThreads, (ULONG_PTR)dwVal);
        }


        //
        // Read the Data transfer rate value for our calculations
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ATQ_REG_MIN_KB_SEC,
                                   ATQ_REG_DEF_MIN_KB_SEC );

        AtqSetInfo( AtqMinKbSec, (ULONG_PTR)dwVal);


        //
        // read the max thread limit
        //

        g_cMaxThreadLimit = I_AtqReadRegDword( hkey,
                                               ATQ_REG_POOL_THREAD_LIMIT,
                                               g_cMaxThreadLimit);

        //
        // read the listen backlog
        //

        g_cListenBacklog = I_AtqReadRegDword( hkey,
                                              ATQ_REG_LISTEN_BACKLOG,
                                              g_cListenBacklog);


        //
        // Read the time (in seconds) of how long the threads
        //   can stay alive when there is no IO operation happening on
        //   that thread.
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ATQ_REG_THREAD_TIMEOUT,
                                   dwDefaultThreadTimeout
                                   );

        AtqSetInfo( AtqThreadTimeout, (ULONG_PTR)dwVal);

        //
        // See if we need to turn off TF_USE_KERNEL_APC flag for
        // TransmitFile
        //
        dwVal = I_AtqReadRegDword( hkey,
                                   ATQ_REG_USE_KERNEL_APC,
                                   ATQ_REG_DEF_USE_KERNEL_APC );
        g_fUseKernelApc = dwVal;

        //
        // Whether or not to enable debug thread creator
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ATQ_REG_ENABLE_DEBUG_THREADS,
                                   g_fEnableDebugThreads );
        g_fEnableDebugThreads = !!dwVal;

        //
        // Do we want to run this backlog monitor at all?
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ATQ_REG_DISABLE_BACKLOG_MONITOR,
                                   g_fDisableBacklogMonitor );
        g_fDisableBacklogMonitor = !!dwVal;

        //
        // Read timeout for backlog monitor
        //

        dwVal = I_AtqReadRegDword( hkey,
                                   ATQ_REG_FORCE_TIMEOUT,
                                   g_cForceTimeout );
        g_cForceTimeout = dwVal;


        ATQ_REQUIRE( !RegCloseKey( hkey ) );
        hkey = NULL;
    }

    DBG_ASSERT( NULL == hkey);

    return ( dwError);
} // I_AtqGetGlobalConfiguration()



DWORD
I_NumAtqEndpointsOpen(VOID)
/*++
  Description:
    This function counts the number of Enpoints that remain open.

  Arguments:
     None

  Returns:
     DWORD containing the number of endpoints that are open.
--*/
{
    DWORD nEPOpen = 0;
    AcquireLock( &AtqEndpointLock);

    PLIST_ENTRY plEP;
    for( plEP  = AtqEndpointList.Flink;
         plEP != &AtqEndpointList;
         plEP  = plEP->Flink ) {

        nEPOpen++;
    } // for

    ReleaseLock( &AtqEndpointLock);
    return ( nEPOpen);
} // I_NumAtqEndpointsOpen()



//
// Global functions
//


DWORD
I_AtqReadRegDword(
   IN HKEY     hkey,
   IN LPCSTR   pszValueName,
   IN DWORD    dwDefaultValue )
/*++

    NAME:       I_AtqReadRegDword

    SYNOPSIS:   Reads a DWORD value from the registry.

    ENTRY:      hkey - Openned registry key to read

                pszValueName - The name of the value.

                dwDefaultValue - The default value to use if the
                    value cannot be read.

    RETURNS     DWORD - The value from the registry, or dwDefaultValue.

--*/
{
    DWORD  err;
    DWORD  dwBuffer;

    DWORD  cbBuffer = sizeof(dwBuffer);
    DWORD  dwType;

    if( hkey != NULL ) {
        err = RegQueryValueExA( hkey,
                               pszValueName,
                               NULL,
                               &dwType,
                               (LPBYTE)&dwBuffer,
                               &cbBuffer );

        if( ( err == NO_ERROR ) && ( dwType == REG_DWORD ) ) {
            dwDefaultValue = dwBuffer;
        }
    }

    return dwDefaultValue;

} // I_AtqReadRegDword()

BOOL
AtqSetSocketOption(
    IN     PATQ_CONTEXT     patqContext,
    IN     INT              optName,
    IN     INT              optValue
    )
/*++

  AtqSetSocketOption()

  Routine Description:

    Set socket options. Presently only handles TCP_NODELAY

  Arguments:

    patqContext - pointer to ATQ context
    optName     - name of property to change
    optValue    - value of property to set

  Return Value:

    TRUE if successful, else FALSE

--*/
{
    if (TCP_NODELAY != optName)
    {
        return FALSE;
    }

    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    IF_DEBUG( API_ENTRY) {

        ATQ_PRINTF(( DBG_CONTEXT, "AtqSetSocketOption( %08x (handle=%08x,"
                     " nIOs = %d), optName=%d, optValue=%d)\n",
                     patqContext, patqContext->hAsyncIO,
                     pContext->m_nIO, optName, optValue));
    }

    if ( pContext ) {

        ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );

        if ( ((BOOL)pContext->IsFlag(ACF_TCP_NODELAY)) == ((BOOL)optValue))
        {
            //
            // The flag is already enabled. Return success.
            //

            return TRUE;
        }
        else
        {
            if (NO_ERROR ==  setsockopt( HANDLE_TO_SOCKET(pContext->hAsyncIO),
                                         IPPROTO_TCP,
                                         TCP_NODELAY,
                                         (char *)&optValue,
                                         sizeof(INT)))
            {
                if ( optValue)
                {
                    pContext->SetFlag(ACF_TCP_NODELAY);
                }
                else
                {
                    pContext->ResetFlag(ACF_TCP_NODELAY);
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}

PIIS_CAP_TRACE_INFO
AtqGetCapTraceInfo(
    IN     PATQ_CONTEXT     patqContext
)
{
    PATQ_CONT pContext = (PATQ_CONT)patqContext;

    ATQ_ASSERT( pContext != NULL );

    return pContext->GetCapTraceInfo();

}

DWORD
AtqDebugCreatorThread(
    LPDWORD                 param
)
/*++

Routine Description:

    For debugging purpose.

    This function will cause another IO thread to be created (regardless of
    the max thread limit).  This IO thread will only serve new connections.

    To trigger the creation of a new thread, set isatq!g_fCreateDebugThread=1

Arguments:

    param - Unused

Return Value:

    ERROR_SUCCESS

--*/
{
    for ( ; !g_fShutdown ; )
    {
        Sleep( 5000 );

        if ( g_fCreateDebugThread )
        {
            OutputDebugString( "Creating DEBUG thread." \
                               "Reseting isatq!g_fCreateDebugThread\n" );

            I_AtqCheckThreadStatus( (VOID*) ATQ_DEBUG_THREAD );

            g_fCreateDebugThread = FALSE;
        }
    }

    return ERROR_SUCCESS;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\auxctrs.h ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       auxctrs.h

   Abstract:
       This module defines the auxiliary counters for Internet Common Services.

   Author:

       Murali R. Krishnan    ( MuraliK )    02-Apr-1996

   Environment:

       Windows NT - User Mode

   Project:

       Internet Services Common DLL

   Revision History:

--*/

# ifndef _IIS_AUX_COUNTERS_HXX_
# define _IIS_AUX_COUNTERS_HXX_

/************************************************************
 *     Include Headers
 ************************************************************/


/************************************************************
 *   Symbolic Definitions
 ************************************************************/

/*++
  Counters belong to two categories
  1. Active Counter - one that counts up and down
      It is expected that this counter consists of the current
      active items and hence this should not be wildly high, unless
      there are large # of counted objects.

  2. Cumulative Counters - counts values up and up
      This count value is used to measure the # of times event(s)
      related to this counter occurred.

  Naming Conventions:
   prefixes used are: Aac & Cac
   Aac - Active Auxiliary Counter
   Cac - Cumulative Auxiliary Counter
   Ac  - Auxiliar Counter

--*/

typedef enum  {   // Ac - stands for Aux Counters.

    AacAtqContextsAlloced = 0,

    CacAtqContextsReused,
    CacAtqContextsCleanedup,
    CacAtqPrepareContexts,
    CacAtqPendingAcceptExScans,

    CacAtqContextsTimedOut,
    CacAtqWaitsForTimeout,
    CacAtqProcWhenTimeout,           // in processing when timeout occurred.

    AacIISMaxCounters                // sentinel counter
} ENUM_IIS_AUX_COUNTER;



#ifdef IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS    (AacIISMaxCounters)

//
// Macros for operating on these counters
//

# define AcIncrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
   g_AuxCounters[acCounter]++ : \
  0)

# define AcDecrement( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ?  \
  g_AuxCounters[acCounter]-- : \
  0)

# define AcCounter( acCounter)   \
 (((acCounter) < NUM_AUX_COUNTERS) ? g_AuxCounters[acCounter] : 0)


extern LONG g_AuxCounters[];


# else // IIS_AUX_COUNTERS

# define NUM_AUX_COUNTERS              (0)

# define AcIncrement( acCounter)       (0)    /* do nothing */
# define AcDecrement( acCounter)       (0)    /* do nothing */
# define AcCounter  ( acCounter)       (0)    /* do nothing */

#endif // IIS_AUX_COUNTERS


# endif // _IIS_AUX_COUNTERS_HXX_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\captrc.cpp ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    iscaptrc.cpp

Abstract:

    Source file to contain variables required for capacity planning tracing 
    of IIS.

Author:

    07-Nov-1998  SaurabN

Revision History:

--*/

//
//
//

#include "isatq.hxx"

#include <objbase.h>
#include <initguid.h>
#include <iscaptrc.h>

#define ResourceName L"MofResource"
#define ImagePath L"inetinfo.exe"

DWORD           IISCapTraceFlag = 0;
TRACEHANDLE     IISCapTraceRegistrationHandle = (TRACEHANDLE) 0;
TRACEHANDLE     IISCapTraceLoggerHandle = (TRACEHANDLE) 0;

ULONG
IISCapTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    );

TRACE_GUID_REGISTRATION IISCapTraceGuids[] =
{
    { (LPGUID) &IISCapTraceGuid,
      NULL
    },
};

ULONG
_stdcall
IISInitializeCapTrace(
    PVOID Param
    )
{
    ULONG status;
  
    status = RegisterTraceGuidsW(
                IISCapTraceControlCallback,
                NULL,
                (LPGUID) &IISCapControlGuid,
                1,
                IISCapTraceGuids,
                NULL,
                NULL,
                &IISCapTraceRegistrationHandle);


    if (status != ERROR_SUCCESS) {
        DBGPRINTF((DBG_CONTEXT,"Capacity Planning Trace registration failed with %x\n",status));
    }
    return status;
}


ULONG
IISCapTraceControlCallback(
    IN WMIDPREQUESTCODE RequestCode,
    IN PVOID RequestContext,
    IN OUT ULONG *InOutBufferSize,
    IN OUT PVOID Buffer
    )
{
    PWNODE_HEADER Wnode = (PWNODE_HEADER)Buffer;
    ULONG Status;
    ULONG RetSize;

    Status = ERROR_SUCCESS;

    switch (RequestCode)
    {
        case WMI_ENABLE_EVENTS:
        {
            IISCapTraceLoggerHandle =
                GetTraceLoggerHandle(Buffer);
            IISCapTraceFlag = 1;
            RetSize = 0;
            break;
        }

        case WMI_DISABLE_EVENTS:
        {
            IISCapTraceFlag = 0;
            RetSize = 0;
            IISCapTraceLoggerHandle = (TRACEHANDLE) 0;
            break;
        }
        default:
        {
            RetSize = 0;
            Status = ERROR_INVALID_PARAMETER;
            break;
        }

    }

    *InOutBufferSize = RetSize;
    return Status;
} // IISCapTraceControlCallback

DWORD GetIISCapTraceFlag()
{
    return IISCapTraceFlag;
}

TRACEHANDLE GetIISCapTraceLoggerHandle()
{
    return IISCapTraceLoggerHandle;
}

VOID SetIISCapTraceFlag(DWORD dwFlag)
{
    IISCapTraceFlag = dwFlag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\place.inc ===
#
#  Places all of the internet binaries into the inetsrv tree
#

# enable building legoizable binaries
NTBBT=1

# define CAP related options
CAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
CAP_LIBS=$(SDK_LIB_PATH)\cap.lib
CAP_FLAGS= -Zd -Gh

!IFDEF CAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(CAP_FLAGS)
LINK_OPTIONS=$(CAP_LINK_OPTIONS)
!ENDIF

# define ICE-CAP related options
ICAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
ICAP_LIBS=$(SDK_LIB_PATH)\icap.lib $(SDK_LIB_PATH)\penter.lib
ICAP_FLAGS= -Zi -Gh

!IFDEF ICAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(ICAP_FLAGS)
LINK_OPTIONS=$(ICAP_LINK_OPTIONS)
!ENDIF

!ifdef _NT386TREE
# ## _NT386TREE=$(_NT386TREE)\iis
!endif

!ifdef _NTALPHATREE
# ## _NTALPHATREE=$(_NTALPHATREE)\iis
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\dirmon.cpp ===
/*++

   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

       dirmon.cpp

   Abstract:
       This module includes definitions of functions and variables
        for CDirMonitor and CDirMonitorEntry object

   Author:

       Charles Grant       ( cgrant   )     April-1997

   Revision History:

        Changed to abstract classes to share code between core IIS and ASP

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "isatq.hxx"
#include "malloc.h"
#include "except.h"

#define IATQ_DLL_IMPLEMENTATION
#define IATQ_IMPLEMENTATION_EXPORT

#include "dirmon.h"


//
// CDirMonitorEntry
//

#define DEFAULT_BUFFER_SIZE 512

CDirMonitorEntry::CDirMonitorEntry() :
                    m_cDirRefCount(0),
                    m_cIORefCount(0),
                    m_hDir(INVALID_HANDLE_VALUE),
                    m_pAtqCtxt(NULL),
                    m_dwNotificationFlags(0),
                    m_pszPath(NULL),
                    m_cPathLength(0),
                    m_pDirMonitor(NULL),
                    m_cBufferSize(0),
                    m_pbBuffer(NULL),
                    m_fInCleanup(FALSE),
                    m_fWatchSubdirectories(FALSE)
/*++

Routine Description:

    CDirMonitorEntry constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
}


CDirMonitorEntry::~CDirMonitorEntry(
    VOID
    )
/*++

Routine Description:

    CDirMonitorEntry destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Destructor\n"));
    }

    // We should only be destroyed when
    // our ref counts have gone to 0

    DBG_ASSERT(m_cDirRefCount == 0);
    DBG_ASSERT(m_cIORefCount == 0);

    //
    // We really ought to have closed the handle by now
    //
    if (m_hDir != INVALID_HANDLE_VALUE) {
        DBGPRINTF(( DBG_CONTEXT, "~CDirMonitorEntry: open handle %p : %p\n",
                    m_hDir, m_pAtqCtxt ));

        m_hDir = INVALID_HANDLE_VALUE;
        AtqCloseFileHandle(m_pAtqCtxt);
    }

    if (m_pDirMonitor != NULL)
    {
        m_pDirMonitor->RemoveEntry(this);
        m_pDirMonitor = NULL;
    }

    m_cPathLength = 0;

    if ( m_pszPath != NULL )
    {
        free( m_pszPath );
        m_pszPath = NULL;
    }

    if (m_pAtqCtxt)
    {
        AtqFreeContext(m_pAtqCtxt, FALSE);
        m_pAtqCtxt = NULL;
    }

    if (m_pbBuffer != NULL)
    {
        free(m_pbBuffer);
        m_cBufferSize = 0;
    }
}

BOOL
CDirMonitorEntry::Init(
    DWORD cBufferSize = DEFAULT_BUFFER_SIZE
)
/*++

Routine Description:

    Initialize the dir montior entry.

Arguments:

    cBufferSize  - Initial size of buffer used to store change notifications

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
        // Don't allow a 0 length buffer
        if (cBufferSize == 0)
        {
                return FALSE;
        }

    DBG_ASSERT( m_pbBuffer == NULL );

        m_pbBuffer = (BYTE *) malloc(cBufferSize);

        if (m_pbBuffer != NULL)
        {
                m_cBufferSize = cBufferSize;
                return TRUE;
        }
        else
        {
                // Unable to allocate buffer
        return FALSE;
    }
}

BOOL
CDirMonitorEntry::RequestNotification(
    VOID
)
/*++

Routine Description:

    Request ATQ to monitor directory changes for the directory handle
    associated with this entry

Arguments:

    None

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitorEntry] Request change notification\n"));
    }

    BOOL fResult = FALSE;

    DBG_ASSERT(m_pDirMonitor);

    // Reset the overlapped io structure

    memset(&m_ovr, 0, sizeof(m_ovr));

    // Increase the ref count in advance

    IOAddRef();

    // Request notification of directory changes

    fResult = AtqReadDirChanges( m_pAtqCtxt,              // Atq context handle
                            m_pbBuffer,                // Buffer for change notifications
                            m_cBufferSize,          // Size of buffer
                            m_fWatchSubdirectories,  // Monitor subdirectories?
                            m_dwNotificationFlags,   // Which changes should we be notified of
                            &m_ovr );                // Overlapped IO structure

    if (!fResult)
    {
        // ReadDirChanges failed so
        // release the ref count we did in advance
        // Might cause IO ref count to go to 0

        IORelease();
    }

    return fResult;

}

BOOL
CDirMonitorEntry::Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleans up resource and determines if the caller need to delete
    the Directory Monitor Entry instance.

Arguments:

    None

Return Value:

    TRUE if the caller is responsible for deleting the object
    This will be the case if there are no pending Asynch IO requests

--*/
{
    DBG_ASSERT(m_cDirRefCount == 0);

    BOOL fDeleteNeeded = FALSE;
    BOOL fHandleClosed = FALSE;

    BOOL fInCleanup = (BOOL) InterlockedExchange((long *) &m_fInCleanup, TRUE);

    if (!fInCleanup)
    {
        // Get the IO ref count BEFORE we close the handle

        DWORD cIORefCount = m_cIORefCount;

        if (m_hDir != INVALID_HANDLE_VALUE)
        {
            // If we have a pending AtqReadDirectoryChanges,
            // closing the directory handle will cause a call back from ATQ.
            // The call back should relase the final refcount on the object
            // which should result in its deletion

            m_hDir = INVALID_HANDLE_VALUE;
            fHandleClosed = AtqCloseFileHandle( m_pAtqCtxt );
        }

        // If there were no pending Asynch IO operations or if we failed
        // to close the handle, then the caller will be responsible for
        // deleting this object.

        if (cIORefCount == 0 || fHandleClosed == FALSE)
        {
            fDeleteNeeded = TRUE;
        }
    }

    return fDeleteNeeded;
}

BOOL
CDirMonitorEntry::ResetDirectoryHandle(
    VOID
    )
/*++

Routine Description:

    Opens a new directory handle and ATQ context for the path,
    and closes the old ones. We want to be able to do this so we
    can change the size of the buffer passed in ReadDirectoryChangesW.
    If we are unable to get a new handle or a new ATQ context, we leave
    the existing ones in place.

Arguments:

    None

Return Value:

    TRUE if the handles were succesfully reopened
    FALSE otherwise

--*/
{
        // We'd better have a directory path available to try this
        
        if (m_pszPath == NULL)
        {
                return FALSE;
        }
        
    // Get a new handle to the directory

    HANDLE hDir = CreateFile(
                           m_pszPath,
                           FILE_LIST_DIRECTORY,
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS |
                                FILE_FLAG_OVERLAPPED,
                           NULL );

    if ( hDir == INVALID_HANDLE_VALUE )
    {
        // We couldn't open another handle on the directory,
        // leave the current handle and ATQ context alone

        return FALSE;
    }

    // Get a new ATQ context for our new handle

    PATQ_CONTEXT pAtqCtxt = NULL;
    if ( !AtqAddAsyncHandle(&pAtqCtxt,
                                NULL,
                                (LPVOID) this,
                                (ATQ_COMPLETION) CDirMonitor::DirMonitorCompletionFunction,
                                INFINITE,
                                hDir ) )
    {
        // We couldn't get a new ATQ context. Close our new handle.
        // We leave the objects current handle and ATQ context alone
        CloseHandle(hDir);
        return FALSE;
    }

    // We have the new handle and ATQ context so we close
    // and replace the old ones.

    AtqCloseFileHandle(m_pAtqCtxt);
        AtqFreeContext(m_pAtqCtxt, FALSE);
        m_pAtqCtxt = pAtqCtxt;
        m_hDir = hDir;

        return TRUE;
}

BOOL
CDirMonitorEntry::SetBufferSize(
    DWORD cBufferSize
    )
/*++

Routine Description:

    Sets the size of the buffer used for storing change notification records

Arguments:

    cBufferSize         new size for the buffer.

Return Value:

    TRUE        if the size of the buffer was succesfully set
    FALSE       otherwise

Note

        When a call to ReadDirectoryChangesW is made, the size of the buffer is set in
        the data associated with the directory handle and is not changed on subsequent
        calls to ReadDirectoryChangesW. To make use of the new buffer size the directory
        handle must be closed and a new handle opened (see ResetDirectoryHandle())
        
--*/
{
        // We should never be called if the buffer doesn't already exist
        
        ASSERT(m_pbBuffer);
        
        // Don't allow the buffer to be set to 0
        
        if (cBufferSize == 0)
        {
                return FALSE;
        }

        VOID *pbBuffer = realloc(m_pbBuffer, cBufferSize);

        if (pbBuffer == NULL)
        {
                // Re-allocation failed, stuck with the same size buffer
                
                return FALSE;
        }
        else
        {
                // Re-allocation succeded, update the member variables
                
                m_pbBuffer = (BYTE *) pbBuffer;
                m_cBufferSize = cBufferSize;
                return TRUE;
        }
}

//
// CDirMonitor
//

CDirMonitor::CDirMonitor()
    : CTypedHashTable<CDirMonitor, CDirMonitorEntry, const char*>("DirMon")
/*++

Routine Description:

    CDirMonitor constructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    INITIALIZE_CRITICAL_SECTION( &m_csSerialComplLock );
    m_cRefs = 1;
}


CDirMonitor::~CDirMonitor()
/*++

Routine Description:

    CDirMonitor destructor

Arguments:

    None

Return Value:

    Nothing

--*/
{
    DeleteCriticalSection(&m_csLock);
    DeleteCriticalSection(&m_csSerialComplLock);
}

BOOL
CDirMonitor::Monitor(
    CDirMonitorEntry *pDME,
    LPCSTR pszDirectory,
    BOOL fWatchSubDirectories,
    DWORD dwNotificationFlags
    )
/*++

Routine Description:

    Create a monitor entry for the specified path

Arguments:

    pszDirectory - directory to monitor
    pCtxt - Context of path is being monitored
    pszDirectory - name of directory to monitor
    fWatchSubDirectories - whether to get notifications for subdirectories
    dwNotificationFlags - which activities to be notified of

Return Value:

    TRUE if success, otherwise FALSE

Remarks:

    Caller should have a lock on the CDirMonitor
    Not compatible with WIN95

--*/
{
    LIST_ENTRY  *pEntry;
    HANDLE      hDirectoryFile = INVALID_HANDLE_VALUE;
    BOOL        fRet = TRUE;
    DWORD       dwDirLength = 0;

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Monitoring new CDirMonitorEntry\n"));
    }

    // Must have a directory monitor entry and a string
    // containing the directory path

    if (!pDME || !pszDirectory)\
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    // Make copy of pszDirectory for the entry to hang on to


    pDME->m_cPathLength = strlen(pszDirectory);
    if ( !(pDME->m_pszPath = (LPSTR)malloc( pDME->m_cPathLength + 1 )) )
    {
        pDME->m_cPathLength = 0;
        return FALSE;
    }
    memcpy( pDME->m_pszPath, pszDirectory, pDME->m_cPathLength + 1 );

    pDME->Init();

    // Open the directory handle

    hDirectoryFile = CreateFile(
                           pszDirectory,
                           FILE_LIST_DIRECTORY,
                                FILE_SHARE_READ |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE,
                           NULL,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS |
                                FILE_FLAG_OVERLAPPED,
                           NULL );

    if ( hDirectoryFile == INVALID_HANDLE_VALUE )
    {
        // Cleanup
        free(pDME->m_pszPath);
        pDME->m_pszPath = NULL;
        pDME->m_cPathLength = 0;
        return FALSE;
    }
    else
    {
        // Store the handle so we can close it on cleanup

        pDME->m_hDir = hDirectoryFile;

        // Set the flags for the type of notifications we want
        // and if we should watch subdirectories or just the root

        pDME->m_dwNotificationFlags = dwNotificationFlags;
        pDME->m_fWatchSubdirectories = fWatchSubDirectories;

        // Get an ATQ context for this handle
        // and register our completion call back function

        if ( AtqAddAsyncHandle( &pDME->m_pAtqCtxt,
                                NULL,
                                (LPVOID) pDME,
                                (ATQ_COMPLETION) DirMonitorCompletionFunction,
                                INFINITE,
                                hDirectoryFile ) )
        {
            // Insert this entry into the list of active entries

            if (InsertEntry(pDME) == LK_SUCCESS)
            {

                // Ask for notification if this directory has changes

                if (!pDME->RequestNotification())
                {
                        // Couldn't register for change notification
                        // Clean up resources
                    RemoveEntry(pDME);
                        pDME->m_hDir = INVALID_HANDLE_VALUE;
                        AtqCloseFileHandle(pDME->m_pAtqCtxt);
                        free(pDME->m_pszPath);
                        pDME->m_pszPath = NULL;
                        pDME->m_cPathLength = 0;
                        return FALSE;
                }
            }
        }
        else
        {
           
            // Failed to add handle to ATQ, clean up

            CloseHandle(hDirectoryFile);
            pDME->m_hDir = INVALID_HANDLE_VALUE;
            free(pDME->m_pszPath);
            pDME->m_pszPath = NULL;
            pDME->m_cPathLength = 0;
            return FALSE;
        }

    }

    return TRUE;
}

VOID
CDirMonitor::DirMonitorCompletionFunction(
    PVOID pCtxt,
    DWORD dwBytesWritten,
    DWORD dwCompletionStatus,
    OVERLAPPED *pOvr
    )
/*++

Routine Description:

Static member function called by ATQ to signal directory changes

Arguments:

    pCtxt - CDirMonitorEntry*
    dwBytesWritten - # bytes returned by ReadDirectoryChanges
    dwCompletionStatus - status of request to ReadDirectoryChanges
    pOvr - OVERLAPPED as specified in call to ReadDirectoryChanges

Return Value:

    Nothing

--*/
{
    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Notification call-back begining. Status %d\n", dwCompletionStatus));
    }

    CDirMonitorEntry*  pDirMonitorEntry = reinterpret_cast<CDirMonitorEntry*>(pCtxt);

    DBG_ASSERT(pDirMonitorEntry);

    // Safety add ref, this should guarentee that the DME is not deleted
    // while we are still processing the callback

    pDirMonitorEntry->IOAddRef();

    // Release for the current Asynch operation
    // Should not send IO ref count to 0

    DBG_REQUIRE(pDirMonitorEntry->IORelease());

    BOOL fRequestNotification = FALSE;

    // There has been a change in the directory we were monitoring
    // carry out whatever work we need to do.

    if (!pDirMonitorEntry->m_fInCleanup)
    {
        pDirMonitorEntry->m_pDirMonitor->SerialComplLock();
        // BUG Under stress ActOnNotification has been initiating a chain of events
        // leading to an AV. For Beta 3 we think we can ignore these AV. For the final
        // product we need to rework the critical sections for the template manager and
        // the include file table.
        TRY
            fRequestNotification = pDirMonitorEntry->ActOnNotification(dwCompletionStatus, dwBytesWritten);
        CATCH(nExcept)
            // We should never get here
            DBG_ASSERT(FALSE);
        END_TRY
        pDirMonitorEntry->m_pDirMonitor->SerialComplUnlock();
    }

    // If we aren't cleaning up and ActOnNotification returned TRUE
    // then make another Asynch notification request. We check m_fInCleanup
    // again because ActOnNotification may have caused it to change

    if (!pDirMonitorEntry->m_fInCleanup && fRequestNotification)
    {
       fRequestNotification = pDirMonitorEntry->RequestNotification();
    }

    // Remove safety ref count, may cause IO ref count to go to 0

    pDirMonitorEntry->IORelease();

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Notification call-back ending\n"));
    }
}


CDirMonitorEntry *
CDirMonitor::FindEntry(
    LPCSTR pszPath
    )
/*++

Routine Description:

    Searches the list of entries for the specified path

Arguments:

    pszPath - file path, including file name

Return Value:

    pointer to the entry, allready addref'd

--*/
{
    DBG_ASSERT(pszPath);

    CDirMonitorEntry *pDME = NULL;
    FindKey(pszPath, &pDME);

    if (pDME)
    {
        if (pDME->m_fInCleanup)
        {
                // Don't hand back a DME that is being shutdown
                pDME = NULL;
        }
        else
        {
                // We found a valid DME which we are going to hand to the caller
                pDME->AddRef();
        }
    }

    return pDME;
}

LK_RETCODE
CDirMonitor::InsertEntry(
    CDirMonitorEntry *pDME
    )
/*++

Routine Description:

    Insert an entry into the list of entries for the monitor

Arguments:

    pDME - entry to insert

Return Value:

    nothing

--*/
{
    DBG_ASSERT(pDME);
    LK_RETCODE  lkResult;

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Inserting directory (DME %08x) %s\n", pDME, pDME->m_pszPath));
    }

    pDME->m_pDirMonitor = this;

    // pass a true value for the fOverwrite flag.  This allows the new entry
    // to replace the previous entry.  The previous entry should only be there
    // if the app it is associated with is being shutdown and the cleanup of
    // the DME records has yet to happen.

    lkResult = InsertRecord(pDME, true);
    
    if (lkResult == LK_SUCCESS) {
        // AddRef on the DirMonitor object to allow Cleanup to wait for all
        // DirMonitorEntries to be removed.  The problem arises when duplicates
        // are added to the hash table.  In this case, only the last entry is
        // kept so checking the size of the hash table during shutdown is not
        // good enough since the DMEs that were bounced may not have been freed
        // yet.
        AddRef();
    }
       
    return lkResult;
}

LK_RETCODE
CDirMonitor::RemoveEntry(
    CDirMonitorEntry *pDME
    )
/*++

Routine Description:

    Deletes an entry from the list of entries for the monitor

Arguments:

    pDME - entry to delete

Return Value:

    None

--*/
{
    DBG_ASSERT(pDME);

    // Release the DME's reference on the DirMonitor object.

    Release();

    LK_RETCODE lkResult = DeleteKey(pDME->m_pszPath);
    pDME->m_pDirMonitor = NULL;

    IF_DEBUG( NOTIFICATION ) {
        DBGPRINTF((DBG_CONTEXT, "[CDirMonitor] Removed DME(%08x), directory %s\n", pDME, pDME->m_pszPath));
    }

    return lkResult;
}

BOOL
CDirMonitor::Cleanup(
    VOID
    )
/*++

Routine Description:

    Pauses while all entries are cleaned up

Arguments:

    None

Return Value:

    None

--*/
{
    //BOOL fProperShutdown = FALSE;

    // Check that all DME have been released before shutting down
    // Sleep a maximum of 30 seconds before shutting down anyway

        while (Size() > 0 || m_cRefs != 1)
    {
                // At least one DME is still active, sleep and try again
                Sleep(200);
    }

    DBGPRINTF((DBG_CONTEXT, "CDirMonitor(%08x): Cleanup, entries remaining %d (Refs = %d)\n", this, Size(),m_cRefs));

    #ifdef _DEBUG
    // TODO: Use LKHASH iterator
    /*if (CHashTable::m_Count)
        {
        Lock();
        CLinkElem *pLink = CHashTable::Head();
        DBGPRINTF((DBG_CONTEXT, "Remaining CDirMonitorEntry objects:\n"));
        while (pLink)
            {
            CDirMonitorEntry *pDME = reinterpret_cast<CDirMonitorEntry *>(pLink);
            DBGPRINTF((DBG_CONTEXT, "CDirMonitorEntry(%08x), ref count = %d, io refcount = %d", pDME, pDME->m_cDirRefCount, pDME->m_cIORefCount));
            pLink = pLink->m_pNext;
            }
        Unlock();
        }
    */
    #endif //_DEBUG

    //DBG_ASSERT(fProperShutdown );


    return TRUE;
}

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\dllmain.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994-1996           **/
/**********************************************************************/

/*
    dllmain.cxx

        Library initialization for isatq.dll  --
           Internet Information Services - ATQ dll.

    FILE HISTORY:

        MuraliK     08-Apr-1996  Created.
*/


#include "isatq.hxx"
#include <inetinfo.h>


/************************************************************
 * Globals
 ************************************************************/

DECLARE_DEBUG_PRINTS_OBJECT();
DECLARE_PLATFORM_TYPE();

const CHAR g_pszAtqRegLocation[] =
    INET_INFO_PARAMETERS_KEY /* string concatenation */
#ifndef _EXEXPRESS
        TEXT("\\isatq");
#else
        TEXT("\\ksatq");
#endif

const CHAR g_szModuleName[] =
#ifndef _EXEXPRESS
        TEXT("\\isatq");
#else
        TEXT("\\ksatq");
#endif

//
// is winsock initialized?
//

BOOL    g_fSocketsInitialized = FALSE;



/************************************************************
 * Functions
 ************************************************************/



extern "C"
BOOL WINAPI
DllMain( HINSTANCE hDll, DWORD dwReason, LPVOID lpvReserved )
{
    BOOL  fReturn = TRUE;

    switch ( dwReason )
    {
    case DLL_PROCESS_ATTACH:  {

        RECT rect;

        CREATE_DEBUG_PRINT_OBJECT( g_szModuleName);

        if ( !VALID_DEBUG_PRINT_OBJECT()) {
            return ( FALSE);
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR( g_pszAtqRegLocation, 0 );

        //
        // Initialize sockets
        //

        {
            DWORD dwError = NO_ERROR;

            WSADATA   wsaData;
            INT       serr;

            //
            //  Connect to WinSock 2.0
            //

            serr = WSAStartup( MAKEWORD( 2, 0), &wsaData);

            if( serr != 0 ) {
                DBGPRINTF((DBG_CONTEXT,"WSAStartup failed with %d\n",serr));
                return(FALSE);
            }
            g_fSocketsInitialized = TRUE;
        }


        //
        // Initialize the platform type
        //
        INITIALIZE_PLATFORM_TYPE();
        ATQ_ASSERT(IISIsValidPlatform());

        //
        // Call a windows API that will cause windows server side thread to
        // be created for tcpsvcs.exe. This prevents a severe winsrv memory
        // leak when spawning processes and
        // gives a perf boost so the windows
        // console isn't brought up and torn down each time.   :(
        //

        (VOID) AdjustWindowRectEx( &rect,
                                  0,
                                  FALSE,
                                  0 );
        // fReturn already init to TRUE

        if ( !INITIALIZE_CRITICAL_SECTION( &g_csInitTermLock ) )
        {
            WSACleanup();
            return FALSE;
        }

        if ( !INITIALIZE_CRITICAL_SECTION( &AtqEndpointLock ) )
        {
            DeleteCriticalSection( &g_csInitTermLock );
            WSACleanup();
            return FALSE;
        }

        DisableThreadLibraryCalls( hDll );
        break;
    }

    case DLL_PROCESS_DETACH:

        if ( lpvReserved != NULL) {

            //
            //  Only Cleanup if there is a FreeLibrary() call.
            //

            break;
        }

        DeleteCriticalSection( &AtqEndpointLock );
        DeleteCriticalSection( &g_csInitTermLock );

        //
        // Cleanup sockets
        //

        if ( g_fSocketsInitialized ) {

            INT serr = WSACleanup();

            if ( serr != 0) {
                DBGPRINTF((DBG_CONTEXT,"WSACleanup failed with %d\n",
                           WSAGetLastError()));
            }
            g_fSocketsInitialized = FALSE;
        }

        DELETE_DEBUG_PRINT_OBJECT();
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break ;
    }

    return ( fReturn);

} // main()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\atqsupp.cxx ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

       atqsupp.cxx

   Abstract:

        Contains internal support routines for the ATQ package
        From atqnew.c

   Author:
        Murali R. Krishnan     (MuraliK)     02-Apr-1996

   Project:
        Internet Server Common DLL
--*/

#include "isatq.hxx"
#include <iscaptrc.h>

DWORD AtqPoolThread( LPDWORD param );

extern PBANDWIDTH_INFO g_pBandwidthInfo;
extern DWORD            IISCapTraceFlag;
extern TRACEHANDLE      IISCapTraceLoggerHandle;


DWORD g_fAlwaysReuseSockets = FALSE;


/************************************************************
 * Functions for ATQ_CONTEXT
 ************************************************************/


PATQ_CONT
I_AtqAllocContextFromCache( VOID);

VOID
I_AtqFreeContextToCache(
            IN PATQ_CONT pAtqContext,
            IN BOOL UnlinkContext
            );



PATQ_CONT
I_AtqAllocContextFromCache( VOID)
/*++
  This function attempts to allocate an ATQ context from the allocation cache.
  It then initializes the state information in the ATQ context object and
    returns the context on success.

  Arguments:
    None

  Returns:
    On success a valid pointer to ATQ_CONT. Otherwise NULL.

--*/
{
    PATQ_CONT  pAtqContext;

    DBG_ASSERT( NULL != g_pachAtqContexts);

    pAtqContext = (ATQ_CONTEXT * ) g_pachAtqContexts->Alloc();

    if ( NULL != pAtqContext ) {

        //
        // Make sure everything is zeroed out so there is
        // no crud from previous use.
        //
        memset(pAtqContext, 0, sizeof(ATQ_CONTEXT));

        pAtqContext->ContextList =
            &AtqActiveContextList[(++AtqGlobalContextCount %
                                   g_dwNumContextLists)];

        pAtqContext->Signature = ATQ_CONTEXT_SIGNATURE;
    }

    return (pAtqContext);
} // I_AtqAllocContextFromCache()




VOID
I_AtqFreeContextToCache(
        IN PATQ_CONT pAtqContext
        )
/*++
  This function releases the given context to the allocation cache.

  Arguments:
    pAtqContext  pointer to the ATQ_CONTEXT that is being freed.

  Returns:
    None

  Issues:
    This function also performs some other cleanup specific to AtqContexts.
--*/
{

#if 0
      ATQ_PRINTF(( DBG_CONTEXT,
                 "[I_AtqFreeCtxtToCache] Freed up %08x\n",
                 pAtqContext
                 ));
#endif

    DBG_ASSERT( pAtqContext->Signature == ATQ_FREE_CONTEXT_SIGNATURE);
    DBG_ASSERT( pAtqContext->lSyncTimeout ==0);
    DBG_ASSERT( pAtqContext->m_nIO ==0);
    DBG_ASSERT( pAtqContext->m_acFlags == 0);
    DBG_ASSERT( pAtqContext->m_acState == 0);
    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);
    DBG_ASSERT( pAtqContext->pvBuff == NULL);
    DBG_ASSERT( pAtqContext->pEndpoint == NULL);
    DBG_ASSERT( pAtqContext->hAsyncIO == NULL);

    DBG_REQUIRE( g_pachAtqContexts->Free( pAtqContext));

    return;

} // I_AtqFreeContextToCache



void
ATQ_CONTEXT::Print( void) const
{
    DBGPRINTF(( DBG_CONTEXT,
                " ATQ_CONTEXT (%08x)\n"
                "\thAsyncIO            = %p   Signature        = %08lx\n"
                "\tOverlapped.Internal = %p   Overlapped.Offset= %08lx\n"
                "\tm_leTimeout.Flink   = %p   m_leTimeout.Blink= %p\n"
                "\tClientContext       = %p   ContextList      = %p\n"
                "\tpfnCompletion       = %p ()\n"
                "\tpEndPoint           = %p   fAcceptExContext = %s\n"
                "\tlSyncTimeout        = %8d     fInTimeout       = %s\n"

                "\tTimeOut             = %08lx   NextTimeout      = %08lx\n"
                "\tBytesSent           = %d (0x%08lx)\n"

                "\tpvBuff              = %p\n"
                "\tfConnectionIndicated= %s      fBlocked         = %8lx\n"

                "\tState               = %8lx    Flags            = %8lx\n",
                this,
                hAsyncIO,
                Signature,
                Overlapped.Internal,
                Overlapped.Offset,
                m_leTimeout.Flink,
                m_leTimeout.Blink,
                ClientContext,
                ContextList,
                pfnCompletion,
                pEndpoint,
                (IsAcceptExRootContext() ? "TRUE" : "FALSE"),
                lSyncTimeout,
                (IsFlag( ACF_IN_TIMEOUT) ? "TRUE" : "FALSE"),
                TimeOut,
                NextTimeout,
                BytesSent,
                BytesSent,
                pvBuff,
                (IsFlag( ACF_CONN_INDICATED) ? "TRUE" : "FALSE"),
                IsBlocked(),
                m_acState, m_acFlags
                ));

    // Print the buffer if necessary.

    return;
} // ATQ_CONTEXT::Print()




VOID
ATQ_CONTEXT::HardCloseSocket( VOID)
/*++
  Description:
     This socket closes the socket by forcibly calling closesocket() on
     the socket. This function is used during the endpoint shutdown
     stage for an atq context

  Arguments:
     None

  Returns:
     None

--*/
{
    HANDLE haio = (HANDLE )
        InterlockedExchangePointer( (PVOID *)&hAsyncIO, NULL );

    DBG_ASSERT( IsState( ACS_SOCK_LISTENING) ||
                IsState( ACS_SOCK_CONNECTED) ||
                IsState( ACS_SOCK_CLOSED) ||
                IsState( ACS_SOCK_UNCONNECTED)
                );

    MoveState( ACS_SOCK_CLOSED);


    //
    //  Let us do a hard close on the socket (handle).
    //  This should generate an IO completion which will free this
    //     ATQ context
    //

    if ( (haio != NULL) &&
         (closesocket( HANDLE_TO_SOCKET(haio) ) == SOCKET_ERROR)
         ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Warning - "
                     " Context=%08x closesocket failed,"
                     " error %d, socket = %x\n",
                     this,
                     GetLastError(),
                     haio ));
        Print();
    }

    return;
} // ATQ_CONTEXT::HardCloseSocket()



VOID
ATQ_CONTEXT::InitWithDefaults(
    IN ATQ_COMPLETION pfnCompletion,
    IN DWORD TimeOut,
    IN HANDLE hAsyncIO
    )
{
    DBG_ASSERT( this->Signature == ATQ_CONTEXT_SIGNATURE);

    this->InitTimeoutListEntry();

    this->Signature    = ATQ_CONTEXT_SIGNATURE;

     // start life at 1. This ref count will be freed up by AtqFreeContext()
    this->m_nIO = 1;

    this->pfnCompletion   = pfnCompletion;

    this->TimeOut         = TimeOut;
    this->TimeOutScanID   = 0;
    this->lSyncTimeout    = 0;

    this->hAsyncIO        = hAsyncIO;

    this->m_acState       = 0;
    this->m_acFlags       = 0;

    // Initialize pbandwidthinfo to point to global object

    this->m_pBandwidthInfo  = g_pBandwidthInfo;

    ZeroMemory(
               &this->Overlapped,
               sizeof( this->Overlapped )
               );

    DBG_ASSERT( this->lSyncTimeout == 0);

    //
    // Following added for bandwidth throttling purposes
    //

    DBG_ASSERT( !this->IsBlocked());
    this->arInfo.atqOp    = AtqIoNone;
    this->arInfo.lpOverlapped = NULL;
    // bandwidth throttling initialization ends here.

    //
    // Should we force socket closure?
    //

    this->m_fForceClose = FALSE;

} // ATQ_CONTEXT::InitWithDefaults()




VOID
ATQ_CONTEXT::InitNonAcceptExState(
    IN PVOID pClientContext
    )
{
    //
    //  Note that if we're not using AcceptEx, then we consider the client
    //  to have been notified externally (thus ACF_CONN_INDICATED is set).
    //  Also we set the next timeout to be infinite, which may be reset
    //   when the next IO is submitted.
    //

    this->NextTimeout          = ATQ_INFINITE;
    this->ClientContext        = pClientContext;
    this->pEndpoint            = NULL;
    this->SetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_CONNECTED);
    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT);

    //
    // Insert this into the active list - since this is a non-acceptex socket
    //

    DBG_ASSERT( this->ContextList != NULL);
    this->ContextList->InsertIntoActiveList( &this->m_leTimeout );

    return;

} // ATQ_CONTEXT::InitNonAcceptExState()



VOID
ATQ_CONTEXT::InitAcceptExState(
            IN DWORD NextTimeOut
            )
{
    this->NextTimeout          = NextTimeOut;
    this->ClientContext        = NULL;
    this->lSyncTimeout         = 0;

    this->ResetFlag( ACF_CONN_INDICATED);
    this->SetState( ACS_SOCK_LISTENING);

    //
    //  Add it to the pending accept ex list
    //
    DBG_ASSERT( this->ContextList != NULL);

    this->ContextList->InsertIntoPendingList( &this->m_leTimeout);

    return;
} // ATQ_CONTEXT::InitAcceptExState()



BOOL
ATQ_CONTEXT::PrepareAcceptExContext(
    PATQ_ENDPOINT          pEndpoint
    )
/*++

Routine Description:

    Initializes the state for completely initializing the state and
    hence prepares the context for AcceptEx

    It expects the caller to send a AtqContext with certain characteristics
      1) this is not NULL
      2) this->pvBuff has valid values

    In the case of failure, caller should call
     pAtqContext->CleanupAndRelese() to free the memory associated with
     this object.

Arguments:

    pEndpoint     - pointer to endpoint object for this context

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

    The caller should free the object on a failure.

--*/
{
    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases
    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( this != NULL);
    DBG_ASSERT( this->pvBuff != NULL);

    //
    //  Make sure that we are adding a AcceptEx() version of AtqContext
    //

    DBG_ASSERT( pEndpoint->ConnectExCompletion != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    //  Fill out the context.  We set NextTimeout to INFINITE
    //  so the timeout thread will ignore this entry until an IO
    //  request is made unless this is an AcceptEx socket, that means
    //  we're about to submit the IO.
    //

    this->
        InitWithDefaults(
                         pEndpoint->IoCompletion,
                         pEndpoint->AcceptExTimeout, // canonical Timeout
                         this->hAsyncIO
                         );


    //
    // TBD: What is the circumstance in which this->pEndpoint!= NULL?
    //

    if ( this->pEndpoint == NULL ) {

        pEndpoint->Reference();
        this->pEndpoint  = pEndpoint;
    }

    this->ResetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

    this->InitAcceptExState( AtqGetCurrentTick() + TimeOut);

    DBG_ASSERT( this->pvBuff != NULL);

    //
    // Initialize capacity planning trace info
    //

    m_CapTraceInfo.IISCapTraceHeader.TraceHeader.Guid         = IISCapTraceGuid;
    m_CapTraceInfo.IISCapTraceHeader.TraceHeader.Class.Type   = EVENT_TRACE_TYPE_START;
    m_CapTraceInfo.IISCapTraceHeader.TraceHeader.Flags        = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
    m_CapTraceInfo.IISCapTraceHeader.TraceHeader.Size         = sizeof (IIS_CAP_TRACE_HEADER);
    m_CapTraceInfo.IISCapTraceHeader.TraceContext.Length      = sizeof(ULONGLONG);
    // Will get over-written
    m_CapTraceInfo.IISCapTraceHeader.TraceContext.DataPtr     = (ULONGLONG)
                                                                (&m_CapTraceInfo.IISCapTraceHeader.TraceContext.DataPtr);
    return (TRUE);

} // ATQ_CONTEXT::PrepareAcceptExContext()




VOID
ATQ_CONTEXT::CleanupAndRelease( VOID)
/*++
  Routine Description:
     This function does the cleanup of the ATQ context. It does not
     attempt to do any reuse of the atq context. After cleanup
     the context is freed to the ATQ pool. Supplied context
     is not valid after calling this function.

  Arguments:
     None

  Returns:
     None
--*/
{
    DBG_ASSERT( this->m_nIO == 0);

    //
    //  Cleanup and free the ATQ Context entirely
    //

    if ( this->hAsyncIO != NULL ) {

        // It is too dangerous to assume that the handle is a socket!
        // But we will do that for fast-pathing IIS operations.

        HANDLE hTmp =
            (HANDLE)InterlockedExchangePointer( (PVOID *)&this->hAsyncIO,
                                                NULL );

        SOCKET hIO = HANDLE_TO_SOCKET(hTmp);

        if ( hIO != NULL &&
             (closesocket( hIO ) == SOCKET_ERROR ) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "ATQ_CONTEXT(%08x)::CleanupAndRelease() : Warning"
                         " - Context=%08x, "
                         " closesocket failed, error %d, socket = %x\n",
                         this,
                         GetLastError(),
                         hIO ));
            this->Print();
        }
    }

    DBG_ASSERT( this->hAsyncIO == NULL);

    if ( this->pvBuff != NULL ) {
        LocalFree( this->pvBuff );
        this->pvBuff = NULL;
    }

    //
    // Unlink from the list
    //

    DBG_ASSERT( this->ContextList != NULL);

    // NYI: Can I avoid this comparison?
    //
    // Check if this context is part of a timeout list.
    // If it is then remove it from the list
    // Only during shutdown code path, we will see trouble here.
    //
    if ( this->m_leTimeout.Flink != NULL ) {
        this->ContextList->RemoveFromList( &this->m_leTimeout);
    }

    //
    //  Deref the listen info if this context is associated with one
    //

    if ( this->pEndpoint != NULL ) {
        this->pEndpoint->Dereference();
        this->pEndpoint = NULL;
    }

    this->Signature    = ATQ_FREE_CONTEXT_SIGNATURE;
    this->lSyncTimeout = 0;
    this->m_acState    = 0;
    this->m_acFlags    = 0;

    I_AtqFreeContextToCache( this);

    return;
} // ATQ_CONTEXT::CleanupAndRelease()





VOID
AtqpUpdateBandwidth( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten)
{
    PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;

    DBG_ASSERT( pBandwidthInfo != NULL );
    DBG_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    // add the bandwidth info to active list if necessary

    pBandwidthInfo->AddToActiveList();

    //this will have problems when we use XmitFile for large files.

    pBandwidthInfo->UpdateBytesXfered( pAtqContext, cbWritten );
} // AtqpUpdateBandwidth()


VOID
AtqpCallOplockCompletion( IN PATQ_CONT pAtqContext,
                          IN DWORD cbWritten)
{
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion;
    PVOID OplockContext;
    POPLOCK_INFO pOplock;

    //
    // The ATQ context object received is a fake one. We actually get
    //  back POPLOCK_INFO object that is used to extract the callback
    //  function & context for the callback
    //

    pOplock = (POPLOCK_INFO)pAtqContext;
    pfnOplockCompletion = (ATQ_OPLOCK_COMPLETION)pOplock->pfnOplockCompletion;
    OplockContext = (PVOID)pOplock->Context;

    LocalFree(pOplock);


    (*pfnOplockCompletion)(OplockContext, (DWORD)cbWritten);
    return;

} // AtqpCallOplockCompletion()



VOID
AtqpProcessContext( IN PATQ_CONT  pAtqContext,
                    IN DWORD      cbWritten,
                    IN LPOVERLAPPED lpo,
                    IN BOOL       fRet)
{
    BOOL fRecvCalled = FALSE;
    DWORD dwError;

    DBG_ASSERT( pAtqContext != NULL);

    DBG_ASSERT( lpo != NULL); // this replaces the SPUD code. get rid of it
    if (lpo == NULL) {
        return;
    }

    dwError = (fRet) ? NO_ERROR: GetLastError();

    //
    //  If this is an AcceptEx listen socket atq completion, then the
    //  client Atq context we really want is keyed from the overlapped
    //  structure that is stored in the client's Atq context.
    //

    if ( pAtqContext->IsAcceptExRootContext() ) {

        pAtqContext = CONTAINING_RECORD( lpo, ATQ_CONTEXT, Overlapped );
    }

#if CC_REF_TRACKING
    //
    // ATQ notification trace
    //
    // Notify client context of all non-oplock notification.
    // This is for debugging purpose only.
    //

    pAtqContext->NotifyIOCompletion( cbWritten, (fRet) ? NO_ERROR: GetLastError(), 0xfefefefe );
#endif

    DBG_CODE(
             if ( ATQ_CONTEXT_SIGNATURE != pAtqContext->Signature) {
                 pAtqContext->Print();
                 DBG_ASSERT( FALSE);
             });


    //
    //  m_nIO also acts as the reference count for the atq contexts
    //  So, increment the count now, so that there is no other thread
    //   that will free up this ATQ context accidentally.
    //

    InterlockedIncrement( &pAtqContext->m_nIO);

    //
    // Busy wait for timeout processing to complete!
    //  This is ugly :( A fix in time for IIS 2.0/Catapult 1.0 release
    //

    InterlockedIncrement(  &pAtqContext->lSyncTimeout);
    while ( pAtqContext->IsFlag( ACF_IN_TIMEOUT)) {

        AcIncrement( CacAtqWaitsForTimeout);

        Sleep( ATQ_WAIT_FOR_TIMEOUT_PROCESSING);
    };

    //
    //  We need to make sure the timeout thread doesn't time this
    //  request out so reset the timeout value
    //

    InterlockedExchange( (LPLONG )&pAtqContext->NextTimeout,
                         (LONG ) ATQ_INFINITE);

    //
    // Update Bandwidth information on successful completion, if needed
    //

    if ( BANDWIDTH_INFO::GlobalEnabled() && fRet && cbWritten > 0)
    {
        AtqpUpdateBandwidth( pAtqContext, cbWritten);
    }

    //
    // Since the IO completion means that one of the async operation finished
    //  decrement our internal ref count appropriately to balance the addition
    //  when the IO operation was submitted.
    //
    InterlockedDecrement( &pAtqContext->m_nIO);

    //
    //  Is this a connection indication?
    //

    if ( !pAtqContext->IsFlag( ACF_CONN_INDICATED) ) {

        PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

        if ( NULL == pEndpoint) {
            pAtqContext->Print();
            OutputDebugString( "Found an ATQ context with bad Endpoint\n");
            DBG_ASSERT( FALSE);
            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);
            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count
            return;
        }

        DBG_ASSERT( pEndpoint != NULL );

        //
        // If the endpoint isn't active it may not be safe to call
        // the connection completion function. Setting an error
        // state will close the connection below.
        //
        if ( fRet && !IS_BLOCK_ACTIVE( pEndpoint ) ) {
            fRet = FALSE;
            dwError = ERROR_OPERATION_ABORTED;
        }

        //
        //  Indicate this socket is in use
        //

        InterlockedDecrement( &pEndpoint->nSocketsAvail );

        //
        //  If we're running low on sockets, add some more now
        //

        if ( pEndpoint->nSocketsAvail <
             (LONG )(pEndpoint->nAcceptExOutstanding >> 2) ) {

            AcIncrement( CacAtqPrepareContexts);

            (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                pEndpoint->nAcceptExOutstanding
                                                );
        }

        //
        //  If an error occurred on this completion,
        //    shutdown the socket
        //

        if ( !fRet ) {

            IF_DEBUG( ERROR) {
                if ( dwError != ERROR_OPERATION_ABORTED &&
                     dwError != ERROR_NETNAME_DELETED ) {
                    ATQ_PRINTF(( DBG_CONTEXT,
                                 " Free Context(%08x, EP=%08x) to cache. "
                                 "Err=%d, sock=%08x\n",
                                 pAtqContext, pEndpoint,
                                 dwError,
                                 pAtqContext->hAsyncIO));
                }
            }

            DBG_REQUIRE( InterlockedDecrement(  &pAtqContext->lSyncTimeout) == 0);

            InterlockedDecrement( &pAtqContext->m_nIO); // balance entry count

            // balance original count
            InterlockedDecrement( &pAtqContext->m_nIO);
            // Free up the atq context without Reuse
            pAtqContext->CleanupAndRelease();
            return;
        }

        //
        //  Shutdown may close the socket from underneath us so don't
        //  assert, just warn.
        //

        if ( !pAtqContext->IsState( ACS_SOCK_LISTENING) ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "[AtqPoolThread] Warning-Socket state not listening\n"
                         ));
            DBG_CODE( pAtqContext->Print());
        }

        pAtqContext->MoveState( ACS_SOCK_CONNECTED);

        //
        // Remove the context from the pending list and put
        // it on the active list
        //

        DBG_ASSERT( pAtqContext->ContextList != NULL);
        pAtqContext->ContextList->MoveToActiveList( &pAtqContext->m_leTimeout);

        //
        //  Set the connection indicated flag.  After we return from
        //  the connection completion routine we assume it's
        //  safe to call the IO completion routine
        //  (or the connection indication routine should do cleanup
        //  and never issue an IO request).  This is primarily for
        //  the timeout thread.
        //

        pAtqContext->ConnectionCompletion( cbWritten, lpo);
    } else {


        //
        //  Not a connection completion indication. I/O completion.
        //

        //
        //  If an error occurred on a TransmitFile (or other IO),
        //  set the state to connected so the socket will get
        //  closed on cleanup
        //

        if ( !fRet &&
             pAtqContext->IsState( ACS_SOCK_UNCONNECTED)
             ){
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

        pAtqContext->IOCompletion( cbWritten, dwError, lpo);
    }

    DBG_ASSERT( pAtqContext->lSyncTimeout > 0);
    InterlockedDecrement( &pAtqContext->lSyncTimeout);

    //
    // We do an interlocked decrement on m_nIO to sync up state
    //  so that the context is not prematurely deleted.
    //

    if ( InterlockedDecrement(  &pAtqContext->m_nIO) == 0) {

        //
        // The number of outstanding ref holders is ZERO.
        // Free up this ATQ context.
        //
        // We really do not free up the context - but try to reuse
        //  it if possible
        //

        // free the atq context now or reuse if possible.
        AtqpReuseOrFreeContext( pAtqContext,
                                (pAtqContext->
                                 IsFlag( ACF_REUSE_CONTEXT) != 0)
                                );
    }

    return;
} // AtqpProcessContext()



DWORD
AtqPoolThread(
    LPDWORD param
    )
/*++

Routine Description:

    This is the pool thread wait and dispatch routine

  Arguments:
    param : unused.

  Return Value:

    Thread return value (ignored)

--*/
{
    PATQ_CONT    pAtqContext = NULL;
    BOOL         fRet;
    LPOVERLAPPED lpo;
    DWORD        cbWritten;
    DWORD        returnValue;
    DWORD        availThreads;

    for(;;) {

        pAtqContext = NULL;
        InterlockedIncrement( &g_cAvailableThreads );

        fRet = g_pfnGetQueuedCompletionStatus( g_hCompPort,
                                               &cbWritten,
                                               (PULONG_PTR)&pAtqContext,
                                               &lpo,
                                               g_msThreadTimeout );

        availThreads = InterlockedDecrement( &g_cAvailableThreads );

        if ( fRet || lpo ) {

            if ( pAtqContext == NULL) {
                if ( g_fShutdown ) {

                    //
                    // This is our signal to exit.
                    //

                    returnValue = NO_ERROR;
                    break;
                }

                OutputDebugString( "A null context received\n");
                continue;  // some error in the context has occured.
            }

            //
            // Make sure we're not running out of threads
            //

            if ( availThreads == 0 ) {

                //
                //  Make sure there are pool threads to service the request
                //

                (VOID)I_AtqCheckThreadStatus();
            }

            if ( (ULONG_PTR) param == ATQ_DEBUG_THREAD )
            {
                //
                // If this is a DEBUG thread, we are only concerned with new
                // connections.  Anything else we ignore.
                //

                if ( pAtqContext->IsFlag( ACF_CONN_INDICATED ) )
                {
                    continue;
                }
            }

            //
            // Capacity planning log
            //

            if (IISCapTraceFlag && pAtqContext)
            {
                PIIS_CAP_TRACE_INFO pCapTraceInfo = pAtqContext->GetCapTraceInfo();

                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Class.Type = EVENT_TRACE_TYPE_START;
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Size       = sizeof (IIS_CAP_TRACE_HEADER);
                pCapTraceInfo->IISCapTraceHeader.TraceContext.DataPtr = (ULONGLONG) &pAtqContext;
                pCapTraceInfo->IISCapTraceHeader.TraceContext.Length  = sizeof(ULONG_PTR);

                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Flags       = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Guid        = IISCapTraceGuid;
                if ( ERROR_INVALID_HANDLE == TraceEvent ( IISCapTraceLoggerHandle,
                                               (PEVENT_TRACE_HEADER) pCapTraceInfo))
                {
                    IISCapTraceFlag = FALSE;
                }
            }

            AtqpProcessContext( pAtqContext, cbWritten, lpo, fRet);

            //
            // Capacity planning log
            //

            if (IISCapTraceFlag && pAtqContext)
            {
                PIIS_CAP_TRACE_INFO pCapTraceInfo = pAtqContext->GetCapTraceInfo();

                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Class.Type = EVENT_TRACE_TYPE_END;
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Size       = sizeof (IIS_CAP_TRACE_HEADER);
                pCapTraceInfo->IISCapTraceHeader.TraceContext.DataPtr = (ULONGLONG) &pAtqContext;
                pCapTraceInfo->IISCapTraceHeader.TraceContext.Length  = sizeof(ULONG_PTR);
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Guid        = IISCapTraceGuid;
                pCapTraceInfo->IISCapTraceHeader.TraceHeader.Flags       = WNODE_FLAG_TRACED_GUID | WNODE_FLAG_USE_MOF_PTR;

                if ( ERROR_INVALID_HANDLE == TraceEvent ( IISCapTraceLoggerHandle,
                                                   (PEVENT_TRACE_HEADER) pCapTraceInfo))
                {
                    IISCapTraceFlag = FALSE;
                }
            }

        } else {

            //
            // don't kill the initial thread - any thread that doesn't have
            // pending I/Os go ahead and allow to die
            //

            if ( ((ULONG_PTR)param == ATQ_INITIAL_THREAD) && !g_fShutdown ) {
                continue;
            }

            if ( !g_fShutdown && GetLastError() == WAIT_TIMEOUT ) {

                NTSTATUS status;
                ULONG flag;

                status = NtQueryInformationThread(
                               NtCurrentThread(),
                               ThreadIsIoPending,
                               &flag,
                               sizeof(flag),
                               NULL );

                IF_DEBUG( TIMEOUT ) {
                    ATQ_PRINTF(( DBG_CONTEXT,
                                 "[ATQ Pool Thread] NtQueryInformationThread() returned 0x%08x, flag = %d\n",
                                 status,
                                 flag ));
                }

                if ( NT_SUCCESS( status ) && flag ) {

                    //
                    //  There are pending I/Os on this thread so don't exit
                    //

                    continue;
                }
            }

            IF_DEBUG( TIMEOUT ) {
                ATQ_PRINTF(( DBG_CONTEXT,
                             "[ATQ Pool Thread] Exiting thread 0x%x\n",
                             GetCurrentThread() ));
            }

            //
            //  An error occurred.  Either the thread timed out, the handle
            //  is going away or something bad happened.  Let the thread exit.
            //

            returnValue = GetLastError();

            break;
        }

    } // for

    if ( NULL != g_pfnExitThreadCallback) {

        //
        //  Client wishes to be told when ATQ threads terminate.
        //

        g_pfnExitThreadCallback();
    }

    if ( InterlockedDecrement( &g_cThreads ) == 0 ) {

        //
        // Wake up ATQTerminate()
        //
        IF_DEBUG( ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "AtqPoolThread() - setting shutdown event %08x."
                         " g_cThreads = %d\n",
                         g_hShutdownEvent, g_cThreads
                         ));
        }

        SetEvent( g_hShutdownEvent );
    }

    return returnValue;
} // AtqPoolThread




BOOL
I_AtqCheckThreadStatus(
    PVOID Context
    )
/*++

Routine Description:

    This routine makes sure there is at least one thread in
    the thread pool.  We're fast and loose so a couple of extra
    threads may be created.

Arguments:

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)

--*/
{
    BOOL fRet = TRUE;
    BOOL fIsDebugThread = ( (ULONG_PTR) Context == ( ATQ_DEBUG_THREAD ) );

    //
    //  If no threads are available, kick a new one off up to the limit
    //
    //  WE NEED TO CHANGE THE CONDITIONS FOR STARTING ANOTHER THREAD
    //  IT SHOULD NOT BE VERY EASY TO START A THREAD ....
    //

    if ( ( (g_cAvailableThreads == 0) &&
           (g_cThreads < g_cMaxThreads) &&
           (g_cThreads < g_cMaxThreadLimit) ) ||
         fIsDebugThread )
    {
        HANDLE hThread;
        DWORD  dwThreadID;

        if ( !fIsDebugThread )
        {
            InterlockedIncrement( &g_cThreads );
        }

        hThread = CreateThread( NULL,
                                0,
                                (LPTHREAD_START_ROUTINE)AtqPoolThread,
                                Context,
                                0,
                                &dwThreadID );

        if ( hThread ) {
            CloseHandle( hThread );     // Free system resources
        } else if ( !fIsDebugThread ) {

            //
            // We fail if there are no threads running
            //

            if ( InterlockedDecrement( &g_cThreads ) == 0) {
                ATQ_PRINTF(( DBG_CONTEXT,
                    "AtqCheckThread: Cannot create ATQ threads\n"));
                fRet = FALSE;
            }
        }
    }

    return fRet;
} // I_AtqCheckThreadStatus()


/************************************************************
 *  Functions to Add/Delete Atq Contexts
 ************************************************************/


BOOL
I_AtqAddAsyncHandle(
    IN OUT PATQ_CONT  *    ppAtqContext,
    IN PATQ_ENDPOINT       pEndpoint,
    PVOID                  ClientContext,
    ATQ_COMPLETION         pfnCompletion,
    DWORD                  TimeOut,
    HANDLE                 hAsyncIO
    )
/*++

  Description:
    This functio adds creates a new NON-AcceptEx() based Atq Context,
     and includes it in proper lists fo ATQ Context management.


  Note:
    The client should call this after the IO handle is openned
    and before the first IO request is made

    Even in the case of failure, client should call AtqFreeContext() and
     free the memory associated with this object.

--*/
{
    BOOL         fReturn = TRUE;

    DBG_ASSERT( ppAtqContext != NULL);
    DBG_ASSERT( ClientContext != NULL);

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        PATQ_CONT    pAtqContext;

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();
        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.  We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.
        //


        pAtqContext->InitWithDefaults(pfnCompletion,
                                      CanonTimeout( TimeOut ), hAsyncIO);

        //
        //  These data members are used if we're doing AcceptEx processing
        //

        pAtqContext->SetAcceptExBuffer( NULL);

        pAtqContext->InitNonAcceptExState(ClientContext);

        //
        // If an endpoint is provided, reference it
        //

        if ( pEndpoint != NULL ) {
            pEndpoint->Reference();
            pAtqContext->pEndpoint = pEndpoint;
        }

        *ppAtqContext = pAtqContext;
    }

    return (TRUE);

} // I_AtqAddAsyncHandle()




BOOL
I_AtqAddListenEndpointToPort(
    IN OUT PATQ_CONT    * ppAtqContext,
    IN PATQ_ENDPOINT    pEndpoint
    )
/*++

  Description:
    This function creates a new AtqContext for the given ListenSocket.
    It uses the listen socket as the AcceptEx() socket too for adding
     the atq context to the completion port.
    It assumes
      TimeOut to be INFINITE, with no Endpoint structure.

  Arguments:
    ppAtqContext - pointer to location that will contain the atq context
                   on successful return.
    pEndpoint - pointer to the endpoint.

  Returns:
    TRUE on success
    FALSE if there is a failure.

  Note:
    The caller should free the *ppAtqContext if there is a failure.

--*/
{
    BOOL         fReturn = TRUE;
    PATQ_CONT    pAtqContext;

    DBG_ASSERT( g_fUseAcceptEx); // only support AcceptEx() cases

    *ppAtqContext = NULL; // initialize

    if ( g_fShutdown) {

        SetLastError( ERROR_NOT_READY);
        return (FALSE);

    } else {

        //
        //  Note we take and release the lock here as we're
        //  optimizing for the reuseable context case
        //

        pAtqContext = I_AtqAllocContextFromCache();

        if ( pAtqContext == NULL) {

            return (FALSE);
        }

        //
        //  Fill out the context.
        //  We set the TimeOut for this object to be ATQ_INFINITE,
        //   since we do not want any interference from the Timeout loop.
        //

        pAtqContext->InitWithDefaults(
                                      pEndpoint->IoCompletion,
                                      ATQ_INFINITE,
                                      SOCKET_TO_HANDLE(pEndpoint->ListenSocket)
                                      );

        //
        //  These data members are used if we're doing AcceptEx processing
        //


        pAtqContext->SetAcceptExBuffer( NULL);

        //
        // Among AcceptEx ATQ Contexts,
        //  only the listen ATQ context will have the Endpoint field as NULL
        //
        pAtqContext->pEndpoint       = NULL;
        pAtqContext->SetFlag( ACF_ACCEPTEX_ROOT_CONTEXT );

        //
        // We set NextTimeout to INFINITE
        //  so the timeout thread will ignore this entry until an IO
        //  request is made unless this is an AcceptEx socket, that means
        //  we're about to submit the IO.

        DBG_ASSERT( g_fUseAcceptEx && pEndpoint->ConnectExCompletion != NULL);

        pAtqContext->InitAcceptExState( ATQ_INFINITE);

        *ppAtqContext = pAtqContext;
    }

    fReturn = I_AddAtqContextToPort( pAtqContext);

    return (fReturn);

} // I_AtqAddListenEndpointToPort()



BOOL
I_AtqAddAcceptExSocket(
    IN PATQ_ENDPOINT          pEndpoint,
    IN PATQ_CONT              pAtqContext
    )
/*++

Routine Description:

    Adds the AtqContext to the AcceptEx() waiters list,
    after allocating a new socket, since pAtqContext->hAsyncIO = NULL.

Arguments:

    pEndpoint - Information about this listenning socket
    patqReusedContext - optional context to use

Return Value:

    TRUE on success, FALSE on failure.
    On failure the caller should free the pAtqContext

--*/
{
    BOOL   fAddToPort = FALSE;
    BOOL   fSuccess = TRUE;

    DBG_ASSERT( pAtqContext != NULL);
    DBG_ASSERT( g_pfnAcceptEx != NULL);
    DBG_ASSERT( pAtqContext->pvBuff != NULL);

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( !IS_BLOCK_ACTIVE(pEndpoint) ) {

        SetLastError( ERROR_NOT_READY );
        return ( FALSE);
    }

    //
    //  Use the supplied socket if any.
    //  Otherwise create a new socket
    //

    if ( pAtqContext->hAsyncIO == NULL) {

        SOCKET sAcceptSocket;

#if WINSOCK11
        sAcceptSocket = socket(
                            AF_INET,
                            SOCK_STREAM,
                            IPPROTO_TCP
                            );
#else
        sAcceptSocket = WSASocketW(
                            AF_INET,
                            SOCK_STREAM,
                            IPPROTO_TCP,
                            NULL,  // protocol info
                            0,     // Group ID = 0 => no constraints
                             WSA_FLAG_OVERLAPPED // completion port notifications
                            );
#endif // WINSOCK11

        if ( sAcceptSocket == INVALID_SOCKET ) {

            fSuccess = FALSE;
            sAcceptSocket = NULL;

            //
            // no need to unlink from any list, since we did not add it to any
            //

        } else {

            //
            // Setup the accept ex socket in the atq context.
            //

            pAtqContext->hAsyncIO = SOCKET_TO_HANDLE(sAcceptSocket);
            fAddToPort = TRUE;
            DBG_ASSERT( fSuccess);
        }
    }

    if ( fSuccess) {

        DWORD        cbRecvd;

        if ( g_fShutdown) {

            //
            // no need to unlink from any list, since we did not add it to any
            //

            SetLastError( ERROR_NOT_READY);
            return (FALSE);
        }

        DBG_ASSERT( pAtqContext->hAsyncIO != NULL);

        //
        // 1. Call I_AtqAddAsyncHandleEx() to establish the links with
        //  proper AcceptEx & AtqContext processing lists.
        //
        //  After 1, the atqcontext will be in the lists, so
        //    cleanup should remove the context from proper lists.
        //
        // 2. Add the socket to Completion Port (if new),
        //    i.e. if fAddToPort is true)
        //
        // 3. Submit the new socket to AcceptEx() so that it may be
        //  used for processing about the new connections.
        //

        // 1.

        DBG_REQUIRE( pAtqContext->PrepareAcceptExContext(pEndpoint));

        // increment outstanding async io operations before AcceptEx() call
        InterlockedIncrement( &pAtqContext->m_nIO);

        fSuccess = (// 2.
                    ( !fAddToPort || I_AddAtqContextToPort( pAtqContext))
                    &&
                    // 3.
                    (
                     g_pfnAcceptEx( pEndpoint->ListenSocket,
                               HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                               pAtqContext->pvBuff,
                               pEndpoint->InitialRecvSize,
                               MIN_SOCKADDR_SIZE,
                               MIN_SOCKADDR_SIZE,
                               &cbRecvd,
                               &pAtqContext->Overlapped )
                     ||
                     (GetLastError() == ERROR_IO_PENDING)
                     )
                    );

        if ( fSuccess) {

            //
            //  We've successfully added this socket, increment the count
            //

            InterlockedIncrement( &pEndpoint->nSocketsAvail );

        } else {

            ATQ_PRINTF(( DBG_CONTEXT,
                        "[AtqAddAcceptExSocket] Reusing an old context (%08x)"
                        " failed; error %d:%d, sAcceptSocket = %x, "
                        " pEndpoint = %lx, parm4 = %d, parm7 = %lx,"
                        " parm8 = %lx\n",
                        pAtqContext,
                        GetLastError(),
                        WSAGetLastError(),
                        pAtqContext->hAsyncIO,
                        pEndpoint,
                        pEndpoint->InitialRecvSize,
                        &cbRecvd,
                        &pAtqContext->Overlapped ));

            //
            // Unlink from the current list, where it was added as a result of
            //  step 1 above.
            //
            DBG_ASSERT( pAtqContext->ContextList != NULL);

            // balance the increment of the async operations outstanding
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) > 0);

            DBG_ASSERT( pAtqContext->m_leTimeout.Flink != NULL);
            pAtqContext->ContextList->
                RemoveFromList( &pAtqContext->m_leTimeout);

            //
            // balance the increment done
            // by pAtqContext->PrepareAcceptExContext()
            //
            DBG_REQUIRE( InterlockedDecrement( &pAtqContext->m_nIO) == 0);
            DBG_ASSERT( !fSuccess);

            //
            // the caller will free the Atq context on failure
            //
        }
    }

    return ( fSuccess);
} // I_AtqAddAcceptExSocket()




VOID
AtqpReuseContext( PATQ_CONT  pAtqContext)
/*++
  Description:
     This function attempts to reuse the ATQ context.
     It first cleans up the state and then uses the function
      I_AtqAddAccetpEx() socket to re-add the context to acceptex pool

  Arguments:
     pAtqContext - pointer to ATQ context that can be reused

  Returns:
     None
--*/
{
    PATQ_ENDPOINT pEndpoint = pAtqContext->pEndpoint;

    DBG_ASSERT( pEndpoint != NULL);
    DBG_ASSERT( pEndpoint->UseAcceptEx);

    //
    // Complete connection has been processed prior to coming here
    //

    DBG_ASSERT(pAtqContext->IsFlag( ACF_CONN_INDICATED));

    //
    // Remove from the current active list
    //
    if ( pAtqContext->m_leTimeout.Flink != NULL ) {
        pAtqContext->ContextList->RemoveFromList( &pAtqContext->m_leTimeout );
    }

    DBG_ASSERT( pAtqContext->m_leTimeout.Flink == NULL);
    DBG_ASSERT( pAtqContext->m_leTimeout.Blink == NULL);

    DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

    //
    //  Either there is no socket or the socket must be in the
    //  unconnected state (meaning reused after TransmitFile)
    //

    if ( !(!pAtqContext->hAsyncIO ||
           (pAtqContext->hAsyncIO &&
            pAtqContext->IsState( ACS_SOCK_UNCONNECTED |
                                  ACS_SOCK_TOBE_FREED)
            )
           )) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqReuseContext] Warning:"
                     " state = %08x, socket = %x (context %lx), "
                     " was Free called w/o close?\n",
                     pAtqContext->m_acState,
                     pAtqContext->hAsyncIO,
                     pAtqContext ));
        DBG_ASSERT( FALSE);
    }

    //
    //  Need to make sure that the state information is cleaned up
    //  before re-adding the context to the list. Also reset socket options.
    //

    if ( pAtqContext->hAsyncIO && pAtqContext->IsFlag(ACF_TCP_NODELAY))
    {
        INT optValue = 0;

        setsockopt( HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                    IPPROTO_TCP,
                    TCP_NODELAY,
                    (char *)&optValue,
                    sizeof(INT)
                  );

        //
        // No need to reset the flag. It will be 0'd out during the Add
        //
    }

    if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

        //
        //  Failed to add the socket, free up the context without reuse
        //

        ATQ_PRINTF(( DBG_CONTEXT,
                     "[AtqpReuseContext] for (%08x) failed with "
                     " Error = %d;  Now freeing the context ...\n",
                     pAtqContext, GetLastError()
                     ));

        DBG_ASSERT( pAtqContext->m_nIO == 0);

        // free without reuse
        pAtqContext->CleanupAndRelease();
    }

    return;
} // AtqpReuseContext()



VOID
AtqpReuseOrFreeContext(
    PATQ_CONT    pAtqContext,
    BOOL         fReuseContext
    )
/*++
  Routine Description:
     This function does a free-up of the ATQ contexts. During the free-up
     path, we also attempt to reuse the ATQ context if the fReuseContext is
     set.

  Arguments:
     pAtqContext - pointer to the ATQ context that needs to be freedup
     fReuseContext - BOOLEAN flag indicating if this context should be reused

  Returns:
     None
--*/
{
    //
    // Get this object out of the Blocked Requests List.
    //

    if ( pAtqContext->IsBlocked()) {
        ATQ_REQUIRE( pAtqContext->m_pBandwidthInfo
                      ->RemoveFromBlockedList( pAtqContext ));
        DBG_ASSERT( !pAtqContext->IsBlocked());
    }

    DBG_ASSERT( pAtqContext->m_pBandwidthInfo != NULL);
    pAtqContext->m_pBandwidthInfo->Dereference();

    //
    //  Conditions for Reuse:
    //   1) fReuseContext == TRUE => caller wants us to reuse context
    //   2) pAtqContext->pEndpoint != NULL => valid endpoint exists
    //   3)  pEndpoint->UseAcceptEx => AcceptEx is enabled
    //   4)  pEndpoint->nSocketsAvail < nAcceptExOutstanding * 2 =>
    //           We do not have lots of outstanding idle sockets
    //       Condition (4) ensures that we do not flood the system
    //         with too many AcceptEx sockets as a result of some spike.
    //       AcceptEx sockets once added to the pool are hard to
    //         remove, because of various timing problems.
    //       Hence we want to prevent arbitrarily adding AcceptEx sockets.
    //
    //    In condition (4) I use a fudge factor of "2", so that
    //     we do continue to prevent reuse of sockets prematurely.
    //

    if ( fReuseContext &&
         (pAtqContext->pEndpoint != NULL)  &&
         (pAtqContext->pEndpoint->UseAcceptEx)
         &&
         ( g_fAlwaysReuseSockets ||
           ((DWORD )pAtqContext->pEndpoint->nSocketsAvail <
            pAtqContext->pEndpoint->nAcceptExOutstanding * 2)
           )
         ) {

        //
        // Call the function to reuse context. On failure
        // the AtqpReuseContext will free up the context
        //

        AcIncrement( CacAtqContextsReused);

        AtqpReuseContext( pAtqContext);

    } else {

        AcIncrement( CacAtqContextsCleanedup);

        pAtqContext->CleanupAndRelease();

    }

    return;
} // AtqpReuseOrFreeContext()



BOOL
I_AtqPrepareAcceptExSockets(
    IN PATQ_ENDPOINT          pEndpoint,
    IN DWORD                  nSockets
    )
/*++

Routine Description:

    Prepare specified number of AcceptEx sockets for the given
      ListenSocket in [pEndpoint]

Arguments:

    pEndpoint - Information about this listenning socket
    nSockets    - number of AcceptEx() sockets to be created.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    BOOL   fReturn;
    DWORD  cbBuffer;
    DWORD  i;

    if ( !g_fUseAcceptEx ) {
        SetLastError( ERROR_NOT_SUPPORTED );
        return FALSE;
    }

    //
    //  If this listen socket isn't accepting new connections, just return
    //

    if ( pEndpoint->State != AtqStateActive ) {
        SetLastError( ERROR_NOT_READY );
        return(FALSE);
    }

    if ( pEndpoint->fAddingSockets) {
        //
        // Someone is already adding sockets. Do not add more
        // Just return success
        //
        return ( TRUE);
    }

    pEndpoint->fAddingSockets = TRUE;

    // calculate the buffer size
    cbBuffer = pEndpoint->InitialRecvSize + 2* MIN_SOCKADDR_SIZE;

    for ( fReturn = TRUE, i = 0 ; fReturn && i++ < nSockets; ) {

        PVOID        pvBuff;
        PATQ_CONT    pAtqContext = NULL;

        //
        //  Alloc a buffer for receive data
        //  TBD: Pool all these buffers into one large buffer.
        //

        pvBuff = LocalAlloc( LPTR, cbBuffer);

        //
        //  Get the ATQ context now because we need its overlapped structure
        //

        if (pvBuff != NULL)
            pAtqContext = I_AtqAllocContextFromCache();


        //
        // Now check if allocations are valid and do proper cleanup on failure
        //

        if ( pvBuff == NULL || pAtqContext == NULL) {

            if ( pvBuff ) {
                LocalFree( pvBuff );
                pvBuff = NULL;
            }

            if ( pAtqContext ) {
                pAtqContext->Signature = ATQ_FREE_CONTEXT_SIGNATURE;
                I_AtqFreeContextToCache( pAtqContext );
                pAtqContext = NULL;
            }

            SetLastError( ERROR_NOT_ENOUGH_MEMORY );
            fReturn = FALSE;
            break;
        } else {

            //
            // Add this socket to AtqContext lists & completion ports
            // From now on the called function will take care of freeing up
            //  pAtqContext, if there is a failure.
            //

            pAtqContext->SetAcceptExBuffer( pvBuff);
            pAtqContext->hAsyncIO = NULL;

            if ( !I_AtqAddAcceptExSocket(pEndpoint, pAtqContext) ) {

                //
                //  Failed to add the socket, free up the context without reuse
                //

                ATQ_PRINTF(( DBG_CONTEXT,
                             "[I_AtqPrepareAcceptExSockets] for Endpoint %08x"
                             " and AtqContext (%08x) failed with "
                             " Error = %d;  Now freeing the context ...\n",
                             pEndpoint, pAtqContext, GetLastError()
                             ));

                DWORD dwError = GetLastError();

                // free without reuse
                DBG_ASSERT( pAtqContext->m_nIO == 0);
                pAtqContext->CleanupAndRelease();

                SetLastError(dwError);

                fReturn = FALSE;
            }
        }
    } // for

    //
    // Finished Adding sockets. Indicate that by resetting the flab
    //

    pEndpoint->fAddingSockets = FALSE;

    ATQ_PRINTF(( DBG_CONTEXT,
                "PrepareAcceptExSockets( Endpoint[%08x], nSockets = %d)==>"
                " avail = %d; Total Refs = %d.\n",
                pEndpoint,
                nSockets,
                pEndpoint->nSocketsAvail,
                pEndpoint->m_refCount
                ));

    return ( fReturn);

} // I_AtqPrepareAcceptExSockets()



BOOL
I_AtqInitializeNtEntryPoints(
    VOID
    )
{

    HINSTANCE tmpInstance;

    //
    // load kernel32 and get NT specific entry points
    //

    tmpInstance = LoadLibrary("kernel32.dll");
    if ( tmpInstance != NULL ) {

        g_pfnReadDirChangesW = (PFN_READ_DIR_CHANGES_W)
            GetProcAddress( tmpInstance, "ReadDirectoryChangesW");

        DBG_ASSERT(g_pfnReadDirChangesW != NULL);

        //
        // We can free this because we are statically linked to it
        //

        FreeLibrary(tmpInstance);
    }

    g_hMSWsock = LoadLibrary( "mswsock.dll" );

    if ( g_hMSWsock != NULL ) {

        SOCKET          sTempSocket = INVALID_SOCKET;
        GUID            guidTransmitFile = WSAID_TRANSMITFILE;
        GUID            guidAcceptEx = WSAID_ACCEPTEX;
        GUID            guidGetAcceptExSockAddrs = WSAID_GETACCEPTEXSOCKADDRS;
        DWORD           cbReturned;

        //
        // Lets create a temporary socket so that we can use WSAIoctl to
        // get the direct function pointers for AcceptEx(), TransmitFile(),
        // etc.
        //

        sTempSocket = WSASocketW( AF_INET,
                                  SOCK_STREAM,
                                  IPPROTO_TCP,
                                  NULL,
                                  0,
                                  0 );

        if ( sTempSocket == INVALID_SOCKET )
        {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Failed to create temp socket "
                         "for determining WinSock provider.  Error = %d",
                         WSAGetLastError() ));
            goto cleanup;
        }

        WSAIoctl( sTempSocket,
                  SIO_GET_EXTENSION_FUNCTION_POINTER,
                  (LPVOID) &guidTransmitFile,
                  sizeof( guidTransmitFile ),
                  &g_pfnTransmitFile,
                  sizeof( g_pfnTransmitFile ),
                  &cbReturned,
                  NULL,
                  NULL );

        WSAIoctl( sTempSocket,
                  SIO_GET_EXTENSION_FUNCTION_POINTER,
                  (LPVOID) &guidAcceptEx,
                  sizeof( guidAcceptEx ),
                  &g_pfnAcceptEx,
                  sizeof( g_pfnAcceptEx ),
                  &cbReturned,
                  NULL,
                  NULL );

        WSAIoctl( sTempSocket,
                  SIO_GET_EXTENSION_FUNCTION_POINTER,
                  (LPVOID) &guidGetAcceptExSockAddrs,
                  sizeof( guidGetAcceptExSockAddrs ),
                  &g_pfnGetAcceptExSockaddrs,
                  sizeof( g_pfnGetAcceptExSockaddrs ),
                  &cbReturned,
                  NULL,
                  NULL );

        //
        // Close temporary socket
        //

        closesocket( sTempSocket );

        if ( !g_pfnAcceptEx ||
             !g_pfnGetAcceptExSockaddrs ||
             !g_pfnTransmitFile ) {

            //
            // This is bad.
            //

            DBG_ASSERT(FALSE);

            ATQ_PRINTF(( DBG_CONTEXT,
                "Failed to get entry points AE %x TF %x GAE %x\n",
                g_pfnAcceptEx, g_pfnTransmitFile,
                g_pfnGetAcceptExSockaddrs));

            goto cleanup;
        }

    } else {

        ATQ_PRINTF((DBG_CONTEXT,
            "Error %d in LoadLibrary[mswsock.dll]\n",
            GetLastError()));
        goto cleanup;
    }

    return(TRUE);

cleanup:

    if ( g_hMSWsock != NULL ) {
        FreeLibrary( g_hMSWsock );
        g_hMSWsock = NULL;
    }

    return(FALSE);
} // I_AtqInitializeEntryPoints
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\dbgutil.h ===
/*++

   Copyright    (c)    1994-1996    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable
// begin_user_unmodifiable



/************************************************************
 *     Include Headers
 ************************************************************/

# include <pudebug.h>


//
//  Define the debugging constants
//

#define DEBUG_SIO                   0x10000000
#define DEBUG_TIMEOUT               0x20000000
#define DEBUG_ENDPOINT              0x40000000

#define DEBUG_ALLOC_CACHE           0x01000000
#define DEBUG_NOTIFICATION          0x02000000


// Use the default constants from pudebug.h

# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\timeout.cxx ===
/*++

   Copyright    (c)    1995-1997    Microsoft Corporation

   Module  Name :
        timeout.cxx

   Abstract:
        This module contains code for timeout processing of ATQ contexts

   Author:

       Murali R. Krishnan    ( MuraliK )     16-July-1997 

   Environment:
       Win32 - User Mode
       
   Project:
       Internet Server - Asynchronous Thread Queue Module

   Functions Exported:



   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

#include "isatq.hxx"


/************************************************************
 * Globals
 ************************************************************/

DWORD   g_dwTimeoutCookie = 0; // Scheduler Cookie for timeout processing

DWORD   g_AtqCurrentTick = 1;

DWORD g_dwTimeout = ATQ_TIMEOUT_INTERVAL;  // active timeout value

/************************************************************
 *    Functions 
 ************************************************************/



BOOL
I_TimeOutContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:
    
    This function does the actual timeout for a particular context.
    Note: The Context list lock is held while processing this function

Arguments:

    Context - Pointer to the context to be timed out

Return value:

    TRUE, if the completion routine was called
    FALSE, otherwise

--*/
{

    DWORD timeout;

    //
    //  Call client after re-checking that this item
    //  really has timed out

    //
    // Fake timeout
    //

    if ( pAtqContext->TimeOut == ATQ_INFINITE ) {
        pAtqContext->NextTimeout = ATQ_INFINITE;
        return(FALSE);
    }

    //
    // Was our timeout long enough?
    //

    // NYI: Optimize: CanonTimeout should be called only once per IO submitted
    timeout = CanonTimeout( pAtqContext->BytesSent/g_cbMinKbSec);
    if ( timeout > pAtqContext->TimeOut ) {

        //
        // Reset the Timeout value based on the bytes to be sent
        // as well as update the time when this pAtqContext be timedout
        //

        pAtqContext->TimeOut = timeout;
        pAtqContext->NextTimeout = AtqGetCurrentTick( ) + timeout;
        return(FALSE);
    }

    //
    // If this is on blocked list, remove it.
    //

    if ( pAtqContext->IsBlocked()) {
        PBANDWIDTH_INFO pBandwidthInfo = pAtqContext->m_pBandwidthInfo;
        ATQ_ASSERT( pBandwidthInfo != NULL );
        ATQ_REQUIRE( pBandwidthInfo->RemoveFromBlockedList(pAtqContext));
    }

    //
    //  If we've already indicated this connection to the client,
    //  then we abort them by calling their IO completion routine
    //  and letting them cleanup.  Otherwise we close the socket
    //  which will generally cause an IO aborted completion that
    //  we will cleanup.  Note there is a window where we may
    //  close the socket out from under a client in their
    //  connection completion routine but that should be ok.
    //

    if ( pAtqContext->pfnCompletion &&
         pAtqContext->IsFlag( ACF_CONN_INDICATED)) {

        //
        //  TransmitFile socket state will be unconnected because
        //  we're expecting it to complete successfully.  Reset the
        //  state so the socket gets cleaned up properly
        //

        if ( pAtqContext->IsState( ACS_SOCK_UNCONNECTED) ) {
            pAtqContext->MoveState( ACS_SOCK_CONNECTED);
        }

        AcIncrement( CacAtqContextsTimedOut);

        pAtqContext->NextTimeout = ATQ_INFINITE;

        pAtqContext->IOCompletion( 0, ERROR_SEM_TIMEOUT, NULL);

        //
        //  We can't touch any items on the list after notifying
        //  the client as the client may have re-entered
        //  and freed some items from the list
        //

        return(TRUE);

    } else {

        HANDLE hIO;

        hIO = (HANDLE ) InterlockedExchangePointer(
                                    (PVOID *)&pAtqContext->hAsyncIO,
                                    NULL
                                    );

        IF_DEBUG( TIMEOUT) {
            ATQ_PRINTF(( DBG_CONTEXT,
                         "Timeout: closesocket(%d) Context=%08x\n",
                         hIO, pAtqContext));
        }
        closesocket( HANDLE_TO_SOCKET(hIO) );
    }

    return(FALSE); // we can touch the items on current list.

} // I_TimeOutContext




VOID
AtqProcessTimeoutOfRequests(
    PATQ_CONTEXT_LISTHEAD ContextList
    )
/*++

Routine Description:

    Walks the list of Atq clients looking for any item that has timed out and
    notifies the client if it has.

    TimeOutScanID is used as a serial number to prevent evaluating the same
    context twice.  We start from the beginning of the list everytime we
    notify a client an Atq context has timed out.  We do this because the
    client timeout processing may remove any number of Items from the
    list (including the next couple of items in the list).

    This routine also checks to make sure outstanding AcceptEx sockets
    haven't been exhausted (if less then 25% available, adds some more).

--*/
{
    DWORD                  newLatest = ATQ_INFINITE;
    BOOL                   fRescan;

    //
    // See if the latest one is timed-out
    //

    if ( ContextList->LatestTimeout > AtqGetCurrentTick( ) ) {

        return;
    }

    // set the latest timeout in the context list,
    // to avoid races with IO being started.
    ContextList->LatestTimeout = ATQ_INFINITE;

    //
    //  Scan the timeout list looking for items that have timed out
    //  and adjust the timeout values
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        ContextList->Lock( );

        fRescan = FALSE;

        for ( pentry  = ContextList->ActiveListHead.Flink;
              pentry != &ContextList->ActiveListHead;
              pentry  = pentryNext ) {

            PATQ_CONT              pContext;

            pentryNext = pentry->Flink;

            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            pContext->TimeOutScanID = scanId;

            //
            // If there is an IO which has popped up now,
            //  we have to do nothing. This code was added to protect catapult!
            //
            pContext->SetFlag( ACF_IN_TIMEOUT);

            if ( !pContext->lSyncTimeout) {

                // no body is using this context. Check and synchronize
                // the timeout state.

                //
                //  The client specifies the IO doesn't timeout if
                //  INFINITE is in the TimeOut field of the ATQ context
                //  If we've timed out, then notify the client.
                //

                DWORD nextTimeout = pContext->NextTimeout;
                if ( nextTimeout > AtqGetCurrentTick() ) {


                    // pick up the latest "low" value for
                    // firing next timeout thread
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                } else if ( I_TimeOutContext(pContext) ) {

                    // we are done checking and processing timeout.
                    // reset the In Timeout flag
                    pContext->ResetFlag( ACF_IN_TIMEOUT);
                    fRescan = TRUE;
                    break;
                } else {

                    //
                    // It is possible that the timeout got reset
                    // Check for the latest "low" value
                    //
                    nextTimeout = pContext->NextTimeout;
                    if ( nextTimeout < newLatest ) {
                        newLatest = nextTimeout;
                    }
                }

            } else {
                AcIncrement( CacAtqProcWhenTimeout);
            }

            // we are done checkin and processing timeouts.
            // reset the In Timeout flag
            pContext->ResetFlag( ACF_IN_TIMEOUT);

        } // scan list

        // let other system threads also run happily for a while
        ContextList->Unlock( );

    } while (fRescan);

    if ( newLatest != ATQ_INFINITE) {
        // We picked up the latest timeout. store it.
        ContextList->LatestTimeout = newLatest;
    }

    return;

} // AtqProcessTimeoutOfRequests




//
// ACCEPT_EX_TIMEOUT_STATS collects statistics for the 
//   timeout processing in the Pending AcceptEx List//  
//
struct ACCEPT_EX_TIMEOUT_STATS {

    DWORD  m_nScanned;
    DWORD  m_nTimedOut;
    DWORD  m_nSkipped;
    DWORD  m_nConnected;
    DWORD  m_nNotConnected;
};


BOOL
I_TimeOutPendingAcceptExContext(
    PATQ_CONT pAtqContext
    )
/*++

Routine Description:
    
    This function does the actual timeout for a pending AcceptEx context.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out

Return value:

    TRUE, if a tmieout operation was conducted.
    FALSE, otherwise

--*/
{
    DBG_ASSERT( pAtqContext != NULL);

    //
    // in the shutdown case it is possible that someone closed this socket already
    // so don't worry about it.
    //
    if ( pAtqContext->hAsyncIO == NULL ) {
        return TRUE;
    }
    
    //
    // Validate our assumptions about this Pending AcceptEx Context
    // there is an endpoint => AcceptEx context
    DBG_ASSERT( pAtqContext->pEndpoint != NULL);
    DBG_ASSERT( pAtqContext->IsState( ACS_SOCK_LISTENING));
    DBG_ASSERT( !pAtqContext->IsFlag( ACF_CONN_INDICATED));
    DBG_ASSERT( pAtqContext->TimeOut != ATQ_INFINITE);
    

    //
    // We will obtain the socket handle stored inside the AcceptEx Context
    //    and free up the context.
    // Warning:
    //   The AcceptEx socket did not have a connection when this function
    //   was called. However now between the time when the state was checked 
    //   and the time this timeout operation completes, it is possible that
    //   a new connection is bound to this AcceptEx context => we can get IO completion.
    //   I need to handle this case
    //

    HANDLE hIO;

    hIO = (HANDLE ) InterlockedExchangePointer(
                       (PVOID *)&pAtqContext->hAsyncIO,
                       NULL
                       );

    IF_DEBUG( TIMEOUT) {
        ATQ_PRINTF(( DBG_CONTEXT,
                     "TimeoutPendingAcceptExContext(%08x): closesocket(%d)\n",
                      pAtqContext, hIO));
    }

    closesocket( HANDLE_TO_SOCKET(hIO) );

    return ( TRUE);
} // I_TimeOutPendingAcceptExContext()


BOOL
I_IsTimeoutForAcceptExContext( 
    IN OUT PATQ_CONT                  pAtqContext, 
    IN OUT ACCEPT_EX_TIMEOUT_STATS  * pAetStats,
    OUT BOOL *                        pfIsConnected
    )
/*++

Routine Description:
    
    This function checks to see if timeout operation has to be performed
    for a given AtqContext. It bases the decision on the a variety of 
    details maintained in Atq Context and the Endpoint.
    Note: The Context list lock is held while processing this function

Arguments:

    pAtqContext - Pointer to the context to be timed out
    pAetStats   - pointer to AcceptEx Timeout Statistics structure
    pfIsConnected - Set to TRUE if socket is connected to, but we're still
                    waiting for data.  Such contexts are prime candidated
                    to be forcibly timed out by backlog monitor

Return value:

    TRUE, if a tmieout operation has to be conducted.
    FALSE, when no timeout is required.

--*/
{
    DBG_ASSERT( pAtqContext);
    DBG_ASSERT( pAetStats);
    
    PATQ_ENDPOINT  pEndpoint;
    pEndpoint = pAtqContext->pEndpoint;

    *pfIsConnected = FALSE;
    
    if ( pEndpoint != NULL) {
        
        //
        // We will use getsockopt() to query the connection status
        //  for the socket inside the Atq context.
        // If Socket is not connected => leave it in the pool
        // If Socket is connected and waiting for receive operation =>
        //        do timeout processing
        //
        // The goal is to maintain a pool of sockets in listening state
        //  so that any new connection will be picked up quickly.
        //
        // getsockopt() is a very costly function.
        // We check to see if we have enough sockets available
        //  for an endpoint. If they are, then we bypass calling getsockopt
        // "enough" is defined as # of available sockets is at least
        //   25% of the total # of accept ex sockets outstanding.
        // Optimize calling getsockopt() based on
        //   current count in pEndpoint->nAvailDuringTimeOut
        //
        
        if ( pEndpoint->nAvailDuringTimeOut >
             ( pEndpoint->nAcceptExOutstanding >> 2)
             ) {
            
            // Already enough Contexts are available.
            //  Do nothing
            pAetStats->m_nSkipped++;
            
            return (FALSE); // Do not timeout
        }

        DWORD dwConnect;
        int   cbOptLen = sizeof( dwConnect );
        
        //
        // Query the socket layer if the current socket has a valid connection
        // An AcceptEx socket can be connected and waiting for new request to 
        //   be read. If we are in such state we should not blow away context.
        //
        if ( getsockopt(HANDLE_TO_SOCKET(pAtqContext->hAsyncIO),
                        SOL_SOCKET,
                        SO_CONNECT_TIME,
                        (char *) &dwConnect,
                        &cbOptLen ) != SOCKET_ERROR
             ) {
            
            //
            //  A return value of 0xFFFFFFFF indicates that the given
            //   AcceptEx socket is not connected yet.
            //  Otherwise the socket is connected and is probably wating
            //   for request to be read or maybe a completion is already
            //   on its way.
            //
            
            if ( dwConnect == (DWORD) 0xFFFFFFFF ) {

                //
                //  Ignore the "Listen" socket context
                //
                
                pAetStats->m_nNotConnected++;
                
                DBG_ASSERT( NULL != pEndpoint);
                pEndpoint->nAvailDuringTimeOut++;

                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;
                
                return ( FALSE);  // Do not timeout
            }
            else if ( !pAtqContext->IsFlag(ACF_WINSOCK_CONNECTED) ) {

                *pfIsConnected = TRUE;
                
                //
                // Mark that this context has connection indicated.
                // If this context waits around in connected state for
                //  long-time we need to blow the context away.
                //
                
                pAetStats->m_nConnected++;
                
                // Update timeout values to give a breather interval
                pAtqContext->NextTimeout =
                    AtqGetCurrentTick() + pAtqContext->TimeOut;
                
                pAtqContext->SetFlag(ACF_WINSOCK_CONNECTED);
                
                return (FALSE); // do not timeout now
            }
        }
    } // if Endpoint exists

    return (TRUE); // yes timeout this context
} // I_IsTimeoutForAcceptExContext()


VOID
I_AtqProcessPendingListens(
    IN PATQ_CONTEXT_LISTHEAD pContextList,
    IN PATQ_ENDPOINT         pEndpoint,
    OUT PDWORD               pcForced
    )
/*++

Routine Description:

    Walks the list of Pending accept ex and makes sure none has timed out.
    Also checks to see if we need to allocate more AcceptEx sockets.

  Arguments:
    pContextList - pointer to ATQ_CONTEXT_LISTHEAD object
    pEndpoint - pointer to ATQ_ENDPOINT object.  If set, then only those
                ATQ_CONTEXTs whose endpoint matches will be timed out.
                If pEndpoint=NULL, then all ATQ_CONTEXTs will be timed out.
    pcForced - If pEndpoint!=NULL, then this is set to # of forced sockets

  Returns:
    None

--*/
{
    BOOL                    fRescan;
    BOOL                    fForceTimeout = ( pEndpoint != NULL );
    BOOL                    fIsConnected = FALSE;

    if ( fForceTimeout )
    {
        *pcForced = 0;
    }

    ACCEPT_EX_TIMEOUT_STATS AetStats;

    //
    // Initialize Statistics block
    //
    AetStats.m_nScanned         = 0;
    AetStats.m_nTimedOut        = 0;
    AetStats.m_nSkipped         = 0;
    AetStats.m_nConnected       = 0;
    AetStats.m_nNotConnected    = 0;
   
    //
    //  Look through the listening sockets to make sure the AcceptEx sockets
    //  haven't been exhausted
    //

    do {

        LIST_ENTRY *           pentry;
        LIST_ENTRY *           pentryNext;
        DWORD                  scanId = AtqGetCurrentTick( );

        fRescan = FALSE;

        pContextList->Lock();

        for ( pentry  = pContextList->PendingAcceptExListHead.Flink;
              pentry != &pContextList->PendingAcceptExListHead;
              pentry  = pentryNext ) {

            PATQ_CONT      pContext;

            pentryNext = pentry->Flink;
            pContext = CONTAINING_RECORD(
                                pentry,
                                ATQ_CONTEXT,
                                m_leTimeout
                                );

            if ( pContext->Signature != ATQ_CONTEXT_SIGNATURE ) {
                DBG_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
                break;
            }

            //
            //  Use PATQ_ENDPOINT filter if necessary
            //
            
            if ( pEndpoint && ( pEndpoint != pContext->pEndpoint ) )
            {
                continue;
            }

            //
            //  Ignore items we've already processed
            //

            if ( pContext->TimeOutScanID == scanId ) {
                continue;
            }

            AetStats.m_nScanned++;
            pContext->TimeOutScanID = scanId;

            //
            // If the context has Timeout value smaller than the one in our global tick
            //  then examine if this context can be timedout
            //

            DBG_CODE( if ( pContext->IsAcceptExRootContext()) 
                        { 
                            DBG_ASSERT( pContext->TimeOut == ATQ_INFINITE); 
                            DBG_ASSERT( pContext->NextTimeout == ATQ_INFINITE); 
                        }
                        );

            if ( pContext->NextTimeout <= AtqGetCurrentTick() ||
                 fForceTimeout ) {
                
                //
                // Protect against the race with the normal IO completion
                //
                pContext->SetFlag( ACF_IN_TIMEOUT);

                if ( !pContext->lSyncTimeout ) {
                    
                    if ( !I_IsTimeoutForAcceptExContext( pContext, 
                                                         &AetStats,
                                                         &fIsConnected )) {
                        
                        if ( !fForceTimeout || !fIsConnected )
                        { 
                            pContext->ResetFlag( ACF_IN_TIMEOUT);
                            continue;
                        }
                    }
                    
                    if ( I_TimeOutPendingAcceptExContext(pContext)) {
                        AetStats.m_nTimedOut++;
                        pContext->ResetFlag(ACF_IN_TIMEOUT);
                        
                        if ( fForceTimeout )
                        {
                            (*pcForced)++;
                        }
                        fRescan = TRUE;
                        break;
                    }
                } // if (!pContext->lSyncTimeout)

                pContext->ResetFlag( ACF_IN_TIMEOUT);
            } // if the context's timeout value <= CurrentTick
            else {
            
                //
                // Timeout value has not been reached. Skip this context
                //
                
                AetStats.m_nSkipped++;
           }
        } // scan list

        pContextList->Unlock();

    } while (fRescan);

    IF_DEBUG( TIMEOUT) {
       DBGPRINTF(( DBG_CONTEXT,
                   "TimeoutPendingListens( CtxtList[%d], AtqTick=%d)\n"
                   " Contexts Scanned=%d, Skipped=%d, TimedOut=%d,"
                   " Connected=%d, NotConnected=%d\n",
                   pContextList - AtqActiveContextList, AtqGetCurrentTick(), 
                   AetStats.m_nScanned, AetStats.m_nSkipped, 
                   AetStats.m_nTimedOut, AetStats.m_nConnected, 
                   AetStats.m_nNotConnected
                ));
    }    

# ifdef IIS_AUX_COUNTERS 
    g_AuxCounters[CacAtqPendingAcceptExScans] += AetStats.m_nScanned;
# endif // IIS_AUX_COUNTERS
                
    return;

} // I_AtqProcessPendingListens()




VOID
I_AtqCheckEndpoints(
            VOID
            )
/*++
  Description:
    This function checks all the listen info objects and adds appropriate
     number of accept ex sockets as necessary.

  Arguments:
    None

  Returns:
    None
--*/
{
    LIST_ENTRY *  pEntry;
    PATQ_ENDPOINT pEndpoint;

    AcquireLock( &AtqEndpointLock);

    for ( pEntry  = AtqEndpointList.Flink;
          pEntry != &AtqEndpointList;
          pEntry  = pEntry->Flink ) {

        pEndpoint = CONTAINING_RECORD(
                                    pEntry,
                                    ATQ_ENDPOINT,
                                    ListEntry
                                    );

        DBG_ASSERT( pEndpoint->Signature == ATQ_ENDPOINT_SIGNATURE );

        DBG_ASSERT( pEndpoint->nSocketsAvail >= 0);
        
        //
        // Check to make sure outstanding AcceptEx sockets
        // haven't been exhausted (if less then 25% available, adds some more).
        //

        if ( ((DWORD ) pEndpoint->nSocketsAvail) <
             (pEndpoint->nAcceptExOutstanding >> 2) ) {

            IF_DEBUG( TIMEOUT ) {
                DBGPRINTF(( DBG_CONTEXT,
                            "[Timeout] Adding AcceptEx Contexts for EP=%08x; nAvail = %d;\n",
                            pEndpoint, pEndpoint->nSocketsAvail));
            }

            (VOID ) I_AtqPrepareAcceptExSockets(pEndpoint,
                                                pEndpoint->nAcceptExOutstanding
                                                );
        }

        //
        // set to zero, so recount will be done during next timeout loop
        //

        pEndpoint->nAvailDuringTimeOut = 0;
    }

    ReleaseLock( &AtqEndpointLock);

    return;
} // I_AtqCheckEndpoints



VOID
I_AtqTimeOutWorker(VOID)
/*++
  Description:
    This function handles timeout processing using the simple
    clock algorithm, wherein partial set of lists are scanned
    during each timeout processing call.

  Arguments:
    None


  Returns:
    None
--*/
{
    DWORD start;
    PATQ_CONTEXT_LISTHEAD pContextList;

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT, "TimeoutWorker: entered\n"));
    }

    start = (AtqGetCurrentTick() & 0x1);

    for ( pContextList = AtqActiveContextList + start;
          pContextList < (AtqActiveContextList + g_dwNumContextLists) ;
          pContextList += 2 ) {

        IF_DEBUG(TIMEOUT) {
            DBGPRINTF((DBG_CONTEXT,
                       "TimeoutWorker: Processing list[%d] = %08x\n",
                       (pContextList - AtqActiveContextList),
                       pContextList));
        }

        AtqProcessTimeoutOfRequests( pContextList );
        I_AtqProcessPendingListens( pContextList, NULL, NULL );
    } // for

    if ( start != 0 ) {
        I_AtqCheckEndpoints( );
    }

    return;

} // I_AtqTimeOutWorker()




VOID
WINAPI
I_AtqTimeoutCompletion(
    IN PVOID Context
    )
/*++

Routine Description:

    Callback routine for the scheduled version of the timeout thread.

    The callback assumes timeouts are rounded to ATQ_TIMEOUT_INTERVAL

    In addition to timing out requests when necessary, the timeout thread
     also performs the job of bandwidth calculation and tuning the bandwidth
     throttle operation (which works on feedback mechanism).
    At every sampling interval the scheduled callback comes in and it updates
     the bandwidth.

Arguments:

    Context - Context returned by the scheduler thread.

Return Value:

    none.

--*/
{
    DWORD Timeout = ATQ_TIMEOUT_INTERVAL;
    BOOL  fDoContextTimeout = TRUE;

    if ( g_fShutdown ) {

        ATQ_PRINTF(( DBG_CONTEXT,
            "Detected a shutdown while entering timeout callback\n"));
        return;
    }

    InterlockedIncrement( (PLONG)&g_AtqCurrentTick );

    //
    //  Perform necessary steps to handle Bandwidth throttling.
    //

    ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout >= 1);

    IF_DEBUG(TIMEOUT) {
        DBGPRINTF((DBG_CONTEXT,
                 "Timeout: BANDWIDTH_INFO::cSamplesForTimeout=%d\n",
                 BANDWIDTH_INFO::sm_cSamplesForTimeout ));
    }

    if ( BANDWIDTH_INFO::GlobalActive() ) {

        --(BANDWIDTH_INFO::sm_cSamplesForTimeout);

        // Perform a sampling to update measured bandwidth +
        //  apply feedback policy

        BANDWIDTH_INFO::UpdateAllBandwidths();

        Timeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        if ( BANDWIDTH_INFO::sm_cSamplesForTimeout != 0) {

            // We have not reached timeout yet. So skip context timeouts

            fDoContextTimeout = FALSE;
        } else {

            // We had reached the timeout interval for requests.
            // Examine and release requests.
            ATQ_ASSERT( BANDWIDTH_INFO::sm_cSamplesForTimeout == 0);

            // reset the count of samples before proceeding.
            BANDWIDTH_INFO::sm_cSamplesForTimeout = NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
        }
    } else {
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    //
    // We are at a Timeout Interval. Examine and timeout requests.
    //

    if ( fDoContextTimeout ) {
        I_AtqTimeOutWorker();
    }

    if ( Timeout != g_dwTimeout) {

        // the scheduled interval is different from this current interval
        // Inidicate the changed timeout value to the scheduler

        ScheduleAdjustTime( g_dwTimeoutCookie, TimeToWait(Timeout));
        g_dwTimeout = Timeout;
    }

    return;
} // I_AtqTimeoutCompletion




BOOL
I_AtqStartTimeoutProcessing(
    IN PVOID Context
    )
/*++

Routine Description:

    Starts the timeout processing. It always uses the scheduler to schedule
    a timeout operation.

    Note: The scheduler should be initialized before getting to this function.

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{
    ATQ_ASSERT( ATQ_SAMPLE_INTERVAL_IN_SECS < ATQ_TIMEOUT_INTERVAL );

    if ( BANDWIDTH_INFO::GlobalEnabled() ) {
        g_dwTimeout = ATQ_SAMPLE_INTERVAL_IN_SECS;
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 
            NUM_SAMPLES_PER_TIMEOUT_INTERVAL;
    } else {
        g_dwTimeout = ATQ_TIMEOUT_INTERVAL;
        BANDWIDTH_INFO::sm_cSamplesForTimeout = 1;
    }

    g_dwTimeoutCookie =
        ScheduleWorkItem(
                         I_AtqTimeoutCompletion,
                         Context,
                         TimeToWait(g_dwTimeout)
                         , TRUE  // ask for periodic timeout
                         );

    if ( g_dwTimeoutCookie == 0 ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "Error %d scheduling timeout\n",GetLastError()));
        return(FALSE);
    }

    return(TRUE);

} // I_AtqStartTimeoutProcessing()



BOOL
I_AtqStopTimeoutProcessing(
    VOID
    )
/*++

Routine Description:

    Stops the timeout processing. It terminates the scheduled workitem and 
    cleans up any state.

    Note: The scheduler should be terminated only after this call

Arguments:

    Context - Context passed to the thread creation or scheduler thread.

Return Value:

    TRUE, if ok
    FALSE, otherwise

--*/
{
    DBGPRINTF(( DBG_CONTEXT, "I_AtqStopTimeoutProcessing\n"));

    if ( 0 != g_dwTimeoutCookie) {
        DBG_REQUIRE( RemoveWorkItem( g_dwTimeoutCookie ));
        g_dwTimeoutCookie = 0;
    }

    return ( TRUE);

} // I_AtqStopTimeoutProcessing()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\atq\oplock\spud.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

      spud.cxx

   Abstract:
      This module implements the user mode entry points for SPUD.SYS.
      SPUD = Special Purpose Utility Driver.

   Author:

       John Ballard ( jballard )     22-Oct-1996

   Environment:

       User Mode -- Win32

   Project:

       Internet Services Common DLL

   Functions Exported:

       BOOL  AtqTransmitFileAndRecv();
       BOOL  AtqSendAndRecv();
       BOOL  AtqBatchRequest();

--*/


#include "isatq.hxx"
#include <tdi.h>
#include <afd.h>
#include <spud.h>
#include "uspud.h"


// ------------------------------
// oplock notification thread stuff
// ------------------------------

#define KILL_OPLOCK_THREAD  ((LPOVERLAPPED)0xffeeffee)

HANDLE g_hOplockThread = NULL;

DWORD
WINAPI
I_AtqOplockThread(
    IN LPVOID Param
    );


VOID
EnableLoadDriverPrivilege(
    VOID
    );

#define SPUD_REG_PATH   \
    L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Spud"

BOOL
I_AtqSpudInitialize(
            IN HANDLE hIoPort,
            IN HANDLE hOplockPort
            )
{
    NTSTATUS    status;
    UNICODE_STRING  DriverName;
    DWORD   Version = SPUD_VERSION;

    if ( !g_fUseDriver ) {
        return(FALSE);
    }

    EnableLoadDriverPrivilege();

    g_pfnRtlInitUnicodeString( &DriverName, SPUD_REG_PATH );
    status = g_pfnNtLoadDriver( &DriverName );
    if ( ( status != STATUS_SUCCESS ) &&
         ( status != STATUS_IMAGE_ALREADY_LOADED ) ) {

        ATQ_PRINTF(( DBG_CONTEXT,
                     "NtLoadDriver failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    status = SPUDInitialize(Version, hIoPort, hOplockPort);
    if ( status != STATUS_SUCCESS ) {

        if ( status == STATUS_INVALID_DEVICE_REQUEST ) {
            SPUDTerminate();
            if ( SPUDInitialize(Version, hIoPort, hOplockPort) == STATUS_SUCCESS ) {
                return TRUE;
            }
        }

        ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDInitialize failed!!! status == %08lx\n",
                     status
                     ));
        goto disable_driver;
    }

    return TRUE;

disable_driver:

    g_fUseDriver = FALSE;

    ATQ_PRINTF((DBG_CONTEXT, "SPUDInitialize: Disabling driver\n"));
    return(FALSE);
} // I_AtqSpudInitialize


BOOL
I_AtqSpudTerminate()
{
    NTSTATUS    status;

    status = SPUDTerminate();
    if ( status != STATUS_SUCCESS ) {

        IF_DEBUG(ERROR) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDTerminate failed!!! status == %08lx\n",
                     status
                     ));
        }
        return FALSE;
    }

    return TRUE;
}

BOOL
I_AtqSpudCheckStatus(
    IN PATQ_CONT                patqContext             // pointer to ATQ context
    )
{
        ULONG status;

        status = SPUDCheckStatus( &patqContext->spudContext );

        if ( status != STATUS_SUCCESS ) {
                return FALSE;
        }

        return TRUE;
}

BOOL
I_AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
/*++
Routine Description:

    Calls SPUDTransmitFileAndRecv().  Cannot be blocked by bandwidth throttler

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_TRANSMIT_FILE_INFO transmitInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                     "I_AtqTransmitFileAndRecv(%08lx) called.\n", patqContext));
        }

        transmitInfo.WriteLength.QuadPart = dwBytesInFile;
        transmitInfo.SendPacketLength = 0;
        transmitInfo.FileHandle = hFile;
        transmitInfo.Flags = dwTFFlags;
        if ( lpTransmitBuffers != NULL ) {
            transmitInfo.Head = lpTransmitBuffers->Head;
            transmitInfo.HeadLength = lpTransmitBuffers->HeadLength;
            transmitInfo.Tail = lpTransmitBuffers->Tail;
            transmitInfo.TailLength = lpTransmitBuffers->TailLength;
        } else {
            transmitInfo.Head = NULL;
            transmitInfo.HeadLength = 0;
            transmitInfo.Tail = NULL;
            transmitInfo.TailLength = 0;
        }

        transmitInfo.Offset.LowPart = patqContext->Overlapped.Offset;
        transmitInfo.Offset.HighPart = 0;

        recvInfo.BufferArray = pwsaBuffers;
        recvInfo.BufferCount = dwBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        status = SPUDTransmitFileAndRecv( patqCont->hAsyncIO,
                                         &transmitInfo,
                                         &recvInfo,
                                         &patqCont->spudContext
                                         );

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                         "SPUDTransmitFileAndRecv failed!!! status == %08lx\n",
                         status
                         ));
            SetLastError(g_pfnRtlNtStatusToDosError(status));
            patqCont->MoveState( ACS_SOCK_CONNECTED);
            return FALSE;
        }

        patqCont->SetFlag( ACF_RECV_ISSUED);

        return TRUE;
}

BOOL
AtqTransmitFileAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN HANDLE                   hFile,                  // handle of file to read
    IN DWORD                    dwBytesInFile,          // Bytes to transmit
    IN LPTRANSMIT_FILE_BUFFERS  lpTransmitBuffers,      // transmit buffer structure
    IN DWORD                    dwTFFlags,              // TF Flags
    IN LPWSABUF                 pwsaBuffers,            // Buffers for recv
    IN DWORD                    dwBufferCount
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {
        BOOL            fRes;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                "AtqTransmitFileAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqTransmitFile.\n", patqContext));
        }

        return AtqTransmitFile( patqContext,
                                hFile,
                                dwBytesInFile,
                                lpTransmitBuffers,
                                dwTFFlags );
    }

    I_SetNextTimeout(pContext);

    pContext->BytesSent = dwBytesInFile;

    DBG_ASSERT( dwBufferCount >= 1);
    pContext->BytesSent += pwsaBuffers->len;
    if ( dwBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaBuffers + 1;
              pWsaBuf <= (pwsaBuffers + dwBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    if ( dwTFFlags == 0 ) {

        //
        // If no flags are set, then we can attempt to use the special
        // write-behind flag.  This flag can cause the TransmitFile to
        // complete immediately, before the send actually completes.
        // This can be a significant performance improvement inside the
        // system.
        //

        dwTFFlags = TF_WRITE_BEHIND;

    }

    InterlockedIncrement( &pContext->m_nIO);

    switch ( pBandwidthInfo->QueryStatus( AtqIoXmitFileRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqTransmitFileAndRecv( patqContext,
                                         hFile,
                                         dwBytesInFile,
                                         lpTransmitBuffers,
                                         dwTFFlags,
                                         pwsaBuffers,
                                         dwBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoXmitFileRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;

        pContext->arInfo.uop.opXmitRecv.hFile = hFile;
        pContext->arInfo.uop.opXmitRecv.dwBytesInFile = dwBytesInFile;
        pContext->arInfo.uop.opXmitRecv.lpXmitBuffers = lpTransmitBuffers;
        pContext->arInfo.uop.opXmitRecv.dwTFFlags     = dwTFFlags;
        pContext->arInfo.uop.opXmitRecv.dwBufferCount = dwBufferCount;

        if ( dwBufferCount == 1) {
            pContext->arInfo.uop.opXmitRecv.buf1.len = pwsaBuffers->len;
            pContext->arInfo.uop.opXmitRecv.buf1.buf = pwsaBuffers->buf;
            pContext->arInfo.uop.opXmitRecv.pBufAll  = NULL;
        } else {

            DBG_ASSERT( dwBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opXmitRecv.pBufAll = pBuf;
                CopyMemory( pBuf, pwsaBuffers,
                            dwBufferCount * sizeof(WSABUF));
            } else {
                return ( FALSE);
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqTransmitFileAndRecv()

BOOL
I_AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
/*++
Routine Description:

    Calls SPUDSendAndRecv().  Cannot be blocked by bandwidth throttler.

Return Value:

    TRUE if successful, FALSE on error (call GetLastError)
--*/
{
        ULONG   status;
        AFD_SEND_INFO          sendInfo;
        AFD_RECV_INFO          recvInfo;
        PATQ_CONT              patqCont = (PATQ_CONT)patqContext;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "I_AtqSendAndRecv(%08lx) called.\n", patqContext));
        }

        sendInfo.BufferArray = pwsaSendBuffers;
        sendInfo.BufferCount = dwSendBufferCount;
        sendInfo.AfdFlags = AFD_OVERLAPPED;
        sendInfo.TdiFlags = 0;

        recvInfo.BufferArray = pwsaRecvBuffers;
        recvInfo.BufferCount = dwRecvBufferCount;
        recvInfo.AfdFlags = AFD_OVERLAPPED;
        recvInfo.TdiFlags = TDI_RECEIVE_NORMAL;
        patqCont->ResetFlag( ACF_RECV_CALLED);

        status = SPUDSendAndRecv( patqCont->hAsyncIO,
                                 &sendInfo,
                                 &recvInfo,
                                 &patqCont->spudContext
                                 );

        if ( status != STATUS_SUCCESS &&
             status != STATUS_PENDING ) {

            ATQ_PRINTF(( DBG_CONTEXT,
                     "SPUDSendAndRecv failed!!! status == %08lx\n",
                     status
                     ));
             SetLastError(g_pfnRtlNtStatusToDosError(status));
             return FALSE;
        }

        patqCont->SetFlag( ACF_RECV_ISSUED);

        return TRUE;
}

BOOL
AtqSendAndRecv(
    IN PATQ_CONTEXT             patqContext,            // pointer to ATQ context
    IN LPWSABUF                 pwsaSendBuffers,        // buffers for send
    IN DWORD                    dwSendBufferCount,      // count of buffers for send
    IN LPWSABUF                 pwsaRecvBuffers,        // Buffers for recv
    IN DWORD                    dwRecvBufferCount       // count of buffers for recv
    )
{
    BOOL fRes;
    PATQ_CONT pContext = (PATQ_CONT) patqContext;
    PBANDWIDTH_INFO pBandwidthInfo = pContext->m_pBandwidthInfo;

    ATQ_ASSERT( pContext->Signature == ATQ_CONTEXT_SIGNATURE );
    ATQ_ASSERT( pContext->arInfo.atqOp == AtqIoNone);
    ATQ_ASSERT( pBandwidthInfo != NULL );
    ATQ_ASSERT( pBandwidthInfo->QuerySignature() == ATQ_BW_INFO_SIGNATURE );

    IF_DEBUG(API_ENTRY) {
        ATQ_PRINTF(( DBG_CONTEXT,
            "AtqSendAndRecv(%08lx) called.\n", patqContext));
    }

    if ( !g_fUseDriver || pContext->IsFlag( ACF_RECV_ISSUED) ) {

        BOOL            fRes;
        DWORD           cbWritten;

        IF_DEBUG(API_ENTRY) {
            ATQ_PRINTF(( DBG_CONTEXT,
                 "AtqSendAndRecv(%08lx) g_fUseDriver == FALSE\n Calling AtqWriteSocket.\n", patqContext));
        }

        return AtqWriteSocket( patqContext,
                               pwsaSendBuffers,
                               dwSendBufferCount,
                               &patqContext->Overlapped );
    }

    InterlockedIncrement( &pContext->m_nIO);

    I_SetNextTimeout(pContext);

    //
    // count the number of bytes
    //

    DBG_ASSERT( dwSendBufferCount >= 1);
    pContext->BytesSent = pwsaSendBuffers->len;
    if ( dwSendBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaSendBuffers + 1;
            pWsaBuf <= (pwsaSendBuffers + dwSendBufferCount);
            pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }


    DBG_ASSERT( dwRecvBufferCount >= 1);
    pContext->BytesSent += pwsaRecvBuffers->len;
    if ( dwRecvBufferCount > 1) {
        LPWSABUF pWsaBuf;
        for ( pWsaBuf = pwsaRecvBuffers + 1;
              pWsaBuf <= (pwsaRecvBuffers + dwRecvBufferCount);
              pWsaBuf++) {
            pContext->BytesSent += pWsaBuf->len;
        }
    }

    switch ( pBandwidthInfo->QueryStatus( AtqIoSendRecv ) )
    {
    case StatusAllowOperation:

        pBandwidthInfo->IncTotalAllowedRequests();

        fRes = I_AtqSendAndRecv( patqContext,
                                 pwsaSendBuffers,
                                 dwSendBufferCount,
                                 pwsaRecvBuffers,
                                 dwRecvBufferCount ) ||
                (GetLastError() == ERROR_IO_PENDING);

        if (!fRes) { InterlockedDecrement( &pContext->m_nIO); };

        break;

    case StatusBlockOperation:

        // store data for restarting the operation.
        pContext->arInfo.atqOp        = AtqIoSendRecv;
        pContext->arInfo.lpOverlapped = &pContext->Overlapped;
        pContext->arInfo.uop.opSendRecv.dwSendBufferCount = dwSendBufferCount;
        pContext->arInfo.uop.opSendRecv.dwRecvBufferCount = dwRecvBufferCount;

        if ( dwSendBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.sendbuf1.len = pwsaSendBuffers->len;
            pContext->arInfo.uop.opSendRecv.sendbuf1.buf = pwsaSendBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pSendBufAll  = NULL;
        } else {

            DBG_ASSERT( dwSendBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwSendBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pSendBufAll = pBuf;
                CopyMemory( pBuf, pwsaSendBuffers,
                            dwSendBufferCount * sizeof(WSABUF));
            } else {
                return ( FALSE);
            }
        }

        if ( dwRecvBufferCount == 1) {
            pContext->arInfo.uop.opSendRecv.recvbuf1.len = pwsaRecvBuffers->len;
            pContext->arInfo.uop.opSendRecv.recvbuf1.buf = pwsaRecvBuffers->buf;
            pContext->arInfo.uop.opSendRecv.pRecvBufAll = NULL;
        } else {

            DBG_ASSERT( dwRecvBufferCount > 1);

            WSABUF * pBuf = (WSABUF *)
            ::LocalAlloc( LPTR, dwRecvBufferCount * sizeof (WSABUF));
            if ( NULL != pBuf) {
                pContext->arInfo.uop.opSendRecv.pRecvBufAll = pBuf;
                CopyMemory( pBuf, pwsaRecvBuffers,
                            dwRecvBufferCount * sizeof(WSABUF));
            } else {
                return ( FALSE);
            }
        }

        // Put this request in queue of blocked requests.
        fRes = pBandwidthInfo->BlockRequest( pContext);
        if ( fRes )
        {
            pBandwidthInfo->IncTotalBlockedRequests();
            break;
        }
        // fall through

    case StatusRejectOperation:
        InterlockedDecrement( &pContext->m_nIO);
        pBandwidthInfo->IncTotalRejectedRequests();
        SetLastError( ERROR_NETWORK_BUSY);
        fRes = FALSE;
        break;

    default:
        ATQ_ASSERT( FALSE);
        SetLastError( ERROR_INVALID_PARAMETER);
        fRes = FALSE;
        break;

    } // switch()

    return fRes;
} // AtqSendAndRecv()




//
//  Short routine to enable the LoadDriverPrivilege for loading spud.sys
//

VOID EnableLoadDriverPrivilege(
    VOID
    )
{
    HANDLE ProcessHandle;
    HANDLE TokenHandle;
    BOOL Result;
    LUID LoadDriverValue;
    TOKEN_PRIVILEGES * TokenPrivileges;
    CHAR buf[ 5 * sizeof(TOKEN_PRIVILEGES) ];

    ProcessHandle = OpenProcess(
                        PROCESS_QUERY_INFORMATION,
                        FALSE,
                        GetCurrentProcessId()
                        );

    if ( ProcessHandle == NULL ) {

        //
        // This should not happen
        //

        goto Cleanup;
    }


    Result = OpenProcessToken (
                 ProcessHandle,
                 TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                 &TokenHandle
                 );

    if ( !Result ) {

        //
        // This should not happen
        //

        goto Cleanup;

    }

    //
    // Find out the value of LoadDriverPrivilege
    //


    Result = LookupPrivilegeValue(
                 NULL,
                 "SeLoadDriverPrivilege",
                 &LoadDriverValue
                 );

    if ( !Result ) {

        goto Cleanup;
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges = (TOKEN_PRIVILEGES *) buf;

    TokenPrivileges->PrivilegeCount = 1;
    TokenPrivileges->Privileges[0].Luid = LoadDriverValue;
    TokenPrivileges->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    (VOID) AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                TokenPrivileges,
                sizeof(buf),
                NULL,
                NULL
                );
Cleanup:

    if ( TokenHandle )
    {
        CloseHandle( TokenHandle );
    }

    if ( ProcessHandle )
    {
        CloseHandle( ProcessHandle );
    }
}

HANDLE
AtqCreateFileW(
    LPCWSTR lpFileName,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlagsAndAttributes,
    SECURITY_INFORMATION si,
    PSECURITY_DESCRIPTOR sd,
    ULONG Length,
    PULONG LengthNeeded,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
    )
{

    NTSTATUS Status;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    UNICODE_STRING FileName;
    IO_STATUS_BLOCK IoStatusBlock;
    BOOLEAN TranslationStatus;
    RTL_RELATIVE_NAME_U RelativeName;
    PVOID FreeBuffer;
    ULONG CreateFlags;
    DWORD SQOSFlags;
    SECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;
    POPLOCK_INFO pOplock;

    CreateFlags = 0;

//    DbgPrint("AtqCreateFileW - %ws\n", lpFileName );

    TranslationStatus = g_pfnRtlDosPathNameToNtPathName_U(
                            lpFileName,
                            &FileName,
                            NULL,
                            &RelativeName
                            );

    if ( !TranslationStatus ) {
        SetLastError(ERROR_PATH_NOT_FOUND);
        return INVALID_HANDLE_VALUE;
        }

    FreeBuffer = FileName.Buffer;

    if ( RelativeName.RelativeName.Length ) {
        FileName = RelativeName.RelativeName;
        }
    else {
        RelativeName.ContainingDirectory = NULL;
        }

    InitializeObjectAttributes(
        &Obja,
        &FileName,
        (dwFlagsAndAttributes & FILE_FLAG_POSIX_SEMANTICS) ? 0 : OBJ_CASE_INSENSITIVE,
        RelativeName.ContainingDirectory,
        NULL
        );


    if ( ARGUMENT_PRESENT(lpSecurityAttributes) ) {
        Obja.SecurityDescriptor = lpSecurityAttributes->lpSecurityDescriptor;
        if ( lpSecurityAttributes->bInheritHandle ) {
            Obja.Attributes |= OBJ_INHERIT;
            }
        }

    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_NO_BUFFERING ? FILE_NO_INTERMEDIATE_BUFFERING : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_WRITE_THROUGH ? FILE_WRITE_THROUGH : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_OVERLAPPED ? 0 : FILE_SYNCHRONOUS_IO_NONALERT );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_SEQUENTIAL_SCAN ? FILE_SEQUENTIAL_ONLY : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_RANDOM_ACCESS ? FILE_RANDOM_ACCESS : 0 );
    CreateFlags |= (dwFlagsAndAttributes & FILE_FLAG_BACKUP_SEMANTICS ? FILE_OPEN_FOR_BACKUP_INTENT : 0 );

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
        }
    } else {
        pOplock = NULL;
    }

    Status = SPUDCreateFile(
                &Handle,
                &Obja,
                &IoStatusBlock,
                dwFlagsAndAttributes & (FILE_ATTRIBUTE_VALID_FLAGS & ~FILE_ATTRIBUTE_DIRECTORY),
                dwShareMode,
                CreateFlags,
                si,
                sd,
                Length,
                LengthNeeded,
                pOplock
                );

    g_pfnRtlFreeHeap(RtlProcessHeap(), 0,FreeBuffer);

    if ( !NT_SUCCESS(Status) ) {
        if ( Status == STATUS_INVALID_PARAMETER ||
             Status == STATUS_OPLOCK_NOT_GRANTED ) {
             SetLastError(ERROR_INVALID_ACCESS);
             return Handle;
        }
        if ( Status == STATUS_FILE_IS_A_DIRECTORY ) {
            SetLastError(ERROR_ACCESS_DENIED);
        } else {
            SetLastError(g_pfnRtlNtStatusToDosError(Status));
        }
        return INVALID_HANDLE_VALUE;
    }

    SetLastError(ERROR_SUCCESS);
    return Handle;

}

BOOL
AtqOplockAcknowledge(
    IN HANDLE   FileHandle,
    ATQ_OPLOCK_COMPLETION pfnOplockCompletion,
    PVOID Context
)
{
    POPLOCK_INFO pOplock;
    NTSTATUS Status;

    if ( pfnOplockCompletion != NULL ) {
        pOplock = (POPLOCK_INFO)
        ::LocalAlloc( LPTR, sizeof(OPLOCK_INFO));
        if ( pOplock ) {
            pOplock->pfnOplockCompletion = pfnOplockCompletion;
            pOplock->Context = Context;
            Status = SPUDOplockAcknowledge(
                          FileHandle,
                          pOplock
                          );

            if ( Status == STATUS_SUCCESS ) {
                return TRUE;
            }

        }
    }
    return FALSE;

}

BOOL
AtqSpudInitialized(
    VOID
    )
{
    return g_fUseDriver;
}


BOOL
I_AtqStartOplockThread(
    VOID
    )
{

    //
    // Sanity check.
    //

    ATQ_ASSERT( g_fUseDriver );
    ATQ_ASSERT( g_hOplockCompPort != NULL );
    ATQ_ASSERT( g_hOplockThread == NULL );

    //
    // Create the thread. This thread will receive all oplock break
    // notifications from SPUD.
    //

    g_hOplockThread = CreateThread(
                          NULL,                 // lpThreadAttributes
                          0,                    // dwStackSize
                          &I_AtqOplockThread,   // lpStartAddress,
                          NULL,                 // lpParameter
                          0,                    // dwCreationFlags
                          NULL                  // lpThreadId
                          );

    if( g_hOplockThread == NULL ) {
        return FALSE;
    }

    return TRUE;

}   // I_AtqStartOplockThread


VOID
I_AtqKillOplockThread(
    VOID
    )
{

    BOOL result;

    //
    // Sanity check.
    //

    ATQ_ASSERT( g_fUseDriver );
    ATQ_ASSERT( g_hOplockCompPort != NULL );
    ATQ_ASSERT( g_hOplockThread != NULL );

    //
    // Post a special "kill yourself" notification to the oplock thread.
    //

    result = g_pfnPostCompletionStatus(
                 g_hOplockCompPort,
                 0,
                 0,
                 KILL_OPLOCK_THREAD
                 );

    if( result ) {

        //
        // Wait for the thread to die.
        //

        WaitForSingleObject( g_hOplockThread, INFINITE );

        CloseHandle( g_hOplockThread );
        g_hOplockThread = NULL;

    } else {
        ATQ_ASSERT( !"PostCompletionStatus() failed" );
    }

}   // I_AtqKillOplockThread


DWORD
WINAPI
I_AtqOplockThread(
    IN LPVOID Param
    )
{

    BOOL result;
    DWORD oplockStatus;
    LPOVERLAPPED overlapped;
    POPLOCK_INFO oplockInfo;
    OPLOCK_INFO capturedInfo;

    //
    // Sanity check.
    //

    ATQ_ASSERT( g_fUseDriver );
    ATQ_ASSERT( g_hOplockCompPort != NULL );
    ATQ_ASSERT( g_hOplockThread != NULL );

    //
    // Spin forever, or at least until we're shut down.
    //

    while( TRUE ) {

        //
        // Get the next entry from the queue.
        //

        result = g_pfnGetQueuedCompletionStatus(
                     g_hOplockCompPort,
                     &oplockStatus,
                     (LPDWORD)&oplockInfo,
                     &overlapped,
                     INFINITE
                     );

        if( result ) {

            //
            // Check for the special "kill yourself" notification.
            //

            if( overlapped == KILL_OPLOCK_THREAD ) {
                break;
            }

            //
            // Validate the return values.
            //

            ATQ_ASSERT( overlapped == NULL );
            ATQ_ASSERT( oplockInfo != NULL );
            ATQ_ASSERT( oplockStatus == OPLOCK_BREAK_NO_OPLOCK ||
                        oplockStatus == OPLOCK_BREAK_OPEN ||
                        oplockStatus == OPLOCK_BREAK_CLOSE );

            //
            // Capture the oplock info, then free the structure.
            //

            capturedInfo = *oplockInfo;
            LocalFree( oplockInfo );

            //
            // Call the oplock completion routine as specified in the
            // returned info structure.
            //

            (capturedInfo.pfnOplockCompletion)(
                capturedInfo.Context,
                oplockStatus
                );

        } else {

            //
            // GetQueuedCompletionStatus() failed. Bail.
            //

            DBGPRINTF((
                DBG_CONTEXT,
                "I_AtqOplockThread: GetQueuedCompletionStatus() failed, error %lu\n",
                GetLastError()
                ));

            ATQ_ASSERT( !"GetQueuedCompletionStatus() failed" );
            break;

        }

    }

    return 0;

}   // I_AtqOplockThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\blobcach.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    blobcach.cxx

    This module implements the private interface to the blob cache.

    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>
#include <tscache.hxx>
#include <dbgutil.h>
#include "tsmemp.hxx"
#include "blobcach.hxx"
#include "blobhash.hxx"

/*
 * Globals
 */
CBlobHashTable * g_pURITable;
CBlobHashTable * g_pBlobTable;
CBlobCacheStats * g_pURICacheStats;
CBlobCacheStats * g_pBlobCacheStats;

#if TSUNAMI_REF_DEBUG
PTRACE_LOG g_pBlobRefTraceLog;
#endif

/*
 * Private helper function declarations
 */
inline VOID DerefBlob(PBLOB_HEADER pBlob);
BOOL BlobFlushFilterAll(PBLOB_HEADER pBlob, PVOID pv);


#define CHECK_BLOB_TYPE(dmx)   DBG_ASSERT(                \
        RESERVED_DEMUX_DIRECTORY_LISTING         == (dmx) \
        || RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD == (dmx) \
        || RESERVED_DEMUX_URI_INFO               == (dmx) \
        || RESERVED_DEMUX_FILE_DATA              == (dmx) \
        || RESERVED_DEMUX_SSI                    == (dmx) \
        || RESERVED_DEMUX_QUERY_CACHE            == (dmx) \
        )



/*
 * function definitions
 */
BOOL
BlobCache_Initialize(
    VOID
    )
{
#if TSUNAMI_REF_DEBUG
    g_pBlobRefTraceLog = CreateRefTraceLog(
                            256,              // LogSize
                            0                 // ExtraBytesInHeader
                            );
#endif  // TSUNAMI_REF_DEBUG

    g_pURITable = new CBlobHashTable("uri");
    if (!g_pURITable) {
        goto error;
    }
    
    g_pBlobTable = new CBlobHashTable("blob");
    if (!g_pBlobTable) {
        goto error;
    }

    g_pURICacheStats = new CBlobCacheStats;
    if (!g_pURICacheStats) {
        goto error;
    }

    g_pBlobCacheStats = new CBlobCacheStats;
    if (!g_pBlobCacheStats) {
        goto error;
    }
    return TRUE;

error:
    if (g_pURICacheStats) {
        delete g_pURICacheStats;
    }

    if (g_pBlobCacheStats) {
        delete g_pBlobCacheStats;
    }

    if (g_pBlobTable) {
        delete g_pBlobTable;
    }

    if (g_pURITable) {
        delete g_pURITable;
    }

    return FALSE;
}



VOID
BlobCache_Terminate(
    VOID
    )
{
    FlushBlobCache();
    
    delete g_pBlobTable;
    DBGPRINTF(( DBG_CONTEXT,
                 "BlobCache_Terminate: deleted g_pBlobTable.\n" ));
    delete g_pURITable;
    DBGPRINTF(( DBG_CONTEXT,
                 "FileCache_Terminate: deleted g_pURITable.\n" ));

    delete g_pURICacheStats;
    delete g_pBlobCacheStats;

#if TSUNAMI_REF_DEBUG
    if( g_pBlobRefTraceLog != NULL ) {
        DestroyRefTraceLog( g_pBlobRefTraceLog );
        g_pBlobRefTraceLog = NULL;
    }
#endif  // TSUNAMI_REF_DEBUG
}

BOOL
CacheBlob(
    IN  PBLOB_HEADER pBlob
    )
/*++
Routine Description:

    Add a Blob info structure to the cache.

Arguments:

    pBlob    - The structure to be cached. 

Return Values:

    TRUE on success.
    FALSE on failure (the item was not cached)
--*/
{
    CBlobHashTable * pHT;
    CBlobCacheStats * pCS;
    enum LK_RETCODE  lkrc;
    BOOL             bRetval;

    DBG_ASSERT( NULL != pBlob );
    DBG_ASSERT( NULL != pBlob->pBlobKey );
    DBG_ASSERT( TS_BLOB_SIGNATURE == pBlob->Signature );
    DBG_ASSERT( !pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    //
    // URI's in the URI table, and directories in the dir table
    //

    if (RESERVED_DEMUX_URI_INFO == pBlob->pBlobKey->m_dwDemux) {
        pHT = g_pURITable;
        pCS = g_pURICacheStats;
    } else {
        pHT = g_pBlobTable;
        pCS = g_pBlobCacheStats;
    }

    //
    // Add a reference for the caller
    //
    pBlob->AddRef();

    pBlob->IsCached = TRUE;

    //
    // put it in the hash table
    //
    lkrc = pHT->InsertRecord(pBlob, false);

    if (LK_SUCCESS == lkrc) {
        bRetval = TRUE;

        DBG_ASSERT( pCS );
        pCS->IncBlobsCached();
    } else {
        bRetval = FALSE;
        pBlob->IsCached = FALSE;
    }

    return (pBlob->IsCached);
}

VOID
DecacheBlob(
    IN  PBLOB_HEADER pBlob
    )
/*++
Routine Description:

    Remove a Blob info entry from the cache. After a call to DecacheBlob
    the entry will not be returned by CheckoutBlob. The entry itself is
    cleaned up when the last CheckinBlob occurs. Calling DecacheBlob
    checks the entry in.

Arguments:

    pBlob - The Blob info structure to be decached 

Return Values:

    None.
--*/
{
    CBlobHashTable * pHT;
    CBlobCacheStats * pCS;

    DBG_ASSERT( NULL != pBlob );
    DBG_ASSERT( TS_BLOB_SIGNATURE == pBlob->Signature );
    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    if (RESERVED_DEMUX_URI_INFO == pBlob->pBlobKey->m_dwDemux) {
        pHT = g_pURITable;
        pCS = g_pURICacheStats;
    } else {
        pHT = g_pBlobTable;
        pCS = g_pBlobCacheStats;
    }

    DBG_REQUIRE( LK_SUCCESS == pHT->DeleteKey(pBlob->pBlobKey) );
    
    DBG_ASSERT( pCS );
    pCS->DecBlobsCached();

    pBlob->IsFlushed = TRUE;
    DerefBlob(pBlob);
}

VOID
FlushBlobCache(
    VOID
    )
/*++
Routine Description:

    Removes all entries from the cache. Unlike DecacheBlob, this
    function does not check any entries in.

Arguments:

    None

Return Value:

    None
--*/
{
    DBG_ASSERT( g_pBlobCacheStats );
    g_pBlobCacheStats->IncFlushes();
    
    FilteredFlushBlobCache(BlobFlushFilterAll, NULL);
}


LK_PREDICATE
BlobFlushCachePredicate(
    PBLOB_HEADER pBlob,
    void* pvState
    )
{
    TS_BLOB_FLUSH_STATE * pFlushState = static_cast<TS_BLOB_FLUSH_STATE*>(pvState);
    LK_PREDICATE          lkpAction;

    if (pFlushState->pfnFilter(pBlob, pFlushState->pvParm)) {
        //
        // put it on the list
        //
        pBlob->AddRef(); // for the list
        
        InsertHeadList(&pFlushState->ListHead, &pBlob->FlushList);
        lkpAction = LKP_PERFORM;
    } else {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
}


VOID
FilteredFlushBlobCacheHelper (
    IN CBlobHashTable * pHT,
    IN PBLOBFILTERRTN   pFilterRoutine,
    IN PVOID            pv
    )
/*++
Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a 
    parameter. The function will be called with each item in the cache.
    If the function returns TRUE, the item will be decached (but not
    checked in). Otherwise the item will remain in the cache.

Arguments:

    pFilterRoutine - A pointer to the filter function 
    
Return Value:

    None
--*/
{
    TS_BLOB_FLUSH_STATE FlushState;
    
    //
    // Initialize the flush state
    //
    FlushState.pfnFilter = pFilterRoutine;
    InitializeListHead(&FlushState.ListHead);
    FlushState.pvParm = pv;

    //
    // Delete elements from table and construct list
    //
    pHT->DeleteIf(BlobFlushCachePredicate, &FlushState);

    //
    // Update element state and delete blobs as necessary
    //
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNext;
    PBLOB_HEADER pBlob;

    for (pEntry = FlushState.ListHead.Flink;
         pEntry != &FlushState.ListHead;
         pEntry = pNext ) {

        pNext = pEntry->Flink;
        pBlob = CONTAINING_RECORD( pEntry, BLOB_HEADER, FlushList );
        DBG_ASSERT( TS_BLOB_SIGNATURE == pBlob->Signature );

        pBlob->IsFlushed = TRUE;

        DerefBlob(pBlob);  // remove list's reference

    }
}


VOID
FilteredFlushBlobCache (
    IN PBLOBFILTERRTN   pFilterRoutine,
    IN PVOID            pv
    )
/*++
Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a 
    parameter. The function will be called with each item in the cache.
    If the function returns TRUE, the item will be decached (but not
    checked in). Otherwise the item will remain in the cache.

Arguments:

    pFilterRoutine - A pointer to the filter function 
    
Return Value:

    None
--*/
{
    DBG_ASSERT( g_pURICacheStats );
    DBG_ASSERT( g_pBlobCacheStats );

    g_pURICacheStats->IncFlushes();
    g_pBlobCacheStats->IncFlushes();

    FilteredFlushBlobCacheHelper(g_pURITable, pFilterRoutine, pv);
    FilteredFlushBlobCacheHelper(g_pBlobTable, pFilterRoutine, pv);
}

VOID
FilteredFlushURIBlobCache (
    IN PBLOBFILTERRTN   pFilterRoutine,
    IN PVOID            pv
    )
/*++
Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a 
    parameter. The function will be called with each item in the cache.
    If the function returns TRUE, the item will be decached (but not
    checked in). Otherwise the item will remain in the cache.

    This routine only flushes the URI cache.

Arguments:

    pFilterRoutine - A pointer to the filter function 
    
Return Value:

    None
--*/
{
    DBG_ASSERT( g_pURICacheStats );

    g_pURICacheStats->IncFlushes();

    FilteredFlushBlobCacheHelper(g_pURITable, pFilterRoutine, pv);
}


BOOL
CheckoutBlob(
    IN  LPCSTR         pstrPath,
    IN ULONG           cchPath,
    IN DWORD           dwService,
    IN DWORD           dwInstance,
    IN ULONG           iDemux,
    OUT PBLOB_HEADER * ppBlob
    )
/*++
Routine Description:

    Look up an entry in the cache and return it. 

Arguments:

    pstrPath  - The pathname of the desired Blob info in UPPERCASE!!
    TSvcCache - This structure identifies the calling server instance,
                which is also used to identify the cache entry. 
    ppBlob    - On success this output points to the cached entry.
                Otherwise it is set to NULL. 

Return Value:

    TRUE if the item was found, FALSE otherwise.
--*/
{
    CBlobHashTable * pHT;
    CBlobCacheStats * pCS;
    CBlobKey blobKey;
    PBLOB_HEADER pBlob;
    BOOL bRetVal;
    BOOL bFlushed;

    DBG_ASSERT( pstrPath != NULL );
    CHECK_BLOB_TYPE(iDemux);

    //
    // Look in the hash table
    //
    blobKey.m_pszPathName = const_cast<char *>(pstrPath);
    blobKey.m_cbPathName = cchPath;
    blobKey.m_dwService = dwService;
    blobKey.m_dwInstance = dwInstance;
    blobKey.m_dwDemux = iDemux;

    //
    // URI's in the URI table, and everything else in the blob table
    //

    if (RESERVED_DEMUX_URI_INFO == blobKey.m_dwDemux) {
        pHT = g_pURITable;
        pCS = g_pURICacheStats;
    } else {
        pHT = g_pBlobTable;
        pCS = g_pBlobCacheStats;
    }
    
    pHT->FindKey(&blobKey, &pBlob);

    if (NULL == pBlob) {
        bRetVal = FALSE;
        goto exit;
    }

    //
    // Make sure it's valid and update state
    //

    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( !pBlob->IsFlushed );

    //
    // success
    //
    bRetVal = TRUE;
    *ppBlob = pBlob;
    
exit:    

    DBG_ASSERT( pCS );
    if (bRetVal) {
        pCS->IncHits();
    } else {
        pCS->IncMisses();
    }

    return bRetVal;
}

BOOL
CheckoutBlobEntry(
    IN  PBLOB_HEADER pBlob
    )
/*++
Routine Description:

    This function checks out an entry to which the caller already has
    a reference.

Arguments:

    pBlob - The blob structure to be checked out. 

Return Value:

    TRUE  - Blob was successfully checked out
    FALSE - Blob was checked out, but should not be used by the
            caller. (it's been flushed)
--*/
{
    BOOL bSuccess;
    CBlobCacheStats * pCS;

    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    pBlob->AddRef();

    if (RESERVED_DEMUX_URI_INFO == pBlob->pBlobKey->m_dwDemux) {
        pCS = g_pURICacheStats;
    } else {
        pCS = g_pBlobCacheStats;
    }
    DBG_ASSERT( pCS );

    if (pBlob->IsFlushed == FALSE) {
        pCS->IncHits();
        bSuccess = TRUE;
    } else {
        pCS->IncMisses();
        bSuccess = FALSE;
    }

    return bSuccess;
}


VOID
CheckinBlob(
    IN  PBLOB_HEADER pBlob
    )
/*++
Routine Description:

    Indicate that a previously checked out Blob info is no longer in use.

Arguments:

    pvBlob - The Blob info structure to be checked in. 

Return Value:

    None.
--*/
{
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    DerefBlob(pBlob);
}



inline VOID
DerefBlob(
    PBLOB_HEADER pBlob
    )
/*++

--*/
{
    DBG_ASSERT( pBlob != NULL );
    DBG_ASSERT( pBlob->IsCached );
    DBG_ASSERT( pBlob->pBlobKey != NULL );
    DBG_ASSERT( pBlob->Signature == TS_BLOB_SIGNATURE );
    CHECK_BLOB_TYPE(pBlob->pBlobKey->m_dwDemux);

    LONG lRefCount;

    //
    // Track memory corruption in free builds.
    //
    if ( TS_BLOB_SIGNATURE != pBlob->Signature )
    {
        DBG_ASSERT(!"The blob is corrupted");
        // This was hit once on winweb during NT5 deployment. Unfortunately
        // it was too close to escrow for a complete investigation.
        return;
    }


    lRefCount = pBlob->Deref();
    
    DBG_ASSERT( lRefCount >= 0 );
    
    if (lRefCount == 0) {
        DBG_ASSERT(pBlob->IsFlushed);

        pBlob->Signature = TS_FREE_BLOB_SIGNATURE;

        //
        // No one is using this one. Destroy!
        // First let the user specified cleanup run
        //
        if (pBlob->pfnFreeRoutine) {
            DBG_REQUIRE( pBlob->pfnFreeRoutine(pBlob) );
        }

        //
        // Delete the key stuff.
        // This should probably be in some other place
        // since we didn't allocate this string.
        // The FREE should go in some counterpart to
        // TsCacheDirectoryBlob.
        //
        CBlobKey * pblock = pBlob->pBlobKey;
        FREE(pblock->m_pszPathName);
        
        //
        // Delete the blob
        // Since TsAllocateEx does this funky trick to
        // allocate the key and the blob at once, we
        // only have to free the key.
        //
        FREE(pblock);
    }
}

BOOL
BlobFlushFilterAll(
    PBLOB_HEADER pBlob,
    PVOID pv
    )
{
    return TRUE;
}

//
// blobcach.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache\getdirp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        getdirp.cxx

   Abstract:
        This module implements the functions for getting directory listings
         and transparently caching them.
        ( This uses OS specific functions to obtain the directory).

   Author:

           Murali R. Krishnan    ( MuraliK )     13-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:
   BOOL TsGetDirectoryListingA()
   BOOL TsFreeDirectoryListing()
   int __cdecl
   AlphaCompareFileBothDirInfo(
              IN const void *   pvFileInfo1,
              IN const void *   pvFileInfo2)

   TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::BuildInfoPointers(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::CleanupThis()

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "tsunamip.hxx"

# include <stdlib.h>
# include <string.h>
# include <dbgutil.h>

/************************************************************
 *     Type Definitions
 ************************************************************/


#define DIRECTORY_BUFFER_SIZE 8160          /* < 8192 bytes */

/************************************************************
 *    Functions
 ************************************************************/


BOOL FreeDirectoryHeaderContents( PVOID pvOldBlock );


dllexp
BOOL
TsGetDirectoryListing(
    IN const TSVC_CACHE         &tsCache,
    IN      PCSTR               pszDirectoryName,
    IN      HANDLE              ListingUser,
    OUT     PTS_DIRECTORY_HEADER * ppTsDirectoryHeader
    )
/*++
  This function obtains the directory listing for dir specified
        in pszDirectoryName.

  Arguments:
    tsCache          Cache structure which is used for lookup
    pwszDirectoryName  pointer to string containing the directory name
    ListingUser        Handle for the user opening the directory
    ppTsDirectoryHeader
                  pointer to pointer to class containing directory information.
       Filled on successful return. On failure this will be NULL

  Returns:
      TRUE on success and FALSE if  there is a failure.
--*/
{
    ASSERT( tsCache.IsValid() );
    ASSERT( pszDirectoryName   != NULL );
    ASSERT( ppTsDirectoryHeader != NULL);

    PVOID          pvBlob = NULL;
    ULONG          ulSize = 0;
    BOOL           bSuccess;

    //
    //  First, check to see if we have already cached a listing of this
    //  directory.
    //

    *ppTsDirectoryHeader = NULL;
    bSuccess = TsCheckOutCachedBlob(  tsCache,
                                      pszDirectoryName,
                                      RESERVED_DEMUX_DIRECTORY_LISTING,
                                      ( PVOID * )&pvBlob,
                                      &ulSize );

    if ( bSuccess )
    {
        ASSERT( BLOB_IS_OR_WAS_CACHED( pvBlob ) );

        *ppTsDirectoryHeader = (PTS_DIRECTORY_HEADER )pvBlob;
        ASSERT ( (*ppTsDirectoryHeader)->IsValid());

        //
        //  Make sure the user tokens match
        //

        if ( hListingUser == (*ppTsDirectoryHeader)->QueryListingUser() )
        {
            IF_DEBUG( DIR_LIST) {

                DBGPRINTF( (DBG_CONTEXT,
                            " Obtained DirectoryListing (%s) from Cache ( %08x)\n",
                            pszDirectoryName,
                            *ppTsDirectoryHeader));

                (*ppTsDirectoryHeader)->Print();
            }

            return TRUE;
        }

        //
        //  User token doesn't match, don't return it
        //

        bSuccess = TsCheckInCachedBlob( pvBlob );

        ASSERT( bSuccess );
    }

    //
    //  The block was not present in cache.
    //  Obtain a fresh copy of the directory listing and cache it.
    //

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( (DBG_CONTEXT,
                    "Missing DirListing (%s) in cache. Generating newly\n",
                    pszDirectoryName));
    }

    *ppTsDirectoryHeader = TsGetFreshDirectoryHeader(
                               tsCache,
                               pszDirectoryName,
                               hListingUser );


    bSuccess = ( *ppTsDirectoryHeader != NULL);

    return ( bSuccess);

} // TsGetDirectoryListing




dllexp
BOOL
TsFreeDirectoryListing(
    IN const TSVC_CACHE &    tsCache,
    IN PTS_DIRECTORY_HEADER  pDirectoryHeader
    )
{
    BOOL fReturn;
    BOOL fCached = BLOB_IS_OR_WAS_CACHED( (PVOID ) pDirectoryHeader);

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "TsFreeDirectoryListing( %08x) called. Cached = %d\n",
                    pDirectoryHeader,
                    fCached));

        pDirectoryHeader->Print();
    }

    if ( fCached )
    {
        fReturn = TsCheckInCachedBlob( ( PVOID )pDirectoryHeader );
    }
    else
    {
        fReturn = TsFree( tsCache, ( PVOID )pDirectoryHeader );
    }

    return( fReturn);
} // TsFreeDirectoryListing()



BOOL
FreeDirectoryHeaderContents(
    PVOID pvOldBlock
    )
{
    PTS_DIRECTORY_HEADER  pDirectoryHeader;

    pDirectoryHeader = ( PTS_DIRECTORY_HEADER )pvOldBlock;

    pDirectoryHeader->CleanupThis();

    //
    //  The item may never have been added to the cache, don't
    //  count it in this case
    //

    if ( BLOB_IS_OR_WAS_CACHED( pvOldBlock ) )
    {
        DEC_COUNTER( BLOB_GET_SVC_ID( pvOldBlock ),
                     CurrentDirLists );
    }

    return ( TRUE);
}  //  FreeDirectoryHeaderContents()




int __cdecl
AlphaCompareFileBothDirInfo(
   IN const void *   pvFileInfo1,
   IN const void *   pvFileInfo2)
{
    const FILE_BOTH_DIR_INFORMATION * pFileInfo1 =
        *((const FILE_BOTH_DIR_INFORMATION **) pvFileInfo1);
    const FILE_BOTH_DIR_INFORMATION * pFileInfo2 =
        *((const FILE_BOTH_DIR_INFORMATION **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmp( (LPCSTR )pFileInfo1->FileName,
                      (LPCSTR )pFileInfo2->FileName));

} // AlphaCompareFileBothDirInfo()



BOOL
SortInPlaceFileInfoPointers(
    IN OUT PFILE_BOTH_DIR_INFORMATION  * prgFileInfo,
    IN int   nEntries,
    IN PFN_CMP_FILE_BOTH_DIR_INFO        pfnCompare)
/*++
  This is a generic function to sort the pointers to file information
    array in place using pfnCompare to compare the records for ordering.

  Returns:
     TRUE on success and FALSE on failure.
--*/
{
    DWORD  dwTime;

#ifdef INSERTION_SORT
    int idxInner;
    int idxOuter;

    dwTime = GetTickCount();
    //
    //  A simple insertion sort is performed. May be modified in future.
    //

    for( idxOuter = 1; idxOuter < nEntries; idxOuter++) {

        for( idxInner = idxOuter; idxInner > 0; idxInner-- ) {

            int iCmp = ( *pfnCompare)( prgFileInfo[ idxInner - 1],
                                       prgFileInfo[ idxInner]);

            if ( iCmp <= 0) {
                //
                //  The entries in prgFileInfo[0 .. idxOuter] are in order.
                //  Stop bubbling the outer down.
                //
                break;
            } else {

                //
                // Swap the two entries.  idxInner, idxInner - 1
                //

                PFILE_BOTH_DIR_INFORMATION  pFInfoTmp;

                pFInfoTmp = prgFileInfo[ idxInner - 1];
                prgFileInfo[ idxInner - 1] = prgFileInfo[idxInner];
                prgFileInfo[ idxInner] = pFInfoTmp;
            }
        }  // inner for

    } // for

    dwTime = GetTickCount() -  dwTime;

# else

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Qsorting the FileInfo Array %08x ( Total = %d)\n",
                    prgFileInfo, nEntries));
    }

    dwTime = GetTickCount();
    qsort( (PVOID ) prgFileInfo, nEntries,
          sizeof( PFILE_BOTH_DIR_INFORMATION),
          pfnCompare);

    dwTime = GetTickCount() - dwTime;

# endif // INSERTION_SORT

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Time to sort %d entries = %d\n",
                    nEntries, dwTime));
    }

    return ( TRUE);
} // SortInPlaceFileInfoPointers()







/**********************************************************************
 *    TS_DIRECTORY_HEADER  related member functions
 **********************************************************************/

inline USHORT
ConvertUnicodeToAnsiInPlace(
   IN OUT  LPWSTR     pwszUnicode,
   IN      USHORT     usLen)
/*++
  Converts given Unicode strings to Ansi In place and returns the
    length of the modified string.
--*/
{
    CHAR achAnsi[MAX_PATH+1];
    DWORD cch;

    if ( usLen > sizeof(achAnsi) )
    {
        ASSERT( FALSE );
        *pwszUnicode = L'\0';
        return 0;
    }

    //
    //  usLen is a byte count and the unicode string isn't terminated
    //

    cch = WideCharToMultiByte( CP_ACP,
                               WC_COMPOSITECHECK,
                               pwszUnicode,
                               usLen / sizeof(WCHAR),
                               achAnsi,
                               sizeof( achAnsi ),
                               NULL,
                               NULL );

    if ( !cch || (cch + 1) > sizeof( achAnsi ) )
    {
        ASSERT( FALSE );
        *pwszUnicode = L'\0';
        return 0;
    }

    achAnsi[cch] = '\0';

    RtlCopyMemory( pwszUnicode, achAnsi, cch + 1 );

    return (USHORT) cch;
}  // ConvertUnicodeToAnsiInPlace()



BOOL
TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
    IN LPCWSTR          pwszDirectoryName,
    IN OUT DWORD *      pcbMemUsed
    )
/*++
  Opens and reads the directory file for given directory to obtain
   information about files and directories in the dir.

  Returns:
     TRUE on success and   FALSE on failure.
     Use GetLastError() for further error information.

--*/
{
    BOOL                fReturn = TRUE;       // default assumed.
    UNICODE_STRING      PathName;
    RTL_RELATIVE_NAME_U RelativeName;
    OBJECT_ATTRIBUTES   Obja;
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    NTSTATUS            Status;
    IO_STATUS_BLOCK     IoStatusBlock;
    BOOL                fFirstTime;
    DWORD               cbExtraMem = 0;

    PFILE_BOTH_DIR_INFORMATION pFileDirInfo;
    PFILE_BOTH_DIR_INFORMATION pFileDirInfoPrior;

    //
    // Initialize the variables properly
    //

    memset( (PVOID ) &PathName, 0, sizeof(PathName));
    memset( (PVOID ) &RelativeName, 0, sizeof(RelativeName));

    //
    //  Convert the DOS name of directory to NT name for NT API to open it.
    //

    fReturn = RtlDosPathNameToRelativeNtPathName_U(
                             pwszDirectoryName,
                             &PathName,
                             NULL,
                             &RelativeName );

    //
    //  If translation fails or
    // If this directory name is in the form <dirname>\<filespec>,
    //        the caller has messed up.
    //

    if ( !fReturn || RelativeName.RelativeName.Length != 0)  {

        if (fReturn) {
            RtlReleaseRelativeName(&RelativeName);
        }

        SetLastError(ERROR_PATH_NOT_FOUND);

        if ( PathName.Buffer != NULL) {     // free up the space.

            RtlFreeHeap( RtlProcessHeap(), 0, PathName.Buffer);
        }

        return( fReturn);
    }

    //
    //  Remember that we need to free the buffer containing the NT name.
    //  i.e. PathName.Buffer
    //

    ASSERT( RelativeName.ContainingDirectory == NULL );
    ASSERT( RelativeName.RelativeName.Length == 0);

    InitializeObjectAttributes(  &Obja,
                                 &PathName,
                                 OBJ_CASE_INSENSITIVE,
                                 RelativeName.ContainingDirectory,
                                 NULL );

    //
    // Open the directory for list access
    //

    Status = NtOpenFile(  &hFindFile,
                          FILE_LIST_DIRECTORY | SYNCHRONIZE,
                          &Obja,
                          &IoStatusBlock,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
                           FILE_OPEN_FOR_BACKUP_INTENT
                        );

    RtlReleaseRelativeName(&RelativeName);

    //
    //  The Buffer is not required any more. Free it before checking status.
    //

    RtlFreeHeap( RtlProcessHeap(), 0, PathName.Buffer );
    PathName.Buffer = NULL;


    if ( !NT_SUCCESS(Status) ) {

        //
        // The full path does not refer to a directory.  This could be a
        // device, but (unlike FindFirstFile()...) we don't care.  If it's
        // not a directory, we don't list it.
        //

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF( ( DBG_CONTEXT, "Failed to open Dir %ws. Handle = %x\n",
                        pwszDirectoryName, hFindFile));
        }

        SetLastError( ERROR_PATH_NOT_FOUND);
        return ( FALSE);
    }

    InitializeListHead( &m_listDirectoryBuffers);

    //
    //  Loop through getting subsequent entries in the directory.
    //
    for( fFirstTime = TRUE; ; fFirstTime = FALSE)
    {
        PVOID pvBuffer;

        //
        // Get the next chunk of directory information.
        //  Obtained in a buffer  with LIST_ENTRY as the first member of buffer
        //

        #define DIR_ALLOC_SIZE  (DIRECTORY_BUFFER_SIZE + sizeof (LIST_ENTRY))

        pvBuffer = ALLOC( DIR_ALLOC_SIZE );
        cbExtraMem += DIR_ALLOC_SIZE;

        if ( pvBuffer == NULL ) {

            //
            //  Allocation failure.
            //
            SetLastError( ERROR_NOT_ENOUGH_MEMORY);
            fReturn = FALSE;
            break;                // Get out of the loop with failure.
        }

        pFileDirInfo = ( PFILE_BOTH_DIR_INFORMATION )
          ((( PCHAR ) pvBuffer) + sizeof( LIST_ENTRY ) );

        Status = NtQueryDirectoryFile(  hFindFile,         // fileHandle
                                        NULL,              // Event
                                        NULL,              // Apc Routine
                                        NULL,              // ApcContext
                                        &IoStatusBlock,    // PIoStatusBlock
                                        pFileDirInfo,      // PFileInfo
                                        DIRECTORY_BUFFER_SIZE, // Len
                                        FileBothDirectoryInformation, //Class
                                        FALSE,             // fSingleEntry ?
                                        NULL,              //FileName
                                        fFirstTime );      // RestartScan ?

        //
        //  If the NT API returns STATUS_NO_MORE_FILES, then it did not use
        //  our buffer at all.  We can just free it.
        //  Now's the time that we leave this loop, and stop reading the
        //  directory file.
        //

        if ( Status == STATUS_NO_MORE_FILES ) {

            FREE( pvBuffer );

            //
            //  Decrement the memory size so we don't get charged for it
            //

            cbExtraMem -= DIR_ALLOC_SIZE;

            fReturn = TRUE;
            break;
        }

        if ( NT_SUCCESS( Status ) || ( Status == STATUS_BUFFER_OVERFLOW ) )
        {

            ULONG Offset;

            //
            //  The buffer contains directory entries.
            //  Place it on the list of such buffers for this directory.
            //

            InsertBufferInTail( (PLIST_ENTRY ) pvBuffer);

            pFileDirInfoPrior = NULL;

            //
            // Scan thru the entries in the buffer,
            //  truncate the last entry ( if partial) and
            //  convert the Unicode strings, inplace to ansi strings.
            //

            do
            {
                pFileDirInfoPrior = pFileDirInfo;

                Offset = pFileDirInfo->NextEntryOffset;

                if ( ( Offset == 0 ) && ( Status == STATUS_BUFFER_OVERFLOW ) )
                {
                    //
                    //  If Status==STATUS_BUFFER_OVERFLOW, the last entry in
                    //  buffer may be a partial entry, broken on boundary of
                    //  buffer. The NT API will give us this entry again next
                    //  time around, so for now we patch the buffer up to
                    //  appear as if it does not contain the partial entry.
                    //

                    if ( pFileDirInfoPrior != NULL )
                    {
                        pFileDirInfoPrior->NextEntryOffset = 0;
                    }
                    else
                    {
                        //
                        // Some fatal problem. Should get out this loop.
                        //
                        BREAKPOINT();
                        fReturn = FALSE;
                        goto Failure;
                    }
                }
                else
                {
                    IncrementDirEntries();

                    if ( pFileDirInfo->FileNameLength != 0) {
                        pFileDirInfo->FileNameLength =
                             ConvertUnicodeToAnsiInPlace(
                                (LPWSTR ) pFileDirInfo->FileName,
                                (USHORT ) pFileDirInfo->FileNameLength);
                    }

                    if ( pFileDirInfo->ShortNameLength != 0) {
                        pFileDirInfo->ShortNameLength =
                           (CCHAR ) ConvertUnicodeToAnsiInPlace(
                                    (LPWSTR ) pFileDirInfo->ShortName,
                                     pFileDirInfo->ShortNameLength);
                    }


                    // Get the next entry in buffer
                    pFileDirInfo =
                      ( PFILE_BOTH_DIR_INFORMATION )
                        ((( PCHAR )pFileDirInfo ) + Offset );
                }
            }
            while ( Offset != 0);

            Status = STATUS_SUCCESS;
        }

        if ( !NT_SUCCESS(Status) )
        {
            fReturn = FALSE;
            break;
        }
    }

Failure:

    ASSERT( PathName.Buffer == NULL);
    if ( hFindFile != INVALID_HANDLE_VALUE) {
        NtClose( hFindFile );
        hFindFile = INVALID_HANDLE_VALUE;
    }

    *pcbMemUsed += cbExtraMem;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile()




VOID
TS_DIRECTORY_HEADER::CleanupThis( VOID)
{
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNextEntry;

    for ( pEntry = QueryDirBuffersListEntry()->Flink;
         pEntry != QueryDirBuffersListEntry();
         pEntry  = pNextEntry )
    {
        pNextEntry = pEntry->Flink;

        //
        //  The buffers are allocated such that first member of buffer is
        //    LIST_ENTRY object.  Free it entirely.
        //
        FREE( pEntry );
    }

    InitializeListHead( QueryDirBuffersListEntry());

    if ( m_ppFileInfo != NULL) {

        FREE( m_ppFileInfo);
        m_ppFileInfo   = NULL;
    }

    m_hListingUser = INVALID_HANDLE_VALUE;
    m_nEntries     = 0;

    return;
} // TS_DIRECTORY_HEADER::CleanupThis()





BOOL
TS_DIRECTORY_HEADER::BuildFileInfoPointers(
    IN OUT DWORD *      pcbMemUsed
    )
/*++

  This constructs the indirection pointers from the buffers containing the
   file information.
  This array of indirection enables faster access to the file information
   structures stored.

   Should be always called after ReadFromNtDirectoryFile() to construct the
    appropriate pointers.

   Returns:
     TRUE on success and FALSE if there are any failures.
--*/
{
    BOOL fReturn = FALSE;
    DWORD cbAlloc;

    ASSERT( QueryNumEntries() != 0);  //  Any directory will atleast have "."

    //
    // Alloc space for holding the pointers for numEntries pointers.
    //

    cbAlloc = QueryNumEntries() * sizeof( PFILE_BOTH_DIR_INFORMATION );

    m_ppFileInfo = (PFILE_BOTH_DIR_INFORMATION *) ALLOC( cbAlloc );

    if ( m_ppFileInfo != NULL ) {

        int          index;
        PLIST_ENTRY  pEntry;
        ULONG        Offset;
        PFILE_BOTH_DIR_INFORMATION   pFileDirInfo;

        //
        //  Get the link to first buffer and start enumeration.
        //
        pEntry = QueryDirBuffersListEntry()->Flink;
        pFileDirInfo = (PFILE_BOTH_DIR_INFORMATION )( pEntry + 1 );

        for ( index = 0;
             index < QueryNumEntries();
             index++ ) {

            ASSERT( pEntry != QueryDirBuffersListEntry());

            m_ppFileInfo[index] = pFileDirInfo;    // store the pointer.

            Offset = pFileDirInfo->NextEntryOffset;

            if ( Offset != 0 ) {

                pFileDirInfo = (PFILE_BOTH_DIR_INFORMATION )
                                 ((( PCHAR )pFileDirInfo ) + Offset );
            } else {

                //
                // we are moving to the next buffer.
                //
                pEntry = pEntry->Flink;
                if ( pEntry == QueryDirBuffersListEntry()) {

                    ASSERT( index == QueryNumEntries() - 1);
                    break;
                }
                pFileDirInfo = ( PFILE_BOTH_DIR_INFORMATION )( pEntry + 1 );
            }


        } // for
        ASSERT( Offset == 0 );
        fReturn = SortInPlaceFileInfoPointers( m_ppFileInfo,
                                              QueryNumEntries(),
                                              AlphaCompareFileBothDirInfo);

    } // valid alloc of the pointers.

    *pcbMemUsed += cbAlloc;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::BuildFileInfoPointers()




# if DBG

VOID
TS_DIRECTORY_HEADER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing TS_DIRECTORY_HEADER ( %08x).\n", this));
    DBGPRINTF( ( DBG_CONTEXT,
                "ListingUser Handle = %08x\t Num Entries = %08x\n",
                m_hListingUser, m_nEntries));
    DBGPRINTF( ( DBG_CONTEXT,
                "Pointer to array of indirection pointers %08x\n",
                m_ppFileInfo));
    //
    //  The buffers containing the data of the file information not printed
    //

    return;
} // TS_DIRECTORY_HEADER::Print()


# endif // DBG

/************************ End of File ***********************/

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\dirchngp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        dirchngp.cxx

   Abstract:
        This module contains the internal directory change routines

   Author:
        Murali R. Krishnan    ( MuraliK )     16-Jan-1995

--*/

#include "TsunamiP.Hxx"
#pragma hdrstop

#include "issched.hxx"
#include "dbgutil.h"
#include <lonsi.hxx>

//
//  Manifests
//

//
//  Globals
//

HANDLE g_hChangeWaitThread = NULL;
LONG   g_nTsunamiThreads = 0;

//
//  Local prototypes
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\dirchang.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

        dirchang.cxx

   Abstract:

        This module contains the directory change manager routines

   Author:

        MuraliK

   Revision History:

        MCourage    24-Mar-1998  Rewrote to use CDirMonitor

--*/

#include "tsunamip.Hxx"
#pragma hdrstop

#include "dbgutil.h"
#include <mbstring.h>

extern "C" {
#include <lmuse.h>
}

#if ENABLE_DIR_MONITOR

#include <malloc.h>
#include "filecach.hxx"
#include "filehash.hxx"

//#define DIR_CHANGE_FILTER   (FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_ATTRIBUTES)

#define DIR_CHANGE_FILTER (FILE_NOTIFY_VALID_MASK & ~FILE_NOTIFY_CHANGE_LAST_ACCESS)
#define DIRMON_BUFFER_SIZE  4096

BOOL ConvertToLongFileName(
                const char *pszPath,
                const char *pszName,
                WIN32_FIND_DATA *pwfd);


CDirMonitor * g_pVRootDirMonitor;
#endif // ENABLE_DIR_MONITOR

BOOL
DcmInitialize(
    VOID
    )
{
#if ENABLE_DIR_MONITOR
    g_pVRootDirMonitor = new CDirMonitor;

    return (g_pVRootDirMonitor != NULL);
#else
    return TRUE;
#endif // ENABLE_DIR_MONITOR
}


VOID
DcmTerminate(
    VOID
    )
{
#if ENABLE_DIR_MONITOR
    if (g_pVRootDirMonitor) {
        g_pVRootDirMonitor->Cleanup();
        delete g_pVRootDirMonitor;
        g_pVRootDirMonitor = NULL;
    }
#endif // ENABLE_DIR_MONITOR
}


BOOL
DcmAddRoot(
    PVIRTUAL_ROOT_MAPPING  pVrm
    )
{
#if ENABLE_DIR_MONITOR
    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "DCM: Adding root \"%s\" to \"%s\"\n",
                    pVrm->pszRootA, pVrm->pszDirectoryA ));
    }

    ASSERT(NULL != g_pVRootDirMonitor);

    CVRootDirMonitorEntry * pDME;

    //
    // See if we're already watching this directory
    //

    pDME = (CVRootDirMonitorEntry *) g_pVRootDirMonitor->FindEntry(pVrm->pszDirectoryA);

    if ( pDME == NULL )
    {
        // Not found - create new entry

        pDME = new CVRootDirMonitorEntry;

        if ( pDME )
        {
            pDME->AddRef();

            // Start monitoring
            if ( !g_pVRootDirMonitor->Monitor(pDME, pVrm->pszDirectoryA, TRUE, DIR_CHANGE_FILTER) )
            {
                // Cleanup if failed
                pDME->Release();
                pDME = NULL;
            }
        }
    }

    // Return entry if found
    if ( pDME != NULL )
    {
        pVrm->pDME = static_cast<CVRootDirMonitorEntry *>(pDME);
        return TRUE;
    }
    else
    {
        pVrm->pDME = NULL;
        return FALSE;
    }

#else // !ENABLE_DIR_MONITOR
    //
    // Doesn't do anything.  Ha!
    //
    return TRUE;
#endif // ENABLE_DIR_MONITOR
}


VOID
DcmRemoveRoot(
    PVIRTUAL_ROOT_MAPPING  pVrm
    )
{
#if ENABLE_DIR_MONITOR
    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "DCM: Removing root \"%s\" to \"%s\"\n",
                    pVrm->pszRootA, pVrm->pszDirectoryA ));
    }

    CVRootDirMonitorEntry * pDME = pVrm->pDME;

    pVrm->pDME = NULL;

    if (pDME) {
        pDME->Release();
    }
#else // !ENABLE_DIR_MONITOR
    //
    // Doesn't do anything.  Ha!
    //
#endif // ENABLE_DIR_MONITOR
}



#if ENABLE_DIR_MONITOR

typedef struct _FLUSH_PREFIX_PARAM {
    PCSTR pszPrefix;
    DWORD cbPrefix;
} FLUSH_PREFIX_PARAM;


BOOL
FlushFilterPrefix(
    TS_OPEN_FILE_INFO * pOpenFile,
    PVOID               pv
    )
{
    DBG_ASSERT( pOpenFile );
    DBG_ASSERT( pOpenFile->GetKey() );

    FLUSH_PREFIX_PARAM * fpp = (FLUSH_PREFIX_PARAM *)pv;
    const CFileKey * pfk = pOpenFile->GetKey();

    //
    // If the prefix matches then we flush.
    //

    //
    // The key stored in TS_OPEN_FILE_INFO is uppercased, so we will do a
    // case insensitive memcmp here. 
    // The alternative is to create a temporary and uppercase all instances 
    // when the directory is dumped or to have CDirMonitorEntry store its 
    // name uppercased.
    //

    return ((pfk->m_cbFileName >= fpp->cbPrefix)
            && (_memicmp(pfk->m_pszFileName, fpp->pszPrefix, fpp->cbPrefix) == 0));
}


/*===================================================================
strcpyEx

Copy one string to another, returning a pointer to the NUL character
in the destination

Parameters:
    szDest - pointer to the destination string
    szSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *strcpyEx(char *szDest, const char *szSrc)
    {
    while (*szDest++ = *szSrc++)
        ;

    return szDest - 1;
    }


CVRootDirMonitorEntry::CVRootDirMonitorEntry() : m_cNotificationFailures(0)
/*++

Routine Description:

    Constructor

Arguments:

    None

Return Value:

    None
--*/
{
}

CVRootDirMonitorEntry::~CVRootDirMonitorEntry()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None
--*/
{
}

BOOL
CVRootDirMonitorEntry::Init(
    VOID
    )
/*++

Routine Description:

    Initialize monitor entry

Arguments:

    pvData    - passed to base Init member

Return Value:

    TRUE if success, otherwise FALSE

--*/
{
    return CDirMonitorEntry::Init(DIRMON_BUFFER_SIZE);
}

#if 0
BOOL CVRootDirMonitorEntry::Release(VOID)
/*++

Routine Description:

    Decrement refcount to an entry, we override the base class because
    otherwise Denali's memory manager can't track when we free the object
    and reports  it as a memory leak

Arguments:

    None

Return Value:

    TRUE if object still alive, FALSE if was last release and object
    destroyed

--*/
{
    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF((DBG_CONTEXT, "[CVRootDirMonitorEntry] Before Release Ref count %d on directory %s\n", m_cDirRefCount, m_pszPath));
    }

    if ( !InterlockedDecrement( &m_cDirRefCount ) )
    {
        BOOL fDeleteNeeded = Cleanup();
        if (fDeleteNeeded)
        {
            delete this;
        }
        return FALSE;
    }

    return TRUE;
}
#endif

BOOL
CVRootDirMonitorEntry::ActOnNotification(
                        DWORD dwStatus,
                        DWORD dwBytesWritten)
/*++

Routine Description:

    Do any work associated with a change notification, i.e.

Arguments:

    None

Return Value:

    TRUE if directory should continue to be monitored, otherwise FALSE

--*/
{
    FILE_NOTIFY_INFORMATION *pNotify = NULL;
    FILE_NOTIFY_INFORMATION *pNextNotify = NULL;
    LPSTR    pszScriptName = NULL; // Name of script
    WCHAR   *pwstrFileName = NULL; // Wide file name
    DWORD   cch = 0;

    pNextNotify = (FILE_NOTIFY_INFORMATION *) m_pbBuffer;

    // If the status word is not NOERROR, then the ReadDirectoryChangesW failed
    if (dwStatus)
    {
        // If the status is ERROR_ACCESS_DENIED the directory may be deleted
        // or secured so we want to stop watching it for changes.
        // we should flush the dir and everything in it.

        if (dwStatus == ERROR_ACCESS_DENIED)
        {
            //
            // Flush the dir here
            //
            IF_DEBUG( DIRECTORY_CHANGE ) {
                DBGPRINTF(( DBG_CONTEXT,
                            "DCM: Flushing directory \"%s\" because we got ACCESS_DENIED\n",
                            m_pszPath ));
            }

            FLUSH_PREFIX_PARAM param;
            param.pszPrefix = m_pszPath;
            param.cbPrefix = strlen(m_pszPath);
            FilteredFlushFileCache(FlushFilterPrefix, &param);

            //
            // no point in having the handle open anymore
            //
            m_hDir = INVALID_HANDLE_VALUE;
            AtqCloseFileHandle( m_pAtqCtxt );

            // No further notifications desired
            // so return false

            return FALSE;
        }

        // If we return TRUE, we'll try change notification again
        // If we return FALSE, we give up on any further change notifcation
        // We'll try a MAX_NOTIFICATION_FAILURES times and give up.

        if (m_cNotificationFailures < MAX_NOTIFICATION_FAILURES)
        {
            IF_DEBUG ( DIRECTORY_CHANGE ) {
                DBGPRINTF((DBG_CONTEXT, "[CVRootDirMonitorEntry] ReadDirectoryChange failed. Status = %d\n", dwStatus));
            }

            m_cNotificationFailures++;
            return TRUE;    // Try to get change notification again
        }
        else
        {
            // CONSIDER: Should we log this?
            DBGPRINTF((DBG_CONTEXT, "[CVRootDirMonitorEntry] ReadDirectoryChange failed too many times. Giving up.\n"));
            return FALSE;   // Give up trying to get change notification
        }
    }
    else
    {
        // Reset the number of notification failure

        m_cNotificationFailures = 0;
    }

    // If dwBytesWritten is 0, then there were more changes then could be
    // recorded in the buffer we provided. Expire the application just in case
    // CONSIDER: is this the best course of action, or should iterate through the
    // cache and test which files are expired

    if (dwBytesWritten == 0)
    {
        IF_DEBUG( DIRECTORY_CHANGE ) {
            DBGPRINTF((DBG_CONTEXT, "[CVRootDirMonitorEntry] ReadDirectoryChange failed, too many changes for buffer\n"));
        }

        // Flush everything in the dir as a precaution
        FLUSH_PREFIX_PARAM param;
        param.pszPrefix = m_pszPath;
        param.cbPrefix = strlen(m_pszPath);
        FilteredFlushFileCache(FlushFilterPrefix, &param);

        return TRUE;
    }

    while ( pNextNotify != NULL )
    {
        BOOL    bDoFlush = TRUE;

        pNotify        = pNextNotify;
        pNextNotify = (FILE_NOTIFY_INFORMATION    *) ((PCHAR) pNotify + pNotify->NextEntryOffset);

        // Get the unicode file name from the notification struct
        // pNotify->FileNameLength returns the wstr's length in **bytes** not wchars

        cch = pNotify->FileNameLength / 2;

        // Convert to ANSI with uniform case and directory delimiters

        pszScriptName = (LPSTR) _alloca(pNotify->FileNameLength + 1);
        DBG_ASSERT(pszScriptName != NULL);
        pszScriptName[ 0 ] = '\0';
        
        cch = WideCharToMultiByte(CP_ACP, 0, pNotify->FileName, cch, pszScriptName, pNotify->FileNameLength + 1, NULL, NULL);
        pszScriptName[cch] = '\0';

        // Take the appropriate action for the directory change
        switch (pNotify->Action)
        {
            case FILE_ACTION_MODIFIED:
                //
                // Since this change won't change the pathname of
                // any files, we don't have to do a flush.
                //
                bDoFlush = FALSE;
            case FILE_ACTION_REMOVED:
            case FILE_ACTION_RENAMED_OLD_NAME:
                FileChanged(pszScriptName, bDoFlush);
                break;
            case FILE_ACTION_ADDED:
            case FILE_ACTION_RENAMED_NEW_NAME:
            default:
                break;
        }

        if(pNotify == pNextNotify)
        {
            break;
        }
    }

    // We should sign up for further change notification

    return TRUE;
}

void
CVRootDirMonitorEntry::FileChanged(const char *pszScriptName, BOOL bDoFlush)
/*++

Routine Description:

    An existing file has been modified or deleted
    Flush scripts from cache or mark application as expired

Arguments:

    pszScriptName   Name of file that changed

Return Value:

    None    Fail silently

--*/
{

    // The file name is set by the application that
    // modified the file, so old applications like EDIT
    // may hand us a munged 8.3 file name which we should
    // convert to a long name. All munged 8.3 file names contain '~'
    // We assume the path does not contain any munged names.
    WIN32_FIND_DATA wfd;
    CHAR            achFullScriptName[ MAX_PATH + 1 ];

    IF_DEBUG( DIRECTORY_CHANGE ) {
        DBGPRINTF(( DBG_CONTEXT,
                    "DCM: Notification on \"%s\\%s\"\n",
                    m_pszPath, pszScriptName ));
    }

    if (strchr(pszScriptName, '~'))
    {

        if (ConvertToLongFileName(m_pszPath, pszScriptName, &wfd))
        {
            CHAR *              pszEnd;
            
            //
            // The filename in wfd.cFileName is the path-less.  We need to 
            // append it to another other sub dirs in pszScriptName (if any)
            //
            
            pszEnd = strrchr( pszScriptName, '\\' );
            if ( pszEnd )
            {
                memcpy( achFullScriptName,
                        pszScriptName,
                        DIFF( pszEnd - pszScriptName ) + 1 );

                memcpy( achFullScriptName + ( pszEnd - pszScriptName ) + 1,
                        wfd.cFileName,
                        strlen( wfd.cFileName ) + 1 );

                pszScriptName = achFullScriptName;
            }
            else
            {
                pszScriptName = wfd.cFileName;
            }
                          
            IF_DEBUG( DIRECTORY_CHANGE ) {
                DBGPRINTF(( DBG_CONTEXT,
                            "DCM: Converted name to \"%s\"\n",
                            pszScriptName ));
            }

        }
        else
        {
            // Fail silently
            return;
        }
    }

    // Allocate enough memory to concatentate the
    // application path and script name

    DWORD cch = m_cPathLength + strlen(pszScriptName) + 1;
    LPSTR pszScriptPath = (LPSTR) _alloca(cch + 1); // CONSIDER using malloc
    DBG_ASSERT(pszScriptPath != NULL);

    // Copy the application path into the script path
    // pT will point to the terminator of the application path

    char* pT = strcpyEx(pszScriptPath, m_pszPath);

    // append a backslash
    *pT++ = '\\';

    // Now append the script name. Note that the script name is
    // relative to the directory that we received the notification for

    lstrcpy(pT, pszScriptName);
    _mbsupr((PUCHAR)pszScriptPath);

    // Get rid of this file, or dir tree
    TS_OPEN_FILE_INFO * pOpenFile;

    if (bDoFlush) {
        //
        // This path is a directory that got removed or renamed
        // so we have to flush everything below it.
        //
        IF_DEBUG( DIRECTORY_CHANGE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "DCM: Flushing directory \"%s\"\n",
                        pszScriptPath ));
        }

        FLUSH_PREFIX_PARAM param;
        param.pszPrefix = pszScriptPath;
        param.cbPrefix = strlen(pszScriptPath);

        FilteredFlushFileCache(FlushFilterPrefix, &param);
    } else if (CheckoutFile(pszScriptPath, 0, &pOpenFile)) {
        //
        // this is just one file, or a directory whose
        // name didn't change. We only have to decache it.
        //
        IF_DEBUG( DIRECTORY_CHANGE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "DCM: decaching file \"%s\"\n",
                        pszScriptPath ));
        }

        DecacheFile(pOpenFile, 0);
    }
}

BOOL
ConvertToLongFileName(
                const char *pszPath,
                const char *pszName,
                WIN32_FIND_DATA *pwfd)
/*++

Routine Description:

    Finds the long filename corresponding to a munged 8.3 filename.

Arguments:

    pszPath     The path to the file
    pszName     The 8.3 munged version of the file name
    pwfd        Find data structure used to contain the long
                version of the file name.

Return Value:

    TRUE        if the file is found,
    FALSE       otherwise
--*/
{
    // Allocate enough memory to concatentate the file path and name

    DWORD cch = strlen(pszPath) + strlen(pszName) + 1;
    char *pszFullName = (char *) _alloca(cch + 1);
    DBG_ASSERT(pszFullName != NULL);

    // Copy the path into the working string
    // pT will point to the terminator of the application path

    char* pT = strcpyEx(pszFullName,
                        pszPath);

    // append a backslash
    *pT++ = '\\';

    // Now append the file name. Note that the script name is
    // relative to the directory that we received the notification for

    lstrcpy(pT, pszName);


    // FindFirstFile will find using the short name
    // We can then find the long name from the WIN32_FIND_DATA

    HANDLE hFindFile = FindFirstFile(pszFullName, pwfd);
    if (hFindFile == INVALID_HANDLE_VALUE)
    {
           return FALSE;
    }

    // Now that we have the find data we don't need the handle
    FindClose(hFindFile);
    return TRUE;
}



#endif // ENABLE_DIR_MONITOR




/*******************************************************************

    NAME:       IsCharTermA (DBCS enabled)

    SYNOPSIS:   check the character in string is terminator or not.
                terminator is '/', '\0' or '\\'

    ENTRY:      lpszString - string

                cch - offset for char to check

    RETURNS:    BOOL - TRUE if it is a terminator

    HISTORY:
        v-ChiKos    15-May-1997 Created.

********************************************************************/
BOOL
IsCharTermA(
    IN LPCSTR lpszString,
    IN INT    cch
    )
{
    CHAR achLast;

    achLast = *(lpszString + cch);

    if ( achLast == '/' || achLast == '\0' )
    {
        return TRUE;
    }

    achLast = *CharPrev(lpszString, lpszString + cch + 1);

    return (achLast == '\\');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\dirlist.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        dirlist.cxx

   Abstract:
        This module implements the member functions for TS_DIRECTORY_INFO

   Author:

           Murali R. Krishnan    ( MuraliK )     16-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:

         TS_DIRECTORY_INFO::CleanupThis()

         TS_DIRECTORY_INFO::GetDirectoryListingA()
                       IN LPCSTR     pszDirectoryName,
                       IN  HANDLE    hListingUser)

         TS_DIRECTORY_INFO::SortFileInfoPointers(
                       IN PFN_CMP_WIN32_FIND_DATA pfnCompare)

         TS_DIRECTORY_INFO::FilterFiles(
                       IN PFN_IS_MATCH_WIN32_FIND_DATA  pfnMatch,
                       IN LPVOID     pContext);

   Revision History:
       MuraliK     06-Dec-1995  Used Win32 apis instead of NT apis
       MCourage    05-Jan-1997  Moved to cache2 directory

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <tsunami.hxx>
# include "tsunamip.hxx"
# include "dbgutil.h"
# include <string.h>

/************************************************************
 *     Type Definitions
 ************************************************************/


dllexp
VOID
TS_DIRECTORY_INFO::CleanupThis( VOID)
{
    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Cleaning up TS_DIRECTORY_INFO ( %08p)\n",
                    this));
        Print();
    }

    if ( m_fValid) {

        if ( m_pTsDirectoryHeader != NULL) {

            TsFreeDirectoryListing( m_tsCache, m_pTsDirectoryHeader);
            m_pTsDirectoryHeader = NULL;
        }

        ASSERT( m_pTsDirectoryHeader == NULL);

        if ( m_prgFileInfo != NULL) {
            FREE( m_prgFileInfo);
            m_prgFileInfo = NULL;
        }
    }

    ASSERT( m_pTsDirectoryHeader == NULL);
    ASSERT( m_prgFileInfo == NULL);
    m_fValid = 0;
    m_cFilesInDirectory = 0;

} // TS_DIRECTORY_INFO::CleanupThis()




static BOOL
MakeCopyOfFileInfoPointers(
   IN OUT   PWIN32_FIND_DATA ** pppFileInfoTo,
   IN const PWIN32_FIND_DATA  * ppFileInfoFrom,
   IN int  nEntries)
/*++
  Allocates memory and makes a copy of the file info pointers in the array
   in ppFileInfoFrom.

  Returns:
    TRUE if success and FALSE if there is any failure.
--*/
{
    DWORD cbCopy;

    ASSERT( *pppFileInfoTo == NULL);

    cbCopy = nEntries * sizeof( PWIN32_FIND_DATA);

    *pppFileInfoTo = (PWIN32_FIND_DATA *) ALLOC( cbCopy);

    if ( *pppFileInfoTo != NULL) {

        memcpy((PVOID ) *pppFileInfoTo,
               (const PVOID ) ppFileInfoFrom,
               cbCopy);

    } else {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
    }

    return ( *pppFileInfoTo != NULL);
} // MakeCopyOfFileInfoPointers()




dllexp
BOOL
TS_DIRECTORY_INFO::GetDirectoryListingA(
    IN  LPCSTR          pszDirectoryName,
    IN  HANDLE          hListingUser)
{
    if ( m_pTsDirectoryHeader == NULL) {

        //
        //  Only if already a directory listing is not obtained.
        //  we obtain newly
        //

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "Obtaining Dir Listing for %s. UserHandle=%08p.\n",
                        pszDirectoryName, hListingUser));
        }

        m_fValid = TsGetDirectoryListing( m_tsCache,
                                           pszDirectoryName,
                                           hListingUser,
                                           &m_pTsDirectoryHeader);

        m_fValid = m_fValid &&
                   MakeCopyOfFileInfoPointers(
                       &m_prgFileInfo,
                       m_pTsDirectoryHeader->QueryArrayOfFileInfoPointers(),
                       m_pTsDirectoryHeader->QueryNumEntries());

        m_cFilesInDirectory = ( m_pTsDirectoryHeader == NULL) ? 0 :
                               m_pTsDirectoryHeader->QueryNumEntries();
    }

    return ( m_fValid);
} // TS_DIRECTORY_INFO::GetDirectoryListingA()




dllexp
BOOL
TS_DIRECTORY_INFO::SortFileInfoPointers(
    IN PFN_CMP_WIN32_FIND_DATA pfnCompare)
{
    BOOL  fReturn = FALSE;

    if ( IsValid()) {

        fReturn = SortInPlaceFileInfoPointers(m_prgFileInfo,
                                              m_cFilesInDirectory,
                                              pfnCompare);
    }

    return ( fReturn);
} // TS_DIRECTORY_INFO::SortFileInfoPointers()




dllexp
BOOL
TS_DIRECTORY_INFO::FilterFiles( IN PFN_IS_MATCH_WIN32_FIND_DATA  pfnMatch,
                                IN LPVOID  pContext)
/*++
  This function filters the list of files using the pfnMatch function
        and the context information specified by pContext.
  This function eliminates all the pointers to FileInfo which do not
    match the given file specification.

  Returns:
    TRUE on success and FALSE on failure.
--*/
{
    BOOL fReturn = FALSE;

    if ( IsValid()) {

        int idxScan;      // for scanning the files
        int idxCur;       // for updating after filter

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "FilterFiles in DirList( %08p) for FileSpec %08p\n",
                        this, pContext));
        }

        for( idxCur = idxScan = 0;
            idxScan < m_cFilesInDirectory;
            idxScan++) {

            PWIN32_FIND_DATA   pFileInfo =
               GetFileInfoPointerFromIdx( idxScan);

            ASSERT( pFileInfo != NULL);
            ASSERT( idxCur <= idxScan);

            if ( (*pfnMatch)( pFileInfo, pContext)) {

                //
                //  this is a match. Retain this item and advance CurPtr
                //
                m_prgFileInfo[ idxCur++] = m_prgFileInfo[ idxScan];
            }
        } // for

        m_cFilesInDirectory = idxCur;
        fReturn = TRUE;
    }

    return ( fReturn);
} // TS_DIRECTORY_INFO::FilterFiles()




# if DBG

VOID
TS_DIRECTORY_INFO::Print( VOID) const
{

    DBGPRINTF( ( DBG_CONTEXT,
                " Printing TS_DIRECTORY_INFO ( %08p).\n"
                "NumEntries=%d\t Valid = %d\n"
                "Directory Header ( %08p) \t ArrayOfFileInfo = %08p\n",
                this,
                m_cFilesInDirectory, m_fValid,
                m_pTsDirectoryHeader, m_prgFileInfo));

    for( int idx  = 0; idx < m_cFilesInDirectory; idx++) {

        PWIN32_FIND_DATA pfi = m_prgFileInfo[idx];

        DBGPRINTF( ( DBG_CONTEXT,
                    "rgFileInfo[%4d] = %08p. Name=%s Attr=0x%x"
                    "Size=0x%x:%x\n",
                    idx, pfi,
                    pfi->cFileName,
                    pfi->dwFileAttributes,
                    pfi->nFileSizeHigh,
                    pfi->nFileSizeLow
                    ));
    }

    m_pTsDirectoryHeader->Print();

    return;
} // TS_DIRECTORY_INFO::Print()


# endif // DBG




BOOL __cdecl
RegExpressionMatchFileInfo( IN const WIN32_FIND_DATA  * pFileInfo,
                            IN CHAR * pszExpression)
/*++
  This function tries to find a match between the file name in
  pFileInfo and the regular expression specified in pszExpression.

  Arguments:
     pFileInfo  -- pointer to file information consisting under query.
     pszExpression - pointer to null-terminated string containing the
                      regular expression, against which file name is tobe
                      matched for.

  Returns:
    TRUE on a match and false if there is any failure.
--*/
{
    const CHAR * pszFileName;

    DBG_ASSERT( pFileInfo != NULL);
    pszFileName = pFileInfo->cFileName;

    if ( strpbrk( pszExpression, "?*<>") != NULL) {

        // No Wild cards. Do normal file comparisons
        return ( strcmp( pszFileName, pszExpression) == 0);
    } else {

        // do a case sensitive comparison
        return IsNameInRegExpressionA( pszExpression, pszFileName, FALSE);
    }

} // RegExpressionMatch()





/************************************************************
 *  Following code is based on the FileSystem Rtl routines
 *    from ntos\fsrtl\name.c
 *  But these are optimized for performance, in our case
 *    using ANSI strings!
 ************************************************************/

# define MAX_MATCHES_ARRAY_SIZE    (16)
# define IS_EMPTY_STRING(psz)      ( (psz) == NULL || *(psz) == '\0')


//
// Original code used USHORT for ULEN. However using USHORT asks
//  a 32 bit processor to add  "and <value>, 0xff for each instruction
//  that accessed the 16 bit (USHORT) value.
// Hence, I decided to use DWORD, since the space usage is not tremendous
//   during the fast path work, compared to performance benefits.
//  - MuraliK (Oct 27, 1995)
//

//  typedef  USHORT  ULEN;
typedef DWORD ULEN;


BOOL __cdecl
IsNameInRegExpressionA(
    IN LPCSTR   pszExpression,
    IN LPCSTR   pszName,
    IN BOOL     fIgnoreCase)
/*++
  This routine compares an ANSI name and an expression and decries to the
  caller if the name is in hte language defined by the expression. The input
  name cannot contain wildcards, while the expression itself may contain
  wildcards.

  Expression wild cards are evaluated as shown in the non-deterministic finite
   automatons below. Note that ~* and ~? stand for DOS_STAR and DOS_QM.


             ~* is DOS_STAR, ~? is DOS_QM, and ~. is DOS_DOT


                                       S
                                    <-----<
                                 X  |     |  e       Y
             X * Y ==       (0)----->-(1)->-----(2)-----(3)


                                      S-.
                                    <-----<
                                 X  |     |  e       Y
             X ~* Y ==      (0)----->-(1)->-----(2)-----(3)



                                X     S     S     Y
             X ?? Y ==      (0)---(1)---(2)---(3)---(4)



                                X     .        .      Y
             X ~.~. Y ==    (0)---(1)----(2)------(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^


                                X     S-.     S-.     Y
             X ~?~? Y ==    (0)---(1)-----(2)-----(3)---(4)
                                   |      |________|
                                   |           ^   |
                                   |_______________|
                                      ^EOF or .^



         where S is any single character

               S-. is any single character except .

               e is a null character transition

               EOF is the end of the name string


    The last construction, ~? (the DOS question mark), can either match any
    single character, or upon encountering a period or end of input string,
    advances the expression to the end of the set of contiguous ~?s.  This may
    seem somewhat convoluted, but is what DOS needs.

  Arguments:
    pszExpression - Supplies the input expression to check against
     ( Caller must already lowercased if passing fIgnoreCase TRUE.)

    pszName  - supplies the input name to check for.

    fIgnoreCase - if TRUE, the name should be lower-cased before comparing.
     ( that is done by this function, dynamically without destroying pszName)

    This function is costly, if the pszExpression does not contain
      any wild cards to be matched for. So Dont use it if there are
      no wild cards in the pszExpression

  Returns:
     BOOL  -- TRUE if pszName is an element in the set of strings denoted
        by the input expression.  FALSE if otherwise.
--*/
{
    ULEN    NameLen;       // length in character count
    ULEN    ExprLen;

    /*
     * Algorithm:
     *  Keep track of all possible locations in the regular expression
     *   that are matching the name. If when the name has been exhausted
     *   one of the locations in the expression is also just exhausted, the
     *  name is in the language defined by the regular expression.
     */


    DBG_ASSERT( pszName != NULL && *pszName != '\0');
    DBG_ASSERT( pszExpression != NULL && *pszExpression != '\0');

    //
    // if one string is empty return FALSE. If both are empty TRUE.
    //

    if ( IS_EMPTY_STRING(pszName) || IS_EMPTY_STRING(pszExpression)) {

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " IsNameInRegExpr( %s, %s, %d) ==>%d\n",
                       pszExpression, pszName, fIgnoreCase,
                       !(*pszName + *pszExpression)
                       ));
        }

        return (BOOL ) (IS_EMPTY_STRING(pszName) && IS_EMPTY_STRING(pszExpression));
    }

    NameLen = strlen(pszName);
    ExprLen = strlen(pszExpression);

    //
    // Special case: reduce the most common wild card search of *
    //

    if ( ExprLen == 1 && pszExpression[0] == '*') {

        IF_DEBUG ( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " IsNameInRegExpr( %s, %s, %d) ==>%d\n",
                       pszExpression, pszName, fIgnoreCase,
                       TRUE
                       ));
        }

        // matches anything. so return TRUE
        return (TRUE);
    }

    //
    //  Walk through the name string, picking off characters.  We go one
    //  character beyond the end because some wild cards are able to match
    //  zero characters beyond the end of the string.
    //
    //  With each new name character we determine a new set of states that
    //  match the name so far.  We use two arrays that we swap back and forth
    //  for this purpose.  One array lists the possible expression states for
    //  all name characters up to but not including the current one, and other
    //  array is used to build up the list of states considering the current
    //  name character as well.  The arrays are then switched and the process
    //  repeated.
    //
    //  There is not a one-to-one correspondence between state number and
    //  offset into the pszExpression.  This is evident from the NFAs in the
    //  initial comment to this function.  State numbering is not continuous.
    //  This allows a simple conversion between state number and expression
    //  offset.  Each character in the Expression can represent one or two
    //  states.  '*' and DOS_STAR generate two states: ExprOffset*2 and
    //  ExprOffset*2 + 1.  All other expression characters can produce only
    //  a single state.  Thus ExprOffset = State/2.
    //
    //
    //  Here is a short description of the variables involved:
    //
    //  NameOffset  -The offset of the current name char being processed.
    //
    //  ExprOffset  -The offset of the current expression char being processed.
    //
    //  SrcCount    -Prior match being investigated with current name char
    //
    //  DestCount   -Next location to put a matching assuming current name char
    //
    //  NameFinished - Allows one more iteration through the Matches array
    //                 after the name is exhusted (to come *s for example)
    //
    //  PreviousDestCount - This is used to prevent entry duplication,
    //                       see comment
    //
    //  PreviousMatches   - Holds the previous set of matches (the Src array)
    //
    //  CurrentMatches    - Holds the current set of matches (the Dest array)
    //
    //  AuxBuffer, LocalBuffer - the storage for the Matches arrays
    //

    ULEN NameOffset;    // offset in terms of byte count
    ULEN ExprOffset;    // offset in terms of byte count

    ULONG SrcCount;
    ULONG DestCount;
    ULONG PreviousDestCount;
    ULONG MatchesCount;
    ULONG BufSize = MAX_MATCHES_ARRAY_SIZE;

    CHAR NameChar, ExprChar;

    // for prev and current matches
    ULEN *AuxBuffer = NULL;
    ULEN *PreviousMatches;
    ULEN *CurrentMatches;

    ULEN MaxState;
    ULEN CurrentState;

    BOOL NameFinished;

    ULEN LocalBuffer[MAX_MATCHES_ARRAY_SIZE * 2];

    // set up the intial values
    // Use the different portions of local buffer for matches.

    PreviousMatches = &LocalBuffer[0];
    CurrentMatches  = &LocalBuffer[MAX_MATCHES_ARRAY_SIZE];

    PreviousMatches[0] = 0;
    MatchesCount       = 1;

    NameOffset = 0;
    MaxState   = (ULEN ) (ExprLen * 2);

    NameFinished = FALSE;
    while (!NameFinished) {


        if ( NameOffset < NameLen) {

            NameChar = pszName[NameOffset/sizeof(CHAR)];
            NameOffset += sizeof(CHAR);
        } else {

            NameFinished = TRUE;

            // if we already exhauseted expression, stop. Else continue
            DBG_ASSERT( MatchesCount >= 1);
            if ( PreviousMatches[MatchesCount - 1] == MaxState) {

                break;
            }
        }

        //
        // Now, for each of previous stored expression matches,
        //  see what we can do with the new name character.
        //

        DestCount = 0;
        PreviousDestCount = 0;

        for( SrcCount = 0;  SrcCount < MatchesCount; ) {

            ULEN Length;

            //
            //  We have to carry on our expression analysis as far as possible
            //  for each character of name, so we loop here until the
            //  expression stops matching.  A clue here is that expression
            //  cases that can match zero or more characters end with a
            //  continue, while those that can accept only a single character
            //  end with a break.
            //

            ExprOffset = (ULEN)((PreviousMatches[SrcCount++] + 1) / 2);

            for( Length = 0; ExprOffset != ExprLen; ) {

                //
                // increment the expression offset to move to next character.
                //
                ExprOffset += Length;
                Length = sizeof(CHAR);

                CurrentState = (ULEN)(ExprOffset * 2);

                if ( ExprOffset == ExprLen * sizeof(CHAR)) {

                    CurrentMatches[DestCount++] = MaxState;
                    break;
                }

                ExprChar = pszExpression[ ExprOffset/sizeof(CHAR) ];

                ASSERT( !fIgnoreCase ||
                        !((ExprChar >= 'A') && (ExprChar <= 'Z')));

                //
                // Before we get started, we have to check for something really
                //  gross. We may be about to exhaust the local space for
                //  ExpressionMatch[][], so when we have to allocate some
                //   pool if this is the case. Yuk!
                //

                if ( DestCount >= BufSize - 2 ) {

                    if (AuxBuffer == NULL) {

                        // 2 copies of array each with 2 states for each char
                        //  in the expression. Each state == ULEN.

                        IF_DEBUG( DIR_LIST) {
                            DBGPRINTF((DBG_CONTEXT, "IsNInExpr(%s,%s,%d):"
                                       "alloc %d for exprlen=%d\n",
                                       pszExpression, pszName, fIgnoreCase,
                                       (ExprLen + 1) *sizeof(ULEN)*2*2,
                                       ExprLen));
                        }

                        BufSize = (ExprLen+1)*2;

                        AuxBuffer = ((ULEN *)
                                     ALLOC(BufSize * sizeof(ULEN) * 2)
                                     );
                        if ( AuxBuffer == NULL) {

                            DBG_ASSERT(!"Failure in mem alloc");

                            return ( FALSE);
                        }

                        RtlCopyMemory( AuxBuffer, CurrentMatches,
                                      MAX_MATCHES_ARRAY_SIZE*sizeof(ULEN));
                        CurrentMatches = AuxBuffer;

                        RtlCopyMemory( AuxBuffer + BufSize,
                                      PreviousMatches,
                                      MAX_MATCHES_ARRAY_SIZE * sizeof(ULEN));

                        PreviousMatches = AuxBuffer + BufSize;
                    } else {

                        DBG_ASSERT(!"Double Overflow occured\n");

                        FREE( AuxBuffer );

                        return FALSE;
                    }
                }

                //
                // '*' Matches any character zero or more times
                //
                if ( ExprChar == '*') {

                    // Add all possible next states into the list
                    // use the above state diagram to identify this.
                    CurrentMatches[DestCount] = CurrentState;
                    CurrentMatches[DestCount+1] = CurrentState + 1;
                    DestCount+= 2;
                    continue;
                }

                //
                // ANSI_DOS_STAR matches any char, zero or more times,
                //  except the DOS's extension '.'
                //

                if ( ExprChar == ANSI_DOS_STAR) {

                    BOOL  ICanEatADot = FALSE;

                    //
                    // If we are at a period, determine if we are
                    //  allowed to consume it. i.e make it is not last one.
                    //
                    if ( !NameFinished && (NameChar == '.')) {

                        ULEN cchOffset;  // in character counts
                        for( cchOffset = NameOffset/sizeof(CHAR);
                            cchOffset < NameLen;
                            cchOffset ++) {

                            if ( pszName[cchOffset]  == '.') {

                                ICanEatADot = TRUE;
                                break;
                            }
                        } // for
                    }

                    if ( NameFinished || (NameChar != '.') || ICanEatADot) {

                        //
                        // Go ahead and consume this character.
                        // Gives two options to move forward.
                        //
                        CurrentMatches[DestCount] = CurrentState;
                        CurrentMatches[DestCount+1] = CurrentState+1;
                        DestCount += 2;
                        continue;
                    } else {

                        //
                        // We are at the period. We can only match zero
                        //  or more characters (ie. the epsilon transition)
                        //

                        CurrentMatches[DestCount++] = CurrentState+1;
                        continue;
                    }
                } // if ( ExprChar == DOS_STAR)

                //
                // The following expression characters all match by consuming
                //  a character, thus force the expression, and thus state
                //  move forward.
                //

                CurrentState += (ULEN)(sizeof(CHAR) *2);

                //
                //  DOS_QM is the most complicated.  If the name is finished,
                //  we can match zero characters.  If this name is a '.', we
                //  don't match, but look at the next expression.  Otherwise
                //  we match a single character.
                //

                if ( ExprChar == ANSI_DOS_QM ) {

                    if ( NameFinished || (NameChar == '.') ) {

                        continue;
                    }

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                //  DOS_DOT can match either a period, or zero characters
                //  beyond the end of the name
                //

                if ( ExprChar == ANSI_DOS_DOT) {

                    if ( NameFinished) {
                        continue;
                    }

                    if ( NameChar == '.') {

                        CurrentMatches[DestCount++] = CurrentState;
                        break;
                    }
                }

                //
                // From this point on a name character is required to
                //  even continue searching, let alone make a match.
                // So if Name is finished, stop.
                //

                if ( NameFinished) {

                    break;
                }

                //
                // If the expression was a '?' we can match it once
                //
                if ( ExprChar == '?') {

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                // Finally, check if the expression char matches name char
                //

                if ( ExprChar == (CHAR ) (fIgnoreCase ?
                                          tolower(NameChar) : NameChar)
                    ){

                    CurrentMatches[DestCount++] = CurrentState;
                    break;
                }

                //
                // The expression did not match, go look at the next
                //  previous match
                //
                break;
            } // for matching from an old state.


            //
            //  Prevent duplication in the destination array.
            //
            //  Each of the arrays is montonically increasing and non-
            //  duplicating, thus we skip over any source element in the src
            //  array if we just added the same element to the destination
            //  array.  This guarentees non-duplication in the dest. array.
            //

            while ( SrcCount < MatchesCount &&
                   PreviousDestCount < DestCount) {
                //
                // logic here is: by eliminating the states with
                //  lesser number than current matched ==> we are
                //  skipping over the smallest states from which
                //  no match may be found.
                //

                if ( PreviousMatches[SrcCount] <
                    CurrentMatches[PreviousDestCount] ) {

                    SrcCount ++;
                }

                PreviousDestCount += 1;
            } // while
        } // for each of old matches....

        //
        //  If we found no matches in the just finished iteration, it's time
        //  to bail.
        //

        if ( DestCount == 0 ) {

            if (AuxBuffer != NULL) {
                IF_DEBUG( DIR_LIST) {

                    DBGPRINTF((DBG_CONTEXT, " Freeing %08p\n", AuxBuffer));
                }

                FREE( AuxBuffer );
            }

            return FALSE;
        }

        //
        //  Swap the meaning the two arrays
        //

        {
            ULEN *Tmp;

            Tmp = PreviousMatches;

            PreviousMatches = CurrentMatches;

            CurrentMatches = Tmp;
        }

        MatchesCount = DestCount;

    } // for each char in Name, until name is finished.

    DBG_ASSERT(MatchesCount > 0);
    CurrentState = PreviousMatches[MatchesCount-1];
    if (AuxBuffer != NULL) {
        IF_DEBUG( DIR_LIST) {
            DBGPRINTF((DBG_CONTEXT, " Freeing %08p\n", AuxBuffer));
        }

        FREE( AuxBuffer );
    }

    return (BOOL ) ( CurrentState == MaxState);

} //  IsNameInRegExpressionA()


/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\etagmb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    etagmb.cxx

    This module contains the methods for ETagMetabaseSink and
    ETagChangeNumber, which watch the metabase for change
    notifications relating to ETags

    FILE HISTORY:
        GeorgeRe    02-Aug-1999     Created
*/

#define INITGUID 
#include <tsunami.hxx>
#include "tsunamip.hxx"
#include "etagmb.h"

ETagChangeNumber* ETagChangeNumber::sm_pSingleton = NULL;

HRESULT
ETagMetabaseSink::SinkNotify(
    /* [in] */          DWORD              dwMDNumElements,
    /* [size_is][in] */ MD_CHANGE_OBJECT_W pcoChangeList[])

/*++

Routine Description:

    This is the change notification routine.  It is called by
    the metabase whenever there is a change in the metabase.

    This routine walks the list of changed metabase values to determine
    whether any etag-related properties have been modified.

Arguments:

    dwMDNumElements - The number of MD_CHANGE_OBJECT structures passed
        to this routine.

    pcoChangeList - An array of all the metabase values that have changed.

Return Value:

    Not used.

--*/

{
    int cUpdates = 0;

    for (DWORD i = 0;  i < dwMDNumElements;  ++i)
    {
        for (DWORD j = 0;  j < pcoChangeList[i].dwMDNumDataIDs;  ++j)
        {
            switch (pcoChangeList[i].pdwMDDataIDs[j])
            {
            case MD_HTTP_PICS:                      // HttpPics
            case MD_DEFAULT_LOAD_FILE:              // DefaultDoc
            case MD_FOOTER_DOCUMENT:                // DefaultDocFooter
            case MD_FOOTER_ENABLED:                 // EnableDocFooter
            case MD_SCRIPT_MAPS:                    // ScriptMaps
            case MD_MIME_MAP:                       // MimeMap
            case MD_VPROP_DIRBROW_LOADDEFAULT:      // EnableDefaultDoc
            case MD_ASP_CODEPAGE:                   // AspCodepage
            case MD_ASP_ENABLEAPPLICATIONRESTART:   // AspEnableApplicationRestart
                ++cUpdates;
                IF_DEBUG( CACHE) {
                    DBGPRINTF(( DBG_CONTEXT,
                                "Updating ETag Change Number for notification %d\n",
                                pcoChangeList[i].pdwMDDataIDs[j]
                                ));
                }
                goto endloop;

            default:
                break;
            }
        }
    }

  endloop:
    if (cUpdates > 0)
    {
        m_pParent->UpdateChangeNumber();
    }
    else
    {
        IF_DEBUG( CACHE) {
            DBGPRINTF(( DBG_CONTEXT,
                        "SinkNotify: not interested in %d changes\n", 
                        dwMDNumElements
                        ));
        }
    }

    return S_OK;
}


ETagChangeNumber::ETagChangeNumber()
    : m_pSink(NULL),
      m_pcAdmCom(NULL),
      m_pConnPoint(NULL),
      m_pConnPointContainer(NULL),
      m_dwSinkNotifyCookie(0),
      m_fChanged(FALSE)
{
    m_dwETagMetabaseChangeNumber = GetETagChangeNumberFromMetabase();
    m_pSink = new ETagMetabaseSink(this);

    HRESULT hr = (m_pSink != NULL) ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_MSAdminBase_W, NULL, CLSCTX_ALL, 
                              IID_IMSAdminBase, (void**) &m_pcAdmCom);
        if (FAILED(hr))
        {
            DBGERROR(( DBG_CONTEXT,
                       "CCI(CLSID_MSAdminBase_W) failed: err %x\n", 
                       hr
                       ));
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pcAdmCom->QueryInterface(IID_IConnectionPointContainer,
                                        (void**) &m_pConnPointContainer);
        if (FAILED(hr))
        {
            DBGERROR(( DBG_CONTEXT,
                       "QI(IConnectionPointContainer failed): %x\n", 
                       hr
                       ));
        }
    }
    
    if (SUCCEEDED(hr))
    {
        hr = m_pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink_W,
                                                        &m_pConnPoint);
        if (FAILED(hr))
        {
            DBGERROR(( DBG_CONTEXT,
                       "FindConnectionPoint failed: err %x\n", 
                       hr
                       ));
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = m_pConnPoint->Advise(m_pSink, &m_dwSinkNotifyCookie);
        if (FAILED(hr))
        {
            DBGERROR(( DBG_CONTEXT,
                       "Advise failed: err %x\n", 
                       hr 
                       ));
        }
    }

    if (FAILED(hr))
    {
        Cleanup();
    }
    else
    {
        DBGERROR(( DBG_CONTEXT,
                   "Created ETagChangeNumber successfully, %d\n",
                   m_dwETagMetabaseChangeNumber
                   ));
    }
}


ETagChangeNumber::~ETagChangeNumber()
{
    if (m_fChanged)
        SetETagChangeNumberInMetabase(m_dwETagMetabaseChangeNumber);
    Cleanup();
}


void
ETagChangeNumber::Cleanup()
{
    if (m_pConnPoint != NULL)
    {
        if (m_dwSinkNotifyCookie != 0)
            m_pConnPoint->Unadvise(m_dwSinkNotifyCookie);
        
        m_pConnPoint->Release();
    }
    m_dwSinkNotifyCookie = 0;
    m_pConnPoint = NULL;

    if (m_pConnPointContainer != NULL)
        m_pConnPointContainer->Release();
    m_pConnPointContainer = NULL;

    if (m_pcAdmCom != NULL)
        m_pcAdmCom->Release();
    m_pcAdmCom = NULL;

    if (m_pSink != NULL)
        m_pSink->Release();
    m_pSink = NULL;

    m_fChanged = FALSE;
}


//
// Read the ETag Metabase Change Number from the metabase
//
DWORD
ETagChangeNumber::GetETagChangeNumberFromMetabase()
{
    MB    mb((IMDCOM*) IIS_SERVICE::QueryMDObject());
    DWORD dwETagMetabaseChangeNumber;

    mb.GetSystemChangeNumber(&dwETagMetabaseChangeNumber);

    if (mb.Open(IIS_MD_LOCAL_MACHINE_PATH "/w3svc", METADATA_PERMISSION_READ))
    {
         if (mb.GetDword("", MD_ETAG_CHANGE_NUMBER, IIS_MD_UT_SERVER,
                         &dwETagMetabaseChangeNumber))
         {
            IF_DEBUG( CACHE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "ETag Change Number = %x.\n",
                            dwETagMetabaseChangeNumber
                            ));
            }
         }
         else
         {
            IF_DEBUG( CACHE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "No ETag Change Number. Using %d. Error = %lu\n",
                            dwETagMetabaseChangeNumber, 
                            GetLastError()
                            ));
            }
         }
         mb.Close();
    }
    else
    {
        DBGERROR(( DBG_CONTEXT,
                   "Couldn't open metabase. Using %x instead. Error = %lu.\n",
                   dwETagMetabaseChangeNumber, 
                   GetLastError()
                   ));
    }

    return dwETagMetabaseChangeNumber;
}


//
// Persist the ETag Metabase Change Number to the metabase
//
BOOL
ETagChangeNumber::SetETagChangeNumberInMetabase(
    DWORD dwETagMetabaseChangeNumber)
{
    MB   mb((IMDCOM*) IIS_SERVICE::QueryMDObject());
    BOOL fSuccess = FALSE;
    
    if (mb.Open(IIS_MD_LOCAL_MACHINE_PATH "/w3svc", METADATA_PERMISSION_WRITE))
    {
        if (mb.SetDword("", MD_ETAG_CHANGE_NUMBER, IIS_MD_UT_SERVER,
                        dwETagMetabaseChangeNumber))
        {
            fSuccess = TRUE;
            IF_DEBUG( CACHE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "Updated ETag Metabase Change Number to %x.\n",
                            dwETagMetabaseChangeNumber
                            ));
            }
        }
        else
        {
            IF_DEBUG( CACHE) {
                DBGPRINTF(( DBG_CONTEXT,
                            "Unable to update ETag Metabase Change Number to %x.\n",
                            dwETagMetabaseChangeNumber
                            ));
            }
        }
        mb.Close();
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\etagmb.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1999                **/
/**********************************************************************/

/*
    etagmb.h

    This module contains the methods for ETagMetabaseSink and
    ETagChangeNumber, which watch the metabase for change
    notifications relating to ETags

    (Adapted from the MB sink notification code in compfilt)

    The underlying rationale for this code is that ETags are computed from a
    function of several variables including the metabase change number. ETags
    are used as part of the If-Modified-Since logic of browsers and proxy
    caches. If the ETags don't match, the cached copy is discarded. The
    metabase change number changes a lot but most of the changes can have no
    possible effect on the contents of a page or its headers. The few
    properties that could make a difference, such as PICS headers or footers,
    are tracked by this code for a low-volatility change number. Voila, more
    effective browser and proxy caching, leading to reduced network utilization
    and better response times as well as reduced load on the server.

    The code persists this number to the metabase on shutdown. If it didn't,
    then the etagchangenumber used when the server restarts will not match the
    one used in the previous session, so ETags will differ and remote caches
    will not be as effective.

    FILE HISTORY:
        GeorgeRe    02-Aug-1999     Created
*/

#ifndef __ETAGMB_H__
#define __ETAGMB_H__

#include <iadmw.h>

class ETagChangeNumber;

class ETagMetabaseSink : public IMSAdminBaseSinkW
{
public:
    ETagMetabaseSink(
        ETagChangeNumber* pParent)
        : m_dwRefCount(1),
          m_pParent(pParent)
    {}

    ~ETagMetabaseSink()
    {}

    HRESULT STDMETHODCALLTYPE
    QueryInterface(REFIID riid, void **ppvObject)
    {
        if (riid == IID_IUnknown || riid == IID_IMSAdminBaseSink)
        {
            *ppvObject = (IMSAdminBaseSink*) this;
        }
        else
        {
            *ppvObject = NULL;
            return E_NOINTERFACE;
        }
        AddRef();
        return S_OK;
    }

    ULONG STDMETHODCALLTYPE
    AddRef()
    {
        return InterlockedIncrement((LONG*) &m_dwRefCount);
    }

    ULONG STDMETHODCALLTYPE
    Release()
    {
        DWORD dwRefCount = InterlockedDecrement((LONG*) &m_dwRefCount);
        if (dwRefCount == 0)
            delete this;
        return dwRefCount;
    }

    HRESULT STDMETHODCALLTYPE
    SinkNotify(
        /* [in] */          DWORD              dwMDNumElements,
        /* [size_is][in] */ MD_CHANGE_OBJECT_W pcoChangeList[]);

    HRESULT STDMETHODCALLTYPE
    ShutdownNotify()
    {
        return S_OK;
    }

public:
    ULONG             m_dwRefCount;
    ETagChangeNumber* m_pParent;
};


class ETagChangeNumber
{
public:
    ETagChangeNumber();
    ~ETagChangeNumber();

    void UpdateChangeNumber()
    {
        InterlockedIncrement((LONG*) &m_dwETagMetabaseChangeNumber);
        // Don't write to the metabase now, or we'll generate recursive
        // notifications
        m_fChanged = TRUE;
    }

    static DWORD
    GetChangeNumber()
    {
        DWORD dw = 0;

        if (sm_pSingleton != NULL)
        {
            dw = sm_pSingleton->m_dwETagMetabaseChangeNumber;
            if (sm_pSingleton->m_fChanged)
            {
                sm_pSingleton->m_fChanged = FALSE;
                SetETagChangeNumberInMetabase(dw);
            }
        }

        return dw;
    }

    static HRESULT
    Create()
    {
        DBG_ASSERT(sm_pSingleton == NULL);
        sm_pSingleton = new ETagChangeNumber();
        if (sm_pSingleton == NULL)
            return E_OUTOFMEMORY;
        else if (sm_pSingleton->m_dwSinkNotifyCookie == 0)
            return E_FAIL;
        else
            return S_OK;
    }

    static void
    Destroy()
    {
        delete sm_pSingleton;
        sm_pSingleton = NULL;
    }

    static DWORD
    GetETagChangeNumberFromMetabase();

    static BOOL
    SetETagChangeNumberInMetabase(
        DWORD dwETagMetabaseChangeNumber);

private:
    void
    Cleanup();

    DWORD                       m_dwETagMetabaseChangeNumber;
    ETagMetabaseSink*           m_pSink;
    IMSAdminBase*               m_pcAdmCom;
    IConnectionPoint*           m_pConnPoint;
    IConnectionPointContainer*  m_pConnPointContainer;
    DWORD                       m_dwSinkNotifyCookie;
    BOOL                        m_fChanged;

    static ETagChangeNumber*    sm_pSingleton;
};

extern ETagChangeNumber* g_pETagChangeNumber;

#endif // __ETAGMB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\filecach.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    filecach.cxx

    This module implements the private interface to the file cache

    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include "tsunamip.hxx"

#include <tsunami.hxx>
#include "filecach.hxx"
#include "filehash.hxx"
#include "tlcach.h"
#include <dbgutil.h>

/*
 * Globals
 */
CFileHashTable *  g_pFileInfoTable;
CFileCacheStats * g_pFileCacheStats;

HANDLE            g_hFileCacheShutdownEvent;
BOOL              g_fFileCacheShutdown;

CRITICAL_SECTION  g_csUriInfo;



#if TSUNAMI_REF_DEBUG
PTRACE_LOG g_pFileRefTraceLog;
#endif


/*
 * Private helper function declarations
 */
inline VOID I_DerefFileInfo(TS_OPEN_FILE_INFO *pOpenFile);
VOID        I_AddRefIO(TS_OPEN_FILE_INFO *pOpenFile);
VOID        I_DerefIO(TS_OPEN_FILE_INFO *pOpenFile);


BOOL FileFlushFilterAll(TS_OPEN_FILE_INFO *pOpenFile, PVOID pv);


/*
 * function definitions
 */
BOOL
FileCache_Initialize(
    IN  DWORD dwMaxFiles
    )
{
    BOOL fReturn;
#if TSUNAMI_REF_DEBUG
    g_pFileRefTraceLog = CreateRefTraceLog(
                            256,              // LogSize
                            0                 // ExtraBytesInHeader
                            );
#endif  // TSUNAMI_REF_DEBUG

    g_pFileInfoTable = new CFileHashTable("FCinfo");
    g_pFileCacheStats = new CFileCacheStats;

    g_fFileCacheShutdown = FALSE;
    g_hFileCacheShutdownEvent = CreateEvent(NULL, TRUE, FALSE, NULL);

    INITIALIZE_CRITICAL_SECTION( &g_csUriInfo );

    if (g_bEnableSequentialRead) {
        TsCreateFileFlags |= FILE_FLAG_SEQUENTIAL_SCAN;
    }

    fReturn = (g_pFileInfoTable
               && g_pFileCacheStats
               && TS_OPEN_FILE_INFO::Initialize(dwMaxFiles)
               && (InitializeTwoLevelCache(g_dwMemCacheSize) == ERROR_SUCCESS)
               && g_hFileCacheShutdownEvent);

    if (!fReturn) {
        FileCache_Terminate();
    }

    return fReturn;

}

VOID
FileCache_Terminate(
    VOID
    )
{
    g_fFileCacheShutdown = TRUE;

    FlushFileCache();

    //
    // At this point the hash table is empty, but there will still
    // be some oplocked files hanging around. We have to wait for
    // all the oplock completions before moving on.
    //
    if (g_pFileCacheStats->GetFlushedEntries()) {
        WaitForSingleObject(g_hFileCacheShutdownEvent, TS_FILE_CACHE_SHUTDOWN_TIMEOUT);
        DBG_ASSERT( g_pFileCacheStats->GetFlushedEntries() == 0 );
    }


    DeleteCriticalSection( &g_csUriInfo );

    CloseHandle(g_hFileCacheShutdownEvent);
    g_hFileCacheShutdownEvent=NULL;

    DBG_REQUIRE(TerminateTwoLevelCache() == ERROR_SUCCESS);

    TS_OPEN_FILE_INFO::Cleanup();
    delete g_pFileInfoTable;

    DBGPRINTF(( DBG_CONTEXT,
                 "FileCache_Terminate: deleted g_pFileInfoTable.\n" ));

    delete g_pFileCacheStats;
    g_pFileInfoTable = NULL;
    g_pFileCacheStats = NULL;

#if TSUNAMI_REF_DEBUG
    if( g_pFileRefTraceLog != NULL ) {
        DestroyRefTraceLog( g_pFileRefTraceLog );
        g_pFileRefTraceLog = NULL;
    }
#endif  // TSUNAMI_REF_DEBUG
}


DWORD
CacheFile(
    IN  TS_OPEN_FILE_INFO * pOpenFile,
    IN  DWORD               dwFlags
    )
/*++
Routine Description:

    Add a file info structure to the cache.

    If the FCF_UNINITIALIZED flag is set, the file will be added to
    the cache, but calls to CheckoutFile will be blocked until the
    file is marked initialized with NotifyFileInitialized.
    CheckoutFileEntry will not block. I expect that this flag will
    always be set.

    The FCF_FOR_IO flag indicates that the caller will be performing
    I/O operations with the cached file handle. This flag will be
    clear in most cases except in TsCreateFile.

Arguments:

    pOpenFile - The structure to be cached.
    pstrPath - The pathname that will be used to look up the cache entry.
    dwFlags - Valid flags are FCF_UNINITIALIZED and FCF_FOR_IO.

Return Value:

    TS_ERROR_SUCCESS
    TS_ERROR_OUT_OF_MEMORY
    TS_ERROR_ALREADY_CACHED
--*/
{
    enum LK_RETCODE lkRetval;
    DWORD dwRetval;

    DBG_ASSERT( pOpenFile != NULL );

    //
    // The caller gets a reference to this file info object
    //
    pOpenFile->AddRef();

    //
    // Don't need to acquire the lock since the object is not yet
    // in the cache.
    //
    pOpenFile->SetCached();
    if (dwFlags & FCF_FOR_IO) {
        pOpenFile->AddRefIO();
    }
   
    if (! (dwFlags & FCF_UNINITIALIZED)) {
        pOpenFile->SetInitialized();
    }

    //
    // Put it in the hash table
    //
    lkRetval = g_pFileInfoTable->InsertRecord(pOpenFile, false);

    if (LK_SUCCESS == lkRetval) {
        dwRetval = TS_ERROR_SUCCESS;
        g_pFileCacheStats->IncFilesCached();
    } else {
        if (LK_ALLOC_FAIL == lkRetval) {
            dwRetval = TS_ERROR_OUT_OF_MEMORY;
        } else if (LK_KEY_EXISTS == lkRetval) {
            dwRetval = TS_ERROR_ALREADY_CACHED;
        } else {
            //
            // No other error should come to pass
            //
            dwRetval = TS_ERROR_OUT_OF_MEMORY;
            DBG_ASSERT(FALSE);
        }

        pOpenFile->ClearCached();
        if (dwFlags & FCF_FOR_IO) {
            pOpenFile->DerefIO();
        }

        //
        // Remove the reference we added.
        // Don't call I_DerefFileInfo, because this
        // object never made it to the cache.
        // The caller will free the memory.
        //
        pOpenFile->Deref();
    }

    return dwRetval;
}


VOID
NotifyInitializedFile(
    IN  TS_OPEN_FILE_INFO * pOpenFile
    )
/*++
Routine Description:

    This function tells that cache that a file previously cached with
    CacheUninitializedFile, is now ready for use.

Arguments:

    pOpenFile - The file which is now initialized.

Return Value:

    None.
--*/
{
    BOOL bShouldClose;

    CHECK_FILE_STATE( pOpenFile );

    //
    // Mark the file as initialized
    //
    pOpenFile->Lock();
    pOpenFile->SetInitialized();
    bShouldClose = pOpenFile->IsCloseable();
    pOpenFile->Unlock();

    //
    // Clean up as neccessary
    // Note that I don't have to worry about the IO refcount
    // going back up because the file is marked as flushed.
    //
    if (bShouldClose) {
        pOpenFile->CloseHandle();
    }

    //
    // TODO: need to execute any notification code?
    //
}


VOID
DecacheFile(
    IN  TS_OPEN_FILE_INFO * pOpenFile,
    IN  DWORD               dwFlags
    )
/*++
Routine Description:

    Remove a file info entry from the cache. After a call to
    DecacheFile the entry will not be returned by CheckoutFile. The
    entry itself is cleaned up when the last CheckinFile occurs.
    Calling DecacheFile checks the entry in.

    The FCF_FOR_IO flag indicates that the caller will be performing
    I/O operations with the cached file handle. I expect that this flag
    will always be clear.

Arguments:

    pOpenFile - The file info structure to be decached
    dwFlags   - Valid flags are FCF_FOR_IO, FCF_NO_DEREF.

Return Value:

    None.
--*/
{
    BOOL  bShouldClose;
    TS_OPEN_FILE_INFO * pHashFile;
    LK_RETCODE lkrc;

    CHECK_FILE_STATE( pOpenFile );

    //
    // remove the file from the hashtable
    //
    lkrc = g_pFileInfoTable->DeleteRecord(pOpenFile);
    DBG_ASSERT( LK_SUCCESS == lkrc || LK_NO_SUCH_KEY == lkrc );


#if TSUNAMI_REF_DEBUG
    if (LK_SUCCESS == lkrc) {
        pOpenFile->TraceCheckpoint();
    }
#endif

    //
    // update state
    //
    pOpenFile->Lock();

    if (! pOpenFile->IsFlushed() ) {
        pOpenFile->SetFlushed();

        g_pFileCacheStats->IncFlushedEntries();
        g_pFileCacheStats->DecFilesCached();
    }


    if (dwFlags & FCF_FOR_IO) {
        I_DerefIO(pOpenFile);
    }

    bShouldClose = pOpenFile->IsCloseable();

    pOpenFile->Unlock();

    //
    // Clean up as neccessary
    // Note that I don't have to worry about the IO refcount
    // going back up because the file is marked as flushed.
    //
    if (bShouldClose) {
        pOpenFile->CloseHandle();
    }

    if (!(dwFlags & FCF_NO_DEREF)) {
        I_DerefFileInfo(pOpenFile);
    }
}


VOID
FlushFileCache(
    VOID
    )
/*++
Routine Description:

    Removes all entries from the cache. Unlike DecacheFile, this
    function does not check any entries in.

Arguments:

    None

Return Value:

    None
--*/
{
    FilteredFlushFileCache(FileFlushFilterAll, NULL);
}



LK_PREDICATE
FileFlushCachePredicate(
    TS_OPEN_FILE_INFO *pOpenFile,
    void* pvState
    )
{
    TS_FILE_FLUSH_STATE * pFlushState = static_cast<TS_FILE_FLUSH_STATE*>(pvState);
    LK_PREDICATE          lkpAction;

    if (pFlushState->pfnFilter(pOpenFile, pFlushState->pvParm)) {
        //
        // put it on the list
        //
        pOpenFile->AddRef(); // for the list

        InsertHeadList(&pFlushState->ListHead, &pOpenFile->FlushList);
        lkpAction = LKP_PERFORM;
    } else {
        lkpAction = LKP_NO_ACTION;
    }

    return lkpAction;
}


VOID
FilteredFlushFileCache(
    IN PFCFILTERRTN pFilterRoutine,
    IN PVOID        pv
    )
/*++
Routine Description:

    Removes entries based on a caller specified filter. The caller
    provides a boolean function which takes a cache entry as a
    parameter. The function will be called with each item in the cache.
    If the function returns TRUE, the item will be decached (but not
    checked in). Otherwise the item will remain in the cache.

Arguments:

    pFilterRoutine - A pointer to the filter function
    pv             - a parameter to the filter function

Return Value:

    None
--*/
{
    TS_FILE_FLUSH_STATE FlushState;

    g_pFileCacheStats->IncFlushes();

    //
    // Initialize the flush state
    //
    FlushState.pfnFilter = pFilterRoutine;
    InitializeListHead(&FlushState.ListHead);
    FlushState.pvParm = pv;

    //
    // Delete elements from table and construct list
    //
    g_pFileInfoTable->DeleteIf(FileFlushCachePredicate, &FlushState);

    //
    // Update element state and close file handles
    //
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNext;
    TS_OPEN_FILE_INFO * pOpenFile;
    BOOL                bShouldClose;

    for (pEntry = FlushState.ListHead.Flink;
         pEntry != &FlushState.ListHead;
         pEntry = pNext ) {

        pNext = pEntry->Flink;
        pOpenFile = CONTAINING_RECORD( pEntry, TS_OPEN_FILE_INFO, FlushList );
        DBG_ASSERT( pOpenFile->CheckSignature() );

        pOpenFile->Lock();

        if (! pOpenFile->IsFlushed() ) {
            pOpenFile->SetFlushed();

            g_pFileCacheStats->IncFlushedEntries();
            g_pFileCacheStats->DecFilesCached();
        }

        bShouldClose = pOpenFile->IsCloseable();

        pOpenFile->Unlock();

        if (bShouldClose) {
            pOpenFile->CloseHandle();
        }

        I_DerefFileInfo(pOpenFile);  // remove our list's reference
    }
}



BOOL
CheckoutFile(
    IN  LPCSTR               pstrPath,
    IN  DWORD                dwFlags,
    OUT TS_OPEN_FILE_INFO ** ppOpenFile
    )
/*++
Routine Description:

    Look up an entry in the cache and return it.

    The FCF_FOR_IO flag indicates that the caller will be performing
    I/O operations with the cached file handle. This flag will be clear
    in most cases except in TsCreateFile.

Arguments:

    pstrPath   - The pathname of the desired file info in UPPERCASE!!
    dwFlags    - The only valid flag is FCF_FOR_IO.
    ppOpenFile - On success this output points to the cached entry.
                 Otherwise it is not set.

Return Value:

    TRUE if the item was found, FALSE otherwise.
    Additional error information can be obtained from GetLastError()
--*/
{
    CFileKey fileKey;
    TS_OPEN_FILE_INFO * pOpenFile;
    BOOL bRetVal = FALSE;
    DWORD dwError;

    DBG_ASSERT( pstrPath != NULL );

    //
    // Look in the hash table
    //
    fileKey.m_pszFileName = const_cast<char *>(pstrPath);
    fileKey.m_cbFileName = strlen(pstrPath);

    g_pFileInfoTable->FindKey(&fileKey, &pOpenFile);

    if (NULL == pOpenFile) {
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    //
    // Make sure it's valid and update state
    //
    CHECK_FILE_STATE( pOpenFile );

    pOpenFile->Lock();

    DBG_ASSERT( pOpenFile->IsCached() );

    if (dwFlags & FCF_FOR_IO) {
        I_AddRefIO(pOpenFile);
    }

    pOpenFile->Unlock();


    //
    // Make sure it's initialized
    //
    if (!pOpenFile->IsInitialized()) {
        int t = 1;  // time to sleep
        int i = 0;  // number of times we've gone to sleep

        while (!pOpenFile->IsInitialized() && i < c_SleepTimeout) {
            Sleep(t);
            if (t < c_dwSleepmax) {
                t <<= 1;
            }

            i++;
        }
    }

    if (!pOpenFile->IsInitialized()) {
        //
        // OK we've waited long enough. Just return failure.
        //
        dwError = ERROR_BUSY;
        goto err;
    }

    if (pOpenFile->IsFlushed()) {
        dwError = ERROR_FILE_NOT_FOUND;
        goto err;
    }

    //
    // At last, sweet success!
    //
    bRetVal = TRUE;
    *ppOpenFile = pOpenFile;
exit:
    if (!bRetVal) {
        SetLastError(dwError);
    }
    
    if (dwFlags & FCF_FOR_IO) {
        if (bRetVal) {
            g_pFileCacheStats->IncHits();
        } else {
            g_pFileCacheStats->IncMisses();
        }
    }

    return bRetVal;

err:
    //
    // if we added to the IO refcount we have to decrement
    // that now.
    //
    if (dwFlags & FCF_FOR_IO) {
        pOpenFile->Lock();
        I_DerefIO(pOpenFile);
        pOpenFile->Unlock();
    }

    //
    // FindKey automatically increments the refcount so
    // we must deref here.
    //
    I_DerefFileInfo(pOpenFile);

    if (dwFlags & FCF_FOR_IO) {
        g_pFileCacheStats->IncMisses();
    }

    SetLastError(dwError);

    return FALSE;
}


BOOL
CheckoutFileEntry(
    IN  TS_OPEN_FILE_INFO * pOpenFile,
    IN  DWORD               dwFlags
    )
/*++
Routine Description:

    This function checks out an entry to which the caller already has
    a reference.

    The FCF_FOR_IO flag indicates that the caller will be performing
    I/O operations with the cached file handle.

Arguments:

    pOpenFile - The file info structure to be checked out.
    dwFlags   - The only valid flag is FCF_FOR_IO.

Return Value:

    TRUE  - File was successfully checked out
    FALSE - File was checked out, but should not be used by the
            caller. (it's been flushed)
--*/
{
    BOOL bSuccess;

    CHECK_FILE_STATE( pOpenFile );

    pOpenFile->AddRef();

    pOpenFile->Lock();

    if (dwFlags & FCF_FOR_IO) {
        I_AddRefIO(pOpenFile);
    }

    if (pOpenFile->IsFlushed() == FALSE) {
        bSuccess = TRUE;
    } else {
        bSuccess = FALSE;
    }

    if (dwFlags & FCF_FOR_IO) {
        if (bSuccess) {
            g_pFileCacheStats->IncHits();
        } else {
            g_pFileCacheStats->IncMisses();
        }
    }

    pOpenFile->Unlock();

    return bSuccess;
}


VOID
CheckinFile(
    IN TS_OPEN_FILE_INFO * pOpenFile,
    IN DWORD               dwFlags
    )
/*++
Routine Description:

    Indicate that a previously checked out file info is no longer in use.

    The FCF_FOR_IO flag indicates that the caller was be performing I/O
    operations with the cached file handle. This flag will be clear in
    most cases except in TsCloseHandle.

Arguments:

    pOpenFile - The file info structure to be checked in.
    dwFlags   - The only valid flag is FCF_FOR_IO.

Return Value:

    None.
--*/
{
    BOOL bShouldClose;

    CHECK_FILE_STATE( pOpenFile );

    //
    // update state
    //
    pOpenFile->Lock();

    if (dwFlags & FCF_FOR_IO) {
        I_DerefIO(pOpenFile);
    }

    bShouldClose = pOpenFile->IsCloseable();

    pOpenFile->Unlock();

    //
    // Clean up as necessary
    //
    if (bShouldClose) {
        pOpenFile->CloseHandle();
    }

    I_DerefFileInfo(pOpenFile);
}


inline VOID
I_DerefFileInfo(
    TS_OPEN_FILE_INFO *pOpenFile
    )
/*++

--*/
{
    LONG lRefCount;

    DBG_ASSERT( pOpenFile != NULL );
    DBG_ASSERT( pOpenFile->CheckSignature() );

    lRefCount = pOpenFile->Deref();

    DBG_ASSERT( lRefCount >= 0 );

    if (lRefCount == 0) {
        DBG_ASSERT(pOpenFile->IsFlushed());
        delete pOpenFile;

        g_pFileCacheStats->DecFlushedEntries();
    }
}


VOID
I_AddRefIO(
    TS_OPEN_FILE_INFO * pOpenFile
    )
/*++
Routine Description:

    Calls pOpenFile->AddRefIO. 

    This should be called with the fileinfo lock held.

Arguments:

    pOpenFile - the file to addref

Return Value:

    None.
--*/
{
    pOpenFile->AddRefIO();
}


VOID
I_DerefIO(
    TS_OPEN_FILE_INFO * pOpenFile
    )
/*++
Routine Description:

    Calls pOpenFile->DerefIO. 

    This should be called with the fileinfo lock held.

Arguments:

    pOpenFile - the file to deref

Return Value:

    None.
--*/
{
    pOpenFile->DerefIO();
}


VOID
TS_OPEN_FILE_INFO::Print(
    VOID
    ) const
{
    //
    // Doesn't do anything.  Ha!
    //
}





BOOL
CFileCacheStats::DumpToHtml(
    CHAR * pchBuffer,
    LPDWORD lpcbBuffer) const
{
    *lpcbBuffer = wsprintf(pchBuffer,
        "<table>"
        "<tr><td>Currently Cached Files</td><td align=right>%d</td></tr>"
        "<tr><td>Total # of files added</td><td align=right>%d</td></tr>"
        "<tr><td>Cache Hits</td><td align=right>%d</td></tr>"
        "<tr><td>Cache Misses</td><td align=right>%d</td></tr>"
        "<tr><td>Cache Flushes</td><td align=right>%d</td></tr>"
        "<tr><td>Oplock Breaks</td><td align=right>%d</td></tr>"
        "<tr><td>Oplock Breaks To None</td><td align=right>%d</td></tr>"
        "<tr><td>Flushed entries in cache</td><td align=right>%d</td></tr>"
        "<tr><td>Total # files flushed</td><td align=right>%d</td></tr>"
        "</table>",
        FilesCached,
        TotalFilesCached,
        Hits,
        Misses,
        Flushes,
        OplockBreaks,
        OplockBreaksToNone,
        FlushedEntries,
        TotalFlushed );

    return TRUE;
}

BOOL
CFileCacheStats::QueryStats(
    INETA_CACHE_STATISTICS * pCacheCtrs
    ) const
{
    return FALSE;
}


BOOL
FileFlushFilterAll(
    TS_OPEN_FILE_INFO *pOpenFile,
    PVOID              pv
    )
{
    return TRUE;
}

#if DBG
BOOL
CheckFileState(
    TS_OPEN_FILE_INFO *pOpenFile
    )
{
    DBG_ASSERT( pOpenFile );
    DBG_ASSERT( pOpenFile->CheckSignature() );
    DBG_ASSERT( pOpenFile->IsCached() );
    DBG_ASSERT( g_pFileInfoTable );

    TS_OPEN_FILE_INFO * pHashFile;
    BOOL                bOK;

    //
    // I was going to do some interesting checks here
    // but the synchronization is just too hard
    //
    bOK = TRUE;

    return bOK;
}
#endif // DBG

//
// filecach.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\fileopen.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    fileopen.cxx

    This module contains the functions for creating and closing
    cached file information.


    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>
#include "filecach.hxx"
#include "filehash.hxx"
#include "tsunamip.hxx"
#include "tlcach.h"
#include <mbstring.h>

#include <atq.h>

#include "dbgutil.h"


extern CFileCacheStats * g_pFileCacheStats;
extern BOOL DisableTsunamiCaching;

//
// globals
//
DWORD         g_dwFileCacheByteThreshold;
DWORDLONG     g_dwMemCacheSize;
BOOL          g_bEnableSequentialRead;

//
// Private functions
//
LPTS_OPEN_FILE_INFO TspOpenFile( LPCSTR pszName, HANDLE hUser, DWORD dwOptions );
LPTS_OPEN_FILE_INFO TspOpenCachedFile( LPCSTR pszName, HANDLE hUser, DWORD dwOptions );
BOOL TspOpenCachedFileHelper( LPCSTR pszName, HANDLE hUser, TS_OPEN_FILE_INFO * pOpenFile, DWORD dwOptions );
DWORD TspMakeWidePath( LPCSTR pszName, DWORD cchWideName, BOOL bNoParse, LPWSTR pwszWideName );

//
// flags to set on CreateFile
//

DWORD TsCreateFileShareMode = (FILE_SHARE_READ   |
                                FILE_SHARE_WRITE |
                                FILE_SHARE_DELETE);

DWORD TsCreateFileFlags = (FILE_FLAG_OVERLAPPED       |
                           FILE_FLAG_BACKUP_SEMANTICS |
                           FILE_DIRECTORY_FILE );

const SECURITY_INFORMATION TsSecurityInfo
        = OWNER_SECURITY_INFORMATION
        | GROUP_SECURITY_INFORMATION
        | DACL_SECURITY_INFORMATION;


//
// macros
//
#define LockUriInfo()      ( EnterCriticalSection( &g_csUriInfo ) )
#define UnlockUriInfo()    ( LeaveCriticalSection( &g_csUriInfo ) )


LPTS_OPEN_FILE_INFO
TsCreateFile(
    IN const TSVC_CACHE     &TSvcCache,
    IN      LPCSTR          pszName,
    IN      HANDLE          OpeningUser,
    IN      DWORD           dwOptions
    )
/*++
Routine Description:

    Opens a TS_OPEN_FILE_INFO. When the requested file is no longer
    needed, the client should close it with TsCloseHandle.

Arguments:

    TSvcCache   - An initialized TSVC_CACHE structure. (Ignored)
    lpszName    - The name of the file
    OpeningUser - HANDLE for the user attempting the open
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON
        TS_FORBID_SHORT_NAMES

Return Values:

    On success TsCreateFile returns a pointer to a TS_OPEN_FILE_INFO
    for the requested file. NULL is returned on failure.  More error
    information can be obtained from GetLastError();

--*/
{
    TS_OPEN_FILE_INFO * pOpenFile = NULL;
    CHAR achUpName[MAX_PATH+1];
    BOOL bCacheToken = !(dwOptions & TS_DONT_CACHE_ACCESS_TOKEN);

    if (DisableTsunamiCaching) {
        dwOptions &= ~TS_CACHING_DESIRED;
    }

//
// This assert doesn't work on workstation, but it would
// be nice.
//
//    DBG_ASSERT( (~TsValidCreateFileOptions & dwOptions) == 0 );
//
    dwOptions &= TsValidCreateFileOptions;

    //
    // Make sure the path is upper case
    //
    IISstrncpy(achUpName, pszName, MAX_PATH);
    achUpName[MAX_PATH] = 0;

    _mbsupr(reinterpret_cast<PUCHAR>(achUpName));

    //
    //  Disallow short file names as they break metabase equivalency
    //  We do the expensive check anytime there's a tilde - number
    //  sequence.  If we find somebody used a short name we return file not found.
    //  Note we revert if not on UNC since most systems have traverse checking
    //  turned off.
    //

    if ( (dwOptions & TS_FORBID_SHORT_NAMES) &&
          strchr( pszName, '~' ))
    {
        DWORD  err;
        BOOL   fShort;

        //
        //  CheckIfShortFileName() should be called unimpersonated
        //
        err = CheckIfShortFileName( (UCHAR *) pszName, OpeningUser, &fShort );

        if ( !err && fShort )
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "Short filename being rejected \"%s\"\n",
                        pszName ));

            err = ERROR_FILE_NOT_FOUND;
        }

        if ( err )
        {
            SetLastError( err );
            return NULL;
        }
    }

    //
    // Try to get the file
    //
    if ( dwOptions & TS_CACHING_DESIRED ) {
        //
        // Look in the cache first
        //
        if ( CheckoutFile(achUpName, FCF_FOR_IO, &pOpenFile) ) {
            //
            // Make sure we can really use this handle
            //
            if ( ( !(dwOptions & TS_NO_ACCESS_CHECK) ) &&
                 ( !pOpenFile->AccessCheck(OpeningUser, bCacheToken) ) ) {

                CheckinFile(pOpenFile, FCF_FOR_IO);

                //
                // Return Access Denied
                //
                pOpenFile = NULL;
                SetLastError(ERROR_ACCESS_DENIED);
            }
        } else if ( GetLastError() == ERROR_FILE_NOT_FOUND ) {
            //
            // The file was not in the cache.  Try to put it in.
            //
            pOpenFile = TspOpenCachedFile(achUpName, OpeningUser, dwOptions);
        }
    } else {
        //
        // We're not using the cache.  Just open the file.
        //
        pOpenFile = TspOpenFile(achUpName, OpeningUser, dwOptions);
    }

    return pOpenFile;
}



LPTS_OPEN_FILE_INFO
TsCreateFileFromURI(
    IN const TSVC_CACHE     &TSvcCache,
    IN      PW3_URI_INFO    pURIInfo,
    IN      HANDLE          OpeningUser,
    IN      DWORD           dwOptions,
    IN      DWORD           *dwError
    )
/*++
Routine Description:

    Opens the TS_OPEN_FILE_INFO associated with the W3_URI_INFO argument. When
    the client is done with the file it should be closed with TsCloseURIFile.

    As a side effect, this routine will set the pOpenFileInfo, and
    dwFileOpenError in the pURIInfo structure.

Arguments:

    TSvcCache   - An initialized TSVC_CACHE structure.
    pURIInfo    - Pointer to the W3_URI_INFO whose associated file should be opened
    OpeningUser - HANDLE for the user attempting the open
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON
        TS_FORBID_SHORT_NAMES
    dwError     - On failure this DWORD will contain an error code

Return Values:

    On success a pointer to the TS_OPEN_FILE_INFO is returned. On failure
    TsCreateFileFromURI returns NULL, and dwError is set to an error code.
--*/
{
    TS_OPEN_FILE_INFO * pOpenFile = NULL;
    DWORD               err;
    BOOL                bCacheToken = !(dwOptions & TS_DONT_CACHE_ACCESS_TOKEN);
    BOOL                bInfoValid;

//
// This assert doesn't work on workstation, but it would
// be nice.
//
//    DBG_ASSERT( (~TsValidCreateFileOptions & dwOptions) == 0 );
//
    dwOptions &= TsValidCreateFileOptions;

    if (DisableTsunamiCaching) {
        pOpenFile = TsCreateFile(TSvcCache,
                                 pURIInfo->pszName,
                                 OpeningUser,
                                 dwOptions);

        *dwError = GetLastError();

        return pOpenFile;
    }

    //
    // It seems that callers expect caching, but don't request it
    //
    dwOptions |= TS_CACHING_DESIRED;

    //
    // Assume no error
    //
    err = ERROR_SUCCESS;

    //
    // Try to get the file
    //
    bInfoValid = FALSE;

    LockUriInfo();

    pOpenFile = pURIInfo->pOpenFileInfo;
    if ( pOpenFile && CheckoutFileEntry(pOpenFile, FCF_FOR_IO) ) {
        bInfoValid = TRUE;
    }

    UnlockUriInfo();

    if ( bInfoValid ) {
        //
        // We've got a cached handle; make sure we're allowed to see it
        //
        if ( !pOpenFile->AccessCheck(OpeningUser, bCacheToken) ) {

            CheckinFile(pOpenFile, FCF_FOR_IO);

            //
            // Return Access Denied
            //
            pOpenFile = NULL;
            err = ERROR_ACCESS_DENIED;
        }
    } else {
        //
        // We've got either an invalid handle or no cached handle
        // at all.
        //
        if (pOpenFile) {
            //
            // The cached file handle is invalid
            //
            TS_OPEN_FILE_INFO * pOldFile;

            LockUriInfo();

            pOldFile = pURIInfo->pOpenFileInfo;
            pURIInfo->pOpenFileInfo = NULL;

            UnlockUriInfo();

            //
            // We've got an invalid entry checked out.
            // It's been checked out twice, once for I/O (above)
            // and once when it was first cached.
            //
            CheckinFile(pOpenFile, FCF_FOR_IO);

            //
            // Now we handle the reference that was cached in the
            // URI info structure.  If someone else already removed
            // the reference, then pOldFile will be NULL, or a new
            // value.
            //

            if (pOldFile == pOpenFile) {
                //
                // We've got the reference all to ourselves so
                // we can delete it.
                //
                CheckinFile(pOpenFile, 0);
            } else if (pOldFile) {
                //
                // Someone else took care of the reference,
                // and cached a new one. It would be nice
                // if we could use it, but the file might have
                // already been flushed. If we go back to the
                // top, there's a chance that we'll loop forever.
                // Instead, we'll just get rid of this new
                // reference and pretend it was never there.
                //
                CheckinFile(pOldFile, 0);
            }
        }

        //
        // No file is cached.  Try to open it.
        //
        pOpenFile = TsCreateFile(TSvcCache,
                                 pURIInfo->pszName,
                                 OpeningUser,
                                 dwOptions);

        //
        // Save the result.
        //
        if ( pOpenFile ) {
            if (dwOptions & TS_CACHING_DESIRED) {
                //
                // To save a copy of the info we need to reference it
                //
                if ( CheckoutFileEntry(pOpenFile, 0) ) {
                    TS_OPEN_FILE_INFO * pOldFile;

                    LockUriInfo();

                    pOldFile                = pURIInfo->pOpenFileInfo;
                    pURIInfo->pOpenFileInfo = pOpenFile;

                    UnlockUriInfo();

                    //
                    // Someone else might have written a value
                    // into the URI info before we got to it, but
                    // we'll show them.  Our value stays while
                    // theirs gets put back.
                    //
                    if (pOldFile) {
                        CheckinFile(pOldFile, 0);
                    }
                } else {
                    //
                    // It's been flushed, so we don't want to save it.
                    //
                    CheckinFile(pOpenFile, 0);
                }
            }
        } else {
            //
            // We couldn't open a file, so just record the error.
            //
            err = GetLastError();
        }
    }

    if ( err != ERROR_SUCCESS ) {
        *dwError = err;
        SetLastError(err);
    }
    return pOpenFile;
}



BOOL
TsCloseHandle(
    IN const TSVC_CACHE           &TSvcCache,
    IN       LPTS_OPEN_FILE_INFO  pOpenFile
    )
/*++
Routine Description:

    Closes a TS_OPEN_FILE_INFO opened with TsCreateFile.

Arguments:

    TSvcCache - An initialized TSVC_CACHE structure.
    pOpenFile - Pointer to the TS_OPEN_FILE_INFO to be closed

Return Values:

    TRUE on success
--*/
{
    if ( pOpenFile->IsCached() ) {
        CheckinFile(pOpenFile, FCF_FOR_IO);
    } else {
        //
        // This is an uncached file.  We can just get rid of it.
        //
        pOpenFile->CloseHandle();
        delete pOpenFile;
    }

    return TRUE;
}


BOOL
TsCloseURIFile(
    IN       LPTS_OPEN_FILE_INFO  pOpenFile
    )
/*++
Routine Description:

    Closes a TS_OPEN_FILE_INFO opened with TsCreateFileFromURI.

Arguments:

    pOpenFile - Pointer to the TS_OPEN_FILE_INFO to be closed

Return Values:

    TRUE on success
--*/
{
    if ( pOpenFile ) {
        if ( pOpenFile->IsCached() ) {
            CheckinFile(pOpenFile, FCF_FOR_IO);
        } else {
            //
            // This is an uncached file.  We can just get rid of it.
            //
            pOpenFile->CloseHandle();
            delete pOpenFile;
        }
    }
    return TRUE;
}




BOOL
TsDerefURIFile(
    IN       LPTS_OPEN_FILE_INFO  pOpenFile
    )
/*++
Routine Description:

    When a W3_URI_INFO gets cleaned up, it needs to get rid
    of it's reference to the file info by calling TsDerefURIFile.

Arguments:

    pOpenFile - Pointer to the TS_OPEN_FILE_INFO to be derefed.

Return Values:

    TRUE on success
--*/
{
    CheckinFile(pOpenFile, 0);

    return TRUE;
}


DWORD
TsMakeWidePath(
    LPCSTR pszName,
    LPWSTR pwszName,
    DWORD  dwWLen)
/*++
Routine Description:

    Wrapper to expose an internal utily routine: TspMakeWidePath

Arguments:

    pszName - Input ANSI file path
    pwszName- output UNICODE name
    dwWLen  - length of output buffer (in unicode chars)

Return Values:

    0 on error, length on success (excluding NIL)
--*/
{
    DWORD cch;

    if (!pszName || !*pszName || !pwszName || dwWLen <= 1) {

        SetLastError( ERROR_INVALID_PARAMETER);
        return 0;
    }

    cch = TspMakeWidePath(pszName, dwWLen - 1, TRUE, pwszName);

    if (cch > 0) {

        pwszName[cch] = L'\0';
    }

    return cch;
}



LPTS_OPEN_FILE_INFO
TspOpenFile(
    LPCSTR pszName,
    HANDLE hUser,
    DWORD  dwOptions
    )
/*++
Routine Description:

    Opens a non-cached TS_OPEN_FILE_INFO for TsCreateFile.

Arguments:

    pszName - The name of the file
    hUser   - HANDLE for the user attempting the open
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN (Ignored for non-cached case)
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON

Return Values:

    On success returns a pointer to a TS_OPEN_FILE_INFO
    for the requested file. NULL is returned on failure.
    More error information can be gotten
    from GetLastError(), which will return one of:

        ERROR_INSUFFICIENT_BUFFER
        ERROR_INVALID_NAME
        ERROR_ACCESS_DENIED
        ERROR_FILE_NOT_FOUND
        ERROR_PATH_NOT_FOUND
        ERROR_NOT_ENOUGH_MEMORY
--*/
{
    TS_OPEN_FILE_INFO * pOpenFile;
    HANDLE              hFile;
    WCHAR               awchPath[MAX_PATH+8+1];
    DWORD               cchPath;
    SECURITY_ATTRIBUTES sa;
    BOOL                bImpersonated;
    BOOL                bNoParse;
    DWORD               dwError = NO_ERROR;
    PSECURITY_DESCRIPTOR  pSecDesc;
    DWORD                 dwSecDescSize;
    DWORD                 dwSecDescSizeReq;
    BOOL                  fSecDescAllocated;

    bImpersonated = FALSE;

    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = FALSE;

    //
    // Allocate a file info object
    //
    pOpenFile = new TS_OPEN_FILE_INFO();
    if (!pOpenFile || !pOpenFile->SetFileName(pszName)) {
        //
        // couldn't allocate an object
        //
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto err;
    }

    //
    // Convert path to unicode
    //
    bNoParse = ! ( dwOptions & TS_USE_WIN32_CANON );
    cchPath = TspMakeWidePath(pszName, MAX_PATH+8, bNoParse, awchPath);
    if (!cchPath) {
        //
        // Path couldn't be converted
        //
        dwError = GetLastError();
        goto err;
    }

    // avoid the infamous ::$DATA bug

    if ( wcsstr( awchPath, L"::" ) )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto err;
    }

    //
    // We may need to impersonate some other user to open the file
    //
    if ( (dwOptions & TS_NOT_IMPERSONATED) &&
         !(dwOptions & TS_NO_ACCESS_CHECK) )
    {
        if ( !::ImpersonateLoggedOnUser( hUser ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "ImpersonateLoggedOnUser[%d] failed with %d\n",
                hUser, GetLastError()));
            //
            // Return access denied
            //
            dwError = ERROR_ACCESS_DENIED;

            goto err;
        }
        bImpersonated = TRUE;
    }

    DWORD dwFileAttributes;
    if ((awchPath[cchPath-1] == L'.' || awchPath[cchPath-1] == L'\\') &&
        ((DWORD(-1) != (dwFileAttributes = GetFileAttributesW(awchPath))) &&
        (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))) {
        SetLastError(ERROR_FILE_NOT_FOUND);
        hFile = INVALID_HANDLE_VALUE;
    } else {

        //
        // Open the file
        //
        hFile = CreateFileW(
            awchPath,
            GENERIC_READ,
            TsCreateFileShareMode,
            &sa,
            OPEN_EXISTING,
            TsCreateFileFlags,
            NULL);
    }

    if ( hFile == INVALID_HANDLE_VALUE ) {
        dwError = GetLastError();
        goto err;
    }

    //
    // If our buffer wasn't big enough we have to get a new one.
    //
    pSecDesc = pOpenFile->QuerySecDesc();
    dwSecDescSize = SECURITY_DESC_DEFAULT_SIZE;
    fSecDescAllocated = FALSE;
    while(1) {
        //
        // get the security descriptor
        //
        if (GetKernelObjectSecurity(hFile,
                                OWNER_SECURITY_INFORMATION
                                | GROUP_SECURITY_INFORMATION
                                | DACL_SECURITY_INFORMATION,
                                pSecDesc,
                                dwSecDescSize,
                                &dwSecDescSizeReq)) {
            break;
        }
        else {
            if (fSecDescAllocated)
            {
                FREE(pSecDesc);
            }
            pSecDesc = NULL;

            if (ERROR_INSUFFICIENT_BUFFER != GetLastError()) {
                //
                // We got some error other than not enough buffer.
                // Fail the whole request.
                //
                dwError = GetLastError();
                ::CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
                goto err;
            }
        }

        dwSecDescSize = ((dwSecDescSizeReq + SECURITY_DESC_GRANULARITY - 1)
            / SECURITY_DESC_GRANULARITY) * SECURITY_DESC_GRANULARITY;

        pSecDesc = ALLOC(dwSecDescSize);
        if (!pSecDesc) {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            ::CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
            goto err;
        }

        fSecDescAllocated = TRUE;
    }

    //
    // Fetch file information
    //
    BY_HANDLE_FILE_INFORMATION FileInfo;

    if (!GetFileInformationByHandle( hFile, &FileInfo)) {
        dwError = GetLastError();
        ::CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        goto err;
    }

    //
    // Store the file information
    //
    pOpenFile->SetFileInfo(
        hFile,
        hUser,
        pSecDesc,
        dwSecDescSize,
        &FileInfo
        );

    if ( bImpersonated ) {
        ::RevertToSelf();
    }

    pOpenFile->TraceCheckpointEx(TS_MAGIC_CREATE_NC, 0, 0);

    return pOpenFile;

err:
    if ( bImpersonated ) {
        ::RevertToSelf();
    }

    if (pOpenFile) {
        delete pOpenFile;
    }

    SetLastError(dwError);

    return NULL;
}


LPTS_OPEN_FILE_INFO
TspOpenCachedFile(
    LPCSTR pszName,
    HANDLE hUser,
    DWORD  dwOptions
    )
/*++
Routine Description:

    Helper function for TsCreateFile

    Opens a TS_OPEN_FILE_INFO and puts it in the file cache.
    We want to make sure that each file only gets opened once,
    so first we put an uninitialized file entry in the cache.
    If the open succeeds, we tell the cache that the file is
    ready for use.  Otherwise we decache it.

Arguments:

    pszName     - The name of the file
    OpeningUser - HANDLE for the user attempting the open
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON

Return Values:

    On success returns a pointer to a TS_OPEN_FILE_INFO
    for the requested file. NULL is returned on failure.
    More error information can be gotten
    from GetLastError(), which will return one of:

        ERROR_INSUFFICIENT_BUFFER
        ERROR_INVALID_NAME
        ERROR_ACCESS_DENIED
        ERROR_FILE_NOT_FOUND
        ERROR_PATH_NOT_FOUND
        ERROR_NOT_ENOUGH_MEMORY
--*/
{
    TS_OPEN_FILE_INFO *pOpenFile;
    DWORD dwResult;
    DWORD dwError = NO_ERROR;

    DBG_ASSERT( !DisableTsunamiCaching );

    //
    // Allocate a file info object
    //
    pOpenFile = new TS_OPEN_FILE_INFO();
    if (!pOpenFile || !pOpenFile->SetFileName(pszName)) {
        //
        // couldn't allocate an object
        //
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto err;
    }

Retry:

    //
    // Add a cache entry to prevent others from opening the file simultaneously
    //
    dwResult = CacheFile(pOpenFile, FCF_UNINITIALIZED | FCF_FOR_IO);

    if ( dwResult == TS_ERROR_OUT_OF_MEMORY ) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto err;
    }


    if (dwResult == TS_ERROR_SUCCESS) {
        //
        // Open the file
        //
        if ( TspOpenCachedFileHelper(pszName, hUser, pOpenFile, dwOptions) ) {
            //
            // Tell the cache it worked
            //
            NotifyInitializedFile(pOpenFile);
        } else {
            //
            // need to remove the entry in the cache
            // since it's not valid.
            //
            // First we need an extra reference which we'll use to tell
            // the cache that the file is initialized. Then we'll
            // decache the file, and finally mark it initialized.
            //
            // The file can't be marked initialized before the decache,
            // because then it might look like a successful open.
            // We need the extra reference because calling decache
            // gets rid of our original reference.
            //
            pOpenFile->TraceCheckpointEx(TS_MAGIC_OPLOCK_FAIL, 0, 0);

            CheckoutFileEntry(pOpenFile, 0);

            DecacheFile(pOpenFile, FCF_FOR_IO);

            NotifyInitializedFile(pOpenFile);
            CheckinFile(pOpenFile, 0);

            pOpenFile = NULL;

            dwError = GetLastError();
            goto err;
        }
    } else {
        TS_OPEN_FILE_INFO *             pExisting = NULL;

        DBG_ASSERT ( dwResult == TS_ERROR_ALREADY_CACHED );

        //
        // Someone beat us to it.  Try to check it out.
        //
        if ( !CheckoutFile(pszName, FCF_FOR_IO, &pExisting) ) {
            //
            // It's been removed from the cache since our
            // attempt to add it.  Try again
            //

            goto Retry;
        }

        delete pOpenFile;
        pOpenFile = pExisting;

    }


    return pOpenFile;

err:
    if (pOpenFile) {
        delete pOpenFile;
    }

    SetLastError(dwError);
    return NULL;
}


BOOL
TspOpenCachedFileHelper(
    LPCSTR              pszName,
    HANDLE              hUser,
    TS_OPEN_FILE_INFO * pOpenFile,
    DWORD               dwOptions
    )
/*++
Routine Description:

    This function actually attempts to open the file with AtqCreateFileW.

    When we enable oplocks, ATQ will need a reference to the object.
    Therefore AtqCreateFileW must somehow be modified to tell me whether
    it has a reference or not.  If ATQ has a reference, we tell the cache
    so here.

Arguments:

    pszName     - The name of the file
    OpeningUser - HANDLE for the user attempting the open
    pOpenFile   - the file info object to update on success
    dwOptions   - Valid options are:
        TS_CACHING_DESIRED          (should always be set here)
        TS_NO_ACCESS_CHECK
        TS_DONT_CACHE_ACCESS_TOKEN
        TS_NOT_IMPERSONATED
        TS_USE_WIN32_CANON

Return Values:

    TRUE if the file was opened, and file information was set.
    FALSE otherwise.  More error information can be gotten
    from GetLastError(), which will return one of:

        ERROR_INSUFFICIENT_BUFFER
        ERROR_INVALID_NAME
        ERROR_ACCESS_DENIED
        ERROR_FILE_NOT_FOUND
        ERROR_PATH_NOT_FOUND
--*/
{
    HANDLE hFile;
    WCHAR  awchPath[MAX_PATH+8+1];
    DWORD  cchPath;
    DWORD  dwError = NO_ERROR;
    BOOL   bSuccess;
    BOOL   bDirectory;
    BOOL   bSmallFile;
    BOOL   bImpersonated = FALSE;
    BOOL   bNoParse;
    SECURITY_ATTRIBUTES   sa;
    PSECURITY_DESCRIPTOR  pSecDesc;
    DWORD                 dwSecDescSize;
    DWORD                 dwSecDescSizeReq;
    DWORD                 cbFileSize = 0;
    DWORD                 cbBytesRequired;
    PBYTE                 pBuffer = NULL;
    HANDLE                hCopyFile = INVALID_HANDLE_VALUE;
    BY_HANDLE_FILE_INFORMATION FileInfo;

    DBG_ASSERT(dwOptions & TS_CACHING_DESIRED);

    bSuccess = FALSE;
    dwSecDescSizeReq = 0;

    //
    // Assume it's not cacheable
    //
    bSmallFile = FALSE;
    bDirectory = FALSE;

    //
    // set up security info
    //
    sa.nLength              = sizeof(sa);
    sa.lpSecurityDescriptor = NULL;
    sa.bInheritHandle       = FALSE;

    //
    // The open file info contains a buffer
    // of the default size.
    //
    pSecDesc = pOpenFile->QuerySecDesc();

    dwSecDescSize = SECURITY_DESC_DEFAULT_SIZE;

    //
    // Convert path to unicode
    //
    bNoParse = ! ( dwOptions & TS_USE_WIN32_CANON );
    cchPath = TspMakeWidePath(pszName, MAX_PATH+8, bNoParse, awchPath);

    if (!cchPath) {
        //
        // Path couldn't be converted
        //
        pSecDesc = NULL;                // Don't free the default buffer.
        dwError = GetLastError();
        goto err;
    }

    // avoid the infamous ::$DATA bug

    if ( wcsstr( awchPath, L"::" ) )
    {
        pSecDesc = NULL;
        dwError = ERROR_FILE_NOT_FOUND;
        goto err;
    }

    //
    // We may need to impersonate some other user to open the file
    //
    if ( (dwOptions & TS_NOT_IMPERSONATED) &&
         !(dwOptions & TS_NO_ACCESS_CHECK) )
    {
        if ( !::ImpersonateLoggedOnUser( hUser ) )
        {
            DBGPRINTF(( DBG_CONTEXT,
                "ImpersonateLoggedOnUser[%d] failed with %d\n",
                hUser, GetLastError()));
            //
            // Return access denied
            //

            pSecDesc = NULL;
            dwError = ERROR_ACCESS_DENIED;
            goto err;
        }
        bImpersonated = TRUE;
    }


    //
    // Open the file
    //

    hFile = CreateFileW(
        awchPath,                   // file name
        GENERIC_READ,               // access mode
        TsCreateFileShareMode,      // share mode
        &sa,                        // SD
        OPEN_EXISTING,              // how to create
        TsCreateFileFlags,          // file attributes
        NULL);                      // handle to template file

    if ( hFile == INVALID_HANDLE_VALUE ) {
        pSecDesc = NULL;                // Don't free the default buffer.
        dwError = GetLastError();
        goto err;
    }

    //
    // Get the security descriptor
    // if the buffer is not big enough, code below will retry
    // with a bigger buffer.
    //

    if (!GetKernelObjectSecurity(hFile,
                             OWNER_SECURITY_INFORMATION
                             | GROUP_SECURITY_INFORMATION
                             | DACL_SECURITY_INFORMATION,
                             pSecDesc,
                             dwSecDescSize,
                             &dwSecDescSizeReq)
        && (ERROR_INSUFFICIENT_BUFFER != GetLastError()) ) {
        //
        // We got some error other than not enough buffer.
        // Fail the whole request.
        //
        pSecDesc = NULL;
        dwError = GetLastError();
        ::CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        goto err;
    }

    //
    // Fetch file information
    //

    if (!GetFileInformationByHandle( hFile, &FileInfo)) {
        pSecDesc = NULL;
        dwError = GetLastError();
        ::CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
        goto err;
    }

    bDirectory = FileInfo.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? TRUE : FALSE;


    // if the name ends with ('\' or '.')
    // and it is NOT a directory, than fail 404

    if ((awchPath[cchPath-1] == L'.' || awchPath[cchPath-1] == L'\\')  && // suspect file name
        !bDirectory) {
         pSecDesc = NULL;
         dwError = ERROR_FILE_NOT_FOUND;
         ::CloseHandle(hFile);
         hFile = INVALID_HANDLE_VALUE;
         goto err;
    }

    //
    // do not cache encrypted files
    //

    BOOL bEncrypted = FileInfo.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ? TRUE : FALSE;

    //
    // If our buffer wasn't big enough we have to get a new one.
    //
    if (dwSecDescSizeReq > dwSecDescSize) {
        //
        // Code below shouldn't try to free our original buffer
        //
        pSecDesc = NULL;

        //
        // Keep getting the security descriptor until we have enough space.
        //

        while (dwSecDescSizeReq > dwSecDescSize) {
            DBGPRINTF(( DBG_CONTEXT,
                        "Allocating a new Security Descriptor buffer! %d > %d\n",
                        dwSecDescSizeReq,
                        dwSecDescSize ));

            dwSecDescSize = ((dwSecDescSizeReq + SECURITY_DESC_GRANULARITY - 1)
                / SECURITY_DESC_GRANULARITY) * SECURITY_DESC_GRANULARITY;

            if (pSecDesc) {
                FREE(pSecDesc);
            }

            pSecDesc = ALLOC(dwSecDescSize);
            if (!pSecDesc) {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto err;
            }

            //
            // get a new security descriptor
            //
            if (!GetKernelObjectSecurity(hFile,
                                     OWNER_SECURITY_INFORMATION
                                     | GROUP_SECURITY_INFORMATION
                                     | DACL_SECURITY_INFORMATION,
                                     pSecDesc,
                                     dwSecDescSize,
                                     &dwSecDescSizeReq)
                && (ERROR_INSUFFICIENT_BUFFER != GetLastError()) ) {
                //
                // We got some error other than not enough buffer.
                // Fail the whole request.
                //
                dwError = GetLastError();
                ::CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;
                goto err;
            }
        }
    }

    //
    // Don't need to be impersonated anymore
    //
    if ( bImpersonated ) {
        ::RevertToSelf();
        bImpersonated = FALSE;
    }

    //
    // We don't need to hold the handle open for directories.
    //
    if (bDirectory) {
        ::CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    //
    // If we're using a non cached token we don't want to save it
    //
    if (dwOptions & TS_DONT_CACHE_ACCESS_TOKEN) {
        hUser = INVALID_HANDLE_VALUE;
    }

    //
    // try to read the file into the memory cache
    //

    if ((FileInfo.nFileSizeHigh == 0) &&
        (FileInfo.nFileSizeLow < g_dwFileCacheByteThreshold)
        && (hFile != INVALID_HANDLE_VALUE)) {

        bSmallFile = TRUE;
        cbFileSize = FileInfo.nFileSizeLow;

    } else {
        bSmallFile = FALSE;
    }

    if (bSmallFile && !bEncrypted) {
        dwError = ReadFileIntoMemoryCache(
                      hFile,
                      cbFileSize,
                      &cbBytesRequired,
                      (PVOID *) &pBuffer
                      );

        if (dwError == ERROR_SUCCESS) {
            //
            // it worked. dump the file handle
            //
            ::CloseHandle(hFile);
            hFile = INVALID_HANDLE_VALUE;
        } else {
            //
            // we failed to make it into
            // the cache, so don't cache
            // this entry
            //
            bSmallFile = FALSE;
        }
    }


    //
    // Add file information to pOpenFile
    //
    pOpenFile->SetFileInfo(
        hFile,                   // handle to the file
        hUser,                   // user token, if we're supposed to cache it
        pSecDesc,                // security descriptor
        dwSecDescSize,           // size of security descriptor
        &FileInfo,               // file information
        pBuffer                  // buffer contains contents of file
        );
    bSuccess = TRUE;


    if (bEncrypted || (!bDirectory && !bSmallFile)) {
        //
        // This is a regular file that is too large
        // for the cache, so don't cache it.
        //
        IF_DEBUG( OPLOCKS ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "Couldn't cache %8p \"%s\"\n",
                        pOpenFile, pOpenFile->GetKey()->m_pszFileName ));
        }

        CheckoutFileEntry(pOpenFile, 0);
        DecacheFile(pOpenFile, 0);
    }

    //
    // fall through to do cleanup
    //

err:

    if ( bImpersonated ) {
        ::RevertToSelf();
    }

    if ( !bSuccess ) {
        if ( pSecDesc ) {
            FREE(pSecDesc);
        }

        SetLastError(dwError);
    }

    return bSuccess;
}

DWORD
TspMakeWidePath(
    IN  LPCSTR  pszName,
    IN  DWORD   cchWideName,
    IN  BOOL    bNoParse,
    OUT LPWSTR  pwszWideName
    )
/*++
Routine Description:

    This routine converts a path name from the local code page and
    converts it to wide characters.  In addition it adds a prefix
    to the string, which is "\\?\UNC\" for a UNC path, and "\\?\" for
    other paths.  This prefix tells Windows not to parse the path.

Arguments:

    IN  pszName      - The path to be converted
    IN  cchWideName  - The size of the pwszWideName buffer
    OUT pwszWideName - The converted path

Return Values:

    On success we return the number of wide characters in the
    converted path + the prefix.

    On failure we return zero.  More error information will be
    returned by GetLastError().  The error code will be one of:

        ERROR_INSUFFICIENT_BUFFER
        ERROR_INVALID_NAME
--*/
{
    DWORD  cbPrefix=0;
    LPCSTR pszPath;
    DWORD  cch=0;

    if ( bNoParse ) {
        if ( (pszName[0] == '\\') && (pszName[1] == '\\') )
        {
            CopyMemory(
                pwszWideName,
                L"\\\\?\\UNC\\",
                (sizeof("\\\\?\\UNC\\")-1) * sizeof(WCHAR)
                );

            cbPrefix = sizeof("\\\\?\\UNC\\")-1;
            pszPath = pszName + sizeof( "\\\\" ) -1;
        }
        else
        {
            CopyMemory(
                pwszWideName,
                L"\\\\?\\",
                (sizeof("\\\\?\\")-1) * sizeof(WCHAR)
                );

            cbPrefix = sizeof("\\\\?\\")-1;
            pszPath = pszName;
        }
    } else {
        //
        // We're not adding a prefix
        //
        cbPrefix = 0;
        pszPath = pszName;
    }

    cch = MultiByteToWideChar( CP_ACP,
                               MB_PRECOMPOSED | MB_ERR_INVALID_CHARS,
                               pszPath,
                               -1,
                               pwszWideName + cbPrefix,
                               cchWideName - cbPrefix );

    if ( !cch && (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ) {
        SetLastError(ERROR_INVALID_NAME);

        return cch; // that is, return 0
    }

    return cch+cbPrefix-1; // return the string length without the ZERO
}


HANDLE
TS_OPEN_FILE_INFO::QueryFileHandle(
    VOID
    )
/*++
Routine Description:

    Returns a handle to the file, which we may have to open.

Arguments:

    None.

Return Values:

    INVALID_HANDLE_VALUE on failure
--*/
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hOldFile;

    Lock();

    if (m_hFile == INVALID_HANDLE_VALUE) {
        WCHAR               awchPath[MAX_PATH+8+1];
        DWORD               cchPath;

        //
        // Convert path to unicode
        //
        cchPath = TspMakeWidePath(m_FileKey.m_pszFileName, MAX_PATH+8, FALSE, awchPath);

        if (cchPath) {
            DWORD dwFileAttributes;

            // avoid the infamous ::$DATA bug

            if ( wcsstr( awchPath, L"::" ) )
            {
                SetLastError(ERROR_FILE_NOT_FOUND);
            } else if ((awchPath[cchPath-1] == L'.' || awchPath[cchPath-1] == L'\\') &&
                ((DWORD(-1) != (dwFileAttributes = GetFileAttributesW(awchPath))) &&
                 (!(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)))) {
                SetLastError(ERROR_FILE_NOT_FOUND);
            } else {
                SECURITY_ATTRIBUTES sa;

                sa.nLength              = sizeof(sa);
                sa.lpSecurityDescriptor = NULL;
                sa.bInheritHandle       = FALSE;

                //
                // Open the file
                //
                hFile = CreateFileW(
                    awchPath,
                    GENERIC_READ,
                    TsCreateFileShareMode,
                    &sa,
                    OPEN_EXISTING,
                    TsCreateFileFlags,
                    NULL);
            }
        }

        hOldFile = InterlockedExchangePointer(&m_hFile, hFile);

        if (hOldFile != INVALID_HANDLE_VALUE) {
            ::CloseHandle(hOldFile);
        }

        Unlock();

        //
        // Decache this file
        //
        DecacheFile(this, FCF_NO_DEREF);
    }
    else
    {
        Unlock();
    }

    return m_hFile;
}


//
// fileopen.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\dirlistp.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        getdirp.cxx

   Abstract:
        This module implements the functions for getting directory listings
         and transparently caching them.
        ( This uses OS specific functions to obtain the directory).

   Author:

           Murali R. Krishnan    ( MuraliK )     13-Jan-1995

   Project:

          Tsunami Lib
          ( Common caching and directory functions for Internet Services)

   Functions Exported:
   BOOL TsGetDirectoryListing()
   BOOL TsFreeDirectoryListing()
   int __cdecl
   AlphaCompareFileBothDirInfo(
              IN const void *   pvFileInfo1,
              IN const void *   pvFileInfo2)

   TS_DIRECTORY_HEADER::ReadWin32DirListing( IN LPCSTR pszDirectoryName)

   TS_DIRECTORY_HEADER::ReadFromNtDirectoryFile(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::BuildFileInfoPointers(
                  IN LPCWSTR          pwszDirectoryName
                  )
   TS_DIRECTORY_HEADER::CleanupThis()

   Revision History:
       MuraliK     06-Dec-1995  Used Win32 apis instead of NT apis
       MCourage    09-Jan-1998  Stopped caching directory information
                                Removed "guardian blobs"

--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include "tsunamip.hxx"

# include <stdlib.h>
# include <string.h>
# include <dbgutil.h>

/************************************************************
 *     Type Definitions
 ************************************************************/

# define DBGCODE(s)      DBG_CODE(s)

#define DIRECTORY_BUFFER_SIZE 8160          /* < 8192 bytes */

/************************************************************
 *    Functions
 ************************************************************/


BOOL FreeDirectoryHeaderContents( PVOID pvOldBlock );

PTS_DIRECTORY_HEADER
TsGetFreshDirectoryHeader(
     IN const TSVC_CACHE  &  tsCache,
     IN LPCSTR               pszDirectoryName,
     IN HANDLE               hLisingUser);



dllexp
BOOL
TsGetDirectoryListing(
    IN const TSVC_CACHE         &tsCache,
    IN      PCSTR               pszDirectoryName,
    IN      HANDLE              hListingUser,
    OUT     PTS_DIRECTORY_HEADER * ppTsDirectoryHeader
    )
/*++
  This function obtains the directory listing for dir specified
        in pszDirectoryName.

  Arguments:
    tsCache          Cache structure which is used for lookup
    pszDirectoryName  pointer to string containing the directory name
    ListingUser        Handle for the user opening the directory
    ppTsDirectoryHeader
       pointer to pointer to class containing directory information.
       Filled on successful return. On failure this will be NULL

  Returns:
      TRUE on success and FALSE if  there is a failure.
--*/
{
    PVOID          pvBlob = NULL;
    ULONG          ulSize = 0;
    BOOL           bSuccess;

    ASSERT( pszDirectoryName   != NULL );
    ASSERT( ppTsDirectoryHeader != NULL);


    //
    //  First, check to see if we have already cached a listing of this
    //  directory.
    //

    *ppTsDirectoryHeader = NULL;

//
// Dont try to cache directory listings
//
//    bSuccess = TsCheckOutCachedBlob(  tsCache,
//                                       pszDirectoryName,
//                                       RESERVED_DEMUX_DIRECTORY_LISTING,
//                                       ( PVOID * )&pvBlob,
//                                       &ulSize );
    bSuccess = FALSE;


    //
    //  The block was not present in cache.
    //  Obtain a fresh copy of the directory listing and cache it.
    //

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( (DBG_CONTEXT,
                    "Missing DirListing (%s) in cache. Generating newly\n",
                    pszDirectoryName));
    }

    *ppTsDirectoryHeader = TsGetFreshDirectoryHeader(
                                                      tsCache,
                                                      pszDirectoryName,
                                                      hListingUser );


    bSuccess = ( *ppTsDirectoryHeader != NULL);

    IF_DEBUG( DIR_LIST) {

        DBGCODE(
            CHAR pchBuff[600];
            wsprintfA( pchBuff,
                      "Obtained DirListing (%s). NEntries = %d\n",
                      pszDirectoryName,
                      (*ppTsDirectoryHeader)->QueryNumEntries());
            OutputDebugString( pchBuff);
        );
    }

    return ( bSuccess);

} // TsGetDirectoryListing()




dllexp
BOOL
TsFreeDirectoryListing
(
    IN const TSVC_CACHE &    tsCache,
    IN PTS_DIRECTORY_HEADER  pDirectoryHeader
)
{
    BOOL fReturn;
    BOOL fCached = pDirectoryHeader->IsCached;

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "TsFreeDirectoryListing( %08p) called. Cached = %d\n",
                    pDirectoryHeader,
                    fCached));

        pDirectoryHeader->Print();
    }

    if ( fCached )
    {
        fReturn = TsCheckInCachedBlob( ( PVOID )pDirectoryHeader );
    }
    else
    {
        fReturn = TsFree( tsCache, ( PVOID )pDirectoryHeader );
    }

    return( fReturn);
} // TsFreeDirectoryListing()







PTS_DIRECTORY_HEADER
TsGetFreshDirectoryHeader(
     IN const TSVC_CACHE  &  tsCache,
     IN LPCSTR               pszDirectoryName,
     IN HANDLE               hListingUser)
/*++

  This function obtains a fresh copy of the directory listing for the
    directory specified and caches it if possible, before returning pointer
    to the directory information.

  Returns:
     On success it returns the pointer to newly constructed directory listing.
     On failure this returns a NULL

--*/
{
    PTS_DIRECTORY_HEADER pDirectoryHeader;
    PVOID               pvGuardBlob;
    BOOL                bSuccess;
    BOOL                bCachedGuardianBlob;

#ifdef TS_USE_DIRECTORY_GUARD
    //
    //  If we are going to cache this directory, we would like to increase the
    //  likelihood that it is an "atomic" snapshot.  This is done as follows:
    //
    //  We cache and hold checked-out a small blob while create the directory
    //  listing.  If that Blob (1) could not be cached, or (2) was ejected
    //  from the cache while we were generating a listing, then we do not
    //  attempt to cache the directory.
    //
    //  Reasoning:
    //
    //  1) If the Blob couldn't be cached then the directory info won't be any
    //     different.
    //
    //  2) If the Blob was ejected, the directory must have changed while we
    //     were reading it.  If this happens, we don't want to cache possibly
    //     inconsistent data.
    //
    //  If the directory changed and the Blob has not yet been ejected, the
    //  directory will soon be ejected anyway.  Notice that the Blob is not
    //  DeCache()'d until after the directory has been cached.
    //

    if ( !TsAllocate( tsCache, sizeof( TS_DIRECTORY_HEADER),
                     (PVOID *) &pvGuardBlob)) {

        //
        //  Failure to allocate and secure a guardian blob.
        //

        IF_DEBUG( DIR_LIST) {

            DBGPRINTF( (DBG_CONTEXT,
                        "Allocation of Guardianblob for %s failed. Error=%d\n",
                        pszDirectoryName, GetLastError()));
        }

        return ( NULL);
    }

    //
    //  A successful guardian block allocated. Try and cache it.
    //

    ULONG cchDirectoryName = strlen(pszDirectoryName);

    bCachedGuardianBlob = TsCacheDirectoryBlob(
                              tsCache,
                              pszDirectoryName,
                              cchDirectoryName,
                              RESERVED_DEMUX_ATOMIC_DIRECTORY_GUARD,
                              pvGuardBlob,
                              TRUE );

    if ( !bCachedGuardianBlob ) {

        BOOL  fFreed;

        //
        //  Already there is one such cached blob. ignore this blob.
        //  So free up the space used.
        //

        fFreed = TsFree( tsCache, pvGuardBlob );
        ASSERT( fFreed);
        pvGuardBlob = NULL;
    }
#endif // TS_USE_DIRECTORY_GUARD

    //
    // Allocate space for Directory listing
    //

    bSuccess = TsAllocateEx( tsCache,
                            sizeof( TS_DIRECTORY_HEADER ),
                            ( PVOID * )&pDirectoryHeader,
                            FreeDirectoryHeaderContents );

    if ( bSuccess) {

        BOOL fReadSuccess;
        DWORD cbBlob = 0;

        ASSERT( pDirectoryHeader != NULL);

        pDirectoryHeader->ReInitialize();  // called since we raw alloced space
        pDirectoryHeader->SetListingUser( hListingUser);

        fReadSuccess = (pDirectoryHeader->ReadWin32DirListing(pszDirectoryName,
                                                               &cbBlob ) &&
                        pDirectoryHeader->BuildFileInfoPointers( &cbBlob )
                        );

        if ( fReadSuccess) {
#if TS_USE_DIRECTORY_GUARD
            //
            //  Attempt and cache the blob if the blob size is cacheable
            //

            if ( bCachedGuardianBlob &&
                 !BLOB_IS_EJECTATE( pvGuardBlob )  ) {


                ASSERT( BLOB_IS_OR_WAS_CACHED( pvGuardBlob ) );

                bSuccess =
                  TsCacheDirectoryBlob(tsCache,
                                        pszDirectoryName,
                                        cchDirectoryName,
                                        RESERVED_DEMUX_DIRECTORY_LISTING,
                                        pDirectoryHeader,
                                        TRUE );

                if ( bSuccess ) {

                    INC_COUNTER( tsCache.GetServiceId(), CurrentDirLists );
                }

                //
                // Even if caching of the blob failed, that is okay!
                //

                if ( bSuccess && BLOB_IS_EJECTATE( pvGuardBlob ) ) {

                    TsExpireCachedBlob( tsCache, pDirectoryHeader );
                }

            }

#endif // TS_USE_DIRECTORY_GUARD

        } else {

            //
            // Reading directory failed.
            //  cleanup directory related data and get out.
            //

            BOOL fFreed = TsFree( tsCache, pDirectoryHeader);
            ASSERT( fFreed);
            pDirectoryHeader = NULL;
            bSuccess = FALSE;
        }

    } else {

        //
        // Allocation of Directory Header failed.
        //
        ASSERT( pDirectoryHeader == NULL);
    }

#if TS_USE_DIRECTORY_GUARD
    // Free up the guardian block and exit.

    if ( bCachedGuardianBlob) {

        bSuccess = TsExpireCachedBlob( tsCache, pvGuardBlob );

        ASSERT( bSuccess );

        bSuccess = TsCheckInCachedBlob(  pvGuardBlob );
        ASSERT( bSuccess );

        pvGuardBlob = NULL;
    }

    ASSERT( pvGuardBlob  == NULL);
#endif // TS_USE_DIRECTORY_GUARD
    
    return ( pDirectoryHeader);
} // TsGetFreshDirectoryHeader




BOOL
FreeDirectoryHeaderContents( PVOID pvOldBlock )
{
    PTS_DIRECTORY_HEADER  pDirectoryHeader;

    pDirectoryHeader = ( PTS_DIRECTORY_HEADER )pvOldBlock;

    pDirectoryHeader->CleanupThis();

    //
    //  The item may never have been added to the cache, don't
    //  count it in this case
    //
//
// We're never caching dir blobs now
//
//    if ( BLOB_IS_OR_WAS_CACHED( pvOldBlock ) ) {
//
//        DEC_COUNTER( BLOB_GET_SVC_ID( pvOldBlock ), CurrentDirLists );
//    }

    return ( TRUE);
}  //  FreeDirectoryHeaderContents()




int __cdecl
AlphaCompareFileBothDirInfo(
   IN const void *   pvFileInfo1,
   IN const void *   pvFileInfo2)
{
    const WIN32_FIND_DATA * pFileInfo1 =
        *((const WIN32_FIND_DATA **) pvFileInfo1);
    const WIN32_FIND_DATA * pFileInfo2 =
        *((const WIN32_FIND_DATA **) pvFileInfo2);

    ASSERT( pFileInfo1 != NULL && pFileInfo2 != NULL);

    return ( lstrcmp( (LPCSTR )pFileInfo1->cFileName,
                      (LPCSTR )pFileInfo2->cFileName));

} // AlphaCompareFileBothDirInfo()



BOOL
SortInPlaceFileInfoPointers(
    IN OUT PWIN32_FIND_DATA  *   prgFileInfo,
    IN int   nEntries,
    IN PFN_CMP_WIN32_FIND_DATA   pfnCompare)
/*++
  This is a generic function to sort the pointers to file information
    array in place using pfnCompare to compare the records for ordering.

  Returns:
     TRUE on success and FALSE on failure.
--*/
{
    DWORD  dwTime;

    IF_DEBUG( DIR_LIST) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Qsorting the FileInfo Array %08p ( Total = %d)\n",
                    prgFileInfo, nEntries));
        dwTime = GetTickCount();
    }


    qsort( (PVOID ) prgFileInfo, nEntries,
          sizeof( PWIN32_FIND_DATA),
          pfnCompare);


    IF_DEBUG( DIR_LIST) {

        dwTime = GetTickCount() - dwTime;
        DBGPRINTF( ( DBG_CONTEXT,
                    " Time to sort %d entries = %d\n",
                    nEntries, dwTime));
    }

    return ( TRUE);
} // SortInPlaceFileInfoPointers()




/**********************************************************************
 *    TS_DIRECTORY_HEADER  related member functions
 **********************************************************************/



const char PSZ_DIR_STAR_STAR[] = "*.*";
# define LEN_PSZ_DIR_STAR_STAR  ( sizeof(PSZ_DIR_STAR_STAR)/sizeof(CHAR))

BOOL
TS_DIRECTORY_HEADER::ReadWin32DirListing(
    IN LPCSTR           pszDirectoryName,
    IN OUT DWORD *      pcbMemUsed
    )
/*++
  Opens and reads the directory file for given directory to obtain
   information about files and directories in the dir.

  Arguments:
    pszDirectoryName  - pointer to string containing directory name
                         with a terminating "\".
    pcbMemUsed        - pointer to DWORD which on successful return
                         will contain the memory used.

  Returns:
     TRUE on success and   FALSE on failure.
     Use GetLastError() for further error information.

--*/
{
    BOOL                fReturn = TRUE;       // default assumed.
    CHAR                pchFullPath[MAX_PATH*2];
    HANDLE              hFindFile = INVALID_HANDLE_VALUE;
    BOOL                fFirstTime;
    DWORD               cbExtraMem = 0;
    DWORD               dwError = NO_ERROR;
    PWIN32_FIND_DATA    pFileInfo = NULL;
    PTS_DIR_BUFFERS     pTsDirBuffers = NULL;
    DWORD startCount;

    DBGCODE( CHAR pchBuff[300];
            );


    DBG_ASSERT( pszDirectoryName != NULL);

    if ( strlen(pszDirectoryName) > MAX_PATH*2 - LEN_PSZ_DIR_STAR_STAR) {

        return ( ERROR_PATH_NOT_FOUND);
    }

    wsprintfA( pchFullPath, "%s%s", pszDirectoryName, PSZ_DIR_STAR_STAR);

    InitializeListHead( &m_listDirectoryBuffers);

    //
    // Get the next chunk of directory information.
    //

    pTsDirBuffers = (PTS_DIR_BUFFERS ) ALLOC( sizeof(TS_DIR_BUFFERS));

    if ( pTsDirBuffers == NULL ) {

        //
        //  Allocation failure.
        //
        SetLastError( ERROR_NOT_ENOUGH_MEMORY);
        fReturn = FALSE;
        goto Failure;
    }

    cbExtraMem += sizeof(TS_DIR_BUFFERS);

    // insert the buffer into the list so that it may be freed later.
    InsertBufferInTail( &pTsDirBuffers->listEntry);
    pTsDirBuffers->nEntries = 0;

    pFileInfo = (PWIN32_FIND_DATA ) pTsDirBuffers->rgFindData;

    hFindFile = FindFirstFile( pchFullPath, pFileInfo);
    if ( hFindFile == INVALID_HANDLE_VALUE) {

        dwError = GetLastError();

        IF_DEBUG( DIR_LIST) {
            DBGPRINTF(( DBG_CONTEXT,
                       "FindFirstFile(%s, %08p) failed. Error = %d\n",
                       pchFullPath, pFileInfo, dwError));
        }
        fReturn = FALSE;
        goto Failure;
    }
    IF_DEBUG( DIR_LIST) {

        DBGCODE(
                wsprintf( pchBuff, "-%d-[%d](%08p) %s(%s)\t%08x\n",
                         MAX_DIR_ENTRIES_PER_BLOCK,
                         0,
                         pFileInfo,
                         pFileInfo->cFileName, pFileInfo->cAlternateFileName,
                         pFileInfo->dwFileAttributes);
                OutputDebugString( pchBuff);
                );
    }

    pFileInfo++;
    IncrementDirEntries();
    pTsDirBuffers->nEntries++;
    startCount = 1;

    // atleast 10 to justify overhead
    DBG_ASSERT( MAX_DIR_ENTRIES_PER_BLOCK > 10);

    //
    //  Loop through getting subsequent entries in the directory.
    //

    for( dwError = NO_ERROR; dwError == NO_ERROR; ) {

        // loop thru and get a block of items

        for( int i = startCount; i < MAX_DIR_ENTRIES_PER_BLOCK; i++ ) {

            if ( !FindNextFile( hFindFile, pFileInfo)) {

                dwError = GetLastError();

                if ( dwError != ERROR_NO_MORE_FILES) {
                    DBGPRINTF(( DBG_CONTEXT,
                               "FindNextFile(%s(%08p), %08p) failed."
                               " Error = %d\n",
                               pchFullPath, hFindFile, pFileInfo,
                               dwError));
                    fReturn = FALSE;
                    goto Failure;
                } else {

                    break;
                }
            }

            IF_DEBUG( DIR_LIST) {

                DBGCODE(
                        wsprintf( pchBuff, "[%d](%08p) %s(%s)\t%08x\n",
                                 i, pFileInfo,
                                 pFileInfo->cFileName,
                                 pFileInfo->cAlternateFileName,
                                 pFileInfo->dwFileAttributes);
                        OutputDebugString( pchBuff);
                        );
            }

            IncrementDirEntries();
            pFileInfo++;

        } // for all elements that fit in this block

        pTsDirBuffers->nEntries = i;

        if ( dwError == ERROR_NO_MORE_FILES) {

            //
            // info on all entries in a directory obtained. Return back.
            //

            dwError = NO_ERROR;
            break;
        } else {

            //
            //  The buffer contains directory entries and is full now.
            //  Update the count of entries in this buffer and
            //  Allocate a new buffer and set the start counts properly.
            //

            IF_DEBUG( DIR_LIST) {
                DBGCODE( OutputDebugString( " Allocating Next Chunck\n"););
            }

            pTsDirBuffers = (PTS_DIR_BUFFERS ) ALLOC(sizeof(TS_DIR_BUFFERS));

            if ( pTsDirBuffers == NULL ) {

                //
                //  Allocation failure.
                //
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                fReturn = FALSE;
                break;                // Get out of the loop with failure.
            }

            cbExtraMem += sizeof(TS_DIR_BUFFERS);

            // insert the buffer into the list so that it may be freed later.
            InsertBufferInTail( &pTsDirBuffers->listEntry);
            pTsDirBuffers->nEntries = 0;

            pFileInfo = ( PWIN32_FIND_DATA ) pTsDirBuffers->rgFindData;

            startCount = 0;  // start count from zero items on this buffer page
        }

    } // for all directory entries

Failure:

    if ( hFindFile != INVALID_HANDLE_VALUE) {
        DBG_REQUIRE( FindClose( hFindFile ));
        hFindFile = INVALID_HANDLE_VALUE;
    }

    *pcbMemUsed += cbExtraMem;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::ReadWin32DirListing()


VOID
TS_DIRECTORY_HEADER::CleanupThis( VOID)
{
    PLIST_ENTRY pEntry;
    PLIST_ENTRY pNextEntry;

    for ( pEntry = QueryDirBuffersListEntry()->Flink;
         pEntry != QueryDirBuffersListEntry();
         pEntry  = pNextEntry )
    {
        PTS_DIR_BUFFERS  pTsDirBuffer =
          CONTAINING_RECORD( pEntry, TS_DIR_BUFFERS, listEntry);

        // cache the next block pointer.
        pNextEntry = pEntry->Flink;

        // remove the current block from list.
        RemoveEntryList( pEntry);

        // delete the current block.
        FREE( pTsDirBuffer );
    }

    InitializeListHead( QueryDirBuffersListEntry());

    if ( m_ppFileInfo != NULL) {

        FREE( m_ppFileInfo);
        m_ppFileInfo   = NULL;
    }

    m_hListingUser = INVALID_HANDLE_VALUE;
    m_nEntries     = 0;

    return;
} // TS_DIRECTORY_HEADER::CleanupThis()





BOOL
TS_DIRECTORY_HEADER::BuildFileInfoPointers(
    IN OUT DWORD *      pcbMemUsed
    )
/*++

  This constructs the indirection pointers from the buffers containing the
   file information.
  This array of indirection enables faster access to the file information
   structures stored.

   Should be always called after ReadFromNtDirectoryFile() to construct the
    appropriate pointers.

   Returns:
     TRUE on success and FALSE if there are any failures.
--*/
{
    BOOL  fReturn = FALSE;
    DWORD cbAlloc;
    int   maxIndex;

    maxIndex = QueryNumEntries();

    ASSERT( maxIndex != 0);  //  Any directory will atleast have "."

    //
    // Alloc space for holding the pointers for numEntries pointers.
    //

    cbAlloc = maxIndex * sizeof( PWIN32_FIND_DATA );

    m_ppFileInfo = (PWIN32_FIND_DATA *) ALLOC( cbAlloc );

    if ( m_ppFileInfo != NULL ) {

        int          index;
        PLIST_ENTRY  pEntry;
        PTS_DIR_BUFFERS    pTsDirBuffers;
        PWIN32_FIND_DATA   pFileInfo;

        //
        //  Get the link to first buffer and start enumeration.
        //

        for( pEntry = QueryDirBuffersListEntry()->Flink, index = 0;
             pEntry != QueryDirBuffersListEntry();
            pEntry = pEntry->Flink
            ) {

            pTsDirBuffers = CONTAINING_RECORD( pEntry, TS_DIR_BUFFERS,
                                               listEntry);

            pFileInfo = pTsDirBuffers->rgFindData;

            for (int  i = 0;
                 i < pTsDirBuffers->nEntries;
                 i++ ) {

                m_ppFileInfo[index++] = pFileInfo;    // store the pointer.

                IF_DEBUG( DIR_LIST) {
                    DBGCODE(
                            CHAR pchBuff[300];
                            wsprintf( pchBuff, "[%d](%08p) %s(%s)\t%08x\n",
                                     index, pFileInfo,
                                     pFileInfo->cFileName,
                                     pFileInfo->cAlternateFileName,
                                     pFileInfo->dwFileAttributes);
                            OutputDebugString( pchBuff);
                            );
                }

                pFileInfo++;

            } // for all elements in a buffer

        } // for ( all buffers in the list)


        ASSERT( index == maxIndex);

        fReturn = SortInPlaceFileInfoPointers( m_ppFileInfo,
                                              maxIndex,
                                              AlphaCompareFileBothDirInfo);

    } // valid alloc of the pointers.

    *pcbMemUsed += cbAlloc;

    return ( fReturn);
} // TS_DIRECTORY_HEADER::BuildFileInfoPointers()



# if DBG

VOID
TS_DIRECTORY_HEADER::Print( VOID) const
{
    DBGPRINTF( ( DBG_CONTEXT,
                "Printing TS_DIRECTORY_HEADER ( %08p).\n"
                "ListingUser Handle = %08p\t Num Entries = %08x\n"
                "Pointer to array of indirection pointers %08p\n",
                this,
                m_hListingUser, m_nEntries,
                m_ppFileInfo));

    //
    //  The buffers containing the data of the file information not printed
    //

    return;
} // TS_DIRECTORY_HEADER::Print()


# endif // DBG

/************************ End of File ***********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\fileinfo.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    fileinfo.cxx

    This module contains the methods for TS_OPEN_FILE_INFO


    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>
#include "tsunamip.hxx"
#include <iistypes.hxx>
#include <acache.hxx>
#include <imd.h>
#include <mb.hxx>
#include "string.h"

#include "filecach.hxx"
#include "filehash.hxx"
#include "tlcach.h"
#include "etagmb.h"


GENERIC_MAPPING g_gmFile = {
    FILE_GENERIC_READ,
    FILE_GENERIC_WRITE,
    FILE_GENERIC_EXECUTE,
    FILE_ALL_ACCESS
};



ALLOC_CACHE_HANDLER * TS_OPEN_FILE_INFO::sm_pachFileInfos;
CRITICAL_SECTION      TS_OPEN_FILE_INFO::sm_cs;


TS_OPEN_FILE_INFO::TS_OPEN_FILE_INFO()
  : m_Signature(TS_FILE_INFO_SIGNATURE),
    m_hFile(INVALID_HANDLE_VALUE),
    m_pFileBuffer(0),
    m_hUser(INVALID_HANDLE_VALUE),
    m_cbSecDescMaxSize(0),
    m_pSecurityDescriptor(m_abSecDesc),
    m_fSecurityDescriptor(FALSE),
    m_cchHttpInfo(0),
    m_cchETag(0),
    m_ETagIsWeak(TRUE),
    m_bIsCached(FALSE),
    m_state(FI_UNINITIALIZED),
    m_lRefCount(0),
    m_dwIORefCount(0),
    m_TTL(1),
    m_FileAttributes(0xFFFFFFFF),
    m_pvContext( NULL ),
    m_pfnFreeRoutine( NULL )
{
    m_FileKey.m_cbFileName = 0;
    m_FileKey.m_pszFileName = NULL;
}

BOOL
TS_OPEN_FILE_INFO::SetContext(
    PVOID                   pvContext,
    PCONTEXT_FREE_ROUTINE   pfnFreeRoutine
)
/*++

Routine Description

    Used by external components (SSI) to set an opaque context and a
    free routine to be called when freeing the context.  This allows SSI
    to associate the SSI parsed template with actual TS_OPEN_FILE_INFO

Arguments

    None.

Return

    TRUE if the context was set.  FALSE if there was already a context.

--*/
{
    BOOL                    fRet;

    Lock();

    if ( m_pvContext != NULL )
    {
        fRet = FALSE;
    }
    else
    {
        m_pvContext = pvContext;
        m_pfnFreeRoutine = pfnFreeRoutine;
        fRet = TRUE;
    }

    Unlock();

    return fRet;
}

PVOID
TS_OPEN_FILE_INFO::QueryContext(
    VOID
) const
/*++

Routine Description

    Returns the context associated with the TS_OPEN_FILE_INFO

Arguments

    None.

Return

    Pointer to context

--*/
{
    PVOID               pvContext;

    Lock();
    pvContext = m_pvContext;
    Unlock();

    return pvContext;
}

VOID
TS_OPEN_FILE_INFO::FreeContext(
    VOID
)
/*++

Routine Description

    Frees the opaque context by calling the free routine

Arguments

    None.

Return

    None

--*/
{
    Lock();
    if ( m_pvContext )
    {
        if ( m_pfnFreeRoutine )
        {
            __try
            {
                m_pfnFreeRoutine( m_pvContext );
            }
            __finally
            {
                m_pvContext = NULL;
            }
        }
        else
        {
            DBG_ASSERT( FALSE );
        }
    }
    Unlock();
}

BOOL
FileFlushFilterContext(
    TS_OPEN_FILE_INFO *pOpenFile,
    PVOID              pv
)
/*++

Routine Description

    Filter used by FilteredFlushFileCache to select those TS_OPEN_FILE_INFO
    objects which have a context.  This routine will actually do the freeing
    and will return FALSE.  This is done to prevent premature flushing of
    the cache when SSI shuts down.

Arguments

    pOpenFile - TS_OPEN_FILE_INFO object
    pv - Unused context

Return

    Always returns FALSE

--*/
{
    DBG_ASSERT( pOpenFile );

    pOpenFile->FreeContext();

    DBG_ASSERT( !pOpenFile->QueryContext() );

    return FALSE;
}

VOID
TsFlushFilesWithContext(
    VOID
)
/*++

Routine Description

    Exported routine used by SSI to free all opaque contexts.  This is called
    before SSINC.DLL is unloaded to prevent AVs in context free

Arguments

    None

Return

    None

--*/
{
    FilteredFlushFileCache( FileFlushFilterContext, NULL );
}

BOOL
TS_OPEN_FILE_INFO::SetFileName(const CHAR * pszFileName)
{
    DBG_ASSERT( pszFileName );
    DBG_ASSERT( pszFileName[0] );

    m_FileKey.m_cbFileName = strlen(pszFileName);

    if (m_FileKey.m_cbFileName < TS_DEFAULT_PATH_SIZE) {
        //
        // It fits in our fixed size buffer
        //
        m_FileKey.m_pszFileName = m_FileKey.m_achFileNameBuf;
    } else {
        //
        // we need a bigger buffer
        //
        m_FileKey.m_pszFileName = new CHAR[m_FileKey.m_cbFileName + 1];
    }

    if (NULL != m_FileKey.m_pszFileName) {
        memcpy(m_FileKey.m_pszFileName, pszFileName, m_FileKey.m_cbFileName + 1);
    } else {
        m_FileKey.m_cbFileName = 0;
    }

    return (0 != m_FileKey.m_cbFileName);
}


TS_OPEN_FILE_INFO::~TS_OPEN_FILE_INFO( VOID)
{
    DBG_ASSERT( 0 == m_lRefCount );
    DBG_ASSERT( 0 == m_dwIORefCount );
    DBG_ASSERT( CheckSignature() );

    m_Signature = TS_FREE_FILE_INFO_SIGNATURE;

    if (m_FileKey.m_pszFileName
        && (m_FileKey.m_achFileNameBuf != m_FileKey.m_pszFileName)) {

        delete [] m_FileKey.m_pszFileName;
    }

    if (m_pFileBuffer) {
        DWORD dwError;

        dwError = ReleaseFromMemoryCache(
                      m_pFileBuffer,
                      m_nFileSizeLow
                      );

        DBG_ASSERT(dwError == ERROR_SUCCESS);
    }

    if (m_hFile != INVALID_HANDLE_VALUE) {
        ::CloseHandle(m_hFile);
    }

    if (m_pSecurityDescriptor
        && (m_pSecurityDescriptor != m_abSecDesc)) {
        FREE(m_pSecurityDescriptor);
    }

    if (m_pvContext)
    {
        FreeContext();
    }
}

BOOL
TS_OPEN_FILE_INFO::AccessCheck(
    IN  HANDLE hUser,
    IN  BOOL   bCache
    )
{
    DBG_ASSERT(hUser != INVALID_HANDLE_VALUE);

    //
    // If it's the same user that last opened the file
    // then we know we have access.
    //
    if (hUser == m_hUser) {
        TraceCheckpointEx(TS_MAGIC_ACCESS_CHECK, (PVOID)hUser, (PVOID)(LONG_PTR)0xffffffff);
        return TRUE;
    }

    //
    // If we've got a security descriptor we can check
    // against that, otherwise fail the check.
    //
    BYTE  psFile[SIZE_PRIVILEGE_SET];
    DWORD dwPS;
    DWORD dwGrantedAccess;
    BOOL  fAccess;

    dwPS = sizeof(psFile);
    ((PRIVILEGE_SET*)&psFile)->PrivilegeCount = 0;

    if (m_fSecurityDescriptor
        && ::AccessCheck(m_pSecurityDescriptor,
                         hUser,
                         FILE_GENERIC_READ,
                         &g_gmFile,
                         (PRIVILEGE_SET*)psFile,
                         &dwPS,
                         &dwGrantedAccess,
                         &fAccess) ) {

        if (fAccess && bCache) {
            m_hUser = hUser;
        }

        TraceCheckpointEx(TS_MAGIC_ACCESS_CHECK, (PVOID)hUser, (PVOID) (ULONG_PTR) fAccess);
        return fAccess;
    } else {
        return FALSE;
    }
}

VOID
TS_OPEN_FILE_INFO::SetFileInfo(
    HANDLE               hFile,
    HANDLE               hUser,
    PSECURITY_DESCRIPTOR pSecDesc,
    DWORD                dwSecDescSize,
    PBY_HANDLE_FILE_INFORMATION pFileInfo,
    PBYTE                pFileBuff
    )
{
    m_FileAttributes = pFileInfo->dwFileAttributes;
    m_nFileSizeLow   = pFileInfo->nFileSizeLow;
    m_nFileSizeHigh  = pFileInfo->nFileSizeHigh;

   
    m_ftLastWriteTime =  pFileInfo->ftLastWriteTime;

    //
    // Save file buffer
    //

    m_pFileBuffer = pFileBuff;

    //
    // Save away the given parameters
    //
    m_hFile = hFile;
    m_hUser = hUser;

    m_pSecurityDescriptor = pSecDesc;
    m_cbSecDescMaxSize = dwSecDescSize;
    if (dwSecDescSize)
        m_fSecurityDescriptor = TRUE;

    //
    // Generate some other file attributes
    //  
    DWORD dwChangeNumber = ETagChangeNumber::GetChangeNumber();
    BOOL  fReturn = TRUE;
    UINT64 Int64Value = (FILETIMEToUINT64(m_ftLastWriteTime) / 10000000) * 10000000;

    m_CastratedLastWriteTime = UINT64ToFILETIME(Int64Value);

    //  
    // Make the ETag
    //
    m_ETagIsWeak = TRUE;

    m_cchETag = FORMAT_ETAG(m_achETag, *(FILETIME*) &m_ftLastWriteTime,
                                dwChangeNumber);

    //
    // Make the ETag strong if possible
    //
    MakeStrongETag();

    //
    //  Turn off the hidden attribute if this is a root directory listing
    //  (root some times has the bit set for no apparent reason)
    //

    if ( m_FileAttributes & FILE_ATTRIBUTE_HIDDEN )
    {
        CHAR * pszFileName = m_FileKey.m_pszFileName;
    
        if ( m_FileKey.m_cbFileName >= 2 )
        {
            if ( pszFileName[ 1 ] == ':' )
            {
                if ( ( pszFileName[ 2 ] == '\0' ) ||
                     ( pszFileName[ 2 ] == '\\' && pszFileName[ 3 ] == '\0' ) )
                {
                    //
                    // This looks like a local root.  Mask out the bit
                    //

                    m_FileAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
                }
            }
        }
    }
}

VOID
TS_OPEN_FILE_INFO::CloseHandle(
    void
    )
{
    HANDLE hFile;
    PBYTE  pFileBuffer;
    BOOL   bClose = FALSE;
    BOOL   bRelease = FALSE;
    DWORD  dwError;

    Lock();
    ASSERT( DisableTsunamiCaching
            || (m_state == FI_FLUSHED)
            || (m_bIsCached == FALSE) );
    ASSERT( m_dwIORefCount == 0 );

    m_state = FI_CLOSED;

    if (m_pFileBuffer) {
        pFileBuffer = m_pFileBuffer;
        m_pFileBuffer = NULL;

        bRelease = TRUE;
    }


    if (m_hFile != INVALID_HANDLE_VALUE) {
        hFile = m_hFile;
        m_hFile = INVALID_HANDLE_VALUE;

        bClose = TRUE;
    }

    Unlock();

    if (bRelease) {
        TraceCheckpointEx(TS_MAGIC_CLOSE, pFileBuffer, (PVOID) 1);

        dwError = ReleaseFromMemoryCache(
                      pFileBuffer,
                      m_nFileSizeLow
                      );

        DBG_ASSERT(dwError == ERROR_SUCCESS);
    }

    if (bClose) {
        TraceCheckpointEx(TS_MAGIC_CLOSE, hFile, 0);
        ::CloseHandle(hFile);
    }
}



INT
FormatETag(
    PCHAR pszBuffer,
    const FILETIME& rft,
    DWORD mdchange)
{
    PCHAR psz = pszBuffer;
    PBYTE pbTime = (PBYTE) &rft;
    const char szHex[] = "0123456789abcdef";

    *psz++ = '\"';
    for (int i = 0; i < 8; i++)
    {
        BYTE b = *pbTime++;
        BYTE bH = b >> 4;
        if (bH != 0)
            *psz++ = szHex[bH];
        *psz++ = szHex[b & 0xF];
    }
    *psz++ = ':';
    psz += strlen(_itoa((DWORD) mdchange, psz, 16));
    *psz++ = '\"';
    *psz = '\0';

    return (INT)(psz - pszBuffer);
}



VOID
TS_OPEN_FILE_INFO::MakeStrongETag(
    VOID
    )
/*++

    Routine Description

        Try and make an ETag 'strong'. To do this we see if the difference
        between now and the last modified date is greater than our strong ETag
        delta - if so, we mark the ETag strong.

    Arguments

        None.

    Returns

        Nothing.

--*/
{
    FILETIME                    ftNow;
    SYSTEMTIME                  stNow;
    FILETIME                    iNow, iFileTime;

    if ( m_pFileBuffer ||
         m_hFile != INVALID_HANDLE_VALUE ) {
        ::GetSystemTimeAsFileTime(&ftNow);

        iNow = ftNow;
        iFileTime = m_ftLastWriteTime;

        if ((FILETIMEToUINT64(iNow) - FILETIMEToUINT64(iFileTime)) > STRONG_ETAG_DELTA )
        {
            m_ETagIsWeak = FALSE;
        }
    }
}




BOOL
TS_OPEN_FILE_INFO::SetHttpInfo(
    IN PSTR pszInfo,
    IN INT  InfoLength
    )
/*++

    Routine Description

        Set the "Last-Modified:" header field in the file structure.

    Arguments

        pszDate - pointer to the header value to save
        InfoLength - length of the header value to save

    Returns

        TRUE if information was cached,
        FALSE if not cached

--*/
{
    if ( !m_ETagIsWeak && InfoLength < sizeof(m_achHttpInfo)-1 ) {

        CopyMemory( m_achHttpInfo, pszInfo, InfoLength+1 );

        //
        // this MUST be set after updating the array,
        // as this is checked to know if the array content is valid.
        //

        m_cchHttpInfo = InfoLength;
        return TRUE;
    }
    return FALSE;
} // TS_OPEN_FILE_INFO::SetHttpInfo

/*
 * Static members
 */

BOOL
TS_OPEN_FILE_INFO::Initialize(
    DWORD dwMaxFiles
    )
{
    ALLOC_CACHE_CONFIGURATION  acConfig = { 1, dwMaxFiles, sizeof(TS_OPEN_FILE_INFO)};

    if ( NULL != sm_pachFileInfos) {

        // already initialized
        return ( TRUE);
    }

    sm_pachFileInfos = new ALLOC_CACHE_HANDLER( "FileInfos",
                                                 &acConfig);

    if ( sm_pachFileInfos ) {
        INITIALIZE_CRITICAL_SECTION(&sm_cs);
    }

    return ( NULL != sm_pachFileInfos);
}

VOID
TS_OPEN_FILE_INFO::Cleanup(
    VOID
    )
{
    if ( NULL != sm_pachFileInfos) {

        delete sm_pachFileInfos;
        sm_pachFileInfos = NULL;

        DeleteCriticalSection(&sm_cs);
    }
}



VOID
TS_OPEN_FILE_INFO::Lock(
    VOID
    )
{
    EnterCriticalSection(&sm_cs);
}


VOID
TS_OPEN_FILE_INFO::Unlock(
    VOID
    )
{
    LeaveCriticalSection(&sm_cs);
}

VOID *
TS_OPEN_FILE_INFO::operator new( size_t s)
{
    DBG_ASSERT( s == sizeof( TS_OPEN_FILE_INFO));

    // allocate from allocation cache.
    DBG_ASSERT( NULL != sm_pachFileInfos);
    return (sm_pachFileInfos->Alloc());
}

VOID
TS_OPEN_FILE_INFO::operator delete( void * pOpenFile)
{
    DBG_ASSERT( NULL != pOpenFile);

    // free to the allocation pool
    DBG_ASSERT( NULL != sm_pachFileInfos);
    DBG_REQUIRE( sm_pachFileInfos->Free(pOpenFile));

    return;
}

//
// fileopen.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\filemisc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1994                **/
/**********************************************************************/

/*
    filemisc.cxx

    This module contains some random functions for manipulating
    TS_OPEN_FILE_INFO objects


    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>

#include <imd.h>
#include <mb.hxx>
#include <mbstring.h>

#include "tsunamip.hxx"
#include "etagmb.h"

BOOL
TsDeleteOnClose(PW3_URI_INFO pURIInfo,
                HANDLE OpeningUser,
                BOOL *fDeleted)
/*++
Routine Description:

    Marks the file associated with the passed URIInfo for deletion. When everyone 
    is done using that file, it will be deleted

Arguments:

    pURIInfo    - The W3_URI_INFO whose file will be marked for deletion 
    OpeningUser - HANDLE for the user attempting the delete operation 
    fDeleted    - Will be set if TsDeleteOnClose returns TRUE. If the user has access 
                  and the file was marked deleted fDeleted will be TRUE. Otherwise it will be 
                  FALSE. 

Return Values:

TRUE  - The user had access and the file was marked, or the user was denied access. 
FALSE - An error other than Access Denied occured. 

--*/
{
    //
    // Doesn't do anything.  Ha ha!
    //
    *fDeleted = FALSE;
    return FALSE;

}



PSECURITY_DESCRIPTOR
TsGetFileSecDesc(
    LPTS_OPEN_FILE_INFO     pFile
    )
/*++

Routine Description:

    Returns the security descriptor associated to the file
    To be freed using LocalFree()

Arguments:

    pFile - ptr to fie object

Return Value:

    ptr to security descriptor or NULL if error

--*/
{
    SECURITY_INFORMATION    si
            = OWNER_SECURITY_INFORMATION |
            GROUP_SECURITY_INFORMATION |
            DACL_SECURITY_INFORMATION;
    BYTE                    abSecDesc[ SECURITY_DESC_DEFAULT_SIZE ];
    DWORD                   dwSecDescSize;
    PSECURITY_DESCRIPTOR    pAcl;

    if ( GetKernelObjectSecurity(
            pFile->QueryFileHandle(),
            si,
            (PSECURITY_DESCRIPTOR)abSecDesc,
            SECURITY_DESC_DEFAULT_SIZE,
            &dwSecDescSize ) )
    {
        if ( dwSecDescSize > SECURITY_DESC_DEFAULT_SIZE )
        {
            if ( !(pAcl = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED, dwSecDescSize )) )
            {
                return NULL;
            }
            if ( !GetKernelObjectSecurity(
                    pFile->QueryFileHandle(),
                    si,
                    pAcl,
                    dwSecDescSize,
                    &dwSecDescSize ) )
            {
                LocalFree( pAcl );

                return NULL;
            }
        }
        else
        {
            if ( dwSecDescSize = GetSecurityDescriptorLength(abSecDesc) )
            {
                if ( !(pAcl = (PSECURITY_DESCRIPTOR)LocalAlloc( LMEM_FIXED,
                        dwSecDescSize )) )
                {
                    return NULL;
                }
                memcpy( pAcl, abSecDesc, dwSecDescSize );
            }
            else
            {
                //
                // Security descriptor is empty : do not return ptr to security descriptor
                //

                pAcl = NULL;
            }
        }
    }
    else
    {
        pAcl = NULL;
    }

    return pAcl;
}



BOOL TsCreateETagFromHandle(
    IN      HANDLE          hFile,
    IN      PCHAR           ETag,
    IN      BOOL            *bWeakETag
    )
/*+++

    TsCreateETagFromHandle

    This routine takes a file handle as input, and creates an ETag in
    the supplied buffer for that file handle.

    Arguments:

    hFile           - File handle for which to create an ETag.
    ETag            - Where to store the ETag. This must be long
                        enough to hold the maximum length ETag.
    bWeakETag       - Set to TRUE if the newly created ETag is weak.

    Returns:

        TRUE if we create an ETag, FALSE otherwise.
---*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    BOOL                        bReturn;
    PUCHAR                      Temp;
    FILETIME                    ftNow;
    DWORD                 dwChangeNumber = ETagChangeNumber::GetChangeNumber();


    bReturn  = GetFileInformationByHandle(
                                    hFile,
                                    &FileInfo
                                    );

    if (!bReturn)
    {
        return FALSE;
    }

    FORMAT_ETAG(ETag, FileInfo.ftLastWriteTime, dwChangeNumber );

    ::GetSystemTimeAsFileTime(&ftNow);

    FILETIME iNow, iFileTime;

    iNow = ftNow;
    iFileTime = FileInfo.ftLastWriteTime;

    if ( (FILETIMEToUINT64(iNow) - FILETIMEToUINT64(iFileTime)) > STRONG_ETAG_DELTA )
    {
        *bWeakETag = FALSE;
    }
    else
    {
        *bWeakETag = TRUE;
    }

    return TRUE;
}



BOOL TsLastWriteTimeFromHandle(
    IN      HANDLE          hFile,
    IN      FILETIME        *tm
    )
/*+++

    TsLastWriteTimeFromHandle

    This routine takes a file handle as input, and returns the last write time
    for that handle.

    Arguments:

    hFile           - File handle for which to get the last write time.
    tm              - Where to return the last write time.

    Returns:

        TRUE if we succeed, FALSE otherwise.
---*/
{
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    BOOL                        bReturn;

    bReturn  = GetFileInformationByHandle(
                                    hFile,
                                    &FileInfo
                                    );

    if (!bReturn)
    {
        return FALSE;
    }

    *tm = FileInfo.ftLastWriteTime;

    return TRUE;
}


DWORD
CheckIfShortFileName(
    IN  CONST UCHAR * pszPath,
    IN  HANDLE        hImpersonation,
    OUT BOOL *        pfShort
    )
/*++
    Description:

        This function takes a suspected NT/Win95 short filename and checks if there's
        an equivalent long filename.  For example, c:\foobar\ABCDEF~1.ABC is the same
        as c:\foobar\abcdefghijklmnop.abc.

        NOTE: This function should be called unimpersonated - the FindFirstFile() must
        be called in the system context since most systems have traverse checking turned
        off - except for the UNC case where we must be impersonated to get network access.

    Arguments:

        pszPath - Path to check
        hImpersonation - Impersonation handle if this is a UNC path - can be NULL if not UNC
        pfShort - Set to TRUE if an equivalent long filename is found

    Returns:

        Win32 error on failure
--*/
{
    DWORD              err = NO_ERROR;
    WIN32_FIND_DATA    FindData;
    UCHAR *            psz;
    BOOL               fUNC;

    psz      = _mbschr( (UCHAR *) pszPath, '~' );
    *pfShort = FALSE;
    fUNC     = (*pszPath == '\\');

    //
    //  Loop for multiple tildas - watch for a # after the tilda
    //

    while ( psz++ )
    {
        if ( *psz >= '0' && *psz <= '9' )
        {
            UCHAR achTmp[MAX_PATH];
            UCHAR * pchEndSeg;
            UCHAR * pchBeginSeg;
            HANDLE  hFind;

            //
            //  Isolate the path up to the segment with the
            //  '~' and do the FindFirst with that path
            //

            pchEndSeg = _mbschr( psz, '\\' );

            if ( !pchEndSeg )
            {
                pchEndSeg = psz + _mbslen( psz );
            }

            //
            //  If the string is beyond MAX_PATH then we allow it through
            //

            if ( ((INT) (pchEndSeg - pszPath)) >= sizeof( achTmp ))
            {
                return NO_ERROR;
            }

            memcpy( achTmp, pszPath, (INT) (pchEndSeg - pszPath) );
            achTmp[pchEndSeg - pszPath] = '\0';

            if ( fUNC && hImpersonation )
            {
                if ( !ImpersonateLoggedOnUser( hImpersonation ))
                {
                    return GetLastError();
                }
            }

            hFind = FindFirstFile( (CHAR *) achTmp, &FindData );

            if ( fUNC && hImpersonation )
            {
                RevertToSelf();
            }

            if ( hFind == INVALID_HANDLE_VALUE )
            {
                err = GetLastError();

                DBGPRINTF(( DBG_CONTEXT,
                            "FindFirst failed!! - \"%s\", error %d\n",
                            achTmp,
                            GetLastError() ));

                //
                //  If the FindFirstFile() fails to find the file then return
                //  success - the path doesn't appear to be a valid path which
                //  is ok.
                //

                if ( err == ERROR_FILE_NOT_FOUND ||
                     err == ERROR_PATH_NOT_FOUND )
                {
                    return NO_ERROR;
                }

                return err;
            }

            DBG_REQUIRE( FindClose( hFind ));

            //
            //  Isolate the last segment of the string which should be
            //  the potential short name equivalency
            //

            pchBeginSeg = _mbsrchr( achTmp, '\\' );
            DBG_ASSERT( pchBeginSeg );
            pchBeginSeg++;

            //
            //  If the last segment doesn't match the long name then this is
            //  the short name version of the path
            //

            if ( _mbsicmp( (UCHAR *) FindData.cFileName, pchBeginSeg ))
            {
                *pfShort = TRUE;
                return NO_ERROR;
            }
        }

        psz = _mbschr( psz, '~' );
    }

    return err;
}

//
// filemisc.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\metacach.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

        metacach.cxx

   Abstract:
        This module contains the tsunami caching routines for metadata.

   Author:
        Henry Sanders    ( henrysa )     15-Oct-1996

--*/
//

#include <tsunami.hxx>
#include "TsunamiP.Hxx"
#pragma hdrstop
#include <dbgutil.h>
#include <issched.hxx>
#include <metacach.hxx>

extern TCHAR * FlipSlashes( TCHAR * pszPath );

//
// The number of buckets in our hash table.
//

#define METACACHE_TABLE_SIZE    127
#define METACACHE_ENTRY_SIGN    ((DWORD)'ECEM')
#define METACACHE_ENTRY_FREE    ((DWORD)'ECEf')


// time in minutes to keep entry in metachace after it was used last time
#define TIME_TO_KEEP_METACACHE_ENTRY    (5)

//
// Structure of a metacache table entry.
//

typedef struct _METACACHE_ENTRY {

    DWORD                   Signature;
    struct _METACACHE_ENTRY *pNext;
    DWORD                   dwDataSetNumber;
    DWORD                   dwServiceID;
    PVOID                   pMetaData;
    DWORD                   dwRefCount;
    DWORD                   dwLastUsedTime;
    PMDFREERTN              pFreeRoutine;
    BOOL                    bValid;

} METACACHE_ENTRY, *PMETACACHE_ENTRY;

//
// Structure of a hash table bucket.
//

typedef struct _METACACHE_BUCKET {

    PMETACACHE_ENTRY        pEntry;
    CRITICAL_SECTION        csCritSec;

} METACACHE_BUCKET;

METACACHE_BUCKET    MetaCacheTable[METACACHE_TABLE_SIZE];

DWORD   MetaCacheTimerCookie = 0;
DWORD   g_dwMetaCacheScavengeCnt = 1;
/************************************************************
 *    Functions
 ************************************************************/
dllexp
PVOID
TsFindMetaData(

    IN      DWORD           dwDataSetNumber,
    IN      DWORD           dwServiceID

    )
/*++

  Routine Description:

    This function takes a data set number and service ID, and tries to find
    a formatted chunk of metadata in the cache. If it does so, it returns a
    pointer to it, otherwise it returns NULL.

  Arguments

    dwDataSetNumber         - The data set number to be found.
    dwServiceID             - ID of calling service.
--*/
{
    DWORD               dwIndex;
    PMETACACHE_ENTRY    pCurrentEntry;

    dwIndex = dwDataSetNumber % METACACHE_TABLE_SIZE;

    //
    // This needes to be protected, we use a critical section per bucket.
    //
    EnterCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    pCurrentEntry = MetaCacheTable[dwIndex].pEntry;

    // Walk the chain on the bucket. If we find a match, return it.
    //
    while (pCurrentEntry != NULL )
    {
        PCOMMON_METADATA        pCMD;

        pCMD = (PCOMMON_METADATA)pCurrentEntry->pMetaData;

        pCMD->CheckSignature();
        ASSERT(pCMD->QueryCacheInfo() == pCurrentEntry);


        if (pCurrentEntry->dwDataSetNumber == dwDataSetNumber &&
            pCurrentEntry->dwServiceID == dwServiceID &&
            pCurrentEntry->bValid)
        {

            ASSERT( pCurrentEntry->Signature == METACACHE_ENTRY_SIGN );

            // Found a match. Increment the refcount and return a pointer
            // to the metadata.
            InterlockedIncrement((LONG *)&pCurrentEntry->dwRefCount);
            pCurrentEntry->dwLastUsedTime = g_dwMetaCacheScavengeCnt;

            LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

            return pCurrentEntry->pMetaData;
        }

        // Otherwise try the next one.
        pCurrentEntry = pCurrentEntry->pNext;
    }


    // Didn't find a match, so we'll return NULL.
    LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    return NULL;
}

dllexp
PVOID
TsAddMetaData(

    IN      PCOMMON_METADATA pMetaData,
    IN      PMDFREERTN      pFreeRoutine,
    IN      DWORD           dwDataSetNumber,
    IN      DWORD           dwServiceID
    )
/*++

  Routine Description:

    Add a chunk of formatted metadata to our cache.

  Arguments

    pMetaData               - MetaData to be added.
    dwDataSetNumber         - The data set number to be found.
    dwServiceID             - ID of calling service.

  Returns
    Pointer to metacache 'handle' to be used when freeing information.

--*/
{
    PMETACACHE_ENTRY        pNewEntry;
    DWORD                   dwIndex;

    pMetaData->CheckSignature();

    dwIndex = dwDataSetNumber % METACACHE_TABLE_SIZE;


    pNewEntry = (PMETACACHE_ENTRY)ALLOC(sizeof(METACACHE_ENTRY));

    if (pNewEntry == NULL)
    {
        // Couldn't add the entry. No big deal, just return.
        return NULL;
    }

    pNewEntry->Signature = METACACHE_ENTRY_SIGN;
    pNewEntry->dwDataSetNumber = dwDataSetNumber;
    pNewEntry->dwServiceID = dwServiceID;
    pNewEntry->pMetaData = pMetaData;
    pNewEntry->pFreeRoutine = pFreeRoutine;
    pNewEntry->dwRefCount = 1;
    pNewEntry->bValid = TRUE;
    pNewEntry->dwLastUsedTime = g_dwMetaCacheScavengeCnt;

    pMetaData->SetCacheInfo(pNewEntry);

    EnterCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    pNewEntry->pNext = MetaCacheTable[dwIndex].pEntry;

    MetaCacheTable[dwIndex].pEntry = pNewEntry;

    LeaveCriticalSection(&MetaCacheTable[dwIndex].csCritSec);

    return pNewEntry;

}

dllexp
VOID
TsFreeMetaData(

    IN      PVOID           pCacheEntry

    )
/*++

  Routine Description:

    Free a chunk of formatted metadata to the cache. What we really do here
    is decrement the ref count. If it goes to 0 and the cache element is
    marked deleted, we'll free it here.

  Arguments

    pMetaData               - MetaData to be freed.
--*/
{
    PMETACACHE_ENTRY        pEntry = (PMETACACHE_ENTRY)pCacheEntry;
    PCOMMON_METADATA        pCMD;


    ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

    pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

    pCMD->CheckSignature();

    ASSERT(pCMD->QueryCacheInfo() == pEntry);

    InterlockedDecrement((LONG *)&pEntry->dwRefCount);

}

dllexp
VOID
TsAddRefMetaData(

    IN      PVOID           pCacheEntry

    )
/*++

  Routine Description:

    Increment reference count to chunk of formatted metadata

  Arguments

    pMetaData               - MetaData to be AddRef'ed
--*/
{
    PMETACACHE_ENTRY        pEntry = (PMETACACHE_ENTRY)pCacheEntry;

    ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

    InterlockedIncrement((LONG *)&pEntry->dwRefCount);
}

dllexp
VOID
TsFlushMetaCache(
    DWORD       dwService,
    BOOL        bTerminating
    )
/*++

  Routine Description:

    Called when we need to flush all of our cached metainformation. We walk
    the table, and for each entry we check to see if it's in use. If it's not
    we'll free it, otherwise we'll mark it as deleted.

    If the passed in dwService ID is non-zero, then we'll only
    flush those entries that match the service. Also, if we're terminating,
    we'll do some additional checking, and also cancle any callbacks if we need
    to.

  Arguments

        dwService       - Service ID of entries to be flushed, 0 for all
                            services.
        bTerminating    - TRUE if the caller is terminating.


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PMETACACHE_ENTRY    pTrailer;
    PCOMMON_METADATA        pCMD;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pTrailer = CONTAINING_RECORD(&MetaCacheTable[i].pEntry,
                                        METACACHE_ENTRY, pNext);

        // Walk the chain on the bucket. For every entry, if it's not in
        // use, free it.
        //
        while (pTrailer->pNext != NULL )
        {
            pEntry = pTrailer->pNext;

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );

            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);

            if (dwService == 0 || dwService == pEntry->dwServiceID)
            {
                if (pEntry->dwRefCount == 0)
                {
                    // This entry is not in use.

                    // If whoever added it gave us a free routine, call it now.
                    if (pEntry->pFreeRoutine != NULL)
                    {
                        (*(pEntry->pFreeRoutine))(pEntry->pMetaData);
                    }

                    // Look at the next one.
                    pTrailer->pNext = pEntry->pNext;

                    pEntry->Signature = METACACHE_ENTRY_FREE;
                    FREE(pEntry);
                }
                else
                {
                    // In a debug build we'll assert here if we're terminating,
                    // since that shouldn't happen. In a free build we won't
                    // assert for that but we will NULL out the free routine to
                    // keep it from getting called, since presumably the owner is
                    // going away.

                    if (bTerminating)
                    {
                        DBGPRINTF(( DBG_CONTEXT,
                            "\n=========================================\n"
                            "Leftover item in metacache - %8p, bValid = %s\n"
                            "\t dwServiceID    = %8d  pMetaData    = %8p\n"
                            "\t dwRefCount     = %8d  pFreeRoutine = %8p\n"
                            ,
                            pEntry,
                            (pEntry->bValid ? "TRUE" : "FALSE"),
                            pEntry->dwServiceID,
                            pEntry->pMetaData,
                            pEntry->dwRefCount,
                            pEntry->pFreeRoutine ));

                        pEntry->pFreeRoutine = NULL;
                    }


                    pEntry->bValid = FALSE;
                    pTrailer = pEntry;
                }
            }
            else
            {
                pTrailer = pEntry;
            }
        }


        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
}

dllexp
VOID
TsReferenceMetaData(
    IN      PVOID           pEntry
    )
/*++

  Routine Description:

    Called when we need to reference a metadata cache entry. The caller
    must have already referenced it once.

  Arguments

    pEntry          - Entry to be referenced.


--*/
{
    PMETACACHE_ENTRY        pCacheEntry = (PMETACACHE_ENTRY)pEntry;
    PCOMMON_METADATA        pCMD;


    ASSERT( pCacheEntry->Signature == METACACHE_ENTRY_SIGN );

    pCMD = (PCOMMON_METADATA)pCacheEntry->pMetaData;

    pCMD->CheckSignature();

    ASSERT(pCMD->QueryCacheInfo() == pCacheEntry);

    InterlockedIncrement((LONG *)&pCacheEntry->dwRefCount);

}

VOID
WINAPI
MetaCacheScavenger(
    PVOID       pContext
    )
/*++

  Routine Description:

    Called periodically to time out metacache information. We scan the table;
    if we find an object that's not in use we free it.

  Arguments

    None.


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PMETACACHE_ENTRY    pTrailer;
    PCOMMON_METADATA        pCMD;


    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        if (MetaCacheTable[i].pEntry == NULL)
        {
            continue;
        }

        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pTrailer = CONTAINING_RECORD(&MetaCacheTable[i].pEntry,
                                        METACACHE_ENTRY, pNext);


        // Walk the chain on the bucket. For every entry, if it's not in
        // use, free it.
        //
        while (pTrailer->pNext != NULL )
        {
            pEntry = pTrailer->pNext;

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );
            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);


            if (pEntry->dwRefCount == 0 &&
                (pEntry->dwLastUsedTime + TIME_TO_KEEP_METACACHE_ENTRY < g_dwMetaCacheScavengeCnt))
            {

                // This entry is not in use.

                // If whoever added it gave us a free routine, call it now.
                if (pEntry->pFreeRoutine != NULL)
                {
                    (*(pEntry->pFreeRoutine))(pEntry->pMetaData);
                }

                // Free the entry and look at the next one.
                pTrailer->pNext = pEntry->pNext;

                pEntry->Signature = METACACHE_ENTRY_FREE;

                FREE(pEntry);
            }
            else
            {
                pTrailer = pEntry;
            }
        }

        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
    InterlockedIncrement ((long *)&g_dwMetaCacheScavengeCnt);
}


dllexp
VOID
_TsValidateMetaCache(
    VOID
    )
/*++


--*/
{
    UINT                i;
    PMETACACHE_ENTRY    pEntry;
    PCOMMON_METADATA        pCMD;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        if (MetaCacheTable[i].pEntry == NULL)
        {
            continue;
        }

        EnterCriticalSection(&MetaCacheTable[i].csCritSec);

        pEntry = MetaCacheTable[i].pEntry;

        while (pEntry != NULL )
        {

            ASSERT( pEntry->Signature == METACACHE_ENTRY_SIGN );
            pCMD = (PCOMMON_METADATA)pEntry->pMetaData;

            pCMD->CheckSignature();
            ASSERT(pCMD->QueryCacheInfo() == pEntry);

            pEntry = pEntry->pNext;
        }

        LeaveCriticalSection(&MetaCacheTable[i].csCritSec);
    }
}


BOOL
MetaCache_Initialize(
    VOID
    )
/*++

  Routine Description:

    Initialize our metacache code.

  Arguments

    Nothing.

--*/
{
    UINT        i;
    UINT        j;
    BOOL        fRet;

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        fRet = INITIALIZE_CRITICAL_SECTION(&MetaCacheTable[i].csCritSec);
        if ( !fRet )
        {
            //
            // Cleanup all inited critical sections
            //

            if ( i > 0 )
            {
                for ( j = 0; j < i - 1; j++ )
                {
                    DeleteCriticalSection(&MetaCacheTable[i].csCritSec);
                }
            }

            return FALSE;
        }

        MetaCacheTable[i].pEntry = NULL;
    }

    MetaCacheTimerCookie = ScheduleWorkItem(
                                       MetaCacheScavenger,
                                       NULL,
                                       60 * 1000,  // 1 minute
                                       TRUE );     // Periodic

    if (!MetaCacheTimerCookie)
    {
        return FALSE;
    }

    return TRUE;
}

BOOL
MetaCache_Terminate(
    VOID
    )
/*++

  Routine Description:

    Terminate our metacache code.

  Arguments

    Nothing.

--*/
{
    UINT i;

    if (MetaCacheTimerCookie != 0)
    {
        RemoveWorkItem(MetaCacheTimerCookie);
        MetaCacheTimerCookie = 0;
    }

    TsFlushMetaCache(0, TRUE);

    for (i = 0; i < METACACHE_TABLE_SIZE; i++)
    {
        DeleteCriticalSection(&MetaCacheTable[i].csCritSec);
    }

    return TRUE;
}




COMMON_METADATA::COMMON_METADATA(VOID)
: m_IpDnsAccessCheckSize( 0 ),
  m_IpDnsAccessCheckPtr ( NULL ),
  m_IpDnsAccessCheckTag ( 0 ),
  m_fDontLog            ( FALSE ),
  m_dwAccessPerm        ( MD_ACCESS_READ ),
  m_dwSslAccessPerm     ( 0 ),
  m_pAcl                ( NULL ),
  m_dwAclTag            ( 0 ),
  m_dwVrLevel           ( 0 ),
  m_dwVrLen             ( 0 ),
  m_hVrToken            ( NULL ),
  m_fVrPassThrough      ( FALSE ),
  m_dwVrError           ( 0 ),
  m_Signature           ( CMD_SIG ),
  m_fDoCache            ( TRUE )
{
    //
    //  Hmmm, since most of these values aren't getting initialized, if
    //  somebody went and deleted all the metadata items from the tree, then
    //  bad things could happen.  We should initialize with defaults things
    //  that might cause us trouble us
    //

} // COMMON_METADATA::COMMON_METADATA()


COMMON_METADATA::~COMMON_METADATA(VOID)
{
    CheckSignature();

    if ( m_IpDnsAccessCheckTag )
        {
            FreeMdTag( m_IpDnsAccessCheckTag );
            m_IpDnsAccessCheckTag = 0;
        }
    else if ( m_IpDnsAccessCheckPtr != NULL )
        {
            LocalFree( m_IpDnsAccessCheckPtr );
            m_IpDnsAccessCheckPtr = NULL;
        }

    if ( m_dwAclTag )
        {
            FreeMdTag( m_dwAclTag );
            m_dwAclTag = 0;
        }

    if ( m_hVrToken )
        {
            TsDeleteUserToken( m_hVrToken );
            m_hVrToken = NULL;
        }

} // COMMON_METADATA::~COMMON_METADATA()


VOID
COMMON_METADATA::FreeMdTag(
    DWORD dwTag
    )
/*++

Routine Description:

    Free a metadata object accessed by reference

Arguments:

    dwTag - tag of metadata object reference

Returns:

    Nothing

--*/
{
    MB  mb( (IMDCOM*) m_pInstance->m_Service->QueryMDObject() );

    CheckSignature();
    mb.ReleaseReferenceData( dwTag );
}


//
//  Private constants.
//

#define DEFAULT_MD_RECORDS          40
#define DEFAULT_RECORD_SIZE         50

# define DEF_MD_REC_SIZE   ((1 + DEFAULT_MD_RECORDS) * \
                            (sizeof(METADATA_RECORD) + DEFAULT_RECORD_SIZE))

#define RMD_ASSERT(x) if (!(x)) {DBG_ASSERT(FALSE); return FALSE; }


BOOL
COMMON_METADATA::ReadMetaData(
    PIIS_SERVER_INSTANCE    pInstance,
    MB *                    pmb,
    LPSTR                   pszURL,
    PMETADATA_ERROR_INFO    pMDError
    )
{
    METADATA_GETALL_INTERNAL_RECORD *pMDRecord;
    DWORD               dwNumMDRecords;
    BYTE                tmpBuffer[ DEF_MD_REC_SIZE];
    BUFFER              TempBuff( tmpBuffer, DEF_MD_REC_SIZE);
    DWORD               i;
    DWORD               dwDataSetNumber;
    INT                 ch;
    LPSTR               pszInVr;
    LPSTR               pszMinInVr;
    DWORD               dwNeed;
    DWORD               dwL;
    DWORD               dwVRLen;
    LPSTR               pszVrUserName;
    LPSTR               pszVrPassword;
    BYTE                tmpPrivateBuffer[ 20 ];
    BUFFER              PrivateBuffer( tmpPrivateBuffer, 20 );
    DWORD               dwPrivateBufferUsed;



    CheckSignature();
    TsValidateMetaCache();

    m_pInstance = pInstance;

    DBG_ASSERT( TempBuff.QuerySize() >=
                (DEFAULT_MD_RECORDS *
                 (sizeof(METADATA_RECORD) + DEFAULT_RECORD_SIZE))
                );

    if ( !pmb->Open( pInstance->QueryMDVRPath() ))
    {
        return FALSE;
    }

    if ( !pmb->GetAll( pszURL,
                     METADATA_INHERIT | METADATA_PARTIAL_PATH | METADATA_REFERENCE,
                     IIS_MD_UT_FILE,
                     &TempBuff,
                     &dwNumMDRecords,
                     &dwDataSetNumber ))
    {
        return FALSE;
    }

    pMDRecord = (METADATA_GETALL_INTERNAL_RECORD *)TempBuff.QueryPtr();
    i = 0;

    //
    // Check from where we got VR_PATH
    //

    pszMinInVr = pszURL ;
    if ( *pszURL )
    {
        for ( pszInVr = pszMinInVr + strlen(pszMinInVr) ;; )
        {
            ch = *pszInVr;
            *pszInVr = '\0';
            dwNeed = 0;
            if ( !pmb->GetString( pszURL, MD_VR_PATH, IIS_MD_UT_FILE, NULL, &dwNeed, 0 ) &&
                 GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                *pszInVr = (CHAR)ch;
                // VR_PATH was defined at this level !

                break;
            }
            *pszInVr = (CHAR)ch;

            if ( ch )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr = CharPrev( pszMinInVr, pszInVr );
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }

            // scan for previous delimiter

            while ( *pszInVr != '/' && *pszInVr != '\\' )
            {
                if ( pszInVr > pszMinInVr )
                {
                    pszInVr = CharPrev( pszMinInVr, pszInVr );
                }
                else
                {
                    //
                    // VR_PATH was defined above Instance vroot
                    // or not at all. If defined above, then the reference
                    // path is empty, so we can claim we found it.
                    // if not defined, then this will be catch later.
                    //

                    break;
                }
            }
        }

        dwVRLen = DIFF(pszInVr - pszMinInVr);
    }
    else
    {
        dwVRLen = 0;
        pszInVr = pszMinInVr;
    }

    // Close this now to minimize lock contention.
    DBG_REQUIRE(pmb->Close());

    for ( dwL = 0 ; pszMinInVr < pszInVr - 1 ; pszMinInVr = CharNext(pszMinInVr) )
    {
        if ( *pszMinInVr == '/' || *pszMinInVr == '\\' )
        {
            ++dwL;
        }
    }

    // Now walk through the array of returned metadata objects and format
    // each one into our predigested form.

    SetVrLevelAndLen( dwL, dwVRLen );
    pszVrPassword = NULL;
    pszVrUserName = NULL;
    dwPrivateBufferUsed = 0;
    pMDError->IsValid = FALSE;

    for ( ; i < dwNumMDRecords; i++, pMDRecord++ ) {

        PVOID       pDataPointer;
        CHAR        *pszMimePtr;
        CHAR        *pszTemp;
        DWORD       dwTemp;


        pDataPointer = (PVOID) ((PCHAR)TempBuff.QueryPtr() +
                                    pMDRecord->dwMDDataOffset);

        switch ( pMDRecord->dwMDIdentifier ) {

        case MD_IP_SEC:
            RMD_ASSERT( pMDRecord->dwMDDataType == BINARY_METADATA );

            if ( pMDRecord->dwMDDataLen )
            {
                if ( !SetIpDnsAccessCheck( pMDRecord->dwMDDataTag ?
                                                pMDRecord->pbMDData :
                                                pDataPointer,
                                           pMDRecord->dwMDDataLen,
                                           pMDRecord->dwMDDataTag ) )
                {
                    goto FreeRefs;
                }
            }
            break;

        case MD_ACCESS_PERM:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetAccessPerms(*(UNALIGNED DWORD*) pDataPointer);
            break;

        case MD_SSL_ACCESS_PERM:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetSslAccessPerms( *((UNALIGNED DWORD *) pDataPointer) );
            break;

        case MD_DONT_LOG:
            DBG_ASSERT( pMDRecord->dwMDDataTag == NULL );
            DBG_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetDontLogFlag( *((UNALIGNED DWORD *) pDataPointer ));
            break;

        case MD_VR_PATH:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            if (!QueryVrPath()->Copy((const CHAR *)pDataPointer))
            {
                goto FreeRefs;
            }
            break;

                case MD_APP_ROOT:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            if (!QueryAppPath()->Copy((const CHAR *)pDataPointer))
            {
                goto FreeRefs;
            }
            break;

        case MD_VR_USERNAME:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            pszVrUserName = (LPSTR)pDataPointer;
            break;

        case MD_VR_PASSWORD:
            RMD_ASSERT( pMDRecord->dwMDDataType == STRING_METADATA );
            pszVrPassword = (LPSTR)pDataPointer;
            break;

        case MD_VR_PASSTHROUGH:
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetVrPassThrough( !!*((UNALIGNED DWORD *) pDataPointer) );
            break;

        case MD_VR_ACL:
            DBG_ASSERT( pMDRecord->dwMDDataTag );
            RMD_ASSERT( pMDRecord->dwMDDataType == BINARY_METADATA );
            if ( pMDRecord->dwMDDataTag )
            {
                SetAcl( pMDRecord->pbMDData,
                        pMDRecord->dwMDDataLen,
                        pMDRecord->dwMDDataTag );
            }
            break;

        case MD_VR_NO_CACHE:
            RMD_ASSERT( pMDRecord->dwMDDataType == DWORD_METADATA );
            // 64bit alignment fix
            SetDoCache( !*(UNALIGNED DWORD *) pDataPointer );
            break;

        default:
            if ( !HandlePrivateProperty( pszURL, pInstance, pMDRecord, pDataPointer, &PrivateBuffer, &dwPrivateBufferUsed, pMDError ) )
            {
                goto FreeRefs;
            }
            CheckSignature();
            break;
        }
    }


    if (!FinishPrivateProperties(&PrivateBuffer, dwPrivateBufferUsed, TRUE))
    {
        goto FreeRefs;
    }

    if ( QueryVrPath()->IsEmpty() &&
         !(QueryAccessPerms() & VROOT_MASK_NO_PHYSICAL_DIR) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                    "[ReadMetaData] Virtual Dir Path mapping not found\n" ));
        SetLastError( ERROR_FILE_NOT_FOUND );
        return FALSE;
    }

    //
    // If this is an UNC share, logon using associated credentials
    // keep a reference to this access token in the cache
    //

    if ( QueryVrPath()->QueryStr()[0] == '\\' &&
         QueryVrPath()->QueryStr()[1] == '\\' )
    {
        if ( pszVrUserName != NULL && pszVrPassword != NULL &&
             pszVrUserName[0] )
        {

            if ( !SetVrUserNameAndPassword( pInstance, pszVrUserName, pszVrPassword ) )
            {
                return FALSE;
            }
        }
    }

    CheckSignature();
    TsValidateMetaCache();
    return TRUE;

FreeRefs:

    FinishPrivateProperties(&PrivateBuffer, dwPrivateBufferUsed, FALSE);
    CheckSignature();
    TsValidateMetaCache();

    for ( ; i < dwNumMDRecords; i++, pMDRecord++ )
    {
        if ( pMDRecord->dwMDDataTag )
        {
            pmb->ReleaseReferenceData( pMDRecord->dwMDDataTag );
        }
    }

    return FALSE;
}


BOOL
COMMON_METADATA::SetVrUserNameAndPassword(
    PIIS_SERVER_INSTANCE    pInstance,
    LPSTR                   pszUserName,
    LPSTR                   pszPassword
    )
/*++
    Description:

        Set the account used to access the virtual root
        associated with this metadata

    Arguments:
        pInstance - current instance
        pszUserName - User name
        pszPassword - password

    Returns:
        TRUE if success, otherwise FALSE

--*/
{
    LARGE_INTEGER       liPwdExpiry;
    BOOL                fHaveExp;
    BOOL                fAsGuest;
    BOOL                fAsAnonymous;
    TCP_AUTHENT_INFO    TAI;

    CheckSignature();
    TAI.fDontUseAnonSubAuth = TRUE;

    m_hVrToken = TsLogonUser( pszUserName,
                              pszPassword,
                              &fAsGuest,
                              &fAsAnonymous,
                              pInstance,
                              &TAI,
                              NULL,
                              &liPwdExpiry,
                              &fHaveExp );

    //
    // If fail to logo, we remember the error and return SUCCESS
    // Caller will have to check metadata after creating it to check
    // the error code. Necessary because metadata needs to be set in HTTP_REQUEST
    // to send back proper auth status even if virtual root init failed.
    //

    if ( !m_hVrToken )
    {
        m_dwVrError = GetLastError();
    }

    return TRUE;
}


BOOL
COMMON_METADATA::BuildApplPhysicalPath(
  MB *            pmb,
  STR *           pstrApplPhysicalPath
  ) const
/*++
  Description:
    This function builds the physical path for the ApplPath of the current
    METADATA object. The ApplPath is a metbase path of the form
     /LM/W3Svc/<instance>/app-root-path
    This function uses the VR_PATH & portion of the APPL_PATH to
      construct the appropriate physical path.

  Arguments:
    pmb                  - pointer to MB object (Metabase pointer)
    pstrApplPhysicalPath - pointer to STR object that will contain
                           the physical path on return.


  Returns:
    TRUE on success and FALSE if there are errors.
    Use GetLastError() to get the appropriate error code.
--*/
{
    BOOL    fRet;
        INT     cOffSet = 0;

    CheckSignature();
    DBG_ASSERT(NULL != pmb && NULL != pstrApplPhysicalPath);

    //    m_strAppPath is in the format of /LM/W3SVC/X/ROOT/AppRoot.....
        //    Now, the next code segment split this format into
        //    strInstanceMDPath = /LM/W3SVC/X/ROOT/
        //    strVrPath = /AppRoot....
    STR      strInstanceMDPath = STR(m_strAppPath);
    LPSTR    pszVrPath = strInstanceMDPath.QueryStr();
        INT      VrLevel = 0;

    while(*pszVrPath != NULL)
        {
        if ('/' == *pszVrPath)
                {
                        VrLevel++;
                        if (5 == VrLevel)
                        {
                                break;
                        }
                }
                pszVrPath++;
    }

        STR strVrPath = STR(pszVrPath);
    // Case: /LM/W3SVC/1/ROOT
        if (4 == VrLevel)
        {
            strVrPath.Append('/');
                // OffSet needs to minus 1 because strInstanceMDPath does not have
                // ending '/'
                cOffSet = strInstanceMDPath.QueryCCH()-1;
        }
        else if ( 5 == VrLevel)
        {
        // Make a copy of VRPath
            // Caculate the cOffSet of /LM/W3SVC/X/Root/
        // Set the strInstanceMDPath
        cOffSet = DIFF(pszVrPath-strInstanceMDPath.QueryStr());
        strInstanceMDPath.SetLen(cOffSet);
        }
        else
        {
            // Can not resolve Application Physical Path.
                DBG_ASSERT(FALSE);
                pstrApplPhysicalPath->SetLen(0);
        return FALSE;
        }

        // Open the metabase key from /LM/W3SVC/X/ROOT/
    fRet = pmb->Open(strInstanceMDPath.QueryStr());
    if (TRUE == fRet)
    {
            // Get VR Path first. (Note, this is not the final VRpath).
        fRet = pmb->GetStr(strVrPath.QueryStr(),
                        MD_VR_PATH,
                        IIS_MD_UT_FILE,
                        pstrApplPhysicalPath,
                        METADATA_INHERIT,
                        NULL);

        if (TRUE == fRet)
        {
            BOOL    fFound = FALSE;
            DWORD   dwBufferSizeNeeded;
            LPSTR   pszTempMDPath = strVrPath.QueryStr();
            LPSTR   pszTemp = pszTempMDPath + strVrPath.QueryCCH() - 1;
            BOOL    fNoMoreVR = FALSE;  // used to break out infinite loop if there is no VR_PATH
                                        // defined at /LM/W3SVC/X/ROOT

            // Find where we get the VR path
            do
            {
                            dwBufferSizeNeeded = 0;
                if ( !pmb->GetString(strVrPath.QueryStr(),
                                    MD_VR_PATH,
                                    IIS_MD_UT_FILE,
                                                                        NULL,
                                    &dwBufferSizeNeeded,
                                    0
                                    )
                     && GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    fFound = TRUE;
                                        // cOffSet is the strlen(closest Metabase path that defined
                                        // a MDVrPath property).
                                        // For Example:
                                        // /LM/W3SVC/1/ROOT/VR1/VR2/VR3
                                        // VR2 defines MDVrPath. cOffSet is strlen(/VR2)
                                        // so, based on cOffSet, we can find VR3 later.
                                        cOffSet += strVrPath.QueryCCH();
                }
                 else
                {
                    // '/' is not a DBCS trailing byte.
                                        // going backwords in /VR1/VR2/VR3/.../VRn and search '/'
                                        // and shrink one VR Level
                    pszTemp = strrchr(pszTempMDPath, '/');
                    strVrPath.SetLen(DIFF(pszTemp-pszTempMDPath));
                    // if this is TRUE, then, strVrPath is empty now, and there is no VR_PATH
                    // defined.
                    if (fNoMoreVR)
                    {
                        break;
                    }

                    if (0 == strVrPath.QueryCCH())
                    {
                        fNoMoreVR = TRUE;
                    }
                }
            } while (!fFound);

            pmb->Close();
                    if (!fFound && 0 == strVrPath.QueryCCH())
                        {
                            DBG_ASSERT(FALSE);
                            pstrApplPhysicalPath->SetLen(0);
                            return FALSE;
                        }
            pstrApplPhysicalPath->Append(m_strAppPath.QueryStr()+cOffSet);
            if (pstrApplPhysicalPath->QueryCCH())
                {
                CHAR ch;

                ch = *CharPrev(pstrApplPhysicalPath->QueryStr(),
                               pstrApplPhysicalPath->QueryStr()+pstrApplPhysicalPath->QueryCCH());

                if (ch != '\\' && ch != '/')
                    {
                    pstrApplPhysicalPath->Append("\\");
                    }
                }

            FlipSlashes(pstrApplPhysicalPath->QueryStr());
        }
        else
        {
            pmb->Close();
        }
    }

        return fRet;
} // COMMON_METADATA::BuildApplPhysicalPath()



BOOL
COMMON_METADATA::BuildPhysicalPath(
    LPSTR           pszURL,
    STR *           pstrPhysicalPath
    )
{
    return BuildPhysicalPathWithAltRoot( pszURL, pstrPhysicalPath, NULL );
}


BOOL
COMMON_METADATA::BuildPhysicalPathWithAltRoot(
    LPSTR           pszURL,
    STR *           pstrPhysicalPath,
    PCSTR           pstrAltRoot
    )
/*++
    Description:

        Construct a physical path of the following components:
        - the virtual root mapping
        - an alternate root (if provided)
        - the significant part of the URI

    Arguments:
        pszURL           - The URL to be converted
        pstrPhysicalPath - the resulting physical path
        pstrAltRoot      - the alternat root

    Returns:
        TRUE if success, otherwise FALSE

--*/
{
    LPSTR               pszInVr;
    DWORD               dwL;
    INT                 ch;


    CheckSignature();
    TsValidateMetaCache();

    //
    // Build physical path from VR_PATH & portion of URI not used to define VR_PATH
    //


    //
    // skip the URI components used to locate the virtual root
    //

    pszInVr = pszURL ;
    dwL = QueryVrLevel();
    while ( dwL-- )
    {
        if ( *pszInVr )
        {
            DBG_ASSERT( *pszInVr == '/' || *pszInVr == '\\' );

            ++pszInVr;

            while ( (ch = *pszInVr) && ch != '/' && ch !='\\' )
            {
                pszInVr = CharNext( pszInVr );
            }
        }
    }

    DBG_ASSERT( dwL == (DWORD)-1 );

    if ( !pstrPhysicalPath->Copy( m_strVrPath ) )
    {
        return FALSE;
    }

    //
    // Add the alternate root
    //

    if ( pstrAltRoot )
    {
        if ( pstrPhysicalPath->QueryCCH() )
        {
            //
            // ensure there is one and only one separator
            //

            ch = *CharPrev(pstrPhysicalPath->QueryStr(), pstrPhysicalPath->QueryStr() +
                                                         pstrPhysicalPath->QueryCCH());

            if ( (ch != '/') && (ch != '\\') &&
                 (*pstrAltRoot != '/') && (*pstrAltRoot != '\\') )
            {
                if ( !pstrPhysicalPath->Append( "\\" ) )
                {
                    return FALSE;
                }
            } else if ( (ch == '/' || ch == '\\') &&
                        (*pstrAltRoot == '/' || *pstrAltRoot == '\\') )
            {
                ++pstrAltRoot;
            }
        }

        if ( !pstrPhysicalPath->Append( pstrAltRoot ) )
        {
            return FALSE;
        }
    }

    //
    // Add a path delimiter char between virtual root mount point & significant part of URI
    //

    if ( pstrPhysicalPath->QueryCCH() )
    {
        ch = *CharPrev(pstrPhysicalPath->QueryStr(), pstrPhysicalPath->QueryStr() +
                                                     pstrPhysicalPath->QueryCCH());
        if ( (ch == '/' || ch == '\\') && *pszInVr )
        {
            ++pszInVr;
        }
    }

    if ( !pstrPhysicalPath->Append( pszInVr ) )
    {
        return FALSE;
    }

    //
    // insure physical path last char uses standard directory delimiter
    //

    FlipSlashes( pstrPhysicalPath->QueryStr() );

    CheckSignature();
    TsValidateMetaCache();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\tlcach.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    tlcach.h

    This module declares the private interface to the two level cache

    FILE HISTORY:
        BAlam           10-31-98        Initial Revision
*/

#ifndef _TLCACH_H_
#define _TLCACH_H_

//
// Default interval between adjusting the memory cache max size
//

#define DEFAULT_ADJUSTMENT_TIME         60000

DWORD
InitializeTwoLevelCache( 
    IN DWORDLONG                cbMemoryCacheSize
);

DWORD
ReadFileIntoMemoryCache( 
    IN HANDLE                   hFile,
    IN DWORD                    cbFile,
    OUT DWORD *                 pcbRequired,
    OUT VOID **                 ppvBuffer
);

DWORD
ReleaseFromMemoryCache(
    IN VOID *                   pvBuffer,
    IN DWORD                    cbBuffer
);

DWORD
TerminateTwoLevelCache(
    VOID
);

DWORD
DumpMemoryCacheToHtml(
    IN CHAR *                   pszBuffer,
    IN OUT DWORD *              pcbBuffer
);

VOID
QueryMemoryCacheStatistics(
    IN INETA_CACHE_STATISTICS * pCacheCtrs,
    IN BOOL                     fClearAll
);


#if defined(LOOKASIDE)

class CLookAside
{
public:
    CLookAside(
        ALLOC_CACHE_CONFIGURATION* paacc,
        SIZE_T                     caacc);
    ~CLookAside();

    LPVOID
    Alloc(
        IN DWORD cbSize);

    BOOL
    Free(
        IN LPVOID pv,
        IN DWORD cbSize);

protected:
    enum {
        HEAP_PREFIX = 8,
        HEAP_SUFFIX = 0,
        ACACHE_OVERHEAD = sizeof(DWORD),
        SIGNATURE   = 'ALsT',
        SIGNATURE_X = 'XLsT',
    };

    int
    _FindAllocator(
        IN DWORD cbSize);

    DWORD                       m_dwSignature;
    ALLOC_CACHE_HANDLER**       m_apach;    // array of acaches
    ALLOC_CACHE_CONFIGURATION*  m_aacc;     // parallel array of config data
    SIZE_T                      m_cach;     // number of acaches
    SIZE_T                      m_nMinSize;
    SIZE_T                      m_nMaxSize;
};

#endif // LOOKASIDE

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\tsmemp.cxx ===
#include "TsunamiP.Hxx"
#pragma hdrstop

#if DBG

PVOID DbgAllocateHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN ULONG Size
)
{
    PVOID pv;

    ASSERT( Flags == 0 );

    pv= IisCalloc( Size + sizeof( PCHAR ) + sizeof( PCHAR ));

    if ( pv )
    {
        *((PCHAR *)pv)=File;
        pv= (( PCHAR *)pv)+1;

        *((int *)pv)=Line;
        pv= (( PCHAR *)pv)+1;
    }

    return( pv );
}

PVOID DbgReAllocateHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN PVOID pvOld,
    IN ULONG Size
)
{
    PVOID pv;

    ASSERT( Flags == 0 );

    pvOld = (PVOID)( ((PCHAR)pvOld) - (sizeof( PCHAR ) + sizeof( PCHAR )) );

    pv=IisReAlloc( pvOld, Size + sizeof( PCHAR ) + sizeof( PCHAR ) );

    if ( pv )
    {
        pv = (PVOID)( ((PCHAR)pv) + sizeof( PCHAR ) + sizeof( PCHAR ) );
    }

    return( pv );
}

BOOL DbgFreeHeap
(
    IN PCHAR File,
    IN int   Line,
    IN ULONG Flags,
    IN PVOID pvOld
)
{
    ASSERT( Flags == 0 );

    pvOld = (PVOID)( ((PCHAR)pvOld) - (sizeof( PCHAR ) + sizeof( PCHAR )) );

    return IisFree( pvOld );
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\tlcach.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    tlcach.cxx

    This module implements the private interface to the two-level cache.  This 
    cache is used to either cache the contents of a file or to copy the
    file and cache the handle to it

    FILE HISTORY:
        BAlam       10-31-1998      Created
*/

#include "TsunamiP.Hxx"
#pragma hdrstop

// #define LOCAL_ALLOC 1
#define PRIVATE_HEAP 1
// #define VIRTUAL_ALLOC 1
// #define LOOKASIDE 1

#include "issched.hxx"
#include "tlcach.h"

//
// Globals
//

// Memory Cache size statistics

DWORDLONG                   g_cbMaxMemCacheSize;
DWORDLONG                   g_cbMemCacheSize;
DWORDLONG                   g_cbMaxMemCacheUsed;
DWORD                       g_cMemCacheElements;
DWORD                       g_cMaxMemCacheElementsUsed;

// Cache utility
                            
CRITICAL_SECTION            g_csMemCache;
DWORD                       g_dwMemCacheSizeCookie;
DWORD                       g_cmsecAdjustmentTime = DEFAULT_ADJUSTMENT_TIME;
CHAR                        g_achTempPath[ MAX_PATH + 1 ];



#if defined(LOCAL_ALLOC)

const char                  g_szTsunamiAllocator[] = "LocalAlloc";

#elif defined(PRIVATE_HEAP)

const char                  g_szTsunamiAllocator[] = "PrivateHeap";

HANDLE                      g_hMemCacheHeap = NULL;

#elif defined(VIRTUAL_ALLOC)

const char                  g_szTsunamiAllocator[] = "VirtualAlloc";

#elif defined(LOOKASIDE)

const char                  g_szTsunamiAllocator[] = "LookAside";

enum {
    ENORMOUS = 300,
    MANY     = 200,
    LOTS     = 100,
    SOME     = 50,
    FEW      = 20,
    MINIMAL  = 4,

    KB = 1024,
};

ALLOC_CACHE_CONFIGURATION g_aacc[] = {
    { 1, SOME,          128},
    { 1, SOME,          256},
    { 1, SOME,          512},
    { 1, LOTS,          768},
    { 1, LOTS,       1 * KB},
    { 1, ENORMOUS,   2 * KB},
    { 1, ENORMOUS,   3 * KB},
    { 1, ENORMOUS,   4 * KB},
    { 1, MANY,       5 * KB},
    { 1, MANY,       6 * KB},
    { 1, MANY,       7 * KB},
    { 1, MANY,       8 * KB},
    { 1, LOTS,       9 * KB},
    { 1, LOTS,      10 * KB},
    { 1, LOTS,      11 * KB},
    { 1, LOTS,      12 * KB},
    { 1, LOTS,      14 * KB},
    { 1, SOME,      16 * KB},
    { 1, SOME,      20 * KB},
    { 1, SOME,      24 * KB},
    { 1, SOME,      28 * KB},
    { 1, SOME,      32 * KB},
    { 1, FEW,       36 * KB},
    { 1, FEW,       40 * KB},
    { 1, FEW,       44 * KB},
    { 1, FEW,       48 * KB},
    { 1, FEW,       56 * KB},
    { 1, MINIMAL,   64 * KB},
    { 1, MINIMAL,   80 * KB},
    { 1, MINIMAL,   96 * KB},
    { 1, MINIMAL,  128 * KB},
    { 1, MINIMAL,  160 * KB},
    { 1, MINIMAL,  192 * KB},
    { 1, MINIMAL,  256 * KB},
};

CLookAside* g_laMemCache = NULL;

// paacc must be sorted in increasing sizes, it is sorted right now from
// where it is called

CLookAside::CLookAside(
    ALLOC_CACHE_CONFIGURATION* paacc,
    SIZE_T                     caacc)
    : m_dwSignature(SIGNATURE),
      m_apach(NULL),
      m_aacc(NULL),
      m_cach(0),
      m_nMinSize(0),
      m_nMaxSize(0)
{
    ALLOC_CACHE_HANDLER** apach = new ALLOC_CACHE_HANDLER* [caacc];
    if (apach == NULL)
        return;

    ALLOC_CACHE_CONFIGURATION* paacc2 = new ALLOC_CACHE_CONFIGURATION [caacc];
    if (paacc2 == NULL)
        return;
    
    for (SIZE_T i = 0;  i < caacc;  ++i)
    {
        ALLOC_CACHE_CONFIGURATION acc = paacc[i];
        acc.cbSize -= HEAP_PREFIX + HEAP_SUFFIX + ACACHE_OVERHEAD;
        paacc2[i] = acc;

        if (i == 0)
            m_nMinSize = acc.cbSize;
        else if (i == caacc-1)
            m_nMaxSize = acc.cbSize;

        char szName[40];
        sprintf(szName, "TsLookAside-%d", acc.cbSize);
        
        apach[i] = new ALLOC_CACHE_HANDLER(szName, &acc);
        bool fInOrder = (i == 0  ||  paacc2[i].cbSize > paacc2[i-1].cbSize);

        if (!fInOrder)
        {
            DBGPRINTF((DBG_CONTEXT, "CLookAside: config array out of order\n"));
        }

        if (apach[i] == NULL  ||  !fInOrder)
        {
            for (SIZE_T j = i;  j-- > 0; )
            {
                delete apach[j];
            }
            m_nMinSize = m_nMaxSize = 0;
            return;
        }
    }

    m_apach = apach;
    m_aacc  = paacc2;
    m_cach  = caacc;
}



CLookAside::~CLookAside()
{
    for (SIZE_T j = m_cach;  j-- > 0; )
    {
        delete m_apach[j];
    }

    delete [] m_apach;
    delete [] m_aacc;

    m_dwSignature = SIGNATURE_X;
}



int
CLookAside::_FindAllocator(
    IN DWORD cbSize)
{
    if (cbSize > m_nMaxSize)
        return -1;  // too big to cache
    else if (cbSize <= m_nMinSize)
        return 0;

    int l = 0, h = m_cach-1;

    do
    {
        DBG_ASSERT(m_aacc[l].cbSize < cbSize  &&  cbSize <= m_aacc[h].cbSize);

        unsigned m = (unsigned) (l + h) >> 1;
        DBG_ASSERT(m > 0);

        if (m_aacc[m-1].cbSize < cbSize  &&  cbSize <= m_aacc[m].cbSize)
            return m;
        else if (m_aacc[m].cbSize < cbSize)
            l = m+1;
        else
            h = m-1;
    } while (l <= h);

    DBG_ASSERT(FALSE);
    return -1;
}



LPVOID
CLookAside::Alloc(
    IN DWORD cbSize)
{
    LPVOID pv = NULL;
    int iAllocator = _FindAllocator(cbSize);

    if (iAllocator < 0)
    {
        pv = VirtualAlloc(NULL, cbSize, MEM_COMMIT, PAGE_READWRITE);
    }
    else
    {
        DBG_ASSERT(iAllocator < m_cach && cbSize <= m_aacc[iAllocator].cbSize);
        pv = m_apach[iAllocator]->Alloc();
    }

    return pv;
}



BOOL
CLookAside::Free(
    IN LPVOID pv,
    IN DWORD cbSize)
{
    int iAllocator = _FindAllocator(cbSize);

    if (iAllocator < 0)
    {
        VirtualFree(pv, 0, MEM_RELEASE);
    }
    else
    {
        DBG_ASSERT(iAllocator < m_cach && cbSize <= m_aacc[iAllocator].cbSize);
        m_apach[iAllocator]->Free(pv);
    }

    return TRUE;
}


#endif // LOCAL_ALLOC

//
// Defines
//

#define MemCacheLock()      ( EnterCriticalSection( &g_csMemCache ) )
#define MemCacheUnlock()    ( LeaveCriticalSection( &g_csMemCache ) )

//
// Private declarations
//

VOID
WINAPI
I_MemoryCacheSizeAdjustor(
    PVOID       pContext
);

//
// Global functions
//

DWORD
InitializeTwoLevelCache( 
    IN DWORDLONG            cbMemoryCacheSize
)
/*++
Routine Description:

    Initialize memory cache

Arguments:

    cbMemoryCacheSize - Size of memory cache (in bytes).  
    
Return Value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    DWORD                   dwError = ERROR_SUCCESS;

    if (DisableTsunamiCaching)
        return dwError;
    
    INITIALIZE_CRITICAL_SECTION( &g_csMemCache );

    if ( cbMemoryCacheSize == (DWORDLONG)-1 )
    {
        MEMORYSTATUSEX          MemoryStatus;
        MemoryStatus.dwLength = sizeof MemoryStatus;
    
        // 
        // Get our own estimate of size of cache
        //
        
        GlobalMemoryStatusEx( &MemoryStatus );
        
        g_cbMaxMemCacheSize = min( MemoryStatus.ullAvailPhys,
                                   MemoryStatus.ullTotalVirtual ) / 2;
        
        //
        // Schedule a max cache size adjustor
        //
        
        g_dwMemCacheSizeCookie = ScheduleWorkItem( I_MemoryCacheSizeAdjustor,
                                                   NULL,
                                                   g_cmsecAdjustmentTime,
                                                   TRUE );
        if ( !g_dwMemCacheSizeCookie )
        {
            dwError = GetLastError();
        }
    }
    else
    {
        g_cbMaxMemCacheSize = cbMemoryCacheSize;
    }

    if ( dwError == ERROR_SUCCESS )
    {
#if defined(LOCAL_ALLOC)
        // no initialization needed
#elif defined(PRIVATE_HEAP)
        g_hMemCacheHeap = HeapCreate( 0, 0, 0 );
        if (g_hMemCacheHeap == NULL)
            dwError = ERROR_NOT_ENOUGH_MEMORY;
#elif defined(VIRTUAL_ALLOC)
        // no initialization needed
#elif defined(LOOKASIDE)
        g_laMemCache = new CLookAside(g_aacc,
                                      sizeof(g_aacc)/sizeof(g_aacc[0]));
        if (g_laMemCache == NULL)
            dwError = ERROR_NOT_ENOUGH_MEMORY;
#endif // LOCAL_ALLOC
    }

    if ( dwError != ERROR_SUCCESS )
    {
        TerminateTwoLevelCache();
    }
    return dwError;
}

DWORD
ReadFileIntoMemoryCache( 
    IN HANDLE               hFile,
    IN DWORD                cbFile,
    OUT DWORD *             pcbRequired,
    OUT VOID **             ppvBuffer
)
/*++
Routine Description:

    Read contents of file into a buffer

Arguments:

    hFile - Handle to valid file
    cbFile - Size of file ( ==> size of buffer )
    pcbRequired - Filled in with number of bytes required to be removed from
                  cache to fit element
    ppvBuffer - Filled in with pointer to buffer with file contents.  Set
                to NULL on failure

Return Value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    BOOL                    bRet;
    VOID *                  pvBuffer = NULL;
    DWORD                   cbRead;
    OVERLAPPED              Overlapped;
    DWORD                   dwError = ERROR_SUCCESS;

    DBG_ASSERT( hFile && ( hFile != INVALID_HANDLE_VALUE ) );
    DBG_ASSERT( pcbRequired != NULL );
    DBG_ASSERT( ppvBuffer != NULL );

    *pcbRequired = 0;

    //
    // First check whether there will be room in cache for the blob 
    //

    MemCacheLock();
    
    if ( ( g_cbMemCacheSize + cbFile ) > g_cbMaxMemCacheSize ) 
    {
        // 
        // Not enough room for cache
        //
        
        MemCacheUnlock();
        *pcbRequired = DIFF(( g_cbMemCacheSize + cbFile ) - g_cbMaxMemCacheSize);
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Finished;
    }
    
    g_cbMemCacheSize += cbFile;
    g_cbMaxMemCacheUsed = max( g_cbMaxMemCacheUsed, g_cbMemCacheSize );
    g_cMemCacheElements++;
    g_cMaxMemCacheElementsUsed = max( g_cMaxMemCacheElementsUsed, g_cMemCacheElements );
    
    MemCacheUnlock();

    *pcbRequired = 0;

    //
    // Allocate blob for file
    //
    
#if defined(LOCAL_ALLOC)
    pvBuffer = LocalAlloc( LMEM_FIXED, cbFile );
#elif defined(PRIVATE_HEAP)
    DBG_ASSERT(g_hMemCacheHeap != NULL);
    pvBuffer = HeapAlloc( g_hMemCacheHeap, 0, cbFile );
#elif defined(VIRTUAL_ALLOC)
    pvBuffer = VirtualAlloc(NULL, cbFile, MEM_COMMIT, PAGE_READWRITE);
#elif defined(LOOKASIDE)
    pvBuffer = g_laMemCache->Alloc(cbFile);
#endif // LOCAL_ALLOC

    if ( pvBuffer == NULL )
    {
        MemCacheLock();
        
        g_cbMemCacheSize -= cbFile;
        
        MemCacheUnlock();

        dwError = ERROR_NOT_ENOUGH_MEMORY;
        goto Finished;
    }
    
    //
    // Read file into blob
    //
    
    Overlapped.Offset = 0;
    Overlapped.OffsetHigh = 0;
    Overlapped.hEvent = NULL;
    
    bRet = ReadFile( hFile,
                     pvBuffer,
                     cbFile,
                     &cbRead,
                     &Overlapped );

    if ( !bRet )
    {
        dwError = GetLastError();
        if ( dwError != ERROR_IO_PENDING )
        {
            // 
            // Something bad happened
            //
            
            goto Finished;
        }
        else
        {
            //
            // Reset the error lest we confuse ourselves later on cleanup
            //
            
            dwError = ERROR_SUCCESS;
        
            //
            // Wait for async read to complete
            //
                           
            bRet = GetOverlappedResult( hFile,
                                        &Overlapped,
                                        &cbRead,
                                        TRUE );
            if ( !bRet )
            {
                //
                // Something bad happened
                //
                
                dwError = GetLastError();
                
                goto Finished;
            }
        }
    }

    //
    // Ensure that we read the number of bytes we expected to
    //
    
    if ( cbRead != cbFile )
    {
        dwError = ERROR_INVALID_DATA;
    }
    
Finished:
    
    if ( dwError != ERROR_SUCCESS )
    {
        if ( pvBuffer != NULL )
        {
#if defined(LOCAL_ALLOC)
            LocalFree( pvBuffer );
#elif defined(PRIVATE_HEAP)
            HeapFree( g_hMemCacheHeap, 0, pvBuffer );
#elif defined(VIRTUAL_ALLOC)
            VirtualFree( pvBuffer, 0, MEM_RELEASE );
#elif defined(LOOKASIDE)
            g_laMemCache->Free(pvBuffer, cbFile);
#endif // LOCAL_ALLOC

            pvBuffer = NULL;
        }
    }
    
    *ppvBuffer = pvBuffer;

    return dwError;
}

DWORD
ReleaseFromMemoryCache(
    IN VOID *                  pvBuffer,
    IN DWORD                   cbBuffer
)
/*++
Routine Description:

    Release file content blob from cache

Arguments:

    pvBuffer - Buffer to release
    cbBuffer - Size of buffer

Return Value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    DBG_ASSERT( pvBuffer );
#if defined(LOCAL_ALLOC)
    LocalFree( pvBuffer );
#elif defined(PRIVATE_HEAP)
    DBG_ASSERT(g_hMemCacheHeap != NULL);

    HeapFree( g_hMemCacheHeap, 0, pvBuffer );
#elif defined(VIRTUAL_ALLOC)
    VirtualFree( pvBuffer, 0, MEM_RELEASE );
#elif defined(LOOKASIDE)
    g_laMemCache->Free(pvBuffer, cbBuffer);
#endif // LOCAL_ALLOC
    
    MemCacheLock();
    
    g_cbMemCacheSize -= cbBuffer;
    g_cMemCacheElements--;
    
    MemCacheUnlock();
    
    return ERROR_SUCCESS;
}

DWORD
TerminateTwoLevelCache(
    VOID
)
/*++
Routine Description:

    Terminate the memory cache

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful
    ERROR_INVALID_DATA if still elements in cache 

--*/
{
    if (DisableTsunamiCaching)
        return ERROR_SUCCESS;
    
#if defined(LOCAL_ALLOC)
    // no cleanup
#elif defined(PRIVATE_HEAP)
    if (g_hMemCacheHeap != NULL)
    {
        DBG_REQUIRE( HeapDestroy( g_hMemCacheHeap ) );
        g_hMemCacheHeap = NULL;
    }
#elif defined(VIRTUAL_ALLOC)
    // no cleanup
#elif defined(LOOKASIDE)
    delete g_laMemCache;
    g_laMemCache = NULL;
#endif // LOCAL_ALLOC

    if ( g_dwMemCacheSizeCookie != 0 )
    {
        RemoveWorkItem( g_dwMemCacheSizeCookie );
        g_dwMemCacheSizeCookie = 0;
    }

    DeleteCriticalSection( &g_csMemCache );
    
    return ( g_cbMemCacheSize ) ? 
            ERROR_INVALID_DATA : ERROR_SUCCESS;
}

VOID
WINAPI
I_MemoryCacheSizeAdjustor(
    IN PVOID                pContext
)
/*++

Routine Description:

    Called to adjust the maximum size of the memory cache

Arguments:

    pContext - Context (set to NULL)

Return value:

    None    

--*/
{
    MEMORYSTATUSEX              MemoryStatus;
    MemoryStatus.dwLength = sizeof MemoryStatus;

    GlobalMemoryStatusEx( &MemoryStatus );

    MemCacheLock();

    g_cbMaxMemCacheSize = min( MemoryStatus.ullAvailPhys + g_cbMemCacheSize,
                               MemoryStatus.ullTotalVirtual ) / 2;

    MemCacheUnlock();
}

DWORD
DumpMemoryCacheToHtml(
    IN CHAR *                   pszBuffer,
    IN OUT DWORD *              pcbBuffer
)
/*++

Routine Description:

    Dump memory cache stats to buffer

Arguments:

    pszBuffer - buffer to fill
    pcbBuffer - size of buffer

Return value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    *pcbBuffer = wsprintf( pszBuffer,
        "<table>"
        "<tr><td>Current memory cache size</td><td align=right>%I64d</td></tr>"
        "<tr><td>Current memory cache limit</td><td align=right>%I64d</td></tr>"
        "<tr><td>Number of items in memory cache</td><td align=right>%d</td></tr>"
        "<tr><td>Peak memory cache size</td><td align=right>%I64d</td></tr>"
        "<tr><td>Peak memory cache element count</td><td align=right>%d</td></tr>"
        "</table>",
        g_cbMemCacheSize,
        g_cbMaxMemCacheSize,
        g_cMemCacheElements,
        g_cbMaxMemCacheUsed,
        g_cMaxMemCacheElementsUsed 
    );

    return TRUE;
    
}

VOID
QueryMemoryCacheStatistics(
    IN  INETA_CACHE_STATISTICS * pCacheCtrs,
    IN  BOOL                     fClearAll
)
/*++

Routine Description:

    Query memory cache perfmon counters

Arguments:

    pCacheCtrs - Relevant members of stat structure are filled in
    fClearAll - Clear the counters

Return value:

    ERROR_SUCCESS if successful, else Win32 Error

--*/
{
    DBG_ASSERT( pCacheCtrs );
    
    if ( fClearAll )
    {
        pCacheCtrs->CurrentFileCacheSize = 0;
        pCacheCtrs->MaximumFileCacheSize = 0;
    }
    else
    {
        pCacheCtrs->CurrentFileCacheSize = g_cbMemCacheSize;
        pCacheCtrs->MaximumFileCacheSize = g_cbMaxMemCacheUsed;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\tsunami.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1998                **/
/**********************************************************************/

/*
    tsunami.cxx

    This module contains most of the public Tsunami Cache routines.

    FILE HISTORY:
        MCourage    09-Dec-1997     Created
*/

#include <tsunami.hxx>
#include <inetinfo.h>
#include <issched.hxx>
#include "inetreg.h"
#include "globals.hxx"
#include "tsunamip.hxx"
#include <inetsvcs.h>
#include "metacach.hxx"
#include "filecach.hxx"
#include "blobcach.hxx"
#include "atq.h"
#include "tracelog.h"
#include <lkrhash.h>
#include "filehash.hxx"
#include "blobhash.hxx"
#include "tlcach.h"
#include "etagmb.h"

BOOL  g_fCacheSecDesc = TRUE;

//
// from TsInit.cxx
//

HANDLE g_hQuit = NULL;
HANDLE g_hNewItem   = NULL;
BOOL g_fW3OnlyNoAuth = FALSE;
BOOL  TsNoDirOpenSupport = FALSE;


#if TSUNAMI_REF_DEBUG
PTRACE_LOG RefTraceLog;
#endif  // TSUNAMI_REF_DEBUG

//
//  The TTL to scavenge the cache and the id of the scheduled work item of the
//  next scheduled scavenge
//

DWORD g_cmsecObjectCacheTTL = (INETA_DEF_OBJECT_CACHE_TTL * 1000);
DWORD g_dwObjectCacheCookie = 0;

# define MIN_CACHE_SCAVENGE_TIME (5*1000) // 5 seconds


//
// Disables Tsunami Caching
//

BOOL DisableTsunamiCaching = FALSE;

//
// Allows us to mask the invalid flags
//

DWORD TsValidCreateFileOptions = TS_IIS_VALID_FLAGS;

//
// from globals.cxx
//
CONFIGURATION Configuration;
BOOL          g_fDisableCaching = FALSE;


//
// Initialization and cleanup
//


BOOL
Tsunami_Initialize(
            VOID
            )
/*++
Routine Description:

    Sets up all the core caches.  Call this before using any
    cache routines.

Arguments:

    None.

Return Values:

    TRUE on success
--*/
{
    HRESULT hr;
    HKEY  hKey;
    DWORD dwType;
    DWORD nBytes;
    DWORD dwValue;
    DWORD dwMaxFile;
    DWORD err;

#if TSUNAMI_REF_DEBUG
    RefTraceLog = CreateRefTraceLog(
                      256,              // LogSize
                      0                 // ExtraBytesInHeader
                      );
#endif  // TSUNAMI_REF_DEBUG

    //
    // Initialize global events
    //

    g_hQuit = IIS_CREATE_EVENT(
                  "g_hQuit",
                  &g_hQuit,
                  TRUE,
                  FALSE
                  );

    g_hNewItem = IIS_CREATE_EVENT(
                     "g_hNewItem",
                     &g_hNewItem,
                     FALSE,
                     FALSE
                     );

    if ( (g_hQuit == NULL) || (g_hNewItem == NULL) ) {
        goto Failure;
    }

    //
    // Set defaults
    //

    MEMORYSTATUS ms;
    ms.dwLength = sizeof(MEMORYSTATUS);
    GlobalMemoryStatus( &ms );

    //
    // default is 1K files per 32MB of physical memory after the 1st 8MB,
    // minimum INETA_MIN_DEF_FILE_HANDLE
    //

    if ( ms.dwTotalPhys > 8 * 1024 * 1024 )
    {
        dwMaxFile = (DWORD)(ms.dwTotalPhys - 8 * 1024 * 1024) / ( 32 * 1024 );
        if ( dwMaxFile < INETA_MIN_DEF_FILE_HANDLE )
        {
            dwMaxFile = INETA_MIN_DEF_FILE_HANDLE;
        }
    }
    else
    {
        dwMaxFile = INETA_MIN_DEF_FILE_HANDLE;
    }

    //
    // If this is not a NTS, disable tsunami caching by default
    //

    if ( !TsIsNtServer() ) {
        DisableTsunamiCaching = TRUE;
    }

    //
    // Read the registry key to see whether tsunami caching is enabled
    //

    err = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                INETA_PARAMETERS_KEY,
                0,
                KEY_READ,
                &hKey
                );

    if ( err == ERROR_SUCCESS ) {

        nBytes = sizeof(dwValue);
        err = RegQueryValueEx(
                    hKey,
                    INETA_DISABLE_TSUNAMI_CACHING,
                    NULL,
                    &dwType,
                    (LPBYTE)&dwValue,
                    &nBytes
                    );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
            DisableTsunamiCaching = (BOOL)dwValue;
        }

        //
        // How big do files have to be before we stop caching them
        //

        err = RegQueryValueEx(
            hKey,
            INETA_MAX_CACHED_FILE_SIZE,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &nBytes
            );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {

            g_dwFileCacheByteThreshold = dwValue;
        } else {

            g_dwFileCacheByteThreshold = INETA_DEF_MAX_CACHED_FILE_SIZE;
        }

        //
        // How big is the memory cache in megabytes
        //
        err = RegQueryValueEx(
            hKey,
            INETA_MEM_CACHE_SIZE,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &nBytes
            );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {

            //
            // set the size in megabytes
            //
            g_dwMemCacheSize = dwValue * (1024 * 1024);
        } else {

            g_dwMemCacheSize = INETA_DEF_MEM_CACHE_SIZE;
        }

        //
        // Do we use the sequential read flag to read files?
        //
        err = RegQueryValueEx(
            hKey,
            INETA_ENABLE_SEQUENTIAL_READ,
            NULL,
            &dwType,
            (LPBYTE)&dwValue,
            &nBytes
            );

        if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {

            g_bEnableSequentialRead = dwValue ? 1 : 0;
        } else {

            g_bEnableSequentialRead = INETA_DEF_ENABLE_SEQUENTIAL_READ;
        }

        if ( g_fW3OnlyNoAuth )
        {
            //
            // TODO: investigate is security descriptor caching
            // can be used in the non-SYSTEM account case.
            //

            g_fCacheSecDesc = FALSE;
        }
        else
        {
            //
            // read the enable cache sec desc flag
            //

            nBytes = sizeof(dwValue);
            err = RegQueryValueEx(
                            hKey,
                            INETA_CACHE_USE_ACCESS_CHECK,
                            NULL,
                            &dwType,
                            (LPBYTE)&dwValue,
                            &nBytes
                            );

            if ( (err == ERROR_SUCCESS) && (dwType == REG_DWORD) ) {
                g_fCacheSecDesc = !!dwValue;
            }
            else {
                 g_fCacheSecDesc = INETA_DEF_CACHE_USE_ACCESS_CHECK;
            }
        }

        //
        // Read the maximum # of files in cache
        //

        nBytes = sizeof(dwValue);
        if ( RegQueryValueEx(
                            hKey,
                            INETA_MAX_OPEN_FILE,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwValue,
                            &nBytes
                            ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            dwMaxFile = dwValue;
        }

        RegCloseKey( hKey );

    }

    //
    // if tsunami caching is disabled, set the flags accordingly
    //

    if ( DisableTsunamiCaching ) {
        g_fDisableCaching = TRUE;
        TsValidCreateFileOptions = TS_PWS_VALID_FLAGS;
        g_fCacheSecDesc = FALSE;
    }

    //
    // Initialize the ETag Metabase Change Number
    //

    hr = ETagChangeNumber::Create();
    if ( FAILED(hr) ) {
        goto Failure;
    }

    //
    // Initialize the directory change manager
    //
    if ( !DcmInitialize( ) ) {
        goto Failure;
    }

    //
    // Initialize the tsunami cache manager
    //

    if ( !FileCache_Initialize( dwMaxFile )) {
        goto Failure;
    }


    if ( !MetaCache_Initialize() ) {
        goto Failure;
    }

    if ( !BlobCache_Initialize() ) {
        goto Failure;
    }

    return( TRUE );

Failure:

    IIS_PRINTF( ( buff, "Tsunami_Initialize() Failed. Error = %d\n",
                GetLastError()));

    if ( g_hQuit )
    {
        CloseHandle( g_hQuit );
        g_hQuit = NULL;
    }

    if ( g_hNewItem )
    {
        CloseHandle( g_hNewItem );
        g_hNewItem = NULL;
    }

    return FALSE;
} // Tsunami_Initialize

VOID
Tsunami_Terminate(
    VOID
    )
/*++
Routine Description:

    Cleans up all the core caches.

Arguments:

    None.

Return Values:

    None.
--*/
{
    DWORD dwResult;

    if ( !SetEvent( g_hQuit ) ) {
        IIS_PRINTF((buff,
                "No Quit event posted for Tsunami. No Cleanup\n"));
        return;
    }

    //
    //  Flush all items from the cache
    //

    TsCacheFlush( 0 );

    //
    //  Synchronize with our thread so we don't leave here before the
    //  thread has finished cleaning up
    //


    CloseHandle( g_hQuit );
    CloseHandle( g_hNewItem );


    BlobCache_Terminate();
    MetaCache_Terminate();
    FileCache_Terminate();
    DcmTerminate();

    ETagChangeNumber::Destroy();

#if TSUNAMI_REF_DEBUG
    if( RefTraceLog != NULL ) {
        DestroyRefTraceLog( RefTraceLog );
        RefTraceLog = NULL;
    }
#endif  // TSUNAMI_REF_DEBUG

} // Tsunami_Terminate


//
// Scavenger routines
//


BOOL
FileFlushFilterTTL(
    TS_OPEN_FILE_INFO * pFileInfo,
    PVOID               pv
    )
{
    if (pFileInfo->GetIORefCount()) {
        //
        // Try not to time out entries which are in use for I/O.
        //
        return FALSE;
    }

    if (pFileInfo->GetTTL() == 0) {
        pFileInfo->TraceCheckpointEx(TS_MAGIC_TIMEOUT, 0, 0);
        return TRUE;
    } else {
        if (pFileInfo->IsInitialized()) {
            pFileInfo->DecrementTTL();
        }
        return FALSE;
    }
}

BOOL
BlobFlushFilterTTL(
    PBLOB_HEADER pBlob,
    PVOID        pv
    )
{
    if (pBlob->TTL == 0) {
        pBlob->TraceCheckpointEx(TS_MAGIC_TIMEOUT, 0, 0);
        return TRUE;
    } else {
        pBlob->TTL--;
        return FALSE;
    }
}


VOID
WINAPI
CacheScavenger(
    VOID * pContext
    )
{
    FilteredFlushFileCache(FileFlushFilterTTL, NULL);
    FilteredFlushBlobCache(BlobFlushFilterTTL, NULL);
}


BOOL
InitializeCacheScavenger(
    VOID
    )
/*++
Routine Description:

    This function kicks off the scheduled tsunami object cache scavenger

Arguments:

    None.

Return Values:

    TRUE on success
--*/
{
    HKEY hkey;

    //
    //  Schedule a scavenger to close all of the objects that haven't been
    //  referenced in the last ttl
    //

    if ( !RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                        INETA_PARAMETERS_KEY,
                        0,
                        KEY_READ,
                        &hkey ))
    {
        DWORD dwType;
        DWORD nBytes;
        DWORD dwValue;

        nBytes = sizeof(dwValue);
        if ( RegQueryValueEx(
                            hkey,
                            INETA_OBJECT_CACHE_TTL,
                            NULL,
                            &dwType,
                            (LPBYTE) &dwValue,
                            &nBytes
                            ) == ERROR_SUCCESS && dwType == REG_DWORD )
        {
            g_cmsecObjectCacheTTL = dwValue;
        } else {
            g_cmsecObjectCacheTTL = 0;
        }


        //
        //  Don't schedule anything if the scavenger should be disabled
        //

        if ( g_cmsecObjectCacheTTL == 0xffffffff )
        {
            RegCloseKey( hkey );
            return TRUE;
        }

        //
        //  The registry setting is in seconds, convert to milliseconds
        //

        g_cmsecObjectCacheTTL *= 1000;

        //
        //  Supply the default if no value was specified
        //

        if ( !g_cmsecObjectCacheTTL )
        {
            g_cmsecObjectCacheTTL = INETA_DEF_OBJECT_CACHE_TTL * 1000;
        }

        RegCloseKey( hkey );
    }

    //
    //  Require a minimum of thirty seconds
    //

    g_cmsecObjectCacheTTL = max( g_cmsecObjectCacheTTL,
                                 MIN_CACHE_SCAVENGE_TIME );

    g_dwObjectCacheCookie = ScheduleWorkItem(
                                        CacheScavenger,
                                        NULL,
                                        g_cmsecObjectCacheTTL,
                                        TRUE );     // Periodic

    if ( !g_dwObjectCacheCookie )
    {
        return FALSE;
    }

    return TRUE;
}

VOID
TerminateCacheScavenger(
    VOID
    )
/*++
Routine Description:

    Stops the cache scavenger
Arguments:

    None.

Return Values:

    None.
--*/
{
    if ( g_dwObjectCacheCookie )
    {
        RemoveWorkItem( g_dwObjectCacheCookie );
        g_dwObjectCacheCookie = 0;
    }
}


//
// Blob memory management
//


BOOL
TsAllocate(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN OUT  PVOID *         ppvNewBlock
    )
{
    return( TsAllocateEx(  TSvcCache,
                           cbSize,
                           ppvNewBlock,
                           NULL ) );
}

BOOL
TsAllocateEx(
    IN const TSVC_CACHE &TSvcCache,
    IN      ULONG           cbSize,
    IN OUT  PVOID *         ppvNewBlock,
    OPTIONAL PUSER_FREE_ROUTINE pfnFreeRoutine
    )
/*++

  Routine Description:

      This function allocates a memory block for the calling server.

      The returned block is suitable for use as a parameter to
      TsCacheDirectoryBlob().  Blocks allocated by this function
      must either be cached or freed with TsFree().  Freeing of
      cached blocks will be handled by the cache manager.

      Anything allocated with this routine MUST be derived from
      BLOB_HEADER!

  Arguments:

      TSvcCache      - An initialized TSVC_CACHE structure.

      cbSize         - Number of bytes to allocate.  (Must be strictly
                       greater than zero.)

      ppvNewBlock    - Address of a pointer to store the new block's
                       address in.

      pfnFreeRoutine - pointer to a routine that will be called to
                       clean up the block when it is decached.

  Return Value:

      TRUE  - The allocation succeeded, and *ppvNewBlock points to
              at least cbSize accessable bytes.

      FALSE - The allocation failed.

--*/
{
    CBlobKey *   pBlobKey;
    PBLOB_HEADER pbhNewBlock;

    DBG_ASSERT( cbSize > 0 );
    DBG_ASSERT( ppvNewBlock != NULL );

    //
    // allocate the blob and the key while we're at it.
    //
    pBlobKey = (CBlobKey *) ALLOC(cbSize + sizeof(CBlobKey));

    if ( pBlobKey != NULL )
    {
        //
        //  If the allocation succeeded, we return a pointer to
        //  the new structure which is directly preceded by it's key.
        //

        pbhNewBlock = (PBLOB_HEADER) (pBlobKey + 1);
        *ppvNewBlock = ( PVOID )( pbhNewBlock );

        //
        //  Set up the BLOB_HEADER: Normal flags and stored allocation
        //  size.
        //

        pbhNewBlock->Signature      = TS_BLOB_SIGNATURE;
        pbhNewBlock->pBlobKey       = pBlobKey;

        pbhNewBlock->IsCached       = FALSE;
        pbhNewBlock->pfnFreeRoutine = pfnFreeRoutine;
        pbhNewBlock->lRefCount      = 0;
        pbhNewBlock->TTL            = 1;
        pbhNewBlock->pSecDesc       = NULL;
        pbhNewBlock->hLastSuccessAccessToken = INVALID_HANDLE_VALUE;

        pBlobKey->m_pszPathName = NULL;
        pBlobKey->m_cbPathName  = 0;
        pBlobKey->m_dwService   = TSvcCache.GetServiceId();
        pBlobKey->m_dwInstance  = TSvcCache.GetInstanceId();
        pBlobKey->m_dwDemux     = 0;

        pbhNewBlock->TraceCheckpointEx(TS_MAGIC_ALLOCATE, (PVOID) (ULONG_PTR) cbSize, pfnFreeRoutine);
    }
    else
    {
        //
        //  The allocation failed, and we need to return NULL
        //

        *ppvNewBlock = NULL;
        return FALSE;
    }

return TRUE;

}

BOOL
TsFree(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvOldBlock
    )
/*++

Routine Description:

    This function frees a memory block allocated with TsAllocate().

    Blocks that are currently cached cannot be freed with this
    function.

Arguments:

    TSvcCache      - An initialized TSVC_CACHE structure.


    pvOldBlock   - The address of the block to free.  (Must be
                   non-NULL.)

Return Value:

    TRUE  - The block was freed.  The pointer pvOldBlock is no longer
            valid.

    FALSE - The block was not freed.  Possible reasons include:

             -  pvOldBlock does not point to a block allocated with
                TsAllocate().

             -  pvOldBlock points to a block that has been cached
                with CacheDirectoryBlob().

             -  pServiceInfo does not point to a valid SERVICE_INFO
                structure.

--*/
{
    BOOL         bSuccess;
    PBLOB_HEADER pbhOldBlock;
    CBlobKey *   pRealOldBlock;

    DBG_ASSERT( pvOldBlock != NULL );

    //
    //  Adjust the input pointer to refer to the BLOB_HEADER.
    //

    pbhOldBlock = (( PBLOB_HEADER )pvOldBlock );

    DBG_ASSERT( TS_BLOB_SIGNATURE == pbhOldBlock->Signature );

    //
    // Track memory corruption in free builds.
    //

    if ( TS_BLOB_SIGNATURE != pbhOldBlock->Signature ) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  If the Blob is currently in the cache, we can't free it.
    //  Check for this in the Blob's flags, and fail if it
    //  occurs.
    //

    if ( pbhOldBlock->IsCached )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "A service (%d) has attempted to TsFree a BLOB that it put in the cache.",
                    TSvcCache.GetServiceId() ));
        BREAKPOINT();

        bSuccess = FALSE;
    }
    else
    {
        pbhOldBlock->Signature = TS_FREE_BLOB_SIGNATURE;

        if ( pbhOldBlock->pfnFreeRoutine )
        {
            bSuccess = pbhOldBlock->pfnFreeRoutine( pvOldBlock );
        }
        else
        {
            bSuccess = TRUE;
        }

        if ( bSuccess )
        {
            //
            //  Free the memory used by the Blob.
            //
            pRealOldBlock = ((CBlobKey *) pvOldBlock) - 1;

            DBG_ASSERT( NULL == pRealOldBlock->m_pszPathName );

            pbhOldBlock->TraceCheckpointEx(TS_MAGIC_DELETE_NC,
                                           (PVOID) (ULONG_PTR) (pRealOldBlock->m_dwDemux),
                                           pbhOldBlock->pfnFreeRoutine);

            bSuccess = !!FREE( pRealOldBlock );


/*
            DEC_COUNTER( TSvcCache.GetServiceId(),
                         CurrentObjects );
 */
        }

    }

    return( bSuccess );
} // TsFree


//
// Standard cache operations
//

BOOL
TsCacheDirectoryBlob(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      ULONG                   cchDirectoryName,
    IN      ULONG                   iDemultiplexor,
    IN      PVOID                   pvBlob,
    IN      BOOLEAN                 bKeepCheckedOut,
    IN      PSECURITY_DESCRIPTOR    pSecDesc
    )
/*++

Routine Description:

    This function associates the Blob given as input with the specified
    directory and demultiplexing number.  Services should use this
    function to add a Blob to the cache.

    Callers must not cache the same Blob twice.  Once a Blob is cached,
    its contents must not be modified, and it must not be freed or re-cached.

Arguments:

    TSvcCache        - An initialized TSVC_CACHE structure.
    pszDirectoryName - The name that will be used as a key in the cache.
    iDemultiplexor   - Identifies the type of the object to be stored
    pvBlob           - Pointer to the actual object to be stored
    bKeepCheckedOut  - If TRUE, the caller can keep a reference to the cached object.
    pSecDesc         - An optional SECURITY_DESCRIPTOR that goes along with the object

Return Values:

    TRUE  - The block successfully added to the cache
    FALSE - The block could not be added to the cache

--*/
{
    BOOL bSuccess;
    PBLOB_HEADER pBlob = (PBLOB_HEADER)pvBlob;
    DBG_ASSERT( TS_BLOB_SIGNATURE == pBlob->Signature );

    //
    // set up the key
    //
    CBlobKey * pbk = pBlob->pBlobKey;
    DBG_ASSERT( NULL != pbk );

    pbk->m_cbPathName = cchDirectoryName;
    pbk->m_pszPathName = (PCHAR) ALLOC(pbk->m_cbPathName + 1);
    if (NULL != pbk->m_pszPathName) {
        memcpy(pbk->m_pszPathName, pszDirectoryName, pbk->m_cbPathName + 1);
    } else {
        pbk->m_cbPathName = 0;
        pbk->m_pszPathName = NULL;
        return FALSE;
    }

    IISstrupr( (PUCHAR)pbk->m_pszPathName );

    pbk->m_dwService = TSvcCache.GetServiceId();
    pbk->m_dwInstance = TSvcCache.GetInstanceId();
    pbk->m_dwDemux = iDemultiplexor;

    //
    // try to cache
    //

    bSuccess = CacheBlob(pBlob);

    if (bSuccess && !bKeepCheckedOut) {
        CheckinBlob(pBlob);
    }

    if (!bSuccess) {
        FREE(pbk->m_pszPathName);
        pbk->m_pszPathName = NULL;
        pbk->m_cbPathName = 0;
    }

    return bSuccess;
} // TsCacheDirectoryBlob


BOOL
TsDeCacheCachedBlob(
    PVOID   pBlobPayload
    )
/*++
Description:

    This function removes a blob payload object from the cache

Arguments:

    pCacheObject - Object to decache

Return Values:

    TRUE on success
--*/
{
    DecacheBlob( (PBLOB_HEADER)pBlobPayload );
    return TRUE;
}


BOOL
TsCheckOutCachedBlob(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszDirectoryName,
    IN      ULONG                   cchDirectoryName,
    IN      ULONG                   iDemultiplexor,
    IN      PVOID *                 ppvBlob,
    IN      HANDLE                  ,
    IN      BOOL                    ,
    IN      PSECURITY_DESCRIPTOR*   )
/*++
Routine Description:

    Searches the cache for a named cache entry. If the entry is found,
    it is checked out and returned to the caller.

Arguments:

    TSvcCache            - An initialized TSVC_CACHE structure.
    pszDirectoryName     - The name used as a key in the cache.
    iDemultiplexor       - Identifies the type of the object to be stored
    ppvBlob              - If the entry is found, a pointer to it will be
                           placed here.
    hAccessToken         - Optional parameter used to determine if the
                           caller is allowed to access the cached object.
    fMayCacheAccessToken - If this is TRUE, and the caller succesfully gains
                           access to the cached object, the hAccessToken will
                           be saved with the object in the cache.
    ppSecDesc            - If this is non-NULL, the caller will be given a
                           copy of the objects security descriptor.

Return Values:

    None.
--*/
{
    CHAR achUpName[MAX_PATH+1];
    BOOL bSuccess;

    //  People really do use this.
    //  DBG_ASSERT( ppSecDesc == NULL );

    //
    // Make sure the path is upper case
    //
    IISstrncpy(achUpName, pszDirectoryName, MAX_PATH);
    achUpName[MAX_PATH] = 0;
    cchDirectoryName = min(cchDirectoryName, MAX_PATH);

    IISstrupr( reinterpret_cast<PUCHAR>(achUpName) );

    bSuccess = CheckoutBlob(achUpName,
                            cchDirectoryName,
                            TSvcCache.GetServiceId(),
                            TSvcCache.GetInstanceId(),
                            iDemultiplexor,
                            (PBLOB_HEADER *) ppvBlob);

    if (bSuccess) {
        //
        // Security handled by the caller
        //
        ((PBLOB_HEADER)*ppvBlob)->TTL = 1;
        return TRUE;
    } else {
        return FALSE;
    }
}

BOOL
TsCheckInCachedBlob(
    IN      PVOID           pvBlob
    )
/*++
Routine Description:

    When a client is done with a blob it must check it back into the cache.

Arguments:

    pvBlob - The object to be checked in

Return Values:

    TRUE for success
--*/
{
    CheckinBlob((PBLOB_HEADER) pvBlob);

    return( TRUE );
} // TsCheckInCachedBlob


BOOL
TsCheckInOrFree(
    IN      PVOID           pvOldBlock
    )
/*++

Routine Description:

    This function checks in a cached memory block or
    frees a non-cached memory block allocated with TsAllocate().

Arguments:

    pvOldBlock   - The address of the block to free.  (Must be
                   non-NULL.)

Return Value:

    TRUE  - The block was freed.  The pointer pvOldBlock is no longer
            valid.

    FALSE - The block was not freed.  Possible reasons include:

             -  pvOldBlock does not point to a block allocated with
                TsAllocate().

--*/
{
    PBLOB_HEADER pBlob = (PBLOB_HEADER) pvOldBlock;
    TSVC_CACHE dummy;

    if (pBlob->IsCached) {
        CheckinBlob(pBlob);
    } else {
        TsFree(dummy, (PVOID)pBlob);
    }
    return( TRUE );
} // TsCheckInOrFree



BOOL
TsCacheFlushDemux(
    IN ULONG            iDemux
    )
/*++

  Routine Description:

    Flush all cache items whose demultiplexor matches that specified.

  Arguments:

    iDemux - Value of demux whose cache items are to be flushed.

--*/
{
    if (RESERVED_DEMUX_OPEN_FILE == iDemux) {
        FlushFileCache();
    } else {
        //
        // Only place where this function is called from is from odbc with
        // a demux of RESERVED_DEMUX_QUERY_CACHE.  We do not need to worry
        // about other cases
        //
        FlushBlobCache();
    }

    return TRUE;
} // TsCacheFlushDemux


BOOL
FlushFilterService(
    PBLOB_HEADER pBlob,
    PVOID        pv
    )
{
    DWORD dwServerMask = * (DWORD *)pv;
    return (pBlob->pBlobKey->m_dwService == dwServerMask);
}



BOOL
TsCacheFlush(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    This function flushes the blob cache of all items for the specified service
    or for all services if dwServerMask is zero.

--*/
{
    if (dwServerMask) {
        FilteredFlushBlobCache(FlushFilterService, &dwServerMask);
    } else {
        FlushBlobCache();
    }

    return TRUE;
} // TsCacheFlush


BOOL
FlushFilterUser(
    TS_OPEN_FILE_INFO *pOpenFile,
    PVOID              pv
    )
{
    HANDLE hUser = * (HANDLE *)pv;
    return (pOpenFile->QueryUser() == hUser);
}


BOOL
TsCacheFlushUser(
    IN  HANDLE      hUserToken,
    IN  BOOL        fDefer
    )
/*++

  Routine Description:

    This function flushes all file handles associated the passed user context

  Arguments:

    hUserToken - User token to flush from the cache
    fDefer - Build list but close handles later in worker thread (Not supported)

--*/
{
    FilteredFlushFileCache(FlushFilterUser, &hUserToken);

    return TRUE;
} // TsCacheFlushUser


typedef struct _FLUSH_URL_PARAM {
    PCSTR pszURL;
    DWORD cbURL;
    DWORD dwService;
    DWORD dwInstance;
} FLUSH_URL_PARAM;


BOOL
FlushFilterURL(
    PBLOB_HEADER pBlob,
    PVOID        pv
    )
{
    DBG_ASSERT( pBlob );
    DBG_ASSERT( pBlob->pBlobKey );

    FLUSH_URL_PARAM * fup = (FLUSH_URL_PARAM *)pv;
    CBlobKey * pbk = pBlob->pBlobKey;
    BOOL bAtRoot;

    //
    // If we're flushing everything, then don't bother
    // with the string comparison
    //
    bAtRoot = (fup->cbURL == 1) && (fup->pszURL[0] == '/');

    //
    // If the service, instance, and URL prefixes match then we flush.
    //
    return ( (pbk->m_dwService == fup->dwService)
             && (pbk->m_dwInstance == fup->dwInstance)
             && (bAtRoot
                || ((pbk->m_cbPathName >= fup->cbURL)
                   && (memcmp(pbk->m_pszPathName, fup->pszURL, fup->cbURL) == 0))) );
}


VOID
TsFlushURL(
    IN const TSVC_CACHE             &TSvcCache,
    IN      PCSTR                   pszURL,
    IN      DWORD                   dwURLLength,
    IN      ULONG                   iDemultiplexor
    )
/*++

  Routine Description:

    This routine takes as input a URL and removes from the cache all cached
    objects that have the input URL as their prefix. This is mostly called
    when we get a change notify for metadata.

  Arguments

    TSvcCache               - Service cache
    pszURL                  - The URL prefix to be flushed.
    iDemultiplexor          - The demultiplexor for the caller's entries.

  Returns

    Nothing

--*/
{
    FLUSH_URL_PARAM fuparam;
    STACK_STR( strUpName, MAX_PATH );

    //
    // It really only makes sense to flush the URI cache
    // with this function.
    //
    DBG_ASSERT( RESERVED_DEMUX_URI_INFO == iDemultiplexor );

    //
    // Make sure the path is upper case
    //
    strUpName.Copy( pszURL, dwURLLength );

    IISstrupr( (PUCHAR) strUpName.QueryStr() );

    fuparam.pszURL     = strUpName.QueryStr();
    fuparam.cbURL      = dwURLLength;
    fuparam.dwService  = TSvcCache.GetServiceId();
    fuparam.dwInstance = TSvcCache.GetInstanceId();

    FilteredFlushURIBlobCache(FlushFilterURL, &fuparam);
}


BOOL
TsExpireCachedBlob(
    IN const TSVC_CACHE &TSvcCache,
    IN      PVOID           pvBlob
    )
{
    DecacheBlob((PBLOB_HEADER) pvBlob);

    return TRUE;
} // TsExpireCachedBlob

//
// Misc cache management
//


BOOL
TsCacheQueryStatistics(
    IN  DWORD       Level,
    IN  DWORD       dwServerMask,
    IN  INETA_CACHE_STATISTICS * pCacheCtrs
    )
/*++

  Routine Description:

    This function returns the statistics for the global cache or for the
    individual services

  Arguments:

    Level - Only valid value is 0
    dwServerMask - Server mask to retrieve statistics for or 0 for the sum
        of the services
    pCacheCtrs - Receives the statistics for cache

  Notes:
    CacheBytesTotal and CacheBytesInUse are not kept on a per-server basis
        so they are only returned when retrieving summary statistics.

  Returns:

    TRUE on success, FALSE on failure
--*/
{
    if ( dwServerMask > LAST_PERF_CTR_SVC )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if ( g_pFileCacheStats
         && g_pURICacheStats
         && g_pBlobCacheStats
         && (dwServerMask == 0) ) {

        pCacheCtrs->FilesCached        = g_pFileCacheStats->GetFilesCached();
        pCacheCtrs->TotalFilesCached   = g_pFileCacheStats->GetTotalFilesCached();
        pCacheCtrs->FileHits           = g_pFileCacheStats->GetHits();
        pCacheCtrs->FileMisses         = g_pFileCacheStats->GetMisses();
        pCacheCtrs->FileFlushes        = g_pFileCacheStats->GetFlushes();
        pCacheCtrs->FlushedEntries     = g_pFileCacheStats->GetFlushedEntries();
        pCacheCtrs->TotalFlushed       = g_pFileCacheStats->GetTotalFlushed();

        pCacheCtrs->URICached          = g_pURICacheStats->GetBlobsCached();
        pCacheCtrs->TotalURICached     = g_pURICacheStats->GetTotalBlobsCached();
        pCacheCtrs->URIHits            = g_pURICacheStats->GetHits();
        pCacheCtrs->URIMisses          = g_pURICacheStats->GetMisses();
        pCacheCtrs->URIFlushes         = g_pURICacheStats->GetFlushes();
        pCacheCtrs->TotalURIFlushed    = g_pURICacheStats->GetTotalFlushed();

        pCacheCtrs->BlobCached         = g_pBlobCacheStats->GetBlobsCached();
        pCacheCtrs->TotalBlobCached    = g_pBlobCacheStats->GetTotalBlobsCached();
        pCacheCtrs->BlobHits           = g_pBlobCacheStats->GetHits();
        pCacheCtrs->BlobMisses         = g_pBlobCacheStats->GetMisses();
        pCacheCtrs->BlobFlushes        = g_pBlobCacheStats->GetFlushes();
        pCacheCtrs->TotalBlobFlushed   = g_pBlobCacheStats->GetTotalFlushed();

        QueryMemoryCacheStatistics( pCacheCtrs, FALSE );

    } else {
        //
        // Either we're reporting for a specific service
        // or stats are not set up. Set all cache
        // counters to zero.
        //
        pCacheCtrs->FilesCached = 0;
        pCacheCtrs->TotalFilesCached = 0;
        pCacheCtrs->FileHits = 0;
        pCacheCtrs->FileMisses = 0;
        pCacheCtrs->FileFlushes = 0;
        pCacheCtrs->FlushedEntries = 0;
        pCacheCtrs->TotalFlushed = 0;

        pCacheCtrs->URICached = 0;
        pCacheCtrs->TotalURICached = 0;
        pCacheCtrs->URIHits = 0;
        pCacheCtrs->URIMisses = 0;
        pCacheCtrs->URIFlushes = 0;
        pCacheCtrs->TotalURIFlushed = 0;

        pCacheCtrs->BlobCached = 0;
        pCacheCtrs->TotalBlobCached = 0;
        pCacheCtrs->BlobHits = 0;
        pCacheCtrs->BlobMisses = 0;
        pCacheCtrs->BlobFlushes = 0;
        pCacheCtrs->TotalBlobFlushed = 0;

        QueryMemoryCacheStatistics( pCacheCtrs, TRUE );
    }

    return TRUE;
}

BOOL
TsCacheClearStatistics(
    IN  DWORD       dwServerMask
    )
/*++

  Routine Description:

    Clears the the specified service's statistics

--*/
{
    if ( dwServerMask > LAST_PERF_CTR_SVC )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  Currently this function isn't supported
    //

    SetLastError( ERROR_NOT_SUPPORTED );
    return FALSE;
} // TsCacheClearStatistics



const char * g_IISAuxCounterNames[] =
{
    "Aac Open URI Files",
    "Cac Calls to TsOpenURI()",
    "Cac Calls to TsCloseURI()",
    "Max Counters"
};



extern "C"
VOID
TsDumpCacheCounters( OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    DWORD  cb = 0;

    *lpcbBuffer = cb;
    return ;
} // TsDumpCacheCounters()






VOID
TsDumpHashTableStats( IN OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    CLKRHashTableStats hts;

    if (!g_pFileInfoTable) {
        *lpcbBuffer = 0;
        return;
    }

    hts = g_pFileInfoTable->GetStatistics();

    *lpcbBuffer = sprintf( pchBuffer,
                           "<TABLE>"
                           "<TR><TD>Record Count</TD><TD>%d</TD></TR>"
                           "<TR><TD>Table Size</TD><TD>%d</TD></TR>"
                           "<TR><TD>Directory Size</TD><TD>%d</TD></TR>"
                           "<TR><TD>Longest Chain</TD><TD>%d</TD></TR>"
                           "<TR><TD>Empty Slots</TD><TD>%d</TD></TR>"
                           "<TR><TD>Split Factor</TD><TD>%f</TD></TR>"
                           "<TR><TD>Average Search Length</TD><TD>%f</TD></TR>"
                           "<TR><TD>Expected Search Length</TD><TD>%f</TD></TR>"
                           "<TR><TD>Average Unsuccessful Search Length</TD><TD>%f</TD></TR>"
                           "<TR><TD>Expected Unsuccessful Search Length</TD><TD>%f</TD></TR>"
                           "</TABLE>",
                           hts.RecordCount,
                           hts.TableSize,
                           hts.DirectorySize,
                           hts.LongestChain,
                           hts.EmptySlots,
                           hts.SplitFactor,
                           hts.AvgSearchLength,
                           hts.ExpSearchLength,
                           hts.AvgUSearchLength,
                           hts.ExpUSearchLength );

}

VOID
TsDumpCacheToHtml( OUT CHAR * pchBuffer, IN OUT LPDWORD lpcbBuffer )
{
    LIST_ENTRY * pEntry;
    DWORD        cItemsOnBin = 0;
    DWORD        cTotalItems = 0;
    DWORD        i, c, cb;
    DWORD        cbTable;

    cb = wsprintf( pchBuffer,
                   " <h4>File Hash Table Stats</h4> " );

    TsDumpHashTableStats( pchBuffer + cb, &cbTable );
    cb += cbTable;

    cb += wsprintf( pchBuffer + cb,
                    " <h4>Some other stats</h4> ");

    if (g_pFileCacheStats) {
        g_pFileCacheStats->DumpToHtml(pchBuffer + cb, &cbTable);
        cb += cbTable;
    }

    DumpMemoryCacheToHtml( pchBuffer + cb, &cbTable );
    cb += cbTable;

    *lpcbBuffer = cb;

    return;
}  // TsDumpCacheToHtml()


//
// tsunami.cxx
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\capiutil.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    capiutil.cxx

Abstract:

    Utility functions for dealing with IIS-CAPI integration

Author:

    Alex Mallet (amallet)    02-Dec-1997

--*/

#include "tcpdllp.hxx"
#pragma hdrstop

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

//
// Local includes
//
#include "iiscert.hxx"
#include "capiutil.hxx"



BOOL RetrieveBlobFromMetabase(MB *pMB,
                              LPTSTR pszKey IN,
                              PMETADATA_RECORD pMDR OUT,
                              DWORD dwSizeHint OPTIONAL)
/*++

Routine Description:

    Tries to retrieve a value of variable length from the metabase

Arguments:

    pMB - pointer to open MB object
    pszKey - key whose value is to be read
    pMDR - pointer to metadata record to be used when reading the value. The pbMDData member
    will be updated on success
    dwSizeHint - if caller has idea of how big value might be, can set this to number of 
    bytes to try first retrieval call with

Returns:

   BOOL indicating whether value was read successfully

--*/
{
    BOOL fSuccess = FALSE;

    //
    // If caller has a clue, let's use it
    //
    if ( dwSizeHint )
    {
        pMDR->pbMDData = new UCHAR[dwSizeHint];

        if ( !(pMDR->pbMDData) )
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    pMDR->dwMDDataLen = (dwSizeHint ? dwSizeHint : 0);

    fSuccess = pMB->GetData( pszKey,
                             pMDR->dwMDIdentifier,
                             pMDR->dwMDUserType,
                             pMDR->dwMDDataType,
                             (VOID *) pMDR->pbMDData,
                             &(pMDR->dwMDDataLen),
                             pMDR->dwMDAttributes );
                             
                             
    if ( !fSuccess )
    {
        //
        // If buffer wasn't big enough, let's try again ...
        //
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            // We were brought up well, so we'll clean stuff up
            //
            if ( dwSizeHint )
            {
                delete [] pMDR->pbMDData;
            }

            pMDR->pbMDData = new UCHAR[pMDR->dwMDDataLen];

            if ( !(pMDR->pbMDData) )
            {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }

            fSuccess = pMB->GetData( pszKey,
                                     pMDR->dwMDIdentifier,
                                     pMDR->dwMDUserType,
                                     pMDR->dwMDDataType,
                                     (VOID *) pMDR->pbMDData,
                                     &(pMDR->dwMDDataLen),
                                     pMDR->dwMDAttributes );

            if ( !fSuccess )
            {
                //ah, sod it, can't do anymore
                delete [] pMDR->pbMDData;
                return FALSE;
            }
        }
    }

    if ( !fSuccess )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "RetrieveBlobFromMB failed, 0x%x\n", GetLastError()));
    }

    return fSuccess;

} //RetrieveBlobFromMetabase


BOOL CopyString( OUT LPTSTR *ppszDest,
                 IN LPTSTR pszSrc )
/*++

Routine Description:

   String-copy that uses "new" for memory allocation

Arguments:

   ppszDest - pointer to pointer to dest string
   pszSrc - pointer to source string

--*/

{
    if ( !pszSrc )
    {
        *ppszDest = NULL;
        return TRUE;
    }

    *ppszDest = new char[strlen(pszSrc) + 1];

    if ( !*ppszDest )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    memcpy( *ppszDest, pszSrc, strlen(pszSrc) + 1 );

    return TRUE;
}


OPEN_CERT_STORE_INFO* ReadCertStoreInfoFromMB( IN IMDCOM *pMDObject,
                                               IN LPTSTR pszMBPath,
                                               IN BOOL fCTL )
/*++

Routine Description:

    Read all the information necessary to open a CAPI store out of the metabase

Arguments:

    pMDObject - pointer to metabase object 
    pszMBPath - full path in metabase where cert store info is stored, starting from /
    fCTL - bool indicating whether info is to be used to reconstruct a CTL or a cert 

Returns:

   Pointer to filled out OPEN_CERT_STORE_INFO structure on success, NULL on failure.
   Note that only some of the OPEN_CERT_STORE_INFO fields are -required-; currently,
   only the store name is required. 

--*/

{
    DBG_ASSERT( pMDObject );
    DBG_ASSERT( pszMBPath );

    MB mb( pMDObject );
    BOOL fSuccess = FALSE;
    OPEN_CERT_STORE_INFO *pCertStoreInfo = NULL;

    pCertStoreInfo = AllocateCertStoreInfo();

    if ( !pCertStoreInfo )
    {
        return NULL;
    }

    //
    // Try to open the key for reading
    //
    if ( mb.Open( pszMBPath,
                  METADATA_PERMISSION_READ ))
    {
        DWORD dwReqDataLen = 0;
        METADATA_RECORD mdr;
     
        //
        //Try to retrieve container
        //
        MD_SET_DATA_RECORD(&mdr, 
                           (fCTL ? MD_SSL_CTL_CONTAINER : MD_SSL_CERT_CONTAINER), 
                           METADATA_NO_ATTRIBUTES, 
                           IIS_MD_UT_SERVER, STRING_METADATA, 
                           NULL,
                           0);
        
        if ( RetrieveBlobFromMetabase(&mb,
                                      NULL,
                                      &mdr) )

        {
            //
            // Metabase will return empty string if NULL string is stored
            //
            if ( !strcmp( (LPTSTR) mdr.pbMDData, TEXT("")) )
            {
                delete [] mdr.pbMDData;
                pCertStoreInfo->pszContainer = NULL;
            }
            else
            {
                pCertStoreInfo->pszContainer = (LPTSTR) mdr.pbMDData;
            }
        }

        //
        //Try to retrieve cert provider
        //
        MD_SET_DATA_RECORD(&mdr, 
                           (fCTL ? MD_SSL_CTL_PROVIDER : MD_SSL_CERT_PROVIDER), 
                           METADATA_NO_ATTRIBUTES, 
                           IIS_MD_UT_SERVER, STRING_METADATA, 
                           NULL,
                           0);
        
        if ( RetrieveBlobFromMetabase(&mb,
                                      NULL,
                                      &mdr) )


        {
            //
            // Metabase will return empty string if NULL string is stored
            //
            if ( !strcmp( (LPTSTR) mdr.pbMDData, TEXT("")) )
            {
                delete [] mdr.pbMDData;
                pCertStoreInfo->pszProvider = NULL;
            }
            else
            {
                pCertStoreInfo->pszProvider = (LPTSTR) mdr.pbMDData;
            }
        }

        //
        //Try to retrieve provider type
        //
        mb.GetDword( NULL,
                     (fCTL ? MD_SSL_CTL_PROVIDER_TYPE : MD_SSL_CERT_PROVIDER_TYPE),
                     IIS_MD_UT_SERVER,
                     &(pCertStoreInfo->dwProvType),
                     METADATA_NO_ATTRIBUTES );

        //
        //Retrieve open flags
        //
        mb.GetDword( NULL,
                     (fCTL ? MD_SSL_CTL_OPEN_FLAGS : MD_SSL_CERT_OPEN_FLAGS),
                     IIS_MD_UT_SERVER,
                     &(pCertStoreInfo->dwFlags),
                     METADATA_NO_ATTRIBUTES ) ;

        //
        //Try to retrieve store name
        //
        MD_SET_DATA_RECORD(&mdr, 
                           (fCTL ? MD_SSL_CTL_STORE_NAME : MD_SSL_CERT_STORE_NAME), 
                           METADATA_NO_ATTRIBUTES, 
                           IIS_MD_UT_SERVER, STRING_METADATA, 
                           NULL,
                           0);

        if ( !RetrieveBlobFromMetabase(&mb,
                                       NULL,
                                       &mdr) )

        {
            goto EndReadStoreInfo;
        }
        else
        {
            //
            // Metabase will return empty string if NULL string is stored, but
            // empty name is -NOT- valid !
            //
            if ( !strcmp( (LPTSTR) mdr.pbMDData, TEXT("")) )
            {
                delete [] mdr.pbMDData;
                goto EndReadStoreInfo;
            }
            else
            {
                pCertStoreInfo->pszStoreName = (LPTSTR) mdr.pbMDData;
            }
        }

        //
        // Everything succeeded
        //
        fSuccess = TRUE;
    }

EndReadStoreInfo:

    if ( !fSuccess )
    {
        DeallocateCertStoreInfo( pCertStoreInfo );
        pCertStoreInfo = NULL;
    }

    return ( pCertStoreInfo );
}


OPEN_CERT_STORE_INFO* AllocateCertStoreInfo()
/*++

Routine Description:

   Allocate and initialize the structure used to hold info about cert stores

Arguments:

   None

Returns:

   Allocated and initialized structure that should be cleaned up with a call to 
   DeallocateCertStoreInfo()

--*/
{
    OPEN_CERT_STORE_INFO *pStoreInfo = new OPEN_CERT_STORE_INFO;

    if ( pStoreInfo )
    {
        memset(pStoreInfo, 0, sizeof(OPEN_CERT_STORE_INFO));
    }

    return pStoreInfo;
}

VOID DeallocateCertStoreInfo( OPEN_CERT_STORE_INFO *pInfo )
/*++

Routine Description:

    Clean up the structure used to track information about a cert store

Arguments:

    pInfo - pointer to OPEN_CERT_STORE_INFO structure to be cleaned up

Returns:

   Nothing

--*/

{
    if ( !pInfo )
    {
        return ;
    }

    if ( pInfo->pszContainer )
    {
        delete [] pInfo->pszContainer;
        pInfo->pszContainer = NULL;
    }

    if ( pInfo->pszProvider )
    {
        delete pInfo->pszProvider;
        pInfo->pszProvider = NULL;
    }

    if ( pInfo->pszStoreName )
    {
        delete [] pInfo->pszStoreName;
        pInfo->pszStoreName = NULL;
    }

    if ( pInfo->hCertStore )
    {
        CertCloseStore( pInfo->hCertStore,
                        0 );
        pInfo->hCertStore = NULL;
    }

    delete pInfo;

}


BOOL
DuplicateCertStoreInfo( OUT OPEN_CERT_STORE_INFO **ppDestStoreInfo,
                        IN OPEN_CERT_STORE_INFO *pSrcStoreInfo )
/*++

Routine Description:

    Make a copy of cert store info

Arguments:

   ppDestStoreInfo - pointer to where copy of pSrcStoreInfo is to be placed
   pSrcStoreInfo - information to be copied

Returns:

   TRUE if copy was successful, FALSE if not

--*/


{
    *ppDestStoreInfo = NULL;
    OPEN_CERT_STORE_INFO *pNewStore = AllocateCertStoreInfo();

    if ( !pNewStore )
    {
        SetLastError( ERROR_OUTOFMEMORY);
        return (FALSE);
    }

    //
    // Copy the relevant items
    //
    if ( pSrcStoreInfo->pszContainer && 
         !CopyString( &pNewStore->pszContainer,
                      pSrcStoreInfo->pszContainer ) )
    {
        goto EndDuplicateInfo;
    }

    if ( pSrcStoreInfo->pszProvider && 
         !CopyString( &pNewStore->pszProvider,
                      pSrcStoreInfo->pszProvider ) )
    {
        goto EndDuplicateInfo;
    }

    //
    // Store name -cannot- be NULL
    //
    if ( !pSrcStoreInfo->pszStoreName )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Null store name !\n"));
        goto EndDuplicateInfo;
    }
    else if ( !CopyString( &pNewStore->pszStoreName,
                           pSrcStoreInfo->pszStoreName ) )
    {
        goto EndDuplicateInfo;
    }

    pNewStore->dwFlags = pSrcStoreInfo->dwFlags;
    pNewStore->dwProvType = pSrcStoreInfo->dwProvType;

    //
    // Duplicate the handle to the store
    //
    if ( !( pNewStore->hCertStore = CertDuplicateStore(pSrcStoreInfo->hCertStore) ))
    {
        goto EndDuplicateInfo;
    }


    //
    // Everything is happy, fill in the pointer
    //
    *ppDestStoreInfo = pNewStore;

EndDuplicateInfo:


    if ( !(*ppDestStoreInfo) )
    {
        DeallocateCertStoreInfo( pNewStore );
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


BOOL ServerAddressHasCAPIInfo( IN MB *pMB,
                               IN LPTSTR pszCredPath,
                               IN DWORD *adwProperties,
                               IN DWORD cProperties )
/*++

Routine Description:

    Checks whether the given MB path has info associated with it necessary to 
    reconstruct a particular CAPI structure eg certificate context, CTL context

Arguments:

     pMB - pointer to metabase object open for reading
     pszCredPath - path to where CAPI info would be stored, relative to pMB object
     adwProperties - array of metabase properties that must exist and be readable for the
     given CAPI object 
     cProperties - number of elements in pdwProperties array [ = 2 * # of properties]
Returns:

    TRUE if cert info exists, FALSE if not

--*/
{

    DBG_ASSERT( pMB );
    DBG_ASSERT( pszCredPath );

    BOOL fAllocated = FALSE;
    BOOL fAllData = TRUE;


    //
    // Iterate through each property, trying to retrieve it with a buffer size of zero;
    // If retrieving a property fails for any reason other than a buffer that's too 
    // small, assume the property doesn't exist
    //
    for (DWORD i = 0; i < cProperties/2; i++)
    {
        DWORD dwSize = 0;

        pMB->GetData( pszCredPath,
                      adwProperties[2*i],
                      IIS_MD_UT_SERVER,
                      adwProperties[2*i + 1],
                      NULL,
                      &dwSize,
                      METADATA_NO_ATTRIBUTES );
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER  )
        {
            fAllData = FALSE;
            break;
        }
    }

    return fAllData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\dbgutil.h ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :

           dbgutil.h

   Abstract:

      This module declares the macros to wrap around DEBUG_PRINTS class.
      This is the exported header file, which the client is allowed to
      modify for each application the accompanying pgmutils.dll is used.

   Author:

      Murali R. Krishnan    ( MuraliK )    22-Sept-1994

   Project:
       TEMPLATE

   Revision History:
      MuraliK  16-May-1995 Added macro for reading debug flags.
      MuraliK  1-Nov-1996  Use common macros from pudebug.h
--*/

# ifndef _DBGUTIL_H_
# define _DBGUTIL_H_


/************************************************************
 *     Include Headers
 ************************************************************/

// begin_user_modifiable

//
//  Modify the following flags if necessary
//

# define   DEFAULT_OUTPUT_FLAGS   ( DbgOutputStderr | DbgOutputLogFile | \
                                    DbgOutputKdb | DbgOutputTruncate)


// end_user_modifiable

# include <pudebug.h>


//
//  Define the debugging constants
//

#define DEBUG_OPLOCKS              0x00001000L

#define DEBUG_GATEWAY              0x00010000L
#define DEBUG_INSTANCE             0x00020000L
#define DEBUG_ENDPOINT             0x00040000L
#define DEBUG_METABASE             0x00080000L

#define DEBUG_DLL_EVENT_LOG        0x00100000L
#define DEBUG_DLL_SERVICE_INFO     0x00200000L
#define DEBUG_DLL_SECURITY         0x00400000L
#define DEBUG_DLL_CONNECTION       0x00800000L

#define DEBUG_DLL_RPC              0x01000000L
#define DEBUG_ODBC                 0x02000000L
#define DEBUG_MIME_MAP             0x04000000L
#define DEBUG_DLL_VIRTUAL_ROOTS    0x08000000L
# define DEBUG_VIRTUAL_ROOTS       (DEBUG_DLL_VIRTUAL_ROOTS)


# define DEBUG_DIR_LIST            0x10000000L
# define DEBUG_OPEN_FILE           0x20000000L
# define DEBUG_CACHE               0x40000000L
# define DEBUG_DIRECTORY_CHANGE    0x80000000L



# endif  /* _DBGUTIL_H_ */

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\authent.cxx ===
/*++







   Copyright    (c)    1995-1996    Microsoft Corporation

   Module  Name :

      authent.cxx

   Abstract:
      Authentication support functions for IIS

   Author:

       Murali R. Krishnan    ( MuraliK )     11-Dec-1996

   Environment:
       User Mode - Win32

   Project:

       Internet Server DLL

   Functions Exported:
       TCP_AUTHENT::*

   Revision History:

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include "tcpdllp.hxx"
#pragma hdrstop

#if 1 // DBCS
#include <mbstring.h>
#endif
# include "infosec.hxx"
#include "TokenAcl.hxx"
#include <softpub.h>
#include <wininet.h>
#include <wincrypt.h>

#include <iiscert.hxx>
#include <iisctl.hxx>
#include <sslinfo.hxx>

#if !defined(CRYPT_E_REVOKED)
#define CRYPT_E_REVOKED                  _HRESULT_TYPEDEF_(0x80092010L)
#endif
#if !defined(CRYPT_E_NO_REVOCATION_CHECK)
#define CRYPT_E_NO_REVOCATION_CHECK      _HRESULT_TYPEDEF_(0x80092012L)
#endif
#if !defined(CRYPT_E_REVOCATION_OFFLINE)
#define CRYPT_E_REVOCATION_OFFLINE       _HRESULT_TYPEDEF_(0x80092013L)
#endif


BOOL
IsCertificateVerified(
    PSecPkgContext_RemoteCredentialInfo pspRCI
        );
extern BOOL g_fCertCheckCA;

/************************************************************
 *    Functions
 ************************************************************/

BOOL
IsCertificateVerified(
    PSecPkgContext_RemoteCredentialInfo pspRCI
    )
{
    if ( g_fCertCheckCA )
    {
        return ((pspRCI->fFlags & RCRED_STATUS_UNKNOWN_ISSUER) == 0);
    }

    return TRUE;
}

TCP_AUTHENT::TCP_AUTHENT(
    DWORD AuthFlags
    )
/*++

Routine Description:

    Constructor for the Authentication class
Arguments:

    AuthFlags - One of the TCPAUTH_* flags.

--*/
    : _hToken          ( NULL ),
      _hSSPToken       ( NULL ),
      _hSSPPrimaryToken( NULL ),
      _fHaveCredHandle ( FALSE ),
      _fHaveCtxtHandle ( FALSE ),
      _fClient         ( FALSE ),
      _fUUEncodeData   ( FALSE ),
      _pDeleteFunction ( NULL ),
      _fBase64         ( FALSE ),
      _fKnownToBeGuest ( FALSE ),
      _pClientCertContext( NULL ),
      _pSslInfo            ( NULL ),
      _pServerX509Certificate( NULL ),
      _fCertCheckForRevocation( TRUE ),
      _fCertCheckCacheOnly( FALSE )
{
    if ( AuthFlags & TCPAUTH_SERVER )
    {
        DBG_ASSERT( !(AuthFlags & TCPAUTH_CLIENT));
    }

    if ( AuthFlags & TCPAUTH_CLIENT )
    {
        _fClient = TRUE;
    }

    if ( AuthFlags & TCPAUTH_UUENCODE )
    {
        _fUUEncodeData = TRUE;
    }

    if ( AuthFlags & TCPAUTH_BASE64 )
    {
        _fBase64 = TRUE;
    }

    DBG_REQUIRE( Reset( TRUE ) );
}

/*******************************************************************/

TCP_AUTHENT::~TCP_AUTHENT(
    )
/*++

Routine Description:

    Destructor for the Authentication class

--*/
{
    Reset( TRUE );
}


BOOL
TCP_AUTHENT::DeleteCachedTokenOnReset(
    VOID
    )
{
    if ( _hToken != NULL )
    {
        CACHED_TOKEN *pct = (CACHED_TOKEN*)_hToken;
        DBG_ASSERT( _fClearText );
        RemoveTokenFromCache( pct);
    }

    return TRUE;
}


BOOL
TCP_AUTHENT::Reset(
    BOOL fSessionReset
    )
/*++

Routine Description:

    Resets this object in preparation for a brand new conversation

--*/
{
    if ( _hToken != NULL )
    {
        DBG_ASSERT( _fClearText );
        TsDeleteUserToken( _hToken );

        _hToken = NULL;
    }

    if ( _hSSPToken )
    {
        ////if ( !_pDeleteFunction )
        {
            CloseHandle( _hSSPToken );
        }

        //
        //  Don't delete the SSPI Token as we queried it directly from SSPI
        //

        _hSSPToken = NULL;
    }

    //
    //  We close this token because we duplicated it from _hSSPToken
    //

    if ( _hSSPPrimaryToken )
    {
        CloseHandle( _hSSPPrimaryToken );
        _hSSPPrimaryToken = NULL;
    }

    if ( _pDeleteFunction )
    {
        (_pDeleteFunction)( &_hctxt, _pDeleteArg );
        _pDeleteFunction = NULL;
        _fHaveCtxtHandle = FALSE;
        _fHaveCredHandle = FALSE;
    }
    else
    {
        if ( _fHaveCtxtHandle )
        {
            pfnDeleteSecurityContext( &_hctxt );
            _fHaveCtxtHandle = FALSE;
        }

        if ( _fHaveCredHandle )
        {
            pfnFreeCredentialsHandle( &_hcred );
            _fHaveCredHandle = FALSE;
        }
    }

    if ( fSessionReset )
    {
        if ( _pClientCertContext )
        {
            (pfnFreeCertCtxt)( _pClientCertContext );
            _pClientCertContext = NULL;
        }
        if ( _pServerX509Certificate )
        {
            (fnFreeCert)( _pServerX509Certificate );
            _pServerX509Certificate = NULL;
        }
        _phSslCtxt        = NULL;
        _fCertCheckForRevocation = TRUE;
        _fCertCheckCacheOnly = FALSE;

        if ( _pSslInfo )
        {
            IIS_SSL_INFO::Release( _pSslInfo );

            _pSslInfo = NULL;
        }
    }

    _fNewConversation = TRUE;
    _fClearText       = FALSE;
    _fHaveAccessTokens= FALSE;
    _cbMaxToken       = 0;
    _fDelegate        = FALSE;

    _pDeleteArg       = NULL;
    _fKnownToBeGuest  = FALSE;
    _fHaveExpiry      = FALSE;

    return TRUE;
}

/*******************************************************************/


BOOL
TCP_AUTHENT::SetSecurityContextToken(
    CtxtHandle* pCtxt,
    HANDLE hPrimaryToken,
    SECURITY_CONTEXT_DELETE_FUNCTION pFn,
    PVOID pArg,
    IIS_SSL_INFO *pSslInfo
    )
/*++

Routine Description:

    Store security context & impersonation token

Arguments:

    pCtxt - SSPI security context
    hPrimaryToken - access token associated with security context
    pFn - function to call to notify security context destruction
    pArg - argument for pFn call
    pSslInfo - pointer to SSL info object to be used for this security context

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( hPrimaryToken != NULL )
    {
        if ( _hSSPToken )
        {
            CloseHandle( _hSSPToken );
            _hSSPToken = NULL;
        }

        if ( _hSSPPrimaryToken )
        {
            CloseHandle( _hSSPPrimaryToken );
            _hSSPPrimaryToken = NULL;
        }

        AdjustTokenPrivileges( hPrimaryToken, TRUE, NULL, NULL, NULL, NULL );
        if ( g_pTokPrev )
        {
            AdjustTokenPrivileges( hPrimaryToken,
                                   FALSE,
                                   g_pTokPrev,
                                   NULL,
                                   NULL,
                                   NULL );
        }

        //
        //  We need to convert the NTLM primary token into a
        //  impersonation token
        //

        if ( !pfnDuplicateTokenEx( hPrimaryToken,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityImpersonation,
                                TokenImpersonation,
                                &_hSSPToken ))
        {
            DBGPRINTF(( DBG_CONTEXT,
                        "[SetSecurityContextToken] DuplicateToken failed, error %lx\n",
                        GetLastError() ));

            return FALSE;
        }

        // Bug 86498:
        // Grant all access to the token for "Everyone" so that ISAPIs that run out of proc
        // can do an OpenThreadToken call
        HRESULT hr;
        if (FAILED( hr = GrantAllAccessToToken( _hSSPToken ) ) )
        {
            DBG_ASSERT( FALSE );
            DBGPRINTF(( DBG_CONTEXT,
                        "[SetSecurityContextToken] Failed to grant access to the token to everyone, error %lx\n",
                        hr ));
            return FALSE;
        }

        _hSSPPrimaryToken = hPrimaryToken;

        _hctxt = *pCtxt;
        _fHaveCtxtHandle = TRUE;
        _pDeleteFunction = pFn;
        _pDeleteArg = pArg;
    }

    _phSslCtxt = pCtxt;

    if ( _pSslInfo )
    {
        IIS_SSL_INFO::Release( _pSslInfo );
    }
    _pSslInfo = pSslInfo;

    return TRUE;
}


BOOL
TCP_AUTHENT::IsForwardable(
    VOID
    ) const
/*++

Routine Description:

    returns TRUE if auth info is forwardable ( e.g. kerberos )

Arguments:

    None

Return Value:

    TRUE if forwardable, otherwise FALSE

--*/
{
    return _fDelegate;
}


BOOL
TCP_AUTHENT::IsSslCertPresent(
    )
/*++

Routine Description:

    Check if SSL cert bound on this security context

Arguments:

    None

Return Value:

    TRUE if SSL cert present, otherwise FALSE

--*/
{
    return _phSslCtxt != NULL;
}


static BOOL IsValidKeyUsageForClientCert(
    PCCERT_CONTEXT pCliCert
    )
/*++

Routine Description:

    private routine checkin extended key usage validity for client certificate

Arguments:

    pCliCert - client certificate to be verified

Return Value:

    TRUE if client cert usage is valid, otherwise FALSE
    in the case of any error FALSE is returned and GetLastError() can be used to 
    retrieve the error code

--*/

{
    HRESULT                     hr = S_OK;
    BOOL                        fRet = TRUE;
    DWORD                       dwRet = ERROR_SUCCESS;
    const DWORD                 cbDefaultEnhKeyUsage = 100;
    STACK_BUFFER(               buffEnhKeyUsage, cbDefaultEnhKeyUsage );
    PCERT_ENHKEY_USAGE          pCertEnhKeyUsage = NULL;
    DWORD                       cbEnhKeyUsage = cbDefaultEnhKeyUsage;
    BOOL                        fEnablesClientAuth = FALSE;

    //
    // Now verify extended usage flags (only for the end certificate)
    //

    fRet = CertGetEnhancedKeyUsage( pCliCert,
                                    0,             //dwFlags,
                                    (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr(),
                                    &cbEnhKeyUsage );
    dwRet = GetLastError();
                                    
    if ( !fRet && ( dwRet == ERROR_MORE_DATA ) )
    {
        //
        // Resize buffer
        //
        if ( !buffEnhKeyUsage.Resize( cbEnhKeyUsage ) ) 
        {
            dwRet = GetLastError();
            goto ExitPoint;
        }
        fRet = CertGetEnhancedKeyUsage( pCliCert,
                                        0,             //dwFlags,
                                        (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr(),
                                        &cbEnhKeyUsage );
        dwRet = GetLastError();
    }
    if ( !fRet )
    {
        //
        // Bad.  Couldn't get the Enhanced Key Usage
        //
        
        goto ExitPoint;
    } 

    pCertEnhKeyUsage = (PCERT_ENHKEY_USAGE) buffEnhKeyUsage.QueryPtr();

    //
    // If the cUsageIdentifier member is zero (0), the certificate might be valid 
    // for all uses or the certificate it might have no valid uses. The return from 
    // a call to GetLastError can be used to determine whether the certificate is 
    // good for all uses or for no uses. If GetLastError returns CRYPT_E_NOT_FOUND 
    // if the certificate is good for all uses. If it returns zero (0), the 
    // certificate has no valid uses 
    //
    
    if ( pCertEnhKeyUsage->cUsageIdentifier == 0 )
    {
        if ( dwRet == CRYPT_E_NOT_FOUND )
        {
            //
            // Certificate valid for any use
            //
            fEnablesClientAuth = TRUE; 
        }
        else
        {
            //
            // Certificate NOT valid for any use
            //
        }
    }
    else
    {
        //
        // Find out if pCertEnhKeyUsage enables CLIENT_AUTH
        //
        for ( DWORD i = 0; i < pCertEnhKeyUsage->cUsageIdentifier; i++ )
        {
            DBG_ASSERT( pCertEnhKeyUsage->rgpszUsageIdentifier[i] != NULL );

            if ( strcmp( pCertEnhKeyUsage->rgpszUsageIdentifier[i], szOID_PKIX_KP_CLIENT_AUTH ) == 0 )
            {
                //
                // certificate enables CLIENT_AUTH
                //
                fEnablesClientAuth = TRUE; 
                break;
            }
        }
    }

    //
    // If ExtendedKeyUsage doesn't enable CLIENT_AUTH then add flag to CertFlags
    //
ExitPoint:    
    return fEnablesClientAuth;
}


BOOL
TCP_AUTHENT::QueryCertificateInfo(
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate information from SSL security context

Arguments:

    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SECURITY_STATUS                    ss;
    CERT_REVOCATION_STATUS             CertRevocationStatus;
    SecPkgContext_RemoteCredentialInfo spRCI;
    HCERTCHAINENGINE hEngine = NULL;
    PCCERT_CHAIN_CONTEXT pCertChain = NULL;

    if ( _pClientCertContext != NULL )
    {
        *pfNoCert = FALSE;
        return TRUE;
    }

    //
    // NULL handle <==> no certificate
    //

    if ( _phSslCtxt == NULL || pfnFreeCertCtxt == NULL )
    {
        goto LNoCertificate;
    }

    //
    // get cert context - if null, we have no certificate
    //

    DBG_ASSERT( RtlValidateProcessHeaps() );

    ss = (pfnQueryContextAttributes)( _phSslCtxt,
                                      SECPKG_ATTR_REMOTE_CERT_CONTEXT,
                                      &_pClientCertContext );


    DBG_ASSERT( RtlValidateProcessHeaps() );

    if ( ss || _pClientCertContext == NULL ) {

        goto LNoCertificate;
    }

    
    //
    // Try to verify the client certificate
    //

#if DBG
    CHAR szSubjectName[1024];
    if ( CertGetNameString( _pClientCertContext,
                            CERT_NAME_SIMPLE_DISPLAY_TYPE,
                            0,
                            NULL,
                            szSubjectName,
                            1024 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Verifying client cert for %s \n", 
                   szSubjectName));
    }

    if ( CertGetNameString( _pClientCertContext,
                            CERT_NAME_SIMPLE_DISPLAY_TYPE,
                            CERT_NAME_ISSUER_FLAG,
                            NULL,
                            szSubjectName,
                            1024 ) )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Client cert issued by %s \n", 
                   szSubjectName));
    }
#endif

    _dwX509Flags = RCRED_CRED_EXISTS;

    if ( _pSslInfo && _pSslInfo->GetCertChainEngine( &hEngine ) )
    {
        //
        // Don't set any usage bits, because there are probably lots of certs floating
        // around out there with no usage bits and we don't want to break them
        // 
        // CODEWORK : might want to consider adding eg MB flag that allows setting of
        // required usage bits on certs
        //
        DWORD dwRevocationFlags = 0;
        DWORD dwCacheFlags = 0;
        CERT_CHAIN_PARA CCP;
        memset( &CCP, 0, sizeof( CCP ) );
        CCP.cbSize = sizeof(CCP);

        DBG_ASSERT( RtlValidateProcessHeaps() );

        //
        // Determine the CertGetCertificateChain() flags related to revocation
        // checking and cache retrieval 
        //
        
        dwRevocationFlags = ( _fCertCheckForRevocation 
                              || g_fCertCheckForRevocation ) 
                              ? CERT_CHAIN_REVOCATION_CHECK_CHAIN : 0;

        dwCacheFlags = _fCertCheckCacheOnly 
                       ? CERT_CHAIN_REVOCATION_CHECK_CACHE_ONLY : 0;

        if ( CertGetCertificateChain( hEngine,
                                      _pClientCertContext, 
                                      NULL,
                                      _pClientCertContext->hCertStore,
                                      &CCP,
                                      dwRevocationFlags | dwCacheFlags,
                                      NULL,
                                      &pCertChain ) )
        {
            //
            // Got a chain, look at the status bits and see whether we like it
            //
            DWORD dwChainStatus = pCertChain->TrustStatus.dwErrorStatus;

            if ( ( dwChainStatus & CERT_TRUST_IS_NOT_TIME_VALID ) ||
                 ( dwChainStatus & CERT_TRUST_CTL_IS_NOT_TIME_VALID ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Cert/CTL is not time-valid\n"));

                _dwX509Flags |= CRED_STATUS_INVALID_TIME;
            }


            if ( ( dwChainStatus & CERT_TRUST_IS_UNTRUSTED_ROOT ) ||
                 ( dwChainStatus & CERT_TRUST_IS_PARTIAL_CHAIN ) )
            {
                //
                // If we sign our CTLs, then we should be able to construct a complete
                // chain up to a trusted root for valid client certs, so we just look at 
                // the status bits of the chain.
                //
                // If our CTLs are not signed, we have to manually check whether the cert at the
                // top of the chain is in our CTL
                //

#if SIGNED_CTL
                DBGPRINTF((DBG_CONTEXT,
                           "Cert doesn't chain up to a trusted root\n"));

                _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;

#else //SIGNED_CTL

                PCERT_SIMPLE_CHAIN pSimpleChain = pCertChain->rgpChain[pCertChain->cChain - 1];

                PCERT_CHAIN_ELEMENT pChainElement = 
                    pSimpleChain->rgpElement[pSimpleChain->cElement - 1];

                PCCERT_CONTEXT pChainTop = pChainElement->pCertContext;

                BOOL fContains = FALSE;

                if ( !_pSslInfo->CTLContainsCert( pChainTop,
                                                  &fContains ) ||
                     !fContains )
                {
                    _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
                }
#endif //SIGNED_CTL
            }

            if ( ( dwChainStatus & CERT_TRUST_IS_NOT_SIGNATURE_VALID ) || 
                 ( dwChainStatus & CERT_TRUST_CTL_IS_NOT_SIGNATURE_VALID ) ||
                 ( !IsValidKeyUsageForClientCert(_pClientCertContext) ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Cert/CTL is not signature valid\n"));
                //
                // if the signature has been tampered with, we'll just treat it
                // as an unknown issuer
                //
                _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
            }

            if ( dwChainStatus & CERT_TRUST_CTL_IS_NOT_VALID_FOR_USAGE )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "CTL isn't valid for usage\n"));
            }

            //
            // If we were supposed to check for revocation and we couldn't do so,
            // treat it as if it were revoked ... ? 
            //
            
            if ( _fCertCheckForRevocation || g_fCertCheckForRevocation )
            {
                BOOL                fRevoke = FALSE;
                
                if ( dwChainStatus & CERT_TRUST_IS_REVOKED )
                {
                    fRevoke = TRUE;
                }
                else if ( dwChainStatus & CERT_TRUST_REVOCATION_STATUS_UNKNOWN )
                {
                    PCERT_SIMPLE_CHAIN      pSimpleChain;
                    PCERT_CHAIN_ELEMENT     pChainElement;
                    PCERT_REVOCATION_INFO   pRevocationInfo;
                    DWORD                   dwCounter;
                    
                    pSimpleChain = pCertChain->rgpChain[ 0 ];
                    
                    for ( dwCounter = 0;
                          dwCounter < pSimpleChain->cElement;
                          dwCounter++ )
                    {
                        pChainElement = pSimpleChain->rgpElement[ dwCounter ];
                        pRevocationInfo = pChainElement->pRevocationInfo;

                        if ( pRevocationInfo &&
                             ( ( pRevocationInfo->dwRevocationResult == CRYPT_E_REVOKED ) ||
                             ( pRevocationInfo->dwRevocationResult != CRYPT_E_NO_REVOCATION_CHECK ) ) )
                        {
                            fRevoke = TRUE;
                            break;
                        }
                    }
                }
            
                if ( fRevoke )
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "'Certificate revoked' or 'CRL needed but not found'\n" ));
                    
                    _dwX509Flags |= CRED_STATUS_REVOKED;
                }
            }
                 
            CertFreeCertificateChain( pCertChain );
            pCertChain = NULL;
        }
        else
        {
            //
            // We don't know anything about the client cert, so treat it as being
            // issued by an unknown CA
            //
            DBGPRINTF((DBG_CONTEXT,
                       "Couldn't get certificate chain : 0x%d\n",
                       GetLastError()));

            _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
        }
    }
    else
    {
        //
        // We don't know anything about the client cert, so treat it as being issued by
        // an unknown CA
        //

        DBGPRINTF((DBG_CONTEXT,
                   "Can't check anything about the client cert\n"));

        _dwX509Flags |= RCRED_STATUS_UNKNOWN_ISSUER;
    }

    DBG_ASSERT( RtlValidateProcessHeaps() );

    *pfNoCert = FALSE;

    return TRUE;

LNoCertificate:

    *pfNoCert = TRUE;
    return FALSE;
}



BOOL
TCP_AUTHENT::QueryServerCertificateInfo(
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get servercertificate information from SSL security context

Arguments:

    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SECURITY_STATUS                     ss;
    _SecPkgContext_LocalCredentialInfo  spcRCI;

    if ( _pServerX509Certificate == NULL )
    {
        if ( _phSslCtxt == NULL
             || fnCrackCert == NULL
             || fnFreeCert == NULL )
        {
            *pfNoCert = TRUE;
            return FALSE;
        }

        ss = pfnQueryContextAttributes( _phSslCtxt,
                                     SECPKG_ATTR_LOCAL_CRED,
                                     &spcRCI );

        if ( ss != STATUS_SUCCESS || !spcRCI.cCertificates )
        {
            *pfNoCert = FALSE;
            SetLastError( ss );
            return FALSE;
        }

        if ( !(fnCrackCert)( spcRCI.pbCertificateChain,
                             spcRCI.cbCertificateChain,
                             0,
                             &_pServerX509Certificate ) )
        {
            pfnFreeContextBuffer(spcRCI.pbCertificateChain);

            *pfNoCert = FALSE;
            return FALSE;
        }
        _dwServerX509Flags = spcRCI.fFlags;
        _dwServerBitsInKey = spcRCI.dwBits;

        pfnFreeContextBuffer(spcRCI.pbCertificateChain);
    }

    return TRUE;
}


BOOL
TCP_AUTHENT::QueryEncryptionKeySize(
    LPDWORD pdw,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get encryption session key size

Arguments:

    pdw - updated with number of bits in key size
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    SecPkgContext_KeyInfo   ski;
    SECURITY_STATUS         ss;

    if ( _phSslCtxt == NULL )
    {
        *pfNoCert = TRUE;
        return FALSE;
    }

    ss = pfnQueryContextAttributes( _phSslCtxt,
                                 SECPKG_ATTR_KEY_INFO,
                                 &ski );

    if ( ss != STATUS_SUCCESS )
    {
        SetLastError( ss );
        *pfNoCert = FALSE;

        return FALSE;
    }

    *pdw = ski.KeySize;
    
    if ( ski.sSignatureAlgorithmName )
    {
        pfnFreeContextBuffer( ski.sSignatureAlgorithmName );
    }
    
    if ( ski.sEncryptAlgorithmName )
    {
        pfnFreeContextBuffer( ski.sEncryptAlgorithmName );
    }

    return TRUE;
}


BOOL
TCP_AUTHENT::QueryEncryptionServerPrivateKeySize(
    LPDWORD pdw,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get encryption server private key size

Arguments:

    pdw - updated with number of bits in key size
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryServerCertificateInfo( pfNoCert ) )
    {
        *pdw = _dwServerBitsInKey;

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryServerCertificateIssuer(
    LPSTR* ppIssuer,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get server certificate Issuer information from SSL security context

Arguments:

    ppIssuer - updated with ptr to Issuer name
               guaranteed to remain valid until auth Reset()
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryServerCertificateInfo( pfNoCert ) )
    {
        *ppIssuer = _pServerX509Certificate->pszIssuer;

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryServerCertificateSubject(
    LPSTR* ppSubject,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get server certificate Subject information from SSL security context

Arguments:

    ppSubject - updated with ptr to Subject name
               guaranteed to remain valid until auth Reset()
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryServerCertificateInfo( pfNoCert ) )
    {
        *ppSubject = _pServerX509Certificate->pszSubject;

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryCertificateIssuer(
    LPSTR   pIssuer,
    DWORD   dwIssuerMaxLen,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate Issuer information from SSL security context

Arguments:

    pIssuer - ptr to buffer filled with Issuer name
    dwIssuerMaxLen - size of pIssuer
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryCertificateInfo( pfNoCert) && pfnCertNameToStrA )
    {
        pfnCertNameToStrA( _pClientCertContext->dwCertEncodingType,
                           &_pClientCertContext->pCertInfo->Issuer,
                           CERT_X500_NAME_STR,
                           pIssuer,
                           dwIssuerMaxLen );

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryCertificateFlags(
    LPDWORD pdwFlags,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate flags information from SSL security context

Arguments:

    pdwFlags - updated with certificate flags
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryCertificateInfo( pfNoCert ) )
    {
        *pdwFlags = _dwX509Flags;

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryCertificateSubject(
    LPSTR   pSubject,
    DWORD   dwSubjectMaxLen,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate Subject information from SSL security context

Arguments:

    ppSubject - updated with ptr to Subject name
                guaranteed to remain valid until auth Reset()
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryCertificateInfo( pfNoCert) && pfnCertNameToStrA )
    {
        pfnCertNameToStrA( _pClientCertContext->dwCertEncodingType,
                           &_pClientCertContext->pCertInfo->Subject,
                           CERT_X500_NAME_STR,
                           pSubject,
                           dwSubjectMaxLen );

        return TRUE;
    }

    return FALSE;
}


BOOL
TCP_AUTHENT::QueryCertificateSerialNumber(
    LPBYTE* ppSerialNumber,
    LPDWORD pdwLen,
    LPBOOL  pfNoCert
    )
/*++

Routine Description:

    Get certificate serial number information from SSL security context

Arguments:

    ppSerialNumber - updated with ptr to serial number as
                     array of bytes
                     guaranteed to remain valid until auth Reset()
    pdwLen - length of serial number
    pfNoCert - updated with TRUE if no cert

Return Value:

    TRUE on success, FALSE on failure

--*/
{
    if ( QueryCertificateInfo( pfNoCert ) )
    {
        *ppSerialNumber = _pClientCertContext->pCertInfo->SerialNumber.pbData;

        *pdwLen = _pClientCertContext->pCertInfo->SerialNumber.cbData;

        return TRUE;
    }

    return FALSE;
}


HANDLE
TCP_AUTHENT::QueryPrimaryToken(
    VOID
    )
/*++

Routine Description:

    Returns a non-impersonated token suitable for use with CreateProcessAsUser

--*/
{
    SECURITY_STATUS sc;

    if ( _hToken && _fClearText )
    {
        return CTO_TO_TOKEN( _hToken );
    }
    else if ( _fHaveAccessTokens )
    {
        return _hSSPPrimaryToken;
    }
    else if ( _fHaveCtxtHandle )
    {
        if ( !_hSSPPrimaryToken )
        {
            if ( !_hSSPToken )
            {
                sc = pfnQuerySecurityContextToken( &_hctxt,
                                                &_hSSPToken );

                if ( !NT_SUCCESS( sc ))
                {
                    DBGPRINTF(( DBG_CONTEXT,
                                "[QueryPrimaryToken] QuerySecurityContext failed, error 0x%lx\n",
                                sc ));

                    SetLastError( sc );

                    return NULL;
                }

                // Bug 86498:
                // Grant all access to the token for "Everyone" so that ISAPIs that run out of proc
                // can do an OpenThreadToken call
                HRESULT hr;
                if (FAILED( hr = GrantAllAccessToToken( _hSSPToken ) ) )
                {
                    DBG_ASSERT( FALSE );
                    DBGPRINTF(( DBG_CONTEXT,
                                "[QueryPrimaryToken] Failed to grant access to the token to everyone, error %lx\n",
                                hr ));
                    return FALSE;
                }

                AdjustTokenPrivileges( _hSSPToken, TRUE, NULL, NULL, NULL, NULL );
                if ( g_pTokPrev )
                {
                    AdjustTokenPrivileges( _hSSPToken,
                                           FALSE,
                                           g_pTokPrev,
                                           NULL,
                                           NULL,
                                           NULL );
                }
            }

            //
            //  We need to convert the NTLM impersonation token into a
            //  primary token
            //

            if ( !pfnDuplicateTokenEx( _hSSPToken,
                                    TOKEN_ALL_ACCESS,
                                    NULL,
                                    SecurityImpersonation,
                                    TokenPrimary,
                                    &_hSSPPrimaryToken ))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[QueryPrimaryToken] DuplicateToken failed, error %lx\n",
                            GetLastError() ));
            }
        }

        return _hSSPPrimaryToken;
    }

    SetLastError( ERROR_INVALID_HANDLE );
    return NULL;
}

HANDLE
TCP_AUTHENT::QueryImpersonationToken(
    VOID
    )
/*++

Routine Description:

    Returns an impersonation token for use with APIs like AccessCheck.

--*/
{
    SECURITY_STATUS sc;

    if ( _hToken && _fClearText )
    {
        return ((CACHED_TOKEN *) _hToken)->QueryImpersonationToken();
    }
    else if ( _fHaveAccessTokens )
    {
        return _hSSPToken;
    }
    else if ( _fHaveCtxtHandle )
    {
        //
        //  We don't need to impersonate since this is already an impersonation
        //  token
        //

        if ( !_hSSPToken )
        {
            sc = pfnQuerySecurityContextToken( &_hctxt,
                                            &_hSSPToken );

            if ( !NT_SUCCESS( sc ))
            {
                DBGPRINTF(( DBG_CONTEXT,
                            "[QueryImpersonationToken] QuerySecurityContext failed, error 0x%lx\n",
                            sc ));

                SetLastError( sc );

                return NULL;
            }

            // Bug 86498:
            // Grant all access to the token for "Everyone" so that ISAPIs that run out of proc
            // can do an OpenThreadToken call
            HRESULT hr;
            if (FAILED( hr = GrantAllAccessToToken( _hSSPToken ) ) )
            {
                DBG_ASSERT( FALSE );
                DBGPRINTF(( DBG_CONTEXT,
                            "[QueryImpersonationToken] Failed to grant access to the token to everyone, error %lx\n",
                            hr ));
                return NULL;
            }

            AdjustTokenPrivileges( _hSSPToken, TRUE, NULL, NULL, NULL, NULL );
            if ( g_pTokPrev )
            {
                AdjustTokenPrivileges( _hSSPToken,
                                       FALSE,
                                       g_pTokPrev,
                                       NULL,
                                       NULL,
                                       NULL );
            }
        }

        return _hSSPToken;
    }

    SetLastError( ERROR_INVALID_HANDLE );
    return NULL;
}


BOOL
TCP_AUTHENT::IsGuest(
    BOOL fIsImpersonated
    )
/*++

Routine Description:

    Returns TRUE if the account is the guest account

--*/
{
    fIsImpersonated;    // Unreferenced variable

    if ( _fHaveCtxtHandle )
    {
        return _fKnownToBeGuest;
    }

    return IsGuestUser( GetUserHandle() );
}

BOOL TCP_AUTHENT::EnumAuthPackages(
    BUFFER * pBuff
    )
/*++

Routine Description:

    Places a double null terminated list of authentication packages on the
    system in pBuff that looks like:

    NTLM\0
    MSKerberos\0
    Netware\0
    \0

Arguments:

    pBuff       - Buffer to receive list

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{

    SECURITY_STATUS   ss;
    PSecPkgInfo       pPackageInfo = NULL;
    ULONG             cPackages;
    ULONG             i;
    ULONG             fCaps;
    DWORD             cbBuffNew = 0;
    DWORD             cbBuffOld = 0;


    if ( !pBuff->Resize( 64 ) )
        return FALSE;

    //
    //  Get the list of security packages on this machine
    //

    ss = pfnEnumerateSecurityPackages( &cPackages,
                                    &pPackageInfo );

    if ( ss != STATUS_SUCCESS )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[EnumAuthPackages] Failed with error %d\n",
                    ss ));

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return FALSE;
    }

    for ( i = 0; i < cPackages ; i++ )
    {
        //
        //  We'll only use the security package if it supports connection
        //  oriented security and it supports the appropriate side (client
        //  or server)
        //

        fCaps = pPackageInfo[i].fCapabilities;

        if ( fCaps & SECPKG_FLAG_CONNECTION )
        {
            if ( (fCaps & SECPKG_FLAG_CLIENT_ONLY) && !_fClient )
                continue;

            cbBuffNew += strlen( pPackageInfo[i].Name ) + 1;

            if ( pBuff->QuerySize() < cbBuffNew )
            {
                if ( !pBuff->Resize( cbBuffNew + 64 ))
                {
                    pfnFreeContextBuffer( pPackageInfo );
                    return FALSE;
                }
            }

            strcpy( (CHAR *)pBuff->QueryPtr() + cbBuffOld,
                    pPackageInfo[i].Name );

            cbBuffOld = cbBuffNew;
        }
    }

    *((CHAR *)pBuff->QueryPtr() + cbBuffOld) = '\0';

    pfnFreeContextBuffer( pPackageInfo );

    return TRUE;

} // EnumAuthPackages


BOOL
TCP_AUTHENT::QueryExpiry(
    PTimeStamp pExpiry
    )
/*++

Routine Description:

    Queries the expiration date/time for a SSPI logon

Arguments:

    pExpiry - ptr to buffer to update with expiration date

Return Value:

    TRUE if successful, FALSE if not available

--*/
{
    SECURITY_STATUS                ss;
    SecPkgContext_PasswordExpiry   speExpiry;

    if ( _fHaveCtxtHandle && !_pDeleteFunction )
    {
        ss = pfnQueryContextAttributes( &_hctxt,
                                     SECPKG_ATTR_PASSWORD_EXPIRY,
                                     &speExpiry );

        if ( ss != STATUS_SUCCESS )
        {
            ((LARGE_INTEGER*)pExpiry)->HighPart = 0x7fffffff;
            ((LARGE_INTEGER*)pExpiry)->LowPart = 0xffffffff;
            SetLastError( ss );
            return FALSE;
        }

        memcpy( pExpiry,
                &speExpiry.tsPasswordExpires,
                sizeof(speExpiry.tsPasswordExpires) );

        return TRUE;
    }
    else if ( _fHaveExpiry )
    {
        memcpy( pExpiry, (LPVOID)&_liPwdExpiry, sizeof(_liPwdExpiry) );
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
TCP_AUTHENT::QueryFullyQualifiedUserName(
    LPSTR                   pszUser,
    STR *                   pstrU,
    PIIS_SERVER_INSTANCE    psi,
    PTCP_AUTHENT_INFO       pTAI
    )
/*++

Routine Description:

    Get fully qualified user name ( domain \ user name )

Arguments:

    pszUser - user name ( prefixed by optional domain )
    strU - string updated with fully qualified name
    psi - server instance data

Return Value:

    TRUE if successful, FALSE otherwise

--*/
{
    CHAR        szDomainAndUser[IIS_DNLEN+UNLEN+2];

    //
    //  Empty user defaults to the anonymous user
    //

    if ( !pszUser || *pszUser == '\0' )
    {
        return FALSE;
    }

    //
    //  Validate parameters & state.
    //
    
    if ( strlen( pszUser ) >= sizeof( szDomainAndUser ) )
    {   
        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        return FALSE;
    }

    //
    //  Save a copy of the domain\user so we can squirrel around
    //  with it a bit.
    //

    int cL = 0;

    //
    // prepend default logon domain if no domain
    // and the default user name was not used
    //

    if ( strchr( pszUser, '/' ) == NULL
#if 1 // DBCS enabling for user name
         && _mbschr( (PUCHAR)pszUser, '\\' ) == NULL )
#else
         && strchr( pszUser, '\\' ) == NULL )
#endif
    {
        psi->LockThisForRead();
        PCSTR pD = pTAI->strDefaultLogonDomain.QueryStr();
        PCSTR pL;
        if ( pD != NULL && pD[0] != '\0' )
        {
#if 1 // DBCS enabling for user name
            if ( ( pL = (PCHAR)_mbschr( (PUCHAR)pD, '\\' ) ) )
#else
            if ( ( pL = strchr( pD, '\\' ) ) )
#endif
            {
                cL = DIFF(pL - pD);
            }
            else
            {
                cL = strlen( pD );
            }
            memcpy( szDomainAndUser, pD, cL );
            szDomainAndUser[ cL++ ] = '\\';
        }
        else
        {
            DWORD dwL = DNLEN + 1;
            if ( GetComputerName( szDomainAndUser, &dwL ) )
            {
                cL = dwL;
                szDomainAndUser[ cL++ ] = '\\';
            }
        }
        psi->UnlockThis();
    }

    strcpy( szDomainAndUser + cL, pszUser );

    return pstrU->Copy( (TCHAR*)szDomainAndUser );
}


BOOL
TCP_AUTHENT::QueryUserName(
    STR * pBuff,
    BOOL fImpersonated
    )
/*++

Routine Description:

    Queries the name associated with this *authenticated* object

Arguments:

    pBuff       - Buffer to receive name

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    SECURITY_STATUS     ss;
    DWORD               cbName;
    SecPkgContext_Names CredNames;
    UINT                l;

    if ( _pDeleteFunction )
    {
        //
        // this context is bound to a SSL/PCT client certificate
        // SECPKG_ATTR_NAMES returns certificate info in this case,
        // 1st try SECPKG_ATTR_MAPNAMES. If fails, use GetUserName()
        //

#if defined(SECPKG_ATTR_MAPNAMES)

        if ( _fHaveCtxtHandle )
        {
            ss = pfnQueryContextAttributes( &_hctxt,
                                         SECPKG_ATTR_MAPNAMES,
                                         &CredNames );

            if ( ss == STATUS_SUCCESS )
            {
                cbName = strlen( CredNames.sUserName ) + 1;
    
                if ( !pBuff->Resize( cbName ))
                {
                    LocalFree( CredNames.sUserName );
                    return FALSE;
                }

                memcpy( pBuff->QueryPtr(), CredNames.sUserName, cbName );

                pBuff->SetLen( cbName - 1 );

                LocalFree( CredNames.sUserName );

                return TRUE;
            }
        }
#endif
        if ( !fImpersonated && !Impersonate() )
        {
            return FALSE;
        }
        DWORD cL = pBuff->QuerySize();
        BOOL fSt = TRUE;
        if ( !GetUserName( (LPTSTR)pBuff->QueryPtr(), &cL ) )
        {
            if ( fSt = pBuff->Resize( cL ) )
            {
                fSt = GetUserName( (LPTSTR)pBuff->QueryPtr(), &cL );
            }
        }

        //
        // Add domain name if not present
        //

#if 1 // DBCS enabling for user name
        if ( fSt && _mbschr( (PUCHAR)pBuff->QueryPtr(), '\\') == NULL )
#else
        if ( fSt && strchr( (LPSTR)pBuff->QueryPtr(), '\\') == NULL )
#endif
        {
            cL = strlen(g_achComputerName);
            if ( pBuff->Resize( l=(cL+1+strlen((LPSTR)pBuff->QueryPtr()))+1 ) )
            {
                memmove( (LPBYTE)pBuff->QueryPtr()+cL+1,
                         pBuff->QueryPtr(),
                         strlen((LPSTR)pBuff->QueryPtr())+sizeof(CHAR) );
                memcpy( pBuff->QueryPtr(), g_achComputerName, cL );
                ((LPBYTE)pBuff->QueryPtr())[cL] = '\\';
                pBuff->SetLen( l );
            }
        }

        if ( !fImpersonated )
        {
            RevertToSelf();
        }

        return fSt;
    }
    else 
    {
        if ( _fHaveCtxtHandle )
        {
            ss = pfnQueryContextAttributes( &_hctxt,
                                         SECPKG_ATTR_NAMES,
                                         &CredNames );
        }
        else
        {
            ss = ERROR_INVALID_HANDLE;
        }

        if ( ss != STATUS_SUCCESS )
        {
            SetLastError( ss );
            return FALSE;
        }

        cbName = strlen( CredNames.sUserName ) + 1;

        if ( !pBuff->Resize( cbName ))
        {
            pfnFreeContextBuffer( CredNames.sUserName );
            return FALSE;
        }

        memcpy( pBuff->QueryPtr(), CredNames.sUserName, cbName );

        pBuff->SetLen( cbName - 1 );

        pfnFreeContextBuffer( CredNames.sUserName );
    }

    return TRUE;
}
/*******************************************************************/

BOOL TCP_AUTHENT::Converse(
    VOID   * pBuffIn,
    DWORD    cbBuffIn,
    BUFFER * pbuffOut,
    DWORD  * pcbBuffOut,
    BOOL   * pfNeedMoreData,
    PTCP_AUTHENT_INFO   pTAI,
    CHAR   * pszPackage,
    CHAR   * pszUser,
    CHAR   * pszPassword,
    PIIS_SERVER_INSTANCE psi
    )
/*++

Routine Description:

    Initiates or continues a previously initiated authentication conversation

    Client calls this first to get the negotiation message which
    it then sends to the server.  The server calls this with the
    client result and sends back the result.  The conversation
    continues until *pfNeedMoreData is FALSE.

    On the first call, pszPackage must point to the zero terminated
    authentication package name to be used and pszUser and pszPassword
    should point to the user name and password to authenticated with
    on the client side (server side will always be NULL).

Arguments:

    pBuffIn - Points to SSP message received from the
        client.  If TCPAUTH_UUENCODE is used, then this must point to a
        zero terminated uuencoded string (except for the first call).
    cbBuffIn - Number of bytes in pBuffIn or zero if pBuffIn points to a
        zero terminated, uuencoded string.
    pbuffOut - If *pfDone is not set to TRUE, this buffer contains the data
        that should be sent to the other side.  If this is zero, then no
        data needs to be sent.
    pcbBuffOut - Number of bytes in pbuffOut
    pfNeedMoreData - Set to TRUE while this side of the conversation is
        expecting more data from the remote side.
    pszPackage - On the first call points to a zero terminate string indicating
        the security package to use
    pszUser - Specifies user or domain\user the first time the client calls
        this method (client side only)
    pszPassword - Specifies the password for pszUser the first time the
        client calls this method (client side only)

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError).  Access is
    denied if FALSE is returned and GetLastError is ERROR_ACCESS_DENIED.

--*/
{
    SECURITY_STATUS       ss;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    SecBufferDesc         InBuffDesc;
    SecBuffer             InSecBuff;
    ULONG                 ContextAttributes;
    BUFFER                buffData;
    BUFFER                buff;
    STACK_STR             ( strDefaultLogonDomain, IIS_DNLEN+1 );

    //
    //  Decode the data if there's something to decode
    //

    if ( _fUUEncodeData && 
         pBuffIn && 
         PackageSupportsEncoding( pszPackage ) )
    {
        if ( !uudecode( (CHAR *) pBuffIn,
                        &buffData,
                        &cbBuffIn,
                        _fBase64
                        ))
        {
            return FALSE;
        }

        pBuffIn = buffData.QueryPtr();
    }

    //
    //  If this is a new conversation, then we need to get the credential
    //  handle and find out the maximum token size
    //

    if ( _fNewConversation )
    {
        if ( !_fClient )
        {
            if ( !CACHED_CREDENTIAL::GetCredential(
                        pszPackage,
                        psi,
                        pTAI,
                        &_hcred,
                        &_cbMaxToken ) )
            {
                return FALSE;
            }
        }
        else
        {
            SecPkgInfo *              pspkg;
            SEC_WINNT_AUTH_IDENTITY   AuthIdentity;
            SEC_WINNT_AUTH_IDENTITY * pAuthIdentity;
            CHAR *                    pszDomain = NULL;
            CHAR                      szDomainAndUser[IIS_DNLEN+UNLEN+2];


            //
            //  If this is the client and a username and password were
            //  specified, then fill out the authentication information
            //

            if ( _fClient &&
                 ((pszUser != NULL) ||
                  (pszPassword != NULL)) )
            {
                pAuthIdentity = &AuthIdentity;

                //
                //  Break out the domain from the username if one was specified
                //

                if ( pszUser != NULL )
                {
                    strcpy( szDomainAndUser, pszUser );
                    if ( !CrackUserAndDomain( szDomainAndUser,
                                              &pszUser,
                                              &pszDomain ))
                    {
                        return FALSE;
                    }
                }

                memset( &AuthIdentity,
                        0,
                        sizeof( AuthIdentity ));

                if ( pszUser != NULL )
                {
                    AuthIdentity.User       = (unsigned char *) pszUser;
                    AuthIdentity.UserLength = strlen( pszUser );
                }

                if ( pszPassword != NULL )
                {
                    AuthIdentity.Password       = (unsigned char *) pszPassword;
                    AuthIdentity.PasswordLength = strlen( pszPassword );
                }

                if ( pszDomain != NULL )
                {
                    AuthIdentity.Domain       = (unsigned char *) pszDomain;
                    AuthIdentity.DomainLength = strlen( pszDomain );
                }

                AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
            }
            else
            {
                //
                // provide default logon domain
                //

                if ( psi == NULL )
                {
                    pAuthIdentity = NULL;
                }
                else
                {
                    pAuthIdentity = &AuthIdentity;

                    memset( &AuthIdentity,
                            0,
                            sizeof( AuthIdentity ));

                    if ( pTAI->strDefaultLogonDomain.QueryCCH() <= IIS_DNLEN )
                    {
                        strDefaultLogonDomain.Copy( pTAI->strDefaultLogonDomain );
                        AuthIdentity.Domain = (LPBYTE)strDefaultLogonDomain.QueryStr();
                    }
                    if ( AuthIdentity.Domain != NULL )
                    {
                        if ( AuthIdentity.DomainLength =
                                strlen( (LPCTSTR)AuthIdentity.Domain ) )
                        {
                            // remove trailing '\\' if present

                            if ( AuthIdentity.Domain[AuthIdentity.DomainLength-1]
                                    == '\\' )
                            {
                                --AuthIdentity.DomainLength;
                            }
                        }
                    }
                    if ( AuthIdentity.DomainLength == 0 )
                    {
                        pAuthIdentity = NULL;
                    }
                    else
                    {
                        AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
                    }
                }
            }

            ss = pfnAcquireCredentialsHandle( NULL,             // New principal
                                           pszPackage,       // Package name
                                           (_fClient ? SECPKG_CRED_OUTBOUND :
                                                       SECPKG_CRED_INBOUND),
                                           NULL,             // Logon ID
                                           pAuthIdentity,    // Auth Data
                                           NULL,             // Get key func
                                           NULL,             // Get key arg
                                           &_hcred,
                                           &Lifetime );

            //
            //  Need to determine the max token size for this package
            //

            if ( ss == STATUS_SUCCESS )
            {
                _fHaveCredHandle = TRUE;
                ss = pfnQuerySecurityPackageInfo( (char *) pszPackage,
                                               &pspkg );
            }

            if ( ss != STATUS_SUCCESS )
            {
                DBGPRINTF(( DBG_CONTEXT,
                           "[Converse] AcquireCredentialsHandle or QuerySecurityPackageInfo failed, error %d\n",
                            ss ));

                SetLastError( ss );
                return FALSE;
            }

            _cbMaxToken = pspkg->cbMaxToken;
            DBG_ASSERT( pspkg->fCapabilities & SECPKG_FLAG_CONNECTION );

            pfnFreeContextBuffer( pspkg );
        }
    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //

    if ( !buff.Resize( _cbMaxToken ))
        return FALSE;

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = _cbMaxToken;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = buff.QueryPtr();

    //
    //  Prepare our Input buffer - Note the server is expecting the client's
    //  negotiation packet on the first call
    //

    if ( pBuffIn )
    {
        InBuffDesc.ulVersion = 0;
        InBuffDesc.cBuffers  = 1;
        InBuffDesc.pBuffers  = &InSecBuff;

        InSecBuff.cbBuffer   = cbBuffIn;
        InSecBuff.BufferType = SECBUFFER_TOKEN;
        InSecBuff.pvBuffer   = pBuffIn;
    }

    //
    //  Client side uses InitializeSecurityContext, server side uses
    //  AcceptSecurityContext
    //

    if ( _fClient )
    {
        //
        //  Note the client will return success when its done but we still
        //  need to send the out buffer if there are bytes to send
        //

        ss = pfnInitializeSecurityContext( &_hcred,
                                        _fNewConversation ? NULL :
                                                            &_hctxt,
                                        _strTarget.IsEmpty() ? 
                                            TCPAUTH_TARGET_NAME : 
                                            _strTarget.QueryStr(),
                                        0,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        _fNewConversation ? NULL :
                                                            &InBuffDesc,
                                        0,
                                        &_hctxt,
                                        &OutBuffDesc,
                                        &ContextAttributes,
                                        &Lifetime );
    }
    else
    {
        //
        //  This is the server side
        //

        SetLastError ( 0 );

        ss = pfnAcceptSecurityContext( &_hcred,
                                    _fNewConversation ? NULL :
                                                        &_hctxt,
                                    &InBuffDesc,
                                    ASC_REQ_EXTENDED_ERROR,
                                    SECURITY_NATIVE_DREP,
                                    &_hctxt,
                                    &OutBuffDesc,
                                    &ContextAttributes,
                                    &Lifetime );
    }

    if ( !NT_SUCCESS( ss ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[Converse] Initialize/AcceptCredentialsHandle failed, error %d\n",
                    ss ));

        if ( !_fNewConversation )
        {
            //
            // If not a new conversation, then when we fail we still have a context
            // handle from previous to AcceptSecurityContext. Need to call
            // DeleteSecurityContext to avoid leaking the context.
            // AcceptSecurityContext does not touch _hctxt if it fails.
            //

            DBG_ASSERT( _fHaveCtxtHandle );

            pfnDeleteSecurityContext( &_hctxt );
        }

        _fHaveCtxtHandle = FALSE;

        if ( ss == SEC_E_LOGON_DENIED ||
             ss == SEC_E_INVALID_TOKEN )
        {
            ss = ERROR_LOGON_FAILURE;
        }

        if ( GetLastError() != ERROR_PASSWORD_EXPIRED
             && GetLastError() != ERROR_PASSWORD_MUST_CHANGE )
        {
            SetLastError( ss );
        }

        return FALSE;
    }

    if( ContextAttributes & ASC_RET_NULL_SESSION  )
    {
        SetLastError( ERROR_LOGON_FAILURE );

        return FALSE;
    }

    _fHaveCtxtHandle = TRUE;

    //
    // NTLMSSP will set the last error to ERROR_NO_SUCH_USER
    // if success and Guest account was used
    //

    if ( GetLastError() == ERROR_NO_SUCH_USER )
    {
        _fKnownToBeGuest = TRUE;
    }

    //
    //  Now we just need to complete the token (if requested) and prepare
    //  it for shipping to the other side if needed
    //

    BOOL fReply = !!OutSecBuff.cbBuffer;

    if ( (ss == SEC_I_COMPLETE_NEEDED) ||
         (ss == SEC_I_COMPLETE_AND_CONTINUE) )
    {
        ss = pfnCompleteAuthToken( &_hctxt,
                                   &OutBuffDesc );

        if ( !NT_SUCCESS( ss ))
            return FALSE;

    }

    //
    //  Format or copy to the output buffer if we need to reply
    //

    if ( fReply )
    {
        if ( _fUUEncodeData && 
             PackageSupportsEncoding( pszPackage ) )
        {
            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer,
                            OutSecBuff.cbBuffer,
                            pbuffOut,
                            _fBase64 ))
            {
                return FALSE;
            }

            *pcbBuffOut = strlen( (CHAR *) pbuffOut->QueryPtr() );
        }
        else
        {
            if ( !pbuffOut->Resize( OutSecBuff.cbBuffer ))
                return FALSE;

            memcpy( pbuffOut->QueryPtr(),
                    OutSecBuff.pvBuffer,
                    OutSecBuff.cbBuffer );

            *pcbBuffOut = OutSecBuff.cbBuffer;
        }
    }
    else
    {
        *pcbBuffOut = 0;
    }

    if ( _fNewConversation )
        _fNewConversation = FALSE;

    *pfNeedMoreData = ((ss == SEC_I_CONTINUE_NEEDED) ||
                       (ss == SEC_I_COMPLETE_AND_CONTINUE));

    if ( !*pfNeedMoreData && !_fClient )
    {
        _fDelegate = !!(ContextAttributes & ASC_RET_DELEGATE);
    }

    return TRUE;
}


BOOL TCP_AUTHENT::ConverseEx(
    SecBufferDesc*          pInSecBufDesc,      // passed in by caller
    BUFFER *                pDecodedBuffer,     // passed in by caller
    BUFFER *                pbuffOut,
    DWORD  *                pcbBuffOut,
    BOOL   *                pfNeedMoreData,
    PTCP_AUTHENT_INFO       pTAI,
    CHAR   *                pszPackage,
    CHAR   *                pszUser,
    CHAR   *                pszPassword,
    PIIS_SERVER_INSTANCE    psi
    )
/*
 *  A variant of Converse that takes variable number of input SecBuffer.
 *  Caller will set the SecBuffers and pass in the SecBufferDesc pointer to ConverseEx.
 *  If the SecBuffer.pvBuffer needs to be decoded, caller has to pass in
 *  an array of BUFFER to hold the decoded data. The number of BUFFER elements
 *  should be the same as the number of SecBuffer.
 *  If decoding it not needed, pass NULL instead.
 *
 */
{

    SECURITY_STATUS       ss;
    TimeStamp             Lifetime;
    SecBufferDesc         OutBuffDesc;
    SecBuffer             OutSecBuff;
    ULONG                 ContextAttributes;
    BUFFER                buffData;
    BUFFER                buff;
    STACK_STR             ( strDefaultLogonDomain, IIS_DNLEN+1 );
    DWORD                 dw, dwDecodedLen;
    SecBuffer             *pSecBuffer;

    // make sure we have at least one SecBuffer to process
    if (pInSecBufDesc->cBuffers == 0)
        return FALSE;

    //
    //  Decode the data if there's something to decode
    //
    if (_fUUEncodeData && 
        pInSecBufDesc && 
        pDecodedBuffer &&
        PackageSupportsEncoding( pszPackage ) )
    {
        pSecBuffer = pInSecBufDesc->pBuffers;
        for (dw = 0; dw < pInSecBufDesc->cBuffers; dw++, pSecBuffer++)
        {
            if (!uudecode((CHAR *)pSecBuffer->pvBuffer,     // points to data to be decoded
                            &pDecodedBuffer[dw],            // to hold decoded data
                            &dwDecodedLen,                  // length of decoded data
                            _fBase64
                            ))
            {
                return FALSE;
            }

            // update the SecBuffer so it now points to the decoded data in BUFFER
            pSecBuffer->pvBuffer = pDecodedBuffer[dw].QueryPtr();
            pSecBuffer->cbBuffer = dwDecodedLen;
        }
    }

    //
    //  If this is a new conversation, then we need to get the credential
    //  handle and find out the maximum token size
    //

    if ( _fNewConversation )
    {
        SecPkgInfo *              pspkg;
        SEC_WINNT_AUTH_IDENTITY   AuthIdentity;
        SEC_WINNT_AUTH_IDENTITY * pAuthIdentity;
        CHAR *                    pszDomain = NULL;
        CHAR                      szDomainAndUser[IIS_DNLEN+UNLEN+2];


        //
        //  If this is the client and a username and password were
        //  specified, then fill out the authentication information
        //

        if ( _fClient &&
             ((pszUser != NULL) ||
              (pszPassword != NULL)) )
        {
            pAuthIdentity = &AuthIdentity;

            //
            //  Break out the domain from the username if one was specified
            //

            if ( pszUser != NULL )
            {
                strcpy( szDomainAndUser, pszUser );
                if ( !CrackUserAndDomain( szDomainAndUser,
                                          &pszUser,
                                          &pszDomain ))
                {
                    return FALSE;
                }
            }

            memset( &AuthIdentity,
                    0,
                    sizeof( AuthIdentity ));

            if ( pszUser != NULL )
            {
                AuthIdentity.User       = (unsigned char *) pszUser;
                AuthIdentity.UserLength = strlen( pszUser );
            }

            if ( pszPassword != NULL )
            {
                AuthIdentity.Password       = (unsigned char *) pszPassword;
                AuthIdentity.PasswordLength = strlen( pszPassword );
            }

            if ( pszDomain != NULL )
            {
                AuthIdentity.Domain       = (unsigned char *) pszDomain;
                AuthIdentity.DomainLength = strlen( pszDomain );
            }

            AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
        }
        else
        {
            //
            // provide default logon domain
            //

            if ( psi == NULL )
            {
                pAuthIdentity = NULL;
            }
            else
            {
                pAuthIdentity = &AuthIdentity;

                memset( &AuthIdentity,
                        0,
                        sizeof( AuthIdentity ));

                if ( pTAI->strDefaultLogonDomain.QueryCCH() <= IIS_DNLEN )
                {
                    strDefaultLogonDomain.Copy( pTAI->strDefaultLogonDomain );
                    AuthIdentity.Domain = (LPBYTE)strDefaultLogonDomain.QueryStr();
                }
                if ( AuthIdentity.Domain != NULL )
                {
                    if ( AuthIdentity.DomainLength =
                            strlen( (LPCTSTR)AuthIdentity.Domain ) )
                    {
                        // remove trailing '\\' if present

                        if ( AuthIdentity.Domain[AuthIdentity.DomainLength-1]
                                == '\\' )
                        {
                            --AuthIdentity.DomainLength;
                        }
                    }
                }
                if ( AuthIdentity.DomainLength == 0 )
                {
                    pAuthIdentity = NULL;
                }
                else
                {
                    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
                }
            }
        }

        ss = pfnAcquireCredentialsHandle( NULL,             // New principal
                                       pszPackage,       // Package name
                                       (_fClient ? SECPKG_CRED_OUTBOUND :
                                                   SECPKG_CRED_INBOUND),
                                       NULL,             // Logon ID
                                       pAuthIdentity,    // Auth Data
                                       NULL,             // Get key func
                                       NULL,             // Get key arg
                                       &_hcred,
                                       &Lifetime );

        //
        //  Need to determine the max token size for this package
        //

        if ( ss == STATUS_SUCCESS )
        {
            _fHaveCredHandle = TRUE;
            ss = pfnQuerySecurityPackageInfo( (char *) pszPackage,
                                           &pspkg );
        }

        if ( ss != STATUS_SUCCESS )
        {
            DBGPRINTF(( DBG_CONTEXT,
                       "[Converse] AcquireCredentialsHandle or QuerySecurityPackageInfo failed, error %d\n",
                        ss ));

            SetLastError( ss );
            return FALSE;
        }

        _cbMaxToken = pspkg->cbMaxToken;
        DBG_ASSERT( pspkg->fCapabilities & SECPKG_FLAG_CONNECTION );

        pfnFreeContextBuffer( pspkg );

    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //

    if ( !buff.Resize( _cbMaxToken ))
        return FALSE;

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = _cbMaxToken;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = buff.QueryPtr();

    //
    // Input sec buffer is passed by caller
    //

    //
    //  Client side uses InitializeSecurityContext, server side uses
    //  AcceptSecurityContext
    //

    if ( _fClient )
    {
        //
        //  Note the client will return success when its done but we still
        //  need to send the out buffer if there are bytes to send
        //

        ss = pfnInitializeSecurityContext( &_hcred,
                                        _fNewConversation ? NULL : &_hctxt,
                                        _strTarget.IsEmpty() ? 
                                            TCPAUTH_TARGET_NAME : 
                                            _strTarget.QueryStr(),
                                        0,
                                        0,
                                        SECURITY_NATIVE_DREP,
                                        _fNewConversation ? NULL : pInSecBufDesc,
                                        0,
                                        &_hctxt,
                                        &OutBuffDesc,
                                        &ContextAttributes,
                                        &Lifetime );
    }
    else
    {
        //
        //  This is the server side
        //

        SetLastError ( 0 );

        ss = pfnAcceptSecurityContext( &_hcred,
                                    _fNewConversation ? NULL : &_hctxt,
                                    pInSecBufDesc,
                                    ASC_REQ_EXTENDED_ERROR,
                                    SECURITY_NATIVE_DREP,
                                    &_hctxt,
                                    &OutBuffDesc,
                                    &ContextAttributes,
                                    &Lifetime );
    }

    if ( !NT_SUCCESS( ss ) )
    {
        DBGPRINTF(( DBG_CONTEXT,
                   "[Converse] Initialize/AcceptCredentialsHandle failed, error %d\n",
                    ss ));

        if ( ss == SEC_E_LOGON_DENIED ||
             ss == SEC_E_INVALID_TOKEN )
        {
            ss = ERROR_LOGON_FAILURE;
        }

        if ( GetLastError() != ERROR_PASSWORD_EXPIRED
             && GetLastError() != ERROR_PASSWORD_MUST_CHANGE )
        {
            SetLastError( ss );
        }

        return FALSE;
    }

    _fHaveCtxtHandle = TRUE;

    //
    // NTLMSSP will set the last error to ERROR_NO_SUCH_USER
    // if success and Guest account was used
    //

    if ( GetLastError() == ERROR_NO_SUCH_USER )
    {
        _fKnownToBeGuest = TRUE;
    }

    //
    //  Now we just need to complete the token (if requested) and prepare
    //  it for shipping to the other side if needed
    //

    BOOL fReply = !!OutSecBuff.cbBuffer;

    if ( (ss == SEC_I_COMPLETE_NEEDED) ||
         (ss == SEC_I_COMPLETE_AND_CONTINUE) )
    {
        ss = pfnCompleteAuthToken( &_hctxt,
                                   &OutBuffDesc );

        if ( !NT_SUCCESS( ss ))
            return FALSE;

    }

    //
    //  Format or copy to the output buffer if we need to reply
    //

    if ( fReply )
    {
        if ( _fUUEncodeData &&
             PackageSupportsEncoding( pszPackage ) )
        {
            if ( !uuencode( (BYTE *) OutSecBuff.pvBuffer,
                            OutSecBuff.cbBuffer,
                            pbuffOut,
                            _fBase64 ))
            {
                return FALSE;
            }

            *pcbBuffOut = strlen( (CHAR *) pbuffOut->QueryPtr() );
        }
        else
        {
            if ( !pbuffOut->Resize( OutSecBuff.cbBuffer ))
                return FALSE;

            memcpy( pbuffOut->QueryPtr(),
                    OutSecBuff.pvBuffer,
                    OutSecBuff.cbBuffer );

            *pcbBuffOut = OutSecBuff.cbBuffer;
        }
    }
    else
    {
        *pcbBuffOut = 0;
    }

    if ( _fNewConversation )
        _fNewConversation = FALSE;

    *pfNeedMoreData = ((ss == SEC_I_CONTINUE_NEEDED) ||
                       (ss == SEC_I_COMPLETE_AND_CONTINUE));

    if ( !*pfNeedMoreData && !_fClient )
    {
        _fDelegate = !!(ContextAttributes & ASC_RET_DELEGATE);
    }

    return TRUE;
}


/*******************************************************************/

#if 0
BOOL
TCP_AUTHENT::DigestLogon(
    PSTR pszUserName,
    PSTR pszRealm,
    PSTR pszUri,
    PSTR pszMethod,
    PSTR pszNonce,
    PSTR pszServerNonce,
    PSTR pszDigest,
    DWORD dwAlgo,
    LPTSVC_INFO     psi
    )
{
    HANDLE      hToken;
    CHAR        szDomainAndUser[IIS_DNLEN+UNLEN+2];
    int         cL = 0;
    CHAR   *    pszUserOnly;
    CHAR   *    pszDomain;

    //
    // prepend default logon domain if no domain
    //

    if (    strchr( pszUserName, '/' ) == NULL
            && strchr( pszUserName, '\\' ) == NULL )
    {
        psi->LockThisForRead();
        PCSTR pD = psi->QueryDefaultLogonDomain();
        PCSTR pL;
        if ( pD != NULL && pD[0] != '\0' )
        {
            if ( ( pL = strchr( pD, '\\' ) ) )
            {
                cL = pL - pD;
            }
            else
            {
                cL = strlen( pD );
            }
            memcpy( szDomainAndUser, pD, cL );
            szDomainAndUser[ cL++ ] = '\\';
        }
        psi->UnlockThis();
    }

    strcpy( szDomainAndUser + cL, pszUserName );

    //
    //  Crack the name into domain/user components.
    //

    if ( !CrackUserAndDomain( szDomainAndUser,
                              &pszUserOnly,
                              &pszDomain ))
    {
        return FALSE;
    }

    if ( LogonDigestUserA(
            pszUserOnly,
            pszDomain,
            pszRealm,
            pszUri,
            pszMethod,
            pszNonce,
            pszServerNonce,
            pszDigest,
            dwAlgo,
            &hToken )
          && SetAccessToken( NULL, hToken ) )
    {
        return TRUE;
    }

    return FALSE;
}
#endif


BOOL
TCP_AUTHENT::ClearTextLogon(
    IN  PCHAR            pszUser,
    IN  PCHAR            pszPassword,
    OUT PBOOL            pfAsGuest,
    OUT PBOOL            pfAsAnonymous,
    IN  PIIS_SERVER_INSTANCE pInstance,
    PTCP_AUTHENT_INFO    pTAI,
    IN  PCHAR            pszWorkstation
    )
/*++

Routine Description:

    Gets a network logon token using clear text

Arguments:

    pszUser - User name (optionally with domain)
    pszPassword - password
    pfAsGuest - Set to TRUE if granted with guest access (NOT SUPPORTED)
    pfAsAnonymous - Set to TRUE if the user received the anonymous token
    pInstance - pointer to Server instance

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    BOOL fHaveExp;

    DBG_ASSERT( !_fHaveCredHandle && !_fHaveCtxtHandle );

    //
    // short circuit fast path
    //

    if ( pszUser == NULL ) {

        _hToken = FastFindAnonymousToken( pTAI );

        //
        // success!
        //

        if ( _hToken != NULL ) {

            _liPwdExpiry.LowPart = _hToken->QueryExpiry()->LowPart;
            _liPwdExpiry.HighPart = _hToken->QueryExpiry()->HighPart;

            _fHaveExpiry = TRUE;
            _fClearText = TRUE;

            *pfAsGuest = _hToken->IsGuest();
            *pfAsAnonymous = TRUE;
            return TRUE;
        }

        //
        // use normal path
        //
    }

    _hToken = TsLogonUser( pszUser,
                           pszPassword,
                           pfAsGuest,
                           pfAsAnonymous,
                           pInstance,
                           pTAI,
                           pszWorkstation,
                           &_liPwdExpiry,
                           &fHaveExp );

    if ( _hToken == NULL  ) {
        return FALSE;
    }

    _fClearText = TRUE;
    _fHaveExpiry = fHaveExp;

    switch ( pTAI->dwLogonMethod )
    {
    case LOGON32_LOGON_BATCH:
    case LOGON32_LOGON_INTERACTIVE:
    case LOGON32_LOGON_NETWORK_CLEARTEXT:
        _fDelegate = TRUE;
    }

    return TRUE;

} // TCP_AUTHENT::ClearTextLogon


BOOL TCP_AUTHENT::SetAccessToken(
    HANDLE          hPrimaryToken,
    HANDLE          hImpersonationToken
    )
/*++

Routine Description:

    Set primary & impersonation token

Arguments:

    hPrimaryToken -- Primary Access Token
    hImpersonationToken -- Impersonation Access Token
      One the two above tokens can be NULL ( but not both )
    psi - pointer to Service info struct

Return Value:

    TRUE if successful, FALSE otherwise ( tokens will be closed )

--*/
{
    if ( !hPrimaryToken )
    {
        if ( !hImpersonationToken )
        {
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if ( !pfnDuplicateTokenEx( hImpersonationToken,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityImpersonation,
                                TokenPrimary,
                                &hPrimaryToken ))
        {

            CloseHandle( hImpersonationToken );
            return FALSE;
        }
    }

    if ( !hImpersonationToken )
    {
        if ( !pfnDuplicateTokenEx( hPrimaryToken,
                                TOKEN_ALL_ACCESS,
                                NULL,
                                SecurityImpersonation,
                                TokenImpersonation,
                                &hImpersonationToken ))
        {

            CloseHandle( hPrimaryToken );
            return FALSE;
        }
    }

    _hSSPToken = hImpersonationToken;
    _hSSPPrimaryToken = hPrimaryToken;

    _fHaveAccessTokens = TRUE;

    return TRUE;
}


/*******************************************************************/

BOOL TCP_AUTHENT::Impersonate(
    VOID
    )
/*++

Routine Description:

    Impersonates the authenticated user

Arguments:

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    if ( _fClearText )
    {
        return TsImpersonateUser( _hToken );
    }
    else if ( _fHaveAccessTokens || _pDeleteFunction )
    {
        return ImpersonateLoggedOnUser( _hSSPToken );
    }
    else
    {
        DBG_ASSERT( _fHaveCtxtHandle );

        return !!NT_SUCCESS( pfnImpersonateSecurityContext( &_hctxt ));
    }
}

/*******************************************************************/

BOOL TCP_AUTHENT::RevertToSelf(
    VOID
    )
/*++

Routine Description:

    Undoes the impersonation

Arguments:

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{

    if ( _fClearText || _fHaveAccessTokens || _pDeleteFunction )
    {
        return ::RevertToSelf();
    }
    else
    {
        DBG_ASSERT( _fHaveCtxtHandle );

        return !!NT_SUCCESS( pfnRevertSecurityContext( &_hctxt ));
    }
}

/*******************************************************************/

BOOL TCP_AUTHENT::StartProcessAsUser(
    LPCSTR                lpApplicationName,
    LPSTR                 lpCommandLine,
    BOOL                  bInheritHandles,
    DWORD                 dwCreationFlags,
    LPVOID                lpEnvironment,
    LPCSTR                lpCurrentDirectory,
    LPSTARTUPINFOA        lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
/*++

Routine Description:

    Creates a process as the authenticated user

Arguments:

    Standard CreateProcess args

Return Value:

    TRUE if successful, FALSE otherwise (call GetLastError)

--*/
{
    HANDLE htoken;
    BOOL   fRet;

    if ( _fClearText )
    {
        htoken = CTO_TO_TOKEN( _hToken );
    }
    else
    {
        //
        //  Need to extract the impersonation token from the opaque SSP
        //  structures
        //

        if ( !Impersonate() )
        {
            return FALSE;
        }

        if ( !OpenThreadToken( GetCurrentThread(),
                               TOKEN_QUERY,
                               TRUE,
                               &htoken ))
        {
            RevertToSelf();
            return FALSE;
        }

        RevertToSelf();
    }

    fRet = CreateProcessAsUser( htoken,
                                lpApplicationName,
                                lpCommandLine,
                                NULL,
                                NULL,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation );

    if ( !_fClearText )
    {
        DBG_REQUIRE( CloseHandle( htoken ) );
    }

    return fRet;
}


BOOL
TCP_AUTHENT::GetClientCertBlob
(
IN  DWORD           cbAllocated,
OUT DWORD *         pdwCertEncodingType,
OUT unsigned char * pbCertEncoded,
OUT DWORD *         pcbCertEncoded,
OUT DWORD *         pdwCertificateFlags
)
{

    if ( (pdwCertEncodingType == NULL)  ||
         (pbCertEncoded == NULL)        ||
         (pcbCertEncoded == NULL)
         ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return ( FALSE);
    }

    BOOL            fReturn = FALSE;
    BOOL            fNoCert;

    if ( !QueryCertificateInfo( &fNoCert) ) {

        goto LNoCertificate;
    }

    //
    // fill in cert size out-parameter
    //

    *pcbCertEncoded = _pClientCertContext->cbCertEncoded;


    //
    //  if buffer is adequate, fill in remaining out-parameters
    //  else return error
    //

    if ( cbAllocated >= *pcbCertEncoded ) {

        CopyMemory( pbCertEncoded,
                    _pClientCertContext->pbCertEncoded,
                    _pClientCertContext->cbCertEncoded );

        *pdwCertEncodingType = _pClientCertContext->dwCertEncodingType;
        *pdwCertificateFlags = _dwX509Flags;
        fReturn = TRUE;

    } else {

        SetLastError( ERROR_INSUFFICIENT_BUFFER );
        fReturn = FALSE;

    }


LExit:

    return fReturn;


LNoCertificate:

    //
    //  No cert: zero-out buffer and return success
    //

    *pbCertEncoded = NULL;
    *pcbCertEncoded = 0;
    *pdwCertEncodingType = 0;
    *pdwCertificateFlags = 0;

    fReturn = TRUE;

    goto LExit;

} // TCP_AUTHENT::GetClientCertBlob()


BOOL
TCP_AUTHENT::UpdateClientCertFlags(
    DWORD   dwFlags,
    LPBOOL  pfNoCert,
    LPBYTE  pbCa,
    DWORD   dwCa
    )
{
    BOOL    fNoCert;

    _fCertCheckForRevocation = !( dwFlags & MD_CERT_NO_REVOC_CHECK );
    _fCertCheckCacheOnly = !!( dwFlags & MD_CERT_CACHE_RETRIEVAL_ONLY );

    if ( QueryCertificateInfo( pfNoCert ) )
    {
        *pfNoCert = FALSE;
        return TRUE;
    }

    return FALSE;
}

BOOL
TCP_AUTHENT::PackageSupportsEncoding(
    LPSTR   pszPackage
)
/*++

Routine Description:

    Check whether the SSPI package should (not) be encoded.    

Arguments:

    pszPackage - Name of SSPI package

Return Value:

    TRUE if should encode, FALSE otherwise

--*/
{
    SECURITY_STATUS     SecurityStatus;
    PSecPkgInfo         pPackageInfo;
    BOOL                fRet = FALSE;

    if ( pszPackage != NULL )
    {
        SecurityStatus = pfnQuerySecurityPackageInfo( pszPackage,
                                                      &pPackageInfo );
    
        if ( SecurityStatus == SEC_E_OK )
        {
            if ( !( pPackageInfo->fCapabilities & SECPKG_FLAG_ASCII_BUFFERS ) )
            {
                fRet = TRUE;
            }
            pfnFreeContextBuffer( pPackageInfo );
        }
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        DBG_ASSERT( FALSE );
    }
    
    return fRet;
}

BOOL
TCP_AUTHENT::SetTargetName(
    LPSTR   pszTargetName
)
/*++

Routine Description:

    Set the target name to pass into InitializeSecurityContext() calls

Arguments:

    pszTargetName - Target name

Return Value:

    TRUE if successful, else FALSE.  Use GetLastError() for error

--*/
{
    if ( pszTargetName != NULL )
    {
        return _strTarget.Copy( pszTargetName );
    }
    else
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
}
/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\fcache.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name:
      fcache.cxx

   Abstract:
      This module supports functions for file caching for servers

   Author:

       Murali R. Krishnan    ( MuraliK )     11-Oct-1995

   Environment:

       Win32 Apps

   Project:

       Internet Services Common  DLL

   Functions Exported:



   Revision History:
     Obtained from old inetsvcs.dll

--*/


/************************************************************
 *     Include Headers
 ************************************************************/
#include <tcpdllp.hxx>
#include <issched.hxx>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <festrcnv.h>

# include "inetreg.h"

//
//  Prototypes
//

//
// RobSol: May 2002
// deleted implementation of
// CheckOutCachedFileFromURI(
// CheckOutCachedFile(
// CheckInCachedFile(
//

//
//  Globals
//

/************************************************************
 *    Functions
 ************************************************************/

//
//  Taken from NCSA HTTP and wwwlib.
//
//  NOTE: These conform to RFC1113, which is slightly different then the Unix
//        uuencode and uudecode!
//

const int _pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr[64] = {
    'A','B','C','D','E','F','G','H','I','J','K','L','M',
    'N','O','P','Q','R','S','T','U','V','W','X','Y','Z',
    'a','b','c','d','e','f','g','h','i','j','k','l','m',
    'n','o','p','q','r','s','t','u','v','w','x','y','z',
    '0','1','2','3','4','5','6','7','8','9','+','/'
};

const int _pr2six64[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
    16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
    40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
     0,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

char _six2pr64[64] = {
    '`','!','"','#','$','%','&','\'','(',')','*','+',',',
    '-','.','/','0','1','2','3','4','5','6','7','8','9',
    ':',';','<','=','>','?','@','A','B','C','D','E','F',
    'G','H','I','J','K','L','M','N','O','P','Q','R','S',
    'T','U','V','W','X','Y','Z','[','\\',']','^','_'
};

BOOL uudecode(char   * bufcoded,
              BUFFER * pbuffdecoded,
              DWORD  * pcbDecoded,
              BOOL     fBase64
             )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout;
    int nprbytes;
    int *pr2six = (int*)(fBase64 ? _pr2six64 : _pr2six);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' || *bufcoded == '\t') bufcoded++;

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */
    bufin = bufcoded;
    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    if ( !pbuffdecoded->Resize( nbytesdecoded + 4 ))
        return FALSE;

    bufout = (unsigned char *) pbuffdecoded->QueryPtr();

    bufin = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    ((CHAR *)pbuffdecoded->QueryPtr())[nbytesdecoded] = '\0';

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;

    return TRUE;
}


//
// NOTE NOTE NOTE
// If the buffer length isn't a multiple of 3, we encode one extra byte beyond the
// end of the buffer. This garbage byte is stripped off by the uudecode code, but
// -IT HAS TO BE THERE- for uudecode to work. This applies not only our uudecode, but
// to every uudecode() function that is based on the lib-www distribution [probably
// a fairly large percentage].
//

BOOL uuencode( BYTE *   bufin,
               DWORD    nbytes,
               BUFFER * pbuffEncoded,
               BOOL     fBase64 )
{
   unsigned char *outptr;
   unsigned int i;
   char *six2pr = fBase64 ? _six2pr64 : _six2pr;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;
   //
   //  Resize the buffer to 133% of the incoming data
   //

   if ( !pbuffEncoded->Resize( nbytes + ((nbytes + 3) / 3) + 4))
        return FALSE;

   outptr = (unsigned char *) pbuffEncoded->QueryPtr();

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return TRUE;
}

/************************ End of File ***********************/


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\globals.cxx ===
/*++

   Copyright    (c)    1994    Microsoft Corporation

   Module  Name :
        globals.c

   Abstract:
        Defines global variables for the common tcpsvcs.dll
    ( It is defined separately because the debug variable should be
        "C" variable.)

   Author:

           Murali R. Krishnan    ( MuraliK )     18-Nov-1994

   Revision History:
          MuraliK         21-Feb-1995  Added Debugging Variables definitions

--*/


#include <tcpdllp.hxx>
#pragma hdrstop


//
// private routines
//

BOOL
DummySvclocFn(
    VOID
    );

BOOL
LoadNTSecurityEntryPoints(
    VOID
    );

BOOL
GetSecurityDllEntryPoints(
    IN HINSTANCE hInstance
    );

BOOL
GetLogonDllEntryPoints(
    IN HINSTANCE hInstance
    );


//
//  Declare all the debugging related variables
//

DECLARE_DEBUG_VARIABLE();
DECLARE_DEBUG_PRINTS_OBJECT();

//
// inetsloc entry points
//

HINSTANCE                   g_hSvcLocDll = NULL;
INET_REGISTER_SVC_FN        pfnInetRegisterSvc = NULL;
INET_DEREGISTER_SVC_FN      pfnInetDeregisterSvc = NULL;
INET_INIT_CONTROL_SVC_FN    pfnInitSvcLoc = NULL;
INET_INIT_CONTROL_SVC_FN    pfnTerminateSvcLoc = NULL;

//  UNDONE remove?  schannel no longer needed???
//
// schannel entrypoints
//

HINSTANCE                   g_hSchannel = NULL;
SSL_CRACK_CERTIFICATE_FN    fnCrackCert = NULL;
SSL_FREE_CERTIFICATE_FN     fnFreeCert = NULL;


//
// crypt32 entrypoints
//

HINSTANCE                           g_hCrypt32Dll = NULL;
CRYPT32_FREE_CERTCTXT_FN            pfnFreeCertCtxt = NULL;
CRYPT32_GET_CERTCTXT_PROP_FN        pfnGetCertCtxtProp = NULL;
CRYPT32_CERT_VERIFY_REVOCATION_FN   pfnCertVerifyRevocation = NULL;
CRYPT32_CERT_VERIFY_TIME_VALIDITY   pfnCertVerifyTimeValidity = NULL;
CRYPT32_CERT_NAME_TO_STR_A_FN       pfnCertNameToStrA = NULL;

//
// sspi entrypoints
//

HINSTANCE                       g_hSecurityDll = NULL;
ACCEPT_SECURITY_CONTEXT_FN      pfnAcceptSecurityContext = NULL;
ACQUIRE_CREDENTIALS_HANDLE_FN   pfnAcquireCredentialsHandle = NULL;
COMPLETE_AUTH_TOKEN_FN          pfnCompleteAuthToken = NULL;
DELETE_SECURITY_CONTEXT_FN      pfnDeleteSecurityContext = NULL;
ENUMERATE_SECURITY_PACKAGES_FN  pfnEnumerateSecurityPackages = NULL;
IMPERSONATE_SECURITY_CONTEXT_FN pfnImpersonateSecurityContext = NULL;
INITIALIZE_SECURITY_CONTEXT_FN  pfnInitializeSecurityContext = NULL;
FREE_CONTEXT_BUFFER_FN          pfnFreeContextBuffer = NULL;
FREE_CREDENTIALS_HANDLE_FN      pfnFreeCredentialsHandle = NULL;
QUERY_CONTEXT_ATTRIBUTES_FN     pfnQueryContextAttributes = NULL;
QUERY_SECURITY_CONTEXT_TOKEN_FN pfnQuerySecurityContextToken = NULL;
QUERY_SECURITY_PACKAGE_INFO_FN  pfnQuerySecurityPackageInfo = NULL;
REVERT_SECURITY_CONTEXT_FN      pfnRevertSecurityContext = NULL;

//
// logon entry points
//

LOGON32_INITIALIZE_FN           pfnLogon32Initialize = NULL;
LOGON_NET_USER_A_FN             pfnLogonNetUserA = NULL;
LOGON_NET_USER_W_FN             pfnLogonNetUserW = NULL;
NET_USER_COOKIE_A_FN            pfnNetUserCookieA = NULL;
LOGON_DIGEST_USER_A_FN          pfnLogonDigestUserA = NULL;
GET_DEFAULT_DOMAIN_NAME_FN      pfnGetDefaultDomainName = NULL;

//
// advapi32
//

DUPLICATE_TOKEN_EX_FN           pfnDuplicateTokenEx = NULL;

LSA_OPEN_POLICY_FN              pfnLsaOpenPolicy = NULL;
LSA_RETRIEVE_PRIVATE_DATA_FN    pfnLsaRetrievePrivateData = NULL;
LSA_STORE_PRIVATE_DATA_FN       pfnLsaStorePrivateData = NULL;
LSA_FREE_MEMORY_FN              pfnLsaFreeMemory = NULL;
LSA_CLOSE_FN                    pfnLsaClose = NULL;
LSA_NT_STATUS_TO_WIN_ERROR_FN   pfnLsaNtStatusToWinError = NULL;

//
// kernel32
//
#if _WIN64
LONG
INET_InterlockedIncrement(
    IN OUT LPLONG lpAddend
    )
{
    return InterlockedIncrement(lpAddend);
}

LONG
INET_InterlockedCompareExchange (
    IN OUT PLONG Destination,
    IN LONG ExChange,
    IN LONG Comperand
    )
{
    return InterlockedCompareExchange(Destination, ExChange, Comperand);
}

LONG
INET_InterlockedExchangeAdd(
    IN OUT LPLONG Addend,
    IN LONG Value
    )
{
    return InterlockedExchangeAdd(Addend, Value);
}

LONG
__cdecl
INET_InterlockedDecrement(
    IN OUT LPLONG lpAddend
    )
{
    return InterlockedDecrement(lpAddend);
}

INTERLOCKED_EXCHANGE_ADD_FN     pfnInterlockedExchangeAdd = INET_InterlockedExchangeAdd;
INTERLOCKED_COMPARE_EXCHANGE_FN pfnInterlockedCompareExchange = (INTERLOCKED_COMPARE_EXCHANGE_FN)INET_InterlockedCompareExchange;
INTERLOCKED_INCREMENT_FN        pfnInterlockedIncrement = INET_InterlockedIncrement;
INTERLOCKED_DECREMENT_FN        pfnInterlockedDecrement = INET_InterlockedDecrement;
READ_DIR_CHANGES_W_FN           pfnReadDirChangesW = ReadDirectoryChangesW;
#else
INTERLOCKED_EXCHANGE_ADD_FN     pfnInterlockedExchangeAdd = NULL;
INTERLOCKED_COMPARE_EXCHANGE_FN pfnInterlockedCompareExchange = NULL;
INTERLOCKED_INCREMENT_FN        pfnInterlockedIncrement = NULL;
INTERLOCKED_DECREMENT_FN        pfnInterlockedDecrement = NULL;
READ_DIR_CHANGES_W_FN           pfnReadDirChangesW;
#endif
//
// lonsi
//

HINSTANCE                       g_hLonsiNT = NULL;

//
// rpcref
//

HINSTANCE                       g_hRpcRef = NULL;
PFN_INETINFO_START_RPC_SERVER   pfnInetinfoStartRpcServer = NULL;
PFN_INETINFO_STOP_RPC_SERVER    pfnInetinfoStopRpcServer  = NULL;


BOOL
GetDynamicEntryPoints(
    VOID
    )
{
    HINSTANCE   hTemp;

    DBG_ASSERT(IISIsValidPlatform());

    //
    // advapi32
    //

    hTemp = LoadLibrary("advapi32.dll");
    if ( hTemp != NULL ) {

        pfnDuplicateTokenEx = (DUPLICATE_TOKEN_EX_FN)
            GetProcAddress(hTemp,"DuplicateTokenEx");

        pfnLsaOpenPolicy = (LSA_OPEN_POLICY_FN)
            GetProcAddress(hTemp,"LsaOpenPolicy");

        pfnLsaRetrievePrivateData = (LSA_RETRIEVE_PRIVATE_DATA_FN)
                GetProcAddress(hTemp,"LsaRetrievePrivateData");

        pfnLsaStorePrivateData = (LSA_STORE_PRIVATE_DATA_FN)
                GetProcAddress(hTemp,"LsaStorePrivateData");

        pfnLsaFreeMemory = (LSA_FREE_MEMORY_FN)
                GetProcAddress(hTemp,"LsaFreeMemory");

        pfnLsaClose = (LSA_CLOSE_FN)
                GetProcAddress(hTemp,"LsaClose");

        pfnLsaNtStatusToWinError = (LSA_NT_STATUS_TO_WIN_ERROR_FN)
                GetProcAddress(hTemp,"LsaNtStatusToWinError");

        FreeLibrary(hTemp);

        if ( !pfnDuplicateTokenEx ||
             !pfnLsaOpenPolicy    ||
             !pfnLsaRetrievePrivateData ||
             !pfnLsaFreeMemory      ||
             !pfnLsaClose           ||
             !pfnLsaNtStatusToWinError ) {

            DBGPRINTF((DBG_CONTEXT,
                "Unable to obtain an advapi32 entry point\n"));
            goto error_exit;
        }

    } else {
        DBGPRINTF((DBG_CONTEXT, "Error %d loading advapi32.dll\n",
            GetLastError() ));
        goto error_exit;
    }

    //
    // kernel32
    //
#ifndef _WIN64
    hTemp = LoadLibrary("kernel32.dll");
    if ( hTemp != NULL ) {

        pfnInterlockedExchangeAdd = (INTERLOCKED_EXCHANGE_ADD_FN)
            GetProcAddress(hTemp,"InterlockedExchangeAdd");

        pfnInterlockedCompareExchange = (INTERLOCKED_COMPARE_EXCHANGE_FN)
            GetProcAddress(hTemp,"InterlockedCompareExchange");

        pfnInterlockedIncrement = (INTERLOCKED_INCREMENT_FN)
            GetProcAddress(hTemp,"InterlockedIncrement");

        pfnInterlockedDecrement = (INTERLOCKED_DECREMENT_FN)
            GetProcAddress(hTemp,"InterlockedDecrement");

        pfnReadDirChangesW = (READ_DIR_CHANGES_W_FN)
            GetProcAddress(hTemp,"ReadDirectoryChangesW");

        FreeLibrary(hTemp);

        if ( !pfnInterlockedExchangeAdd ||
             !pfnInterlockedCompareExchange ||
             !pfnInterlockedIncrement ||
             !pfnInterlockedDecrement ||
             !pfnReadDirChangesW ) {

            DBGPRINTF((DBG_CONTEXT,
                "Unable to obtain NT kernel32 entry point\n"));
            goto error_exit;
        }

    } else {
        DBGPRINTF((DBG_CONTEXT,"Error %d loading kernel32.dll\n",
            GetLastError()));
        goto error_exit;
    }
#endif

    //
    // load the service locator entry points. Not fatal on failure.
    //

    // Loading of the inetsloc.dll service is disabled
    //    g_hSvcLocDll = LoadLibrary("inetsloc.dll");
    g_hSvcLocDll = NULL;
    if ( g_hSvcLocDll != NULL ) {

        pfnInetRegisterSvc = (INET_REGISTER_SVC_FN)
                GetProcAddress( g_hSvcLocDll, "INetRegisterService" );

        pfnInetDeregisterSvc = (INET_DEREGISTER_SVC_FN)
                GetProcAddress( g_hSvcLocDll, "INetDeregisterService" );

        pfnInitSvcLoc = (INET_INIT_CONTROL_SVC_FN)
                GetProcAddress( g_hSvcLocDll, "InitSvcLocator" );

        pfnTerminateSvcLoc = (INET_INIT_CONTROL_SVC_FN)
                GetProcAddress( g_hSvcLocDll, "TerminateSvcLocator" );

        if ( !pfnInetRegisterSvc ||
             !pfnInetDeregisterSvc ||
             !pfnInitSvcLoc ||
             !pfnTerminateSvcLoc ) {

            DBGPRINTF((DBG_CONTEXT,"Unable to find an inetsloc entrypoint\n"));
            FreeLibrary( g_hSvcLocDll );
            g_hSvcLocDll = NULL;
        }
    }

    if ( g_hSvcLocDll == NULL ) {
        DBGPRINTF((DBG_CONTEXT,
            "Unable to find an inetsloc.dll entrypoints!!!. Ignore if NTW.\n"));
        pfnInitSvcLoc = (INET_INIT_CONTROL_SVC_FN)DummySvclocFn;
        pfnTerminateSvcLoc = (INET_INIT_CONTROL_SVC_FN)DummySvclocFn;
    }

    //
    // rpcref
    //

    g_hRpcRef = LoadLibrary("rpcref.dll");
    if ( g_hRpcRef != NULL ) {

        pfnInetinfoStartRpcServer = (PFN_INETINFO_START_RPC_SERVER)
            GetProcAddress(g_hRpcRef,"InetinfoStartRpcServerListen");

        pfnInetinfoStopRpcServer = (PFN_INETINFO_STOP_RPC_SERVER)
            GetProcAddress(g_hRpcRef,"InetinfoStopRpcServerListen");
    } else {
        DBGPRINTF((DBG_CONTEXT, "Error %d loading rpcref.dll\n",
            GetLastError() ));
        goto error_exit;
    }

    if ( !LoadNTSecurityEntryPoints( ) ) {
        goto error_exit;
    }

    return(TRUE);

error_exit:
    return(FALSE);

} // GetDynamicEntryPoints



VOID
FreeDynamicLibraries(
    VOID
    )
{
    if ( g_hSchannel != NULL ) {
        FreeLibrary( g_hSchannel );
        g_hSchannel = NULL;
    }

    if ( g_hCrypt32Dll != NULL ) {
        FreeLibrary( g_hCrypt32Dll );
        g_hCrypt32Dll = NULL;
    }

    if ( g_hSecurityDll != NULL ) {
        FreeLibrary( g_hSecurityDll );
        g_hSecurityDll = NULL;
    }

    if ( g_hSvcLocDll != NULL ) {
        FreeLibrary( g_hSvcLocDll );
        g_hSvcLocDll = NULL;
    }

    if ( g_hRpcRef != NULL ) {
        FreeLibrary( g_hRpcRef );
        g_hRpcRef = NULL;
    }

    if ( g_hLonsiNT != NULL ) {
        FreeLibrary( g_hLonsiNT );
        g_hLonsiNT = NULL;
    }

    return;

} // FreeDynamicLibraries



BOOL
LoadNTSecurityEntryPoints(
    VOID
    )
{
    IF_DEBUG(DLL_SECURITY) {
        DBGPRINTF((DBG_CONTEXT,"Entering LoadNTSecurityEntryPoints\n"));
    }

    //
    // Load Schannel
    //

    g_hSchannel = LoadLibrary( "schannel.dll" );

    if ( g_hSchannel != NULL ) {
        fnCrackCert = (SSL_CRACK_CERTIFICATE_FN)
                GetProcAddress( g_hSchannel, "SslCrackCertificate" );
        fnFreeCert = (SSL_FREE_CERTIFICATE_FN)
                GetProcAddress( g_hSchannel, "SslFreeCertificate" );
    } else {
        DBGPRINTF((DBG_CONTEXT,
            "Unable to load schannel.dll[err %d]\n", GetLastError() ));
    }


    //
    // Load Crypt32
    //

    g_hCrypt32Dll = LoadLibrary( "crypt32.dll" );

    if ( g_hCrypt32Dll != NULL ) {
        pfnFreeCertCtxt = (CRYPT32_FREE_CERTCTXT_FN)
                GetProcAddress( g_hCrypt32Dll, "CertFreeCertificateContext" );
        pfnGetCertCtxtProp = (CRYPT32_GET_CERTCTXT_PROP_FN)
                GetProcAddress( g_hCrypt32Dll, "CertGetCertificateContextProperty" );
        pfnCertVerifyRevocation = (CRYPT32_CERT_VERIFY_REVOCATION_FN)
                GetProcAddress( g_hCrypt32Dll, "CertVerifyRevocation" );
        pfnCertVerifyTimeValidity = (CRYPT32_CERT_VERIFY_TIME_VALIDITY)
                GetProcAddress( g_hCrypt32Dll, "CertVerifyTimeValidity" );
        pfnCertNameToStrA = (CRYPT32_CERT_NAME_TO_STR_A_FN)
                GetProcAddress( g_hCrypt32Dll, "CertNameToStrA" );

    } else {
        DBGPRINTF((DBG_CONTEXT,
            "Unable to load crypt32.dll[err %d]\n", GetLastError() ));
    }

    DBG_ASSERT( pfnFreeCertCtxt );
    DBG_ASSERT( pfnGetCertCtxtProp );
    DBG_ASSERT( pfnCertVerifyRevocation );
    DBG_ASSERT( pfnCertVerifyTimeValidity );
    DBG_ASSERT( pfnCertNameToStrA );

    //
    // Load security.dll
    //

    g_hSecurityDll = LoadLibrary( "security.dll" );
    if ( g_hSecurityDll == NULL ) {
        DBGPRINTF((DBG_CONTEXT,"Error %d loading security.dll\n",
            GetLastError()));
        return(FALSE);
    }

    if ( !GetSecurityDllEntryPoints( g_hSecurityDll ) ) {
        return(FALSE);
    }

    //
    // Load lsa stuff from lonsint.dll
    //

    g_hLonsiNT = LoadLibrary( "lonsint.dll" );
    if ( g_hLonsiNT == NULL ) {
        DBGPRINTF((DBG_CONTEXT,"Error %d loading lonsint.dll\n",
            GetLastError()));
        return(FALSE);
    }

    if ( !GetLogonDllEntryPoints( g_hLonsiNT ) ) {
        return FALSE;
    }

    return(TRUE);

} // LoadNTSecurityEntryPoints



BOOL
GetSecurityDllEntryPoints(
    IN HINSTANCE    hInstance
    )
{

    pfnAcceptSecurityContext = (ACCEPT_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "AcceptSecurityContext" );

    pfnAcquireCredentialsHandle = (ACQUIRE_CREDENTIALS_HANDLE_FN)
                GetProcAddress( hInstance, "AcquireCredentialsHandleA" );

    pfnCompleteAuthToken = (COMPLETE_AUTH_TOKEN_FN)
                GetProcAddress( hInstance, "CompleteAuthToken" );

    pfnDeleteSecurityContext = (DELETE_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "DeleteSecurityContext" );

    pfnEnumerateSecurityPackages = (ENUMERATE_SECURITY_PACKAGES_FN)
                GetProcAddress( hInstance, "EnumerateSecurityPackagesA" );

    pfnImpersonateSecurityContext = (IMPERSONATE_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "ImpersonateSecurityContext" );

    pfnInitializeSecurityContext = (INITIALIZE_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "InitializeSecurityContextA" );

    pfnFreeContextBuffer = (FREE_CONTEXT_BUFFER_FN)
                GetProcAddress( hInstance, "FreeContextBuffer" );

    pfnFreeCredentialsHandle = (FREE_CREDENTIALS_HANDLE_FN)
                GetProcAddress( hInstance, "FreeCredentialsHandle" );

    pfnQueryContextAttributes = (QUERY_CONTEXT_ATTRIBUTES_FN)
                GetProcAddress( hInstance, "QueryContextAttributesA" );

    pfnQuerySecurityContextToken = (QUERY_SECURITY_CONTEXT_TOKEN_FN)
                GetProcAddress( hInstance, "QuerySecurityContextToken" );

    pfnQuerySecurityPackageInfo = (QUERY_SECURITY_PACKAGE_INFO_FN)
                GetProcAddress( hInstance, "QuerySecurityPackageInfoA" );

    pfnRevertSecurityContext = (REVERT_SECURITY_CONTEXT_FN)
                GetProcAddress( hInstance, "RevertSecurityContext" );

    if ( !pfnAcceptSecurityContext      ||
         !pfnAcquireCredentialsHandle   ||
         !pfnCompleteAuthToken          ||
         !pfnDeleteSecurityContext      ||
         !pfnEnumerateSecurityPackages  ||
         !pfnImpersonateSecurityContext ||
         !pfnInitializeSecurityContext  ||
         !pfnFreeContextBuffer          ||
         !pfnFreeCredentialsHandle      ||
         !pfnQueryContextAttributes     ||
         !pfnQuerySecurityContextToken  ||
         !pfnQuerySecurityPackageInfo   ||
         !pfnRevertSecurityContext ) {

        DBGPRINTF((DBG_CONTEXT,"Unable to get security entry points\n"));
        SetLastError(ERROR_PROC_NOT_FOUND);
        DBG_ASSERT(FALSE);
        return FALSE;
    }

    return(TRUE);

} // GetSecurityDllEntryPoints


BOOL
GetLogonDllEntryPoints(
    IN HINSTANCE    hInstance
    )
{
    pfnLogon32Initialize = (LOGON32_INITIALIZE_FN)
                GetProcAddress( hInstance, "IISLogon32Initialize" );

    pfnLogonNetUserA = (LOGON_NET_USER_A_FN)
                GetProcAddress( hInstance, "IISLogonNetUserA" );

    pfnLogonNetUserW = (LOGON_NET_USER_W_FN)
                GetProcAddress( hInstance, "IISLogonNetUserW" );

    pfnNetUserCookieA = (NET_USER_COOKIE_A_FN)
                GetProcAddress( hInstance, "IISNetUserCookieA" );

    pfnLogonDigestUserA = (LOGON_DIGEST_USER_A_FN)
                GetProcAddress( hInstance, "IISLogonDigestUserA" );

    pfnGetDefaultDomainName = (GET_DEFAULT_DOMAIN_NAME_FN)
                GetProcAddress( hInstance, "IISGetDefaultDomainName" );

    if ( !pfnLogon32Initialize      ||
         !pfnLogonNetUserA          ||
         !pfnLogonNetUserW          ||
         !pfnNetUserCookieA         ||
         !pfnLogonDigestUserA       ||
         !pfnGetDefaultDomainName ) {

        DBGPRINTF((DBG_CONTEXT,"Unable to get an entry point on lonsint.dll\n"));
        SetLastError( ERROR_PROC_NOT_FOUND );
        DBG_ASSERT(FALSE);
        return FALSE;
    }

    return(TRUE);

} // GetLogonDllEntryPoints


BOOL
DummySvclocFn(
    VOID
    )
{
    return(TRUE);
} // DummySvclocFn
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\cache2\virtroot.cxx ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

       virtroot.cxx

   Abstract:

       This module defines functions for managing virtual roots.

   Author:

      ???                  ( ???)      ??-??-1994/5

   Environment:

      User Mode -- Win32
   Project:

       TSunami DLL for Internet Services

   Functions Exported:



   Revision History:

       MuraliK         Added File System type to information stored about
                          each virtual root.
       MuraliK         Modified TsLookupVirtualRoot() to support variable
                          length buffer and hence check for invalid writes

       MuraliK    22-Jan-1996  Cache & return UNC virtual root impersonation
                                   token.
       MCourage   05-Jan-1997  Moved to cache2 directory for cache rewrite

       SaurabN    07-Oct-1998  Reimplement using LKRHash.
--*/



/************************************************************
 *     Include Headers
 ************************************************************/

#include <tsunami.hxx>
#include "TsunamiP.Hxx"
#pragma hdrstop

#include <mbstring.h>
#include <rpc.h>
#include <rpcndr.h>
#include "dbgutil.h"
#include <string.h>
#include <refb.hxx>
#include <imd.h>
#include <mb.hxx>
#include <iiscnfg.h>
#include <malloc.h>

extern TCHAR * FlipSlashes( TCHAR * pszPath );


IIS_VROOT_TABLE::IIS_VROOT_TABLE(
                            VOID
                            )
:
    CLKRHashTable("IISVRootTable",
                  ExtractKey,
                  CalcKeyHash,
                  EqualKeys,
                  AddRefRecord,
                  DFLT_LK_INITSIZE,
                  LK_SMALL_TABLESIZE),
    m_nVroots           (0 )
{

} // IIS_VROOT_TABLE::IIS_VROOT_TABLE



IIS_VROOT_TABLE::~IIS_VROOT_TABLE(
                            VOID
                            )
{
    RemoveVirtualRoots( );
    DBG_ASSERT( m_nVroots == 0 );

} // IIS_VROOT_TABLE::~IIS_VROOT_TABLE




BOOL
IIS_VROOT_TABLE::AddVirtualRoot(
    PCHAR                  pszRoot,
    PCHAR                  pszDirectory,
    DWORD                  dwAccessMask,
    PCHAR                  pszAccountName,
    HANDLE                 hImpersonationToken,
    DWORD                  dwFileSystem,
    BOOL                   fDoCache
    )
/*++
    Description:

        This function adds a symbolic link root and directory mapping
        part to the virtual root list

        We always strip trailing slashes from the root and directory name.

        If the root is "\" or "/", then the effective root will be zero
        length and will always be placed last in the list.  Thus if a lookup
        can't find a match, it will always match the last entry.

    Arguments:
        pszRoot - Virtual symbolic link root
        pszDirectory - Physical directory
        dwAccessMask - Type of access allowed on this virtual root
        pszAccountName - User name to impersonate if UNC (only gets stored
            for RPC apis)
        hImpersonationToken - Impersonation token to use for UNC
                                directory paths
        dwFileSystem - DWORD containing the file system type
                      ( symbolic constant)
        fDoCache - Should we cache the vdir

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    PVIRTUAL_ROOT_MAPPING   pVrm, pVrmOld;
    PLIST_ENTRY             pEntry;
    BOOL                    fRet = FALSE;
    BOOL                    fUNC;
    DWORD                   cchRoot;
    BOOL                    fAllowEmptyDirectory = !!(dwAccessMask & VROOT_MASK_NO_PHYSICAL_DIR);

    if ( !pszRoot || !pszDirectory || (!*pszDirectory && !fAllowEmptyDirectory) )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (!*pszDirectory)
    {
        fDoCache = FALSE;
    }

    //
    //  Disallow allow UNC roots if we don't have an impersonation token and
    //  this isn't a placeholder
    //

    fUNC = (BOOL)((pszDirectory[0] == '\\') && (pszDirectory[1] == '\\'));

    //
    //  Strip the trailing '/' from the virtual root
    //

    cchRoot = strlen( pszRoot );

    if ( IS_CHAR_TERM_A( pszRoot, cchRoot - 1))
    {
        pszRoot[--cchRoot] = '\0';
    }

    //
    //  Look in the current list and see if the root is already there.
    //  If the directory is the same, we just return success.  If the
    //  directory is different, we remove the old item and add the new one.
    //

    LockShared();

    if (LK_SUCCESS == FindKey((DWORD_PTR) pszRoot, (const void **)&pVrm))
    {
        //
        // Key exists
        //

        if ( !lstrcmpi( pszDirectory, pVrm->pszDirectoryA ) &&
             ((*pszDirectory == '\0') ||
             IS_CHAR_TERM_A( pszDirectory, pVrm->cchDirectoryA ) ))
        {
            //
            //  This root is already in the list
            //

            Unlock();
            return TRUE;

        }
        else
        {

            //
            //  A root is having its directory entry changed
            //

            Unlock();
            SetLastError( ERROR_NOT_SUPPORTED );
            return FALSE;
        }
    }

    //
    // Add a new key
    //

    pVrm = ( PVIRTUAL_ROOT_MAPPING )ALLOC( sizeof( VIRTUAL_ROOT_MAPPING ) );

    if ( pVrm == NULL )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        Unlock();
        return FALSE;
    }

    //
    //  Initialize the new root item
    //

    pVrm->Signature     = VIRT_ROOT_SIGNATURE;
    pVrm->cchRootA      = strlen( pszRoot );

    if (pVrm->cchRootA > MAX_LENGTH_VIRTUAL_ROOT)
    {
       SetLastError( ERROR_BAD_PATHNAME );
       Unlock();
       return FALSE;
    }

    pVrm->cchDirectoryA = strlen( pszDirectory );
    if (pVrm->cchDirectoryA > MAX_PATH)
    {
       SetLastError( ERROR_BAD_PATHNAME );
       Unlock();
       return FALSE;
    }

    pVrm->dwFileSystem  = dwFileSystem;
    pVrm->dwAccessMask  = dwAccessMask;

    pVrm->fUNC                = (BOOLEAN)fUNC;
    pVrm->hImpersonationToken = hImpersonationToken;

    //
    //  The old cache design used APCs to do change notification, the new cache
    //  uses the CDirMon class so we don't need any refcounting.
    //

    strcpy( pVrm->pszRootA, pszRoot );
    strcpy( pVrm->pszDirectoryA, pszDirectory );
    strcpy( pVrm->pszAccountName, pszAccountName ? pszAccountName : "" );

    //
    //  Strip trailing slashes from the root and directory
    //

    if ( (pVrm->cchRootA != 0) &&
         IS_CHAR_TERM_A( pVrm->pszRootA, pVrm->cchRootA - 1 ))
    {
        pVrm->pszRootA[--pVrm->cchRootA] = '\0';
    }

    if ( (pVrm->cchDirectoryA > 0) &&
         IS_CHAR_TERM_A( pVrm->pszDirectoryA, pVrm->cchDirectoryA - 1))
    {
        //
        //  Note we assume virtual directories always begin with a '/...' to
        //  provide the necessary path separator between the root directory
        //  path and the remaining virtual directory
        //

        pVrm->pszDirectoryA[--pVrm->cchDirectoryA] = '\0';
    }

    //
    //  Add the item to the list
    //

    LockConvertExclusive();

    fRet = (LK_SUCCESS == InsertRecord(pVrm));

    if (fRet)
    {
        fRet = fDoCache ? DcmAddRoot( pVrm ) : TRUE;

        if (!fRet)
        {
            DeleteRecord(pVrm);
        }
    }

    if ( fRet)
    {
        m_nVroots++;

        IF_DEBUG( VIRTUAL_ROOTS )
                DBGPRINTF(( DBG_CONTEXT,
                        "Successfully added Vroot - %s => %s\n",
                        pVrm->pszRootA,
                        pVrm->pszDirectoryA ));
    }
    else
    {
        FREE( pVrm );
/*
        //
        // this memory was already released!
        //
        DBGPRINTF(( DBG_CONTEXT,
                    " Error %d adding Vroot - %s => %s\n",
                    GetLastError(),
                    pVrm->pszRootA,
                    pVrm->pszDirectoryA ));
 */
    }

    Unlock();
    return fRet;

} // IIS_VROOT_TABLE::AddVirtualRoot



BOOL
IIS_VROOT_TABLE::LookupVirtualRoot(
    IN     const CHAR *       pszVirtPath,
    OUT    CHAR *             pszDirectory,
    IN OUT LPDWORD            lpcbSize,
    OUT    LPDWORD            lpdwAccessMask,        // Optional
    OUT    LPDWORD            pcchDirRoot,           // Optional
    OUT    LPDWORD            pcchVRoot,             // Optional
    OUT    HANDLE   *         phImpersonationToken,  // Optional
    OUT    LPDWORD            lpdwFileSystem         // Optional
    )
/*++
    Description:

        This function looks in the map list for the specified root
        and returns the corresponding directory

    Arguments:
        pszVirtPath - Virtual symbolic link path
        pszDirectory - receives Physical directory.
                    This is of the size specified by lpcbSize
        lpcbSize - pointer to DWORD containing the size of buffer pszDirectory
                     On retur contains the number of bytes written
        lpdwAccessMask - The access mask for this root
        pcchDirRoot - Number of characters of the directory this virtual
            root maps to (i.e., /foo/ ==> c:\root, lookup "/foo/bar/abc.htm"
            this value returns the length of "c:\root")
        pcchVRoot - Number of characters that made up the found virtual root
            (i.e., returns the lenght of "/foo/")
        phImpersonationToken - pointer to handle object that will contain
           the handle to be used for impersonation for UNC/secure virtual roots
        lpdwFileSystem - on successful return will contain the file system
                        type for the directory matched with root specified.

    Returns:
        TRUE on success and FALSE if any failure.

    History:
        MuraliK     28-Apr-1995   Improved robustness
        MuraliK     18-Jan-1996   Support imperonstaion token

    Note:
       This function is growing in the number of parameters returned.
       Maybe we should expose the VIRTUAL_ROOT_MAPPING structure
         and return a pointer to this object and allow the callers to
         extract all required pieces of data.

--*/
{
    DWORD    dwError = NO_ERROR;
    PVIRTUAL_ROOT_MAPPING   pVrm = NULL;

    DBG_ASSERT( pszDirectory != NULL);
    DBG_ASSERT( lpcbSize != NULL);

    DWORD cchPath = strlen( pszVirtPath );

    char * pszPath = (char *)_alloca(cchPath);  // make local copy that we can modify

    strcpy(pszPath, pszVirtPath);

    //
    //  Strip the trailing '/' from the virtual path
    //

    if ( IS_CHAR_TERM_A( pszPath, cchPath - 1))
    {
        pszPath[--cchPath] = '\0';
    }

    char * pCh = pszPath;

    LockShared();

    while(pCh != NULL)
    {
        if (LK_SUCCESS == FindKey((DWORD_PTR) pszPath, (const void **)&pVrm))
        {
            break;
        }
        else
        {
            //
            // Trim the VRoot path from the right to the next /
            //

            pCh = (char *)IISstrrchr( (const UCHAR *)pszPath, '/');

            if (pCh)
            {
                *pCh = '\0';    // truncate search string
            }
        }
    }

    if (pVrm)
    {

        //
        //  we found a match. return all requested parameters.
        //

        DBG_ASSERT( pVrm->Signature == VIRT_ROOT_SIGNATURE );

        DWORD cbReqd = ( pVrm->cchDirectoryA +
                         strlen(pszVirtPath + pVrm->cchRootA));

        if ( cbReqd <= *lpcbSize)
        {

            PCHAR pathStart = pszDirectory + pVrm->cchDirectoryA;

            //
            //  Copy the physical directory base then append the rest of
            //  the non-matching virtual path
            //

            CopyMemory(
                pszDirectory,
                pVrm->pszDirectoryA,
                pVrm->cchDirectoryA
                );

            strcpy( pathStart,
                    pszVirtPath + pVrm->cchRootA );

            if ( lpdwFileSystem != NULL) {
                *lpdwFileSystem = pVrm->dwFileSystem;
            }

            if ( pcchDirRoot ) {
                *pcchDirRoot = pVrm->cchDirectoryA;
            }

            if ( pcchVRoot ) {
                *pcchVRoot = pVrm->cchRootA;
            }

            if ( lpdwAccessMask != NULL) {
                *lpdwAccessMask = pVrm->dwAccessMask;
            }

            if ( phImpersonationToken != NULL) {

                // Should we increment refcount of the impersonation token?
                *phImpersonationToken = pVrm->hImpersonationToken;
            }

            Unlock();

            FlipSlashes( pathStart );
            *lpcbSize = cbReqd;

            return(TRUE);

        } else {

            dwError = ERROR_INSUFFICIENT_BUFFER;
        }

        *lpcbSize = cbReqd;
    }

    if ( lpdwAccessMask ) {
        *lpdwAccessMask = 0;
    }

    if ( lpdwFileSystem != NULL) {
        *lpdwFileSystem  = FS_ERROR;
    }

    if ( phImpersonationToken != NULL) {
        *phImpersonationToken = NULL;
    }

    if ( dwError == NO_ERROR) {
        dwError = ERROR_PATH_NOT_FOUND;
    }
    SetLastError( dwError );

    Unlock();
    return FALSE;

} // IIS_VROOT_TABLE::LookupVirtualRoot




BOOL
IIS_VROOT_TABLE::RemoveVirtualRoots(
    VOID
    )
/*++
    Description:

        Removes all of the virtual roots for the instance

    Arguments:
        None.

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{

    PVIRTUAL_ROOT_MAPPING   pVrm;

    CIterator               iter;
    DWORD                   dwValue;

    LockExclusive();

    LK_RETCODE  lkrc = InitializeIterator(&iter);

    while (LK_SUCCESS == lkrc)
    {
        pVrm = (PVIRTUAL_ROOT_MAPPING) iter.Record();

        DBG_ASSERT( pVrm->Signature == VIRT_ROOT_SIGNATURE );

        //
        // Increment the iterator before removing the record from the Hash
        // Table else we hit an Assert in the increment.
        //

        lkrc = IncrementIterator(&iter);

        DeleteVRootEntry(pVrm);    // Removes from Hash Table Also
    }

    CloseIterator(&iter);

    Clear();

    Unlock();
    return TRUE;

} // TsRemoveVirtualRoots



BOOL
IIS_VROOT_TABLE::RemoveVirtualRoot(
    IN  PCHAR              pszVirtPath
    )
/*++
    Description:

        Removes the virtual roots named pszVirtPath for the instance.

    Arguments:
        pszVirtPath - Name of the virtual root to remove.

    Returns:
        TRUE on success and FALSE if any failure.

--*/
{
    PVIRTUAL_ROOT_MAPPING   pVrm;
    BOOL                    bSuccess = FALSE;

    DWORD cchPath = strlen( pszVirtPath );

    //
    //  Strip the trailing '/' from the virtual path
    //

    if ( IS_CHAR_TERM_A( pszVirtPath, cchPath - 1))
    {
        pszVirtPath[--cchPath] = '\0';
    }

    LockExclusive();

   if (LK_SUCCESS == FindKey((DWORD_PTR) pszVirtPath, (const void **)&pVrm))
   {
        //
        // Found a match
        //

        DeleteRecord(pVrm);       // Remove Entry from Hash Table
        DeleteVRootEntry(pVrm);

        bSuccess = TRUE;
   }

    Unlock();
   return bSuccess;
}


VOID
IIS_VROOT_TABLE::DeleteVRootEntry(
    IN PVOID   pEntry
)
{

    DBG_ASSERT(NULL != pEntry);

    PVIRTUAL_ROOT_MAPPING pVrm = (PVIRTUAL_ROOT_MAPPING)pEntry;

    DBG_ASSERT(pVrm->Signature == VIRT_ROOT_SIGNATURE );

    m_nVroots--;

    IF_DEBUG( DIRECTORY_CHANGE )
        DBGPRINTF(( DBG_CONTEXT,
                    "Removing root %s\n",
                     pVrm->pszDirectoryA ));

    //
    // Remove reference to Dir Monitor
    //

    DcmRemoveRoot( pVrm );

    //
    // We need to close the impersonation token, if one exists.
    //

    if ( pVrm->hImpersonationToken != NULL)
    {
        DBG_REQUIRE( CloseHandle( pVrm->hImpersonationToken ));
        pVrm->hImpersonationToken = NULL;
    }

    pVrm->Signature = 0;
    FREE( pVrm );
}


const DWORD_PTR
IIS_VROOT_TABLE::ExtractKey(const void* pvRecord)
{
    PVIRTUAL_ROOT_MAPPING   pVrm = (PVIRTUAL_ROOT_MAPPING)pvRecord;
    return (DWORD_PTR)pVrm->pszRootA;
}

DWORD
IIS_VROOT_TABLE::CalcKeyHash(const DWORD_PTR pnKey)
{
    return HashStringNoCase((LPCSTR)pnKey);
}

bool
IIS_VROOT_TABLE::EqualKeys(const DWORD_PTR pnKey1, const DWORD_PTR pnKey2)
{
    return ( IISstricmp((UCHAR *)pnKey1, (UCHAR *)pnKey2) == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\certnotf.cxx ===
/*++







Copyright (c) 1995  Microsoft Corporation

Module Name:

   certnotf.cxx

Abstract:

    This module contains the code for the class to deal with CAPI store change notifications

Author:

    Alex Mallet [amallet] 17-Dec-1997

Revision History:
--*/



#include "tcpdllp.hxx"
#pragma hdrstop

#include <winbase.h>
#include <dbgutil.h>
#include <ole2.h>
#include <imd.h>
#include <nturtl.h>
#include <certnotf.hxx>



#if DBG
#define VALIDATE_HEAP() DBG_ASSERT( RtlValidateProcessHeaps() )
#else
#define VALIDATE_HEAP()
#endif 

DWORD STORE_CHANGE_ENTRY::m_dwNumEntries = 0;
CRITICAL_SECTION *STORE_CHANGE_NOTIFIER::m_pStoreListCS = NULL;


STORE_CHANGE_NOTIFIER::STORE_CHANGE_NOTIFIER() :
m_dwSignature(NOTIFIER_GOOD_SIG)
/*++

Routine Description:

     Constructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    //
    // Critical sections
    //
    if ( !STORE_CHANGE_NOTIFIER::m_pStoreListCS )
    {
        STORE_CHANGE_NOTIFIER::m_pStoreListCS = new CRITICAL_SECTION;
        
        if ( STORE_CHANGE_NOTIFIER::m_pStoreListCS )
        {
            INITIALIZE_CRITICAL_SECTION(STORE_CHANGE_NOTIFIER::m_pStoreListCS);
        }
        else
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Failed to allocate memory for store list critical section !\n"));
        }
    }
    
    InitializeListHead( &m_StoreList );
}

STORE_CHANGE_NOTIFIER::~STORE_CHANGE_NOTIFIER()
/*++

Routine Description:

    Destructor

Arguments:

    None

Returns:

    Nothing

--*/
{
    DBG_ASSERT( CheckSignature() );

    STORE_CHANGE_NOTIFIER::Lock();

    //
    // Clean up all the stores, so we don't get bitten in the @$$ when trying to
    // clean up the STORE_CHANGE_ENTRY objects : CertCloseStore() calls RtlDeregisterWait()
    // which can't be called from inside a callback function, so we need to clean up 
    // the cert stores before triggering any of the callbacks used to clean up the
    // STORE_CHANGE_ENTRY objects.
    //
    LIST_ENTRY *pListEntry;
    STORE_CHANGE_ENTRY *pStoreEntry;

    for ( pListEntry = m_StoreList.Flink;
          pListEntry != &m_StoreList;
          pListEntry = pListEntry->Flink )
    {
        pStoreEntry = CONTAINING_RECORD( pListEntry, STORE_CHANGE_ENTRY, m_StoreListEntry );
        
        CertCloseStore( pStoreEntry->m_hCertStore,
                        0 );
        pStoreEntry->m_hCertStore = NULL;
    }

    //
    // Go through both the active and inactive store entries and start the process to
    // clean them up [they'll actually be cleaned up on a different thread, in a callback from
    // the thread pool].
    //
    while ( !IsListEmpty( &m_StoreList ) )
    {
        pStoreEntry = CONTAINING_RECORD( m_StoreList.Flink,
                                    STORE_CHANGE_ENTRY,
                                    m_StoreListEntry );

        RemoveEntryList( &(pStoreEntry->m_StoreListEntry) );
        
        InitializeListHead( &(pStoreEntry->m_StoreListEntry) );

        StartCleanup( pStoreEntry );
    }

    STORE_CHANGE_NOTIFIER::Unlock();

    //
    // The STORE_CHANGE_ENTRY objects are cleaned up on a different so we loop and wait 
    // until they've all been cleaned up, to avoid problems with a thread/DLL going away
    // before proper cleanup has occurred.
    //
    DWORD dwNumWaits = 0;
    DWORD dwNumEntries = 0;
    while ( ( dwNumEntries = STORE_CHANGE_ENTRY::QueryStoreEntryCount() ) &&
            dwNumWaits < 30 * 5 ) //sleep for 2 secs => 30x/min, wait for 5 mins
    {
        Sleep( 2000 );

        DBGPRINTF((DBG_CONTEXT,
                   "Waiting %d seconds for %d store entries to be cleaned up\n",
                   dwNumWaits * 2,
                   dwNumEntries));

        dwNumWaits++;
    }

    if ( dwNumEntries != 0 )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "WARNING : Failed to clean up all STORE_CHANGE_ENTRY objects, %d left\n",
                   dwNumEntries));
    }
    else
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Cleaned up all store entries \n"));
    }

    m_dwSignature = NOTIFIER_BAD_SIG;

}

VOID STORE_CHANGE_NOTIFIER::ReleaseRegisteredStores()
/*++

Routine Description:

    Releases all the events that have been registered for store change notifications
    and closes the stores that were being watched.

Arguments:

    None

Returns:

    Nothing

--*/

{
    LIST_ENTRY *        pEntry;

    DBG_ASSERT( CheckSignature() );

    STORE_CHANGE_NOTIFIER::Lock();

    for ( pEntry = m_StoreList.Flink;
          pEntry != &m_StoreList;
          pEntry = pEntry->Flink )
    {
        STORE_CHANGE_ENTRY *pStoreEntry = CONTAINING_RECORD( pEntry,
                                                             STORE_CHANGE_ENTRY,
                                                             m_StoreListEntry );
                                                        
        StartCleanup( pStoreEntry );
    }

    STORE_CHANGE_NOTIFIER::Unlock();
}


VOID STORE_CHANGE_NOTIFIER::StartCleanup( IN STORE_CHANGE_ENTRY *pEntry )
/*++

Routine Description:

    Start the cleanup for a STORE_CHANGE_ENTRY object.
    This function MUST be called between calls to STORE_CHANGE_NOTIFIER::Lock()/Unlock() !

Arguments:

    pEntry - STORE_CHANGE_ENTRY to clean up.

Returns:

    Nothing

--*/

{
    //
    // Grab the lock, mark the entry as being ready for deletion,signal the event associated 
    // with it and release a reference to the entry . We hold the lock, so we have exclusive 
    // access to the entries. Possible execution paths : 
    //
    // #1. No callback comes in while we're executing this code. We set the deletion bit and 
    // signal the event. If the callback now fires, it smacks into
    // the lock and waits its turn. If it doesn't fire, that's OK too. We unlock and go on our 
    // merry way. At some point in time, the callback -will- fire, because we didn't call 
    // UnregisterWait(). Then, in the callback, we see the "delete me" flag and delete the
    // entry. Also, the wait is cancelled because we acquired the wait handle with the 
    // WT_EXECUTEDELETEWAIT flag, which removes the wait immediately after calling the callback. 
    // 
    // #2. A callback comes in while we're executing this code. It waits to acquire the lock,
    // and by the time it acquires it we've set the deletion bit and signalled the event.
    // The callback sees the deletion bit and deletes the entry. The wait is cancelled, and
    // so it doesn't matter that we signalled the event.
    //

    pEntry->MarkForDelete();
    
    SetEvent( pEntry->QueryStoreEvent() );

}

BOOL STORE_CHANGE_NOTIFIER::IsStoreRegisteredForChange( IN LPTSTR pszStoreName,
                                                        IN NOTIFFNCPTR pFncPtr,
                                                        IN LPVOID pvParam )
/*++

Routine Description:

    Check whether the store described by the parameters already has an event registered
    for change notifications. 

Arguments:

    pszStoreName - name of cert store
    pFncPtr - pointer to  notification function. If pFncPtr == INVALID_FNC_PTR, checks for any
    notification functions
    pvParam - arg to notification function; if pFncPtr == INVALID_FNC_PTR, is ignored

Returns:

   TRUE if store is registered, FALSE if not.

--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( pszStoreName );
    DBG_ASSERT( pFncPtr );

    PSTORE_CHANGE_ENTRY pEntry = InternalIsStoreRegisteredForChange( pszStoreName,
                                                                     pFncPtr,
                                                                     pvParam ) ;


    return ( pEntry ? TRUE : FALSE );

}

PSTORE_CHANGE_ENTRY
STORE_CHANGE_NOTIFIER::InternalIsStoreRegisteredForChange( IN LPTSTR pszStoreName,
                                                           IN NOTIFFNCPTR pFncPtr,
                                                           IN LPVOID pvParam )

/*++

Routine Description:

    Check whether the store described by the parameters already has an event registered
    for change notifications. 

Arguments:

    pszStoreName - name of cert store
    pFncPtr - pointer to notification function. If pFncPtr == INVALID_FNC_PTR, checks for any
    notification functions
    pvParam - arg for notification function. Ignored if pFncPtr == INVALID_FNC_PTR

Returns:

   pointer to STORE_ENTRY structure that contains the registration info, NULL if non-existent.

--*/

{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( pszStoreName );
    DBG_ASSERT( pFncPtr );

    STORE_CHANGE_ENTRY *pStoreEntry = NULL, *pMatchingEntry = NULL;
    LIST_ENTRY *pEntry;
    BOOL fFound = FALSE;

    STORE_CHANGE_NOTIFIER::Lock();

    for ( pEntry = m_StoreList.Flink;
          pEntry != &m_StoreList;
          pEntry = pEntry->Flink )
    {
        pStoreEntry = CONTAINING_RECORD( pEntry, STORE_CHANGE_ENTRY, m_StoreListEntry );

        if ( pStoreEntry->Matches( pszStoreName,
                                   pFncPtr,
                                   pvParam ) )
        {
            pMatchingEntry = pStoreEntry;
            break;
        }
    }

    STORE_CHANGE_NOTIFIER::Unlock();

    return pMatchingEntry;
}


BOOL STORE_CHANGE_NOTIFIER::RegisterStoreForChange( IN LPTSTR pszStoreName,
                                                    IN HCERTSTORE hStore,
                                                    IN NOTIFFNCPTR pFncPtr,
                                                    IN LPVOID pvParam )
/*++

Routine Description:

    Register the store for change notifications

    Critical Sections acquired : m_pStoreListCS, m_pStoreArrayCS

Arguments:

    pszStoreName - name of cert store
    hCertStore - handle to cert store 
    pFncPtr - pointer to notification function
    pvParam  - arg to notification function

Returns:

   TRUE if store was registered, FALSE if not
--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( pszStoreName );
    DBG_ASSERT( pFncPtr );

    BOOL fAlreadyRegistered = FALSE;
    BOOL fSuccess = FALSE;
    PSTORE_CHANGE_ENTRY pStoreEntry = NULL;

    STORE_CHANGE_NOTIFIER::Lock();

    //
    // Check whether there already some notifications on this store
    //
    pStoreEntry = InternalIsStoreRegisteredForChange( pszStoreName,
                                                      (NOTIFFNCPTR)   INVALID_FNC_PTR,
                                                      NULL );

    fAlreadyRegistered = (pStoreEntry == NULL ? FALSE : TRUE );

    //
    // If this is a totally new store, need to allocate and fill in new store watch entry
    //
    if ( !pStoreEntry )
    {
        HCERTSTORE hCertStore = NULL;
        HANDLE hStoreEvent = NULL;
        HANDLE hWaitHandle = NULL;

        pStoreEntry = new STORE_CHANGE_ENTRY( this,
                                              pszStoreName, 
                                              hStore,
                                              pFncPtr,
                                              pvParam) ;
        
        if ( !pStoreEntry || pStoreEntry->GetLastError() )
        {
            if ( pStoreEntry )
            {
                SetLastError( pStoreEntry->GetLastError() );
            }
            goto EndRegisterStore;
        }

        //
        // Add the entire entry to the list of stores to be watched
        //
        InsertTailList( &m_StoreList, &pStoreEntry->m_StoreListEntry );                      
    }
    //
    // Else, possibly update the notification functions to be called - only update
    // if there isn't already a copy of this function with the same parameters
    //
    else
    {
        DBG_ASSERT( pStoreEntry->QueryStoreHandle() &&
                    pStoreEntry->QueryStoreEvent() &&
                    pStoreEntry->QueryNotifier() &&
                    pStoreEntry->QueryWaitHandle() );

        if ( !pStoreEntry->ContainsNotifFnc( pFncPtr,
                                             pvParam ) )
        {
            if ( !pStoreEntry->AddNotifFnc( pFncPtr,
                                            pvParam ) )
            {
                SetLastError( pStoreEntry->GetLastError() );
                goto EndRegisterStore;
            }
        }
    }

    fSuccess = TRUE;

EndRegisterStore:
    
    if ( !fSuccess )
    {
        //
        // If we failed to register the store and we allocated a new STORE_CHANGE_ENTRY
        // object, clean it up. Note that ref count is only set if everything succeeds
        //
        if ( !fAlreadyRegistered && pStoreEntry )
        {
            delete pStoreEntry;
        }

        DBGPRINTF((DBG_CONTEXT,"Failed to register store %s : 0x%x\n",
                   pszStoreName, GetLastError()));
    }

    STORE_CHANGE_NOTIFIER::Unlock();

    return fSuccess;
}


VOID STORE_CHANGE_NOTIFIER::UnregisterStore( IN LPTSTR pszStoreName,
                                             IN NOTIFFNCPTR pNotifFnc,
                                             IN LPVOID pvParam )
/*++

Routine Description:

   Unregister a notification function for a store

Arguments:

   pszStoreName - name of store
   pNotifFnc - notification function to deregister. If pNotifFnc == INVALID_FNC_PTR,
   all notifications for that store are removed
   pvParam - arg to notification function. Ignored if pNotifFnc == INVALID_FNC_PTR

--*/
{
    DBG_ASSERT( CheckSignature() );

    DBG_ASSERT( pszStoreName );
    DBG_ASSERT( pNotifFnc );

    STORE_CHANGE_ENTRY *pStoreEntry;
    LIST_ENTRY *pEntry;
    BOOL fRemoveAll = (pNotifFnc == (NOTIFFNCPTR) INVALID_FNC_PTR ? TRUE : FALSE );

    STORE_CHANGE_NOTIFIER::Lock();

    //
    // Iterate through the active list to find it
    //
    for ( pEntry = m_StoreList.Flink;
          pEntry != &m_StoreList;
          pEntry = pEntry->Flink )
    {
        pStoreEntry = CONTAINING_RECORD( pEntry, STORE_CHANGE_ENTRY, m_StoreListEntry );

        if ( pStoreEntry->Matches( pszStoreName,
                                   pNotifFnc,
                                   pvParam  ) )
        {
            //
            // If we're removing all notifications for this store, or there will be no
            // notification functions left for this store, clean everything up
            //
            if ( fRemoveAll || ( pStoreEntry->RemoveNotifFnc( pNotifFnc,
                                                              pvParam ) &&
                                 !pStoreEntry->HasNotifFncs() ) )
            {
                StartCleanup( pStoreEntry );
            }

            break;
        }

    }

    STORE_CHANGE_NOTIFIER::Unlock();
}
    

#if DBG
VOID STORE_CHANGE_NOTIFIER::DumpRegisteredStores()
/*++

Routine Description:

  Dumps all the stores currently being watched

Arguments:

   None

Returns:

   Nothing 
--*/

{
    STORE_CHANGE_ENTRY *pStoreEntry = NULL;
    LIST_ENTRY *pEntry1 = NULL, *pEntry2 = NULL;

    DBG_ASSERT( CheckSignature() );

    STORE_CHANGE_NOTIFIER::Lock();


    DBGPRINTF((DBG_CONTEXT,
                   "------------------------------------------------------------------------\nRegistered Stores : \n"));

    for ( pEntry1 = m_StoreList.Flink;
          pEntry1 != &m_StoreList;
          pEntry1 = pEntry1->Flink )
    {
        pStoreEntry = CONTAINING_RECORD( pEntry1, 
                                         STORE_CHANGE_ENTRY,
                                         m_StoreListEntry );
                                                            
        DBGPRINTF((DBG_CONTEXT,
                   "Store %s, store handle 0x%x, event handle 0x%x, wait handle 0x%x has the ff functions registered : \n", 
                   pStoreEntry->QueryStoreName(),
                   pStoreEntry->QueryStoreHandle(),
                   pStoreEntry->QueryStoreEvent(), 
                   pStoreEntry->QueryWaitHandle() ));

        LIST_ENTRY *pFncs = pStoreEntry->QueryNotifFncChain();

        for ( pEntry2 = pFncs->Flink;
              pEntry2 != pFncs;
              pEntry2 = pEntry2->Flink )
        {
            PNOTIF_FNC_CHAIN_ENTRY pNFE = CONTAINING_RECORD( pEntry2,
                                                             NOTIF_FNC_CHAIN_ENTRY,
                                                             ListEntry );

            DBGPRINTF((DBG_CONTEXT,"Function 0x%x, parameter 0x%x\n",
                       pNFE->pNotifFnc,
                       pNFE->pvParam ));
        }

    }
    DBGPRINTF((DBG_CONTEXT,
               "------------------------------------------------------------------------\n"));

    STORE_CHANGE_NOTIFIER::Unlock();
}
#endif //DBG


VOID NTAPI STORE_CHANGE_NOTIFIER::NotifFncCaller( IN PVOID pvCallbackArg,
                                                  IN BOOLEAN fUnused )
/*++

Routine Description:

   This is the function called when one of the events we registered for is signalled.
   The context passed in can be in one of three states :

   1. Valid : has an associated chain of notification functions that are to be called.
   2. Invalid : don't do any processing, because we're not interested in that store anymore
   ie UnregisterStore() has been called on it
   3. To Be Deleted : the context is to be deleted, because we're shutting down 

Arguments:

   pvCallbackArg - context pointer 
   fUnused - boolean, not used. [part of WAITFORTIMERCALLBACKFUNC prototype, which this function
   has to conform to]

--*/
{
    LIST_ENTRY *            pNotifFncChain = NULL;
    PSTORE_CHANGE_ENTRY     pEntry = NULL;
    
    if ( !pvCallbackArg )
    {
        DBG_ASSERT( FALSE ); //make sure we barf in debug build

        return;
    }
   
    pEntry = (PSTORE_CHANGE_ENTRY) pvCallbackArg;

    //
    // Make sure we have exclusive access 
    //
    STORE_CHANGE_NOTIFIER::Lock();

    DBG_ASSERT( pEntry->CheckSignature() );

    //
    // If we signalled the event ourselves because we need to clean up this context,
    // just delete it - we know we won't get any more callbacks, since we acquired the
    // wait handle with WTEXECUTEDELETEWAIT. We don't need to remove it from a list 
    // because it has already been removed prior to this callback being generated. 
    // [in the destructor for STORE_CHANGE_NOTIFIER]
    //
    if ( !pEntry->IsMarkedForDelete() && !pEntry->IsInvalid() )
    {
        //
        // Make a copy of the list of notification functions to call, so that even if
        // one of the functions called changes the list, we still have a kosher copy to
        // work with. 
        //
        // Note that another assumption is that if functions A and B are both in the list
        // being walked, and A is called before B, it doesn't destroy anything that B uses.
        //
        
        pNotifFncChain = CopyNotifFncChain( pEntry->QueryNotifFncChain() );
        
        //
        // Remove this entry from the active list and delete it: it'll never get notified again
        // because we acquired it with the WTEXECUTEDELETEWAIT flag 
        //
        
    }
    
    RemoveEntryList( &(pEntry->m_StoreListEntry) );

    delete pEntry;

    STORE_CHANGE_NOTIFIER::Unlock();

    // Call the notification functions now, after releasing the lock.  This
    // prevents deadlock with SSPIFILT.  In particular the scenario where:
    //
    // SSPIFILT__AddFullyQualifiedItem acquires SSPI then StoreChange
    // NotifyFncCaller acquires StoreChange then SSPI 
    //
    // should be avoided

    if ( pNotifFncChain )
    {
        NOTIF_FNC_CHAIN_ENTRY * pChainEntry = NULL;
        LIST_ENTRY *            pListEntry = NULL;
        
        //
        // Walk the list, call the functions and be generally studly ...
        //
        
        for ( pListEntry =  pNotifFncChain->Flink;
              pListEntry != pNotifFncChain;
              pListEntry = pListEntry->Flink )
        {
            pChainEntry = CONTAINING_RECORD( pListEntry, NOTIF_FNC_CHAIN_ENTRY,
                                                 ListEntry );
                
            if ( pChainEntry->pNotifFnc )
            {
#ifdef NOTIFICATION_DBG
                DBGPRINTF((DBG_CONTEXT,
                           "Calling notification fnc %p, arg %p\n",
                           pChainEntry->pNotifFnc, pChainEntry->pvParam));
#endif                                

                pChainEntry->pNotifFnc( pChainEntry->pvParam );

            }
        }
            
        DeallocateNotifFncChain( pNotifFncChain );
    }                

    return;
}

STORE_CHANGE_ENTRY::STORE_CHANGE_ENTRY( STORE_CHANGE_NOTIFIER *pNotifier,
                                        LPSTR pszStoreName,
                                        HCERTSTORE hStore,
                                        NOTIFFNCPTR pFncPtr,
                                        PVOID pvParam ) :
m_dwSignature( STORE_ENTRY_GOOD_SIG ),
m_pNotifier( pNotifier ),
m_dwRefCount( -1 ),
m_dwError( 0 ),
m_hCertStore( NULL ),
m_hStoreEvent( NULL ),
m_hWaitHandle( NULL ),
m_fDeleteMe( FALSE ),
m_fInvalid( FALSE ),
m_strStoreName( pszStoreName )
/*++

Routine Description:

  Constructor

Arguments:

  pNotifier - parent notifier object
  pszStoreName - name of store to be watched
  hStore - handle to store to be watched
  pFncPtr - notification function to call when store changes
  pvParam - arg to notification function

Returns:
  
  Nothing 

--*/
{
    PNOTIF_FNC_CHAIN_ENTRY pNewNotifFnEntry = NULL;

    INITIALIZE_CRITICAL_SECTION( &m_CS );

    InitializeListHead( &m_NotifFncChain );

    //
    // Duplicate store handle to watch
    //
    m_hCertStore = CertDuplicateStore( hStore );

    //
    // Create the event to be signalled when store changes
    //
    if ( !(m_hStoreEvent = CreateEvent( NULL, //default attributes,
                                        TRUE,
                                        FALSE, //initally non-signalled
                                        NULL ) ) ) //no name
    {
        m_dwError = GetLastError();
        return;
    }
        
    //
    // Register with wait thread pool
    //
#if 1
    if ( !NT_SUCCESS( RtlRegisterWait( &m_hWaitHandle,
                                       m_hStoreEvent,
                                       STORE_CHANGE_NOTIFIER::NotifFncCaller,
                                       (PVOID) this,
                                       INFINITE,
                                       WT_EXECUTEONLYONCE ) ) )
#else

    if ( !(m_hWaitHandle = RegisterWaitForSingleObjectEx( m_hStoreEvent, 
                                                        STORE_CHANGE_NOTIFIER::NotifFncCaller,
                                                        (PVOID) this,
                                                        INFINITE,
                                                        WT_EXECUTEONLYONCE ) ) )
#endif 
    {
        m_dwError = GetLastError();
        goto cleanup;
    }

    //
    // Register for change events on the store
    //
    if ( !CertControlStore( m_hCertStore,
                            0,
                            CERT_STORE_CTRL_NOTIFY_CHANGE,
                            (LPVOID) &m_hStoreEvent) )
    {
        m_dwError = GetLastError();
        goto cleanup;
    }


    //
    // Create a new chain of notification functions
    //
    pNewNotifFnEntry = new NOTIF_FNC_CHAIN_ENTRY;
    if ( !pNewNotifFnEntry )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Couldn't allocate new notification function chain : 0x%x\n",
                   GetLastError()));
        m_dwError = ERROR_OUTOFMEMORY;
        goto cleanup;
    }

    pNewNotifFnEntry->pNotifFnc = pFncPtr;
    pNewNotifFnEntry->pvParam = pvParam;

    //
    // Add the function to the chain
    //
    InsertTailList( &m_NotifFncChain, &pNewNotifFnEntry->ListEntry );              

    //
    // Increment number of entry objects, to help in cleanup later
    //
    STORE_CHANGE_ENTRY::IncrementStoreEntryCount();

cleanup:

    //
    // Cleanup that's only done on error
    //
    if ( m_dwError != 0 )
    {
        if ( m_hWaitHandle )
        {
            RtlDeregisterWait( m_hWaitHandle );
            m_hWaitHandle = NULL;
        }

        if ( m_hStoreEvent )
        {
            CloseHandle( m_hStoreEvent );
            m_hStoreEvent = NULL;
        }

        if ( m_hCertStore )
        {
            CertCloseStore( m_hCertStore,
                            0 );
            m_hCertStore = NULL;
        }

        //
        // Go through the chain of notification functions and clean it up
        //
        while ( !IsListEmpty(&(m_NotifFncChain)) )
        {
            NOTIF_FNC_CHAIN_ENTRY *pChainEntry = CONTAINING_RECORD( m_NotifFncChain.Flink,
                                                                    NOTIF_FNC_CHAIN_ENTRY,
                                                                    ListEntry );
            RemoveEntryList( &(pChainEntry->ListEntry) );
            
            delete pChainEntry;
        }
    }

}

STORE_CHANGE_ENTRY::~STORE_CHANGE_ENTRY()
/*++

Routine Description:

   Destructor 

Arguments:

   None

Return value:

   None
--*/

{
    DBG_ASSERT( CheckSignature() );

    //
    // No need to call RtlDeregisterWait() for the handle, since it's already been
    // deregistered [after having been used in the callback]
    //

    //
    // Clean up store change event
    //
    if ( m_hStoreEvent )
    {
        CloseHandle( m_hStoreEvent );
        m_hStoreEvent = NULL;
    }

    //
    // Close cert store
    //
    if ( m_hCertStore )
    {
        CertCloseStore( m_hCertStore,
                        0 );
        m_hCertStore = NULL;
    }

    //
    // Go through the chain of notification functions and clean it up
    //
    while ( !IsListEmpty(&(m_NotifFncChain)) )
    {
        NOTIF_FNC_CHAIN_ENTRY *pChainEntry = CONTAINING_RECORD( m_NotifFncChain.Flink,
                                                                NOTIF_FNC_CHAIN_ENTRY,
                                                                ListEntry );
        RemoveEntryList( &(pChainEntry->ListEntry) );

        delete pChainEntry;
    }

    DeleteCriticalSection( &m_CS );

    //
    // Another one bites the dust ...
    //
    STORE_CHANGE_ENTRY::DecrementStoreEntryCount();

    m_dwSignature = STORE_ENTRY_BAD_SIG;

}


BOOL STORE_CHANGE_ENTRY::ContainsNotifFnc( IN NOTIFFNCPTR pFncPtr,
                                           IN LPVOID pvParam )
/*++

Routine Description:

   Checks whether the given store watch entry contains the specified notification function with
   the specified args

Arguments:

  pFncPtr - pointer to notification function 
  pvParam - arg to notification function
Returns:
  
   True if function is found, false otherwise
--*/

{
    NOTIF_FNC_CHAIN_ENTRY *pChainEntry;
    LIST_ENTRY *pEntry = NULL;
    BOOL fFound = FALSE;

    Lock();

    for ( pEntry = m_NotifFncChain.Flink;
          pEntry != &m_NotifFncChain;
          pEntry = pEntry->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pEntry, NOTIF_FNC_CHAIN_ENTRY, ListEntry );

        if ( pChainEntry->pNotifFnc == pFncPtr && pChainEntry->pvParam == pvParam )
        {
            fFound = TRUE;
            break;
        }
    }

    Unlock();

    return fFound;
}    


BOOL STORE_CHANGE_ENTRY::AddNotifFnc( IN NOTIFFNCPTR pFncPtr,
                                      IN LPVOID pvParam )
/*++

Routine Description:

  Adds a notification function to a store entry

Arguments:

  pFncPtr - pointer to notification function 
  pvParam - arg to notification function

Returns:
  
   TRUE if function is added, FALSE otherwise
--*/

{
    PNOTIF_FNC_CHAIN_ENTRY pNewFnc = new NOTIF_FNC_CHAIN_ENTRY;
    
    if ( !pNewFnc )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Failed to get new notif fnc entry : 0x%x\n",
                   GetLastError()));

        m_dwError = ERROR_OUTOFMEMORY;
        return FALSE;
    }

    pNewFnc->pNotifFnc = pFncPtr;
    pNewFnc->pvParam = pvParam;

    Lock();

    InsertTailList( &m_NotifFncChain, &pNewFnc->ListEntry );

    Unlock();

    return TRUE;
}

BOOL STORE_CHANGE_ENTRY::RemoveNotifFnc( IN NOTIFFNCPTR pFncPtr,
                                         IN LPVOID pvParam )
/*++

Routine Description:

  Removes a notification function from a store entry

Arguments:

  pFncPtr - pointer to notification function 
  pvParam - arg to notification function

Returns:
  
   Noting
--*/
{
    NOTIF_FNC_CHAIN_ENTRY *pChainEntry;
    LIST_ENTRY *pEntry = NULL;

    Lock();

    for ( pEntry = m_NotifFncChain.Flink;
          pEntry != &m_NotifFncChain;
          pEntry = pEntry->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pEntry, NOTIF_FNC_CHAIN_ENTRY, ListEntry );

        if ( pChainEntry->pNotifFnc == pFncPtr && pChainEntry->pvParam == pvParam )
        {
            RemoveEntryList( pEntry );

            break;
        }
    }
    
    Unlock();

    return TRUE;
}

BOOL STORE_CHANGE_ENTRY::Matches( IN LPSTR pszStoreName,
                                  IN NOTIFFNCPTR pFncPtr,
                                  IN PVOID pvParam )
/*++

Routine Description:

   Checks whether a given store change object matches the given store/function combination

Arguments:

    pszStoreName - name of cert store
    pFncPtr - pointer to notification function; may be INVALID_FNC_PTR if any function will match
    pvParam - parameter for function pointed to by pFncPtr

Return Value:

    TRUE if it matches, FALSE if not 

--*/
{
    BOOL fFound = FALSE;

    Lock();

    if ( ( ( m_strStoreName.IsEmpty() && pszStoreName == NULL) ||
            !strcmp(m_strStoreName.QueryStr(), pszStoreName)  ) && 
             ( pFncPtr == (NOTIFFNCPTR) INVALID_FNC_PTR || 
               ContainsNotifFnc( pFncPtr,
                                 pvParam ) ) )
    {
        fFound = TRUE;
    }

    Unlock();

    return fFound;
}


LIST_ENTRY* CopyNotifFncChain( LIST_ENTRY *pNotifFncChain )
/*++

Routine Description:

   Function that copies a chain of notification functions

Arguments:

   pNotifFncChain - pointer to chain to be copied

Return Value:

   Pointer to copied chain, NULL on failure 

--*/
{
    LIST_ENTRY *pNewChain = new LIST_ENTRY;

    if ( !pNewChain )
    {
        return NULL;
    }
    
    InitializeListHead( pNewChain );

    NOTIF_FNC_CHAIN_ENTRY *pChainEntry, *pNewChainEntry;
    LIST_ENTRY *pListEntry;
    
    for ( pListEntry = pNotifFncChain->Flink;
          pListEntry != pNotifFncChain;
          pListEntry = pListEntry->Flink )
    {
        pChainEntry = CONTAINING_RECORD( pListEntry, NOTIF_FNC_CHAIN_ENTRY,
                                         ListEntry );
        
        
        pNewChainEntry = new NOTIF_FNC_CHAIN_ENTRY;
        
        if ( !pNewChainEntry )
        {
            DeallocateNotifFncChain( pNewChain );
            return NULL;
        }

        pNewChainEntry->pNotifFnc = pChainEntry->pNotifFnc;
        pNewChainEntry->pvParam = pChainEntry->pvParam;

        InsertTailList( pNewChain, &(pNewChainEntry->ListEntry) );
    }

    return ( pNewChain );
}




VOID DeallocateNotifFncChain( LIST_ENTRY *pChain )
/*++

Routine Description:

   Function that cleans up resources associated with a notification function chain

Arguments:

   pChain - chain to be cleaned up 

Return Value:

   None

--*/
{
    if ( !pChain )
    {
        return;
    }
    
    NOTIF_FNC_CHAIN_ENTRY *pChainEntry;
    LIST_ENTRY *pListEntry;
    

    while ( !IsListEmpty( pChain ) ) 
    {
        pChainEntry = CONTAINING_RECORD( pChain->Flink,
                                         NOTIF_FNC_CHAIN_ENTRY,
                                         ListEntry );

        RemoveEntryList( &(pChainEntry->ListEntry) );
        
        delete pChainEntry; 
    }

    delete pChain;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\igateway.cxx ===
/*++

   Copyright    (c)    1995    Microsoft Corporation

   Module  Name :

      igateway.cxx

   Abstract:
   
      This module defines the functions for Internet Services related
       gateway processing ( spawning process and thread for i/o).

   Author:

       Murali R. Krishnan    ( MuraliK )     25-Jan-1995 

   Environment:

      User Mode - Win32
       
   Project:

      Internet Services Common DLL

   Functions Exported:

      BOOL TsProcessGatewayRequest( 
               IN LPVOID pClientContext,
               IN PIGATEWAY_REQUEST  pigRequest,
               IN PFN_GATEWAY_READ_CALLBACK pfnReadCallBack);

   Revision History:

--*/

/*++

   A service may require gateway call to process special 
     requests received from the clients. 
   Such requests are processed by spawning a special process and communicating
     with the special process. The process takes the client supplied data as 
     input and sends its output to  be sent to the client.
   Since the service module is aware of the details of input and output,
     a special thread is created in the service process to deal with the
     input and output. A two-way pipe is established b/w the spawned process
     and the service thread.
   Once the "special gateway process" completes processing the input and 
    terminates, the thread doing I/O proceeds to munging.
   During munging state, the thread calls upon a callback function for
     munging and data transfer. The call-back function is  responsible 
     for altering the data if need be and sending the data to client.
     After this the service thread terminates its work.


--*/


/************************************************************
 *     Include Headers
 ************************************************************/

# include <tcpdllp.hxx>
# include "igateway.hxx"


# define MAX_CB_DATA_FROM_GATEWAY         ( 4096)


/************************************************************
 *    Type Definitions
 ************************************************************/


class IGATEWAY_PROCESSOR {

  public:
    
    inline 
      IGATEWAY_PROCESSOR( 
        IN LPVOID    pClientContext, 
        IN PFN_IGATEWAY_READ_CALLBACK  pfnReadCallBack,
        IN LPBYTE     pbDataToGateway = NULL,
        IN DWORD      cbDataToGateway = 0
        )
      : m_pClientContext         ( pClientContext),
        m_pfnReadCallBack        ( pfnReadCallBack),
        m_pbDataToGateway        ( pbDataToGateway),
        m_cbDataToGateway        ( cbDataToGateway),
        m_hStdIn                 ( INVALID_HANDLE_VALUE),
        m_hStdOut                ( INVALID_HANDLE_VALUE)
          {
              m_fCompleted = 0;
              m_fValid = ( m_pfnReadCallBack   != NULL);
          }
                           
    
    inline virtual ~IGATEWAY_PROCESSOR( VOID);
    
    BOOL IsValid( VOID) const
      { return ( m_fValid); }

    VOID
      SetProcessingCompleted( IN BOOL fValue = TRUE) 
        { m_fCompleted = ( fValue) ? 1 : 0; }

    BOOL
      IsProcessingCompleted( VOID) const
        { return ( m_fCompleted == 1); }

    HANDLE
      QueryStdInHandle( VOID) const
        { return ( m_hStdIn); }
    
    HANDLE
      QueryStdOutHandle( VOID) const
        { return ( m_hStdOut); }

    BOOL
      StartGatewayProcess( 
         IN LPCTSTR  pszCmdLine,
         IN LPCTSTR  pszWorkingDir,
         IN LPVOID   lpvEnvironment,
         IN HANDLE   hUserToken);


    //
    // the worker thread for gateway request processing
    //
    DWORD
      GatewayIOWorker( VOID); 


# if DBG

    VOID Print( VOID) const;

# endif // DBG

  private:

    DWORD        m_fValid : 1;
    DWORD        m_fCompleted : 1;
    

    PVOID        m_pClientContext;       // client context information
    PFN_IGATEWAY_READ_CALLBACK m_pfnReadCallBack;
    
    HANDLE       m_hStdIn;
    HANDLE       m_hStdOut;

    LPBYTE       m_pbDataToGateway;
    DWORD        m_cbDataToGateway;

    BOOL
      SetupChildPipes( IN STARTUPINFO * pStartupInfo);
    

};  // class IGATEWAY_PROCESSOR


typedef  IGATEWAY_PROCESSOR * PIGATEWAY_PROCESSOR;


inline IGATEWAY_PROCESSOR::~IGATEWAY_PROCESSOR( VOID)
{
    DBG_ASSERT( IsProcessingCompleted());
    
    if ( m_hStdIn != INVALID_HANDLE_VALUE &&
         !CloseHandle( m_hStdIn)) {
        
        IF_DEBUG( GATEWAY) {
            
            DBGPRINTF( ( DBG_CONTEXT,
                        "IGATEWAY_PROCESSOR:CloseHandle( StdIn %08x) failed."
                        " Error = %d.\n",
                        m_hStdIn, GetLastError()));
        }
    }
    
    if ( m_hStdOut != INVALID_HANDLE_VALUE &&
         !CloseHandle( m_hStdOut)) {
        
        IF_DEBUG( GATEWAY) {
            
            DBGPRINTF( ( DBG_CONTEXT,
                        "IGATEWAY_PROCESSOR:CloseHandle( StdOut %08x) failed."
                        " Error = %d.\n",
                        m_hStdOut, GetLastError()));
        }
    }

} // IGATEWAY_PROCESSOR::~IGATEWAY_PROCESSOR()




# if DBG

static inline VOID
PrintStartupInfo( IN const STARTUPINFO * pStartInfo)
{

    IF_DEBUG( GATEWAY) {
        DBGPRINTF( ( DBG_CONTEXT,
                    " Startup Info = %08x. cb = %d."
                    " hStdInput = %08x. hStdOutput = %08x."
                    " hStdError = %08x.\n",
                    pStartInfo, pStartInfo->cb,
                    pStartInfo->hStdInput,
                    pStartInfo->hStdOutput,
                    pStartInfo->hStdError));
    }

} // PrintStartupInfo()


static inline VOID
PrintProcessInfo( IN const PROCESS_INFORMATION * pProcInfo)
{
    IF_DEBUG( GATEWAY) {
        DBGPRINTF( ( DBG_CONTEXT, 
                    " ProcessInfo = %08x."
                    " hProcess = %08x. hThread = %08x."
                    " dwProcessId = %08x. dwThreadId = %08x",
                    pProcInfo, pProcInfo->hProcess,
                    pProcInfo->hThread, 
                    pProcInfo->dwProcessId,
                    pProcInfo->dwThreadId));
    }

} // PrintProcessInfo()

# endif // DBG


/************************************************************
 *    Functions 
 ************************************************************/


static 
DWORD
WINAPI
GatewayRequestIOThreadFunction(
   IN LPVOID  pThreadParam)
/*++
   The function is called when the thread for Gateway request I/O is created.
   This function calls the GatewayIOWorker member function to process I/O
     from the gateway process.

  In addition this function also deletes the IGATEWAY_PROCESSOR object, at 
   the end. Memory deallocation is done here, since this thread will die
   at the end of this procedure and no other thread has knowledge about this
   object to perform cleanup.

  Arguments:
     pThreadParam        pointer to thread parameter. This function is called
                          with the parameter as the pointer to 
                          IGATEWAY_PROCESSOR object.

  Returns:
    Win32 error code resulting from gateway I/O processing.
 
--*/
{
    PIGATEWAY_PROCESSOR pigProcessor = (PIGATEWAY_PROCESSOR ) pThreadParam;
    DWORD dwError;
    
    DBG_ASSERT( pigProcessor != NULL);

    dwError =  pigProcessor->GatewayIOWorker();

    IF_DEBUG( GATEWAY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    "Freeing the IGATEWAY_PROCESSOR object ( %08x)\n",
                    pigProcessor));
    }

    delete pigProcessor;

    return ( dwError);
} // GatewayRequestIOThreadFunction()





dllexp BOOL
TsProcessGatewayRequest( 
   IN LPVOID                     pClientContext,
   IN PIGATEWAY_REQUEST          pigRequest,
   IN PFN_IGATEWAY_READ_CALLBACK pfnReadCallBack)
/*++

  Description:
    This function creates a gateway processor object responsible for processing
    gateway requests. It extracts the parameters required from input request
    package ( IGATEWAY_REQUEST structure). It creates a separate process for 
    gateway request and a separate thread for handling I/O for the 
    gateway request. The thread uses buffers supplied for i/o in pigRequest.
    On a completion of read, the thread calls the callback function for 
    processing the data retrieved. If the call back function returns any error
    further procecssing in the thread is halted and the thread dies.
    The process also will eventually die, since the pipes are broken.


  Arguments:
      pClientContext        context information supplied by client
      pigRequest            pointer to IGATEWAY_REQUEST object.
      pfnReadCallBack       pointer to callback function for read completions.

  Returns:
      TRUE on success and FALSE if there is any failure.
      Use GetLastError() to retrieve Win32 error code.
--*/
{
    BOOL fReturn = FALSE;
    PIGATEWAY_PROCESSOR  pigProcessor = NULL;


    DBG_ASSERT( pigRequest != NULL && pfnReadCallBack != NULL);

    IF_DEBUG( GATEWAY) {

        DBGPRINTF( ( DBG_CONTEXT, 
                    "TsProcessGatewayRequest() called. pigRequest = %08x.\n",
                    pigRequest));
    }


    //
    // create a new gateway processor object for handling the gateway request.
    //
    
    pigProcessor = new IGATEWAY_PROCESSOR( pClientContext,
                                           pfnReadCallBack,
                                           pigRequest->pbDataToGateway,
                                           pigRequest->cbDataToGateway);
    
    fReturn = ( pigProcessor != NULL) && pigProcessor->IsValid();

    if ( fReturn) {
        
        IF_DEBUG( GATEWAY) {

            DBGPRINTF( ( DBG_CONTEXT, 
                        " Created a new IGATEWAY_PROCESSOR object.\n"));
            DBG_CODE( pigProcessor->Print());
            
            DBGPRINTF( ( DBG_CONTEXT,
                        " Starting a process for the gateway command\n"));
        }

        fReturn = pigProcessor->StartGatewayProcess( pigRequest->pszCmdLine,
                                                    pigRequest->pszWorkingDir,
                                                    pigRequest->lpvEnvironment,
                                                    pigRequest->hUserToken);
        if ( fReturn) {

            HANDLE hThread;
            DWORD  dwThreadId;

            IF_DEBUG( GATEWAY) {

                DBGPRINTF( ( DBG_CONTEXT,
                            " Creating a new thread to handle gateway I/O\n"));
            }

            //
            // Create a new thread to handle I/O with the process spawned.
            //

            hThread = CreateThread( NULL,         // lpSecurityAttributes,
                                    0,            // stack size in Bytes,
                                    GatewayRequestIOThreadFunction,
                                    (LPVOID )pigProcessor,  // params
                                    0,            // Creation flags
                                    &dwThreadId);
            
            if ( ( fReturn = ( hThread != NULL)))  {
                
                IF_DEBUG( GATEWAY) {
                    
                    DBGPRINTF( ( DBG_CONTEXT,
                                " Created Gateway I/O thread. Hdl=%d. Id=%d\n",
                                hThread, dwThreadId));
                }

                //
                // Close thread handle, since we are not bothered about its
                //  termination and there is no special cleanup required.
                //
                DBG_REQUIRE( CloseHandle( hThread));
                
            } else {

                IF_DEBUG( GATEWAY) {

                    DBGPRINTF( ( DBG_CONTEXT,
                                "Creation of gateway I/O thread failed."
                                " Error = %d\n",
                                GetLastError()));
                }
            } // creation of IO thread
        } // successful start of process for gateway.
    } // creation of pigProcessor



    if ( !fReturn) {

        IF_DEBUG( GATEWAY) {
            
            DBGPRINTF( ( DBG_CONTEXT,
                        " Failure to set up gateway request processiong."
                        " Deleting the IGATEWAY_PROCESSOR object( %08x)."
                        " Error = %d.\n",
                        pigProcessor,
                        GetLastError()));
        }

        if ( pigProcessor != NULL) {

            DBG_ASSERT( !pigProcessor->IsValid());
            delete pigProcessor;
        }
    }

    return ( fReturn);
} // TsProcessGatewayRequest()



/************************************************************
 *   IGATEWAY_PROCESSOR member functions
 ************************************************************/



BOOL
IGATEWAY_PROCESSOR::StartGatewayProcess(
    IN LPCTSTR  pszCmdLine,
    IN LPCTSTR  pszWorkingDir,
    IN LPVOID   lpvEnvironment,               // optional
    IN HANDLE   hUserToken)
/*++
  Description:
    This function sets up pipes for communication with gateway
     and starts a process for gateway application.

  Arguments:
    pszCmdLine     pointer to null-terminated string containing the 
                    command line for the gateway call.
                   The first word ( seq of chars) in pszCmdLine, specifies
                    the gateway application to be used.

    pszWorkingDir  pointer to working directory for the gateway call.
    hUserToken    handle for the user accessing gateway for secure access.
    lpvEnvironment pointer to Environment Block for CreateProcess to pass
                      environment information to the gateway application.
    
  Returns:
  TRUE on success; and FALSE if there is any failure.
    Use GetLastError() for Win32 error code.
--*/
{
    BOOL                fReturn;
    STARTUPINFO         startInfo;
    PROCESS_INFORMATION procInfo;

    DBG_ASSERT( pszCmdLine != NULL && pszWorkingDir != NULL);
    DBG_ASSERT( hUserToken != INVALID_HANDLE_VALUE);

    memset( (PVOID ) &procInfo,  0, sizeof( procInfo));
    memset( (PVOID ) &startInfo, 0, sizeof( startInfo));
    startInfo.cb = sizeof( startInfo);

    
    if ( ( fReturn = SetupChildPipes( &startInfo))) {

        //
        // Successfully setup the child pipes. Proceed to create the process.
        //

        fReturn = CreateProcessAsUser(  hUserToken,
                                       NULL,         // pszImageName
                                       (TCHAR *) pszCmdLine, // pszCommandLine
                                       NULL,         // process security
                                       NULL,         // thread security
                                       TRUE,         // inherit handles,
                                       DETACHED_PROCESS,
                                       lpvEnvironment,
                                       pszWorkingDir,
                                       &startInfo,
                                       &procInfo);


        DBG_CODE( PrintStartupInfo( &startInfo));
        DBG_CODE( PrintProcessInfo( &procInfo));

        //
        //  Had already set up the stderror to be same as stdoutput
        //  in SetupChildPipes(). Verify the same.
        //
        
        if ( fReturn) {

            DBG_REQUIRE( startInfo.hStdError == startInfo.hStdOutput);

            DBG_REQUIRE( CloseHandle( startInfo.hStdOutput));
            DBG_REQUIRE( CloseHandle( startInfo.hStdInput));
            DBG_REQUIRE( CloseHandle( procInfo.hProcess));
            DBG_REQUIRE( CloseHandle( procInfo.hThread));
        }
        
        IF_DEBUG( GATEWAY) {
            
            DBGPRINTF( ( DBG_CONTEXT,
                        "StartGatewayProcess: CreateProcessAsUser( %s)"
                        " returns %d. Error = %d.\n",
                        pszCmdLine, fReturn, GetLastError()));
        }
                                      
    } else {

        IF_DEBUG( GATEWAY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "StartGatewayProcess(). Unable to setup child Pipes."
                        " Error = %d\n",
                        GetLastError()));
        }
    }

    return ( fReturn);
} // IGATEWAY_PROCESSOR::StartGatewayProcess()





BOOL
IGATEWAY_PROCESSOR::SetupChildPipes( IN LPSTARTUPINFO lpStartupInfo)
/*++
  Description:
    Creates pipe and duplicates handles for redirecting stdin and stdout
      to child process.

  Arguments:
     pStartupInfo       pointer to startup information structure used by
                        CreateProcess().
                        This receives the child stdin and stdout.

  Returns:
     TRUE on success and FALSE if there is any error.
--*/
{
    BOOL fReturn;
    SECURITY_ATTRIBUTES  securityAttributes;

    DBG_ASSERT( lpStartupInfo != NULL);

    securityAttributes.nLength              = sizeof( securityAttributes);
    securityAttributes.bInheritHandle       = TRUE;
    securityAttributes.lpSecurityDescriptor = NULL;

    m_hStdIn  = m_hStdOut  = NULL;
    lpStartupInfo->dwFlags = STARTF_USESTDHANDLES;
    
    //
    // create pipes for communication and duplicate handles.
    // mark the duplicates handles as non-inherited to avoid handle leaks
    //
    
    fReturn  = ( CreatePipe( &m_hStdIn,                // parent read pipe
                            &lpStartupInfo->hStdOutput,// child write pipe
                            &securityAttributes,
                            0) &&                      // nSize
                DuplicateHandle( GetCurrentProcess(),  // hSourceProcess
                                 m_hStdIn,             // hSourceHandle
                                 GetCurrentProcess(),  // hTargetProcess
                                 &m_hStdIn,            // lphTargetHandle
                                 0,                    // desired access
                                 FALSE,                // bInheritHandle
                                 DUPLICATE_SAME_ACCESS | 
                                  DUPLICATE_CLOSE_SOURCE) &&
                CreatePipe( &lpStartupInfo->hStdInput, // parent read pipe
                           &m_hStdOut,                 // child write pipe
                           &securityAttributes,
                           0) &&                       // nSize
                DuplicateHandle( GetCurrentProcess(),  // hSourceProcess
                                m_hStdOut,             // hSourceHandle
                                GetCurrentProcess(),   // hTargetProcess
                                &m_hStdOut,            // lphTargetHandle
                                0,                     // desired access
                                FALSE,                 // bInheritHandle
                                DUPLICATE_SAME_ACCESS | 
                                 DUPLICATE_CLOSE_SOURCE)
                );


    //
    // stdout and stderr share the same handle. In the worst case 
    //  clients close stderr before closing stdout, then we need to duplicate
    //  stderr too. For now dont duplicate stdout.
    //
    lpStartupInfo->hStdError = lpStartupInfo->hStdOutput;


    IF_DEBUG( GATEWAY) {
        
        DBGPRINTF( ( DBG_CONTEXT,
                    "Handles. ChildProcess. In= %08x. Out= %08x. Err= %08x.\n",
                    lpStartupInfo->hStdInput,
                    lpStartupInfo->hStdOutput,
                    lpStartupInfo->hStdError));

        DBGPRINTF( ( DBG_CONTEXT,
                    " IO Thread. In= %08x. Out= %08x.\n",
                    m_hStdIn,
                    m_hStdOut));
    }

    if ( !fReturn) {

        IF_DEBUG( GATEWAY) {

            DBGPRINTF( ( DBG_CONTEXT, 
                        " SetupChildPipes failed. Error = %d.\n",
                        GetLastError()));
        }

        //
        //   Free up the handles if any allocated.
        //
        
        if ( m_hStdIn != NULL) {
            
            DBG_REQUIRE( CloseHandle( m_hStdIn));
            m_hStdIn = INVALID_HANDLE_VALUE;
        }

        if ( m_hStdOut != NULL) {
            
            DBG_REQUIRE( CloseHandle( m_hStdOut));
            m_hStdOut = INVALID_HANDLE_VALUE;
        }
    }

    return ( fReturn);
} // IGATEWAY_PROCESSOR::SetupChildPipes()





DWORD
IGATEWAY_PROCESSOR::GatewayIOWorker( VOID)
/*++
  Description:
    This is the core function that performs the I/O with the gateway process.
    I/O is performed using the pipes created by cross-linking 
    the stdout and stdin of gateway process to duplicated handles in the I/O
     thread.

    First, this function writes any data to be sent to the gateway process
       on the read pipe of the process
       ( to m_hStdOut of the IGATEWAY_PROCESSOR object).
    
    Subsequently it loops receiving data from the gateway process and passing
       it onto the client ( meaning service that requested gateway processing).
       It uses the read callback function to make the client perform necessary
         work.
    At the least the client should copy the data returned during in  callback.
    ( Otherwise, there is a danger of the data getting lost in subsequent 
      read from the gateway process.)

  Arguments:
     None

  Returns:
     Win32 error code.
--*/
{
    DWORD  dwError = NO_ERROR;
    BOOL   fDoneWaitingForGateway;
    BYTE   pbDataFromGateway[ MAX_CB_DATA_FROM_GATEWAY];
    DWORD  cbRead = 0;
    
    IF_DEBUG( GATEWAY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " Entering IGATEWAY_PROCESSOR( %08x)::GatewayIOWorker()\n",
                    this));
    }

    //
    // 1. Write any data to the gateway process's stdin
    //
    
    if ( m_cbDataToGateway != 0) {

        DWORD cbWritten;
        BOOL  fWritten;

        DBG_ASSERT( m_pbDataToGateway != NULL);

        IF_DEBUG( GATEWAY) {

            DBGPRINTF( ( DBG_CONTEXT,
                        "GatewayIOWorker( %08x)."
                        " Writing %u bytes to gateway ( child) process's"
                        " stdin ( %08x)\n",
                        this, m_cbDataToGateway, m_hStdOut));
        }

        fWritten = WriteFile( m_hStdOut,
                              m_pbDataToGateway,
                              m_cbDataToGateway, 
                              &cbWritten,
                             NULL);

        IF_DEBUG( GATEWAY) { 

            DBGPRINTF( ( DBG_CONTEXT,
                        "GatewayIOWorker( %08x). WriteFile() returns %d."
                        " written %u bytes of %u bytes. Error = %d.\n",
                        this, fWritten, cbWritten, m_cbDataToGateway, 
                        GetLastError()));
        }

        //
        // The error if any during WriteFile() is ignored.
        //


    }  // data written to gateway process


    //
    //  2.  Loop for data from gateway.
    //

    DBG_ASSERT( m_pfnReadCallBack != NULL);
    for( fDoneWaitingForGateway = FALSE; !fDoneWaitingForGateway; ) {

        BOOL fCallBack;
        
        //
        //  3. Wait for data from gateway process.
        //

        dwError = WaitForSingleObject( m_hStdIn, INFINITE);

        //
        // 4. Depending on return code, either read data or get error code
        //

        switch( dwError) {

          case WAIT_OBJECT_0:
            {
                
                BOOL   fRead;
                
                //
                // 4.a  Got something to read. Read the data into buffer.
                //
                
                fRead = ReadFile( m_hStdIn, 
                                 pbDataFromGateway,
                                 MAX_CB_DATA_FROM_GATEWAY,
                                 &cbRead,
                                 NULL);
                
                dwError = ( fRead) ? NO_ERROR: GetLastError();
                
                IF_DEBUG( GATEWAY) {
                    
                    DBGPRINTF( ( DBG_CONTEXT, 
                                " GatewayIOWorker( %08x). ReadDataFromGateway"
                                " returns %d. Read %d bytes. Error = %d.\n",
                                this, fRead, cbRead, dwError));
                }
                
                if ( dwError == ERROR_BROKEN_PIPE) {

                    fDoneWaitingForGateway = TRUE;
                }
                
                break;
                
            } // case WAIT_OBJECT_0
            
            
          case WAIT_FAILED:
          default: {
              //
              // Unknown error.
              // 

              IF_DEBUG( GATEWAY) {

                  DBGPRINTF( ( DBG_CONTEXT, 
                              " GatewayIOWorker(). WaitForReading Gateway"
                              " data failed. Error = %d\n",
                              dwError));
              }

              fDoneWaitingForGateway = TRUE; 
              break;
          }
            
        } // switch

        //
        // 5. send data or error code back to the callback function.
        //
        
        fCallBack = ( *m_pfnReadCallBack)( m_pClientContext,
                                          dwError,
                                          pbDataFromGateway,
                                          cbRead);

        if ( !fCallBack) {

            dwError = GetLastError();

            IF_DEBUG( GATEWAY) {
                DBGPRINTF( ( DBG_CONTEXT, 
                            " GatewayIOWorker( %08x). ReadCallback failed."
                            " Exiting the gateway processing. Error = %d\n",
                            dwError));
            }

            fDoneWaitingForGateway = TRUE;
        }
        
    } // for


    IF_DEBUG( GATEWAY) {

        DBGPRINTF( ( DBG_CONTEXT,
                    " GatewayIOWorker( %08x). Exiting the IO thread."
                    " Error = %d.\n",
                    this, dwError));
    }
    
    SetProcessingCompleted( TRUE);

    return ( dwError);
} // IGATEWAY_PROCESSOR::GatewayIOWorker()




# if DBG

VOID
IGATEWAY_PROCESSOR::Print( VOID) const
{
    
    DBGPRINTF( ( DBG_CONTEXT, 
                " Printing IGATEWAY_PROCESSOR object ( %08x)\n",
                this));
    
    DBGPRINTF( ( DBG_CONTEXT,
                "IsValid = %d. IsIOCompleted = %d.\n",
                m_fValid, m_fCompleted));

    DBGPRINTF( ( DBG_CONTEXT, 
                " Client Context = %08x\tIO call back function = %08x\n",
                m_pClientContext, m_pfnReadCallBack));
    
    DBGPRINTF( ( DBG_CONTEXT,
                " Child StdIn handle = %08x\t Child StdOut handle = %08x\n",
                m_hStdIn, m_hStdOut));
    
    DBGPRINTF( ( DBG_CONTEXT,
                " Buffer for Data to Gateway = %08x, %u bytes\n",
                m_pbDataToGateway, m_cbDataToGateway));
    
    return;
} // IGATEWAY_PROCESSOR::Print()



dllexp VOID
PrintIGatewayRequest( IN const IGATEWAY_REQUEST * pigRequest)
{
    
    DBGPRINTF( ( DBG_CONTEXT,
                " Printing IGATEWAY_REQUEST object ( %08x)\n",
                pigRequest));
    
    if ( pigRequest != NULL) {

        DBGPRINTF( ( DBG_CONTEXT, 
                    " CommandLine = %s.\n WorkingDir = %s\n",
                    pigRequest->pszCmdLine, pigRequest->pszWorkingDir));
        DBGPRINTF( ( DBG_CONTEXT,
                    " UserHandle = %08x. lpvEnvironment = %08x\n",
                    pigRequest->hUserToken, pigRequest->lpvEnvironment));

        DBGPRINTF( ( DBG_CONTEXT,
                    " pbDataToGateway = %08x. cbDataToGateway = %u.\n",
                    pigRequest->pbDataToGateway, pigRequest->cbDataToGateway));
    }

    return;
} // PrintIGatewayRequest()



# endif // DBG



/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\iisadmin.cxx ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        iisadmin.cxx

   Abstract:

        Contains the admin functions of the IIS_SERVICE class

   Author:

        Johnson Apacible            (JohnsonA)      24-June-1996

--*/

#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"

BOOL
PopulateSiteArray(
    LPINET_INFO_SITE_LIST * ppSites,
    PVOID    pvUnused,
    IN IIS_SERVER_INSTANCE * pInst
    );

PIIS_SERVICE
IIS_SERVICE::FindFromServiceInfoList(
                IN DWORD dwServiceId
                )
/*++
    Description:

        Finds a given Services Info object from the global list.

    Arguments:

        dwServiceId - Service id of service to look for.

    Returns:
        pointer to service object, if found.
        NULL, otherwise.

--*/
{
    PLIST_ENTRY  listEntry;
    PIIS_SERVICE pInetSvc;

    //
    //  Loop through the list of running internet servers and call the callback
    //  for each server that has one of the service id bits set
    //

    AcquireGlobalLock( );
    for ( listEntry  = sm_ServiceInfoListHead.Flink;
          listEntry != &sm_ServiceInfoListHead;
          listEntry  = listEntry->Flink ) {

        pInetSvc = CONTAINING_RECORD(
                                listEntry,
                                IIS_SERVICE,
                                m_ServiceListEntry );

        if ( dwServiceId == pInetSvc->QueryServiceId() &&
             (pInetSvc->QueryCurrentServiceState() == SERVICE_RUNNING ||
             pInetSvc->QueryCurrentServiceState() == SERVICE_PAUSED ) ) {

            //
            // reference and return
            //

            if ( !pInetSvc->CheckAndReference( ) ) {
                IF_DEBUG( INSTANCE ) {
                    DBGPRINTF((DBG_CONTEXT,
                        "Failed to reference service %d\n", dwServiceId));
                }
                pInetSvc = NULL;
            }

            ReleaseGlobalLock( );
            return pInetSvc;
        }
    }

    ReleaseGlobalLock( );

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "FindFromServiceList cannot find service %d\n", dwServiceId));
    }

    return NULL;

} // IIS_SERVICE::FindFromServiceInfoList



BOOL
IIS_SERVICE::SetServiceAdminInfo(
        IN DWORD        dwLevel,
        IN DWORD        dwServiceId,
        IN DWORD        dwInstance,
        IN BOOL         fCommonConfig,
        IN INETA_CONFIG_INFO * pConfigInfo
        )
/*++
    Description:

        Sets the service configuration.

    Arguments:

        dwLevel - Info level
        dwServiceId - ID of service to set
        dwInstance - ID of instance to set
        fCommonConfig - Determines if we should set the common or the service
            configuration
        pConfigInfo - Configuration structure

    Returns:
        TRUE on sucess and FALSE if there is a failure

--*/
{
    BOOL          fRet = TRUE;
    PIIS_SERVICE  pInetSvc;

    DBG_ASSERT( IIS_SERVICE::sm_fInitialized);

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "SetServiceAdmin called for svc %d inst %d\n",
                dwServiceId, dwInstance));
    }

    pInetSvc = FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        SetLastError( ERROR_SERVICE_NOT_ACTIVE);
        fRet = FALSE;
        goto exit;
    }

    //
    // Set the parameters and update
    //

    fRet = pInetSvc->SetInstanceConfiguration(
                                    dwInstance,
                                    dwLevel,
                                    fCommonConfig,
                                    pConfigInfo );

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );
exit:
    return fRet;
}  // IIS_SERVICE::SetServiceAdminInfo





BOOL
IIS_SERVICE::GetServiceAdminInfo(
        IN DWORD        dwLevel,
        IN DWORD        dwServiceId,
        IN DWORD        dwInstance,
        IN BOOL         fCommonConfig,
        OUT PDWORD      nRead,
        OUT LPINETA_CONFIG_INFO * ppConfigInfo
        )
/*++
    Description:

        Gets the service configuration.

    Arguments:

        dwLevel - Info level of this operation
        dwServiceId - ID of service to get
        dwInstance - ID of instance to get
        fCommonConfig - Determines if we should get the common or the service
            configuration
        pBuffer     - on return, will contains a pointer to
            the configuration block

    Returns:
        TRUE on sucess and FALSE if there is a failure

--*/
{
    BOOL fRet = FALSE;
    PIIS_SERVICE  pInetSvc;

    DBG_ASSERT( IIS_SERVICE::sm_fInitialized);

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "GetServiceAdmin called for svc %d inst %x\n",
                dwServiceId, dwInstance));
    }

    pInetSvc = FindFromServiceInfoList( dwServiceId );
    if ( pInetSvc == NULL ) {
        SetLastError( ERROR_SERVICE_NOT_ACTIVE);
        goto exit;
    }

    //
    // Get the params
    //

    fRet = pInetSvc->GetInstanceConfiguration(
                                        dwInstance,
                                        dwLevel,
                                        fCommonConfig,
                                        nRead,
                                        ppConfigInfo
                                        );

    //
    // This was referenced in Find
    //

    pInetSvc->Dereference( );

exit:
    return fRet;
}  // IIS_SERVICE::GetServiceAdminInfo



BOOL
IIS_SERVICE::GetServiceSiteInfo(
                    IN  DWORD                   dwServiceId,
                    OUT LPINET_INFO_SITE_LIST * ppSites
                    )
/*++
    Description:

        Gets the list of service instances.

    Arguments:

        dwServiceId - ID of service to get
        ppSites     - on return, will contain a pointer to
                      the array of sites

    Returns:
        TRUE on sucess and FALSE if there is a failure

--*/
{
    BOOL fRet = FALSE;
    PIIS_SERVICE  pInetSvc;
    DWORD cInstances = 0;
    LPINET_INFO_SITE_LIST pSites;
    
    DBG_ASSERT( IIS_SERVICE::sm_fInitialized);

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "GetServiceSiteInfo called for svc %d\n",
                dwServiceId));
    }

    pInetSvc = FindFromServiceInfoList( dwServiceId );
    
    if ( pInetSvc == NULL ) {
        SetLastError( ERROR_SERVICE_NOT_ACTIVE);
        return FALSE;
    }

    //
    // Get the params
    //

    pInetSvc->AcquireServiceLock(TRUE);

    cInstances = pInetSvc->QueryInstanceCount();

    //allocate enough memory to hold the Site Info Arrary
    
    pSites = (LPINET_INFO_SITE_LIST) 
                midl_user_allocate (sizeof(INET_INFO_SITE_LIST) + sizeof(INET_INFO_SITE_ENTRY)*cInstances);

    if (!pSites) {
    
        pInetSvc->ReleaseServiceLock(TRUE);

    	//This was referenced in Find
        pInetSvc->Dereference( );    
        
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
        
    *ppSites = pSites;
    
    pSites->cEntries = 0;
    
    fRet = pInetSvc->EnumServiceInstances(
                                        (PVOID) ppSites,
                                        NULL,
                                        (PFN_INSTANCE_ENUM) PopulateSiteArray
                                        );
                                        
    if (!fRet) {
    
        for (DWORD i=0; i<pSites->cEntries; i++) {
            midl_user_free(pSites->aSiteEntry[i].pszComment);
        }
        
        midl_user_free(pSites);

        *ppSites = NULL;
    }
    
    pInetSvc->ReleaseServiceLock(TRUE);

    //This was referenced in Find
    
    pInetSvc->Dereference( );
                                        
    return fRet;
}  // IIS_SERVICE::GetServiceSiteInfo



BOOL
PopulateSiteArray(
    LPINET_INFO_SITE_LIST * ppSites,
    PVOID    pvUnused,
    IN IIS_SERVER_INSTANCE * pInst
    )
/*++
    Description:

        Fills the ppSites array with the instance id and site comment.

    Arguments:
        pvUnused    - not used
        pInst       - pointer to service instance
        ppSites     - on return, will contain a pointer to
                      the array of sites

    Returns:
        TRUE on sucess and FALSE if there is a failure

--*/
{
    DWORD cbComment = 0;
    LPINET_INFO_SITE_LIST pSites = *ppSites;



    //Set the instance ID
    pSites->aSiteEntry[pSites->cEntries].dwInstance = pInst->QueryInstanceId();


    //allocate memory for the site name
    cbComment = (strlen(pInst->QuerySiteName())+1) * sizeof(WCHAR);
    
    pSites->aSiteEntry[pSites->cEntries].pszComment = (LPWSTR)midl_user_allocate(cbComment);

    
    if (!(pSites->aSiteEntry[pSites->cEntries].pszComment)) 
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    //  Need unicode conversion here
    //

    if (!MultiByteToWideChar(  CP_ACP,                                      // code page
                        MB_PRECOMPOSED,                                     // character-type options
                        pInst->QuerySiteName(),                             // address of string to map
                        -1,                                                 // number of bytes in string
                        pSites->aSiteEntry[pSites->cEntries].pszComment,    // address of wide-character buffer
                        cbComment / sizeof(WCHAR)                           // size of buffer
                      )) 
    {
        pSites->aSiteEntry[pSites->cEntries].pszComment[0] = L'\0';
    }

    pSites->cEntries++;

    return TRUE;

} //PopulateSiteArray


DWORD
IIS_SERVICE::GetNewInstanceId(
            VOID
            )
/*++
    Description:

        Returns a new instance ID.

    Arguments:

        None.

    Returns:

        A non zero dword containing the instance ID.
        0 if there was an error.

--*/
{
    DWORD  dwId;
    CHAR   regParamKey[MAX_PATH+1];
    MB     mb( (IMDCOM*) QueryMDObject()  );

    AcquireServiceLock( );

    for (; ; ) {

        dwId = ++m_maxInstanceId;

        if ( m_maxInstanceId > INET_INSTANCE_MAX ) {
            m_maxInstanceId = INET_INSTANCE_MIN;
        }

        //
        // Make sure the metapath does not exist
        //

        GetMDInstancePath( dwId, regParamKey );
        if ( !mb.Open( regParamKey ) ) {

            DBG_ASSERT(GetLastError() == ERROR_FILE_NOT_FOUND);
            if ( GetLastError() != ERROR_FILE_NOT_FOUND ) {
                DBGPRINTF((DBG_CONTEXT,
                    "Error %d trying to open %s.\n", GetLastError(), regParamKey ));

                dwId = 0;
            }
            break;
        }

    }

    ReleaseServiceLock( );

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT, "GetNewInstanceId returns %d\n", dwId));
    }

    return dwId;

} // IIS_SERVICE::GetNewInstanceId




BOOL
IIS_SERVICE::SetInstanceConfiguration(
    IN DWORD            dwInstance,
    IN DWORD            dwLevel,
    IN BOOL             fCommonConfig,
    IN LPINETA_CONFIG_INFO pConfig
    )
/*++
    Description:

        Set the configuration for the instance.

    Arguments:

        dwInstance - Instance number to find - IGNORED FOR SET!!
        dwLevel - level of information to set
        pCommonConfig - Whether info is common or service specific
        pConfig - pointer to the configuration block

    Returns:

        A dword containing the instance ID.
--*/
{
    BOOL fRet = FALSE;
    PLIST_ENTRY  listEntry;
    PIIS_SERVER_INSTANCE pInstance;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "SetInstanceConfiguration called for instance %d\n", dwInstance));
    }

    //
    // Try to find this instance
    //

    AcquireServiceLock( TRUE );

    //
    //  Find the instance in the instance list
    //

    if ( dwInstance == INET_INSTANCE_ROOT ) {
        DBG_ASSERT( !"Explicit default instance no longer supported inherited from metabase)\n" );
        pInstance = NULL;
    } else {
        pInstance = FindIISInstance( QueryDownLevelInstance() );
    }

    if ( pInstance != NULL ) {
        goto found;
    }

    SetLastError(ERROR_FILE_NOT_FOUND);
    DBG_ASSERT(!fRet);
    goto exit;

found:

    if ( fCommonConfig ) {

        fRet = pInstance->SetCommonConfig( pConfig, TRUE);

    } else {

        fRet = pInstance->SetServiceConfig( (CHAR *) pConfig);
    }

exit:
    ReleaseServiceLock( TRUE );
    return fRet;

} // IIS_SERVICE::SetInstanceConfiguration


BOOL
IIS_SERVICE::GetInstanceConfiguration(
        IN DWORD dwInstance,
        IN DWORD dwLevel,
        IN BOOL fCommonConfig,
        OUT PDWORD nRead,
        OUT LPINETA_CONFIG_INFO * pBuffer
        )
/*++
    Description:

        Get the configuration for the instance.

    Arguments:

        dwInstance - Instance number to find - IGNORED!!
        dwLevel - level of information to get
        pCommonConfig - Whether info is common or service specific
        nRead - pointer to a DWORD where the number of entries to be
            returned is set.
        pBuffer - pointer to the configuration block

    Returns:

        A dword containing the instance ID.
--*/
{

    PLIST_ENTRY  listEntry;
    PIIS_SERVER_INSTANCE pInstance;
    DWORD nInstances = 1;
    DWORD nSize;
    PCHAR pConfig;

    //
    // Set and Get only work against the default instance
    //

    dwInstance = QueryDownLevelInstance();

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "GetInstanceConfiguration [%x][%d] called for instance %x L%d\n",
            this, fCommonConfig, dwInstance, dwLevel));
    }

    //
    // We support only 1
    //

    *nRead = 0;
    *pBuffer = NULL;

    if ( fCommonConfig ) {

        DBG_ASSERT( dwLevel == 1 );

        nSize = sizeof( INETA_CONFIG_INFO );

    } else {

        DWORD err;

        nSize = GetServiceConfigInfoSize(dwLevel);
        if ( nSize == 0 ) {
            SetLastError(ERROR_INVALID_LEVEL);
            return(FALSE);
        }
    }

    //
    // Try to find this instance
    //

    AcquireServiceLock( );

    if ( dwInstance == INET_INSTANCE_ALL ) {
        nInstances = QueryInstanceCount( );
        if ( nInstances == 0 ) {
            goto exit;
        }
        IF_DEBUG(INSTANCE) {
            DBGPRINTF((DBG_CONTEXT,"%d instances found\n",nInstances));
        }
    }

    *pBuffer = (LPINETA_CONFIG_INFO) MIDL_user_allocate(nInstances * nSize);
    if ( *pBuffer == NULL ) {
        goto error_exit;
    }

    ZeroMemory( *pBuffer, nInstances * nSize );

    //
    //  Loop through the list of running internet servers and call the callback
    //  for each server that has one of the service id bits set
    //

    pConfig = (CHAR *) *pBuffer;

    if ( dwInstance != INET_INSTANCE_ROOT ) {

        for ( listEntry  = m_InstanceListHead.Flink;
              listEntry != &m_InstanceListHead;
              listEntry  = listEntry->Flink ) {

            pInstance = CONTAINING_RECORD(
                                    listEntry,
                                    IIS_SERVER_INSTANCE,
                                    m_InstanceListEntry );

            if ( (dwInstance == pInstance->QueryInstanceId()) ||
                 (dwInstance == INET_INSTANCE_ALL)   ||
                 (dwInstance == INET_INSTANCE_FIRST) ) {

                if ( fCommonConfig ) {
                    if ( !pInstance->GetCommonConfig(pConfig,dwLevel) ) {
                        goto error_exit;
                    }
                } else {
                    if ( !pInstance->GetServiceConfig(pConfig,dwLevel) ) {
                        goto error_exit;
                    }
                }

                //
                // if not get all, return.
                //

                (*nRead)++;
                pConfig += nSize;

                if ( dwInstance != INET_INSTANCE_ALL ) {
                    break;
                }
            }
        }
    } else {

        DBG_ASSERT( !"Default instance no longer supported!\n" );
    }

exit:

    if ( *nRead == 0 ) {
        if ( dwInstance != INET_INSTANCE_ALL ) {
            SetLastError(ERROR_FILE_NOT_FOUND);
            goto error_exit;
        }
    }

    ReleaseServiceLock( );

    DBG_ASSERT(nInstances == *nRead);
    return TRUE;

error_exit:

    ReleaseServiceLock( );

    IF_DEBUG(ERROR) {
        DBGPRINTF((DBG_CONTEXT,"Error %x in GetInstanceConfiguration\n",
            GetLastError()));
    }

    if ( *pBuffer != NULL ) {
        MIDL_user_free(*pBuffer);
        *pBuffer = NULL;
    }
    *nRead = 0;
    return(FALSE);

} // IIS_SERVICE::GetInstanceConfiguration




PIIS_SERVER_INSTANCE
IIS_SERVICE::FindIISInstance(
    IN DWORD            dwInstance
    )
/*++
    Description:

        Find the instance
        *** Service lock assumed held ***

    Arguments:

        dwInstance - Instance number to find

    Returns:

        Pointer to the instance.
        NULL if not found.
--*/
{
    BOOL fRet = TRUE;
    PLIST_ENTRY  listEntry;
    PIIS_SERVER_INSTANCE pInstance;

    //
    //  Find the instance in the instance list
    //

    for ( listEntry  = m_InstanceListHead.Flink;
          listEntry != &m_InstanceListHead;
          listEntry  = listEntry->Flink ) {

        pInstance = CONTAINING_RECORD(
                                listEntry,
                                IIS_SERVER_INSTANCE,
                                m_InstanceListEntry );

        if ( (dwInstance == pInstance->QueryInstanceId()) ||
             (dwInstance == INET_INSTANCE_FIRST) ) {

            return pInstance;
        }
    }

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "FindIISInstance: Cannot find instance %d\n", dwInstance));
    }

    SetLastError(ERROR_FILE_NOT_FOUND);
    return(NULL);

} // IIS_SERVICE::FindIISInstance



BOOL
IIS_SERVICE::DeleteInstanceInfo(
                IN DWORD    dwInstance
                )
{
    PIIS_SERVER_INSTANCE pInstance;
    DWORD err = NO_ERROR;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "DeleteInstanceInfo called for %d\n", dwInstance));
    }

    //
    // Find the instance and close it
    //

    AcquireServiceLock( TRUE );

    //
    //  Find the instance in the instance list
    //

    pInstance = FindIISInstance( dwInstance );

    if( pInstance == NULL ) {

        err = ERROR_FILE_NOT_FOUND;

    } else {

        //
        // Remove it from the list
        //

        RemoveEntryList( &pInstance->m_InstanceListEntry );
        m_nInstance--;

        //
        // Shut it down
        //

        pInstance->CloseInstance();

        //
        // Dereference it
        //

        pInstance->Dereference( );

    }

    ReleaseServiceLock( TRUE );

    if( err == NO_ERROR ) {

        return TRUE;

    }

    SetLastError( err );
    return FALSE;

} // IIS_SERVICE::DeleteInstanceInfo


BOOL
IIS_SERVICE::EnumerateInstanceUsers(
                    IN DWORD dwInstance,
                    OUT PDWORD nRead,
                    OUT PCHAR* pBuffer
                    )
{

    PIIS_SERVER_INSTANCE pInstance;
    BOOL    fRet;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "EnumerateInstanceUsers called for service %x (Instance %d)\n",
                this, dwInstance ));
    }

    //
    // Find the instance
    //

    AcquireServiceLock( );

    //
    //  Find the instance in the instance list
    //

    pInstance = FindIISInstance( dwInstance );
    if ( pInstance != NULL ) {
        goto found;
    }

    ReleaseServiceLock( );
    SetLastError(ERROR_FILE_NOT_FOUND);
    return(FALSE);

found:

    fRet = pInstance->EnumerateUsers( pBuffer, nRead );
    ReleaseServiceLock( );

    return(fRet);

} // IIS_SERVICE::EnumerateInstanceUsers




BOOL
IIS_SERVICE::DisconnectInstanceUser(
                    IN DWORD dwInstance,
                    IN DWORD dwIdUser
                    )
{

    PIIS_SERVER_INSTANCE pInstance;
    BOOL    fRet;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "DisconnectInstanceUsers called for service %x (Instance %d)\n",
                this, dwInstance ));
    }

    //
    // Find the instance
    //

    AcquireServiceLock( );

    //
    //  Find the instance in the instance list
    //

    pInstance = FindIISInstance( dwInstance );
    if ( pInstance != NULL ) {
        goto found;
    }

    ReleaseServiceLock( );
    SetLastError(ERROR_FILE_NOT_FOUND);
    return(FALSE);

found:

    fRet = pInstance->DisconnectUser( dwIdUser );
    ReleaseServiceLock( );

    return(fRet);

} // IIS_SERVICE::DisconnectInstanceUsers




BOOL
IIS_SERVICE::GetInstanceStatistics(
                IN DWORD    dwInstance,
                IN DWORD    dwLevel,
                OUT PCHAR*  pBuffer
                )
{

    PIIS_SERVER_INSTANCE pInstance;
    BOOL                 fRet;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "GetInstanceStats called for service %x (Instance %d)\n",
                this, dwInstance ));
    }

    //
    // Find the instance and close it
    //

    AcquireServiceLock( TRUE);

    if (dwInstance == 0 ) 
    {
        fRet = GetGlobalStatistics(dwLevel,pBuffer);
    }
    else if ( dwInstance == INET_INSTANCE_GLOBAL)
    {
        //
        // We need to aggregate statistics across all instances
        //
        
        PLIST_ENTRY listEntry;
        PCHAR       pStats;
        BOOL        fFirst = TRUE;

        fRet        = FALSE;
        *pBuffer    = NULL;
        
        //
        // Loop through all the instances and add their counters
        //
            
        for ( listEntry  = m_InstanceListHead.Flink;
              listEntry != &m_InstanceListHead;
              listEntry  = listEntry->Flink) 
        {
        
            pInstance = CONTAINING_RECORD(
                                    listEntry,
                                    IIS_SERVER_INSTANCE,
                                    m_InstanceListEntry );

            pInstance->LockThisForRead();
            fRet = pInstance->GetStatistics(dwLevel, &pStats);
            pInstance->UnlockThis();
            
            if (fRet)
            {
                if (fFirst)
                {
                    //
                    // This is the first successful retrieval.
                    //

                    *pBuffer = pStats;
                    fFirst = FALSE;
                }
                else
                {
                    AggregateStatistics(*pBuffer, pStats);
                    MIDL_user_free(pStats);
                }
            }
        } 
    }
    else 
    {

        //
        //  Find the instance in the instance list
        //

        pInstance = FindIISInstance( dwInstance );
        if ( pInstance != NULL ) 
        {
            fRet = pInstance->GetStatistics(dwLevel,pBuffer);
        }
        else
        {
            SetLastError(ERROR_FILE_NOT_FOUND);
            fRet = FALSE;
        }
    }

    ReleaseServiceLock( TRUE);

    return(fRet);


} // IIS_SERVICE::GetInstanceStatistics


BOOL 
IIS_SERVICE::GetGlobalStatistics(
    IN DWORD dwLevel, 
    OUT PCHAR *pBuffer
    )
{
    return FALSE;
}   // IIS_SERVICE::GetGlobalStatistics


BOOL
IIS_SERVICE::ClearInstanceStatistics(
                IN DWORD    dwInstance
                )
{

    PIIS_SERVER_INSTANCE pInstance;
    BOOL    fRet;

    IF_DEBUG( INSTANCE ) {
        DBGPRINTF((DBG_CONTEXT,
            "ClearInstanceStats called for service %x (instance %d)\n",
                this, dwInstance ));
    }

    //
    // Find the instance and close it
    //

    AcquireServiceLock( );

    //
    //  Find the instance in the instance list
    //

    pInstance = FindIISInstance( dwInstance );
    if ( pInstance != NULL ) {
        goto found;
    }

    ReleaseServiceLock( );
    SetLastError(ERROR_FILE_NOT_FOUND);
    return(FALSE);

found:

    fRet = pInstance->ClearStatistics( );
    ReleaseServiceLock( );

    return(fRet);

} // IIS_SERVICE::ClearInstanceStatistics



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\iisassoc.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iisassoc.cxx

Abstract:

    This module implements the IIS_ASSOCIATION class.

Author:

    Keith Moore (keithmo)        16-Jan-1997

Revision History:

--*/


#include "tcpdllp.hxx"
#pragma hdrstop
#include <iisassoc.hxx>


//
// Private constants.
//

#define HASH_FROM_CONTEXT(ctx)                                      \
            (                                                       \
                (m_HashIpAddress ? ctx->IpAddressHash : 0) +        \
                (m_HashHostName ? ctx->HostNameHash : 0)            \
            )


//
// Private types.
//

typedef struct _HASH_ENTRY {

    LIST_ENTRY HashBucketListEntry;
    DWORD IpAddress;
    DWORD Hash;
    LPVOID Context;
    CHAR HostName[1];   // Expands as needed. MUST BE LAST FIELD IN STRUCTURE!

} HASH_ENTRY, *PHASH_ENTRY;


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_ASSOCIATION::IIS_ASSOCIATION(
    IN BOOL HashIpAddress,
    IN BOOL HashHostName,
    IN INT NumHashBuckets
    ) :
    m_HashIpAddress( HashIpAddress ),
    m_HashHostName( HashHostName ),
    m_NumHashBuckets( NumHashBuckets ),
    m_HashBuckets( NULL )
/*++

Routine Description:

    IIS_ASSOCIATION constructor.

Arguments:

    HashIpAddress - TRUE if this association should hash the IP address.

    HashHostName - TRUE if this association should hash the host name.

    NumHashBuckets - The number of hash buckets to create for this
        association.

Return Value:

    None.

--*/
{

    //
    // Sanity check.
    //

    DBG_ASSERT( HashIpAddress || HashHostName );
    DBG_ASSERT( NumHashBuckets > 0 );

    //
    // Initialize the hash buckets.
    //

    m_HashBuckets = new LIST_ENTRY[m_NumHashBuckets];

    if( m_HashBuckets == NULL ) {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );

    } else {

        for( INT i = 0 ; i < m_NumHashBuckets ; i++ ) {

            InitializeListHead( &m_HashBuckets[i] );

        }

    }

}   // IIS_ASSOCIATION::IIS_ASSOCIATION


IIS_ASSOCIATION::~IIS_ASSOCIATION()
/*++

Routine Description:

    IIS_ASSOCIATION destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    INT i;
    PLIST_ENTRY hashBucket;
    PLIST_ENTRY listEntry;
    PHASH_ENTRY hashEntry;

    //
    // Purge the hash bucket entries.
    //

    for( i = 0, hashBucket = m_HashBuckets ;
         i < m_NumHashBuckets ;
         i++, hashBucket++ ) {

        while( !IsListEmpty( hashBucket ) ) {

            listEntry = RemoveHeadList( hashBucket );

            hashEntry = CONTAINING_RECORD(
                            listEntry,
                            HASH_ENTRY,
                            HashBucketListEntry
                            );

            delete hashEntry;

        }

    }

    //
    // Delete the hash bucket array.
    //

    delete m_HashBuckets;

}   // IIS_ASSOCIATION::~IIS_ASSOCIATION


DWORD
IIS_ASSOCIATION::AddDescriptor(
    IN DWORD IpAddress,
    IN const CHAR * HostName,
    IN LPVOID Context,
    IN OUT PHASH_CONTEXT HashContext OPTIONAL
    )
/*++

Routine Description:

    Adds a new descriptor to the association.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    Context - A context to associate with the descriptor.

    HashContext - An optional hash context from a previous call to one
        of the association functions. This is used to avoid redundant
        hash calculations. If NULL, then a temporary hash context is
        created and used.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    HASH_CONTEXT localContext;
    PHASH_ENTRY hashEntry;

    //
    // If a hash context was specified, use it. Otherwise, initialize a
    // local context and use it instead.
    //

    if( HashContext == NULL ) {

        HashContext = &localContext;
        InitializeHashContext( &localContext );

    }

    //
    // Get the hash.
    //

    CalculateHash(
        IpAddress,
        HostName,
        HashContext
        );

    //
    // Try to find the descriptor in the hash table. If it's there, then
    // fail the request. Otherwise, create a new hash entry and stick it
    // in the table.
    //

    hashEntry = FindDescriptor(
                    IpAddress,
                    HostName,
                    HashContext
                    );

    if( hashEntry == NULL ) {

        hashEntry = CreateHashEntry(
                        IpAddress,
                        HostName,
                        HashContext
                        );

        if( hashEntry != NULL ) {

            InsertHeadList(
                &m_HashBuckets[hashEntry->Hash % m_NumHashBuckets],
                &hashEntry->HashBucketListEntry
                );

            hashEntry->Context = Context;
            return NO_ERROR;

        }

        return ERROR_NOT_ENOUGH_MEMORY;

    }

    return ERROR_DUP_NAME;

}   // IIS_ASSOCIATION::AddDescriptor


DWORD
IIS_ASSOCIATION::LookupDescriptor(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    OUT LPVOID *Context,
    IN OUT PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Searches the association for the specified descriptor.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    Context - Recieves the context associated with the descriptor if
        successful.

    HashContext - An optional hash context from a previous call to one
        of the association functions. This is used to avoid redundant
        hash calculations. If NULL, then a temporary hash context is
        created and used.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    HASH_CONTEXT localContext;
    PHASH_ENTRY hashEntry;

    //
    // If a hash context was specified, use it. Otherwise, initialize a
    // local context and use it instead.
    //

    if( HashContext == NULL ) {

        HashContext = &localContext;
        InitializeHashContext( &localContext );

    }

    //
    // Get the hash.
    //

    CalculateHash(
        IpAddress,
        HostName,
        HashContext
        );

    //
    // Try to find the descriptor in the hash table. If it's there, then
    // return the context to the caller. Otherwise, fail the request.
    //

    hashEntry = FindDescriptor(
                    IpAddress,
                    HostName,
                    HashContext
                    );

    if( hashEntry != NULL ) {

        *Context = hashEntry->Context;
        return NO_ERROR;

    }

    return ERROR_INVALID_PARAMETER;

}   // IIS_ASSOCIATION::LookupDescriptor


DWORD
IIS_ASSOCIATION::RemoveDescriptor(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    OUT LPVOID *Context,
    IN OUT PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Removes a descriptor from the association.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    Context - Receives the context associated with the descriptor if
        successful.

    HashContext - An optional hash context from a previous call to one
        of the association functions. This is used to avoid redundant
        hash calculations. If NULL, then a temporary hash context is
        created and used.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    HASH_CONTEXT localContext;
    PHASH_ENTRY hashEntry;

    //
    // If a hash context was specified, use it. Otherwise, initialize a
    // local context and use it instead.
    //

    if( HashContext == NULL ) {

        HashContext = &localContext;
        InitializeHashContext( &localContext );

    }

    //
    // Get the hash.
    //

    CalculateHash(
        IpAddress,
        HostName,
        HashContext
        );

    //
    // Try to find the descriptor in the hash table. If it's there, then
    // remove it from the hash table and return the context to the caller.
    // Otherwise, fail the request.
    //

    hashEntry = FindDescriptor(
                    IpAddress,
                    HostName,
                    HashContext
                    );

    if( hashEntry != NULL ) {

        *Context = hashEntry->Context;
        RemoveEntryList(
            &hashEntry->HashBucketListEntry
            );
        delete hashEntry;

        return NO_ERROR;

    }

    return ERROR_INVALID_PARAMETER;

}   // IIS_ASSOCIATION::RemoveDescriptor


VOID
IIS_ASSOCIATION::EnumDescriptors(
    IN LPFN_ASSOCIATION_CALLBACK Callback,
    IN LPVOID CallbackContext
    )
/*++

Routine Description:

    Enumerates the descriptors in the association.

Arguments:

    Callback - A function to call for every descriptor.

    CallbackContext - A context to pass back to the callback.

Return Value:

    None.

--*/
{

    INT i;
    PLIST_ENTRY listEntry;
    PLIST_ENTRY hashBuckets;
    PHASH_ENTRY hashEntry;

    DBG_ASSERT( Callback != NULL );

    for( i = 0, hashBuckets = m_HashBuckets ;
         i < m_NumHashBuckets ;
         i++, hashBuckets++ ) {

        listEntry = hashBuckets->Flink;

        while( listEntry != hashBuckets ) {

            hashEntry = CONTAINING_RECORD(
                            listEntry,
                            HASH_ENTRY,
                            HashBucketListEntry
                            );

            listEntry = listEntry->Flink;

            if( !(Callback)(
                    CallbackContext,
                    hashEntry->Context,
                    hashEntry->IpAddress,
                    hashEntry->HostName
                    ) ) {

                break;

            }

        }

    }

}   // IIS_ASSOCIATION::EnumDescriptors

//
// Private functions.
//


VOID
IIS_ASSOCIATION::CalculateHash(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    OUT PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Calculates the hash of the IP address (if HashIpAddress == TRUE) and/or
    the host name (if HashHostName == TRUE).

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    HashContext - Will receive the updated hash.

Return Value:

    None.

--*/
{

    //
    // Calculate the IP address hash if needed and not already calculated.
    //

    if( HashContext->IpAddressHash == 0 && m_HashIpAddress ) {

        HashContext->IpAddressHash = IpAddress;

        if( HashContext->IpAddressHash == 0 ) {
            HashContext->IpAddressHash++;
        }

    }

    //
    // Calculate the host name hash if needed and not already calculated.
    //

    if( HashContext->HostNameHash == 0 && m_HashHostName ) {

        DWORD hash = 0;

        DBG_ASSERT( HostName != NULL );

        while( *HostName ) {
            CHAR ch;

            ch = *HostName++;

            //
            // This is basically toupper() for 7-bit ASCII. This is
            // OK for DNS names.
            //

            if( ch >= 'a' && ch <= 'z' ) {
                ch -= ( 'a' - 'A' );
            }

            hash = ( hash * 5 ) + (DWORD)ch;
        }

        if( hash == 0 ) {
            hash++;
        }

        HashContext->HostNameHash = hash;

    }

}   // IIS_ASSOCIATION::CalculateHash


PHASH_ENTRY
IIS_ASSOCIATION::FindDescriptor(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    IN PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Finds a descriptor in the association.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    HashContext - The current hash value.

Return Value:

    PHASH_ENTRY - Pointer to the hash entry if successful, NULL otherwise.

--*/
{

    DWORD hash;
    PLIST_ENTRY bucket;
    PLIST_ENTRY scan;
    PHASH_ENTRY entry;

    //
    // Get the correct bucket based on the hash value.
    //

    hash = HASH_FROM_CONTEXT(HashContext);
    bucket = &m_HashBuckets[hash % m_NumHashBuckets];

    //
    // Scan the bucket, looking for a match.
    //

    for( scan = bucket->Flink ; scan != bucket ; scan = scan->Flink ) {

        entry = CONTAINING_RECORD(
                    scan,
                    HASH_ENTRY,
                    HashBucketListEntry
                    );

        if( entry->Hash != hash ) {

            continue;

        }

        if( m_HashIpAddress &&
            entry->IpAddress != IpAddress ) {

            continue;

        }

        if( m_HashHostName ) {

            DBG_ASSERT( HostName != NULL );

            if( _stricmp(
                    entry->HostName,
                    HostName
                    ) ) {

                continue;

            }

        }

        //
        // Success!
        //

        return entry;

    }

    //
    // If we made it this far, then the item is not in the hash table.
    //

    return NULL;

}   // IIS_ASSOCIATION::FindDescriptor


PHASH_ENTRY
IIS_ASSOCIATION::CreateHashEntry(
    IN DWORD IpAddress,
    IN const CHAR * HostName OPTIONAL,
    IN PHASH_CONTEXT HashContext
    )
/*++

Routine Description:

    Creats a new hash entry.

Arguments:

    IpAddress - The descriptor IP address. Ignored if the association
        was not created with HashIpAddress == TRUE.

    HostName - The descriptor host name. Ignored if the association was
        not created with HashHostName == TRUE.

    HashContext - The current hash value.

Return Value:

    PHASH_ENTRY - Pointer to the newly created hash entry if successful,
        NULL otherwise.

--*/
{

    PHASH_ENTRY entry;

    entry = (PHASH_ENTRY)( new BYTE[sizeof(*entry) + strlen(HostName)] );

    if( entry != NULL ) {

        entry->IpAddress = IpAddress;
        entry->Hash = HASH_FROM_CONTEXT(HashContext);
        strcpy( entry->HostName, HostName );

    }

    return entry;

}   // IIS_ASSOCIATION::CreateHashEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\iiscert.cxx ===
/*++





Copyright (c) 1997  Microsoft Corporation

Module Name:

    iiscert.cxx

Abstract:

    Code to handle retrieving/storing/using CAPI2 certificate contexts for IIS server 
    certificates.

Author:

    Alex Mallet (amallet)    02-Dec-1997

--*/

#include "tcpdllp.hxx"
#pragma hdrstop

#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>


//
// Local includes
//
#include "iiscert.hxx"
#include "capiutil.hxx"


#define SHA1_HASH_SIZE 20 //size of SHA1 hash 

HCRYPTPROV IIS_SERVER_CERT::m_hFortezzaCSP = NULL;
HCRYPTDEFAULTCONTEXT IIS_SERVER_CERT::m_hFortezzaCtxt = NULL;

IIS_SERVER_CERT::IIS_SERVER_CERT( IN IMDCOM *pMDObject,
                                  IN LPTSTR pszMBPath ) :
m_strMBPath( pszMBPath ),
m_pStoreInfo( NULL ), 
m_hCryptProv( NULL ),
m_pCertContext( NULL ),
m_fIsFortezzaCert( FALSE )
/*++

Routine Description:

    Constructor for server cert that reads all necessary info out of metabase

Arguments:

    pMDObject - pointer to metabase object 
    pszMBPath - full path in metabase to information for this virtual server instance

Returns:

   Nothing

--*/
{
    DBG_ASSERT( pMDObject );
    DBG_ASSERT( pszMBPath );

    DWORD dwSize = 0;
    METADATA_HANDLE hInstanceInfoHandle = NULL;
    int iLengthNeeded = 0;
    PBYTE pbCertHash = NULL;
    DWORD dwHashSize = 0;
    DWORD dwPathLength = 0;
    MB mb( pMDObject );
    LPTSTR pszCSPString = NULL;
    LPTSTR pszCSPStringCopy = NULL;
    BOOL fProgPINEntry = FALSE;

    m_dwStatus = CERT_ERR_NONE;

    if ( !m_strMBPath.IsValid() )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        goto EndRetrieveCertContext;
    }

    if ( mb.Open( m_strMBPath.QueryStr(),
                  METADATA_PERMISSION_READ ))
    {
        DWORD dwReqDataLen = 0;
        METADATA_RECORD mdr;
        DWORD dwFortezza = 0;

        //
        // Retrieve cert hash
        //
        MD_SET_DATA_RECORD(&mdr, MD_SSL_CERT_HASH, METADATA_NO_ATTRIBUTES,
                           IIS_MD_UT_SERVER, BINARY_METADATA, NULL,
                           0);


        if ( !RetrieveBlobFromMetabase(&mb,
                                       NULL,
                                       &mdr,
                                       SHA1_HASH_SIZE ) ) 

        {
            m_dwStatus = CERT_ERR_MB;
            goto EndRetrieveCertContext;
        }
        else
        {
            DBG_ASSERT( mdr.dwMDDataLen == SHA1_HASH_SIZE );

            pbCertHash = mdr.pbMDData;
            dwHashSize = mdr.dwMDDataLen;
        }

        //
        // Retrieve flag indicating whether it's a Fortezza cert or not
        //
        if ( !mb.GetDword( NULL,
                           MD_SSL_CERT_IS_FORTEZZA,
                           IIS_MD_UT_SERVER,
                           &(dwFortezza),
                           METADATA_NO_ATTRIBUTES ) )
        {
            if ( GetLastError() != MD_ERROR_DATA_NOT_FOUND )
            {
                m_dwStatus = CERT_ERR_MB;
                goto EndRetrieveCertContext;
            }
            else
            {
                m_fIsFortezzaCert = FALSE;
            }
        }
        else
        {
            m_fIsFortezzaCert = (BOOL) dwFortezza;
        }

        //
        // If it's a Fortezza cert and we're supposed to do programmatic PIN entry,
        // we need to get a handle to the CSP ourselves by providing the 
        // PIN in the call to CryptAcquireContext(), to avoid the "Enter PIN" dialog 
        //
        if ( m_fIsFortezzaCert && ( fProgPINEntry = UseProgrammaticPINEntry( &mb ) ) )
        {
            LPTSTR pszPIN = NULL;
            LPTSTR pszSerialNumber = NULL;
            LPTSTR pszPersonality = NULL;
            DWORD cbPIN = 0;
            DWORD cbSerialNumber = 0;
            DWORD cbPersonality = 0;
            DWORD cbLen = 0;
            DWORD iPos = 0;
            
            if ( !RetrievePINInfo( &mb,
                                   &pszPIN,
                                   &pszSerialNumber,
                                   &pszPersonality ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Couldn't retrieve PIN info for Fortezza card\n"));
                m_dwStatus = CERT_ERR_MB;
                goto EndRetrieveCertContext;
            }
            DBG_ASSERT( pszPIN && pszSerialNumber && pszPersonality );
            
            //
            // Construct string to be passed to CryptAcquireContext - it's
            // <card serial #>\n<personality>\n<PIN>. 
            //
            cbPIN = strlen( pszPIN );
            cbSerialNumber = strlen( pszSerialNumber );
            cbPersonality = strlen( pszPersonality );
            cbLen = cbPIN + cbSerialNumber + cbPersonality + 10; //add a few bytes for CR
                                                                 //and null terminating char
            
            pszCSPString = new CHAR[cbLen];
            pszCSPStringCopy = new CHAR[cbLen];

            if ( !pszCSPString || !pszCSPStringCopy )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Couldn't allocate memory for CSP string\n"));
                
                //
                // Clean out the PIN info - the less time we leave it lying around,
                // the better
                //
                memset( pszPIN, 0, cbPIN );
                delete [] pszPIN;
                
                memset( pszSerialNumber, 0, cbSerialNumber );
                delete [] pszSerialNumber;
                
                memset( pszPersonality, 0, cbPersonality );
                delete [] pszPersonality;
                
                m_dwStatus = CERT_ERR_INTERNAL;
                
                goto EndRetrieveCertContext;
            }
            
            //
            // Build the magic string that will unlock the Fortezza secret ...
            //
            strcpy( pszCSPString, pszSerialNumber );
            strcat( pszCSPString, "\n" );
            strcat( pszCSPString, pszPersonality );
            strcat( pszCSPString, "\n" );
            strcat( pszCSPString, pszPIN );
            
            //
            // Make a copy we can reuse later
            //
            strcpy( pszCSPStringCopy, pszCSPString );

            //
            // Clean out the PIN & serial number - the less time we leave it lying around,
            // the better
            //
            memset( pszPIN, 0, cbPIN );
            delete [] pszPIN;
            
            memset( pszSerialNumber, 0, cbSerialNumber );
            delete [] pszSerialNumber;
            
            memset( pszPersonality, 0, cbPersonality );
            delete [] pszPersonality;
            
            //
            // Get a handle to the CSP, passing in the serial # etc and the 
            // CRYPT_SILENT flag to avoid any UI
            //
            if ( !CryptAcquireContext( &m_hCryptProv,
                                       pszCSPString,
                                       NULL,
                                       PROV_FORTEZZA,
                                       CRYPT_SILENT | CRYPT_MACHINE_KEYSET ) )
            {
                DBGPRINTF((DBG_CONTEXT,
                           "Couldn't get handle to Fortezza CSP : 0x%d\n",
                           GetLastError()));

                m_dwStatus = CERT_ERR_CAPI;
                goto EndRetrieveCertContext;
            }

            if ( !IIS_SERVER_CERT::m_hFortezzaCSP )
            {
                //
                // There's apparently no way to duplicate an HCRYPTPROV handle,
                // so we have to call CryptAcquireContext again. Also, rumour
                // has it that the Fortezza CSP nulls out the string passed to it,
                // so we have to use a copy of it 
                //
                if ( !CryptAcquireContext( &IIS_SERVER_CERT::m_hFortezzaCSP,
                                           pszCSPStringCopy,
                                           NULL,
                                           PROV_FORTEZZA,
                                           CRYPT_SILENT | CRYPT_MACHINE_KEYSET ) )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Couldn't get handle to Fortezza CSP : 0x%d\n",
                               GetLastError()));

                    m_dwStatus = CERT_ERR_CAPI;
                    goto EndRetrieveCertContext;
                }
                
                //
                // Install the handler used to verify Fortezza signatures.
                //
                CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA CDCMOP;
                LPSTR rgszOID[2];

                CDCMOP.cOID = 2;
                CDCMOP.rgpszOID = rgszOID;
                CDCMOP.rgpszOID[0] = szOID_INFOSEC_mosaicUpdatedSig;
                CDCMOP.rgpszOID[1] = szOID_INFOSEC_mosaicKMandUpdSig;

                if (!CryptInstallDefaultContext( IIS_SERVER_CERT::m_hFortezzaCSP,
                                                 CRYPT_DEFAULT_CONTEXT_MULTI_CERT_SIGN_OID,
                                                 &CDCMOP,
                                                 CRYPT_DEFAULT_CONTEXT_PROCESS_FLAG,
                                                 NULL,
                                                 &IIS_SERVER_CERT::m_hFortezzaCtxt ) )
                {
                    DBGPRINTF((DBG_CONTEXT,
                               "Failed to install Fortezza context : 0x%d\n",
                               GetLastError()));
                    m_dwStatus = CERT_ERR_CAPI;
                    goto EndRetrieveCertContext;
                }
            }
        }
    }
    mb.Close();

    //
    // Read store name etc out of MB
    //
    m_pStoreInfo = ReadCertStoreInfoFromMB( pMDObject,
                                            m_strMBPath.QueryStr(),
                                            FALSE );

    if ( !m_pStoreInfo )
    {
        m_dwStatus = CERT_ERR_MB;
        goto EndRetrieveCertContext;
    }

    //
    // Open store in which to look for the cert
    //
    if ( !(m_pStoreInfo->hCertStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                                     0,
                                                     (fProgPINEntry ? m_hCryptProv : NULL ),
                                                     CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                                     m_pStoreInfo->pszStoreName ) ) )

    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndRetrieveCertContext;
    }

    //
    // Try to find the cert in the store
    //
    CRYPT_HASH_BLOB HashBlob;
    HashBlob.cbData = dwHashSize;
    HashBlob.pbData = pbCertHash;
    
    m_pCertContext = CertFindCertificateInStore( m_pStoreInfo->hCertStore,
                                                 X509_ASN_ENCODING,
                                                 0,
                                                 CERT_FIND_SHA1_HASH,
                                                 (VOID *) &HashBlob,
                                                 NULL );
    
    if ( !m_pCertContext )
    {
        m_dwStatus = CERT_ERR_CERT_NOT_FOUND;
        goto EndRetrieveCertContext;
    }
    else
    {
#if DBG
        CHAR szSubjectName[1024];
        if ( CertGetNameString( m_pCertContext,
                                CERT_NAME_SIMPLE_DISPLAY_TYPE,
                                0,
                                NULL,
                                szSubjectName,
                                1024 ) )
        {
            DBGPRINTF((DBG_CONTEXT,
                       "Retrieved cert for %s \n", 
                       szSubjectName));
        }
#endif
    }
    
    if ( fProgPINEntry )
    {
        //
        // If this is a Fortezza cert, then we should set the 
        // CERT_KEY_PROV_HANDLE_PROP_ID property of the context to point to
        // the HCRYPTPROV retrieved by CryptAcquireContext().  Why?  Because
        // if we don't set this property, Schannel will try to acquire the 
        // provider handle itself, and will NOT set the CRYPT_MACHINE_KEY
        // flag when doing the call to CryptAcquireContext() and thus we
        // will not be able to acquire the credential handle in SSPIFILT.
        //
        // Fortezza rocks
        //
    
        if ( !CertSetCertificateContextProperty( m_pCertContext,
                                                 CERT_KEY_PROV_HANDLE_PROP_ID,
                                                 CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                                 (VOID*) m_hCryptProv ) )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndRetrieveCertContext;
        }
    }

    //
    // If we got this far, everything is happy
    //
    m_dwStatus = CERT_ERR_NONE;

EndRetrieveCertContext:

    //
    // This is where all the cleanup that takes place only if we fail needs to
    // happen
    //

    DBG_ASSERT( m_dwStatus < CERT_ERR_END );

    if ( m_dwStatus != CERT_ERR_NONE )
    {
        DBGPRINTF((DBG_CONTEXT,
                    "IIS_SERVER cert constructor, Error occurred : 0x%x\n", 
                    GetLastError()));

        if ( m_pCertContext != NULL )
        {
            CertFreeCertificateContext( m_pCertContext );
            m_pCertContext = NULL;
        }

        if ( m_pStoreInfo )
        {
            DeallocateCertStoreInfo( m_pStoreInfo );
            m_pStoreInfo = NULL;
        }


        if ( m_hCryptProv != NULL )
        {
            CryptReleaseContext( m_hCryptProv,
                                 0 );
            m_hCryptProv = NULL;
        }
    }

    //
    // Cleanup we do regardless of success/failure
    //
    //
    // clean out memory holding PIN
    //
    if ( pszCSPString )
    {
        memset( pszCSPString, 0, strlen( pszCSPString ) );
        delete [] pszCSPString;
    }

    if ( pszCSPStringCopy )
    {
        memset( pszCSPStringCopy, 0, strlen( pszCSPStringCopy ) );
        delete [] pszCSPStringCopy;
    }

    mb.Close();

} //IIS_SERVER_CERT::IIS_SERVER_CERT

IIS_SERVER_CERT::~IIS_SERVER_CERT()
/*++

Routine Description:
 
    Destructor

Arguments :
  
    None

Returns :

    Nothing
--*/
{
    if ( m_pCertContext )
    {
        CertFreeCertificateContext( m_pCertContext );
        m_pCertContext = NULL;
    }

    if ( m_pStoreInfo )
    {
        DeallocateCertStoreInfo( m_pStoreInfo );
        m_pStoreInfo = NULL;
    }

    if ( m_hCryptProv )
    {
        CryptReleaseContext( m_hCryptProv,
                             0 );
        m_hCryptProv = NULL;
    }
} //~IIS_SERVER_CERT::IIS_SERVER_CERT

BOOL IIS_SERVER_CERT::RetrievePINInfo( IN MB *pMB,
                                       OUT LPTSTR *ppszPIN,
                                       OUT LPTSTR *ppszSerialNumber,
                                       OUT LPTSTR *ppszPersonality )
/*++

Routine Description:

     Retrieve PIN information for Fortezza certificates 

Arguments:

    pMB - pointer to MB object, open for reading 
    ppszPIN - pointer to pointer to PIN for Fortezza card, updated on success
    ppszSerialNumber - pointer to pointer to card serial number, updated on success
    ppszPersonality - pointer to pointer to Fortezza "personality", updated on sucess

Returns:

   BOOL indicating success/failure

--*/
{
    DBG_ASSERT( pMB && 
                ppszPIN && 
                ppszSerialNumber && 
                ppszPersonality );

    DWORD cbLen = 0;
    BOOL fSuccess = FALSE;
    DWORD dwReqDataLen = 0;
    METADATA_RECORD mdr;

    //
    // Retrieve PIN
    //
    cbLen = 0;
    if ( ( !pMB->GetString( NULL,
                            MD_SSL_CERT_FORTEZZA_PIN,
                            IIS_MD_UT_SERVER,
                            NULL,
                            &cbLen,
                            METADATA_SECURE ) &&
           GetLastError() != ERROR_INSUFFICIENT_BUFFER ) ||
         !cbLen )
    {
        goto end_pin_info;
    }
    
    *ppszPIN = new CHAR[cbLen + 1];
    
    if ( !*ppszPIN ||
         !pMB->GetString( NULL,
                          MD_SSL_CERT_FORTEZZA_PIN,
                          IIS_MD_UT_SERVER,
                          *ppszPIN,
                          &cbLen,
                          METADATA_SECURE ) )
    {
        goto end_pin_info;
    }
    
        
    //
    // Retrieve serial #
    //
    cbLen = 0;
    if ( ( !pMB->GetString( NULL,
                            MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
                            IIS_MD_UT_SERVER,
                            NULL,
                            &cbLen,
                            METADATA_SECURE ) &&
           GetLastError() != ERROR_INSUFFICIENT_BUFFER ) || 
         !cbLen )
    {
        goto end_pin_info;
    }
    
    *ppszSerialNumber = new CHAR[cbLen + 1];

    if ( !*ppszSerialNumber ||
         !pMB->GetString( NULL,
                          MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
                          IIS_MD_UT_SERVER,
                          *ppszSerialNumber,
                          &cbLen,
                          METADATA_SECURE ) )
    {
        goto end_pin_info;
    }


    //
    // Retrieve personality
    //
    cbLen = 0;
    if ( ( !pMB->GetString( NULL,
                            MD_SSL_CERT_FORTEZZA_PERSONALITY,
                            IIS_MD_UT_SERVER,
                            NULL,
                            &cbLen,
                            METADATA_SECURE ) &&
           GetLastError() != ERROR_INSUFFICIENT_BUFFER ) || 
         !cbLen )
    {
        goto end_pin_info;
    }
    
    *ppszPersonality = new CHAR[cbLen + 1];
    
    if ( !*ppszPersonality ||
         !pMB->GetString( NULL,
                          MD_SSL_CERT_FORTEZZA_PERSONALITY,
                          IIS_MD_UT_SERVER,
                          *ppszPersonality,
                          &cbLen,
                          METADATA_SECURE ) )
    {
        goto end_pin_info;
    }
    
    fSuccess = TRUE;

end_pin_info:

    if ( !fSuccess )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "RetrievePINInfo failed : 0x%x\n",
                   GetLastError()));

        //
        // Clean out all the PIN info, making sure to erase the memory
        //
        if ( *ppszPIN )
        {
            /* INTRINSA suppress = uninitialized */
            memset( *ppszPIN, 0, strlen(*ppszPIN) );
            delete [] *ppszPIN;
        }

        if ( *ppszSerialNumber )
        {
            memset( *ppszSerialNumber, 0, strlen(*ppszSerialNumber) );
            delete [] *ppszSerialNumber;
        }

        if ( *ppszPersonality )
        {
            memset( *ppszPersonality, 0, strlen(*ppszPersonality) );
            delete [] *ppszPersonality;
        }
    }

    return fSuccess;
}


inline
BOOL IIS_SERVER_CERT::IsValid()
{
 return ( m_dwStatus == CERT_ERR_NONE ? TRUE : FALSE ) ; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\iisctl.cxx ===
/*++



Copyright (c) 1995  Microsoft Corporation

Module Name:

   iisctl.cxx

Abstract:

    This module contains the code for the class to deal with Certificate Trust Lists

Author:

    Alex Mallet [amallet] 01-09-98

Revision History:
--*/

#include "tcpdllp.hxx"
#pragma hdrstop


#include <dbgutil.h>
#include <buffer.hxx>
#include <ole2.h>
#include <imd.h>
#include <mb.hxx>

#include <iiscert.hxx>
#include <capiutil.hxx>
#include <iisctl.hxx>


IIS_CTL::IIS_CTL( IN IMDCOM *pMBObject,
                  IN LPTSTR pszMBPath ) :
m_strMBPath( pszMBPath ),
m_pwszListIdentifier( NULL ),
m_hMemoryStore( NULL ),
m_pCTLContext( NULL ),
m_hCryptProv( NULL ),
m_fFoundCerts( FALSE ),
m_pCTLCerts( NULL ),
m_cCertsFound( 0 ),
m_hMyStore( NULL ),
m_hCAStore( NULL ),
m_hRootStore( NULL ),
m_pSignerCert( NULL )
/*++

Routine Description:

    Constructor for CTL

Arguments:

    pMDObject - pointer to metabase object 
    pszMBPath - fully qualified path in metabase where CTL identifier is stored

Returns:

   Nothing

--*/
{
    DBG_ASSERT( pMBObject );
    DBG_ASSERT( pszMBPath );

    MB mb( pMBObject );
    METADATA_HANDLE hInfoHandle = NULL;
    POPEN_CERT_STORE_INFO pCertStoreInfo = NULL;
    DWORD dwIdentifierSize = 0;
    HCRYPTPROV hCryptProv = NULL;
    HCERTSTORE hStore = NULL;

    m_dwStatus = CERT_ERR_INTERNAL;

    if ( !m_strMBPath.IsValid() )
    {
        m_dwStatus = CERT_ERR_INTERNAL;
        SetLastError(ERROR_OUTOFMEMORY);
        goto EndCTLConstructor;
    }

    //
    // Read CTL identifier out of MB 
    //
    if ( mb.Open( m_strMBPath.QueryStr(),
                  METADATA_PERMISSION_READ ))
    {
        METADATA_RECORD mdr;
        
        MD_SET_DATA_RECORD( &mdr, 
                            MD_SSL_CTL_IDENTIFIER,
                            METADATA_NO_ATTRIBUTES,
                            IIS_MD_UT_SERVER, 
                            STRING_METADATA, 
                            NULL,
                            0 );

        if ( !RetrieveBlobFromMetabase( &mb,
                                        NULL,
                                        &mdr,
                                        0 ) )
        {
            m_dwStatus = CERT_ERR_MB;
            goto EndCTLConstructor;
        }
        else
        {
#if DBG
            DBGPRINTF((DBG_CONTEXT,
                       "List identifier : %s\n", 
                       (LPSTR) mdr.pbMDData));
#endif

            //
            // Need to convert the list identifier to a wide-char string
            //
            dwIdentifierSize = 0;
            
            if ( dwIdentifierSize = MultiByteToWideChar( CP_ACP,
                                                         0,
                                                         (LPCSTR) mdr.pbMDData,
                                                         mdr.dwMDDataLen,
                                                         NULL,
                                                         0 ) )
            {
                m_pwszListIdentifier = new WCHAR[dwIdentifierSize];                    
                
                if ( !m_pwszListIdentifier || 
                     !MultiByteToWideChar( CP_ACP,
                                           0,
                                           (LPCSTR) mdr.pbMDData,
                                           mdr.dwMDDataLen,
                                           m_pwszListIdentifier, 
                                           dwIdentifierSize ) )
                {
                    delete [] mdr.pbMDData;
                    m_dwStatus = CERT_ERR_INTERNAL;
                    goto EndCTLConstructor;
                }
            }
            else
            {
                delete [] mdr.pbMDData;
                m_dwStatus = CERT_ERR_INTERNAL;
                goto EndCTLConstructor;
            }

            delete [] mdr.pbMDData;
        }
    }        
    mb.Close();

    //
    // Read cert store info out of MB, and try to reconstruct CTL context
    //
    if ( (pCertStoreInfo = ReadCertStoreInfoFromMB( pMBObject,
                                                    pszMBPath,
                                                    TRUE ) ) )
    {
#if 0
        if ( !CryptAcquireContext( &m_hCryptProv,
                                   pCertStoreInfo->pszContainer,
                                   pCertStoreInfo->pszProvider,
                                   pCertStoreInfo->dwProvType,
                                   pCertStoreInfo->dwFlags ) )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndCTLConstructor;
        }

        if ( !( hStore = CertOpenSystemStore( m_hCryptProv,
                                              pCertStoreInfo->pszStoreName ) ) )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndCTLConstructor;
        }
#else
        if ( !( hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                        0,
                                        NULL,
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                        pCertStoreInfo->pszStoreName ) ) )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndCTLConstructor;
        }
        else
        {
            if ( ! m_strStoreName.Copy( pCertStoreInfo->pszStoreName ) )
            {
                SetLastError( ERROR_OUTOFMEMORY );
                goto EndCTLConstructor;
            }
        }
#endif

        CTL_FIND_USAGE_PARA CtlFindUsagePara;
        memset(&CtlFindUsagePara, 0, sizeof(CtlFindUsagePara));

        CtlFindUsagePara.cbSize = sizeof(CtlFindUsagePara);
        CtlFindUsagePara.ListIdentifier.cbData = dwIdentifierSize * sizeof(WCHAR);
        CtlFindUsagePara.ListIdentifier.pbData = (PBYTE) m_pwszListIdentifier;


        //
        // Try to find CTL in specified store
        //
        m_pCTLContext = CertFindCTLInStore( hStore,
                                            X509_ASN_ENCODING | PKCS_7_ASN_ENCODING,
                                            0,
                                            CTL_FIND_USAGE,
                                            (LPVOID) &CtlFindUsagePara,
                                            NULL );

        if ( !m_pCTLContext )
        {
            m_dwStatus = CERT_ERR_CAPI;
            goto EndCTLConstructor;
        }
    }
    else
    {
        m_dwStatus = CERT_ERR_MB;
        goto EndCTLConstructor;
    }


    //
    // Construct the in-memory store that will only contain this CTL, to be passed to
    // WinVerifyTrust and add the CTL to the created store
    //
    m_hMemoryStore = NULL;
    m_hMemoryStore = CertOpenStore( CERT_STORE_PROV_MEMORY,
                                    0,
                                    0,
                                    0,
                                    0 );

    if ( !m_hMemoryStore )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }        

    if ( !CertAddCTLContextToStore( m_hMemoryStore,
                                    m_pCTLContext,
                                    CERT_STORE_ADD_NEW,
                                    NULL ) )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }


    if ( !( m_hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                        0,
                                        NULL,
                                        CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                        MY_STORE_NAME ) ) )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }

    if ( !(m_hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                       0,
                                       NULL,
                                       CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                       CA_STORE_NAME ) ) )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }

    if ( !( m_hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                          0,
                                          NULL,
                                          CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                          ROOT_STORE_NAME ) ) )
    {
        m_dwStatus = CERT_ERR_CAPI;
        goto EndCTLConstructor;
    }

    m_dwStatus = CERT_ERR_NONE;

EndCTLConstructor:

    DBG_ASSERT( m_dwStatus< CERT_ERR_END );

    //
    // Cleanup done only on failure
    //
    if ( m_dwStatus != CERT_ERR_NONE )
    {
        DBGPRINTF((DBG_CONTEXT,
                   "Error in CTL constructor : 0x%x\n",
                   GetLastError()));

        if ( m_pwszListIdentifier )
        {
            delete [] m_pwszListIdentifier;
            m_pwszListIdentifier = NULL;
        }

        if ( m_pCTLContext )
        {
            CertFreeCTLContext( m_pCTLContext );
            m_pCTLContext = NULL;
        }

        if ( hStore )
        {
            CertCloseStore( hStore,
                            0 );
            hStore = NULL;
        }
        
        if ( m_hMemoryStore )
        {
            CertCloseStore( m_hMemoryStore,
                            0 );
            m_hMemoryStore = NULL;
        }

        if ( m_hRootStore )
        {
            CertCloseStore( m_hRootStore,
                            0 );
            m_hRootStore = NULL;
        }

        if ( m_hCAStore )
        {
            CertCloseStore( m_hCAStore,
                            0 );
            m_hCAStore = NULL;
        }

        if ( m_hMyStore )
        {
            CertCloseStore( m_hMyStore,
                            0 );
            m_hMyStore = NULL;
        }

        if ( m_hCryptProv )
        {
            CryptReleaseContext ( m_hCryptProv,
                                  0 );
            m_hCryptProv = NULL;
        }
    }

    //
    //Cleanup done regardless of success/failure
    //
    DeallocateCertStoreInfo( pCertStoreInfo );
    pCertStoreInfo = NULL;

} //IIS_CTL:IIS_CTL



IIS_CTL::~IIS_CTL()
/*++

Routine Description:

    Destructor for CTL

Arguments:

   None

Returns:

   Nothing

--*/
{
    if ( m_pwszListIdentifier )
    {
        delete [] m_pwszListIdentifier;
        m_pwszListIdentifier = NULL;
    }
    
    if ( m_pCTLContext )
    {
        CertFreeCTLContext( m_pCTLContext );
        m_pCTLContext = NULL;
    }

    if ( m_hMemoryStore )
    {
        CertCloseStore( m_hMemoryStore,
                        0 );
        m_hMemoryStore = NULL;
    }

    if ( m_hRootStore )
    {
        CertCloseStore( m_hRootStore,
                        0 );
        m_hRootStore = NULL;
    }
    
    if ( m_hCAStore )
    {
        CertCloseStore( m_hCAStore,
                        0 );
        m_hCAStore = NULL;
    }
    
    if ( m_hMyStore )
    {
        CertCloseStore( m_hMyStore,
                        0 );
        m_hMyStore = NULL;
    }
    
    if ( m_hCryptProv )
    {
        CryptReleaseContext ( m_hCryptProv,
                              0 );
        m_hCryptProv = NULL;
    }

    if ( m_cCertsFound && m_pCTLCerts )
    {
        for ( DWORD i = 0; i < m_cCertsFound; i++ )
        {
            CertFreeCertificateContext( m_pCTLCerts[i] );
        }
        delete [] m_pCTLCerts;

        m_pCTLCerts = NULL;
        m_cCertsFound = 0;
    }
}

HCERTSTORE IIS_CTL::GetMemoryStore()
/*++

Routine Description:

    Returns a handle to an in-memory store that contains the CTL

Arguments:

    None

Returns:

     Handle to in-memory store
--*/

{
    DBG_ASSERT( m_hMemoryStore );

    if ( m_hMemoryStore )
    {
        return CertDuplicateStore( m_hMemoryStore );
    }

    return NULL;
}
    
                                   
BOOL IIS_CTL::QuerySignerCert( OUT PCCERT_CONTEXT *ppcSigner )
/*++

Routine Description:

    Retrieves the cert that signed this CTL

Arguments:

    ppcSigner - pointer to pointer to cert context, updated if successful. Caller's
    responsibility to clean it up

Returns:

    TRUE if there were no errors encountered in retrieving the signer
--*/
{
    DWORD dwNumSigners = 3;
    HCERTSTORE ahStores[3];
    BOOL fGotRoot = TRUE;
    BOOL fGotCA = TRUE;
    BOOL fOk = TRUE;

    if ( !m_pSignerCert )
    {
        //
        // Look in 3 stores to find signer : store the cert came from, CA and ROOT stores
        // for Local Machine
        //
        ahStores[0] = m_pCTLContext->hCertStore;
        ahStores[1] = m_hRootStore;
        ahStores[2] = m_hCAStore;

        CryptMsgGetAndVerifySigner( (HCRYPTMSG) m_pCTLContext->hCryptMsg,
                                    dwNumSigners,
                                    ahStores,
                                    CMSG_TRUSTED_SIGNER_FLAG,
                                    &m_pSignerCert,
                                    0 );
    }
    
    //
    // If we don't have a signer cert at this point, we're just not happy
    //
    if ( m_pSignerCert )
    {
        *ppcSigner = CertDuplicateCertificateContext( m_pSignerCert );
    }
    else
    {
        fOk = FALSE;
    }

    return fOk;
}


BOOL IIS_CTL::VerifySignature( IN OPTIONAL HCERTSTORE *phSignerStores,
                               IN DWORD cSignerStores,
                               LPBOOL pfTrusted )

/*++

Routine Description:

    Verify that this CTL was signed by a certificate in a trusted store.

Arguments:

    phSignerStores - optional array of store handles to be used in searching for a cert used
    to sign this CTL. If NULL, the stores tried are the CA and ROOT stores for the local machine, 
    as well as the store the CTL came from.

    cSignerStores - number of stores in phSignerStores. Should be zero if phSignerStores == NULL

    pfTrusted - pointer to bool, updated with TRUE if CTL signature was verified, FALSE if not.

Returns:

    TRUE if there were no errors encountered in checking the CTL, FALSE if not 
    NB : TRUE does -NOT- mean the CTL signature was verified !!!

--*/
{
    DBG_ASSERT( m_pCTLContext );

    DWORD dwNumSigners = cSignerStores;
    HCERTSTORE *phStores = phSignerStores;
    HCERTSTORE ahStores[3];
    BOOL fGotRoot = TRUE;
    BOOL fGotCA = TRUE;


    if ( !phSignerStores )
    {
        dwNumSigners = 3;

        ahStores[0] = m_pCTLContext->hCertStore;
        ahStores[1] = m_hRootStore;
        ahStores[2] = m_hCAStore;

        phStores = ahStores;
    }

    *pfTrusted = CryptMsgGetAndVerifySigner( (HCRYPTMSG) m_pCTLContext->hCryptMsg,
                                             dwNumSigners,
                                             phStores,
                                             CMSG_TRUSTED_SIGNER_FLAG,
                                             NULL,
                                             0 );
    if ( !*pfTrusted )
    {
        DBGPRINTF((DBG_CONTEXT, "CTL wasn't verified b'cos 0x%x\n",
                   GetLastError()));
    }

    return TRUE;
}
                                             
BOOL IIS_CTL::GetContainedCertificates( OUT PCCERT_CONTEXT **pppCertContext,
                                        OUT DWORD *pcCertsFound,
                                        OUT DWORD *pcCertsInCTL )

/*++

Routine Description:

    Tries to retrieve CERT_CONTEXT pointers for the certs contained in the Certificate
    Trust List.

Arguments:

    pppCertContext - pointer to array of CERT_CONTEXT pointers, filled out with the found 
    CERT_CONTEXTS.
    Caller is responsible for releasing the contexts when done with them and deleting
    the array used to hold them.

    pcCertsFound - pointer to number of cert contexts returned in ppCertContext

    pcCertsInCTL - pointer to number of certs in CTL; may differ from *pccCertsFound
    if some certificates couldn't be found
    
Returns:

    TRUE if no internal errors occurred, FALSE if NOT
--*/
{
    PCTL_INFO pCtlInfo = m_pCTLContext->pCtlInfo;
    HCERTSTORE ahStores[3];
    DWORD dwNumStores = 3;


    DBG_ASSERT( pCtlInfo->cCTLEntry );

    //
    // Let's be optimistic and allocate as much space as we can possibly 
    // need
    //
    *pppCertContext = new PCCERT_CONTEXT[pCtlInfo->cCTLEntry];
        
    if ( !*pppCertContext )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        return FALSE;
    }

    *pcCertsFound  = 0;
    *pcCertsInCTL = pCtlInfo->cCTLEntry;
    
    //
    // If we haven't searched the stores yet, do so now
    //
    if ( !m_fFoundCerts )
    {
        m_pCTLCerts = new PCCERT_CONTEXT[pCtlInfo->cCTLEntry];
        m_cCertsFound = 0;
        
        if ( !m_pCTLCerts )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            /* INTRINSA suppress = leaks */
            return FALSE;
        }
        
        ahStores[0] = m_hMyStore;
        ahStores[1] = m_hCAStore;
        ahStores[2] = m_hRootStore;

        //
        // Iterate through the certs in the CTL. For each cert, try to find it
        // by SHA1 hash in the supplied stores. 
        //
        DWORD dwIndex = 0;
        DWORD dwStoreIndex = 0;
        PCCERT_CONTEXT pcCert = NULL;
        
        for ( dwIndex = 0; dwIndex < pCtlInfo->cCTLEntry; dwIndex++ )
        {
            for ( dwStoreIndex = 0; dwStoreIndex < dwNumStores; dwStoreIndex++ )
            {
                
                if ( pcCert = CertFindCertificateInStore( ahStores[dwStoreIndex],
                                                          X509_ASN_ENCODING,
                                                          0,
                                                          CERT_FIND_SHA1_HASH,
                                      (VOID *) &(pCtlInfo->rgCTLEntry[dwIndex].SubjectIdentifier),
                                                          NULL ) )
                {
                    m_pCTLCerts[m_cCertsFound] = pcCert;
                    
                    (*pppCertContext)[m_cCertsFound] = 
                        CertDuplicateCertificateContext( pcCert );
                    
                    m_cCertsFound++;
                    
                    break;
                }
            }
        }
        
        *pcCertsFound = m_cCertsFound;
        m_fFoundCerts = TRUE;
    } // if ( !m_fFounCerts
    //
    // Already have the list of certs in the CTL
    //
    else
    {
        *pppCertContext = new PCCERT_CONTEXT[m_cCertsFound];
        if ( !*pppCertContext )
        {
            SetLastError( ERROR_OUTOFMEMORY );
            return FALSE;
        }
        
        for ( DWORD i = 0; i < m_cCertsFound; i++ )
        {
            (*pppCertContext)[i] = CertDuplicateCertificateContext( m_pCTLCerts[i] );
        }
        
        *pcCertsInCTL = pCtlInfo->cCTLEntry;
        *pcCertsFound = m_cCertsFound;
    }

    return TRUE;
}

inline 
BOOL IIS_CTL::IsValid()
{
 return ( m_dwStatus == CERT_ERR_NONE ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\iisendp.cxx ===
/*++
   Copyright    (c)    1996        Microsoft Corporation

   Module Name:

        iisendp.cxx

   Abstract:

        This module defines the IIS_ENDPOINT class

   Author:

        Johnson Apacible    (JohnsonA)      June-04-1996

--*/

#include "tcpdllp.hxx"
#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include <iisassoc.hxx>
#include "inetreg.h"
#include <tcpcons.h>
#include <apiutil.h>
#include <issched.hxx>

#include "..\atq\atqtypes.hxx"

#if IE_REF_TRACKING

//
//  Ref count trace log size
//
#define C_IIS_ENDP_REFTRACES      4000
#define C_LOCAL_ENDP_REFTRACES         40

//
//  Ref trace log for IIS_ENDPOINT objects
//  NOTE we make this global so other classes can get at it
//
PTRACE_LOG   g_pDbgIERefTraceLog = NULL;

#endif

/*******************************************************************

    Macro support for IIS_ENDPOINT::Reference/Dereference

    HISTORY:
        MCourage       31-Oct-1997 Added ref trace logging

********************************************************************/

#if IE_REF_TRACKING
#define IE_LOG_REF_COUNT( cRefs )                               \
                                                                \
    IE_SHARED_LOG_REF_COUNT(                                       \
        cRefs                                                   \
        , (PVOID) this                                          \
        , m_state                                               \
        , m_atqEndpoint                                                \
        , 0xffffffff                                                \
        );                                                      \
    IE_LOCAL_LOG_REF_COUNT(                                        \
        cRefs                                                   \
        , (PVOID) this                                          \
        , m_state                                               \
        , m_atqEndpoint                                                \
        , 0xffffffff                                                \
        );
#else
#define IE_LOG_REF_COUNT( cRefs )
#endif



PVOID
I_IISAddListenEndpoint(
        IN PATQ_ENDPOINT_CONFIGURATION Configuration,
        IN PVOID                EndpointContext
        );


BOOL
IIS_SERVICE::AssociateInstance(
    IN PIIS_SERVER_INSTANCE pInstance
    )
/*++

Routine Description:

    Associates an instance with an endpoint.  It also activates the endpoint.

Arguments:

    pInstance - instance to associate.

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{

    DWORD err = NO_ERROR;
    BOOL shouldStart = FALSE;

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,
            "AssociateInstance %p called\n",
            pInstance));
    }

    //
    // Lock the service.
    //

    AcquireServiceLock( TRUE );

    //
    // if service is closing, abort
    //

    if ( !IsActive() ) {
        err = ERROR_NOT_READY;
        goto exit;
    }

    if ( pInstance->QueryServerState( ) != MD_SERVER_STATE_STOPPED ) {
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,"Server not in stopped (%d) state\n",
                    pInstance->QueryServerState()));
        }
        err = ERROR_INVALID_FUNCTION;
        goto exit;
    }

    //
    // Start the server instance.
    //

    shouldStart = TRUE;
    err = pInstance->DoStartInstance();

    if( err != NO_ERROR ) {
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT, "BindInstance() failed, %lu\n", err));
        }
    }

exit:

    if( shouldStart ) {

        //
        // We're up and running. Note that the StartInstance() method will
        // set the instance state appropriately if successful, so we only
        // need to set it if the start failed.
        //

        if( err != NO_ERROR ) {
            pInstance->SetServerState( MD_SERVER_STATE_STOPPED, err );
        }

        ReleaseServiceLock( TRUE );
        return TRUE;

    } else {

        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,"AssociateInstace: Error %d\n",
                err));
        }

        pInstance->SetServerState( MD_SERVER_STATE_STOPPED, err );
        ReleaseServiceLock( TRUE );
        SetLastError(err);
        return FALSE;

    }

} // IIS_SERVICE::AssociateInstance



BOOL
IIS_SERVICE::DisassociateInstance(
    IN PIIS_SERVER_INSTANCE pInstance
    )
/*++

Routine Description:

    Removes an instance from an endpoint.

Arguments:

    pInstance - instance to associate.

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{

    //
    // if it's running, stop it
    //

    AcquireServiceLock( TRUE );

    if ( pInstance->QueryServerState( ) == MD_SERVER_STATE_STOPPED ) {
        ReleaseServiceLock( TRUE );
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,
                "Cannot disassociate stopped server %p\n",pInstance));
        }
        return(TRUE);
    }

    pInstance->SetServerState( MD_SERVER_STATE_STOPPED, NO_ERROR );
    ReleaseServiceLock( TRUE );

    //
    // Blow away any users still clinging to this instance,
    // then unbind the instance.
    //

    pInstance->Reference();
    DisconnectUsersByInstance( pInstance );
    pInstance->UnbindInstance();
    pInstance->Dereference();

    return TRUE;

} // IIS_SERVICE::DisassociateInstance



BOOL
IIS_SERVICE::ShutdownService(
    VOID
    )
/*++

Routine Description:

    Shuts down all endpoints.

Arguments:

    None.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{

    //
    // Walk the list and close the instances
    //

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT, "ShutdownService called\n"));
    }

    //
    // Update the service state.
    //

    AcquireServiceLock( );
    m_state = BlockStateClosed;
    ReleaseServiceLock( );

    //
    // Blow away all instances.
    //

    DestroyAllServerInstances();

    return TRUE;

} // IIS_SERVICE::ShutdownService




IIS_ENDPOINT::IIS_ENDPOINT(
    IN PIIS_SERVICE pService,
    IN USHORT Port,
    IN DWORD IpAddress,
    IN BOOL fIsSecure
    )
:
    m_signature                     ( IIS_ENDPOINT_SIGNATURE),
    m_state                         ( BlockStateIdle),
    m_atqEndpoint                   ( NULL),
    m_isSecure                      ( fIsSecure),
    m_fAtqEpStopped                 ( FALSE),
    m_service                       ( NULL),
    m_reference                     ( 1),
    m_NumQualifiedInstances         ( 0),
    m_WildcardInstance              ( NULL),
    m_nAcceptExOutstanding          ( 0),
    m_AcceptExTimeout               ( 0),
    m_nInstances                    ( 0)
{

    //
    // initialize the lock
    //

    INITIALIZE_CRITICAL_SECTION(&m_endpointLock);

    //
    // initialize the association info
    //

    ZeroMemory(
        m_QualifiedInstances,
        sizeof(m_QualifiedInstances)
        );

    //
    // reference the service
    //

    if ( !pService->CheckAndReference( ) ) {
        m_state = BlockStateInvalid;
        return;
    }

    m_service = pService;

    //
    // use the service name as the advertised name
    //

    m_Port = Port;
    m_IpAddress = IpAddress;

#if IE_REF_TRACKING
    _pDbgIERefTraceLog = CreateRefTraceLog( C_LOCAL_ENDP_REFTRACES, 0 );
#endif

} // IIS_ENDPOINT::IIS_ENDPOINT


IIS_ENDPOINT::~IIS_ENDPOINT(
    VOID
    )
{
    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,"IIS Endpoint %p freed\n",this));
    }

    DBG_ASSERT( m_signature == IIS_ENDPOINT_SIGNATURE );

    //
    // Delete the instance association objects.
    //

    for( INT qualifier = (INT)FullyQualified ;
         qualifier < (INT)NumInstanceQualifiers ;
         qualifier++ ) {

        delete m_QualifiedInstances[qualifier];

    }

    //
    // Dereference the owning service.
    //

    if ( m_service != NULL ) {
        m_service->Dereference();
        m_service = NULL;
    }

    m_signature = IIS_ENDPOINT_SIGNATURE_FREE;
    DeleteCriticalSection(&m_endpointLock);

#if IE_REF_TRACKING
    DestroyRefTraceLog( _pDbgIERefTraceLog );
#endif

} // IIS_ENDPOINT::~IIS_ENDPOINT



BOOL
IIS_ENDPOINT::AddInstance(
    IN PIIS_SERVER_INSTANCE pInstance,
    IN DWORD IpAddress,
    IN const CHAR * HostName
    )
/*++

Routine Description:

    Adds an instance to an existing endpoint.

Arguments:

    pInstance - instance to add.

    IpAddress - The IP address for this instance; may be INADDR_ANY;.

    HostName - The host name for this instance; may be empty ("").

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{
    INSTANCE_QUALIFIER qualifier;
    DWORD status;

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,
            "IIS_ENDPOINT::AddInstance %p called\n", pInstance));
    }

    //
    // Determine the proper qualifier based on the presence of the
    // IP address and host name.
    //

    qualifier = CalcQualifier( IpAddress, HostName );

    LockEndpoint();

    //
    // Put instance into proper association.
    //

    if( qualifier == WildcardInstance ) {

        if( m_WildcardInstance == NULL ) {
            m_WildcardInstance = pInstance;
        } else {
            DBGPRINTF((
                DBG_CONTEXT,
                "AddInstance: endpoint %p already has a wildcard instance\n",
                this
                ));

            status = ERROR_INVALID_PARAMETER;
            goto unlock_and_fail;
        }

    } else {

        PIIS_ASSOCIATION association;

        //
        // Create a new instance association object if necessary.
        //

        association = m_QualifiedInstances[qualifier];

        if( association == NULL ) {
            association = new IIS_ASSOCIATION(
                                  ( qualifier == FullyQualified ) ||
                                      ( qualifier == QualifiedByIpAddress ),
                                  ( qualifier == FullyQualified ) ||
                                      ( qualifier == QualifiedByHostName )
                                  );

            if( association == NULL ) {
                DBGPRINTF((
                    DBG_CONTEXT,
                    "AddInstance: cannot create new association\n"
                    ));

                status = ERROR_NOT_ENOUGH_MEMORY;
                goto unlock_and_fail;
            }

            m_QualifiedInstances[qualifier] = association;
        }

        //
        // Add the instance to the association.
        //

        status = association->AddDescriptor(
                     IpAddress,
                     HostName,
                     (LPVOID)pInstance
                     );

        if( status != NO_ERROR ) {
            goto unlock_and_fail;
        }

        //
        // Update the number of qualified instances on this endpoint.
        // We use this to "short circuit" the instance lookup in the
        // common case of a single wildcard instance per endpoint.
        //

        m_NumQualifiedInstances++;

    }

    //
    // Setup the necessary references, update the server state.
    //

    Reference();
    pInstance->Reference();
    InterlockedIncrement( (LPLONG)&m_nInstances );

    //
    // Aggregate the AcceptEx outstanding parameter.
    //

    m_nAcceptExOutstanding += pInstance->QueryAcceptExOutstanding();
    m_nMaximumAcceptExOutstanding = pInstance->QueryMaxEndpointConnections();

    //
    // Activate the endpoint if necessary.
    //

    if ( !ActivateEndpoint() ) {
        status = GetLastError();
        RemoveInstance( pInstance, IpAddress, HostName );
        goto unlock_and_fail;
    }

    UnlockEndpoint();
    return TRUE;

unlock_and_fail:

    DBG_ASSERT( status != NO_ERROR );
    UnlockEndpoint();
    SetLastError( status );
    return FALSE;

} // IIS_ENDPOINT::AddInstance


BOOL
IIS_ENDPOINT::RemoveInstance(
    IN PIIS_SERVER_INSTANCE pInstance,
    IN DWORD IpAddress,
    IN const CHAR * HostName
    )
/*++

Routine Description:

    Removes an instance to an existing endpoint.

Arguments:

    pInstance - instance to remove

    IpAddress - The IP address for this instance; may be INADDR_ANY;.

    HostName - The host name for this instance; may be empty ("").

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{
    INSTANCE_QUALIFIER qualifier;
    DWORD status;

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,
            "RemoveInstance called endpoint %p instance %p\n",
            this, pInstance ));
    }

    DBG_ASSERT( m_signature == IIS_ENDPOINT_SIGNATURE );

    //
    // Determine the proper qualifier based on the presence of the
    // IP address and host name.
    //

    qualifier = CalcQualifier( IpAddress, HostName );

    LockEndpoint();

    m_nAcceptExOutstanding -= pInstance->QueryAcceptExOutstanding();

    if( qualifier == WildcardInstance ) {

        DBG_ASSERT( m_WildcardInstance == pInstance );
        m_WildcardInstance->Dereference();
        m_WildcardInstance = NULL;

    } else {

        LPVOID Context;

        DBG_ASSERT( m_QualifiedInstances[qualifier] != NULL );
        status = m_QualifiedInstances[qualifier]->RemoveDescriptor(
                        IpAddress,
                        HostName,
                        &Context
                        );

        if( status == NO_ERROR ) {

            DBG_ASSERT( Context == (LPVOID)pInstance );
            pInstance->Dereference();
            m_NumQualifiedInstances--;

        }

    }

    UnlockEndpoint();

    //
    // If this was the last instance, then remove ourselves from
    // the service's endpoint list and initiate shutdown.
    //

    if ( InterlockedDecrement( (LPLONG ) &m_nInstances) == 0 ) {
        RemoveEntryList( &m_EndpointListEntry );
        ShutdownEndpoint( );
    }

    //
    // Remove the reference added in AddInstance().
    //

    Dereference();
    return TRUE;

} // IIS_ENDPOINT::RemoveInstance




BOOL
IIS_ENDPOINT::ActivateEndpoint(
    VOID
    )
/*++

Routine Description:

    Starts an idle endpoint.

Arguments:

    None.

Return Value:

    TRUE - if successful, FALSE otherwise

--*/
{
    PVOID atqEndpoint = NULL;
    ATQ_ENDPOINT_CONFIGURATION config;

    //
    // Make sure this is idle
    //

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,"Calling activate on %p\n",this));
    }

    LockEndpoint( );
    if ( m_state == BlockStateActive ) {
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF(( DBG_CONTEXT,
                "Activate called on %p is not in idle state(%d)\n",
                this, (DWORD)m_state ));
        }

        DBG_ASSERT(m_atqEndpoint != NULL);

        AtqEndpointSetInfo(
                m_atqEndpoint,
                EndpointInfoAcceptExOutstanding,
                min(
                    m_nAcceptExOutstanding,
                    m_nMaximumAcceptExOutstanding
                    )
                );

        UnlockEndpoint();
        return(TRUE);
    }

    config.cbAcceptExRecvBuffer = m_service->m_cbRecvBuffer;
    config.pfnConnect = m_service->m_pfnConnect;
    config.pfnConnectEx = m_service->m_pfnConnectEx;
    config.pfnIoCompletion = m_service->m_pfnIoCompletion;

    config.ListenPort = m_Port;
    config.IpAddress = m_IpAddress;
    config.nAcceptExOutstanding = min( m_nAcceptExOutstanding,
                                       m_nMaximumAcceptExOutstanding );
    config.AcceptExTimeout = m_AcceptExTimeout;

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT,"%d %d %d\n",
            config.ListenPort,
            config.nAcceptExOutstanding, config.AcceptExTimeout ));
    }

    atqEndpoint = I_IISAddListenEndpoint(
                                         &config,
                                         (PVOID)this
                                         );

    if ( atqEndpoint == NULL ) {
        UnlockEndpoint();
        DBGPRINTF(( DBG_CONTEXT,
            "Activate failed, error %d\n",GetLastError()));
        return(FALSE);
    }

    //
    // Update the state
    //

    m_state = BlockStateActive;
    m_atqEndpoint = atqEndpoint;
    Reference( );
    UnlockEndpoint();

    return(TRUE);

} // IIS_ENDPOINT::ActivateEndpoint



BOOL
IIS_ENDPOINT::StopEndpoint( VOID)
/*++

Routine Description:

    Stops the ATQ endpoint structure stored inside the IIS_ENDPOINT
    This will prevent us from accepting new connection. This function
    should be called only when are preparing ourselves to shut this
    endpoint down entirely.

Arguments:

    None.

Return Value:

    None.

History:
    MuraliK    7/8/97
--*/
{
    BOOL fReturn = TRUE;

    //
    // lock, check the state and
    //  then, stop any Atq Endpoint, if any.
    //

    LockEndpoint( );

    //
    // NYI: We mayhave to use an intermediate state for STopped endpoint.
    // Unfortunately the state machine usage in IIS_SERVICE/INSTANCE/ENDPOINT
    //   is not setup for doing so. For now I will just assert that this
    //   object is in an Active State
    //  - muralik  7/8/97
    //
    DBG_ASSERT( m_state == BlockStateActive);

    if ( m_atqEndpoint != NULL ) {
        
        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT, 
                       "IIS_ENDPOINT(%08p) Stopping ATQ Endpoint %p\n",
                       this, m_atqEndpoint));
        }
        
        if ( !m_fAtqEpStopped ) {
            
            fReturn = AtqStopEndpoint( m_atqEndpoint);
            if ( fReturn ) {
                m_fAtqEpStopped = TRUE;
            }
        }
    }

    UnlockEndpoint();

    return (fReturn);
} // IIS_ENDPOINT::StopEndpoint()



VOID
IIS_ENDPOINT::ShutdownEndpoint(
    VOID
    )
/*++

Routine Description:

    Shuts down an endpoint.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // lock, check the state and mark it closed.
    //  then, shutdown any Atq Endpoint, if any.
    //

    LockEndpoint( );

    DBG_ASSERT(m_nInstances == 0);

    if ( m_state == BlockStateActive ) {

        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,"Shutting down endpoint %p\n",this));
        }
        m_state = BlockStateClosed;
        UnlockEndpoint();

        IF_DEBUG( INSTANCE ) {
            DBGPRINTF(( DBG_CONTEXT,
                        "IIS_ENDPOINT(%08p)::ShutdownEndpoint() for "
                        " AtqEndpoint  %08p\n",
                        this, m_atqEndpoint ));
        }

        if ( m_atqEndpoint != NULL ) {

            // I replaced AtqStopAndCloseEndpoint() here 

            if ( !m_fAtqEpStopped ) {

                DBG_REQUIRE( AtqStopEndpoint( m_atqEndpoint));
                m_fAtqEpStopped = TRUE;
            }
            
/*
 * Moved this to IIS_ENDPOINT::Dereference for shutdown thread hack
 *
            AtqCloseEndpoint( m_atqEndpoint);
            m_atqEndpoint = NULL;
 */
        }

        Dereference( );
    } else {
        UnlockEndpoint();
    }

    return;
} // IIS_ENDPOINT::ShutdownEndpoint



PIIS_SERVER_INSTANCE
IIS_ENDPOINT::FindAndReferenceInstance(
                   IN LPCSTR pszDomainName,
                   IN const DWORD   IPAddress,
                   OUT LPBOOL pbMaxConnExceeded
                   )
/*++

Routine Description:

    Finds the appropriate instance given domain name and
    socket information.  The instance is referenced if found.

Arguments:

    pszDomainName - Domain name of request.
    IPAddress - Local IP Address of the connection.
    pbMaxConnExceeded - Receives TRUE if the maximum number of connections
        for this endpoint has been exceeded. It is still the caller's
        responsibility to properly dispose of the instance.

Return Value:

    if successful, returns the pointer to the instance.
    NULL, otherwise.

--*/
{

    PIIS_SERVER_INSTANCE instance;
    DWORD status;
    INT qualifier;
    IIS_ASSOCIATION::HASH_CONTEXT context;

    IF_DEBUG(ENDPOINT) {

        LPCSTR tmp = pszDomainName;
        if ( tmp == NULL ) {
            tmp = "";
        }
        DBGPRINTF((DBG_CONTEXT,"Finding %s %x\n", tmp, IPAddress));
    }

    LockEndpoint( );
    DBG_CODE( instance = NULL );

    if( m_NumQualifiedInstances == 0 ) {

        //
        // Fast path: only the wildcard instance.
        //

        instance = m_WildcardInstance;
        status = NO_ERROR;

    } else {

        //
        // Less-fast path: we'll need to go hunt for it.
        //

        if( pszDomainName == NULL ) {
            pszDomainName = "";
        }

        IIS_ASSOCIATION::InitializeHashContext( &context );

        for( qualifier = FullyQualified ;
             qualifier < NumInstanceQualifiers ;
             qualifier++ ) {

            if( m_QualifiedInstances[qualifier] != NULL ) {

                status = m_QualifiedInstances[qualifier]->LookupDescriptor(
                             IPAddress,
                             pszDomainName,
                             (LPVOID *)&instance,
                             &context
                             );

                if( status == NO_ERROR ) {

                    goto FoundInstance;

                }

                DBG_ASSERT( instance == NULL );

            }

        }

        //
        // If we made it this far, then no qualified instances will
        // take the request, so use the wildcard (if available).
        //

        instance = m_WildcardInstance;

        //
        // Reset the status so that we may continue.
        //

        status = NO_ERROR;

    }

    if( instance == NULL ) {

        status = ERROR_BAD_NET_NAME;

    }

FoundInstance:

    if( status == NO_ERROR ) {

        DBG_ASSERT( instance != NULL );

        if( instance->QueryServerState() != MD_SERVER_STATE_STARTED ) {
            status = ERROR_FILE_NOT_FOUND;
        }

    }

    if( status == NO_ERROR ) {

        //
        // Reference this
        //

        instance->Reference( );
        UnlockEndpoint( );

        //
        // Make sure that we have not exceeded the max
        //

        instance->IncrementCurrentConnections();

        *pbMaxConnExceeded = ( instance->QueryCurrentConnections() >
                               instance->QueryMaxConnections() );

        if( *pbMaxConnExceeded ) {

            IF_DEBUG(ERROR) {
                DBGPRINTF((DBG_CONTEXT,
                  "Too many connected users (%d) max %d, refusing connection\n",
                   instance->QueryCurrentConnections(),
                   instance->QueryMaxConnections() ));
            }
        }

        IF_DEBUG(ENDPOINT) {
            DBGPRINTF((DBG_CONTEXT,
                "Found and referenced instance %p\n",instance));
        }

        return instance;

    }

    UnlockEndpoint();
    SetLastError( status );
    return NULL;

} // IIS_ENDPOINT::FindInstance




PVOID
I_IISAddListenEndpoint(
        IN PATQ_ENDPOINT_CONFIGURATION Configuration,
        IN PVOID                EndpointContext
        )
/*++

    Description:

        Adds a TCPIP ATQ endpoint.

    Arguments:

        Configuration - contains the endpoint configuration
        EndpointContext - context to return during completion

    Returns:

        TRUE if successful,
        FALSE, otherwise

--*/
{
    PVOID   atqEndpoint;
    BOOL    fReturn = FALSE;
 
    IF_DEBUG( INSTANCE ) {
        DBGPRINTF(( DBG_CONTEXT, "I_IISAddListenEndpoint called\n"));
    }

    //
    // Create the endpoint
    //

    atqEndpoint = AtqCreateEndpoint(
                            Configuration,
                            EndpointContext
                            );

    if ( atqEndpoint == NULL ) {
        goto error_exit;
    }

    //
    // Activate the endpoint
    //

    if ( !AtqStartEndpoint(atqEndpoint) ) {
        goto error_exit;
    }

    return (atqEndpoint);

error_exit:

    DWORD dwError = GetLastError();

    DBG_ASSERT( NO_ERROR != dwError );

    if ( atqEndpoint != NULL ) {

        AtqCloseEndpoint( atqEndpoint);
        atqEndpoint = NULL;
    }

    SetLastError(dwError);
    
    return(NULL);

} // I_IISAddListenEndpoint()



VOID
IIS_ENDPOINT::Reference( VOID )
/*++

Routine Description:

    Increments the reference count for the endpoint
    
Arguments:

    None
    
Return Value:

    None
    
--*/
{
    InterlockedIncrement( &m_reference );

    IE_LOG_REF_COUNT( m_reference );
}



typedef struct _ENDPOINT_HACK_PARAM {
    PIIS_ENDPOINT piisEndpoint;
    PVOID         patqEndpoint;
} ENDPOINT_HACK_PARAM, *PENDPOINT_HACK_PARAM;


VOID
WINAPI
EndpointHackFunc( PVOID pv );


VOID
IIS_ENDPOINT::Dereference( )
/*++

Routine Description:

    Decrements the reference count for the endpoint and cleans up if the refcount
    reaches zero.
    
Arguments:

    None
    
Return Value:

    None
    
--*/
{

    ASSERT( m_signature == IIS_ENDPOINT_SIGNATURE );
    ASSERT( m_reference > 0 );

    //
    // Write the trace log BEFORE the decrement operation :(
    // If we write it after the decrement, we will run into potential
    // race conditions in this object getting freed up accidentally
    // by another thread
    //
    // NOTE we write (_cRef - 1) == ref count AFTER decrement happens
    //
    LONG cRefsAfter = (m_reference - 1);
    IE_LOG_REF_COUNT( cRefsAfter );


    if ( InterlockedDecrement( &m_reference ) == 0 ) {
        DWORD dwCookie;
        PENDPOINT_HACK_PARAM pParam;


        DBGPRINTF((DBG_CONTEXT,"deleting endpoint %p\n",this));

        if ( m_atqEndpoint != NULL ) {
            ASSERT( ((PATQ_ENDPOINT)m_atqEndpoint)->Signature == ATQ_ENDPOINT_SIGNATURE );
        
            //
            // Because the ATQ endpoint has an uncounted reference to this object, we can't
            // go away until the ATQ endpoint is closed.  Since it may be bad to block our
            // own thread while waiting for the ATQ endpoint, we create a new thread to do
            // it.
            //
            pParam = new ENDPOINT_HACK_PARAM;
            if (pParam == NULL) {
                goto threadfail;
            }

            pParam->piisEndpoint = this;
            pParam->patqEndpoint = m_atqEndpoint;

            dwCookie = ScheduleWorkItem( EndpointHackFunc, pParam, 0 );
            
            if ( dwCookie == 0 ) {
                delete pParam;
                pParam = NULL;
                goto threadfail;
            }
        } else {
            //
            // If we couldn't activate the endpoint we will not have an ATQ_ENDPOINT
            // to close.  In this case we can clean up immediately
            //
            delete this;
        }

    } else {
        //DBGPRINTF((DBG_CONTEXT,"endpoint deref count %d\n",m_reference));
    }

    return;

threadfail:
    
    if ( AtqCloseEndpoint( m_atqEndpoint ) ) {

        ASSERT( m_signature == IIS_ENDPOINT_SIGNATURE );
            
        delete this;
    } else {
        //
        // There could still be some connections to us, so we can't free the memory.
        // However we have to dereference the IIS_SERVICE, which is waiting for us
        // during shutdown.  Normally this deref occurs during the IIS_ENDPOINT destructor.
        //
        m_service->Dereference();
        m_service = NULL;

        DBGPRINTF((DBG_CONTEXT,
                   "AtqCloseEndpoint returned FALSE! "
                   "Leaking endpoints: iisEndpoint = %p, atqEndpoint = %p\n",
                   this, m_atqEndpoint));
    }
    
}


VOID
WINAPI
EndpointHackFunc(
    PVOID pv
    )
/*++

Routine Description:

    This function is a work item scheduled by IIS_ENDPOINT::Dereference.  When the IIS_ENDPOINT
    refcount hits zero, there is still a reference to the structure from the ATQ_ENDPOINT.
    We call AtqCloseEndpoint, which returns when the reference is gone, and then clean up
    when it is safe to do so.
    
Arguments:

    pv - a parameter block containing pointers to the IIS_ENDPOINT and it's ATQ_ENDPOINT.
    
Return Value:

    None
    
--*/
{
    PENDPOINT_HACK_PARAM pParam = (PENDPOINT_HACK_PARAM) pv;
    
    ASSERT( pParam->piisEndpoint->CheckSignature(IIS_ENDPOINT_SIGNATURE) );
    ASSERT( ((PATQ_ENDPOINT)pParam->patqEndpoint)->Signature == ATQ_ENDPOINT_SIGNATURE );

    IF_DEBUG(ENDPOINT) {
        DBGPRINTF((DBG_CONTEXT, "EndpointHackFunc: iis=%p atq=%p\n", 
                   pParam->piisEndpoint, pParam->patqEndpoint));
    }

    //
    // if AtqCloseEndpoint fails we can't clean up, because someone could
    // still have a pointer to us!
    //
    if ( AtqCloseEndpoint( pParam->patqEndpoint ) ) {

        ASSERT( pParam->piisEndpoint->CheckSignature(IIS_ENDPOINT_SIGNATURE) );
            
        delete pParam->piisEndpoint;
    } else {
        //
        // There could still be some connections to us, so we can't free the memory.
        // However we have to dereference the IIS_SERVICE, which is waiting for us
        // during shutdown.  Normally this deref occurs during the IIS_ENDPOINT destructor.
        //
        pParam->piisEndpoint->QueryService()->Dereference();
        pParam->piisEndpoint->SetService( NULL );

        DBGPRINTF((DBG_CONTEXT,
                   "AtqCloseEndpoint returned FALSE! "
                   "Leaking endpoints: iisEndpoint = %p, atqEndpoint = %p\n",
                   pParam->piisEndpoint, pParam->patqEndpoint));
    }
    
    delete pParam;    
}

BOOL
InitializeEndpointUtilities(
    VOID
)
/*++

Routine Description:

    Called during infocomm initialization.  This sets up a global debug trace
    log object

Arguments:

    None
    
Return Value:

    TRUE if successful
    
--*/
{
#if IE_REF_TRACKING
    if ( g_pDbgIERefTraceLog == NULL ) 
    {
        g_pDbgIERefTraceLog = CreateRefTraceLog( C_IIS_ENDP_REFTRACES, 0 );
        return g_pDbgIERefTraceLog != NULL;
    }
#endif
    return TRUE;
}

BOOL
TerminateEndpointUtilities(
    VOID
)
/*++

Routine Description:

    Called during infocomm cleanup.  This cleans up the global debug trace
    log object 

Arguments:

    None
    
Return Value:

    TRUE if successful
    
--*/
{
#if IE_REF_TRACKING
    if ( g_pDbgIERefTraceLog )
    {
         DestroyRefTraceLog( g_pDbgIERefTraceLog );
         g_pDbgIERefTraceLog = NULL;
    }
#endif
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\iisbind.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    iisbind.cxx

Abstract:

    This module implements the IIS_SERVER_BINDING class.

Author:

    Keith Moore (keithmo)        16-Jan-1997

Revision History:

--*/


#include "tcpdllp.hxx"
#pragma hdrstop
#include <iisbind.hxx>


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//


IIS_SERVER_BINDING::IIS_SERVER_BINDING(
    IN DWORD IpAddress,
    IN USHORT IpPort,
    IN const CHAR * HostName,
    IN PIIS_ENDPOINT Endpoint
    ) :
    m_IpAddress( IpAddress ),
    m_IpPort( IpPort ),
    m_HostName( HostName ),
    m_Endpoint( Endpoint )
/*++

Routine Description:

    IIS_SERVER_BINDING constructor.

Arguments:

    IpAddress - The IP address for this binding. May be INADDR_ANY.

    IpPort - The IP port for this binding. Required.

    HostName - The host name for this binding. May be empty ("").

    Endpoint - The IIS_ENDPOINT to associate with this binding.

Return Value:

    None.

--*/
{

    //
    // Sanity check.
    //

    DBG_ASSERT( HostName != NULL );
    DBG_ASSERT( Endpoint != NULL );

}   // IIS_SERVER_BINDING::IIS_SERVER_BINDING


IIS_SERVER_BINDING::~IIS_SERVER_BINDING()
/*++

Routine Description:

    IIS_SERVER_BINDING destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{

    //
    // This space intentionally left blank.
    //

}   // IIS_SERVER_BINDING::~IIS_SERVER_BINDING()


DWORD
IIS_SERVER_BINDING::ParseDescriptor(
    IN const CHAR * Descriptor,
    OUT LPDWORD IpAddress,
    OUT PUSHORT IpPort,
    OUT const CHAR ** HostName
    )
/*++

Routine Description:

    Parses a descriptor string of the form "ip_address:ip_port:host_name"
    into its component parts.

Arguments:

    Descriptor - The descriptor string.

    IpAddress - Receives the IP address component if present, or
        INADDR_ANY if not.

    IpPort - Recieves the IP port component.

    HostName - Receives a pointer to the host name component.

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    const CHAR * ipAddressString;
    const CHAR * ipPortString;
    const CHAR * hostNameString;
    const CHAR * end;
    CHAR temp[sizeof("123.123.123.123")];
    INT length;
    LONG tempPort;

    //
    // Sanity check.
    //

    DBG_ASSERT( Descriptor != NULL );
    DBG_ASSERT( IpAddress != NULL );
    DBG_ASSERT( IpPort != NULL );
    DBG_ASSERT( HostName != NULL );

    //
    // Find the various parts of the descriptor;
    //

    ipAddressString = Descriptor;

    ipPortString = strchr( ipAddressString, ':' );

    if( ipPortString == NULL ) {
        goto fatal;
    }

    ipPortString++;

    hostNameString = strchr( ipPortString, ':' );

    if( hostNameString == NULL ) {
        goto fatal;
    }

    hostNameString++;

    //
    // Validate and parse the IP address portion.
    //

    if( *ipAddressString == ':' ) {

        *IpAddress = INADDR_ANY;

    } else {

        length = DIFF(ipPortString - ipAddressString) - 1;

        if( length >= sizeof(temp) ) {
            goto fatal;
        }

        memcpy(
            temp,
            ipAddressString,
            length
            );

        temp[length] = '\0';

        *IpAddress = (DWORD)inet_addr( temp );

        if( *IpAddress == INADDR_NONE ) {
            goto fatal;
        }

    }

    //
    // Validate and parse the port.
    //

    if( *ipPortString == ':' ) {
        goto fatal;
    }

    length = DIFF(hostNameString - ipPortString);

    if( length >= sizeof(temp) ) {
        goto fatal;
    }

    memcpy(
        temp,
        ipPortString,
        length
        );

    temp[length] = '\0';

    tempPort = strtol(
                   temp,
                   (CHAR **)&end,
                   0
                   );

    if( tempPort <= 0 || tempPort > 0xFFFF ) {
        goto fatal;
    }

    if( *end != ':' ) {
        goto fatal;
    }

    *IpPort = (USHORT)tempPort;

    //
    // Validate and parse the host name.
    //

    if( *hostNameString == ' ' || *hostNameString == ':' ) {
        goto fatal;
    }

    *HostName = hostNameString;

    return NO_ERROR;

fatal:

    return ERROR_INVALID_PARAMETER;

}   // IIS_SERVER_BINDING::ParseDescriptor


DWORD
IIS_SERVER_BINDING::Compare(
    IN const CHAR * Descriptor,
    OUT LPBOOL Result
    )
/*++

Routine Description:

    Compares the current binding with the descriptor string.

Arguments:

    Descriptor - The descriptor to compare against.

    Result - Receives the result of the comparison (TRUE if they match,
        FALSE otherwise).

Return Value:

    DWORD - Completion status. 0 if successful, !0 otherwise.

--*/
{

    DWORD ipAddress;
    USHORT ipPort;
    const CHAR * hostName;
    DWORD status;

    //
    // Sanity check.
    //

    DBG_ASSERT( Descriptor != NULL );
    DBG_ASSERT( Result != NULL );

    //
    // Parse the descriptor.
    //

    status = ParseDescriptor(
                 Descriptor,
                 &ipAddress,
                 &ipPort,
                 &hostName
                 );

    if( status == NO_ERROR ) {

        *Result = Compare(
                      ipAddress,
                      ipPort,
                      hostName
                      );

    }

    return status;

}   // IIS_SERVER_BINDING::Compare


BOOL
IIS_SERVER_BINDING::Compare(
    IN DWORD IpAddress,
    IN USHORT IpPort,
    IN const CHAR * HostName
    )
/*++

Routine Description:

    Compares the current binding with the specified IP address, IP port,
    and host name.

Arguments:

    IpAddress - The IP address to compare against.

    IpPort - The IP port to compare against.

    HostName - The host name to compare against.

Return Value:

    BOOL - TRUE if they match, FALSE otherwise.

--*/
{

    //
    // Sanity check.
    //

    DBG_ASSERT( HostName != NULL );

    //
    // Compare the components.
    //

    if( IpAddress == QueryIpAddress() &&
        IpPort == QueryIpPort() &&
        !_stricmp(
            HostName,
            QueryHostName()
            ) ) {

        return TRUE;

    }

    return FALSE;

}   // IIS_SERVER_BINDING::Compare


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\infocomm\common\iissvc.cxx ===
/*++


   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        iissvc.cxx

   Abstract:

        Defines the IIS_SERVICE class

    FILE HISTORY:
           MuraliK       15-Nov-1994 Created.
           CezaryM       11-May-2000 Added events:
                           started/stopped/paused/resumed
--*/



#include "tcpdllp.hxx"

#include <rpc.h>
#include <tsunami.hxx>
#include <iistypes.hxx>
#include <iisendp.hxx>
#include "inetreg.h"
#include "tcpcons.h"
#include "apiutil.h"
#include <imd.h>
#include <ole2.h>
#include <inetsvcs.h>
#include <issched.hxx>

#include "reftrce2.h"

/************************************************************
 *    Symbolic Constants
 ************************************************************/


//
//  What we assume to be the last winsock error
//
#define WSA_MAX_ERROR   (WSABASEERR + 3000)

//
//  For socket errors, we return the numeric socket error
//

#define SOCK_ERROR_STR_W        L"Socket error %d"
#define SOCK_ERROR_STR_A        "Socket error %d"

#define LM_PREFIX               "/" IIS_MD_LOCAL_MACHINE_PATH "/"
#define LM_PREFIX_CCH           sizeof(LM_PREFIX) - sizeof(CHAR)


//
// The time indicating how long it will take for IIS to start up a service
//  <-- Service controller will wait for this duration before telling user
//  that there is some problem.
// For PDC 1996, a hacked value of 90 seconds used.
// The new value of 30 seconds is plugged in on 7/7/97
//

# define IIS_SERVICE_START_WAIT_HINT_SECONDS            (30) // 30 seconds
# define IIS_SERVICE_START_WAIT_HINT                    (IIS_SERVICE_START_WAIT_HINT_SECONDS * 1000) // 30 seconds
# define IIS_SERVICE_START_WAIT_HINT_EXTENDED           (IIS_SERVICE_START_WAIT_HINT * 4) // 2 minutes

# define IIS_SERVICE_START_INDICATOR_INTERVAL           (IIS_SERVICE_START_WAIT_HINT_EXTENDED / 2) // 1 minute
# define IIS_SERVICE_START_INDICATOR_INTERVAL_SECONDS   (IIS_SERVICE_START_INDICATOR_INTERVAL / 1000)

# define MAX_NUMBER_OF_START_HINT_REPETITIONS 200  // 50 minutes

//
// MS_SERVICE_SHUTDOWN_INDICATOR_TIME_INTERVAL
//  - specifies the time interval in milli-seconds for the interval
//    to notify the service controller that a service is shutting down.
//
# define MS_SERVICE_SHUTDOWN_INDICATOR_TIME_INTERVAL \
            (SERVICE_STOP_WAIT_HINT/2)



#ifdef _KNFOCOMM
//
//  List of "known" services that use knfocomm -
//  This is needed to break deadlocks between infocomm & knfocomm..
//

static char* rgKnfoServices[] = {
    TEXT("pop3svc"),
    TEXT("imap4svc")
};

static DWORD gNumKnfoServices = 3;
#endif // _KNFOCOMM


//
//  Deferred metabase change notify
//

VOID
WINAPI
DeferredMDChange(
    PVOID pv
    );

BOOL
I_StopInstanceEndpoint( PVOID                 pvContext1,
                        PVOID                 pvContext2,
                        IIS_SERVER_INSTANCE * pInstance );

VOID
WINAPI
ServiceShutdownIndicator( VOID * pSvcContext);


//
// Critical section used for locking the list of IIS_SERVICE objects
//      during insertion and deletion
//

CRITICAL_SECTION  IIS_SERVICE::sm_csLock;
LIST_ENTRY        IIS_SERVICE::sm_ServiceInfoListHead;
BOOL              IIS_SERVICE::sm_fInitialized = FALSE;
PISRPC            IIS_SERVICE::sm_isrpc = NULL;
IUnknown *        IIS_SERVICE::sm_MDObject = NULL;
IUnknown *        IIS_SERVICE::sm_MDNseObject = NULL;

#if SERVICE_REF_TRACKING
//
//  Ref count trace log size
//
#define C_SERVICE_REFTRACES         400
#define C_LOCAL_SERVICE_REFTRACES    40
#endif // SERVICE_REF_TRACKING

//
PTRACE_LOG IIS_SERVICE::sm_pDbgRefTraceLog = NULL;


/************************************************************
 *    Functions
 ************************************************************/

DWORD
InitMetadataDCom(
    PVOID Context,
    PVOID NseContext
    );

//
// LOCAL Functions
//

extern MIME_MAP * g_pMimeMap;
#define MAX_ADDRESSES_SUPPORTED           20
#define SIZEOF_IP_SEC_LIST( IPList )      (sizeof(INET_INFO_IP_SEC_LIST) + \
                                           (IPList)->cEntries *        \
                                           sizeof(INET_INFO_IP_SEC_ENTRY))


/************************************************************
 *    Functions
 ************************************************************/

//
// These 2 functions cannot be inline as they reference sm_csLock
// which is a static non-exported member of IIS_SERVICE
// Having them inline causes build to break when compiled with /Od
//

VOID
IIS_SERVICE::AcquireGlobalLock( )
{
    EnterCriticalSection(&sm_csLock);
}


VOID
IIS_SERVICE::ReleaseGlobalLock( )
{
    LeaveCriticalSection(&sm_csLock);
}


IIS_SERVICE::IIS_SERVICE(
    IN  LPCSTR                           pszServiceName,
    IN  LPCSTR                           pszModuleName,
    IN  LPCSTR                           pszRegParamKey,
    IN  DWORD                            dwServiceId,
    IN  ULONGLONG                        SvcLocId,
    IN  BOOL                             MultipleInstanceSupport,
    IN  DWORD                            cbAcceptExRecvBuffer,
    IN  ATQ_CONNECT_CALLBACK             pfnConnect,
    IN  ATQ_COMPLETION                   pfnConnectEx,
    IN  ATQ_COMPLETION                   pfnIoCompletion
    )
/*++
    Description:

        Contructor for IIS_SERVICE class.
        This constructs a new service info object for the service specified.

    Arguments:

        pszServiceName - name of the service to be created.

        pszModuleName - name of the module for loading string resources.

        pszRegParamKey - fully qualified name of the registry key that
            contains the common service data for this server

        dwServiceId - DWORD containing the bitflag id for service.

        SvcLocId - Service locator id

        MultipleInstanceSupport - Does this service support multiple instances

        cbAcceptExRecvBuffer, pfnConnect, pfnConnectEx, pfnIoCompletion
             - parameters for ATQ Endpoint

    On success it initializes all the members of the object,
     inserts itself to the global list of service info objects and
     returns with success.

    Note:
        The caller of this function should check the validity by
        invoking the member function IsValid() after constructing
        this object.

--*/
:
    m_state               ( BlockStateInvalid),  // state is invalid at start
    m_reference           ( 1),
    m_pDbgRefTraceLog     ( NULL),
    m_nInstance           ( 0),
    m_nStartedInstances   ( 0),
    m_maxInstanceId       ( 1),
    m_fIpcStarted         ( FALSE ),
    m_fSvcLocationDone    ( FALSE ),
    m_fSocketsInitialized ( FALSE ),
    m_fEnableSvcLocation  ( INETA_DEF_ENABLE_SVC_LOCATION ),
    m_fMultiInstance      ( MultipleInstanceSupport ),
    m_SvcLocId            ( SvcLocId ),
    m_dwServiceId         ( dwServiceId),
    m_strServiceName      ( pszServiceName),
    m_strServiceComment   ( ),
    m_strParametersKey    ( pszRegParamKey),
    m_hsvcStatus          ( NULL_SERVICE_STATUS_HANDLE),
    m_pMimeMap            ( g_pMimeMap),
    m_strModuleName       ( pszModuleName),
    m_hModule             ( NULL),
    m_dwDownlevelInstance ( 1),
    m_EventLog            ( pszServiceName ),
    m_fIsDBCS             ( FALSE ),
    m_hShutdownEvent      ( NULL),
    m_dwShutdownScheduleId( 0),
    m_nShutdownIndicatorCalls  (0),
    m_dwStartUpIndicatorCalls  (0),
    m_dwClientStartActivityIndicator (0),
    m_dwNextSCMUpdateTime ( 0),
    m_hPendingShutdownEvent (NULL),
    //
    // Initialize ATQ callbacks
    //
    m_pfnConnect         ( pfnConnect),
    m_pfnConnectEx       ( pfnConnectEx),
    m_pfnIoCompletion    ( pfnIoCompletion),
    m_cbRecvBuffer       ( cbAcceptExRecvBuffer)
{
    MB    mb( (IMDCOM*) QueryMDObject() );
    DWORD errInit = NO_ERROR;

    //
    // Initialize endpoint list
    //

    InitializeListHead( &m_EndpointListHead );
    InitializeListHead( &m_InstanceListHead );

    INITIALIZE_CRITICAL_SECTION( &m_lock );

#if SERVICE_REF_TRACKING
    m_pDbgRefTraceLog = CreateRefTraceLog(C_LOCAL_SERVICE_REFTRACES, 0);
#endif // SERVICE_REF_TRACKING

    //
    //  Initialize the service metapath
    //

    strcpy( m_achServiceMetaPath, "/" IIS_MD_LOCAL_MACHINE_PATH "/" );
    strcat( m_achServiceMetaPath, QueryServiceName() );
    strcat( m_achServiceMetaPath, "/" );

    DBG_ASSERT( strlen(m_achServiceMetaPath) < sizeof(m_achServiceMetaPath) );

    //
    //  Read the downlevel instance
    //

    if ( mb.Open( QueryMDPath() ) )
    {
        mb.GetDword( "",
                     MD_DOWNLEVEL_ADMIN_INSTANCE,
                     IIS_MD_UT_SERVER,
                     0xffffffff,                // default value
                     &m_dwDownlevelInstance
                     );
        mb.Close( );
    }
    else
    {
        errInit = GetLastError();
    