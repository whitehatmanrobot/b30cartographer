ORD ExternalRelease();

	// implementation helpers
	LPUNKNOWN GetInterface(const void FAR*);
	LPUNKNOWN QueryAggregates(const void FAR*);

	// advanced overrideables for implementation
	virtual BOOL OnCreateAggregates();
	virtual LPUNKNOWN GetInterfaceHook(const void FAR*);

	// OLE automation implementation
protected:
	DWORD m_xDispatch;  // place-holder for IDispatch vtable

	// IDispatch implementation helpers
	void GetStandardProp(AFX_DISPMAP_ENTRY FAR* pEntry,
		LPVOID pvarResult, UINT FAR* puArgErr);
	long SetStandardProp(AFX_DISPMAP_ENTRY FAR* pEntry,
		LPVOID pdispparams, UINT FAR* puArgErr);
	long InvokeHelper(AFX_DISPMAP_ENTRY FAR* pEntry, WORD wFlags,
		LPVOID pvarResult, LPVOID pdispparams, UINT FAR* puArgErr);
	AFX_DISPMAP_ENTRY FAR* GetDispEntry(LONG memid);
	static LONG MemberIDFromName(AFX_DISPMAP FAR* pDispMap, LPCSTR lpszName);
	friend class COleDispatchImpl;
};

class CCmdUI        // simple helper class
{
public:
// Attributes
	UINT m_nID;
	UINT m_nIndex;          // menu item or other index

	// if a menu item
	CMenu* m_pMenu;         // NULL if not a menu
	CMenu* m_pSubMenu;      // sub containing menu item
							// if a popup sub menu - ID is for first in popup

	// if from some other window
	CWnd* m_pOther;         // NULL if a menu or not a CWnd

// Operations to do in ON_UPDATE_COMMAND_UI
	virtual void Enable(BOOL bOn = TRUE);
	virtual void SetCheck(int nCheck = 1);   // 0, 1 or 2 (indeterminate)
	virtual void SetRadio(BOOL bOn = TRUE);
	virtual void SetText(LPCSTR lpszText);

// Advanced operation
	void ContinueRouting();

// Implementation
	CCmdUI();
	BOOL m_bEnableChanged;
	BOOL m_bContinueRouting;
	UINT m_nIndexMax;       // last + 1 for iterating m_nIndex

	CMenu* m_pParentMenu;   // NULL if parent menu not easily determined
							//  (probably a secondary popup menu)

	void DoUpdate(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);
};

// special CCmdUI derived classes are used for other UI paradigms
//  like toolbar buttons and status indicators

// pointer to afx_msg member function
#ifndef AFX_MSG_CALL
#define AFX_MSG_CALL PASCAL
#endif
typedef void (AFX_MSG_CALL CCmdTarget::*AFX_PMSG)(void);

struct AFX_DISPMAP_ENTRY
{
	char szName[32];        // member/property name
	long lDispID;           // DISPID (may be DISPID_UNKNOWN)
	BYTE pbParams[16];      // member parameter description
	WORD vt;                // return value type / or type of property
	AFX_PMSG pfn;           // normal member On<membercall> or, OnGet<property>
	AFX_PMSG pfnSet;        // special member for OnSet<property>
	size_t nPropOffset;     // property offset
};

/////////////////////////////////////////////////////////////////////////////
// CWnd implementation

// structures (see afxext.h)
struct CCreateContext;      // context for creating things
struct CPrintInfo;          // print preview customization info

struct AFX_MSGMAP_ENTRY
{
	UINT nMessage;   // windows message or control notification code
	UINT nID;        // control ID (or 0 for windows messages)
	UINT nSig;       // signature type (action) or near pointer to message #
	AFX_PMSG pfn;    // routine to call (or special value)
};

/////////////////////////////////////////////////////////////////////////////
// CWnd - a Microsoft Windows application window

class COleDropTarget;   // for more information see AFXOLE.H

class CWnd : public CCmdTarget
{
	DECLARE_DYNCREATE(CWnd)
protected:
	static const MSG* PASCAL GetCurrentMessage();

// Attributes
public:
	HWND m_hWnd;            // must be first data member

	HWND GetSafeHwnd() const;
	DWORD GetStyle() const;
	DWORD GetExStyle() const;

	CWnd* GetOwner() const;
	void SetOwner(CWnd* pOwnerWnd);

// Constructors and other creation
	CWnd();

	static CWnd* PASCAL FromHandle(HWND hWnd);
	static CWnd* PASCAL FromHandlePermanent(HWND hWnd);    // INTERNAL USE
	static void PASCAL DeleteTempMap();
	BOOL Attach(HWND hWndNew);
	HWND Detach();
	BOOL SubclassWindow(HWND hWnd);
	BOOL SubclassDlgItem(UINT nID, CWnd* pParent);
			// for dynamic subclassing of windows control

protected: // This CreateEx() wraps CreateWindowEx - dangerous to use directly
	BOOL CreateEx(DWORD dwExStyle, LPCSTR lpszClassName,
		LPCSTR lpszWindowName, DWORD dwStyle,
		int x, int y, int nWidth, int nHeight,
		HWND hWndParent, HMENU nIDorHMenu, LPSTR lpParam = NULL);

private:
	CWnd(HWND hWnd);    // just for special initialization

public:
	// for child windows, views, panes etc
	virtual BOOL Create(LPCSTR lpszClassName,
		LPCSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL);

	virtual BOOL DestroyWindow();

	// special pre-creation and window rect adjustment hooks
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);

	// Advanced: virtual AdjustWindowRect
	enum AdjustType { adjustBorder = 0, adjustOutside = 1 };
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);

// Window tree access
	int GetDlgCtrlID() const;
		// return window ID, for child windows only
	CWnd* GetDlgItem(int nID) const;
		// get immediate child with given ID
	CWnd* GetDescendantWindow(int nID, BOOL bOnlyPerm = FALSE) const;
		// like GetDlgItem but recursive
	void SendMessageToDescendants(UINT message, WPARAM wParam = 0,
		LPARAM lParam = 0, BOOL bDeep = TRUE, BOOL bOnlyPerm = FALSE);
	CFrameWnd* GetParentFrame() const;

// Message Functions
	LRESULT SendMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0);
	BOOL PostMessage(UINT message, WPARAM wParam = 0, LPARAM lParam = 0);

// Window Text Functions
	void SetWindowText(LPCSTR lpszString);
	int GetWindowText(LPSTR lpszStringBuf, int nMaxCount) const;
	int GetWindowTextLength() const;
	void GetWindowText(CString& rString) const;
	void SetFont(CFont* pFont, BOOL bRedraw = TRUE);
	CFont* GetFont() const;

// CMenu Functions - non-Child windows only
	CMenu* GetMenu() const;
	BOOL SetMenu(CMenu* pMenu);
	void DrawMenuBar();
	CMenu* GetSystemMenu(BOOL bRevert) const;
	BOOL HiliteMenuItem(CMenu* pMenu, UINT nIDHiliteItem, UINT nHilite);

// Window Size and Position Functions
	BOOL IsIconic() const;
	BOOL IsZoomed() const;
	void MoveWindow(int x, int y, int nWidth, int nHeight,
				BOOL bRepaint = TRUE);
	void MoveWindow(LPCRECT lpRect, BOOL bRepaint = TRUE);

	static const CWnd AFXAPI_DATA wndTop; // SetWindowPos's pWndInsertAfter
	static const CWnd AFXAPI_DATA wndBottom; // SetWindowPos's pWndInsertAfter
#if (WINVER >= 0x030a)
	static const CWnd AFXAPI_DATA wndTopMost; // SetWindowPos pWndInsertAfter
	static const CWnd AFXAPI_DATA wndNoTopMost; // SetWindowPos pWndInsertAfter
#endif

	BOOL SetWindowPos(const CWnd* pWndInsertAfter, int x, int y,
				int cx, int cy, UINT nFlags);
	UINT ArrangeIconicWindows();
	void BringWindowToTop();
	void GetWindowRect(LPRECT lpRect) const;
	void GetClientRect(LPRECT lpRect) const;

#if (WINVER >= 0x030a)
	BOOL GetWindowPlacement(WINDOWPLACEMENT FAR* lpwndpl) const;
	BOOL SetWindowPlacement(const WINDOWPLACEMENT FAR* lpwndpl);
#endif

// Coordinate Mapping Functions
	void ClientToScreen(LPPOINT lpPoint) const;
	void ClientToScreen(LPRECT lpRect) const;
	void ScreenToClient(LPPOINT lpPoint) const;
	void ScreenToClient(LPRECT lpRect) const;
#if (WINVER >= 0x030a)
	void MapWindowPoints(CWnd* pwndTo, LPPOINT lpPoint, UINT nCount) const;
	void MapWindowPoints(CWnd* pwndTo, LPRECT lpRect) const;
#endif

// Update/Painting Functions
	CDC* BeginPaint(LPPAINTSTRUCT lpPaint);
	void EndPaint(LPPAINTSTRUCT lpPaint);
	CDC* GetDC();
	CDC* GetWindowDC();
	int ReleaseDC(CDC* pDC);

	void UpdateWindow();
	void SetRedraw(BOOL bRedraw = TRUE);
	BOOL GetUpdateRect(LPRECT lpRect, BOOL bErase = FALSE);
	int GetUpdateRgn(CRgn* pRgn, BOOL bErase = FALSE);
	void Invalidate(BOOL bErase = TRUE);
	void InvalidateRect(LPCRECT lpRect, BOOL bErase = TRUE);
	void InvalidateRgn(CRgn* pRgn, BOOL bErase = TRUE);
	void ValidateRect(LPCRECT lpRect);
	void ValidateRgn(CRgn* pRgn);
	BOOL ShowWindow(int nCmdShow);
	BOOL IsWindowVisible() const;
	void ShowOwnedPopups(BOOL bShow = TRUE);

#if (WINVER >= 0x030a)
	CDC* GetDCEx(CRgn* prgnClip, DWORD flags);
	BOOL LockWindowUpdate();
	BOOL RedrawWindow(LPCRECT lpRectUpdate = NULL,
		CRgn* prgnUpdate = NULL,
		UINT flags = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE);
	BOOL EnableScrollBar(int nSBFlags, UINT nArrowFlags = ESB_ENABLE_BOTH);
#endif

// Timer Functions
	UINT SetTimer(UINT nIDEvent, UINT nElapse,
					void (CALLBACK EXPORT* lpfnTimer)(HWND, UINT, UINT, DWORD));
	BOOL KillTimer(int nIDEvent);

// Window State Functions
	BOOL IsWindowEnabled() const;
	BOOL EnableWindow(BOOL bEnable = TRUE);

	// This active window applies only to top-most (i.e. Frame windows)
	static CWnd* PASCAL GetActiveWindow();
	CWnd* SetActiveWindow();

	// Capture and Focus apply to all windows
	static CWnd* PASCAL GetCapture();
	CWnd* SetCapture();
	static CWnd* PASCAL GetFocus();
	CWnd* SetFocus();

	static CWnd* PASCAL GetDesktopWindow();

// Obsolete and non-portable APIs - not recommended for new code
	void CloseWindow();
	BOOL OpenIcon();
	CWnd* SetSysModalWindow();
	static CWnd* PASCAL GetSysModalWindow();

// Dialog-Box Item Functions
// (NOTE: Dialog-Box Items/Controls are not necessarily in dialog boxes!)
	void CheckDlgButton(int nIDButton, UINT nCheck);
	void CheckRadioButton(int nIDFirstButton, int nIDLastButton,
					int nIDCheckButton);
	int GetCheckedRadioButton(int nIDFirstButton, int nIDLastButton);
	int DlgDirList(LPSTR lpPathSpec, int nIDListBox,
					int nIDStaticPath, UINT nFileType);
	int DlgDirListComboBox(LPSTR lpPathSpec, int nIDComboBox,
					int nIDStaticPath, UINT nFileType);
	BOOL DlgDirSelect(LPSTR lpString, int nIDListBox);
	BOOL DlgDirSelectComboBox(LPSTR lpString, int nIDComboBox);

	UINT GetDlgItemInt(int nID, BOOL* lpTrans = NULL,
					BOOL bSigned = TRUE) const;
	int GetDlgItemText(int nID, LPSTR lpStr, int nMaxCount) const;
	CWnd* GetNextDlgGroupItem(CWnd* pWndCtl, BOOL bPrevious = FALSE) const;

	CWnd* GetNextDlgTabItem(CWnd* pWndCtl, BOOL bPrevious = FALSE) const;
	UINT IsDlgButtonChecked(int nIDButton) const;
	LRESULT SendDlgItemMessage(int nID, UINT message,
					WPARAM wParam = 0, LPARAM lParam = 0);
	void SetDlgItemInt(int nID, UINT nValue, BOOL bSigned = TRUE);
	void SetDlgItemText(int nID, LPCSTR lpszString);

// Scrolling Functions
	int GetScrollPos(int nBar) const;
	void GetScrollRange(int nBar, LPINT lpMinPos, LPINT lpMaxPos) const;
	void ScrollWindow(int xAmount, int yAmount,
					LPCRECT lpRect = NULL,
					LPCRECT lpClipRect = NULL);
	int SetScrollPos(int nBar, int nPos, BOOL bRedraw = TRUE);
	void SetScrollRange(int nBar, int nMinPos, int nMaxPos,
			BOOL bRedraw = TRUE);
	void ShowScrollBar(UINT nBar, BOOL bShow = TRUE);
	void EnableScrollBarCtrl(int nBar, BOOL bEnable = TRUE);
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
			// return sibling scrollbar control (or NULL if none)

#if (WINVER >= 0x030a)
	int ScrollWindowEx(int dx, int dy,
				LPCRECT lpRectScroll, LPCRECT lpRectClip,
				CRgn* prgnUpdate, LPRECT lpRectUpdate, UINT flags);
#endif


// Window Access Functions
	CWnd* ChildWindowFromPoint(POINT point) const;
	static CWnd* PASCAL FindWindow(LPCSTR lpszClassName, LPCSTR lpszWindowName);
	CWnd* GetNextWindow(UINT nFlag = GW_HWNDNEXT) const;
	CWnd* GetTopWindow() const;

	CWnd* GetWindow(UINT nCmd) const;
	CWnd* GetLastActivePopup() const;

	BOOL IsChild(const CWnd* pWnd) const;
	CWnd* GetParent() const;
	CWnd* SetParent(CWnd* pWndNewParent);
	static CWnd* PASCAL WindowFromPoint(POINT point);

// Alert Functions
	BOOL FlashWindow(BOOL bInvert);
	int MessageBox(LPCSTR lpszText, LPCSTR lpszCaption = NULL,
			UINT nType = MB_OK);

// Clipboard Functions
	BOOL ChangeClipboardChain(HWND hWndNext);
	HWND SetClipboardViewer();
	BOOL OpenClipboard();
	static CWnd* PASCAL GetClipboardOwner();
	static CWnd* PASCAL GetClipboardViewer();
#if (WINVER >= 0x030a)
	static CWnd* PASCAL GetOpenClipboardWindow();
#endif

// Caret Functions
	void CreateCaret(CBitmap* pBitmap);
	void CreateSolidCaret(int nWidth, int nHeight);
	void CreateGrayCaret(int nWidth, int nHeight);
	static CPoint PASCAL GetCaretPos();
	static void PASCAL SetCaretPos(POINT point);
	void HideCaret();
	void ShowCaret();

// Drag-Drop Functions
#if (WINVER >= 0x030a)
	void DragAcceptFiles(BOOL bAccept = TRUE);
#endif

// Dialog Data support
public:
	BOOL UpdateData(BOOL bSaveAndValidate = TRUE);
			// data wnd must be same type as this

// Help Command Handlers
	afx_msg void OnHelp();          // F1 (uses current context)
	afx_msg void OnHelpIndex();     // ID_HELP_INDEX, ID_DEFAULT_HELP
	afx_msg void OnHelpUsing();     // ID_HELP_USING
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

// Layout and other functions
public:
	enum RepositionFlags
		{ reposDefault = 0, reposQuery = 1, reposExtra = 2 };
	void RepositionBars(UINT nIDFirst, UINT nIDLast, UINT nIDLeftOver,
		UINT nFlag = reposDefault, LPRECT lpRectParam = NULL,
		LPCRECT lpRectClient = NULL);

	void UpdateDialogControls(CCmdTarget* pTarget, BOOL bDisableIfNoHndler);

// Window-Management message handler member functions
protected:
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
	afx_msg void OnCancelMode();
	afx_msg void OnChildActivate();
	afx_msg void OnClose();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);

	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);

	afx_msg void OnDestroy();
	afx_msg void OnEnable(BOOL bEnable);
	afx_msg void OnEndSession(BOOL bEnding);
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnGetMinMaxInfo(MINMAXINFO FAR* lpMMI);
	afx_msg void OnIconEraseBkgnd(CDC* pDC);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg LRESULT OnMenuChar(UINT nChar, UINT nFlags, CMenu* pMenu);
	afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
	afx_msg void OnMove(int x, int y);
	afx_msg void OnPaint();
	afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg BOOL OnQueryEndSession();
	afx_msg BOOL OnQueryNewPalette();
	afx_msg BOOL OnQueryOpen();
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnSize(UINT nType, int cx, int cy);
#if (WINVER >= 0x030a)
	afx_msg void OnWindowPosChanging(WINDOWPOS FAR* lpwndpos);
	afx_msg void OnWindowPosChanged(WINDOWPOS FAR* lpwndpos);
#endif

// Nonclient-Area message handler member functions
	afx_msg BOOL OnNcActivate(BOOL bActive);
	afx_msg void OnNcCalcSize(BOOL bCalcValidRects, NCCALCSIZE_PARAMS FAR* lpncsp);
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnNcDestroy();
	afx_msg UINT OnNcHitTest(CPoint point);
	afx_msg void OnNcLButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcLButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcMButtonUp(UINT nHitTest, CPoint point);
	afx_msg void OnNcMouseMove(UINT nHitTest, CPoint point);
	afx_msg void OnNcPaint();
	afx_msg void OnNcRButtonDblClk(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonDown(UINT nHitTest, CPoint point);
	afx_msg void OnNcRButtonUp(UINT nHitTest, CPoint point);

// System message handler member functions
#if (WINVER >= 0x030a)
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg void OnPaletteIsChanging(CWnd* pRealizeWnd);
#endif
	afx_msg void OnSysChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnSysDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnSysKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnCompacting(UINT nCpuTime);
	afx_msg void OnDevModeChange(LPSTR lpDeviceName);
	afx_msg void OnFontChange();
	afx_msg void OnPaletteChanged(CWnd* pFocusWnd);
	afx_msg void OnSpoolerStatus(UINT nStatus, UINT nJobs);
	afx_msg void OnSysColorChange();
	afx_msg void OnTimeChange();
	afx_msg void OnWinIniChange(LPCSTR lpszSection);

// Input message handler member functions
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnDeadChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnKeyUp(UINT nChar, UINT nRepCnt, UINT nFlags);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnMButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnMButtonUp(UINT nFlags, CPoint point);
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg void OnTimer(UINT nIDEvent);

// Initialization message handler member functions
	afx_msg void OnInitMenu(CMenu* pMenu);
	afx_msg void OnInitMenuPopup(CMenu* pPopupMenu, UINT nIndex, BOOL bSysMenu);

// Clipboard message handler member functions
	afx_msg void OnAskCbFormatName(UINT nMaxCount, LPSTR lpszString);
	afx_msg void OnChangeCbChain(HWND hWndRemove, HWND hWndAfter);
	afx_msg void OnDestroyClipboard();
	afx_msg void OnDrawClipboard();
	afx_msg void OnHScrollClipboard(CWnd* pClipAppWnd, UINT nSBCode, UINT nPos);
	afx_msg void OnPaintClipboard(CWnd* pClipAppWnd, HGLOBAL hPaintStruct);
	afx_msg void OnRenderAllFormats();
	afx_msg void OnRenderFormat(UINT nFormat);
	afx_msg void OnSizeClipboard(CWnd* pClipAppWnd, HGLOBAL hRect);
	afx_msg void OnVScrollClipboard(CWnd* pClipAppWnd, UINT nSBCode, UINT nPos);

// Control message handler member functions
	afx_msg int OnCompareItem(int nIDCtl, LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	afx_msg void OnDeleteItem(int nIDCtl, LPDELETEITEMSTRUCT lpDeleteItemStruct);
	afx_msg void OnDrawItem(int nIDCtl, LPDRAWITEMSTRUCT lpDrawItemStruct);
	afx_msg UINT OnGetDlgCode();
	afx_msg void OnMeasureItem(int nIDCtl, LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	afx_msg int OnCharToItem(UINT nChar, CListBox* pListBox, UINT nIndex);
	afx_msg int OnVKeyToItem(UINT nKey, CListBox* pListBox, UINT nIndex);

// MDI message handler member functions
	afx_msg void OnMDIActivate(BOOL bActivate,
			CWnd* pActivateWnd, CWnd* pDeactivateWnd);

// Overridables and other helpers (for implementation of derived classes)
protected:
	// for deriving from a standard control
	virtual WNDPROC* GetSuperWndProcAddr();

	// for dialog data exchange and validation
	virtual void DoDataExchange(CDataExchange* pDX);

public:
	// for translating Windows messages in main message pump
	virtual BOOL PreTranslateMessage(MSG* pMsg);

protected:
	// for processing Windows messages
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	// for handling default processing
	LRESULT Default();
	virtual LRESULT DefWindowProc(UINT message, WPARAM wParam, LPARAM lParam);

	// for custom cleanup after WM_NCDESTROY
	virtual void PostNcDestroy();
	// for notifications from parent
	virtual BOOL OnChildNotify(UINT message, WPARAM wParam, LPARAM lParam,
					LRESULT* pLResult);
					// return TRUE if parent should not process this message

// Implementation
public:
	virtual ~CWnd();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	// helper routines for implementation
	BOOL SendChildNotifyLastMsg(LRESULT* pLResult = NULL);
	BOOL ExecuteDlgInit(LPCSTR lpszResourceName);
	static BOOL PASCAL GrayCtlColor(HDC hDC, HWND hWnd, UINT nCtlColor,
			HBRUSH hbrGray, COLORREF clrText);
	void CenterWindow(CWnd* pAlternateOwner = NULL);
	static CWnd* PASCAL GetDescendantWindow(HWND hWnd, int nID,
		BOOL bOnlyPerm);
	static void PASCAL SendMessageToDescendants(HWND hWnd, UINT message,
		WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm);
	virtual BOOL IsFrameWnd() const; // IsKindOf(RUNTIME_CLASS(CFrameWnd)))
	CWnd* GetTopLevelParent() const;
	CFrameWnd* GetTopLevelFrame() const;
	virtual void OnFinalRelease();

	// implementation message handlers for private messages
	afx_msg LRESULT OnVBXEvent(WPARAM wParam, LPARAM lParam);

protected:
	HWND m_hWndOwner;   // implementation of SetOwner and GetOwner

	COleDropTarget* m_pDropTarget;  // for automatic cleanup of drop target
	friend class COleDropTarget;

	// implementation of message routing
	friend LRESULT CALLBACK AFX_EXPORT _AfxSendMsgHook(int, WPARAM, LPARAM);
	friend LRESULT PASCAL _AfxCallWndProc(CWnd*, HWND, UINT, WPARAM, LPARAM);

	//{{AFX_MSG(CWnd)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// helpers for registering your own WNDCLASSes
const char* AFXAPI AfxRegisterWndClass(UINT nClassStyle,
	HCURSOR hCursor = 0, HBRUSH hbrBackground = 0, HICON hIcon = 0);

// Implementation
LRESULT CALLBACK AFX_EXPORT AfxWndProc(HWND, UINT, WPARAM, LPARAM);
typedef void (AFX_MSG_CALL CWnd::*AFX_PMSGW)(void);
		// like 'AFX_PMSG' but for CWnd derived classes only

/////////////////////////////////////////////////////////////////////////////
// CDialog - a modal or modeless dialog

class CDialog : public CWnd
{
	DECLARE_DYNAMIC(CDialog)

	// Modeless construct
		// (protected since you must subclass to implement a modeless Dialog)
protected:
	CDialog();

	BOOL Create(LPCSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	BOOL Create(UINT nIDTemplate, CWnd* pParentWnd = NULL);
	BOOL CreateIndirect(const void FAR* lpDialogTemplate,
		CWnd* pParentWnd = NULL);

	// Modal construct
public:
	CDialog(LPCSTR lpszTemplateName, CWnd* pParentWnd = NULL);
	CDialog(UINT nIDTemplate, CWnd* pParentWnd = NULL);

	BOOL InitModalIndirect(HGLOBAL hDialogTemplate);
							 // was CModalDialog::Create()

// Attributes
public:
	void MapDialogRect(LPRECT lpRect) const;
	void SetHelpID(UINT nIDR);

// Operations
public:
	// modal processing
	virtual int DoModal();

	// message processing for modeless
	BOOL IsDialogMessage(LPMSG lpMsg);

	// support for passing on tab control - use 'PostMessage' if needed
	void NextDlgCtrl() const;
	void PrevDlgCtrl() const;
	void GotoDlgCtrl(CWnd* pWndCtrl);

	// default button access
	void SetDefID(UINT nID);
	DWORD GetDefID() const;

	// termination
	void EndDialog(int nResult);

// Overridables (special message map entries)
	virtual BOOL OnInitDialog();
	virtual void OnSetFont(CFont* pFont);
protected:
	virtual void OnOK();
	virtual void OnCancel();

// Implementation
public:
	virtual ~CDialog();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);

protected:
	UINT m_nIDHelp;             // Help ID (0 for none, see HID_BASE_RESOURCE)

	// parameters for 'DoModal'
	LPCSTR m_lpDialogTemplate;  // name or MAKEINTRESOURCE
	HGLOBAL m_hDialogTemplate;  // Indirect if (lpDialogTemplate == NULL)
	CWnd* m_pParentWnd;

	// implementation helpers
	HWND PreModal();
	void PostModal();

protected:
	//{{AFX_MSG(CDialog)
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

// all CModalDialog functionality is now in CDialog
#define CModalDialog    CDialog

/////////////////////////////////////////////////////////////////////////////
// Standard Windows controls

class CStatic : public CWnd
{
	DECLARE_DYNAMIC(CStatic)

// Constructors
public:
	CStatic();
	BOOL Create(LPCSTR lpszText, DWORD dwStyle,
				const RECT& rect, CWnd* pParentWnd, UINT nID = 0xffff);

#if (WINVER >= 0x030a)
	HICON SetIcon(HICON hIcon);
	HICON GetIcon() const;
#endif

// Implementation
public:
	virtual ~CStatic();
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
};

class CButton : public CWnd
{
	DECLARE_DYNAMIC(CButton)

// Constructors
public:
	CButton();
	BOOL Create(LPCSTR lpszCaption, DWORD dwStyle,
				const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	UINT GetState() const;
	void SetState(BOOL bHighlight);
	int GetCheck() const;
	void SetCheck(int nCheck);
	UINT GetButtonStyle() const;
	void SetButtonStyle(UINT nStyle, BOOL bRedraw = TRUE);

// Overridables (for owner draw only)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Implementation
public:
	virtual ~CButton();
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};


class CListBox : public CWnd
{
	DECLARE_DYNAMIC(CListBox)

// Constructors
public:
	CListBox();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes

	// for entire listbox
	int GetCount() const;
	int GetHorizontalExtent() const;
	void SetHorizontalExtent(int cxExtent);
	int GetTopIndex() const;
	int SetTopIndex(int nIndex);

	// for single-selection listboxes
	int GetCurSel() const;
	int SetCurSel(int nSelect);

	// for multiple-selection listboxes
	int GetSel(int nIndex) const;           // also works for single-selection
	int SetSel(int nIndex, BOOL bSelect = TRUE);
	int GetSelCount() const;
	int GetSelItems(int nMaxItems, LPINT rgIndex) const;

	// for listbox items
	DWORD GetItemData(int nIndex) const;
	int SetItemData(int nIndex, DWORD dwItemData);
	void* GetItemDataPtr(int nIndex) const;
	int SetItemDataPtr(int nIndex, void* pData);
	int GetItemRect(int nIndex, LPRECT lpRect) const;
	int GetText(int nIndex, LPSTR lpszBuffer) const;
	int GetTextLen(int nIndex) const;
	void GetText(int nIndex, CString& rString) const;

	// Settable only attributes
	void SetColumnWidth(int cxWidth);
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
	void SetTabStops();
	BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

#if (WINVER >= 0x030a)
	int SetItemHeight(int nIndex, UINT cyItemHeight);
	int GetItemHeight(int nIndex) const;
	int FindStringExact(int nIndexStart, LPCSTR lpszFind) const;
	int GetCaretIndex() const;
	int SetCaretIndex(int nIndex, BOOL bScroll = TRUE);
#endif

// Operations
	// manipulating listbox items
	int AddString(LPCSTR lpszItem);
	int DeleteString(UINT nIndex);
	int InsertString(int nIndex, LPCSTR lpszItem);
	void ResetContent();
	int Dir(UINT attr, LPCSTR lpszWildCard);

	// selection helpers
	int FindString(int nStartAfter, LPCSTR lpszItem) const;
	int SelectString(int nStartAfter, LPCSTR lpszItem);
	int SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem);

// Overridables (must override draw, measure and compare for owner draw)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);

// Implementation
public:
	virtual ~CListBox();
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};

class CComboBox : public CWnd
{
	DECLARE_DYNAMIC(CComboBox)

// Constructors
public:
	CComboBox();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	// for entire combo box
	int GetCount() const;
	int GetCurSel() const;
	int SetCurSel(int nSelect);

	// for edit control
	DWORD GetEditSel() const;
	BOOL LimitText(int nMaxChars);
	BOOL SetEditSel(int nStartChar, int nEndChar);

	// for combobox item
	DWORD GetItemData(int nIndex) const;
	int SetItemData(int nIndex, DWORD dwItemData);
	void* GetItemDataPtr(int nIndex) const;
	int SetItemDataPtr(int nIndex, void* pData);
	int GetLBText(int nIndex, LPSTR lpszText) const;
	int GetLBTextLen(int nIndex) const;
	void GetLBText(int nIndex, CString& rString) const;

#if (WINVER >= 0x030a)
	int SetItemHeight(int nIndex, UINT cyItemHeight);
	int GetItemHeight(int nIndex) const;
	int FindStringExact(int nIndexStart, LPCSTR lpszFind) const;
	int SetExtendedUI(BOOL bExtended = TRUE);
	BOOL GetExtendedUI() const;
	void GetDroppedControlRect(LPRECT lprect) const;
	BOOL GetDroppedState() const;
#endif

// Operations
	// for drop-down combo boxes
	void ShowDropDown(BOOL bShowIt = TRUE);

	// manipulating listbox items
	int AddString(LPCSTR lpszString);
	int DeleteString(UINT nIndex);
	int InsertString(int nIndex, LPCSTR lpszString);
	void ResetContent();
	int Dir(UINT attr, LPCSTR lpszWildCard);

	// selection helpers
	int FindString(int nStartAfter, LPCSTR lpszString) const;
	int SelectString(int nStartAfter, LPCSTR lpszString);

	// Clipboard operations
	void Clear();
	void Copy();
	void Cut();
	void Paste();

// Overridables (must override draw, measure and compare for owner draw)
	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
	virtual int CompareItem(LPCOMPAREITEMSTRUCT lpCompareItemStruct);
	virtual void DeleteItem(LPDELETEITEMSTRUCT lpDeleteItemStruct);

// Implementation
public:
	virtual ~CComboBox();
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
	virtual BOOL OnChildNotify(UINT, WPARAM, LPARAM, LRESULT*);
};


class CEdit : public CWnd
{
	DECLARE_DYNAMIC(CEdit)

// Constructors
public:
	CEdit();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	BOOL CanUndo() const;
	int GetLineCount() const;
	BOOL GetModify() const;
	void SetModify(BOOL bModified = TRUE);
	void GetRect(LPRECT lpRect) const;
	DWORD GetSel() const;
	void GetSel(int& nStartChar, int& nEndChar) const;
	HLOCAL GetHandle() const;
	void SetHandle(HLOCAL hBuffer);

	// NOTE: first word in lpszBuffer must contain the size of the buffer!
	int GetLine(int nIndex, LPSTR lpszBuffer) const;
	int GetLine(int nIndex, LPSTR lpszBuffer, int nMaxLength) const;

// Operations
	void EmptyUndoBuffer();
	BOOL FmtLines(BOOL bAddEOL);

	void LimitText(int nChars = 0);
	int LineFromChar(int nIndex = -1) const;
	int LineIndex(int nLine = -1) const;
	int LineLength(int nLine = -1) const;
	void LineScroll(int nLines, int nChars = 0);
	void ReplaceSel(LPCSTR lpszNewText);
	void SetPasswordChar(char ch);
	void SetRect(LPCRECT lpRect);
	void SetRectNP(LPCRECT lpRect);
	void SetSel(DWORD dwSelection, BOOL bNoScroll = FALSE);
	void SetSel(int nStartChar, int nEndChar, BOOL bNoScroll = FALSE);
	BOOL SetTabStops(int nTabStops, LPINT rgTabStops);
	void SetTabStops();
	BOOL SetTabStops(const int& cxEachStop);    // takes an 'int'

	// Clipboard operations
	BOOL Undo();
	void Clear();
	void Copy();
	void Cut();
	void Paste();

#if (WINVER >= 0x030a)
	BOOL SetReadOnly(BOOL bReadOnly = TRUE);
	int GetFirstVisibleLine() const;
	char GetPasswordChar() const;
#endif

// Implementation
public:
	virtual ~CEdit();
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
};


class CScrollBar : public CWnd
{
	DECLARE_DYNAMIC(CScrollBar)

// Constructors
public:
	CScrollBar();
	BOOL Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

// Attributes
	int GetScrollPos() const;
	int SetScrollPos(int nPos, BOOL bRedraw = TRUE);
	void GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const;
	void SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw = TRUE);
	void ShowScrollBar(BOOL bShow = TRUE);

#if (WINVER >= 0x030a)
	BOOL EnableScrollBar(UINT nArrowFlags = ESB_ENABLE_BOTH);
#endif

// Implementation
public:
	virtual ~CScrollBar();
protected:
	virtual WNDPROC* GetSuperWndProcAddr();
};

/////////////////////////////////////////////////////////////////////////////
// CFrameWnd - base class for SDI and other frame windows

// Frame window styles
#define FWS_ADDTOTITLE      0x8000L  // modify title based on content

struct CPrintPreviewState;      // forward reference (see afxext.h)
class COleFrameHook;            // forward reference for OLE implementation

class CFrameWnd : public CWnd
{
	DECLARE_DYNCREATE(CFrameWnd)

// Constructors
public:
	static const CRect AFXAPI_DATA rectDefault;
	CFrameWnd();

	BOOL LoadAccelTable(LPCSTR lpszResourceName);
	BOOL Create(LPCSTR lpszClassName,
				LPCSTR lpszWindowName,
				DWORD dwStyle = WS_OVERLAPPEDWINDOW,
				const RECT& rect = rectDefault,
				CWnd* pParentWnd = NULL,        // != NULL for popups
				LPCSTR lpszMenuName = NULL,
				DWORD dwExStyle = 0,
				CCreateContext* pContext = NULL);

	// dynamic creation - load frame and associated resources
	virtual BOOL LoadFrame(UINT nIDResource,
				DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
				CWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);

// Attributes
	virtual CDocument* GetActiveDocument();

	// Active child view maintenance
	CView* GetActiveView() const;           // active view or NULL
	void SetActiveView(CView* pViewNew, BOOL bNotify = TRUE);
		// active view or NULL, bNotify == FALSE if focus should not be set

	// Active frame (for frames within frames -- MDI)
	virtual CFrameWnd* GetActiveFrame();

	BOOL m_bAutoMenuEnable;
		// TRUE => menu items without handlers will be disabled

// Operations
	virtual void RecalcLayout(BOOL bNotify = TRUE);
	virtual void ActivateFrame(int nCmdShow = -1);

// Overridables
	virtual void OnSetPreviewMode(BOOL bPreview, CPrintPreviewState* pState);
protected:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);

// Command Handlers
public:
	afx_msg void OnContextHelp();   // for Shift+F1 help

// Implementation
public:
	virtual ~CFrameWnd();
	int m_nWindow;  // general purpose window number - display as ":n"
					// -1 => unknown, 0 => only window viewing document
					// 1 => first of many windows viewing document, 2=> second

	HMENU m_hMenuDefault;       // default menu resource for this frame
	HACCEL m_hAccelTable;       // accelerator table
	DWORD m_dwPromptContext;    // current help prompt context for message box
	BOOL m_bHelpMode;           // if TRUE, then Shift+F1 help mode is active
	CFrameWnd* m_pNextFrameWnd; // next CFrameWnd in app global list
	CRect m_rectBorder;         // for OLE 2.0 border space negotiation
	COleFrameHook* m_pNotifyHook;

protected:
	UINT m_nIDHelp;             // Help ID (0 for none, see HID_BASE_RESOURCE)
	UINT m_nIDTracking;         // tracking command ID or string IDS
	UINT m_nIDLastMessage;      // last displayed message string IDS
	CView* m_pViewActive;       // current active view
	BOOL (CALLBACK* m_lpfnCloseProc)(CFrameWnd* pFrameWnd);
	UINT m_cModalStack;         // BeginModalState depth
	HWND* m_phWndDisable;       // windows disabled because of BeginModalState
	HMENU m_hMenuAlt;           // menu to update to (NULL means default)
	CString m_strTitle;         // default title (original)

public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL IsFrameWnd() const;
	BOOL IsTracking() const;
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual CWnd* GetMessageBar();
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
	virtual BOOL PreTranslateMessage(MSG* pMsg);

	// idle update of frame user interface
	enum IdleFlags
		{ idleMenu = 1, idleTitle = 2, idleNotify = 4, idleLayout = 8 };
	UINT m_nIdleFlags;          // set of bit flags for idle processing
	virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
	void DelayUpdateFrameTitle();
	void DelayRecalcLayout(BOOL bNotify);

	// border space negotiation
	enum BorderCmd
		{ borderGet = 1, borderRequest = 2, borderSet = 3 };
	virtual BOOL NegotiateBorderSpace(UINT nBorderCmd, LPRECT lpRectBorder);

	// frame window based modality
	void BeginModalState();
	void EndModalState();
	BOOL InModalState() const;
	void ShowOwnedWindows(BOOL bShow);

	// for Shift+F1 help support
	BOOL CanEnterHelpMode();
	virtual void ExitHelpMode();

protected:
	// implementation helpers
	LPCSTR GetIconWndClass(DWORD dwDefaultStyle, UINT nIDResource);
	void UpdateFrameTitleForDocument(const char* pszDocName);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
	virtual void PostNcDestroy();   // default to delete this.
	int OnCreateHelper(LPCREATESTRUCT lpcs, CCreateContext* pContext);

	// implementation helpers for Shift+F1 help mode
	BOOL ProcessHelpMsg(MSG& msg, DWORD* pContext);
	HWND SetHelpCapture(POINT point, BOOL* pbDescendant);

	// CFrameWnd list management
	void AddFrameWnd();
	void RemoveFrameWnd();

	//{{AFX_MSG(CFrameWnd)
	// Windows messages
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnNcDestroy();
	afx_msg void OnClose();
	afx_msg void OnInitMenuPopup(CMenu*, UINT, BOOL);
	afx_msg void OnMenuSelect(UINT nItemID, UINT nFlags, HMENU hSysMenu);
	afx_msg LRESULT OnSetMessageString(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	afx_msg void OnEnterIdle(UINT nWhy, CWnd* pWho);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnActivate(UINT nState, CWnd* pWndOther, BOOL bMinimized);
	afx_msg void OnActivateApp(BOOL bActive, HTASK hTask);
	afx_msg void OnSysCommand(UINT nID, LONG lParam);
	afx_msg BOOL OnQueryEndSession();
	afx_msg void OnEndSession(BOOL bEnding);
	afx_msg void OnDropFiles(HDROP hDropInfo);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnHelpHitTest(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDDEInitiate(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDDEExecute(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnDDETerminate(WPARAM wParam, LPARAM lParam);
	afx_msg void OnSysColorChange();
	afx_msg void OnEnable(BOOL bEnable);
	// standard commands
	afx_msg void OnUpdateControlBarMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnBarCheck(UINT nID);
	afx_msg void OnUpdateKeyIndicator(CCmdUI* pCmdUI);
	afx_msg void OnHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
// MDI Support

#ifndef _AFXCTL
class CMDIFrameWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(CMDIFrameWnd)

public:

// Constructors
	CMDIFrameWnd();

// Operations
	void MDIActivate(CWnd* pWndActivate);
	CMDIChildWnd* MDIGetActive(BOOL* pbMaximized = NULL) const;
	void MDIIconArrange();
	void MDIMaximize(CWnd* pWnd);
	void MDINext();
	void MDIRestore(CWnd* pWnd);
	CMenu* MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu);
	void MDITile();
	void MDICascade();

#if (WINVER >= 0x030a)
	void MDITile(int nType);
	void MDICascade(int nType);
#endif

// Overridables
	// MFC V1 backward compatible CreateClient hook (called by OnCreateClient)
	virtual BOOL CreateClient(LPCREATESTRUCT lpCreateStruct, CMenu* pWindowMenu);
	// customize if using an 'Window' menu with non-standard IDs
	virtual HMENU GetWindowMenuPopup(HMENU hMenuBar);

// Implementation
public:
	HWND m_hWndMDIClient;       // MDI Client window handle

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL LoadFrame(UINT nIDResource,
				DWORD dwDefaultStyle = WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,
				CWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnUpdateFrameMenu(HMENU hMenuAlt);
	virtual void DelayUpdateFrameMenu(HMENU hMenuAlt);
	virtual CFrameWnd* GetActiveFrame();

protected:
	virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);

	//{{AFX_MSG(CMDIFrameWnd)
	afx_msg void OnDestroy();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnUpdateMDIWindowCmd(CCmdUI* pCmdUI);
	afx_msg BOOL OnMDIWindowCmd(UINT nID);
	afx_msg void OnWindowNew();
	afx_msg LRESULT OnCommandHelp(WPARAM wParam, LPARAM lParam);
	afx_msg LRESULT OnIdleUpdateCmdUI(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


class CMDIChildWnd : public CFrameWnd
{
	DECLARE_DYNCREATE(CMDIChildWnd)

// Constructors
public:
	CMDIChildWnd();

	BOOL Create(LPCSTR lpszClassName,
				LPCSTR lpszWindowName,
				DWORD dwStyle = WS_CHILD | WS_VISIBLE | WS_OVERLAPPEDWINDOW,
				const RECT& rect = rectDefault,
				CMDIFrameWnd* pParentWnd = NULL,
				CCreateContext* pContext = NULL);

// Attributes
	CMDIFrameWnd* GetMDIFrame();

// Operations
	void MDIDestroy();
	void MDIActivate();
	void MDIMaximize();
	void MDIRestore();

// Implementation
protected:
	HMENU m_hMenuShared;        // menu when we are active
public:
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL LoadFrame(UINT nIDResource, DWORD dwDefaultStyle,
					CWnd* pParentWnd, CCreateContext* pContext = NULL);
					// 'pParentWnd' parameter is required for MDI Child
	virtual BOOL DestroyWindow();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual void ActivateFrame(int nCmdShow = -1);
	virtual void OnUpdateFrameMenu(BOOL bActive, CWnd* pActivateWnd,
		HMENU hMenuAlt);

	BOOL m_bPseudoInactive;     // TRUE if window is MDI active according to
								//  windows, but not according to MFC...

protected:

	virtual CWnd* GetMessageBar();
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);
	virtual LRESULT DefWindowProc(UINT nMsg, WPARAM wParam, LPARAM lParam);
	//{{AFX_MSG(CMDIChildWnd)
	afx_msg void OnMDIActivate(BOOL bActivate, CWnd*, CWnd*);
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif //!_AFXCTL

/////////////////////////////////////////////////////////////////////////////
// class CView is the client area UI for a document

class CPrintDialog;     // forward reference (from afxdlgs.h)
class CPreviewView;
class CSplitterWnd;
class COleServerDoc;    // forward reference (from afxole.h)

typedef DWORD DROPEFFECT;
class COleDataObject;

class CView : public CWnd
{
	DECLARE_DYNAMIC(CView)

// Constructors
protected:
	CView();

// Attributes
public:
	CDocument* GetDocument() const;

// Operations
public:
	// for standard printing setup (override OnPreparePrinting)
	BOOL DoPreparePrinting(CPrintInfo* pInfo);

// Overridables
public:
	virtual BOOL IsSelected(const CObject* pDocItem) const; // support for OLE

	// OLE 2.0 scrolling support (used for drag/drop as well)
	virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

	// OLE 2.0 drag/drop support
	virtual DROPEFFECT OnDragEnter(COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual DROPEFFECT OnDragOver(COleDataObject* pDataObject,
		DWORD dwKeyState, CPoint point);
	virtual void OnDragLeave();
	virtual BOOL OnDrop(COleDataObject* pDataObject,
		DROPEFFECT dropEffect, CPoint point);

	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);

	virtual void OnInitialUpdate(); // called first time after construct

protected:
	// Activation
	virtual void OnActivateView(BOOL bActivate, CView* pActivateView,
					CView* pDeactiveView);

	// General drawing/updating
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	virtual void OnDraw(CDC* pDC) = 0;

	// Printing support
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
					// must override to enable printing and print preview

	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnPrint(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);

	// Advanced: end print preview mode, move to point
	virtual void OnEndPrintPreview(CDC* pDC, CPrintInfo* pInfo, POINT point,
					CPreviewView* pView);

// Implementation
public:
	virtual ~CView();
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG

	// Advanced: for implementing custom print preview
	BOOL DoPrintPreview(UINT nIDResource, CView* pPrintView,
			CRuntimeClass* pPreviewViewClass, CPrintPreviewState* pState);

	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);
	virtual CScrollBar* GetScrollBarCtrl(int nBar) const;
	static CSplitterWnd* GetParentSplitter(const CWnd* pWnd, BOOL bAnyState);

protected:
	CDocument* m_pDocument;

	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual void PostNcDestroy();
	virtual void OnActivateFrame(UINT nState, CFrameWnd* pFrameWnd);

	// friend classes that call protected CView overridables
	friend class CDocument;
	friend class CDocTemplate;
	friend class CPreviewView;
	friend class CFrameWnd;
	friend class CMDIFrameWnd;
	friend class CMDIChildWnd;
	friend class CSplitterWnd;
	friend class COleServerDoc;

	//{{AFX_MSG(CView)
	afx_msg int OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnDestroy();
	afx_msg void OnPaint();
	afx_msg int OnMouseActivate(CWnd* pDesktopWnd, UINT nHitTest, UINT message);
	// commands
	afx_msg void OnUpdateSplitCmd(CCmdUI* pCmdUI);
	afx_msg BOOL OnSplitCmd(UINT nID);
	afx_msg void OnUpdateNextPaneMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnNextPaneCmd(UINT nID);

	// not mapped commands - must be mapped in derived class
	afx_msg void OnFilePrint();
	afx_msg void OnFilePrintPreview();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CScrollView supports simple scrolling and scaling

class CScrollView : public CView
{
	DECLARE_DYNAMIC(CScrollView)

// Constructors
protected:
	CScrollView();

public:
	static const SIZE AFXAPI_DATA sizeDefault;
		// used to specify default calculated page and line sizes

	// in logical units - call one of the following Set routines
	void SetScaleToFitSize(SIZE sizeTotal);
	void SetScrollSizes(int nMapMode, SIZE sizeTotal,
				const SIZE& sizePage = sizeDefault,
				const SIZE& sizeLine = sizeDefault);

// Attributes
public:
	CPoint GetScrollPosition() const;       // upper corner of scrolling
	CSize GetTotalSize() const;             // logical size

	// for device units
	CPoint GetDeviceScrollPosition() const;
	void GetDeviceScrollSizes(int& nMapMode, SIZE& sizeTotal,
			SIZE& sizePage, SIZE& sizeLine) const;

// Operations
public:
	void ScrollToPosition(POINT pt);    // set upper left position
	void FillOutsideRect(CDC* pDC, CBrush* pBrush);
	void ResizeParentToFit(BOOL bShrinkOnly = TRUE);

// Implementation
protected:
	int m_nMapMode;
	CSize m_totalLog;         // total size in logical units (no rounding)
	CSize m_totalDev;         // total size in device units
	CSize m_pageDev;          // per page scroll size in device units
	CSize m_lineDev;          // per line scroll size in device units

	BOOL m_bCenter;          // Center output if larger than total size
	BOOL m_bInsideUpdate;    // internal state for OnSize callback
	void CenterOnPoint(CPoint ptCenter);
	void ScrollToDevicePosition(POINT ptDev); // explicit scrolling no checking

protected:
	virtual void OnDraw(CDC* pDC) = 0;      // pass on pure virtual

	void UpdateBars(BOOL bSendRecalc = TRUE); // adjust scrollbars etc
	BOOL GetTrueClientSize(CSize& size, CSize& sizeSb);
		// size with no bars
	void GetScrollBarSizes(CSize& sizeSb);
	void GetScrollBarState(CSize sizeClient, CSize& needSb,
		CSize& sizeRange, CPoint& ptMove, BOOL bInsideClient);

public:
	virtual ~CScrollView();
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG
	virtual void CalcWindowRect(LPRECT lpClientRect,
		UINT nAdjustType = adjustBorder);
	virtual void OnPrepareDC(CDC* pDC, CPrintInfo* pInfo = NULL);

	// scrolling implementation support for OLE 2.0
	virtual BOOL OnScroll(UINT nScrollCode, UINT nPos, BOOL bDoScroll = TRUE);
	virtual BOOL OnScrollBy(CSize sizeScroll, BOOL bDoScroll = TRUE);

	//{{AFX_MSG(CScrollView)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	afx_msg void OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Global functions for access to the one and only CWinApp

extern "C"
{
#ifndef _AFXDLL
// standard C variables if you wish to access them from C programs,
// use inline functions for C++ programs
extern CWinApp* NEAR afxCurrentWinApp;
extern HINSTANCE NEAR afxCurrentInstanceHandle;
extern HINSTANCE NEAR afxCurrentResourceHandle;
extern const char* NEAR afxCurrentAppName;
extern DWORD NEAR afxTempMapLock;
#endif //!_AFXDLL

// Advanced initialization: for overriding default WinMain
extern BOOL AFXAPI AfxWinInit(HINSTANCE, HINSTANCE, LPSTR, int);
extern void AFXAPI AfxWinTerm();
}

// Global Windows state data helper functions (inlines)
CWinApp* AFXAPI AfxGetApp();
CWnd* AFXAPI AfxGetMainWnd();
HINSTANCE AFXAPI AfxGetInstanceHandle();
HINSTANCE AFXAPI AfxGetResourceHandle();
void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource);
const char* AFXAPI AfxGetAppName();

// access to message filter in CWinApp
class COleMessageFilter;        // see AFXOLE.H for more information
COleMessageFilter* AFXAPI AfxOleGetMessageFilter();

/////////////////////////////////////////////////////////////////////////////
// CWinApp - the root of all Windows applications

#define _AFX_MRU_COUNT   4      // default support for 4 entries in file MRU

class CWinApp : public CCmdTarget
{
	DECLARE_DYNAMIC(CWinApp)
public:

// Constructor
	CWinApp(const char* pszAppName = NULL);     // app name defaults to EXE name

// Attributes
	// Startup args (do not change)
	HINSTANCE m_hInstance;
	HINSTANCE m_hPrevInstance;
	LPSTR m_lpCmdLine;
	int m_nCmdShow;

	// Running args (can be changed in InitInstance)
	CWnd* m_pMainWnd;           // main window (optional)
	CWnd* m_pActiveWnd;         // active main window (may not be m_pMainWnd)
	const char* m_pszAppName;   // human readable name
								//  (from constructor or AFX_IDS_APP_TITLE)

	// Support for Shift+F1 help mode.
	BOOL m_bHelpMode;               // are we in Shift+F1 mode?

public:  // set in constructor to override default
	const char* m_pszExeName;       // executable name (no spaces)
	const char* m_pszHelpFilePath;  // default based on module path
	const char* m_pszProfileName;   // default based on app name

// Initialization Operations - should be done in InitInstance
protected:
	void LoadStdProfileSettings(); // load MRU file list and last preview state
	void EnableVBX();
	void EnableShellOpen();

	void SetDialogBkColor(COLORREF clrCtlBk = RGB(192, 192, 192),
				COLORREF clrCtlText = RGB(0, 0, 0));
		// set dialog box and message box background color

	void RegisterShellFileTypes();
		// call after all doc templates are registered

// Helper Operations - usually done in InitInstance
public:
	// Cursors
	HCURSOR LoadCursor(LPCSTR lpszResourceName) const;
	HCURSOR LoadCursor(UINT nIDResource) const;
	HCURSOR LoadStandardCursor(LPCSTR lpszCursorName) const; // for IDC_ values
	HCURSOR LoadOEMCursor(UINT nIDCursor) const;             // for OCR_ values

	// Icons
	HICON LoadIcon(LPCSTR lpszResourceName) const;
	HICON LoadIcon(UINT nIDResource) const;
	HICON LoadStandardIcon(LPCSTR lpszIconName) const;       // for IDI_ values
	HICON LoadOEMIcon(UINT nIDIcon) const;                   // for OIC_ values

	// Profile settings (to the app specific .INI file)
	UINT GetProfileInt(LPCSTR lpszSection, LPCSTR lpszEntry, int nDefault);
	BOOL WriteProfileInt(LPCSTR lpszSection, LPCSTR lpszEntry, int nValue);
	CString GetProfileString(LPCSTR lpszSection, LPCSTR lpszEntry,
				LPCSTR lpszDefault = NULL);
	BOOL WriteProfileString(LPCSTR lpszSection, LPCSTR lpszEntry,
				LPCSTR lpszValue);

// Running Operations - to be done on a running application
	// Dealing with document templates
	void AddDocTemplate(CDocTemplate* pTemplate);

	// Dealing with files
	virtual CDocument* OpenDocumentFile(LPCSTR lpszFileName); // open named file
	virtual void AddToRecentFileList(const char* pszPathName);  // add to MRU

	// Printer DC Setup routine, 'struct tagPD' is a PRINTDLG structure
	BOOL GetPrinterDeviceDefaults(struct tagPD FAR* pPrintDlg);

	// Preloading/Unloading VBX files and checking for existance
	HMODULE LoadVBXFile(LPCSTR lpszFileName);
	BOOL UnloadVBXFile(LPCSTR lpszFileName);

	// Command line parsing
	BOOL RunEmbedded();
	BOOL RunAutomated();

// Overridables
	// hooks for your initialization code
	virtual BOOL InitApplication();
	virtual BOOL InitInstance();

	// running and idle processing
	virtual int Run();
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	virtual BOOL OnIdle(LONG lCount); // return TRUE if more idle processing

	// exiting
	virtual BOOL SaveAllModified(); // save before exit
	virtual int ExitInstance(); // return app exit code

	// Advanced: to override message boxes and other hooks
	virtual int DoMessageBox(LPCSTR lpszPrompt, UINT nType, UINT nIDPrompt);
	virtual BOOL ProcessMessageFilter(int code, LPMSG lpMsg);
	virtual LRESULT ProcessWndProcException(CException* e, const MSG* pMsg);
	virtual void DoWaitCursor(int nCode); // 0 => restore, 1=> begin, -1=> end

	// Advanced: process async DDE request
	virtual BOOL OnDDECommand(char* pszCommand);

	// Advanced: Help support
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);    // general

	// Advanced: virtual access to m_pMainWnd
	virtual CWnd* GetMainWnd();

// Command Handlers
protected:
	// map to the following for file new/open
	afx_msg void OnFileNew();
	afx_msg void OnFileOpen();

	// map to the following to enable print setup
	afx_msg void OnFilePrintSetup();

	// map to the following to enable help
	afx_msg void OnContextHelp();   // shift-F1
	afx_msg void OnHelp();          // F1 (uses current context)
	afx_msg void OnHelpIndex();     // ID_HELP_INDEX, ID_DEFAULT_HELP
	afx_msg void OnHelpUsing();     // ID_HELP_USING

// Implementation
protected:
	MSG m_msgCur;                   // current message

	HGLOBAL m_hDevMode;             // printer Dev Mode
	HGLOBAL m_hDevNames;            // printer Device Names
	DWORD m_dwPromptContext;        // help context override for message box

	int m_nWaitCursorCount;         // for wait cursor (>0 => waiting)
	HCURSOR m_hcurWaitCursorRestore; // old cursor to restore after wait cursor

	CString m_strRecentFiles[_AFX_MRU_COUNT]; // default MRU implementation

	void UpdatePrinterSelection(BOOL bForceDefaults);
	void SaveStdProfileSettings();  // save options to .INI file

public: // public for implementation access
	CPtrList m_templateList;        // list of templates

	ATOM m_atomApp, m_atomSystemTopic;   // for DDE open
	UINT m_nNumPreviewPages;      // number of default printed pages

	// memory safety pool
	size_t  m_nSafetyPoolSize;      // ideal size
	void*   m_pSafetyPoolBuffer;    // current buffer

	// stack safety size
	UINT    m_nCmdStack;            // stack required for WM_COMMAND
	UINT    m_nMsgStack;            // stack required for other message

	void (CALLBACK* m_lpfnCleanupVBXFiles)();

	void (CALLBACK* m_lpfnOleFreeLibraries)();
	void (CALLBACK* m_lpfnOleTerm)();
	COleMessageFilter* m_pMessageFilter;

	void SetCurrentHandles();
	BOOL PumpMessage();     // low level message pump
	int GetOpenDocumentCount();

	// helpers for standard commdlg dialogs
	BOOL DoPromptFileName(CString& fileName, UINT nIDSTitle,
			DWORD lFlags, BOOL bOpenFileDialog, CDocTemplate* pTemplate);
	int DoPrintDialog(CPrintDialog* pPD);

	void EnableModeless(BOOL bEnable); // to disable OLE in-place dialogs

public:
	virtual ~CWinApp();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
	int m_nDisablePumpCount; // Diagnostic trap to detect illegal re-entrancy
#endif //_DEBUG

	void HideApplication();     // hide application before closing docs
	void CloseAllDocuments(BOOL bEndSession);
		// close documents before exiting

#ifdef _AFXDLL
	// force linkage to AFXDLL startup code and special stack segment for
	//    applications linking with AFXDLL
	virtual void _ForceLinkage();
#endif //_AFXDLL

protected: // standard commands
	//{{AFX_MSG(CWinApp)
	afx_msg void OnAppExit();
	afx_msg void OnUpdateRecentFileMenu(CCmdUI* pCmdUI);
	afx_msg BOOL OnOpenRecentFile(UINT nID);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// class CDocTemplate creates documents

class CDocTemplate : public CCmdTarget
{
	DECLARE_DYNAMIC(CDocTemplate)

// Constructors
protected:
	CDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Attributes
public:
	// setup for OLE containers
	void SetContainerInfo(UINT nIDOleInPlaceContainer);

	// setup for OLE servers
	void SetServerInfo(UINT nIDOleEmbedding, UINT nIDOleInPlaceServer = 0,
		CRuntimeClass* pOleFrameClass = NULL, CRuntimeClass* pOleViewClass = NULL);

	// iterating over open documents
	virtual POSITION GetFirstDocPosition() const = 0;
	virtual CDocument* GetNextDoc(POSITION& rPos) const = 0;

// Operations
public:
	virtual void AddDocument(CDocument* pDoc);      // must override
	virtual void RemoveDocument(CDocument* pDoc);   // must override

	enum DocStringIndex
	{
		windowTitle,        // default window title
		docName,            // user visible name for default document
		fileNewName,        // user visible name for FileNew
		// for file based documents:
		filterName,         // user visible name for FileOpen
		filterExt,          // user visible extension for FileOpen
		// for file based documents with Shell open support:
		regFileTypeId,      // REGEDIT visible registered file type identifier
		regFileTypeName     // Shell visible registered file type name
	};
	virtual BOOL GetDocString(CString& rString,
		enum DocStringIndex index) const; // get one of the info strings

// Overridables
public:
	enum Confidence
	{
		noAttempt,
		maybeAttemptForeign,
		maybeAttemptNative,
		yesAttemptForeign,
		yesAttemptNative,
		yesAlreadyOpen
	};
	virtual Confidence MatchDocType(const char* pszPathName,
					CDocument*& rpDocMatch);
	virtual CDocument* CreateNewDocument();
	virtual CFrameWnd* CreateNewFrame(CDocument* pDoc, CFrameWnd* pOther);
	virtual void InitialUpdateFrame(CFrameWnd* pFrame, CDocument* pDoc,
		BOOL bMakeVisible = TRUE);
	virtual BOOL SaveAllModified();     // for all documents
	virtual void CloseAllDocuments(BOOL bEndSession);
	virtual CDocument* OpenDocumentFile(
		const char* pszPathName, BOOL bMakeVisible = TRUE) = 0;
					// open named file
					// if lpszPathName == NULL => create new file with this type

// Implementation
public:
	virtual ~CDocTemplate();

	// back pointer to OLE or other server (NULL if none of disabled)
	CObject* m_pAttachedFactory;

	// menu & accelerator resources for in-place container
	HMENU m_hMenuInPlace;
	HACCEL m_hAccelInPlace;

	// menu & accelerator resource for server editing embedding
	HMENU m_hMenuEmbedding;
	HACCEL m_hAccelEmbedding;

	// menu & accelerator resource for server editing in-place
	HMENU m_hMenuInPlaceServer;
	HACCEL m_hAccelInPlaceServer;

#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif
	virtual void OnIdle();              // for all documents

	// implementation helpers
	CFrameWnd* CreateOleFrame(CWnd* pParentWnd, CDocument* pDoc,
		BOOL bCreateView);

protected:  // standard implementation
	UINT m_nIDResource;                // IDR_ for frame/menu/accel as well
	UINT m_nIDServerResource;          // IDR_ for OLE frame/menu/accel
	CRuntimeClass* m_pDocClass;        // class for creating new documents
	CRuntimeClass* m_pFrameClass;      // class for creating new frames
	CRuntimeClass* m_pViewClass;       // class for creating new views
	CRuntimeClass* m_pOleFrameClass;   // class for creating in-place frame
	CRuntimeClass* m_pOleViewClass;    // class for creating in-place view
	CString m_strDocStrings;    // '\n' separated names
		// The document names sub-strings are represented as _one_ string:
		// windowTitle\ndocName\n ... (see DocStringIndex enum)
};

#ifndef _AFXCTL
// SDI support (1 document only)
class CSingleDocTemplate : public CDocTemplate
{
	DECLARE_DYNAMIC(CSingleDocTemplate)

// Constructors
public:
	CSingleDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
	virtual ~CSingleDocTemplate();
	virtual void AddDocument(CDocument* pDoc);
	virtual void RemoveDocument(CDocument* pDoc);
	virtual POSITION GetFirstDocPosition() const;
	virtual CDocument* GetNextDoc(POSITION& rPos) const;
	virtual CDocument* OpenDocumentFile(
		const char* pszPathName, BOOL bMakeVisible = TRUE);
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
	CDocument* m_pOnlyDoc;
};

// MDI support (zero or more documents)
class CMultiDocTemplate : public CDocTemplate
{
	DECLARE_DYNAMIC(CMultiDocTemplate)

// Constructors
public:
	CMultiDocTemplate(UINT nIDResource, CRuntimeClass* pDocClass,
		CRuntimeClass* pFrameClass, CRuntimeClass* pViewClass);

// Implementation
public:
	// Menu and accel table for MDI Child windows of this type
	HMENU m_hMenuShared;
	HACCEL m_hAccelTable;

	virtual ~CMultiDocTemplate();
	virtual void AddDocument(CDocument* pDoc);
	virtual void RemoveDocument(CDocument* pDoc);
	virtual POSITION GetFirstDocPosition() const;
	virtual CDocument* GetNextDoc(POSITION& rPos) const;
	virtual CDocument* OpenDocumentFile(
		const char* pszPathName, BOOL bMakeVisible = TRUE);
#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG

protected:  // standard implementation
	CPtrList m_docList;          // open documents of this type
	UINT m_nUntitledCount;   // start at 0, for "Document1" title
};
#endif //!_AFXCTL

/////////////////////////////////////////////////////////////////////////////
// class CDocument is the main document data abstraction

class CDocument : public CCmdTarget
{
	DECLARE_DYNAMIC(CDocument)

public:
// Constructors
	CDocument();

// Attributes
public:
	const CString& GetTitle() const;
	virtual void SetTitle(const char* pszTitle);
	const CString& GetPathName() const;
	virtual void SetPathName(const char* pszPathName, BOOL bAddToMRU = TRUE);

	CDocTemplate* GetDocTemplate() const;
	BOOL IsModified();
	void SetModifiedFlag(BOOL bModified = TRUE);

// Operations
	void AddView(CView* pView);
	void RemoveView(CView* pView);
	virtual POSITION GetFirstViewPosition() const;
	virtual CView* GetNextView(POSITION& rPosition) const;

	// Update Views (simple update - DAG only)
	void UpdateAllViews(CView* pSender, LPARAM lHint = 0L,
								CObject* pHint = NULL);

// Overridables
	// Special notifications
	virtual void OnChangedViewList(); // after Add or Remove view
	virtual void DeleteContents(); // delete doc items etc

	// File helpers
	virtual BOOL OnNewDocument();
	virtual BOOL OnOpenDocument(const char* pszPathName);
	virtual BOOL OnSaveDocument(const char* pszPathName);
	virtual void OnCloseDocument();
	virtual void ReportSaveLoadException(const char* pszPathName,
				CException* e, BOOL bSaving, UINT nIDPDefault);

	// advanced overridables, closing down frame/doc, etc.
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	virtual BOOL SaveModified(); // return TRUE if ok to continue

// Implementation
protected:
	// default implementation
	CString m_strTitle;
	CString m_strPathName;
	CDocTemplate* m_pDocTemplate;
	CPtrList m_viewList;                // list of views
	BOOL m_bModified;                   // changed since last saved

public:
	BOOL m_bAutoDelete;           // TRUE => delete document when no more views

#ifdef _DEBUG
	virtual void Dump(CDumpContext&) const;
	virtual void AssertValid() const;
#endif //_DEBUG
	virtual ~CDocument();

	// implementation helpers
	BOOL DoSave(const char* pszPathName, BOOL bReplace = TRUE);
	void UpdateFrameCounts();
	void DisconnectViews();
	void SendInitialUpdate();

	// overridables for implementation
	virtual HMENU GetDefaultMenu(); // get menu depending on state
	virtual HACCEL GetDefaultAccel();
	virtual void PreCloseFrame(CFrameWnd* pFrame);
	virtual void OnIdle();
	virtual void OnFinalRelease();

	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra,
		AFX_CMDHANDLERINFO* pHandlerInfo);
	friend class CDocTemplate;
protected:
	// file menu commands
	//{{AFX_MSG(CDocument)
	afx_msg void OnFileClose();
	afx_msg void OnFileSave();
	afx_msg void OnFileSaveAs();
	//}}AFX_MSG
	// mail enabling
	afx_msg void OnFileSendMail();
	afx_msg void OnUpdateFileSendMail(CCmdUI* pCmdUI);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// Extra diagnostic tracing options

#ifdef _DEBUG
// afxTraceFlags
	// 1 => multi-app debugging
	// 2 => main message pump trace (includes DDE)
	// 4 => Windows message tracing
	// 8 => Windows command routing trace (set 4+8 for control notifications)
	// 16 (0x10) => special OLE callback trace
#ifndef _AFXDLL
extern "C" { extern int NEAR afxTraceFlags; }
#endif //!_AFXDLL
#endif // _DEBUG

//////////////////////////////////////////////////////////////////////////////
// MessageBox helpers

void AFXAPI AfxFormatString1(CString& rString, UINT nIDS, LPCSTR lpsz1);
void AFXAPI AfxFormatString2(CString& rString, UINT nIDS,
				LPCSTR lpsz1, LPCSTR lpsz2);
int AFXAPI AfxMessageBox(LPCSTR lpszText, UINT nType = MB_OK,
				UINT nIDHelp = 0);
int AFXAPI AfxMessageBox(UINT nIDPrompt, UINT nType = MB_OK,
				UINT nIDHelp = (UINT)-1);

// Implementation string helpers
void AFXAPI AfxFormatStrings(CString& rString, UINT nIDS,
				LPCSTR FAR* rglpsz, int nString);
void AFXAPI AfxFormatStrings(CString& rString, LPCSTR lpszFormat,
				LPCSTR FAR* rglpsz, int nString);
BOOL AFXAPI AfxExtractSubString(CString& rString, LPCSTR lpszFullString,
				int iSubString, char chSep = '\012');

/////////////////////////////////////////////////////////////////////////////
// Special target variant APIs

// AFX DLL special includes
#ifdef _AFXDLL
#include <afxdll_.h>
#endif

// Stub special OLE Control macros
#ifndef _AFXCTL
#define AFX_MANAGE_STATE(pData)
#define METHOD_MANAGE_STATE(theClass, localClass) \
	METHOD_PROLOGUE(theClass, localClass)
#endif

// Windows Version compatibility (obsolete)
#define AfxEnableWin30Compatibility()

// Temporary map management
#define AfxLockTempMaps() (++afxTempMapLock)
BOOL AFXAPI AfxUnlockTempMaps();

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXWIN_INLINE inline
#include <afxwin1.inl>
#include <afxwin2.inl>
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

/////////////////////////////////////////////////////////////////////////////
#else //RC_INVOKED
#include <afxres.h>     // standard resource IDs
#endif //RC_INVOKED
#endif //__AFXWIN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\mfc\include\afxwin1.inl ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWIN.H (part 1)

#ifdef _AFXWIN_INLINE

/////////////////////////////////////////////////////////////////////////////

// Global helper functions
#ifndef _AFXDLL
_AFXWIN_INLINE CWinApp* AFXAPI AfxGetApp()
	{ return afxCurrentWinApp; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetInstanceHandle()
	{ ASSERT(afxCurrentInstanceHandle != NULL);
		return afxCurrentInstanceHandle; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetResourceHandle()
	{ ASSERT(afxCurrentResourceHandle != NULL);
		return afxCurrentResourceHandle; }
_AFXWIN_INLINE void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource)
	{ ASSERT(hInstResource != NULL); afxCurrentResourceHandle = hInstResource; }
_AFXWIN_INLINE const char* AFXAPI AfxGetAppName()
	{ ASSERT(afxCurrentAppName != NULL); return afxCurrentAppName; }
#else //_AFXDLL
_AFXWIN_INLINE CWinApp* AFXAPI AfxGetApp()
	{ return _AfxGetAppData()->appCurrentWinApp; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetInstanceHandle()
	{ ASSERT(_AfxGetAppData()->appCurrentInstanceHandle != NULL);
		return _AfxGetAppData()->appCurrentInstanceHandle; }
_AFXWIN_INLINE HINSTANCE AFXAPI AfxGetResourceHandle()
	{ ASSERT(_AfxGetAppData()->appCurrentResourceHandle != NULL);
		return _AfxGetAppData()->appCurrentResourceHandle; }
_AFXWIN_INLINE void AFXAPI AfxSetResourceHandle(HINSTANCE hInstResource)
	{ ASSERT(hInstResource != NULL);
		_AfxGetAppData()->appCurrentResourceHandle = hInstResource; }
_AFXWIN_INLINE const char* AFXAPI AfxGetAppName()
	{ ASSERT(_AfxGetAppData()->appCurrentAppName != NULL);
		return _AfxGetAppData()->appCurrentAppName; }
#ifdef _AFXCTL
_AFXWIN_INLINE AFX_MAINTAIN_STATE::AFX_MAINTAIN_STATE(AFX_APPDATA_MODULE* psData)
	{   m_psPrevious = AfxPushModuleContext(psData); }
_AFXWIN_INLINE AFX_MAINTAIN_STATE::~AFX_MAINTAIN_STATE()
	{   if (m_psPrevious != NULL)
			AfxPopModuleContext(m_psPrevious); }
#endif
#endif //_AFXDLL

#ifdef _AFXCTL
_AFXWIN_INLINE CWnd* AFXAPI AfxGetMainWnd()
	{   HWND hwnd = ::GetActiveWindow();
		return (hwnd != NULL && GetWindowTask(hwnd) == GetCurrentTask()) ?
			CWnd::FromHandle(hwnd) : NULL; }
#else
_AFXWIN_INLINE CWnd* AFXAPI AfxGetMainWnd()
	{ return AfxGetApp() != NULL ? AfxGetApp()->GetMainWnd() : NULL; }
#endif
_AFXWIN_INLINE COleMessageFilter* AFXAPI AfxOleGetMessageFilter()
	{ ASSERT_VALID(AfxGetApp()); return AfxGetApp()->m_pMessageFilter; }

// CSize
_AFXWIN_INLINE CSize::CSize()
	{ /* random filled */ }
_AFXWIN_INLINE CSize::CSize(int initCX, int initCY)
	{ cx = initCX; cy = initCY; }
_AFXWIN_INLINE CSize::CSize(SIZE initSize)
	{ *(SIZE*)this = initSize; }
_AFXWIN_INLINE CSize::CSize(POINT initPt)
	{ *(POINT*)this = initPt; }
_AFXWIN_INLINE CSize::CSize(DWORD dwSize)
	{ *(DWORD*)this = dwSize; }
_AFXWIN_INLINE BOOL CSize::operator==(SIZE size) const
	{ return (cx == size.cx && cy == size.cy); }
_AFXWIN_INLINE BOOL CSize::operator!=(SIZE size) const
	{ return (cx != size.cx || cy != size.cy); }
_AFXWIN_INLINE void CSize::operator+=(SIZE size)
	{ cx += size.cx; cy += size.cy; }
_AFXWIN_INLINE void CSize::operator-=(SIZE size)
	{ cx -= size.cx; cy -= size.cy; }
_AFXWIN_INLINE CSize CSize::operator+(SIZE size) const
	{ return CSize(cx + size.cx, cy + size.cy); }
_AFXWIN_INLINE CSize CSize::operator-(SIZE size) const
	{ return CSize(cx - size.cx, cy - size.cy); }
_AFXWIN_INLINE CSize CSize::operator-() const
	{ return CSize(-cx, -cy); }

// CPoint
_AFXWIN_INLINE CPoint::CPoint()
	{ /* random filled */ }
_AFXWIN_INLINE CPoint::CPoint(int initX, int initY)
	{ x = initX; y = initY; }
_AFXWIN_INLINE CPoint::CPoint(POINT initPt)
	{ *(POINT*)this = initPt; }
_AFXWIN_INLINE CPoint::CPoint(SIZE initSize)
	{ *(SIZE*)this = initSize; }
_AFXWIN_INLINE CPoint::CPoint(DWORD dwPoint)
	{ *(DWORD*)this = dwPoint; }
_AFXWIN_INLINE void CPoint::Offset(int xOffset, int yOffset)
	{ x += xOffset; y += yOffset; }
_AFXWIN_INLINE void CPoint::Offset(POINT point)
	{ x += point.x; y += point.y; }
_AFXWIN_INLINE void CPoint::Offset(SIZE size)
	{ x += size.cx; y += size.cy; }
_AFXWIN_INLINE BOOL CPoint::operator==(POINT point) const
	{ return (x == point.x && y == point.y); }
_AFXWIN_INLINE BOOL CPoint::operator!=(POINT point) const
	{ return (x != point.x || y != point.y); }
_AFXWIN_INLINE void CPoint::operator+=(SIZE size)
	{ x += size.cx; y += size.cy; }
_AFXWIN_INLINE void CPoint::operator-=(SIZE size)
	{ x -= size.cx; y -= size.cy; }
_AFXWIN_INLINE CPoint CPoint::operator+(SIZE size) const
	{ return CPoint(x + size.cx, y + size.cy); }
_AFXWIN_INLINE CPoint CPoint::operator-(SIZE size) const
	{ return CPoint(x - size.cx, y - size.cy); }
_AFXWIN_INLINE CPoint CPoint::operator-() const
	{ return CPoint(-x, -y); }
_AFXWIN_INLINE CSize CPoint::operator-(POINT point) const
	{ return CSize(x - point.x, y - point.y); }


// CRect
_AFXWIN_INLINE CRect::CRect()
	{ /* random filled */ }
_AFXWIN_INLINE CRect::CRect(int l, int t, int r, int b)
	{ left = l; top = t; right = r; bottom = b; }
_AFXWIN_INLINE CRect::CRect(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
_AFXWIN_INLINE CRect::CRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
_AFXWIN_INLINE CRect::CRect(POINT point, SIZE size)
	{ right = (left = point.x) + size.cx; bottom = (top = point.y) + size.cy; }
_AFXWIN_INLINE int CRect::Width() const
	{ return right - left; }
_AFXWIN_INLINE int CRect::Height() const
	{ return bottom - top; }
_AFXWIN_INLINE CSize CRect::Size() const
	{ return CSize(right - left, bottom - top); }
_AFXWIN_INLINE CPoint& CRect::TopLeft()
	{ return *((CPoint*)this); }
_AFXWIN_INLINE CPoint& CRect::BottomRight()
	{ return *((CPoint*)this+1); }
_AFXWIN_INLINE CRect::operator LPRECT()
	{ return this; }
_AFXWIN_INLINE CRect::operator LPCRECT() const
	{ return this; }
_AFXWIN_INLINE BOOL CRect::IsRectEmpty() const
	{ return ::IsRectEmpty(this); }
_AFXWIN_INLINE BOOL CRect::IsRectNull() const
	{ return (left == 0 && right == 0 && top == 0 && bottom == 0); }
_AFXWIN_INLINE BOOL CRect::PtInRect(POINT point) const
	{ return ::PtInRect(this, point); }
_AFXWIN_INLINE void CRect::SetRect(int x1, int y1, int x2, int y2)
	{ ::SetRect(this, x1, y1, x2, y2); }
_AFXWIN_INLINE void CRect::SetRectEmpty()
	{ ::SetRectEmpty(this); }
_AFXWIN_INLINE void CRect::CopyRect(LPCRECT lpSrcRect)
	{ ::CopyRect(this, lpSrcRect); }
_AFXWIN_INLINE BOOL CRect::EqualRect(LPCRECT lpRect) const
	{ return ::EqualRect(this, lpRect); }
_AFXWIN_INLINE void CRect::InflateRect(int x, int y)
	{ ::InflateRect(this, x, y); }
_AFXWIN_INLINE void CRect::InflateRect(SIZE size)
	{ ::InflateRect(this, size.cx, size.cy); }
_AFXWIN_INLINE void CRect::OffsetRect(int x, int y)
	{ ::OffsetRect(this, x, y); }
_AFXWIN_INLINE void CRect::OffsetRect(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
_AFXWIN_INLINE void CRect::OffsetRect(SIZE size)
	{ ::OffsetRect(this, size.cx, size.cy); }
_AFXWIN_INLINE BOOL CRect::IntersectRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::IntersectRect(this, lpRect1, lpRect2);}
_AFXWIN_INLINE BOOL CRect::UnionRect(LPCRECT lpRect1, LPCRECT lpRect2)
	{ return ::UnionRect(this, lpRect1, lpRect2); }
_AFXWIN_INLINE void CRect::operator=(const RECT& srcRect)
	{ ::CopyRect(this, &srcRect); }
_AFXWIN_INLINE BOOL CRect::operator==(const RECT& rect) const
	{ return ::EqualRect(this, &rect); }
_AFXWIN_INLINE BOOL CRect::operator!=(const RECT& rect) const
	{ return !::EqualRect(this, &rect); }
_AFXWIN_INLINE void CRect::operator+=(POINT point)
	{ ::OffsetRect(this, point.x, point.y); }
_AFXWIN_INLINE void CRect::operator-=(POINT point)
	{ ::OffsetRect(this, -point.x, -point.y); }
_AFXWIN_INLINE void CRect::operator&=(const RECT& rect)
	{ ::IntersectRect(this, this, &rect); }
_AFXWIN_INLINE void CRect::operator|=(const RECT& rect)
	{ ::UnionRect(this, this, &rect); }
_AFXWIN_INLINE CRect CRect::operator+(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, pt.x, pt.y); return rect; }
_AFXWIN_INLINE CRect CRect::operator-(POINT pt) const
	{ CRect rect(*this); ::OffsetRect(&rect, -pt.x, -pt.y); return rect; }
_AFXWIN_INLINE CRect CRect::operator&(const RECT& rect2) const
	{ CRect rect; ::IntersectRect(&rect, this, &rect2);
		return rect; }
_AFXWIN_INLINE CRect CRect::operator|(const RECT& rect2) const
	{ CRect rect; ::UnionRect(&rect, this, &rect2);
		return rect; }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE BOOL CRect::SubtractRect(LPCRECT lpRectSrc1, LPCRECT lpRectSrc2)
	{ return ::SubtractRect(this, lpRectSrc1, lpRectSrc2); }
#endif // WINVER >= 0x030a

// CArchive output helpers
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, SIZE size)
	{ ar.Write(&size, sizeof(SIZE));
	return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, POINT point)
	{ ar.Write(&point, sizeof(POINT));
	return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator<<(CArchive& ar, const RECT& rect)
	{ ar.Write(&rect, sizeof(RECT));
	return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, SIZE& size)
	{ ar.Read(&size, sizeof(SIZE));
	return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, POINT& point)
	{ ar.Read(&point, sizeof(POINT));
	return ar; }
_AFXWIN_INLINE CArchive& AFXAPI operator>>(CArchive& ar, RECT& rect)
	{ ar.Read(&rect, sizeof(RECT));
	return ar; }


// exception support
_AFXWIN_INLINE CResourceException::CResourceException()
	{ }
_AFXWIN_INLINE CUserException::CUserException()
	{ }

// CString support (windows specific)
_AFXWIN_INLINE int CString::Compare(const char* psz) const
	{ return lstrcmp(m_pchData, psz); }
_AFXWIN_INLINE int CString::CompareNoCase(const char* psz) const
	{ return lstrcmpi(m_pchData, psz); }
_AFXWIN_INLINE int CString::Collate(const char* psz) const
	{ return lstrcmp(m_pchData, psz); } // lstrcmp does correct sort order
_AFXWIN_INLINE void CString::MakeUpper()
	{ ::AnsiUpper(m_pchData); }
_AFXWIN_INLINE void CString::MakeLower()
	{ ::AnsiLower(m_pchData); }

// CGdiObject
_AFXWIN_INLINE HGDIOBJ CGdiObject::GetSafeHandle() const
	{ return this == NULL ? NULL : m_hObject; }
_AFXWIN_INLINE CGdiObject::CGdiObject()
	{ m_hObject = NULL; }
_AFXWIN_INLINE int CGdiObject::GetObject(int nCount, LPVOID lpObject) const
	{ return ::GetObject(m_hObject, nCount, lpObject); }
_AFXWIN_INLINE BOOL CGdiObject::CreateStockObject(int nIndex)
	{ return (m_hObject = ::GetStockObject(nIndex)) != NULL; }
_AFXWIN_INLINE BOOL CGdiObject::UnrealizeObject()
	{ return ::UnrealizeObject(m_hObject); }

// CPen
_AFXWIN_INLINE CPen* PASCAL CPen::FromHandle(HPEN hPen)
	{ return (CPen*) CGdiObject::FromHandle(hPen); }
_AFXWIN_INLINE CPen::CPen()
	{ }
_AFXWIN_INLINE BOOL CPen::CreatePen(int nPenStyle, int nWidth, COLORREF crColor)
	{ return Attach(::CreatePen(nPenStyle, nWidth, crColor)); }
_AFXWIN_INLINE BOOL CPen::CreatePenIndirect(LPLOGPEN lpLogPen)
	{ return Attach(::CreatePenIndirect(lpLogPen)); }

// CBrush
_AFXWIN_INLINE CBrush* PASCAL CBrush::FromHandle(HBRUSH hBrush)
	{ return (CBrush*) CGdiObject::FromHandle(hBrush); }
_AFXWIN_INLINE CBrush::CBrush()
	{ }
_AFXWIN_INLINE BOOL CBrush::CreateSolidBrush(COLORREF crColor)
	{ return Attach(::CreateSolidBrush(crColor)); }
_AFXWIN_INLINE BOOL CBrush::CreateHatchBrush(int nIndex, COLORREF crColor)
	{ return Attach(::CreateHatchBrush(nIndex, crColor)); }
_AFXWIN_INLINE BOOL CBrush::CreateBrushIndirect(LPLOGBRUSH lpLogBrush)
	{ return Attach(::CreateBrushIndirect(lpLogBrush)); }
_AFXWIN_INLINE BOOL CBrush::CreateDIBPatternBrush(HGLOBAL hPackedDIB, UINT nUsage)
	{ return Attach(::CreateDIBPatternBrush(hPackedDIB, nUsage)); }
_AFXWIN_INLINE BOOL CBrush::CreatePatternBrush(CBitmap* pBitmap)
	{ return Attach(::CreatePatternBrush((HBITMAP)pBitmap->GetSafeHandle())); }

// CFont
_AFXWIN_INLINE CFont* PASCAL CFont::FromHandle(HFONT hFont)
	{ return (CFont*) CGdiObject::FromHandle(hFont); }
_AFXWIN_INLINE CFont::CFont()
	{ }
_AFXWIN_INLINE BOOL CFont::CreateFontIndirect(const LOGFONT FAR* lpLogFont)
	{ return Attach(::CreateFontIndirect(lpLogFont)); }
_AFXWIN_INLINE BOOL CFont::CreateFont(int nHeight, int nWidth, int nEscapement,
		int nOrientation, int nWeight, BYTE bItalic, BYTE bUnderline,
		BYTE cStrikeOut, BYTE nCharSet, BYTE nOutPrecision,
		BYTE nClipPrecision, BYTE nQuality, BYTE nPitchAndFamily,
		LPCSTR lpszFacename)
	{ return Attach(::CreateFont(nHeight, nWidth, nEscapement,
		nOrientation, nWeight, bItalic, bUnderline, cStrikeOut,
		nCharSet, nOutPrecision, nClipPrecision, nQuality,
		nPitchAndFamily, lpszFacename)); }

// CBitmap
_AFXWIN_INLINE CBitmap* PASCAL CBitmap::FromHandle(HBITMAP hBitmap)
	{ return (CBitmap*) CGdiObject::FromHandle(hBitmap); }
_AFXWIN_INLINE CBitmap::CBitmap()
	{ }
_AFXWIN_INLINE BOOL CBitmap::CreateBitmap(int nWidth, int nHeight, UINT nPlanes,
	 UINT nBitcount, const void FAR* lpBits)
	{ return Attach(::CreateBitmap(nWidth, nHeight, nPlanes, nBitcount, lpBits)); }
_AFXWIN_INLINE BOOL CBitmap::CreateBitmapIndirect(LPBITMAP lpBitmap)
	{ return Attach(::CreateBitmapIndirect(lpBitmap)); }

_AFXWIN_INLINE DWORD CBitmap::SetBitmapBits(DWORD dwCount, const void FAR* lpBits)
	{ return ::SetBitmapBits((HBITMAP)m_hObject, dwCount, lpBits); }
_AFXWIN_INLINE DWORD CBitmap::GetBitmapBits(DWORD dwCount, LPVOID lpBits) const
	{ return ::GetBitmapBits((HBITMAP)m_hObject, dwCount, lpBits); }
_AFXWIN_INLINE BOOL CBitmap::LoadBitmap(LPCSTR lpszResourceName)
	{ return Attach(::LoadBitmap(AfxGetResourceHandle(), lpszResourceName));}
_AFXWIN_INLINE CSize CBitmap::SetBitmapDimension(int nWidth, int nHeight)
	{ return ::SetBitmapDimension((HBITMAP)m_hObject, nWidth, nHeight); }
_AFXWIN_INLINE CSize CBitmap::GetBitmapDimension() const
	{ return ::GetBitmapDimension((HBITMAP)m_hObject); }

_AFXWIN_INLINE BOOL CBitmap::LoadBitmap(UINT nIDResource)
	{ return Attach(::LoadBitmap(AfxGetResourceHandle(),
	MAKEINTRESOURCE(nIDResource))); }
_AFXWIN_INLINE BOOL CBitmap::LoadOEMBitmap(UINT nIDBitmap)
	{ return Attach(::LoadBitmap(NULL, MAKEINTRESOURCE(nIDBitmap))); }
_AFXWIN_INLINE BOOL CBitmap::CreateCompatibleBitmap(CDC* pDC, int nWidth, int nHeight)
	{ return Attach(::CreateCompatibleBitmap(pDC->m_hDC, nWidth, nHeight)); }
_AFXWIN_INLINE BOOL CBitmap::CreateDiscardableBitmap(CDC* pDC, int nWidth, int nHeight)
	{ return Attach(::CreateDiscardableBitmap(pDC->m_hDC, nWidth, nHeight)); }

// CPalette
_AFXWIN_INLINE CPalette* PASCAL CPalette::FromHandle(HPALETTE hPalette)
	{ return (CPalette*) CGdiObject::FromHandle(hPalette); }
_AFXWIN_INLINE CPalette::CPalette()
	{ }
_AFXWIN_INLINE BOOL CPalette::CreatePalette(LPLOGPALETTE lpLogPalette)
	{ return Attach(::CreatePalette(lpLogPalette)); }
_AFXWIN_INLINE UINT CPalette::GetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors) const
	{ return ::GetPaletteEntries((HPALETTE)m_hObject, nStartIndex,
		nNumEntries, lpPaletteColors); }
_AFXWIN_INLINE UINT CPalette::SetPaletteEntries(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors)
	{ return ::SetPaletteEntries((HPALETTE)m_hObject, nStartIndex,
		nNumEntries, lpPaletteColors); }
_AFXWIN_INLINE void CPalette::AnimatePalette(UINT nStartIndex, UINT nNumEntries,
		LPPALETTEENTRY lpPaletteColors)
	{ ::AnimatePalette((HPALETTE)m_hObject, nStartIndex, nNumEntries,
		lpPaletteColors); }
_AFXWIN_INLINE UINT CPalette::GetNearestPaletteIndex(COLORREF crColor) const
	{ return ::GetNearestPaletteIndex((HPALETTE)m_hObject, crColor); }
_AFXWIN_INLINE BOOL CPalette::ResizePalette(UINT nNumEntries)
	{ return ::ResizePalette((HPALETTE)m_hObject, nNumEntries); }

// CRgn
_AFXWIN_INLINE CRgn* PASCAL CRgn::FromHandle(HRGN hRgn)
	{ return (CRgn*) CGdiObject::FromHandle(hRgn); }
_AFXWIN_INLINE CRgn::CRgn()
	{ }
_AFXWIN_INLINE BOOL CRgn::CreateRectRgn(int x1, int y1, int x2, int y2)
	{ return Attach(::CreateRectRgn(x1, y1, x2, y2)); }
_AFXWIN_INLINE BOOL CRgn::CreateRectRgnIndirect(LPCRECT lpRect)
	{ return Attach(::CreateRectRgnIndirect(lpRect)); }
_AFXWIN_INLINE BOOL CRgn::CreateEllipticRgn(int x1, int y1, int x2, int y2)
	{ return Attach(::CreateEllipticRgn(x1, y1, x2, y2)); }
_AFXWIN_INLINE BOOL CRgn::CreateEllipticRgnIndirect(LPCRECT lpRect)
	{ return Attach(::CreateEllipticRgnIndirect(lpRect)); }
_AFXWIN_INLINE BOOL CRgn::CreatePolygonRgn(LPPOINT lpPoints, int nCount, int nMode)
	{ return Attach(::CreatePolygonRgn(lpPoints, nCount, nMode)); }
_AFXWIN_INLINE BOOL CRgn::CreatePolyPolygonRgn(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount, int nPolyFillMode)
	{ return Attach(::CreatePolyPolygonRgn(lpPoints, lpPolyCounts, nCount, nPolyFillMode)); }
_AFXWIN_INLINE BOOL CRgn::CreateRoundRectRgn(int x1, int y1, int x2, int y2, int x3, int y3)
	{ return Attach(::CreateRoundRectRgn(x1, y1, x2, y2, x3, y3)); }
_AFXWIN_INLINE void CRgn::SetRectRgn(int x1, int y1, int x2, int y2)
	{ ::SetRectRgn((HRGN)m_hObject, x1, y1, x2, y2); }
_AFXWIN_INLINE void CRgn::SetRectRgn(LPCRECT lpRect)
	{ ::SetRectRgn((HRGN)m_hObject, lpRect->left, lpRect->top, lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE int CRgn::CombineRgn(CRgn* pRgn1, CRgn* pRgn2, int nCombineMode)
	{ return ::CombineRgn((HRGN)m_hObject, (HRGN)pRgn1->GetSafeHandle(),
		(HRGN)pRgn2->GetSafeHandle(), nCombineMode); }
_AFXWIN_INLINE int CRgn::CopyRgn(CRgn* pRgnSrc)
	{ return ::CombineRgn((HRGN)m_hObject, (HRGN)pRgnSrc->GetSafeHandle(), NULL, RGN_COPY); }
_AFXWIN_INLINE BOOL CRgn::EqualRgn(CRgn* pRgn) const
	{ return ::EqualRgn((HRGN)m_hObject, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE int CRgn::OffsetRgn(int x, int y)
	{ return ::OffsetRgn((HRGN)m_hObject, x, y); }
_AFXWIN_INLINE int CRgn::OffsetRgn(POINT point)
	{ return ::OffsetRgn((HRGN)m_hObject, point.x, point.y); }
_AFXWIN_INLINE int CRgn::GetRgnBox(LPRECT lpRect) const
	{ return ::GetRgnBox((HRGN)m_hObject, lpRect); }
_AFXWIN_INLINE BOOL CRgn::PtInRegion(int x, int y) const
	{ return ::PtInRegion((HRGN)m_hObject, x, y); }
_AFXWIN_INLINE BOOL CRgn::PtInRegion(POINT point) const
	{ return ::PtInRegion((HRGN)m_hObject, point.x, point.y); }
_AFXWIN_INLINE BOOL CRgn::RectInRegion(LPCRECT lpRect) const
	{ return ::RectInRegion((HRGN)m_hObject, lpRect); }

// CDC
_AFXWIN_INLINE HDC CDC::GetSafeHdc() const
	{ return this == NULL ? NULL : m_hDC; }
_AFXWIN_INLINE BOOL CDC::IsPrinting() const
	{ return m_bPrinting; }

_AFXWIN_INLINE BOOL CDC::CreateDC(LPCSTR lpszDriverName,
	LPCSTR lpszDeviceName, LPCSTR lpszOutput,
	const void FAR* lpInitData)
	{ return Attach(::CreateDC(lpszDriverName,
		lpszDeviceName, lpszOutput,
		lpInitData)); }
_AFXWIN_INLINE BOOL CDC::CreateIC(LPCSTR lpszDriverName,
	LPCSTR lpszDeviceName, LPCSTR lpszOutput,
	const void FAR* lpInitData)
	{ return Attach(::CreateIC(lpszDriverName,
		lpszDeviceName, lpszOutput,
		lpInitData)); }
_AFXWIN_INLINE BOOL CDC::CreateCompatibleDC(CDC* pDC)
	{ return Attach(::CreateCompatibleDC(pDC->GetSafeHdc())); }
_AFXWIN_INLINE int CDC::ExcludeUpdateRgn(CWnd* pWnd)
	{ return ::ExcludeUpdateRgn(m_hDC, pWnd->m_hWnd); }
_AFXWIN_INLINE int CDC::GetDeviceCaps(int nIndex) const
	{ return ::GetDeviceCaps(m_hAttribDC, nIndex); }
_AFXWIN_INLINE CPoint CDC::GetBrushOrg() const
	{ return ::GetBrushOrg(m_hDC); }
_AFXWIN_INLINE CPoint CDC::SetBrushOrg(int x, int y)
	{ return ::SetBrushOrg(m_hDC, x, y); }
_AFXWIN_INLINE CPoint CDC::SetBrushOrg(POINT point)
	{ return ::SetBrushOrg(m_hDC, point.x, point.y); }
_AFXWIN_INLINE int CDC::EnumObjects(int nObjectType,
	int (CALLBACK EXPORT* lpfn)(LPVOID, LPARAM), LPARAM lpData)
#ifdef STRICT
	{ return ::EnumObjects(m_hAttribDC, nObjectType, (GOBJENUMPROC)lpfn, lpData); }
#else
	{ return ::EnumObjects(m_hAttribDC, nObjectType, (GOBJENUMPROC)lpfn, (LPSTR)lpData); }
#endif


_AFXWIN_INLINE CBitmap* CDC::SelectObject(CBitmap* pBitmap)
	{ return (CBitmap*) SelectGdiObject(m_hDC, pBitmap->GetSafeHandle());}

_AFXWIN_INLINE HGDIOBJ CDC::SelectObject(HGDIOBJ hObject) // Safe for NULL handles
	{ ASSERT(m_hDC == m_hAttribDC); // ASSERT a simple CDC object
		return (hObject != NULL) ? ::SelectObject(m_hDC, hObject) : NULL; }

_AFXWIN_INLINE COLORREF CDC::GetNearestColor(COLORREF crColor) const
	{ return ::GetNearestColor(m_hAttribDC, crColor); }
_AFXWIN_INLINE UINT CDC::RealizePalette()
	{ return ::RealizePalette(m_hDC); }
_AFXWIN_INLINE void CDC::UpdateColors()
	{ ::UpdateColors(m_hDC); }
_AFXWIN_INLINE COLORREF CDC::GetBkColor() const
	{ return ::GetBkColor(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetBkMode() const
	{ return ::GetBkMode(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetPolyFillMode() const
	{ return ::GetPolyFillMode(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetROP2() const
	{ return ::GetROP2(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetStretchBltMode() const
	{ return ::GetStretchBltMode(m_hAttribDC); }
_AFXWIN_INLINE COLORREF CDC::GetTextColor() const
	{ return ::GetTextColor(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetMapMode() const
	{ return ::GetMapMode(m_hAttribDC); }

_AFXWIN_INLINE CPoint CDC::GetViewportOrg() const
	{ return ::GetViewportOrg(m_hAttribDC); }
_AFXWIN_INLINE CSize CDC::GetViewportExt() const
	{ return ::GetViewportExt(m_hAttribDC); }
_AFXWIN_INLINE CPoint CDC::GetWindowOrg() const
	{ return ::GetWindowOrg(m_hAttribDC); }
_AFXWIN_INLINE CSize CDC::GetWindowExt() const
	{ return ::GetWindowExt(m_hAttribDC); }
// non-virtual helpers calling virtual mapping functions
_AFXWIN_INLINE CPoint CDC::SetViewportOrg(POINT point)
	{ return SetViewportOrg(point.x, point.y); }
_AFXWIN_INLINE CSize CDC::SetViewportExt(SIZE size)
	{ return SetViewportExt(size.cx, size.cy); }
_AFXWIN_INLINE CPoint CDC::SetWindowOrg(POINT point)
	{ return SetWindowOrg(point.x, point.y); }
_AFXWIN_INLINE CSize CDC::SetWindowExt(SIZE size)
	{ return SetWindowExt(size.cx, size.cy); }

_AFXWIN_INLINE void CDC::DPtoLP(LPPOINT lpPoints, int nCount /* = 1 */) const
	{ VERIFY(::DPtoLP(m_hAttribDC, lpPoints, nCount)); }
_AFXWIN_INLINE void CDC::DPtoLP(LPRECT lpRect) const
	{ VERIFY(::DPtoLP(m_hAttribDC, (LPPOINT)lpRect, 2)); }
_AFXWIN_INLINE void CDC::LPtoDP(LPPOINT lpPoints, int nCount /* = 1 */) const
	{ VERIFY(::LPtoDP(m_hAttribDC, lpPoints, nCount)); }
_AFXWIN_INLINE void CDC::LPtoDP(LPRECT lpRect) const
	{ VERIFY(::LPtoDP(m_hAttribDC, (LPPOINT)lpRect, 2)); }

_AFXWIN_INLINE BOOL CDC::FillRgn(CRgn* pRgn, CBrush* pBrush)
	{ return ::FillRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::FrameRgn(CRgn* pRgn, CBrush* pBrush, int nWidth, int nHeight)
	{ return ::FrameRgn(m_hDC, (HRGN)pRgn->GetSafeHandle(), (HBRUSH)pBrush->GetSafeHandle(),
		nWidth, nHeight); }
_AFXWIN_INLINE BOOL CDC::InvertRgn(CRgn* pRgn)
	{ return ::InvertRgn(m_hDC, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::PaintRgn(CRgn* pRgn)
	{ return ::PaintRgn(m_hDC, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CDC::PtVisible(int x, int y) const
	{ return ::PtVisible(m_hDC, x, y); }
_AFXWIN_INLINE BOOL CDC::PtVisible(POINT point) const
	{ return PtVisible(point.x, point.y); } // call virtual
_AFXWIN_INLINE BOOL CDC::RectVisible(LPCRECT lpRect) const
	{ return ::RectVisible(m_hDC, lpRect); }
_AFXWIN_INLINE CPoint CDC::GetCurrentPosition() const
	{ return ::GetCurrentPosition(m_hAttribDC); }

_AFXWIN_INLINE CPoint CDC::MoveTo(POINT point)
	{ return MoveTo(point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::LineTo(POINT point)
	{ return LineTo(point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::Arc(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{ return ::Arc(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Arc(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ return ::Arc(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE BOOL CDC::Polyline(LPPOINT lpPoints, int nCount)
	{ return ::Polyline(m_hDC, lpPoints, nCount); }
_AFXWIN_INLINE void CDC::FillRect(LPCRECT lpRect, CBrush* pBrush)
	{ ::FillRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE void CDC::FrameRect(LPCRECT lpRect, CBrush* pBrush)
	{ ::FrameRect(m_hDC, lpRect, (HBRUSH)pBrush->GetSafeHandle()); }
_AFXWIN_INLINE void CDC::InvertRect(LPCRECT lpRect)
	{ ::InvertRect(m_hDC, lpRect); }
_AFXWIN_INLINE BOOL CDC::DrawIcon(int x, int y, HICON hIcon)
	{ return ::DrawIcon(m_hDC, x, y, hIcon); }
_AFXWIN_INLINE BOOL CDC::DrawIcon(POINT point, HICON hIcon)
	{ return ::DrawIcon(m_hDC, point.x, point.y, hIcon); }
_AFXWIN_INLINE BOOL CDC::Chord(int x1, int y1, int x2, int y2, int x3, int y3,
	int x4, int y4)
	{ return ::Chord(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Chord(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ return ::Chord(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE void CDC::DrawFocusRect(LPCRECT lpRect)
	{ ::DrawFocusRect(m_hDC, lpRect); }
_AFXWIN_INLINE BOOL CDC::Ellipse(int x1, int y1, int x2, int y2)
	{ return ::Ellipse(m_hDC, x1, y1, x2, y2); }
_AFXWIN_INLINE BOOL CDC::Ellipse(LPCRECT lpRect)
	{ return ::Ellipse(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE BOOL CDC::Pie(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4)
	{ return ::Pie(m_hDC, x1, y1, x2, y2, x3, y3, x4, y4); }
_AFXWIN_INLINE BOOL CDC::Pie(LPCRECT lpRect, POINT ptStart, POINT ptEnd)
	{ return ::Pie(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, ptStart.x, ptStart.y,
		ptEnd.x, ptEnd.y); }
_AFXWIN_INLINE BOOL CDC::Polygon(LPPOINT lpPoints, int nCount)
	{ return ::Polygon(m_hDC, lpPoints, nCount); }
_AFXWIN_INLINE BOOL CDC::PolyPolygon(LPPOINT lpPoints, LPINT lpPolyCounts, int nCount)
	{ return ::PolyPolygon(m_hDC, lpPoints, lpPolyCounts, nCount); }
_AFXWIN_INLINE BOOL CDC::Rectangle(int x1, int y1, int x2, int y2)
	{ return ::Rectangle(m_hDC, x1, y1, x2, y2); }
_AFXWIN_INLINE BOOL CDC::Rectangle(LPCRECT lpRect)
	{ return ::Rectangle(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom); }
_AFXWIN_INLINE BOOL CDC::RoundRect(int x1, int y1, int x2, int y2, int x3, int y3)
	{ return ::RoundRect(m_hDC, x1, y1, x2, y2, x3, y3); }
_AFXWIN_INLINE BOOL CDC::RoundRect(LPCRECT lpRect, POINT point)
	{ return ::RoundRect(m_hDC, lpRect->left, lpRect->top,
		lpRect->right, lpRect->bottom, point.x, point.y); }
_AFXWIN_INLINE BOOL CDC::PatBlt(int x, int y, int nWidth, int nHeight, DWORD dwRop)
	{ return ::PatBlt(m_hDC, x, y, nWidth, nHeight, dwRop); }
_AFXWIN_INLINE BOOL CDC::BitBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
	int xSrc, int ySrc, DWORD dwRop)
	{ return ::BitBlt(m_hDC, x, y, nWidth, nHeight,
		pSrcDC->GetSafeHdc(), xSrc, ySrc, dwRop); }
_AFXWIN_INLINE BOOL CDC::StretchBlt(int x, int y, int nWidth, int nHeight, CDC* pSrcDC,
	int xSrc, int ySrc, int nSrcWidth, int nSrcHeight, DWORD dwRop)
	{ return ::StretchBlt(m_hDC, x, y, nWidth, nHeight,
		pSrcDC->GetSafeHdc(), xSrc, ySrc, nSrcWidth, nSrcHeight,
		dwRop); }
_AFXWIN_INLINE COLORREF CDC::GetPixel(int x, int y) const
	{ return ::GetPixel(m_hDC, x, y); }
_AFXWIN_INLINE COLORREF CDC::GetPixel(POINT point) const
	{ return ::GetPixel(m_hDC, point.x, point.y); }
_AFXWIN_INLINE COLORREF CDC::SetPixel(int x, int y, COLORREF crColor)
	{ return ::SetPixel(m_hDC, x, y, crColor); }
_AFXWIN_INLINE COLORREF CDC::SetPixel(POINT point, COLORREF crColor)
	{ return ::SetPixel(m_hDC, point.x, point.y, crColor); }
_AFXWIN_INLINE BOOL CDC::FloodFill(int x, int y, COLORREF crColor)
	{ return ::FloodFill(m_hDC, x, y, crColor); }
_AFXWIN_INLINE BOOL CDC::ExtFloodFill(int x, int y, COLORREF crColor, UINT nFillType)
	{ return ::ExtFloodFill(m_hDC, x, y, crColor, nFillType); }
_AFXWIN_INLINE BOOL CDC::TextOut(int x, int y, LPCSTR lpszString, int nCount)
	{ return ::TextOut(m_hDC, x, y, lpszString, nCount); }
_AFXWIN_INLINE BOOL CDC::TextOut(int x, int y, const CString& str)
	{ return TextOut(x, y, (const char*)str, str.GetLength()); } // call virtual
_AFXWIN_INLINE BOOL CDC::ExtTextOut(int x, int y, UINT nOptions, LPCRECT lpRect,
	LPCSTR lpszString, UINT nCount, LPINT lpDxWidths)
	{ return ::ExtTextOut(m_hDC, x, y, nOptions, lpRect,
		lpszString, nCount, lpDxWidths); }
_AFXWIN_INLINE CSize CDC::TabbedTextOut(int x, int y, LPCSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions, int nTabOrigin)
	{ return ::TabbedTextOut(m_hDC, x, y, lpszString, nCount,
		nTabPositions, lpnTabStopPositions, nTabOrigin); }
_AFXWIN_INLINE int CDC::DrawText(LPCSTR lpszString, int nCount, LPRECT lpRect,
		UINT nFormat)
	{ return ::DrawText(m_hDC, lpszString, nCount, lpRect, nFormat); }
_AFXWIN_INLINE CSize CDC::GetTextExtent(LPCSTR lpszString, int nCount) const
	{ return ::GetTextExtent(m_hAttribDC, lpszString, nCount); }
_AFXWIN_INLINE CSize CDC::GetOutputTextExtent(LPCSTR lpszString, int nCount) const
	{ return ::GetTextExtent(m_hDC, lpszString, nCount); }
_AFXWIN_INLINE CSize CDC::GetTabbedTextExtent(LPCSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions) const
	{ return ::GetTabbedTextExtent(m_hAttribDC, lpszString, nCount,
		nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE CSize CDC::GetOutputTabbedTextExtent(LPCSTR lpszString, int nCount,
	int nTabPositions, LPINT lpnTabStopPositions) const
	{ return ::GetTabbedTextExtent(m_hDC, lpszString, nCount,
		nTabPositions, lpnTabStopPositions); }
_AFXWIN_INLINE BOOL CDC::GrayString(CBrush* pBrush,
	BOOL (CALLBACK EXPORT* lpfnOutput)(HDC, LPARAM, int),
		LPARAM lpData, int nCount,
		int x, int y, int nWidth, int nHeight)
	{ return ::GrayString(m_hDC, (HBRUSH)pBrush->GetSafeHandle(),
		(GRAYSTRINGPROC)lpfnOutput, lpData, nCount, x, y, nWidth, nHeight); }
_AFXWIN_INLINE UINT CDC::GetTextAlign() const
	{ return ::GetTextAlign(m_hAttribDC); }
_AFXWIN_INLINE int CDC::GetTextFace(int nCount, LPSTR lpszFacename) const
	{ return ::GetTextFace(m_hAttribDC, nCount, lpszFacename); }
_AFXWIN_INLINE BOOL CDC::GetTextMetrics(LPTEXTMETRIC lpMetrics) const
	{ return ::GetTextMetrics(m_hAttribDC, lpMetrics); }
_AFXWIN_INLINE BOOL CDC::GetOutputTextMetrics(LPTEXTMETRIC lpMetrics) const
	{ return ::GetTextMetrics(m_hDC, lpMetrics); }
_AFXWIN_INLINE int CDC::GetTextCharacterExtra() const
	{ return ::GetTextCharacterExtra(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::GetCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{ return ::GetCharWidth(m_hAttribDC, nFirstChar, nLastChar, lpBuffer); }
_AFXWIN_INLINE BOOL CDC::GetOutputCharWidth(UINT nFirstChar, UINT nLastChar, LPINT lpBuffer) const
	{ return ::GetCharWidth(m_hDC, nFirstChar, nLastChar, lpBuffer); }
_AFXWIN_INLINE CSize CDC::GetAspectRatioFilter() const
	{ return ::GetAspectRatioFilter(m_hAttribDC); }
_AFXWIN_INLINE BOOL CDC::ScrollDC(int dx, int dy,
		LPCRECT lpRectScroll, LPCRECT lpRectClip,
		CRgn* pRgnUpdate, LPRECT lpRectUpdate)
	{ return ::ScrollDC(m_hDC, dx, dy, lpRectScroll,
		lpRectClip, (HRGN)pRgnUpdate->GetSafeHandle(), lpRectUpdate); }
_AFXWIN_INLINE BOOL CDC::PlayMetaFile(HMETAFILE hMF)
	{ return ::PlayMetaFile(m_hDC, hMF); }

// Printer Escape Functions
_AFXWIN_INLINE int CDC::Escape(int nEscape, int nCount, LPCSTR lpszInData, LPVOID lpOutData)
	{ return ::Escape(m_hDC, nEscape, nCount, lpszInData, lpOutData);}

// CDC 3.1 Specific functions
#if (WINVER >= 0x030a)
_AFXWIN_INLINE BOOL CDC::QueryAbort() const
	{ return ::QueryAbort(m_hDC, 0); }
_AFXWIN_INLINE UINT CDC::SetBoundsRect(LPCRECT lpRectBounds, UINT flags)
	{ return ::SetBoundsRect(m_hDC, lpRectBounds, flags); }
_AFXWIN_INLINE UINT CDC::GetBoundsRect(LPRECT lpRectBounds, UINT flags)
	{ return ::GetBoundsRect(m_hAttribDC, lpRectBounds, flags); }
_AFXWIN_INLINE BOOL CDC::ResetDC(const DEVMODE FAR* lpDevMode)
	{ return ::ResetDC(m_hAttribDC, lpDevMode) != NULL; }
_AFXWIN_INLINE UINT CDC::GetOutlineTextMetrics(UINT cbData, LPOUTLINETEXTMETRIC lpotm) const
	{ return ::GetOutlineTextMetrics(m_hAttribDC, cbData, lpotm); }
_AFXWIN_INLINE BOOL CDC::GetCharABCWidths(UINT nFirst, UINT nLast, LPABC lpabc) const
	{ return ::GetCharABCWidths(m_hAttribDC, nFirst, nLast, lpabc); }
_AFXWIN_INLINE DWORD CDC::GetFontData(DWORD dwTable, DWORD dwOffset, LPVOID lpData,
	DWORD cbData) const
	{ return ::GetFontData(m_hAttribDC, dwTable, dwOffset, lpData, cbData); }
_AFXWIN_INLINE int CDC::GetKerningPairs(int nPairs, LPKERNINGPAIR lpkrnpair) const
	{ return ::GetKerningPairs(m_hAttribDC, nPairs, lpkrnpair); }
_AFXWIN_INLINE DWORD CDC::GetGlyphOutline(UINT nChar, UINT nFormat, LPGLYPHMETRICS lpgm,
		DWORD cbBuffer, LPVOID lpBuffer, const MAT2 FAR* lpmat2) const
	{ return ::GetGlyphOutline(m_hAttribDC, nChar, nFormat,
			lpgm, cbBuffer, lpBuffer, lpmat2); }
#endif // WINVER >= 0x030a

// CMenu
_AFXWIN_INLINE CMenu::CMenu()
	{ m_hMenu = NULL; }
_AFXWIN_INLINE BOOL CMenu::CreateMenu()
	{ return Attach(::CreateMenu()); }
_AFXWIN_INLINE BOOL CMenu::CreatePopupMenu()
	{ return Attach(::CreatePopupMenu()); }
_AFXWIN_INLINE HMENU CMenu::GetSafeHmenu() const
	{ return this == NULL ? NULL : m_hMenu; }
_AFXWIN_INLINE BOOL CMenu::DeleteMenu(UINT nPosition, UINT nFlags)
	{ return ::DeleteMenu(m_hMenu, nPosition, nFlags); }
_AFXWIN_INLINE BOOL CMenu::AppendMenu(UINT nFlags, UINT nIDNewItem /* = 0 */, LPCSTR lpszNewItem /* = NULL */)
	{ return ::AppendMenu(m_hMenu, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::AppendMenu(UINT nFlags, UINT nIDNewItem, const CBitmap* pBmp)
	{ return ::AppendMenu(m_hMenu, nFlags | MF_BITMAP, nIDNewItem,
		MAKEINTRESOURCE(pBmp->GetSafeHandle())); }
_AFXWIN_INLINE UINT CMenu::CheckMenuItem(UINT nIDCheckItem, UINT nCheck)
	{ return ::CheckMenuItem(m_hMenu, nIDCheckItem, nCheck); }
_AFXWIN_INLINE UINT CMenu::EnableMenuItem(UINT nIDEnableItem, UINT nEnable)
	{ return ::EnableMenuItem(m_hMenu, nIDEnableItem, nEnable); }
_AFXWIN_INLINE UINT CMenu::GetMenuItemCount() const
	{ return ::GetMenuItemCount(m_hMenu); }
_AFXWIN_INLINE UINT CMenu::GetMenuItemID(int nPos) const
	{ return ::GetMenuItemID(m_hMenu, nPos); }
_AFXWIN_INLINE UINT CMenu::GetMenuState(UINT nID, UINT nFlags) const
	{ return ::GetMenuState(m_hMenu, nID, nFlags); }
_AFXWIN_INLINE int CMenu::GetMenuString(UINT nIDItem, LPSTR lpString, int nMaxCount, UINT nFlags) const
	{ return ::GetMenuString(m_hMenu, nIDItem, lpString, nMaxCount, nFlags); }
_AFXWIN_INLINE CMenu* CMenu::GetSubMenu(int nPos) const
	{ return CMenu::FromHandle(::GetSubMenu(m_hMenu, nPos)); }
_AFXWIN_INLINE BOOL CMenu::InsertMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem /* = 0 */,
		LPCSTR lpszNewItem /* = NULL */)
	{ return ::InsertMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::InsertMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem, const CBitmap* pBmp)
	{ return ::InsertMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem,
		MAKEINTRESOURCE(pBmp->GetSafeHandle())); }
_AFXWIN_INLINE BOOL CMenu::ModifyMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem /* = 0 */, LPCSTR lpszNewItem /* = NULL */)
	{ return ::ModifyMenu(m_hMenu, nPosition, nFlags, nIDNewItem, lpszNewItem); }
_AFXWIN_INLINE BOOL CMenu::ModifyMenu(UINT nPosition, UINT nFlags, UINT nIDNewItem, const CBitmap* pBmp)
	{ return ::ModifyMenu(m_hMenu, nPosition, nFlags | MF_BITMAP, nIDNewItem,
		MAKEINTRESOURCE(pBmp->GetSafeHandle())); }
_AFXWIN_INLINE BOOL CMenu::RemoveMenu(UINT nPosition, UINT nFlags)
	{ return ::RemoveMenu(m_hMenu, nPosition, nFlags); }
_AFXWIN_INLINE BOOL CMenu::SetMenuItemBitmaps(UINT nPosition, UINT nFlags,
		const CBitmap* pBmpUnchecked, const CBitmap* pBmpChecked)
	{ return ::SetMenuItemBitmaps(m_hMenu, nPosition, nFlags,
		(HBITMAP)pBmpUnchecked->GetSafeHandle(),
		(HBITMAP)pBmpChecked->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CMenu::LoadMenu(LPCSTR lpszResourceName)
	{ return Attach(::LoadMenu(AfxGetResourceHandle(), lpszResourceName)); }
_AFXWIN_INLINE BOOL CMenu::LoadMenu(UINT nIDResource)
	{ return Attach(::LoadMenu(AfxGetResourceHandle(),
			MAKEINTRESOURCE(nIDResource))); }
_AFXWIN_INLINE BOOL CMenu::LoadMenuIndirect(const void FAR* lpMenuTemplate)
	{ return Attach(::LoadMenuIndirect(lpMenuTemplate)); }

// CCmdUI
_AFXWIN_INLINE void CCmdUI::ContinueRouting()
	{ m_bContinueRouting = TRUE; }

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\mfc\include\afxsock.inl ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXSOCK.H

#ifdef _AFXSOCK_INLINE

_AFXSOCK_INLINE BOOL CAsyncSocket::GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
		{ return (SOCKET_ERROR != getpeername(m_hSocket, lpSockAddr, lpSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
		{ return (SOCKET_ERROR != getsockname(m_hSocket, lpSockAddr, lpSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::SetSockOpt(int nOptionName, const void* lpOptionValue, int nOptionLen, int nLevel)
		{ return (SOCKET_ERROR != setsockopt(m_hSocket, nLevel, nOptionName, (LPCSTR)lpOptionValue, nOptionLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::GetSockOpt(int nOptionName, void* lpOptionValue, int* lpOptionLen, int nLevel)
		{ return (SOCKET_ERROR != getsockopt(m_hSocket, nLevel, nOptionName, (LPSTR)lpOptionValue, lpOptionLen)); }
_AFXSOCK_INLINE CAsyncSocket* PASCAL CAsyncSocket::FromHandle(SOCKET hSocket)
		{ return CAsyncSocket::LookupHandle(hSocket, FALSE); }
_AFXSOCK_INLINE int CAsyncSocket::GetLastError()
		{ return WSAGetLastError(); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Bind(const SOCKADDR* lpSockAddr, int nSockAddrLen)
		{ return (SOCKET_ERROR != bind(m_hSocket, lpSockAddr, nSockAddrLen)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen)
		{ return ConnectHelper(lpSockAddr, nSockAddrLen); }
_AFXSOCK_INLINE BOOL CAsyncSocket::IOCtl(long lCommand, DWORD* lpArgument)
		{ *lpArgument = 0; return (SOCKET_ERROR != ioctlsocket(m_hSocket, lCommand, lpArgument)); }
_AFXSOCK_INLINE BOOL CAsyncSocket::Listen(int nConnectionBacklog)
		{ return (SOCKET_ERROR != listen(m_hSocket, nConnectionBacklog)); }
_AFXSOCK_INLINE int CAsyncSocket::ReceiveFrom(void FAR* lpBuf, int nBufLen, SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags)
		{ return ReceiveFromHelper(lpBuf, nBufLen, lpSockAddr, lpSockAddrLen, nFlags); }
_AFXSOCK_INLINE BOOL CAsyncSocket::ShutDown(int nHow)
		{ return (SOCKET_ERROR != shutdown(m_hSocket,nHow)); }
_AFXSOCK_INLINE int CAsyncSocket::SendTo(const void FAR* lpBuf, int nBufLen, const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags)
		{ return SendToHelper(lpBuf, nBufLen, lpSockAddr, nSockAddrLen, nFlags); }

_AFXSOCK_INLINE BOOL CSocket::Create(UINT nSocketPort, int nSocketType, LPCTSTR lpszSocketAddress)
		{ return CAsyncSocket::Create(nSocketPort, nSocketType,	FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE, lpszSocketAddress); }
_AFXSOCK_INLINE BOOL CSocket::IsBlocking()
		{ return (m_pbBlocking != NULL); }
_AFXSOCK_INLINE CSocket* PASCAL 	CSocket::FromHandle(SOCKET hSocket)
		{ return (CSocket*)CAsyncSocket::LookupHandle(hSocket, FALSE); }
_AFXSOCK_INLINE BOOL CSocket::Attach(SOCKET hSocket)
		{ return CAsyncSocket::Attach(hSocket); }

#endif //_AFXSOCK_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\mfc\include\afxsock.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1994 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __AFXSOCK_H__
#define __AFXSOCK_H__

#ifdef _AFX_NO_SOCKET_SUPPORT
	#error Windows Sockets classes not supported in this library variant.
#endif

#ifndef __AFXWIN_H__
	#include <afxwin.h>
#endif

#include <winsock.h>

/////////////////////////////////////////////////////////////////////////////
// AFXSOCK - MFC support for Windows Sockets

// Classes declared in this file

	// CObject
		class CAsyncSocket; // Async Socket implementation and
                            // base class for Synchronous Socket
		    class CSocket;  // Synchronous Socket

	// CFile
		class CSocketFile; // Used with CSocket and CArchive for
		                   // streaming objects on sockets.

/////////////////////////////////////////////////////////////////////////////

// AFXDLL support
#undef AFXAPP_DATA
#define AFXAPP_DATA AFXAPIEX_DATA

/////////////////////////////////////////////////////////////////////////////
// CSocketWnd -- internal use only
//  Implementation for sockets notification callbacks.
//  Future versions of MFC may or may not include this exact class.

class CSocketWnd : public CWnd
{
// Construction
public:
	CSocketWnd();

// Implementation
public:
	virtual ~CSocketWnd();

friend CAsyncSocket;

protected:
	//{{AFX_MSG(CSocketWnd)
	LRESULT OnSocketNotify(WPARAM wParam, LPARAM lParam);
	LRESULT OnSocketDead(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CAsyncSocket

class CAsyncSocket : public CObject
{
	DECLARE_DYNAMIC(CAsyncSocket);
private:
	CAsyncSocket(const CAsyncSocket& rSrc);    // no implementation
	void operator=(const CAsyncSocket& rSrc);  // no implementation

// Construction
public:
	CAsyncSocket();
	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM, 
		long lEvent = FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		LPCTSTR lpszSocketAddress = NULL);

// Attributes
public:
	SOCKET m_hSocket;

	BOOL Attach(SOCKET hSocket, long lEvent = 
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);
	SOCKET Detach();

	BOOL GetPeerName(CString& rPeerAddress, UINT& rPeerPort);
	BOOL GetPeerName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);

	BOOL GetSockName(CString& rSocketAddress, UINT& rSocketPort);
	BOOL GetSockName(SOCKADDR* lpSockAddr, int* lpSockAddrLen);

	BOOL SetSockOpt(int nOptionName, const void* lpOptionValue,
		int nOptionLen, int nLevel = SOL_SOCKET);
	BOOL GetSockOpt(int nOptionName, void* lpOptionValue,
		int* lpOptionLen, int nLevel = SOL_SOCKET);

	static CAsyncSocket* PASCAL FromHandle(SOCKET hSocket);
	static int GetLastError();

// Operations
public:

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);

	BOOL Bind(UINT nSocketPort, LPCTSTR lpszSocketAddress = NULL);
	BOOL Bind(const SOCKADDR* lpSockAddr, int nSockAddrLen);

	virtual void Close();

	BOOL Connect(LPCTSTR lpszHostAddress, UINT nHostPort);
	BOOL Connect(const SOCKADDR* lpSockAddr, int nSockAddrLen);

	BOOL IOCtl(long lCommand, DWORD* lpArgument);

	BOOL Listen(int nConnectionBacklog=5);

	virtual int Receive(void FAR* lpBuf, int nBufLen, int nFlags = 0);

	int ReceiveFrom(void FAR* lpBuf, int nBufLen, 
		CString& rSocketAddress, UINT& rSocketPort, int nFlags = 0);
	int ReceiveFrom(void FAR* lpBuf, int nBufLen, 
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags = 0);

	enum { receives = 0, sends = 1, both = 2 };
	BOOL ShutDown(int nHow=sends);

	virtual int Send(const void FAR* lpBuf, int nBufLen, int nFlags = 0);

	int SendTo(const void FAR* lpBuf, int nBufLen, 
		UINT nHostPort, LPCTSTR lpszHostAddress = NULL, int nFlags = 0);
	int SendTo(const void FAR* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags = 0);

	BOOL AsyncSelect(long lEvent = 
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE);

// Overridable callbacks
protected:
	virtual void OnReceive(int nErrorCode);
	virtual void OnSend(int nErrorCode);
	virtual void OnOutOfBandData(int nErrorCode);
	virtual void OnAccept(int nErrorCode);
	virtual void OnConnect(int nErrorCode);
	virtual void OnClose(int nErrorCode);

// Implementation
public:
	virtual ~CAsyncSocket();

	static CAsyncSocket* PASCAL LookupHandle(SOCKET hSocket, BOOL bDead = FALSE);
	static void PASCAL AttachHandle(SOCKET hSocket, CAsyncSocket* pSocket, BOOL bDead = FALSE);
	static void PASCAL DetachHandle(SOCKET hSocket, BOOL bDead = FALSE);
	static void PASCAL KillSocket(SOCKET hSocket, CAsyncSocket* pSocket);
	static void PASCAL DoCallBack(WPARAM wParam, LPARAM lParam);

	BOOL Socket(int nSocketType=SOCK_STREAM, long lEvent = 
		FD_READ | FD_WRITE | FD_OOB | FD_ACCEPT | FD_CONNECT | FD_CLOSE,
		int nProtocolType = 0, int nAddressFormat = PF_INET);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:
	friend class CSocketWnd;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void FAR* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void FAR* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);
};

/////////////////////////////////////////////////////////////////////////////
// CSocket

class CSocket : public CAsyncSocket
{
	DECLARE_DYNAMIC(CSocket);
private:
	CSocket(const CSocket& rSrc);         // no implementation
	void operator=(const CSocket& rSrc);  // no implementation

// Construction
public:
	CSocket();
	BOOL Create(UINT nSocketPort = 0, int nSocketType=SOCK_STREAM, 
		LPCTSTR lpszSocketAddress = NULL);

// Attributes
public:
	BOOL IsBlocking();
	static CSocket* PASCAL FromHandle(SOCKET hSocket);
	BOOL Attach(SOCKET hSocket);

// Operations
public:
	void CancelBlockingCall();

// Overridable callbacks
protected:
	virtual BOOL OnMessagePending();

// Implementation
public:
	int m_nTimeOut;

	virtual ~CSocket();

	static int PASCAL ProcessAuxQueue();

	virtual BOOL Accept(CAsyncSocket& rConnectedSocket,
		SOCKADDR* lpSockAddr = NULL, int* lpSockAddrLen = NULL);
	virtual void Close();
	virtual int Receive(void FAR* lpBuf, int nBufLen, int nFlags = 0);
	virtual int Send(const void FAR* lpBuf, int nBufLen, int nFlags = 0);

	int SendChunk(const void FAR* lpBuf, int nBufLen, int nFlags);

protected:
	BOOL* m_pbBlocking;
	int m_nConnectError;

	virtual BOOL ConnectHelper(const SOCKADDR* lpSockAddr, int nSockAddrLen);
	virtual int ReceiveFromHelper(void FAR* lpBuf, int nBufLen,
		SOCKADDR* lpSockAddr, int* lpSockAddrLen, int nFlags);
	virtual int SendToHelper(const void FAR* lpBuf, int nBufLen,
		const SOCKADDR* lpSockAddr, int nSockAddrLen, int nFlags);

	static void PASCAL AuxQueueAdd(UINT message, WPARAM wParam, LPARAM lParam);

	virtual BOOL PumpMessages(UINT uStopFlag);

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
};

/////////////////////////////////////////////////////////////////////////////
// CSocketFile

class CSocketFile : public CFile
{
	DECLARE_DYNAMIC(CSocketFile)
public:
//Constructors
	CSocketFile(CSocket* pSocket, BOOL bArchiveCompatible = TRUE);

// Implementation
public:
	CSocket* m_pSocket;
	BOOL m_bArchiveCompatible;

	virtual ~CSocketFile();

#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	virtual UINT Read(void FAR* lpBuf, UINT nCount);
	virtual void Write(const void FAR* lpBuf, UINT nCount);
	virtual void Close();

// Unsupported APIs
	virtual BOOL Open(LPCTSTR lpszFileName, UINT nOpenFlags, CFileException* pError = NULL);
	virtual CFile* Duplicate() const;
	virtual DWORD GetPosition() const;
	virtual LONG Seek(LONG lOff, UINT nFrom);
	virtual void SetLength(DWORD dwNewLen);
	virtual DWORD GetLength() const;
	virtual void LockRange(DWORD dwPos, DWORD dwCount);
	virtual void UnlockRange(DWORD dwPos, DWORD dwCount);
	virtual void Flush();
	virtual void Abort();
};

/////////////////////////////////////////////////////////////////////////////
// Global functions

BOOL AfxSocketInit(WSADATA* lpwsaData = NULL);

/////////////////////////////////////////////////////////////////////////////
// Inline function declarations

#ifdef _AFX_ENABLE_INLINES
#define _AFXSOCK_INLINE inline
#include <afxsock.inl>
#undef _AFXSOCK_INLINE
#endif

#undef AFXAPP_DATA
#define AFXAPP_DATA     NEAR

#endif // __AFXSOCK_H__

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\faxapip.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    faxapi.h

Abstract:

    This module contains all includes to the FAX client DLL.  All
    objects in this DLL should include this header only.

Author:

    Wesley Witt (wesw) 12-Jan-1996

--*/

#define _WINFAX_

#include <windows.h>
#include <shellapi.h>
#include <winspool.h>

#include <rpc.h>
#include <tapi.h>
#include <tapi3if.h>

#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <shlobj.h>

#include "jobtag.h"
#include "faxreg.h"
#include "prtcovpg.h"
#include "faxutil.h"
#include "faxrpc.h"
#include "faxcli.h"
#include "faxext.h"
#include "faxsvcrg.h"
#include "rpcutil.h"
#include "tiff.h"
#include "tifflib.h"

#include "fxsapip.h"
#include "devmode.h"
#include "shlwapi.h"
#include "FaxRpcLimit.h"

typedef enum
{
    FHT_SERVICE,            // Handle to server (FaxConnectFaxServer)
    FHT_PORT,               // Port Handle (FaxOpenPort)
    FHT_MSGENUM             // Message enumeration handle (FaxStartMessagesEnum)
} FaxHandleType;


#define TAPI_LIBRARY                         TEXT("%systemroot%\\system32\\tapi32.dll")
#define ARGUMENT_PRESENT(ArgumentPointer)    ((CHAR *)(ArgumentPointer) != (CHAR *)(NULL))

#define FixupStringPtr(_buf,_str) \
    if (_str)  \
    {          \
       LPTSTR * lpptstr = (LPTSTR *)&(_str) ; \
       *lpptstr = (LPTSTR)((LPBYTE)(*(_buf))  + (ULONG_PTR)(_str)); \
    }

#define FixupStringPtrW(_buf,_str) \
    if (_str)  \
    {          \
       LPWSTR * lppwstr = (LPWSTR *)&(_str) ; \
       *lppwstr = (LPWSTR)((LPBYTE)(*(_buf))  + (ULONG_PTR)(_str)); \
    }
//
// typedefs
//
typedef int (*FaxConnFunction)(LPTSTR,handle_t*);

#define FH_PORT_HANDLE(_phe)     (((PHANDLE_ENTRY)(_phe))->hGeneric)
#define FH_MSG_ENUM_HANDLE(_phe) (((PHANDLE_ENTRY)(_phe))->hGeneric)
#define FH_FAX_HANDLE(_phe)      (((PHANDLE_ENTRY)(_phe))->FaxData->FaxHandle)
#define FH_SERVER_VER(_phe)      (((PHANDLE_ENTRY)(_phe))->FaxData->dwServerAPIVersion)
#define FH_REPORTED_SERVER_VER(_phe)  (((PHANDLE_ENTRY)(_phe))->FaxData->dwReportedServerAPIVersion)
#define FH_CONTEXT_HANDLE(_phe)  (((PHANDLE_ENTRY)(_phe))->FaxContextHandle)
#define FH_DATA(_phe)            (((PHANDLE_ENTRY)(_phe))->FaxData)
#define ValidateFaxHandle(_phe,_type)   ((_phe && \
                                          *(LPDWORD)_phe && \
                                          (((PHANDLE_ENTRY)_phe)->Type == _type)) ? TRUE : FALSE)

typedef struct _FAX_HANDLE_DATA {
    HANDLE              FaxHandle;                       // Fax handle obtained from FaxClientBindToFaxServer()
    LIST_ENTRY          HandleTableListHead;             //
    CRITICAL_SECTION    CsHandleTable;                   // Critical section to protect concurrent access
    DWORD               dwRefCount;                      // Usage reference counter
    LPTSTR              MachineName;                     // The server machine name (NULL for local server)
    DWORD               dwServerAPIVersion;              // The API version of the server we're connected to (filtered)
    DWORD               dwReportedServerAPIVersion;      // The API version of the server we're connected to (non-filtered)
    BOOL                bLocalConnection;                // Indicates that this connection to fax server is local

} FAX_HANDLE_DATA, *PFAX_HANDLE_DATA;

typedef struct _HANDLE_ENTRY {
    LIST_ENTRY          ListEntry;                       // linked list pointers
    FaxHandleType       Type;                            // handle type, see FHT defines
    DWORD               Flags;                           // open flags
    DWORD               DeviceId;                        // device id
    PFAX_HANDLE_DATA    FaxData;                         // pointer to connection data
    HANDLE              hGeneric;                        // Generic handle to store
    HANDLE              FaxContextHandle;                // context handle for refcounting
                                                         // (for FaxConnectFaxServer, obtained from FAX_ConnectionRefCount)
} HANDLE_ENTRY, *PHANDLE_ENTRY;

#define ASYNC_EVENT_INFO_SIGNATURE TEXT("KukiMuki")
#define ASYNC_EVENT_INFO_SIGNATURE_LEN sizeof(ASYNC_EVENT_INFO_SIGNATURE)/sizeof(TCHAR)+1

typedef struct _ASYNC_EVENT_INFO 
{
    TCHAR               tszSignature[ASYNC_EVENT_INFO_SIGNATURE_LEN];   // Security signature
    HANDLE              CompletionPort;                  // Completion port handle
    ULONG_PTR           CompletionKey;                   // Completion key
    HWND                hWindow;                         // Window handle
    UINT                MessageStart;                    // Application's base window message
    BOOL                bEventEx;                        // Flag that indicates to use FAX_EVENT_EX
    BOOL                bLocalNotificationsOnly;         // client registration for local events only
    handle_t            hBinding;                        // RPC client binding handle
    BOOL                bInUse;                          // Indicates that this ASYNC_EVENT_INFO was already processed in Fax_OpenConnection
    DWORD               dwServerAPIVersion;              // The API version of the server we're connected to (filtered)
} ASYNC_EVENT_INFO, *PASYNC_EVENT_INFO;

//
// prototypes
//

VOID
CloseFaxHandle(
    PHANDLE_ENTRY       pHandleEntry
    );

PHANDLE_ENTRY
CreateNewServiceHandle(
    PFAX_HANDLE_DATA    FaxData
    );

PHANDLE_ENTRY
CreateNewPortHandle(
    PFAX_HANDLE_DATA    FaxData,
    DWORD               Flags,
    HANDLE              FaxPortHandle
    );

PHANDLE_ENTRY
CreateNewMsgEnumHandle(
    PFAX_HANDLE_DATA    pFaxData
);


BOOL
ConvertUnicodeStringInPlace(
    LPCWSTR UnicodeString
    );

LPTSTR
GetFaxPrinterName(
    HANDLE hFax
    );

BOOL
IsLocalFaxConnection(
    HANDLE FaxHandle
    );

//
// Fax Client RPC Client
//

DWORD
FaxClientBindToFaxServer (
    IN  LPCTSTR               lpctstrServerName,
    IN  LPCTSTR               lpctstrServiceName,
    IN  LPCTSTR               lpctstrNetworkOptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    );

DWORD
FaxClientUnbindFromFaxServer(
    IN  RPC_BINDING_HANDLE BindingHandle
    );

BOOL
FaxClientInitRpcServer(
    VOID
    );

VOID
FaxClientTerminateRpcServer(
    VOID
    );


//
// Fax Client RPC Server
//

DWORD
StartFaxClientRpcServer(
    VOID  
    );

DWORD
StopFaxClientRpcServer(
    VOID
    );


VOID
DumpRPCExtendedStatus ();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\clirpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    clirpc.c

Abstract:

    This module contains the client side RPC
    functions.  These functions are used when the
    WINFAX client runs as an RPC server too.  These
    functions are the ones available for the RPC
    clients to call.  Currently the only client
    of these functions is the fax service.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#include "CritSec.h"
#pragma hdrstop

extern CFaxCriticalSection g_CsFaxAssyncInfo; // used to synchronize access to the assync info structures (notification context)
extern DWORD g_dwFaxClientRpcNumInst;
extern TCHAR g_tszEndPoint[MAX_ENDPOINT_LEN];

static const ASYNC_EVENT_INFO g_scBadAsyncInfo = {0};   // this ASYNC_EVENT_INFO structure will be used as a return value for
                                                        // malicious RPC calls.

BOOL
ValidAsyncInfoSignature (PASYNC_EVENT_INFO pAsyncInfo);




VOID
WINAPI
FaxFreeBuffer(
    LPVOID Buffer
    )
{
    MemFree( Buffer );
}


void *
MIDL_user_allocate(
    IN size_t NumBytes
    )
{
    return MemAlloc( NumBytes );
}


void
MIDL_user_free(
    IN void *MemPointer
    )
{
    MemFree( MemPointer );
}


BOOL
WINAPI
FaxStartServerNotification (
        IN  HANDLE      hFaxHandle,
        IN  DWORD       dwEventTypes,
        IN  HANDLE      hCompletionPort,
        IN  ULONG_PTR   upCompletionKey,
        IN  HWND        hWnd,
        IN  DWORD       dwMessage,
        IN  BOOL        bEventEx,
        OUT LPHANDLE    lphEvent
)
{
    PASYNC_EVENT_INFO AsyncInfo = NULL;
    error_status_t ec = ERROR_SUCCESS;
    TCHAR ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    WCHAR ComputerNameW[MAX_COMPUTERNAME_LENGTH + 1];
    WCHAR wszEndPoint[MAX_ENDPOINT_LEN] = {0};
    DWORD Size;
    BOOL RpcServerStarted = FALSE;
    HANDLE         hServerContext;    	
    DEBUG_FUNCTION_NAME(TEXT("FaxStartServerNotification"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
       return FALSE;
    }

    if ((hCompletionPort && hWnd) || (!hCompletionPort && !hWnd))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        DebugPrintEx(DEBUG_ERR, _T("(hCompletionPort && hWnd) || (!hCompletionPort && !hWnd)."));
        return FALSE;
    }

#ifdef WIN95
    if (NULL != hCompletionPort)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Win95 does not support completion port"));
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }
#endif // WIN95

    if (hWnd && dwMessage < WM_USER)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("dwMessage must be equal to/greater than  WM_USER"));
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (TRUE == bEventEx)
    {
        if (!((dwEventTypes & FAX_EVENT_TYPE_IN_QUEUE)      ||
              (dwEventTypes & FAX_EVENT_TYPE_OUT_QUEUE)     ||
              (dwEventTypes & FAX_EVENT_TYPE_CONFIG)        ||
              (dwEventTypes & FAX_EVENT_TYPE_ACTIVITY)      ||
              (dwEventTypes & FAX_EVENT_TYPE_QUEUE_STATE)   ||
              (dwEventTypes & FAX_EVENT_TYPE_IN_ARCHIVE)    ||
              (dwEventTypes & FAX_EVENT_TYPE_OUT_ARCHIVE)   ||
              (dwEventTypes & FAX_EVENT_TYPE_FXSSVC_ENDED)  ||
              (dwEventTypes & FAX_EVENT_TYPE_DEVICE_STATUS) ||
              (dwEventTypes & FAX_EVENT_TYPE_NEW_CALL)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwEventTypes is invalid - No valid event type indicated"));
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }

        if ( 0 != (dwEventTypes & ~(FAX_EVENT_TYPE_IN_QUEUE     |
                                    FAX_EVENT_TYPE_OUT_QUEUE    |
                                    FAX_EVENT_TYPE_CONFIG       |
                                    FAX_EVENT_TYPE_ACTIVITY     |
                                    FAX_EVENT_TYPE_QUEUE_STATE  |
                                    FAX_EVENT_TYPE_IN_ARCHIVE   |
                                    FAX_EVENT_TYPE_OUT_ARCHIVE  |
                                    FAX_EVENT_TYPE_FXSSVC_ENDED |
                                    FAX_EVENT_TYPE_DEVICE_STATUS|
                                    FAX_EVENT_TYPE_NEW_CALL     ) ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("dwEventTypes is invalid - contains invalid event type bits"));
            SetLastError( ERROR_INVALID_PARAMETER );
            return FALSE;
        }
    }
    else
    {
        Assert (FAX_EVENT_TYPE_LEGACY == dwEventTypes);
    }
    
    //
    // Get host name
    //
    Size = sizeof(ComputerName) / sizeof(TCHAR);
    if (!GetComputerName( ComputerName, &Size ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetComputerName failed (ec = %ld)"),
            GetLastError());
        return FALSE;
    }

    AsyncInfo = (PASYNC_EVENT_INFO) MemAlloc( sizeof(ASYNC_EVENT_INFO) );
    if (!AsyncInfo)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't allocate ASTNC_EVENT_INFO"));
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    _tcscpy (AsyncInfo->tszSignature, ASYNC_EVENT_INFO_SIGNATURE);
    AsyncInfo->bEventEx       = bEventEx;
    AsyncInfo->CompletionPort = NULL;
    AsyncInfo->hWindow        = NULL;
    AsyncInfo->hBinding       = NULL;
    AsyncInfo->bLocalNotificationsOnly = FH_DATA(hFaxHandle)->bLocalConnection; //  Fax client asked for notification from local or remote fax service.
    AsyncInfo->bInUse         = FALSE;
    AsyncInfo->dwServerAPIVersion = FH_DATA(hFaxHandle)->dwServerAPIVersion; // Fax server API version.

    if (hCompletionPort != NULL)
    {
        //
        // Completion port notifications
        //
        AsyncInfo->CompletionPort = hCompletionPort;
        AsyncInfo->CompletionKey  = upCompletionKey;
    }
    else
    {
        //
        // Window messages notifications
        //
        AsyncInfo->hWindow = hWnd;
        AsyncInfo->MessageStart = dwMessage;
    }
    Assert ((NULL != AsyncInfo->CompletionPort &&  NULL == AsyncInfo->hWindow) ||
            (NULL == AsyncInfo->CompletionPort &&  NULL != AsyncInfo->hWindow));
    //
    // We rely on the above assertion when validating the 'Context' parameter (points to this AssyncInfo structure) in
    // Fax_OpenConnection.
    //


    //
    // timing: get the server thread up and running before
    // registering with the fax service (our client)
    //

    ec = StartFaxClientRpcServer();
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartFaxClientRpcServer failed (ec = %ld)"),
            ec);
        goto error_exit;
    }
    RpcServerStarted = TRUE;
    Assert (_tcslen(g_tszEndPoint));

#ifdef UNICODE
    wcscpy(ComputerNameW,ComputerName);
    wcscpy(wszEndPoint, g_tszEndPoint);
#else // !UNICODE
    if (0 == MultiByteToWideChar(CP_ACP,
                                 MB_PRECOMPOSED,
                                 ComputerName,
                                 -1,
                                 ComputerNameW,
                                 sizeof(ComputerNameW)/sizeof(ComputerNameW[0])))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MultiByteToWideChar failed (ec = %ld)"),
            ec);
        goto error_exit;
    }

    if (0 == MultiByteToWideChar(CP_ACP,
                                 MB_PRECOMPOSED,
                                 g_tszEndPoint,
                                 -1,
                                 wszEndPoint,
                                 sizeof(wszEndPoint)/sizeof(wszEndPoint[0])))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MultiByteToWideChar failed (ec = %ld)"),
            ec);
        goto error_exit;
    }
#endif // UNICODE


    //
    // Register at the fax server for events
    //
    __try
    {   
        ec = FAX_StartServerNotificationEx(
            FH_FAX_HANDLE(hFaxHandle),
            ComputerNameW,  // Passed to create RPC binding
            (LPCWSTR)wszEndPoint,       // Passed to create RPC binding
            (ULONG64) AsyncInfo, // Passed to the server,
            // the server passes it back to the client with FAX_OpenConnection,
            // and the client returns it back to the server as a context handle.
            L"ncacn_ip_tcp",     // For BOS interoperability it must be set to "ncacn_ip_tcp"
            bEventEx,            // flag to use FAX_EVENT_EX
            dwEventTypes,        // used in FAX_EVENT_EX
            &hServerContext      // returns a context handle to the client.
            );    
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_StartServerNotification/Ex. (ec: %ld)"),
            ec);
    }
    
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_StartServerNotification/Ex failed (ec = %ld)"),
            ec);
        goto error_exit;
    }


    if (TRUE == bEventEx)
    {
        *lphEvent = hServerContext;
    }

    return TRUE;

error_exit:

    MemFree(AsyncInfo);
    AsyncInfo = NULL;

    if (RpcServerStarted)
    {
        //
        // this should also terminate FaxServerThread
        //
        StopFaxClientRpcServer();
    }

    SetLastError(ec);
    return FALSE;
}


BOOL
WINAPI
FaxRegisterForServerEvents (
        IN  HANDLE      hFaxHandle,
        IN  DWORD       dwEventTypes,
        IN  HANDLE      hCompletionPort,
        IN  ULONG_PTR   upCompletionKey,
        IN  HWND        hWnd,
        IN  DWORD       dwMessage,
        OUT LPHANDLE    lphEvent
)
{
    return FaxStartServerNotification ( hFaxHandle,
                                        dwEventTypes,
                                        hCompletionPort,
                                        upCompletionKey,
                                        hWnd,
                                        dwMessage,
                                        TRUE,  // extended API
                                        lphEvent
                                      );

}

BOOL
WINAPI
FaxInitializeEventQueue(
    IN HANDLE FaxHandle,
    IN HANDLE CompletionPort,
    IN ULONG_PTR upCompletionKey,
    IN HWND hWnd,
    IN UINT MessageStart
    )

/*++

Routine Description:

    Initializes the client side event queue.  There can be one event
    queue initialized for each fax server that the client app is
    connected to.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    CompletionPort  - Handle of an existing completion port opened using CreateIoCompletionPort.
    upCompletionKey - A value that will be returned through the upCompletionKey parameter of GetQueuedCompletionStatus.
    hWnd            - Window handle to post events to
    MessageStart    - Starting message number, message range used is MessageStart + FEI_NEVENTS

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    if (hWnd && (upCompletionKey == -1))
    //
    // Backwards compatibility only.
    // See "Receiving Notification Messages from the Fax Service" on MSDN
    //

    {
        return TRUE;
    }

    return FaxStartServerNotification ( FaxHandle,
                                        FAX_EVENT_TYPE_LEGACY,  //Event type
                                        CompletionPort,
                                        upCompletionKey,
                                        hWnd,
                                        MessageStart,
                                        FALSE, // Event Ex
                                        NULL   // Context handle
                                      );
}


BOOL
WINAPI
FaxUnregisterForServerEvents (
        IN  HANDLE      hEvent
)
/*++

Routine name : FaxUnregisterForServerEvents

Routine description:

    A fax client application calls the FaxUnregisterForServerEvents function to stop
    recieving notification.

Author:

    Oded Sacher (OdedS), Dec, 1999

Arguments:

    hEvent   [in] - The enumeration handle value.
                    This value is obtained by calling FaxRegisterForServerEvents.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FaxUnregisterForServerEvents"));

    if (NULL == hEvent)
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("hEvent is NULL."));
        return FALSE;
    }

    __try
    {
        //
        // Attempt to tell the server we are shutting down this notification context
        //
        ec = FAX_EndServerNotification (&hEvent);     // this will free Assync info
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EndServerNotification. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        DebugPrintEx(DEBUG_ERR, _T("FAX_EndServerNotification failed. (ec: %ld)"), ec);
    }
    
    ec = StopFaxClientRpcServer();
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StopFaxClientRpcServer failed. (ec: %ld)"),
            ec);
    }
    
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
        return FALSE;
    }
    return TRUE;
}   // FaxUnregisterForServerEvents

BOOL
ValidAsyncInfoSignature (PASYNC_EVENT_INFO pAsyncInfo)
{
    if (NULL == pAsyncInfo)
	{		
		return FALSE;
	}
    if (&g_scBadAsyncInfo == pAsyncInfo)
    {
        //
        //  We are under attack!
        //
        return FALSE;
    }
    if (_tcscmp (pAsyncInfo->tszSignature, ASYNC_EVENT_INFO_SIGNATURE))
    {
        return FALSE;
    }
    return TRUE;
}   // ValidAsyncInfoSignature

error_status_t
FAX_OpenConnection(
   IN handle_t  hBinding,
   IN ULONG64   Context,
   OUT LPHANDLE FaxHandle
   )
{
    PASYNC_EVENT_INFO pAsyncInfo = (PASYNC_EVENT_INFO) Context;
    DWORD ec = ERROR_SUCCESS;	
    DEBUG_FUNCTION_NAME(TEXT("FAX_OpenConnection"));	

    EnterCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    //
    //  Try to access the AssyncInfo structure pointed by 'Context' to verify it is not corrupted.
    //
    if (IsBadReadPtr(
            pAsyncInfo,                 // memory address,
            sizeof(ASYNC_EVENT_INFO)    // size of block
        ))
    {
        //
        // We are under attack!!!
        //
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid AssyncInfo structure pointed by 'Context'. We are under attack!!!!"));
        ec = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Looks good, Let's do some more verifications.
    //
    __try
    {
        if ((NULL == pAsyncInfo->CompletionPort && NULL == pAsyncInfo->hWindow) ||
            (NULL != pAsyncInfo->CompletionPort && NULL != pAsyncInfo->hWindow)) 
        {
            //
            // Invalid AssyncInfo structure pointed by 'Context'. We are under attack!!!!
            //
            ec = ERROR_INVALID_PARAMETER;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid AssyncInfo structure pointed by 'Context'. We are under attack!!!!"));
            goto exit;
        }
        if (!ValidAsyncInfoSignature(pAsyncInfo))
        {
            //
            // Signature mismatch. We are under attack!!!!
            //
            ec = ERROR_INVALID_PARAMETER;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid AssyncInfo siganture pointed by 'Context'. We are under attack!!!!"));
            goto exit;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception when trying to access the AssyncInfo structure (ec: %ld)"),
            ec);
        goto exit;
    }

    Assert (ERROR_SUCCESS == ec);

    if (pAsyncInfo->bInUse)
    {
        //
        //  This AsynchInfo is already used by another notifier (server). We are under attack!!!!
        //
        ec = ERROR_INVALID_PARAMETER;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("This AsynchInfo is already used by another notifier (server). We are under attack!!!!"));
        goto exit;
    }
    
    //
    //  Mark this AsynchInfo as being used.
    //
    pAsyncInfo->bInUse = TRUE;

    if (IsWinXPOS() &&
        pAsyncInfo->dwServerAPIVersion > FAX_API_VERSION_1)
    {
        //  We are running on XP or later OS, and
        //  talking to fax server running on OS later then XP   (.NET and later), 
        //  we require at least packet-level privacy  (RPC_C_AUTHN_LEVEL_PKT_PRIVACY). 
        //
        RPC_AUTHZ_HANDLE hPrivs;
        DWORD dwAuthn;
        RPC_STATUS status = RPC_S_OK; 

        //
        //  Query the client's authentication level
        //
        status = RpcBindingInqAuthClient(
			        hBinding,
			        &hPrivs,
			        NULL,
			        &dwAuthn,
			        NULL,
			        NULL);
	    if (status != RPC_S_OK) 
        {
		    DebugPrintEx(DEBUG_ERR,
                        TEXT("RpcBindingInqAuthClient returned: 0x%x"), 
                        status);
		    ec = ERROR_ACCESS_DENIED;
            goto exit;
	    }

        //
	    //  Now check the authentication level.
	    //  We require at least packet-level privacy  (RPC_C_AUTHN_LEVEL_PKT_PRIVACY).
        //
	    if (dwAuthn < RPC_C_AUTHN_LEVEL_PKT_PRIVACY) 
        {
		    DebugPrintEx(DEBUG_ERR,
                        TEXT("Attempt by client to use weak authentication. - 0x%x"),
                        dwAuthn);
		    ec = ERROR_ACCESS_DENIED;
            goto exit;
	    }
    }
    else
    {
        //
        //  Talking to Fax service running on pre .NET OS, allow anonymous connection
        //
        DebugPrintEx(DEBUG_WRN,
                     TEXT("Talking to Fax server, with anonymous RPC connection."));
    }

    //
    //  hBinding is a valid context handle pointing to a real ASYNC_EVENT_INFO object.
    //  Save the binding handle for other RPC calls.
    //
    pAsyncInfo->hBinding = hBinding;

    if ( pAsyncInfo->bLocalNotificationsOnly )
    {
        //
        //  Client asked for local events only
        //
        BOOL bIsLocal = FALSE;

        ec = IsLocalRPCConnectionIpTcp(hBinding,&bIsLocal);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("IsLocalRPCConnectionIpTcp failed. (ec: %lu)"),
                ec);
            *FaxHandle = NULL;
            LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
            return ec;
        }
        else
        {
            if (FALSE == bIsLocal)
            {
                //
                //  Client asked for local events only but the call is from remote location. We are under attack!!!!
                //
                ec = ERROR_INVALID_PARAMETER;
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Client asked for local events only. We are under attack!!!!"));
                goto exit;
            }
        }
    }

    Assert (ERROR_SUCCESS == ec);

exit:

    if (ERROR_SUCCESS == ec)
    {
        *FaxHandle = (HANDLE) Context;
    }
    else
    {
        //
        //  Probably we are under attack, The notification RPC functions should not fail if a wrong (read: malicious) 
        //  notification context arrives. 
        //	Instead, it should report success but not process notifications from that AsyncInfo object. 
        //
        //	This will make it very hard for an attacker to scan the 4G context range and detect the 
        //  right context for bogus notifications.
        //
        *FaxHandle = (HANDLE)&g_scBadAsyncInfo ;
        ec = ERROR_SUCCESS;
    }
    LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    
    return ec;
}


error_status_t
FAX_CloseConnection(
   OUT LPHANDLE pFaxHandle
   )
{
    PASYNC_EVENT_INFO pAsyncInfo = (PASYNC_EVENT_INFO) *pFaxHandle;
    error_status_t ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("FAX_CloseConnection"));

    EnterCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    
    if (!ValidAsyncInfoSignature(pAsyncInfo))
    {
        //
        //  Probably we are under attack, The notification RPC functions should not fail if a wrong (read: malicious) 
        //  notification context arrives. 
        //	Instead, it should report success but not process notifications from that AsyncInfo object. 
        //
        //	This will make it very hard for an attacker to scan the 4G context range and detect the 
        //  right context for bogus notifications.
        //

        DebugPrintEx(DEBUG_ERR, TEXT("Invalid AssyncInfo signature. We are under attack!!!!"));

        //
        //  Don't report the error to the malicious user!
        //
        ec = ERROR_SUCCESS;
        goto exit;
    }

    if ( pAsyncInfo->bLocalNotificationsOnly)
    {
        //
        //  Client asked for local events only
        //
        BOOL bIsLocal = FALSE;

        ec = IsLocalRPCConnectionIpTcp(pAsyncInfo->hBinding,&bIsLocal);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("IsLocalRPCConnectionIpTcp failed. (ec: %lu)"),
                ec);
            goto exit;
        }
        else
        {
            if (FALSE == bIsLocal)
            {
                //
                //  Client asked for local events only but the call is from remote location. We are under attack!!!!
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Client asked for local events only. We are under attack!!!!"));

                //
                //  Don't report the error to the malicious user!
                //
                ec = ERROR_SUCCESS;
                goto exit;
            }
        }
    }


    ZeroMemory (*pFaxHandle, sizeof(ASYNC_EVENT_INFO));
    MemFree (*pFaxHandle); // Assync info
    *pFaxHandle = NULL;  // prevent rundown
   
exit:
    LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    return ec;
}


error_status_t
FAX_ClientEventQueue(
    IN HANDLE FaxHandle,
    IN FAX_EVENT FaxEvent
    )
/*++

Routine Description:

    This function is called when the a fax server wants
    to deliver a fax event to this client.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FaxEvent        - FAX event structure.
    Context         - Context token, really a ASYNC_EVENT_INFO structure pointer

Return Value:

    Win32 error code.

--*/

{
    PASYNC_EVENT_INFO AsyncInfo = (PASYNC_EVENT_INFO) FaxHandle;
    error_status_t ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_ClientEventQueue"));

    EnterCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    if (!ValidAsyncInfoSignature(AsyncInfo))
    {
        //
        //  Probably we are under attack, The notification RPC functions should not fail if a wrong (read: malicious) 
        //  notification context arrives. 
        //	Instead, it should report success but not process notifications from that AsyncInfo object. 
        //
        //	This will make it very hard for an attacker to scan the 4G context range and detect the 
        //  right context for bogus notifications.
        //

        DebugPrintEx(DEBUG_ERR, TEXT("Invalid AssyncInfo signature"));

        //
        //  Don't report the error to the malicious user!
        //
        ec = ERROR_SUCCESS;
        goto exit;
    }   

    if ( AsyncInfo->bLocalNotificationsOnly)
    {
        //
        //  Client asked for local events only
        //
        BOOL bIsLocal = FALSE;

        ec = IsLocalRPCConnectionIpTcp(AsyncInfo->hBinding,&bIsLocal);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("IsLocalRPCConnectionIpTcp failed. (ec: %lu)"),
                ec);
            goto exit;
        }
        else
        {
            if (FALSE == bIsLocal)
            {
                //
                //  Client asked for local events only but the call is from remote location. We are under attack!!!!
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Client asked for local events only. We are under attack!!!!"));

                //
                //  Don't report the error to the malicious user!
                //
                ec = ERROR_SUCCESS;
                goto exit;
            }
        }
    }


    if (AsyncInfo->CompletionPort != NULL)
    {
        //
        // Use completion port
        //
        PFAX_EVENT FaxEventPost = NULL;

        FaxEventPost = (PFAX_EVENT) LocalAlloc( LMEM_FIXED, sizeof(FAX_EVENT) );
        if (!FaxEventPost)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        CopyMemory( FaxEventPost, &FaxEvent, sizeof(FAX_EVENT) );

        if (!PostQueuedCompletionStatus(
                                        AsyncInfo->CompletionPort,
                                        sizeof(FAX_EVENT),
                                        AsyncInfo->CompletionKey,
                                        (LPOVERLAPPED) FaxEventPost))
        {
            ec = GetLastError();
            DebugPrint(( TEXT("PostQueuedCompletionStatus failed, ec = %d\n"), ec ));
            LocalFree (FaxEventPost);
            goto exit;
        }
        goto exit;
    }

    Assert (AsyncInfo->hWindow != NULL)
    //
    // Use window messages
    //
    if (! PostMessage( AsyncInfo->hWindow,
                       AsyncInfo->MessageStart + FaxEvent.EventId,
                       (WPARAM)FaxEvent.DeviceId,
                       (LPARAM)FaxEvent.JobId ))
    {
        ec = GetLastError();
        DebugPrint(( TEXT("PostMessage failed, ec = %d\n"), ec ));
        goto exit;
    }
    
exit:
    LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    return ec;
}

DWORD
DispatchEvent (
    const ASYNC_EVENT_INFO* pAsyncInfo,
    const FAX_EVENT_EX* pEvent,
    DWORD dwEventSize
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("DispatchEvent"));

    Assert (pAsyncInfo && pEvent && dwEventSize);

    if (pAsyncInfo->CompletionPort != NULL)
    {
        //
        // Use completion port
        //
        if (!PostQueuedCompletionStatus( pAsyncInfo->CompletionPort,
                                         dwEventSize,
                                         pAsyncInfo->CompletionKey,
                                         (LPOVERLAPPED) pEvent))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("PostQueuedCompletionStatus failed (ec: %ld)"),
                   dwRes);
            goto exit;
        }
    }
    else
    {
        Assert (pAsyncInfo->hWindow != NULL)
        //
        // Use window messages
        //
        if (! PostMessage( pAsyncInfo->hWindow,
                           pAsyncInfo->MessageStart,
                           (WPARAM)NULL,
                           (LPARAM)pEvent ))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("PostMessage failed (ec: %ld)"),
                   dwRes);
            goto exit;
        }
    }

    Assert (ERROR_SUCCESS == dwRes);
exit:
    return dwRes;
}  // DispatchEvent



void
PostRundownEventEx (
PASYNC_EVENT_INFO pAsyncInfo
    )
{
    PFAX_EVENT_EX pEvent = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwEventSize = sizeof(FAX_EVENT_EX);
    DEBUG_FUNCTION_NAME(TEXT("PostRundownEventEx"));

    Assert (pAsyncInfo);

    pEvent = (PFAX_EVENT_EX)MemAlloc (dwEventSize);
    if (NULL == pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostRundownEventEx failed , Error allocatin FAX_EVENT_EX"));
        return;
    }

    ZeroMemory(pEvent, dwEventSize);
    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );
    pEvent->EventType = FAX_EVENT_TYPE_FXSSVC_ENDED;

    dwRes = DispatchEvent (pAsyncInfo, pEvent, dwEventSize);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR, _T("DispatchEvent failed , ec = %ld"), dwRes);
        MemFree (pEvent);
    }
}   // PostRundownEventEx


VOID
RPC_FAX_HANDLE_rundown(
    IN HANDLE FaxHandle
    )
{
    PASYNC_EVENT_INFO pAsyncInfo = (PASYNC_EVENT_INFO) FaxHandle;
    DWORD dwRes = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_HANDLE_rundown"));

    EnterCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    if (!ValidAsyncInfoSignature(pAsyncInfo))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Invalid AssyncInfo signature"));
        LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
        return;
    }        

    Assert (pAsyncInfo->CompletionPort || pAsyncInfo->hWindow);

    if (pAsyncInfo->bEventEx == TRUE)
    {
        PostRundownEventEx(pAsyncInfo);
    }
    else
    {
       // legacy event - FAX_EVENT
        if (pAsyncInfo->CompletionPort != NULL)
        {
            PFAX_EVENT pFaxEvent;

            pFaxEvent = (PFAX_EVENT) LocalAlloc( LMEM_FIXED, sizeof(FAX_EVENT) );
            if (!pFaxEvent)
            {
                goto exit;
            }

            pFaxEvent->SizeOfStruct      = sizeof(ASYNC_EVENT_INFO);
            GetSystemTimeAsFileTime( &pFaxEvent->TimeStamp );
            pFaxEvent->DeviceId = 0;
            pFaxEvent->EventId  = FEI_FAXSVC_ENDED;
            pFaxEvent->JobId    = 0;


            if( !PostQueuedCompletionStatus (pAsyncInfo->CompletionPort,
                                        sizeof(FAX_EVENT),
                                        pAsyncInfo->CompletionKey,
                                        (LPOVERLAPPED) pFaxEvent
                                        ) )

            {
                dwRes = GetLastError();
                DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("PostQueuedCompletionStatus failed (ec: %ld)"),
                       dwRes);
                LocalFree (pFaxEvent);
                goto exit;
            }
        }

        if (pAsyncInfo->hWindow != NULL)
        {
            PostMessage (pAsyncInfo->hWindow,
                         pAsyncInfo->MessageStart + FEI_FAXSVC_ENDED,
                         0,
                         0);
        }
    }

exit:
	ZeroMemory(pAsyncInfo, sizeof(ASYNC_EVENT_INFO));
    MemFree (pAsyncInfo);
    LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo    
    return;
}


BOOL
ValidateAndFixupEventStringPtr (
    PFAX_EVENT_EXW  pEventEx,
    LPCWSTR        *lpptstrString,
    DWORD           dwDataSize
)
/*++

Routine Description:

    This function validates that the string offest in a FAX_EVENT_EXW structure
    is completely contained within the event structure data range.
    Once this is validated, the function converts the offest to a valid string pointer.

Arguments:

    pEventEx        [in] -       Pointer to the fax event structure.
    lpptstrString   [in / out] - Pointer to string offset, later converted to the string itself.
    dwDataSize      [in] -       Size of the event blob (bytes)

Return Value:

    Win32 error code.

--*/
{
    LPCWSTR lpcwstrString = *lpptstrString;
    if (!lpcwstrString)
    {
        return TRUE;
    }
    //
    // Make sure the offest falls within the structure size
    //
    if ((ULONG_PTR)lpcwstrString >= dwDataSize)
    {
        return FALSE;
    }
    //
    // Convert offset to string
    //
    *lpptstrString = (LPCWSTR)((LPBYTE)pEventEx + (ULONG_PTR)lpcwstrString);
    lpcwstrString = *lpptstrString;
    if ((ULONG_PTR)lpcwstrString < (ULONG_PTR)pEventEx)
    {
        return FALSE;
    }
    //
    // Make sure string ends within the event structure bounds
    //
    while (*lpcwstrString != TEXT('\0'))
    {
        lpcwstrString++;
        if (lpcwstrString >= (LPCWSTR)((LPBYTE)pEventEx + dwDataSize))
        {
            //
            // Going to exceed structure - corrupted offset
            //
            return FALSE;
        }
    }
    return TRUE;
}   // ValidateAndFixupEventStringPtr   


error_status_t
FAX_ClientEventQueueEx(
   IN RPC_FAX_HANDLE    hClientContext,
   IN const LPBYTE      lpbData,
   IN DWORD             dwDataSize
   )
{
    PASYNC_EVENT_INFO pAsyncInfo = (PASYNC_EVENT_INFO) hClientContext;
    PFAX_EVENT_EXW pEvent = NULL;
    PFAX_EVENT_EXA pEventA = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_ClientEventQueueEx"));

    Assert (pAsyncInfo && lpbData && dwDataSize);

    EnterCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    if (!ValidAsyncInfoSignature(pAsyncInfo))
    {
        //
        //  Probably we are under attack, The notification RPC functions should not fail if a wrong (read: malicious) 
        //  notification context arrives. 
        //	Instead, it should report success but not process notifications from that AsyncInfo object. 
        //
        //	This will make it very hard for an attacker to scan the 4G context range and detect the 
        //  right context for bogus notifications.
        //

        DebugPrintEx(DEBUG_ERR, TEXT("Invalid AssyncInfo signature"));

        //
        //  Don't report the error to the malicious user!
        //
        dwRes = ERROR_SUCCESS;

        LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
        goto exit;
    }

    if ( pAsyncInfo->bLocalNotificationsOnly )
    {
        //
        //  Client asked for local events only
        //
        BOOL bIsLocal = FALSE;

        dwRes = IsLocalRPCConnectionIpTcp(pAsyncInfo->hBinding,&bIsLocal);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("IsLocalRPCConnectionIpTcp failed. (ec: %lu)"),
                dwRes);

            LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
            goto exit;
        }
        else
        {
            if (FALSE == bIsLocal)
            {
                //
                //  Client asked for local events only but the call is from remote location. We are under attack!!!!
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Client asked for local events only. We are under attack!!!!"));

                //
                //  Don't report the error to the malicious user!
                //
                dwRes = ERROR_SUCCESS;

                LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
                goto exit;
            }
        }
    }

    LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo


  	//
	// IMPORTANT - Do not use pAsyncInfo before validating it again with ValidAsyncInfoSignature().
	// 

    pEvent = (PFAX_EVENT_EXW)MemAlloc (dwDataSize);
    if (NULL == pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin FAX_EVENT_EX"));
        return ERROR_OUTOFMEMORY;
    }
    CopyMemory (pEvent, lpbData, dwDataSize);

    if(pEvent->EventType == FAX_EVENT_TYPE_NEW_CALL)
    {
        if (!ValidateAndFixupEventStringPtr (pEvent, 
                                             (LPCWSTR *)&(pEvent->EventInfo).NewCall.lptstrCallerId,
                                             dwDataSize))
        {
            dwRes = ERROR_INVALID_DATA;
            goto exit;
        }
    }

    if ( (pEvent->EventType == FAX_EVENT_TYPE_IN_QUEUE  ||
           pEvent->EventType == FAX_EVENT_TYPE_OUT_QUEUE)    &&
         ((pEvent->EventInfo).JobInfo.Type == FAX_JOB_EVENT_TYPE_STATUS) )
    {
        //
        // Unpack FAX_EVENT_EX
        //
        Assert ((pEvent->EventInfo).JobInfo.pJobData);

        (pEvent->EventInfo).JobInfo.pJobData = (PFAX_JOB_STATUSW)
                                                ((LPBYTE)pEvent +
                                                 (ULONG_PTR)((pEvent->EventInfo).JobInfo.pJobData));

        if (!ValidateAndFixupEventStringPtr (pEvent, 
                                             &((pEvent->EventInfo).JobInfo.pJobData->lpctstrExtendedStatus),
                                             dwDataSize) ||
            !ValidateAndFixupEventStringPtr (pEvent, 
                                             &((pEvent->EventInfo).JobInfo.pJobData->lpctstrTsid),
                                             dwDataSize)           ||
            !ValidateAndFixupEventStringPtr (pEvent, 
                                             &((pEvent->EventInfo).JobInfo.pJobData->lpctstrCsid),
                                             dwDataSize)           ||
            !ValidateAndFixupEventStringPtr (pEvent, 
                                             &((pEvent->EventInfo).JobInfo.pJobData->lpctstrDeviceName),
                                             dwDataSize)     ||
            !ValidateAndFixupEventStringPtr (pEvent, 
                                             &((pEvent->EventInfo).JobInfo.pJobData->lpctstrCallerID),
                                             dwDataSize)       ||
            !ValidateAndFixupEventStringPtr (pEvent, 
                                             &((pEvent->EventInfo).JobInfo.pJobData->lpctstrRoutingInfo),
                                             dwDataSize))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ValidateAndFixupEventStringPtr failed"));
            dwRes = ERROR_INVALID_DATA;
            goto exit;
        }                            
        #ifndef UNICODE
        (pEvent->EventInfo).JobInfo.pJobData->dwSizeOfStruct = sizeof(FAX_JOB_STATUSA);
        if (!ConvertUnicodeStringInPlace( (LPWSTR) (pEvent->EventInfo).JobInfo.pJobData->lpctstrExtendedStatus ) ||
            !ConvertUnicodeStringInPlace( (LPWSTR) (pEvent->EventInfo).JobInfo.pJobData->lpctstrTsid )           ||
            !ConvertUnicodeStringInPlace( (LPWSTR) (pEvent->EventInfo).JobInfo.pJobData->lpctstrCsid )           ||
            !ConvertUnicodeStringInPlace( (LPWSTR) (pEvent->EventInfo).JobInfo.pJobData->lpctstrDeviceName )     ||
            !ConvertUnicodeStringInPlace( (LPWSTR) (pEvent->EventInfo).JobInfo.pJobData->lpctstrCallerID )       ||
            !ConvertUnicodeStringInPlace( (LPWSTR) (pEvent->EventInfo).JobInfo.pJobData->lpctstrRoutingInfo ))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ConvertUnicodeStringInPlace failed with %ld"),
                dwRes);
            goto exit;
        }
        #endif //   ifndef UNICODE
    }

    EnterCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    if (!ValidAsyncInfoSignature(pAsyncInfo))
    {
        DebugPrintEx(DEBUG_ERR, TEXT("Invalid AssyncInfo signature"));
        LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
        //
        //  if we got here and pAsyncInfo is invalid, it must be that 
        //  Fax_CloseConnection or rundown was called and the pAsyncInfo
        //  become invalid.
        //
        dwRes = ERROR_INVALID_DATA;
        goto exit;
    }    

    #ifdef UNICODE
    dwRes = DispatchEvent (pAsyncInfo, pEvent, dwDataSize);
    #else
    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EXA);
    pEventA = (PFAX_EVENT_EXA)pEvent;
    dwRes = DispatchEvent (pAsyncInfo, pEventA, dwDataSize);
    #endif
    
    LeaveCriticalSection(&g_CsFaxAssyncInfo);    // Protect AsyncInfo
    
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("DispatchEvent failed , errro %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        MemFree (pEvent);
    }
    return dwRes;
}   // FAX_ClientEventQueueEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\mfc\include\afxwin2.inl ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Inlines for AFXWIN.H (part 2)

#include <limits.h>

#ifdef _AFXWIN_INLINE

/////////////////////////////////////////////////////////////////////////////

// CWnd
_AFXWIN_INLINE HWND CWnd::GetSafeHwnd() const
	{ return this == NULL ? NULL : m_hWnd; }
_AFXWIN_INLINE DWORD CWnd::GetStyle() const
	{ return (DWORD)GetWindowLong(m_hWnd, GWL_STYLE); }
_AFXWIN_INLINE DWORD CWnd::GetExStyle() const
	{ return (DWORD)GetWindowLong(m_hWnd, GWL_EXSTYLE); }
_AFXWIN_INLINE CWnd* CWnd::GetOwner() const
	{ return m_hWndOwner != NULL ? CWnd::FromHandle(m_hWndOwner) : GetParent(); }
_AFXWIN_INLINE void CWnd::SetOwner(CWnd* pOwnerWnd)
	{ m_hWndOwner = pOwnerWnd != NULL ? pOwnerWnd->m_hWnd : NULL; }
_AFXWIN_INLINE LRESULT CWnd::SendMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ return ::SendMessage(m_hWnd, message, wParam, lParam); }
_AFXWIN_INLINE BOOL CWnd::PostMessage(UINT message, WPARAM wParam, LPARAM lParam)
	{ return ::PostMessage(m_hWnd, message, wParam, lParam); }
_AFXWIN_INLINE void CWnd::SetWindowText(LPCSTR lpszString)
	{ ::SetWindowText(m_hWnd, lpszString); }
_AFXWIN_INLINE int CWnd::GetWindowText(LPSTR lpszString, int nMaxCount) const
	{ return ::GetWindowText(m_hWnd, lpszString, nMaxCount); }
_AFXWIN_INLINE int CWnd::GetWindowTextLength() const
	{ return ::GetWindowTextLength(m_hWnd); }
_AFXWIN_INLINE void CWnd::GetWindowText(CString& rString) const
	{ int nLen = ::GetWindowTextLength(m_hWnd);
		::GetWindowText(m_hWnd, rString.GetBufferSetLength(nLen), nLen+1); }
_AFXWIN_INLINE void CWnd::SetFont(CFont* pFont, BOOL bRedraw /* = TRUE */)
	{ ::SendMessage(m_hWnd, WM_SETFONT, (WPARAM)pFont->GetSafeHandle(), bRedraw); }
_AFXWIN_INLINE CFont* CWnd::GetFont() const
	{ return CFont::FromHandle((HFONT)::SendMessage(m_hWnd, WM_GETFONT, 0, 0)); }
_AFXWIN_INLINE CMenu* CWnd::GetMenu() const
	{ return CMenu::FromHandle(::GetMenu(m_hWnd)); }
_AFXWIN_INLINE BOOL CWnd::SetMenu(CMenu* pMenu)
	{ return ::SetMenu(m_hWnd, pMenu->GetSafeHmenu()); }
_AFXWIN_INLINE void CWnd::DrawMenuBar()
	{ ::DrawMenuBar(m_hWnd); }
_AFXWIN_INLINE CMenu* CWnd::GetSystemMenu(BOOL bRevert) const
	{ return CMenu::FromHandle(::GetSystemMenu(m_hWnd, bRevert)); }
_AFXWIN_INLINE BOOL CWnd::HiliteMenuItem(CMenu* pMenu, UINT nIDHiliteItem, UINT nHilite)
	{ return ::HiliteMenuItem(m_hWnd, pMenu->m_hMenu, nIDHiliteItem, nHilite); }
_AFXWIN_INLINE int CWnd::GetDlgCtrlID() const
	{ return ::GetDlgCtrlID(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::IsIconic() const
	{ return ::IsIconic(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::IsZoomed() const
	{ return ::IsZoomed(m_hWnd); }
_AFXWIN_INLINE void CWnd::MoveWindow(int x, int y, int nWidth, int nHeight, BOOL bRepaint /* = TRUE */)
	{ ::MoveWindow(m_hWnd, x, y, nWidth, nHeight, bRepaint); }
_AFXWIN_INLINE void CWnd::MoveWindow(LPCRECT lpRect, BOOL bRepaint /* = TRUE */)
	{ ::MoveWindow(m_hWnd, lpRect->left, lpRect->top, lpRect->right - lpRect->left,
			lpRect->bottom - lpRect->top, bRepaint); }
_AFXWIN_INLINE BOOL CWnd::SetWindowPos(const CWnd* pWndInsertAfter, int x, int y, int cx, int cy, UINT nFlags)
#if (WINVER >= 0x030a)
	{ return ::SetWindowPos(m_hWnd, pWndInsertAfter->GetSafeHwnd(),
		x, y, cx, cy, nFlags); }
#else
	{ ::SetWindowPos(m_hWnd, pWndInsertAfter->GetSafeHwnd(),
		x, y, cx, cy, nFlags); return TRUE; }
#endif // WINVER >= 0x030a
_AFXWIN_INLINE UINT CWnd::ArrangeIconicWindows()
	{ return ::ArrangeIconicWindows(m_hWnd); }
_AFXWIN_INLINE void CWnd::BringWindowToTop()
	{ ::BringWindowToTop(m_hWnd); }
_AFXWIN_INLINE void CWnd::GetWindowRect(LPRECT lpRect) const
	{ ::GetWindowRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::GetClientRect(LPRECT lpRect) const
	{ ::GetClientRect(m_hWnd, lpRect); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE BOOL CWnd::GetWindowPlacement(WINDOWPLACEMENT FAR* lpwndpl) const
	{ return ::GetWindowPlacement(m_hWnd, lpwndpl); }
_AFXWIN_INLINE BOOL CWnd::SetWindowPlacement(const WINDOWPLACEMENT FAR* lpwndpl)
	{ return ::SetWindowPlacement(m_hWnd, lpwndpl); }
_AFXWIN_INLINE void CWnd::MapWindowPoints(CWnd* pwndTo, LPPOINT lpPoint, UINT nCount) const
	{ ::MapWindowPoints(m_hWnd, pwndTo->GetSafeHwnd(), lpPoint, nCount); }
_AFXWIN_INLINE void CWnd::MapWindowPoints(CWnd* pwndTo, LPRECT lpRect) const
	{ ::MapWindowPoints(m_hWnd, pwndTo->GetSafeHwnd(), (LPPOINT)lpRect, 2); }
#endif // WINVER >= 0x030a
_AFXWIN_INLINE void CWnd::ClientToScreen(LPPOINT lpPoint) const
	{ ::ClientToScreen(m_hWnd, lpPoint); }
_AFXWIN_INLINE void CWnd::ClientToScreen(LPRECT lpRect) const
	{ ::ClientToScreen(m_hWnd, (LPPOINT)lpRect);
		::ClientToScreen(m_hWnd, ((LPPOINT)lpRect)+1); }
_AFXWIN_INLINE void CWnd::ScreenToClient(LPPOINT lpPoint) const
	{ ::ScreenToClient(m_hWnd, lpPoint); }
_AFXWIN_INLINE void CWnd::ScreenToClient(LPRECT lpRect) const
	{ ::ScreenToClient(m_hWnd, (LPPOINT)lpRect);
		::ScreenToClient(m_hWnd, ((LPPOINT)lpRect)+1); }
_AFXWIN_INLINE CDC* CWnd::BeginPaint(LPPAINTSTRUCT lpPaint)
	{ return CDC::FromHandle(::BeginPaint(m_hWnd, lpPaint)); }
_AFXWIN_INLINE void CWnd::EndPaint(LPPAINTSTRUCT lpPaint)
	{ ::EndPaint(m_hWnd, lpPaint); }
_AFXWIN_INLINE CDC* CWnd::GetDC()
	{ return CDC::FromHandle(::GetDC(m_hWnd)); }
_AFXWIN_INLINE CDC* CWnd::GetWindowDC()
	{ return CDC::FromHandle(::GetWindowDC(m_hWnd)); }
_AFXWIN_INLINE int CWnd::ReleaseDC(CDC* pDC)
	{ return ::ReleaseDC(m_hWnd, pDC->m_hDC); }
_AFXWIN_INLINE void CWnd::UpdateWindow()
	{ ::UpdateWindow(m_hWnd); }
_AFXWIN_INLINE void CWnd::SetRedraw(BOOL bRedraw /* = TRUE */)
	{ ::SendMessage(m_hWnd, WM_SETREDRAW, bRedraw, 0); }
_AFXWIN_INLINE BOOL CWnd::GetUpdateRect(LPRECT lpRect, BOOL bErase /* = FALSE */)
	{ return ::GetUpdateRect(m_hWnd, lpRect, bErase); }
_AFXWIN_INLINE int CWnd::GetUpdateRgn(CRgn* pRgn, BOOL bErase /* = FALSE */)
	{ return ::GetUpdateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle(), bErase); }
_AFXWIN_INLINE void CWnd::Invalidate(BOOL bErase /* = TRUE */)
	{ ::InvalidateRect(m_hWnd, NULL, bErase); }
_AFXWIN_INLINE void CWnd::InvalidateRect(LPCRECT lpRect, BOOL bErase)
	{ ::InvalidateRect(m_hWnd, lpRect, bErase); }
_AFXWIN_INLINE void CWnd::InvalidateRgn(CRgn* pRgn, BOOL bErase /* = TRUE */)
	{ ::InvalidateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle(), bErase); }
_AFXWIN_INLINE void CWnd::ValidateRect(LPCRECT lpRect)
	{ ::ValidateRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CWnd::ValidateRgn(CRgn* pRgn)
	{ ::ValidateRgn(m_hWnd, (HRGN)pRgn->GetSafeHandle()); }
_AFXWIN_INLINE BOOL CWnd::ShowWindow(int nCmdShow)
	{ return ::ShowWindow(m_hWnd, nCmdShow); }
_AFXWIN_INLINE BOOL CWnd::IsWindowVisible() const
	{ return ::IsWindowVisible(m_hWnd); }
_AFXWIN_INLINE void CWnd::ShowOwnedPopups(BOOL bShow /* = TRUE */)
	{ ::ShowOwnedPopups(m_hWnd, bShow); }
_AFXWIN_INLINE void CWnd::SendMessageToDescendants(
	UINT message, WPARAM wParam, LPARAM lParam, BOOL bDeep, BOOL bOnlyPerm)
	{ CWnd::SendMessageToDescendants(m_hWnd, message, wParam, lParam, bDeep,
		bOnlyPerm); }
_AFXWIN_INLINE CWnd* CWnd::GetDescendantWindow(int nID, BOOL bOnlyPerm) const
	{ return CWnd::GetDescendantWindow(m_hWnd, nID, bOnlyPerm); }

#if (WINVER >= 0x030a)
_AFXWIN_INLINE CDC* CWnd::GetDCEx(CRgn* prgnClip, DWORD flags)
	{ return CDC::FromHandle(::GetDCEx(m_hWnd, (HRGN)prgnClip->GetSafeHandle(), flags)); }
_AFXWIN_INLINE BOOL CWnd::LockWindowUpdate()
	{ return ::LockWindowUpdate(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::RedrawWindow(LPCRECT lpRectUpdate,
			CRgn* prgnUpdate,
			UINT flags /* = RDW_INVALIDATE | RDW_UPDATENOW | RDW_ERASE */)
	{ return ::RedrawWindow(m_hWnd, lpRectUpdate, (HRGN)prgnUpdate->GetSafeHandle(), flags); }
_AFXWIN_INLINE BOOL CWnd::EnableScrollBar(int nSBFlags,
		UINT nArrowFlags /* = ESB_ENABLE_BOTH */)
	{ return (BOOL)::EnableScrollBar(m_hWnd, nSBFlags, nArrowFlags); }
#endif // WINVER >= 0x030a

_AFXWIN_INLINE UINT CWnd::SetTimer(UINT nIDEvent, UINT nElapse,
		void (CALLBACK EXPORT* lpfnTimer)(HWND, UINT, UINT, DWORD))
	{ return ::SetTimer(m_hWnd, nIDEvent, nElapse,
		(TIMERPROC)lpfnTimer); }
_AFXWIN_INLINE BOOL CWnd::KillTimer(int nIDEvent)
	{ return ::KillTimer(m_hWnd, nIDEvent); }
_AFXWIN_INLINE BOOL CWnd::IsWindowEnabled() const
	{ return ::IsWindowEnabled(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::EnableWindow(BOOL bEnable /* = TRUE */)
	{ return ::EnableWindow(m_hWnd, bEnable); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetActiveWindow()
	{ return CWnd::FromHandle(::GetActiveWindow()); }
_AFXWIN_INLINE CWnd* CWnd::SetActiveWindow()
	{ return CWnd::FromHandle(::SetActiveWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetCapture()
	{ return CWnd::FromHandle(::GetCapture()); }
_AFXWIN_INLINE CWnd* CWnd::SetCapture()
	{ return CWnd::FromHandle(::SetCapture(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetFocus()
	{ return CWnd::FromHandle(::GetFocus()); }
_AFXWIN_INLINE CWnd* CWnd::SetFocus()
	{ return CWnd::FromHandle(::SetFocus(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetDesktopWindow()
	{ return CWnd::FromHandle(::GetDesktopWindow()); }
_AFXWIN_INLINE void CWnd::CheckDlgButton(int nIDButton, UINT nCheck)
	{ ::CheckDlgButton(m_hWnd, nIDButton, nCheck); }
_AFXWIN_INLINE void CWnd::CheckRadioButton(int nIDFirstButton, int nIDLastButton,
		int nIDCheckButton)
	{ ::CheckRadioButton(m_hWnd, nIDFirstButton, nIDLastButton, nIDCheckButton); }
_AFXWIN_INLINE int CWnd::DlgDirList(LPSTR lpPathSpec, int nIDListBox,
		int nIDStaticPath, UINT nFileType)
	{ return ::DlgDirList(m_hWnd, lpPathSpec, nIDListBox,
			nIDStaticPath, nFileType); }
_AFXWIN_INLINE int CWnd::DlgDirListComboBox(LPSTR lpPathSpec, int nIDComboBox,
		int nIDStaticPath, UINT nFileType)
	{ return ::DlgDirListComboBox(m_hWnd, lpPathSpec,
			nIDComboBox, nIDStaticPath, nFileType); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelect(LPSTR lpString, int nIDListBox)
	{ return ::DlgDirSelect(m_hWnd, lpString, nIDListBox); }
_AFXWIN_INLINE BOOL CWnd::DlgDirSelectComboBox(LPSTR lpString, int nIDComboBox)
	{ return ::DlgDirSelectComboBox(m_hWnd, lpString, nIDComboBox);}
_AFXWIN_INLINE CWnd* CWnd::GetDlgItem(int nID) const
	{ return CWnd::FromHandle(::GetDlgItem(m_hWnd, nID)); }
_AFXWIN_INLINE UINT CWnd::GetDlgItemInt(int nID, BOOL* lpTrans /* = NULL */,
		BOOL bSigned /* = TRUE */) const
	{ return ::GetDlgItemInt(m_hWnd, nID, lpTrans, bSigned);}
_AFXWIN_INLINE int CWnd::GetDlgItemText(int nID, LPSTR lpStr, int nMaxCount) const
	{ return ::GetDlgItemText(m_hWnd, nID, lpStr, nMaxCount);}
_AFXWIN_INLINE CWnd* CWnd::GetNextDlgGroupItem(CWnd* pWndCtl, BOOL bPrevious /* = FALSE */) const
	{ return CWnd::FromHandle(::GetNextDlgGroupItem(m_hWnd,
			pWndCtl->m_hWnd, bPrevious)); }
_AFXWIN_INLINE CWnd* CWnd::GetNextDlgTabItem(CWnd* pWndCtl, BOOL bPrevious /* = FALSE */) const
	{ return CWnd::FromHandle(::GetNextDlgTabItem(m_hWnd,
			pWndCtl->m_hWnd, bPrevious)); }
_AFXWIN_INLINE UINT CWnd::IsDlgButtonChecked(int nIDButton) const
	{ return ::IsDlgButtonChecked(m_hWnd, nIDButton); }
_AFXWIN_INLINE LPARAM CWnd::SendDlgItemMessage(int nID, UINT message, WPARAM wParam /* = 0 */, LPARAM lParam /* = 0 */)
	{ return ::SendDlgItemMessage(m_hWnd, nID, message, wParam, lParam); }
_AFXWIN_INLINE void CWnd::SetDlgItemInt(int nID, UINT nValue, BOOL bSigned /* = TRUE */)
	{ ::SetDlgItemInt(m_hWnd, nID, nValue, bSigned); }
_AFXWIN_INLINE void CWnd::SetDlgItemText(int nID, LPCSTR lpszString)
	{ ::SetDlgItemText(m_hWnd, nID, lpszString); }
_AFXWIN_INLINE void CWnd::ScrollWindow(int xAmount, int yAmount,
		LPCRECT lpRect /* = NULL */,
		LPCRECT lpClipRect /* = NULL */)
	{::ScrollWindow(m_hWnd, xAmount, yAmount, lpRect, lpClipRect); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE int CWnd::ScrollWindowEx(int dx, int dy,
				LPCRECT lpRectScroll, LPCRECT lpRectClip,
				CRgn* prgnUpdate, LPRECT lpRectUpdate, UINT flags)
	{ return ::ScrollWindowEx(m_hWnd, dx, dy, lpRectScroll, lpRectClip,
			(HRGN)prgnUpdate->GetSafeHandle(), lpRectUpdate, flags); }
#endif // WINVER >= 0x030a

_AFXWIN_INLINE void CWnd::ShowScrollBar(UINT nBar, BOOL bShow /* = TRUE */)
	{ ::ShowScrollBar(m_hWnd, nBar, bShow); }
_AFXWIN_INLINE CWnd* CWnd::ChildWindowFromPoint(POINT point) const
	{ return CWnd::FromHandle(::ChildWindowFromPoint(m_hWnd, point)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::FindWindow(LPCSTR lpszClassName, LPCSTR lpszWindowName)
	{ return CWnd::FromHandle(
			::FindWindow(lpszClassName, lpszWindowName)); }
_AFXWIN_INLINE CWnd* CWnd::GetNextWindow(UINT nFlag /* = GW_HWNDNEXT */) const
	{ return CWnd::FromHandle(::GetNextWindow(m_hWnd, nFlag)); }
_AFXWIN_INLINE CWnd* CWnd::GetTopWindow() const
	{ return CWnd::FromHandle(::GetTopWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* CWnd::GetWindow(UINT nCmd) const
	{ return CWnd::FromHandle(::GetWindow(m_hWnd, nCmd)); }
_AFXWIN_INLINE CWnd* CWnd::GetLastActivePopup() const
	{ return CWnd::FromHandle(::GetLastActivePopup(m_hWnd)); }
_AFXWIN_INLINE BOOL CWnd::IsChild(const CWnd* pWnd) const
	{ return ::IsChild(m_hWnd, pWnd->GetSafeHwnd()); }
_AFXWIN_INLINE CWnd* CWnd::GetParent() const
	{ return CWnd::FromHandle(::GetParent(m_hWnd)); }
_AFXWIN_INLINE CWnd* CWnd::SetParent(CWnd* pWndNewParent)
	{ return CWnd::FromHandle(::SetParent(m_hWnd,
			pWndNewParent->GetSafeHwnd())); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::WindowFromPoint(POINT point)
	{ return CWnd::FromHandle(::WindowFromPoint(point)); }
_AFXWIN_INLINE BOOL CWnd::FlashWindow(BOOL bInvert)
	{ return ::FlashWindow(m_hWnd, bInvert); }
_AFXWIN_INLINE BOOL CWnd::ChangeClipboardChain(HWND hWndNext)
	{ return ::ChangeClipboardChain(m_hWnd, hWndNext); }
_AFXWIN_INLINE HWND CWnd::SetClipboardViewer()
	{ return ::SetClipboardViewer(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::OpenClipboard()
	{ return ::OpenClipboard(m_hWnd); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetOpenClipboardWindow()
	{ return CWnd::FromHandle(::GetOpenClipboardWindow()); }
#endif // WINVER >= 0x030a
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetClipboardOwner()
	{ return CWnd::FromHandle(::GetClipboardOwner()); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetClipboardViewer()
	{ return CWnd::FromHandle(::GetClipboardViewer()); }
_AFXWIN_INLINE void CWnd::CreateCaret(CBitmap* pBitmap)
	{ ::CreateCaret(m_hWnd, (HBITMAP)pBitmap->GetSafeHandle(), 0, 0); }
_AFXWIN_INLINE void CWnd::CreateSolidCaret(int nWidth, int nHeight)
	{ ::CreateCaret(m_hWnd, (HBITMAP)0, nWidth, nHeight); }
_AFXWIN_INLINE void CWnd::CreateGrayCaret(int nWidth, int nHeight)
	{ ::CreateCaret(m_hWnd, (HBITMAP)1, nWidth, nHeight); }
_AFXWIN_INLINE CPoint PASCAL CWnd::GetCaretPos()
	{ CPoint point; ::GetCaretPos((LPPOINT)&point); return point; }
_AFXWIN_INLINE void PASCAL CWnd::SetCaretPos(POINT point)
	{ ::SetCaretPos(point.x, point.y); }
_AFXWIN_INLINE void CWnd::HideCaret()
	{ ::HideCaret(m_hWnd); }
_AFXWIN_INLINE void CWnd::ShowCaret()
	{ ::ShowCaret(m_hWnd); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE void CWnd::DragAcceptFiles(BOOL bAccept)
	{ ::DragAcceptFiles(m_hWnd, bAccept); }
#endif // WINVER >= 0x030a

// Default message map implementations
_AFXWIN_INLINE afx_msg void CWnd::OnActivate(UINT, CWnd*, BOOL)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnActivateApp(BOOL, HTASK)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnCancelMode()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnChildActivate()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnClose()
	{ Default(); }
_AFXWIN_INLINE afx_msg int CWnd::OnCreate(LPCREATESTRUCT)
	{ return (int)Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnDestroy()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnEnable(BOOL)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnEndSession(BOOL)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnEnterIdle(UINT, CWnd*)
	{ Default(); }
_AFXWIN_INLINE afx_msg BOOL CWnd::OnEraseBkgnd(CDC*)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnGetMinMaxInfo(MINMAXINFO FAR*)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnIconEraseBkgnd(CDC*)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnKillFocus(CWnd*)
	{ Default(); }
_AFXWIN_INLINE afx_msg LRESULT CWnd::OnMenuChar(UINT, UINT, CMenu*)
	{ return Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnMenuSelect(UINT, UINT, HMENU)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnMove(int, int)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnPaint()
	{ Default(); }
_AFXWIN_INLINE afx_msg HCURSOR CWnd::OnQueryDragIcon()
	{ return (HCURSOR)Default(); }
_AFXWIN_INLINE afx_msg BOOL CWnd::OnQueryEndSession()
	{ return (BOOL)Default(); }
_AFXWIN_INLINE afx_msg BOOL CWnd::OnQueryNewPalette()
	{ return (BOOL)Default(); }
_AFXWIN_INLINE afx_msg BOOL CWnd::OnQueryOpen()
	{ return (BOOL)Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSetFocus(CWnd*)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnShowWindow(BOOL, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSize(UINT, int, int)
	{ Default(); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE afx_msg void CWnd::OnWindowPosChanging(WINDOWPOS FAR*)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnWindowPosChanged(WINDOWPOS FAR*)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnDropFiles(HDROP)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnPaletteIsChanging(CWnd*)
	{ Default(); }
#endif // WINVER >= 0x030a
_AFXWIN_INLINE afx_msg BOOL CWnd::OnNcActivate(BOOL)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS FAR*)
	{ Default(); }
_AFXWIN_INLINE afx_msg BOOL CWnd::OnNcCreate(LPCREATESTRUCT)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE afx_msg UINT CWnd::OnNcHitTest(CPoint)
	{ return (UINT)Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcLButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcLButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcLButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcMButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcMButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcMButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcMouseMove(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcPaint()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcRButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcRButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnNcRButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSysChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSysCommand(UINT, LPARAM)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSysDeadChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSysKeyDown(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSysKeyUp(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnCompacting(UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnDevModeChange(LPSTR)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnFontChange()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnPaletteChanged(CWnd*)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSpoolerStatus(UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSysColorChange()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnTimeChange()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnWinIniChange(LPCSTR)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnDeadChar(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnKeyDown(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnKeyUp(UINT, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnLButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnLButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnLButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnMButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnMButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnMButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg int CWnd::OnMouseActivate(CWnd*, UINT, UINT)
	{ return (int)Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnMouseMove(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnRButtonDblClk(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnRButtonDown(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnRButtonUp(UINT, CPoint)
	{ Default(); }
_AFXWIN_INLINE afx_msg BOOL CWnd::OnSetCursor(CWnd*, UINT, UINT)
	{ return (BOOL)Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnTimer(UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnInitMenu(CMenu*)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnInitMenuPopup(CMenu*, UINT, BOOL)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnAskCbFormatName(UINT, LPSTR)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnChangeCbChain(HWND, HWND)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnDestroyClipboard()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnDrawClipboard()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnHScrollClipboard(CWnd*, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnPaintClipboard(CWnd*, HGLOBAL)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnRenderAllFormats()
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnRenderFormat(UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnSizeClipboard(CWnd*, HGLOBAL)
	{ Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnVScrollClipboard(CWnd*, UINT, UINT)
	{ Default(); }
_AFXWIN_INLINE afx_msg UINT CWnd::OnGetDlgCode()
	{ return (UINT)Default(); }
_AFXWIN_INLINE afx_msg int CWnd::OnCharToItem(UINT, CListBox*, UINT)
	{ return (int)Default(); }
_AFXWIN_INLINE afx_msg int CWnd::OnVKeyToItem(UINT, CListBox*, UINT)
	{ return (int)Default(); }
_AFXWIN_INLINE afx_msg void CWnd::OnMDIActivate(BOOL, CWnd*, CWnd*)
	{ Default(); }

// CWnd dialog data support
_AFXWIN_INLINE void CWnd::DoDataExchange(CDataExchange*)
	{ } // default does nothing

// CFrameWnd
_AFXWIN_INLINE void CFrameWnd::DelayUpdateFrameTitle()
	{ m_nIdleFlags |= idleTitle; }
_AFXWIN_INLINE void CFrameWnd::DelayRecalcLayout(BOOL bNotify)
	{ m_nIdleFlags |= (idleLayout | (bNotify ? idleNotify : 0)); };
_AFXWIN_INLINE BOOL CFrameWnd::InModalState() const
	{ return m_cModalStack != 0; }

// CDialog
_AFXWIN_INLINE BOOL CDialog::Create(UINT nIDTemplate, CWnd* pParentWnd /* = NULL */)
	{ return Create(MAKEINTRESOURCE(nIDTemplate), pParentWnd); }
_AFXWIN_INLINE void CDialog::MapDialogRect(LPRECT lpRect) const
	{ ::MapDialogRect(m_hWnd, lpRect); }
_AFXWIN_INLINE void CDialog::SetHelpID(UINT nIDR)
	{ m_nIDHelp = nIDR; }
_AFXWIN_INLINE BOOL CDialog::IsDialogMessage(LPMSG lpMsg)
	{ return ::IsDialogMessage(m_hWnd, lpMsg); }
_AFXWIN_INLINE void CDialog::NextDlgCtrl() const
	{ ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 0, 0); }
_AFXWIN_INLINE void CDialog::PrevDlgCtrl() const
	{ ::SendMessage(m_hWnd, WM_NEXTDLGCTL, 1, 0); }
_AFXWIN_INLINE void CDialog::GotoDlgCtrl(CWnd* pWndCtrl)
	{ ::SendMessage(m_hWnd, WM_NEXTDLGCTL, (WPARAM)pWndCtrl->m_hWnd, 1L); }
_AFXWIN_INLINE void CDialog::SetDefID(UINT nID)
	{ ::SendMessage(m_hWnd, DM_SETDEFID, nID, 0); }
_AFXWIN_INLINE DWORD CDialog::GetDefID() const
	{ return ::SendMessage(m_hWnd, DM_GETDEFID, 0, 0); }
_AFXWIN_INLINE void CDialog::EndDialog(int nResult)
	{ ::EndDialog(m_hWnd, nResult); }

// Window control functions
_AFXWIN_INLINE CStatic::CStatic()
	{ }
_AFXWIN_INLINE CButton::CButton()
	{ }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE HICON CStatic::SetIcon(HICON hIcon)
	{ return (HICON)::SendMessage(m_hWnd, STM_SETICON, (WPARAM)hIcon, 0L); }
_AFXWIN_INLINE HICON CStatic::GetIcon() const
	{ return (HICON)::SendMessage(m_hWnd, STM_GETICON, 0, 0L); }
#endif // WINVER >= 0x030a

_AFXWIN_INLINE UINT CButton::GetState() const
	{ return (UINT)::SendMessage(m_hWnd, BM_GETSTATE, 0, 0); }
_AFXWIN_INLINE void CButton::SetState(BOOL bHighlight)
	{ ::SendMessage(m_hWnd, BM_SETSTATE, bHighlight, 0); }
_AFXWIN_INLINE int CButton::GetCheck() const
	{ return (int)::SendMessage(m_hWnd, BM_GETCHECK, 0, 0); }
_AFXWIN_INLINE void CButton::SetCheck(int nCheck)
	{ ::SendMessage(m_hWnd, BM_SETCHECK, nCheck, 0); }
_AFXWIN_INLINE UINT CButton::GetButtonStyle() const
	{ return (UINT)GetWindowLong(m_hWnd, GWL_STYLE) & 0xff; }
_AFXWIN_INLINE void CButton::SetButtonStyle(UINT nStyle, BOOL bRedraw /* = TRUE */)
	{ ::SendMessage(m_hWnd, BM_SETSTYLE, nStyle, (LPARAM)bRedraw); }
_AFXWIN_INLINE CListBox::CListBox()
	{ }
_AFXWIN_INLINE int CListBox::GetCount() const
	{ return (int)::SendMessage(m_hWnd, LB_GETCOUNT, 0, 0); }
_AFXWIN_INLINE int CListBox::GetCurSel() const
	{ return (int)::SendMessage(m_hWnd, LB_GETCURSEL, 0, 0); }
_AFXWIN_INLINE int CListBox::SetCurSel(int nSelect)
	{ return (int)::SendMessage(m_hWnd, LB_SETCURSEL, nSelect, 0); }
_AFXWIN_INLINE int CListBox::GetHorizontalExtent() const
	{ return (int)::SendMessage(m_hWnd, LB_GETHORIZONTALEXTENT,
		0, 0); }
_AFXWIN_INLINE void CListBox::SetHorizontalExtent(int cxExtent)
	{ ::SendMessage(m_hWnd, LB_SETHORIZONTALEXTENT, cxExtent, 0); }
_AFXWIN_INLINE int CListBox::GetSelCount() const
	{ return (int)::SendMessage(m_hWnd, LB_GETSELCOUNT, 0, 0); }
_AFXWIN_INLINE int CListBox::GetSelItems(int nMaxItems, LPINT rgIndex) const
	{ return (int)::SendMessage(m_hWnd, LB_GETSELITEMS, nMaxItems, (LPARAM)rgIndex); }
_AFXWIN_INLINE int CListBox::GetTopIndex() const
	{ return (int)::SendMessage(m_hWnd, LB_GETTOPINDEX, 0, 0); }
_AFXWIN_INLINE int CListBox::SetTopIndex(int nIndex)
	{ return (int)::SendMessage(m_hWnd, LB_SETTOPINDEX, nIndex, 0);}
_AFXWIN_INLINE DWORD CListBox::GetItemData(int nIndex) const
	{ return ::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetItemData(int nIndex, DWORD dwItemData)
	{ return (int)::SendMessage(m_hWnd, LB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }
_AFXWIN_INLINE void* CListBox::GetItemDataPtr(int nIndex) const
	{ return _AfxGetPtrFromFarPtr((LPVOID)::SendMessage(m_hWnd, LB_GETITEMDATA, nIndex, 0)); }
_AFXWIN_INLINE int CListBox::SetItemDataPtr(int nIndex, void* pData)
	{ return SetItemData(nIndex, (DWORD)(LPVOID)pData); }
_AFXWIN_INLINE int CListBox::GetItemRect(int nIndex, LPRECT lpRect) const
	{ return (int)::SendMessage(m_hWnd, LB_GETITEMRECT, nIndex, (LPARAM)lpRect); }
_AFXWIN_INLINE int CListBox::GetSel(int nIndex) const
	{ return (int)::SendMessage(m_hWnd, LB_GETSEL, nIndex, 0); }
_AFXWIN_INLINE int CListBox::SetSel(int nIndex, BOOL bSelect)
	{ return (int)::SendMessage(m_hWnd, LB_SETSEL, bSelect, nIndex); }
_AFXWIN_INLINE int CListBox::GetText(int nIndex, LPSTR lpszBuffer) const
	{ return (int)::SendMessage(m_hWnd, LB_GETTEXT, nIndex, (LPARAM)lpszBuffer); }
_AFXWIN_INLINE int CListBox::GetTextLen(int nIndex) const
	{ return (int)::SendMessage(m_hWnd, LB_GETTEXTLEN, nIndex, 0); }
_AFXWIN_INLINE void CListBox::GetText(int nIndex, CString& rString) const
	{ GetText(nIndex, rString.GetBufferSetLength(GetTextLen(nIndex))); }
_AFXWIN_INLINE void CListBox::SetColumnWidth(int cxWidth)
	{ ::SendMessage(m_hWnd, LB_SETCOLUMNWIDTH, cxWidth, 0); }
_AFXWIN_INLINE BOOL CListBox::SetTabStops(int nTabStops, LPINT rgTabStops)
	{ return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, nTabStops, (LPARAM)rgTabStops); }
_AFXWIN_INLINE void CListBox::SetTabStops()
	{ VERIFY(::SendMessage(m_hWnd, LB_SETTABSTOPS, 0, 0)); }
_AFXWIN_INLINE BOOL CListBox::SetTabStops(const int& cxEachStop)
	{ return (BOOL)::SendMessage(m_hWnd, LB_SETTABSTOPS, 1, (LPARAM)(LPINT)&cxEachStop); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE int CListBox::SetItemHeight(int nIndex, UINT cyItemHeight)
	{ return (int)::SendMessage(m_hWnd, LB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0)); }
_AFXWIN_INLINE int CListBox::GetItemHeight(int nIndex) const
	{ return (int)::SendMessage(m_hWnd, LB_GETITEMHEIGHT, nIndex, 0L); }
_AFXWIN_INLINE int CListBox::FindStringExact(int nIndexStart, LPCSTR lpszFind) const
	{ return (int)::SendMessage(m_hWnd, LB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind); }
_AFXWIN_INLINE int CListBox::GetCaretIndex() const
	{ return (int)::SendMessage(m_hWnd, LB_GETCARETINDEX, 0, 0L); }
_AFXWIN_INLINE int CListBox::SetCaretIndex(int nIndex, BOOL bScroll /* = TRUE */)
	{ return (int)::SendMessage(m_hWnd, LB_SETCARETINDEX, nIndex, MAKELONG(bScroll, 0)); }
#endif // WINVER >= 0x030a
_AFXWIN_INLINE int CListBox::AddString(LPCSTR lpszItem)
	{ return (int)::SendMessage(m_hWnd, LB_ADDSTRING, 0, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::DeleteString(UINT nIndex)
	{ return (int)::SendMessage(m_hWnd, LB_DELETESTRING, nIndex, 0); }
_AFXWIN_INLINE int CListBox::InsertString(int nIndex, LPCSTR lpszItem)
	{ return (int)::SendMessage(m_hWnd, LB_INSERTSTRING, nIndex, (LPARAM)lpszItem); }
_AFXWIN_INLINE void CListBox::ResetContent()
	{ ::SendMessage(m_hWnd, LB_RESETCONTENT, 0, 0); }
_AFXWIN_INLINE int CListBox::Dir(UINT attr, LPCSTR lpszWildCard)
	{ return (int)::SendMessage(m_hWnd, LB_DIR, attr, (LPARAM)lpszWildCard); }
_AFXWIN_INLINE int CListBox::FindString(int nStartAfter, LPCSTR lpszItem) const
	{ return (int)::SendMessage(m_hWnd, LB_FINDSTRING,
		nStartAfter, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::SelectString(int nStartAfter, LPCSTR lpszItem)
	{ return (int)::SendMessage(m_hWnd, LB_SELECTSTRING,
		nStartAfter, (LPARAM)lpszItem); }
_AFXWIN_INLINE int CListBox::SelItemRange(BOOL bSelect, int nFirstItem, int nLastItem)
	{ return (int)::SendMessage(m_hWnd, LB_SELITEMRANGE, bSelect,
		MAKELONG(nFirstItem, nLastItem)); }

_AFXWIN_INLINE CComboBox::CComboBox()
	{ }
_AFXWIN_INLINE int CComboBox::GetCount() const
	{ return (int)::SendMessage(m_hWnd, CB_GETCOUNT, 0, 0); }
_AFXWIN_INLINE int CComboBox::GetCurSel() const
	{ return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }
_AFXWIN_INLINE int CComboBox::SetCurSel(int nSelect)
	{ return (int)::SendMessage(m_hWnd, CB_SETCURSEL, nSelect, 0); }
_AFXWIN_INLINE DWORD CComboBox::GetEditSel() const
	{ return ::SendMessage(m_hWnd, CB_GETEDITSEL, 0, 0); }
_AFXWIN_INLINE BOOL CComboBox::LimitText(int nMaxChars)
	{ return (BOOL)::SendMessage(m_hWnd, CB_LIMITTEXT, nMaxChars, 0); }
_AFXWIN_INLINE BOOL CComboBox::SetEditSel(int nStartChar, int nEndChar)
	{ return (BOOL)::SendMessage(m_hWnd, CB_SETEDITSEL, 0, MAKELONG(nStartChar, nEndChar)); }
_AFXWIN_INLINE DWORD CComboBox::GetItemData(int nIndex) const
	{ return ::SendMessage(m_hWnd, CB_GETITEMDATA, nIndex, 0); }
_AFXWIN_INLINE int CComboBox::SetItemData(int nIndex, DWORD dwItemData)
	{ return (int)::SendMessage(m_hWnd, CB_SETITEMDATA, nIndex, (LPARAM)dwItemData); }
_AFXWIN_INLINE void* CComboBox::GetItemDataPtr(int nIndex) const
	{ return _AfxGetPtrFromFarPtr((LPVOID)GetItemData(nIndex)); }
_AFXWIN_INLINE int CComboBox::SetItemDataPtr(int nIndex, void* pData)
	{ return SetItemData(nIndex, (DWORD)(LPVOID)pData); }
_AFXWIN_INLINE int CComboBox::GetLBText(int nIndex, LPSTR lpszText) const
	{ return (int)::SendMessage(m_hWnd, CB_GETLBTEXT, nIndex, (LPARAM)lpszText); }
_AFXWIN_INLINE int CComboBox::GetLBTextLen(int nIndex) const
	{ return (int)::SendMessage(m_hWnd, CB_GETLBTEXTLEN, nIndex, 0); }
_AFXWIN_INLINE void CComboBox::GetLBText(int nIndex, CString& rString) const
	{ GetLBText(nIndex, rString.GetBufferSetLength(GetLBTextLen(nIndex))); }
_AFXWIN_INLINE void CComboBox::ShowDropDown(BOOL bShowIt /* = TRUE */)
	{ ::SendMessage(m_hWnd, CB_SHOWDROPDOWN, bShowIt, 0); }
_AFXWIN_INLINE int CComboBox::AddString(LPCSTR lpszString)
	{ return (int)::SendMessage(m_hWnd, CB_ADDSTRING, 0, (LPARAM)lpszString); }
_AFXWIN_INLINE int CComboBox::DeleteString(UINT nIndex)
	{ return (int)::SendMessage(m_hWnd, CB_DELETESTRING, nIndex, 0);}
_AFXWIN_INLINE int CComboBox::InsertString(int nIndex, LPCSTR lpszString)
	{ return (int)::SendMessage(m_hWnd, CB_INSERTSTRING, nIndex, (LPARAM)lpszString); }
_AFXWIN_INLINE void CComboBox::ResetContent()
	{ ::SendMessage(m_hWnd, CB_RESETCONTENT, 0, 0); }
_AFXWIN_INLINE int CComboBox::Dir(UINT attr, LPCSTR lpszWildCard)
	{ return (int)::SendMessage(m_hWnd, CB_DIR, attr, (LPARAM)lpszWildCard); }
_AFXWIN_INLINE int CComboBox::FindString(int nStartAfter, LPCSTR lpszString) const
	{ return (int)::SendMessage(m_hWnd, CB_FINDSTRING, nStartAfter,
		(LPARAM)lpszString); }
_AFXWIN_INLINE int CComboBox::SelectString(int nStartAfter, LPCSTR lpszString)
	{ return (int)::SendMessage(m_hWnd, CB_SELECTSTRING,
		nStartAfter, (LPARAM)lpszString); }
_AFXWIN_INLINE void CComboBox::Clear()
	{ ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXWIN_INLINE void CComboBox::Copy()
	{ ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXWIN_INLINE void CComboBox::Cut()
	{ ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXWIN_INLINE void CComboBox::Paste()
	{ ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE int CComboBox::SetItemHeight(int nIndex, UINT cyItemHeight)
	{ return (int)::SendMessage(m_hWnd, CB_SETITEMHEIGHT, nIndex, MAKELONG(cyItemHeight, 0)); }
_AFXWIN_INLINE int CComboBox::GetItemHeight(int nIndex) const
	{ return (int)::SendMessage(m_hWnd, CB_GETITEMHEIGHT, nIndex, 0L); }
_AFXWIN_INLINE int CComboBox::FindStringExact(int nIndexStart, LPCSTR lpszFind) const
	{ return (int)::SendMessage(m_hWnd, CB_FINDSTRINGEXACT, nIndexStart, (LPARAM)lpszFind); }
_AFXWIN_INLINE int CComboBox::SetExtendedUI(BOOL bExtended /* = TRUE */ )
	{ return (int)::SendMessage(m_hWnd, CB_SETEXTENDEDUI, bExtended, 0L); }
_AFXWIN_INLINE BOOL CComboBox::GetExtendedUI() const
	{ return (BOOL)::SendMessage(m_hWnd, CB_GETEXTENDEDUI, 0, 0L); }
_AFXWIN_INLINE void CComboBox::GetDroppedControlRect(LPRECT lprect) const
	{ ::SendMessage(m_hWnd, CB_GETDROPPEDCONTROLRECT, 0, (DWORD)lprect); }
_AFXWIN_INLINE BOOL CComboBox::GetDroppedState() const
	{ return (BOOL)::SendMessage(m_hWnd, CB_GETDROPPEDSTATE, 0, 0L); }
#endif // WINVER >= 0x030a

_AFXWIN_INLINE CEdit::CEdit()
	{ }
_AFXWIN_INLINE BOOL CEdit::CanUndo() const
	{ return (BOOL)::SendMessage(m_hWnd, EM_CANUNDO, 0, 0); }
_AFXWIN_INLINE int CEdit::GetLineCount() const
	{ return (int)::SendMessage(m_hWnd, EM_GETLINECOUNT, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::GetModify() const
	{ return (BOOL)::SendMessage(m_hWnd, EM_GETMODIFY, 0, 0); }
_AFXWIN_INLINE void CEdit::SetModify(BOOL bModified /* = TRUE */)
	{ ::SendMessage(m_hWnd, EM_SETMODIFY, bModified, 0); }
_AFXWIN_INLINE void CEdit::GetRect(LPRECT lpRect) const
	{ ::SendMessage(m_hWnd, EM_GETRECT, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::GetSel(int& nStartChar, int& nEndChar) const
	{
		DWORD dwSel = (DWORD)::SendMessage(m_hWnd, EM_GETSEL, 0, 0);
		nStartChar = (int)LOWORD(dwSel);
		nEndChar = (int)HIWORD(dwSel);
	}
_AFXWIN_INLINE DWORD CEdit::GetSel() const
	{ return ::SendMessage(m_hWnd, EM_GETSEL, 0, 0); }
_AFXWIN_INLINE HLOCAL CEdit::GetHandle() const
	{ return (HLOCAL)::SendMessage(m_hWnd, EM_GETHANDLE, 0, 0); }
_AFXWIN_INLINE void CEdit::SetHandle(HLOCAL hBuffer)
	{ ::SendMessage(m_hWnd, EM_SETHANDLE, (WPARAM)hBuffer, 0); }
_AFXWIN_INLINE int CEdit::GetLine(int nIndex, LPSTR lpszBuffer) const
	{ return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer); }
_AFXWIN_INLINE int CEdit::GetLine(int nIndex, LPSTR lpszBuffer, int nMaxLength) const
	{
		*(LPINT)lpszBuffer = nMaxLength;
		return (int)::SendMessage(m_hWnd, EM_GETLINE, nIndex, (LPARAM)lpszBuffer);
	}
_AFXWIN_INLINE void CEdit::EmptyUndoBuffer()
	{ ::SendMessage(m_hWnd, EM_EMPTYUNDOBUFFER, 0, 0); }
_AFXWIN_INLINE BOOL CEdit::FmtLines(BOOL bAddEOL)
	{ return (BOOL)::SendMessage(m_hWnd, EM_FMTLINES, bAddEOL, 0); }
_AFXWIN_INLINE void CEdit::LimitText(int nChars /* = 0 */)
	{ ::SendMessage(m_hWnd, EM_LIMITTEXT, nChars, 0); }
_AFXWIN_INLINE int CEdit::LineFromChar(int nIndex /* = -1 */) const
	{ return (int)::SendMessage(m_hWnd, EM_LINEFROMCHAR, nIndex, 0); }
_AFXWIN_INLINE int CEdit::LineIndex(int nLine /* = -1 */) const
	{ return (int)::SendMessage(m_hWnd, EM_LINEINDEX, nLine, 0); }
_AFXWIN_INLINE int CEdit::LineLength(int nLine /* = -1 */) const
	{ return (int)::SendMessage(m_hWnd, EM_LINELENGTH, nLine, 0); }
_AFXWIN_INLINE void CEdit::LineScroll(int nLines, int nChars /* = 0 */)
	{ ::SendMessage(m_hWnd, EM_LINESCROLL, 0, MAKELONG(nLines, nChars)); }
_AFXWIN_INLINE void CEdit::ReplaceSel(LPCSTR lpszNewText)
	{ ::SendMessage(m_hWnd, EM_REPLACESEL, 0, (LPARAM)lpszNewText); }
_AFXWIN_INLINE void CEdit::SetPasswordChar(char ch)
	{ ::SendMessage(m_hWnd, EM_SETPASSWORDCHAR, ch, 0); }
_AFXWIN_INLINE void CEdit::SetRect(LPCRECT lpRect)
	{ ::SendMessage(m_hWnd, EM_SETRECT, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::SetRectNP(LPCRECT lpRect)
	{ ::SendMessage(m_hWnd, EM_SETRECTNP, 0, (LPARAM)lpRect); }
_AFXWIN_INLINE void CEdit::SetSel(DWORD dwSelection, BOOL bNoScroll)
	{ ::SendMessage(m_hWnd, EM_SETSEL, bNoScroll, (LPARAM)dwSelection); }
_AFXWIN_INLINE void CEdit::SetSel(int nStartChar, int nEndChar, BOOL bNoScroll)
	{ ::SendMessage(m_hWnd, EM_SETSEL, bNoScroll,
			MAKELONG(nStartChar, nEndChar)); }
_AFXWIN_INLINE BOOL CEdit::SetTabStops(int nTabStops, LPINT rgTabStops)
	{ return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS, nTabStops,
		(LPARAM)rgTabStops); }
_AFXWIN_INLINE void CEdit::SetTabStops()
	{ VERIFY(::SendMessage(m_hWnd, EM_SETTABSTOPS, 0, 0)); }
_AFXWIN_INLINE BOOL CEdit::SetTabStops(const int& cxEachStop)
	{ return (BOOL)::SendMessage(m_hWnd, EM_SETTABSTOPS,
		1, (LPARAM)(LPINT)&cxEachStop); }
_AFXWIN_INLINE BOOL CEdit::Undo()
	{ return (BOOL)::SendMessage(m_hWnd, EM_UNDO, 0, 0); }
_AFXWIN_INLINE void CEdit::Clear()
	{ ::SendMessage(m_hWnd, WM_CLEAR, 0, 0); }
_AFXWIN_INLINE void CEdit::Copy()
	{ ::SendMessage(m_hWnd, WM_COPY, 0, 0); }
_AFXWIN_INLINE void CEdit::Cut()
	{ ::SendMessage(m_hWnd, WM_CUT, 0, 0); }
_AFXWIN_INLINE void CEdit::Paste()
	{ ::SendMessage(m_hWnd, WM_PASTE, 0, 0); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE BOOL CEdit::SetReadOnly(BOOL bReadOnly /* = TRUE */ )
	{ return (BOOL)::SendMessage(m_hWnd, EM_SETREADONLY, bReadOnly, 0L); }
_AFXWIN_INLINE int CEdit::GetFirstVisibleLine() const
	{ return (int)::SendMessage(m_hWnd, EM_GETFIRSTVISIBLELINE, 0, 0L); }
_AFXWIN_INLINE char CEdit::GetPasswordChar() const
	{ return (char)::SendMessage(m_hWnd, EM_GETPASSWORDCHAR, 0, 0L); }
#endif // WINVER >= 0x030a

_AFXWIN_INLINE CScrollBar::CScrollBar()
	{ }
_AFXWIN_INLINE int CScrollBar::GetScrollPos() const
	{ return ::GetScrollPos(m_hWnd, SB_CTL); }
_AFXWIN_INLINE int CScrollBar::SetScrollPos(int nPos, BOOL bRedraw /* = TRUE */)
	{ return ::SetScrollPos(m_hWnd, SB_CTL, nPos, bRedraw); }
_AFXWIN_INLINE void CScrollBar::GetScrollRange(LPINT lpMinPos, LPINT lpMaxPos) const
	{ ::GetScrollRange(m_hWnd, SB_CTL, lpMinPos, lpMaxPos); }
_AFXWIN_INLINE void CScrollBar::SetScrollRange(int nMinPos, int nMaxPos, BOOL bRedraw /* = TRUE */)
	{ ::SetScrollRange(m_hWnd, SB_CTL, nMinPos, nMaxPos, bRedraw); }
_AFXWIN_INLINE void CScrollBar::ShowScrollBar(BOOL bShow /* = TRUE */)
	{ ::ShowScrollBar(m_hWnd, SB_CTL, bShow); }
#if (WINVER >= 0x030a)
_AFXWIN_INLINE BOOL CScrollBar::EnableScrollBar(UINT nArrowFlags /* = ESB_ENABLE_BOTH */ )
	{ return ::EnableScrollBar(m_hWnd, SB_CTL, nArrowFlags); }
#endif // WINVER >= 0x030a

// MDI functions
#ifndef _AFXCTL
_AFXWIN_INLINE void CMDIFrameWnd::MDIActivate(CWnd* pWndActivate)
	{ ::SendMessage(m_hWndMDIClient, WM_MDIACTIVATE,
		(WPARAM)pWndActivate->m_hWnd, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIIconArrange()
	{ ::SendMessage(m_hWndMDIClient, WM_MDIICONARRANGE, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIMaximize(CWnd* pWnd)
	{ ::SendMessage(m_hWndMDIClient, WM_MDIMAXIMIZE, (WPARAM)pWnd->m_hWnd, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDINext()
	{ ::SendMessage(m_hWndMDIClient, WM_MDINEXT, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDIRestore(CWnd* pWnd)
	{ ::SendMessage(m_hWndMDIClient, WM_MDIRESTORE, (WPARAM)pWnd->m_hWnd, 0); }
_AFXWIN_INLINE CMenu* CMDIFrameWnd::MDISetMenu(CMenu* pFrameMenu, CMenu* pWindowMenu)
	{ return CMenu::FromHandle((HMENU)::SendMessage(
		m_hWndMDIClient, WM_MDISETMENU, 0,
		MAKELONG(pFrameMenu->GetSafeHmenu(),
		pWindowMenu->GetSafeHmenu())));
	}
_AFXWIN_INLINE void CMDIFrameWnd::MDITile()
	{ ::SendMessage(m_hWndMDIClient, WM_MDITILE, 0, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDICascade()
	{ ::SendMessage(m_hWndMDIClient, WM_MDICASCADE, 0, 0); }

#if (WINVER >= 0x030a)
_AFXWIN_INLINE void CMDIFrameWnd::MDICascade(int nType)
	{ ::SendMessage(m_hWndMDIClient, WM_MDICASCADE, nType, 0); }
_AFXWIN_INLINE void CMDIFrameWnd::MDITile(int nType)
	{ ::SendMessage(m_hWndMDIClient, WM_MDITILE, nType, 0); }
#endif // WINVER >= 0x030a
_AFXWIN_INLINE void CMDIChildWnd::MDIDestroy()
	{ ::SendMessage(GetParent()->m_hWnd, WM_MDIDESTROY, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIActivate()
	{ ::SendMessage(GetParent()->m_hWnd, WM_MDIACTIVATE, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIMaximize()
	{ ::SendMessage(GetParent()->m_hWnd, WM_MDIMAXIMIZE, (WPARAM)m_hWnd, 0L); }
_AFXWIN_INLINE void CMDIChildWnd::MDIRestore()
	{ ::SendMessage(GetParent()->m_hWnd, WM_MDIRESTORE, (WPARAM)m_hWnd, 0L); }
#endif //_AFXCTL

// CView
_AFXWIN_INLINE CDocument* CView::GetDocument() const
	{ return m_pDocument; }
_AFXWIN_INLINE CSize CScrollView::GetTotalSize() const
	{ return m_totalLog; }

// CDocument
_AFXWIN_INLINE const CString& CDocument::GetTitle() const
	{ return m_strTitle; }
_AFXWIN_INLINE const CString& CDocument::GetPathName() const
	{ return m_strPathName; }
_AFXWIN_INLINE CDocTemplate* CDocument::GetDocTemplate() const
	{ return m_pDocTemplate; }
_AFXWIN_INLINE BOOL CDocument::IsModified()
	{ return m_bModified; }
_AFXWIN_INLINE void CDocument::SetModifiedFlag(BOOL bModified)
	{ m_bModified = bModified; }

// CWinApp
_AFXWIN_INLINE HCURSOR CWinApp::LoadCursor(LPCSTR lpszResourceName) const
	{ return ::LoadCursor(AfxGetResourceHandle(), lpszResourceName); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadCursor(UINT nIDResource) const
	{ return ::LoadCursor(AfxGetResourceHandle(),
		MAKEINTRESOURCE(nIDResource)); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadStandardCursor(LPCSTR lpszCursorName) const
	{ return ::LoadCursor(NULL, lpszCursorName); }
_AFXWIN_INLINE HCURSOR CWinApp::LoadOEMCursor(UINT nIDCursor) const
	{ return ::LoadCursor(NULL, MAKEINTRESOURCE(nIDCursor)); }
_AFXWIN_INLINE HICON CWinApp::LoadIcon(LPCSTR lpszResourceName) const
	{ return ::LoadIcon(AfxGetResourceHandle(), lpszResourceName); }
_AFXWIN_INLINE HICON CWinApp::LoadIcon(UINT nIDResource) const
	{ return ::LoadIcon(AfxGetResourceHandle(), MAKEINTRESOURCE(nIDResource)); }
_AFXWIN_INLINE HICON CWinApp::LoadStandardIcon(LPCSTR lpszIconName) const
	{ return ::LoadIcon(NULL, lpszIconName); }
_AFXWIN_INLINE HICON CWinApp::LoadOEMIcon(UINT nIDIcon) const
	{ return ::LoadIcon(NULL, MAKEINTRESOURCE(nIDIcon)); }

/////////////////////////////////////////////////////////////////////////////
// Obsolete and non-portable

_AFXWIN_INLINE void CWnd::CloseWindow()
	{ ::CloseWindow(m_hWnd); }
_AFXWIN_INLINE BOOL CWnd::OpenIcon()
	{ return ::OpenIcon(m_hWnd); }
_AFXWIN_INLINE CWnd* CWnd::SetSysModalWindow()
	{ return CWnd::FromHandle(::SetSysModalWindow(m_hWnd)); }
_AFXWIN_INLINE CWnd* PASCAL CWnd::GetSysModalWindow()
	{ return CWnd::FromHandle(::GetSysModalWindow()); }

/////////////////////////////////////////////////////////////////////////////

#endif //_AFXWIN_INLINE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\sdktools\msvc15\mfc\include\winres.h ===
// Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation,
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// winres.h - Windows resource definitions
//  extracted from WINDOWS.H
//          Version 3.10
//          Copyright (c) 1985-1993, Microsoft Corp. All rights reserved.
//

#ifdef APSTUDIO_INVOKED
#define APSTUDIO_HIDDEN_SYMBOLS // Ignore following symbols
#endif

#define OBM_CLOSE       32754
#define OBM_UPARROW     32753
#define OBM_DNARROW     32752
#define OBM_RGARROW     32751
#define OBM_LFARROW     32750
#define OBM_REDUCE      32749
#define OBM_ZOOM        32748
#define OBM_RESTORE     32747
#define OBM_REDUCED     32746
#define OBM_ZOOMD       32745
#define OBM_RESTORED    32744
#define OBM_UPARROWD    32743
#define OBM_DNARROWD    32742
#define OBM_RGARROWD    32741
#define OBM_LFARROWD    32740
#define OBM_MNARROW     32739
#define OBM_COMBO       32738
#define OBM_UPARROWI    32737
#define OBM_DNARROWI    32736
#define OBM_RGARROWI    32735
#define OBM_LFARROWI    32734
#define OBM_OLD_CLOSE   32767
#define OBM_SIZE        32766
#define OBM_OLD_UPARROW 32765
#define OBM_OLD_DNARROW 32764
#define OBM_OLD_RGARROW 32763
#define OBM_OLD_LFARROW 32762
#define OBM_BTSIZE      32761
#define OBM_CHECK       32760
#define OBM_CHECKBOXES  32759
#define OBM_BTNCORNERS  32758
#define OBM_OLD_REDUCE  32757
#define OBM_OLD_ZOOM    32756
#define OBM_OLD_RESTORE 32755
#define OCR_NORMAL      32512
#define OCR_IBEAM       32513
#define OCR_WAIT        32514
#define OCR_CROSS       32515
#define OCR_UP          32516
#define OCR_SIZE        32640
#define OCR_ICON        32641
#define OCR_SIZENWSE    32642
#define OCR_SIZENESW    32643
#define OCR_SIZEWE      32644
#define OCR_SIZENS      32645
#define OCR_SIZEALL     32646
#define OCR_ICOCUR      32647
#define OIC_SAMPLE      32512
#define OIC_HAND        32513
#define OIC_QUES        32514
#define OIC_BANG        32515
#define OIC_NOTE        32516

#define WS_OVERLAPPED   0x00000000L
#define WS_POPUP        0x80000000L
#define WS_CHILD        0x40000000L
#define WS_CLIPSIBLINGS 0x04000000L
#define WS_CLIPCHILDREN 0x02000000L
#define WS_VISIBLE      0x10000000L
#define WS_DISABLED     0x08000000L
#define WS_MINIMIZE     0x20000000L
#define WS_MAXIMIZE     0x01000000L
#define WS_CAPTION      0x00C00000L
#define WS_BORDER       0x00800000L
#define WS_DLGFRAME     0x00400000L
#define WS_VSCROLL      0x00200000L
#define WS_HSCROLL      0x00100000L
#define WS_SYSMENU      0x00080000L
#define WS_THICKFRAME   0x00040000L
#define WS_MINIMIZEBOX  0x00020000L
#define WS_MAXIMIZEBOX  0x00010000L
#define WS_GROUP        0x00020000L
#define WS_TABSTOP      0x00010000L

// other aliases
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW  (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW  (WS_CHILD)
#define WS_TILED        WS_OVERLAPPED
#define WS_ICONIC       WS_MINIMIZE
#define WS_SIZEBOX      WS_THICKFRAME
#define WS_TILEDWINDOW  WS_OVERLAPPEDWINDOW

#define VK_LBUTTON      0x01
#define VK_RBUTTON      0x02
#define VK_CANCEL       0x03
#define VK_MBUTTON      0x04
#define VK_BACK         0x08
#define VK_TAB          0x09
#define VK_CLEAR        0x0C
#define VK_RETURN       0x0D
#define VK_SHIFT        0x10
#define VK_CONTROL      0x11
#define VK_MENU         0x12
#define VK_PAUSE        0x13
#define VK_CAPITAL      0x14
#define VK_ESCAPE       0x1B
#define VK_SPACE        0x20
#define VK_PRIOR        0x21
#define VK_NEXT         0x22
#define VK_END          0x23
#define VK_HOME         0x24
#define VK_LEFT         0x25
#define VK_UP           0x26
#define VK_RIGHT        0x27
#define VK_DOWN         0x28
#define VK_SELECT       0x29
#define VK_PRINT        0x2A
#define VK_EXECUTE      0x2B
#define VK_SNAPSHOT     0x2C
#define VK_INSERT       0x2D
#define VK_DELETE       0x2E
#define VK_HELP         0x2F
#define VK_NUMPAD0      0x60
#define VK_NUMPAD1      0x61
#define VK_NUMPAD2      0x62
#define VK_NUMPAD3      0x63
#define VK_NUMPAD4      0x64
#define VK_NUMPAD5      0x65
#define VK_NUMPAD6      0x66
#define VK_NUMPAD7      0x67
#define VK_NUMPAD8      0x68
#define VK_NUMPAD9      0x69
#define VK_MULTIPLY     0x6A
#define VK_ADD          0x6B
#define VK_SEPARATOR    0x6C
#define VK_SUBTRACT     0x6D
#define VK_DECIMAL      0x6E
#define VK_DIVIDE       0x6F
#define VK_F1           0x70
#define VK_F2           0x71
#define VK_F3           0x72
#define VK_F4           0x73
#define VK_F5           0x74
#define VK_F6           0x75
#define VK_F7           0x76
#define VK_F8           0x77
#define VK_F9           0x78
#define VK_F10          0x79
#define VK_F11          0x7A
#define VK_F12          0x7B
#define VK_F13          0x7C
#define VK_F14          0x7D
#define VK_F15          0x7E
#define VK_F16          0x7F
#define VK_F17          0x80
#define VK_F18          0x81
#define VK_F19          0x82
#define VK_F20          0x83
#define VK_F21          0x84
#define VK_F22          0x85
#define VK_F23          0x86
#define VK_F24          0x87
#define VK_NUMLOCK      0x90
#define VK_SCROLL       0x91

#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

#define DS_ABSALIGN     0x01L
#define DS_SYSMODAL     0x02L
#define DS_LOCALEDIT    0x20L
#define DS_SETFONT      0x40L
#define DS_MODALFRAME   0x80L
#define DS_NOIDLEMSG    0x100L

#define SS_LEFT         0x00000000L
#define SS_CENTER       0x00000001L
#define SS_RIGHT        0x00000002L
#define SS_ICON         0x00000003L
#define SS_BLACKRECT    0x00000004L
#define SS_GRAYRECT     0x00000005L
#define SS_WHITERECT    0x00000006L
#define SS_BLACKFRAME   0x00000007L
#define SS_GRAYFRAME    0x00000008L
#define SS_WHITEFRAME   0x00000009L
#define SS_SIMPLE       0x0000000BL
#define SS_LEFTNOWORDWRAP 0x0000000CL
#define SS_NOPREFIX     0x00000080L

#define BS_PUSHBUTTON   0x00000000L
#define BS_DEFPUSHBUTTON 0x00000001L
#define BS_CHECKBOX     0x00000002L
#define BS_AUTOCHECKBOX 0x00000003L
#define BS_RADIOBUTTON  0x00000004L
#define BS_3STATE       0x00000005L
#define BS_AUTO3STATE   0x00000006L
#define BS_GROUPBOX     0x00000007L
#define BS_USERBUTTON   0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT     0x00000020L

#define ES_LEFT         0x00000000L
#define ES_CENTER       0x00000001L
#define ES_RIGHT        0x00000002L
#define ES_MULTILINE    0x00000004L
#define ES_UPPERCASE    0x00000008L
#define ES_LOWERCASE    0x00000010L
#define ES_PASSWORD     0x00000020L
#define ES_AUTOVSCROLL  0x00000040L
#define ES_AUTOHSCROLL  0x00000080L
#define ES_NOHIDESEL    0x00000100L
#define ES_OEMCONVERT   0x00000400L
#define ES_READONLY     0x00000800L
#define ES_WANTRETURN   0x00001000L

#define SBS_HORZ        0x0000L
#define SBS_VERT        0x0001L
#define SBS_TOPALIGN    0x0002L
#define SBS_LEFTALIGN   0x0002L
#define SBS_BOTTOMALIGN 0x0004L
#define SBS_RIGHTALIGN  0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN 0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX     0x0008L

#define LBS_NOTIFY      0x0001L
#define LBS_SORT        0x0002L
#define LBS_NOREDRAW    0x0004L
#define LBS_MULTIPLESEL 0x0008L
#define LBS_OWNERDRAWFIXED 0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS  0x0040L
#define LBS_USETABSTOPS 0x0080L
#define LBS_NOINTEGRALHEIGHT 0x0100L
#define LBS_MULTICOLUMN 0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL 0x0800L
#define LBS_DISABLENOSCROLL 0x1000L
#define LBS_STANDARD    (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)

#define CBS_SIMPLE      0x0001L
#define CBS_DROPDOWN    0x0002L
#define CBS_DROPDOWNLIST 0x0003L
#define CBS_OWNERDRAWFIXED 0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL 0x0040L
#define CBS_OEMCONVERT  0x0080L
#define CBS_SORT        0x0100L
#define CBS_HASSTRINGS  0x0200L
#define CBS_NOINTEGRALHEIGHT 0x0400L
#define CBS_DISABLENOSCROLL 0x0800L

// operation messages sent to DLGINIT
#define WM_USER         0x0400
#define LB_ADDSTRING    (WM_USER+1)
#define CB_ADDSTRING    (WM_USER+3)

#ifdef APSTUDIO_INVOKED
#undef APSTUDIO_HIDDEN_SYMBOLS
#endif

#define IDOK            1
#define IDCANCEL        2
#define IDABORT         3
#define IDRETRY         4
#define IDIGNORE        5
#define IDYES           6
#define IDNO            7
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\handle.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module contains the handle table mgmt routines.

Author:

    Wesley Witt (wesw) 12-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop




PHANDLE_ENTRY
CreateNewHandle(
    PFAX_HANDLE_DATA    pFaxData,
    FaxHandleType       Type,
    DWORD               Flags,
    HANDLE              hGeneric
    )
{
    PHANDLE_ENTRY pHandleEntry;

    DEBUG_FUNCTION_NAME(TEXT("CreateNewHandle"));

    pHandleEntry = (PHANDLE_ENTRY) MemAlloc( sizeof(HANDLE_ENTRY) );
    Assert (pFaxData);
    if (!pHandleEntry) 
    {
        return NULL;
    }

    EnterCriticalSection( &pFaxData->CsHandleTable );

    InsertTailList( &pFaxData->HandleTableListHead, &pHandleEntry->ListEntry );

    pHandleEntry->Type           = Type;
    pHandleEntry->Flags          = Flags;
    pHandleEntry->FaxData        = pFaxData;
    pHandleEntry->hGeneric       = hGeneric;
    pHandleEntry->DeviceId       = 0;
    pHandleEntry->FaxContextHandle = NULL;
    pFaxData->dwRefCount++;

    LeaveCriticalSection( &pFaxData->CsHandleTable );

    return pHandleEntry;
}


PHANDLE_ENTRY
CreateNewServiceHandle(
    PFAX_HANDLE_DATA    pFaxData
    )
/*++

Routine name : CreateNewServiceHandle

Routine description:

    Creates a new service context handle.

Arguments:

    pFaxData    [in] - Pointer to context data

Return Value:

    Pointer to newly created handle or NULL in case of a failure.

    Callee should call CloseFaxHandle() for proper cleanup.
    
--*/

{
    PHANDLE_ENTRY pHandleEntry = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    
    DEBUG_FUNCTION_NAME(TEXT("CreateNewServiceHandle"));

    __try
    {
        InitializeCriticalSection( &pFaxData->CsHandleTable );
    }
    __except (StatusNoMemoryExceptionFilter(GetExceptionCode()))
    {
        dwRes = GetExceptionCode ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("InitializeCriticalSection failed: err = %lu"),
            dwRes);
        return NULL;
    }

    pHandleEntry = CreateNewHandle(
                        pFaxData,
                        FHT_SERVICE,
                        0,
                        NULL
                        );
    if (!pHandleEntry)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR, 
            TEXT("CreateNewHandle() failed ec=%lu."),
            dwRes);        
        goto exit;
    }
    
    Assert(dwRes == ERROR_SUCCESS);

exit:
    if (dwRes != ERROR_SUCCESS)
    {
        DeleteCriticalSection (&pFaxData->CsHandleTable);
    }

    return pHandleEntry;
} // CreateNewServiceHandle


PHANDLE_ENTRY
CreateNewPortHandle(
    PFAX_HANDLE_DATA    FaxData,
    DWORD               Flags,
    HANDLE              FaxPortHandle
    )
{
    return CreateNewHandle(
        FaxData,
        FHT_PORT,
        Flags,
        FaxPortHandle       
        );
}

PHANDLE_ENTRY
CreateNewMsgEnumHandle(
    PFAX_HANDLE_DATA    pFaxData
)
/*++

Routine name : CreateNewMsgEnumHandle

Routine description:

    Creates a new enumeration context handle

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    pFaxData    [in] - Pointer to context data

Return Value:

    Pointer to newly created handle

--*/
{
    Assert (pFaxData);
    return CreateNewHandle(
        pFaxData,
        FHT_MSGENUM,
        0,
        NULL       
        );
}   // CreateNewMsgEnumHandle


VOID
CloseFaxHandle(
    PHANDLE_ENTRY       pHandleEntry
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CloseFaxHandle"));

    Assert (pHandleEntry);

    PFAX_HANDLE_DATA pData = pHandleEntry->FaxData;
    Assert (pData);
    EnterCriticalSection( &pData->CsHandleTable );
    RemoveEntryList( &pHandleEntry->ListEntry );
#if DBG
    ZeroMemory (pHandleEntry, sizeof (HANDLE_ENTRY));
#endif
    //
    // We put an invalid value in the handle type just in case someone calls FaxClose again with the same value.
    //
    pHandleEntry->Type = (FaxHandleType)0xffff;
    MemFree( pHandleEntry );
    //
    // Decrease reference count of data
    //
    Assert (pData->dwRefCount > 0);
    (pData->dwRefCount)--;
    if (0 == pData->dwRefCount)
    {
        //
        // Time to delete the handle's data
        //

        MemFree(pData->MachineName);
        LeaveCriticalSection(&pData->CsHandleTable);
        DeleteCriticalSection (&pData->CsHandleTable);
#if DBG
        ZeroMemory (pData, sizeof (FAX_HANDLE_DATA));
#endif
        MemFree(pData);
    }
    else
    {
        LeaveCriticalSection(&pData->CsHandleTable);
    }
}   // CloseFaxHandle
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\faxapi.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxapi.c

Abstract:

    This module contains the Win32 FAX APIs.
    The function implemented here are simply very
    thin wrappers around the RPC stubs.  The wrappers
    are necessary so that the last error value
    is set properly.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop

static
DWORD
ConnectToFaxServer(
    PHANDLE_ENTRY       pHandleEntry,
    PFAX_HANDLE_DATA    pFaxData
    )
/*++

Routine Description:

    Helper function that wrap RPC call for connecting to the fax service.

    The function first attempt to call FAX_ConnectFaxServer in order to connect to .NET or XP fax servers,
    if the call fails with RPC_S_PROCNUM_OUT_OF_RANGE, that indicates that we are dealing with BOS 2000, we try 
    to connect to BOS fax server with FAX_ConnectionRefCount.

Arguments:

    pHandleEntry            - [in/out] pointer to fax service handle entry.
                                       the function will use the binding handle and update the context handle.
    pFaxData                - [in/out] pointer to fax handle data.
                                       the function will update the server's API version within this handle data

Return Value:

    Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("ConnectToFaxServer"));

    Assert (pHandleEntry);
    Assert (pFaxData);

    __try
    {
        dwRes = FAX_ConnectFaxServer(   FH_FAX_HANDLE(pHandleEntry),              // Binding handle
                                        CURRENT_FAX_API_VERSION,                  // Our API version
                                        &(pFaxData->dwReportedServerAPIVersion),  // Server's API version
                                        &FH_CONTEXT_HANDLE(pHandleEntry));        // Server's context handle
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        dwRes = GetExceptionCode();
    }

    if (ERROR_SUCCESS != dwRes)
    {
        if (RPC_S_PROCNUM_OUT_OF_RANGE == dwRes)
        {
            // 
            // Got "The procedure number is out of range.".
            // This is because we're trying to call an RPC function which doesn't exist in BOS 2000 Fax server.
            // Try the 'old' FaxConnectionRefCount() call 
            //
            DWORD dwShare;  // Igonred
            __try
            {
                dwRes = FAX_ConnectionRefCount( FH_FAX_HANDLE(pHandleEntry),
                                                &FH_CONTEXT_HANDLE(pHandleEntry),
                                                1,
                                                &dwShare);
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                //
                // For some reason we crashed.
                //
                dwRes = GetExceptionCode();
            }
            if (ERROR_SUCCESS == dwRes)
            {
                //
                // Hooray!!! This is a BOS 2000 Fax Server
                //
                pFaxData->dwReportedServerAPIVersion = FAX_API_VERSION_0;
            }
            else
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Exception on RPC call to FAX_ConnectionRefCount. (ec: %lu)"),
                    dwRes);

                DumpRPCExtendedStatus ();
            }
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Exception on RPC call to FAX_ConnectFaxServer. (ec: %lu)"),
                dwRes);

            DumpRPCExtendedStatus ();
        }
    }
   return  dwRes;
         
}   // ConnectToFaxServer

               


//
// Note: the name of this function is actually a macro that expands to FaxConnectFaxServerW
// or FaxConnectFaxServerA depnding on the UNICODE macro.
//
BOOL
WINAPI
FaxConnectFaxServer(
    IN LPCTSTR lpMachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )

/*++

Routine Description:

    Creates a connection to a FAX server.  The binding handle that is
    returned is used for all subsequent FAX API calls.

Arguments:

    lpMachineName - Machine name, NULL, or "."
    FaxHandle     - Pointer to a FAX handle



Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    PFAX_HANDLE_DATA pFaxData = NULL;
    PHANDLE_ENTRY pHandleEntry = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    BOOL bLocalConnection = IsLocalMachineName (lpMachineName);

    DEBUG_FUNCTION_NAME(TEXT("FaxConnectFaxServer"));

    if (!FaxHandle)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("FaxHandle is NULL."));
        return FALSE;
    }

    pFaxData = (PFAX_HANDLE_DATA)MemAlloc( sizeof(FAX_HANDLE_DATA) );
    if (!pFaxData)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        DebugPrintEx(DEBUG_ERR, _T("MemAlloc is failed."));
        return FALSE;
    }

    ZeroMemory (pFaxData, sizeof(FAX_HANDLE_DATA));

    pFaxData->bLocalConnection = bLocalConnection;
    InitializeListHead( &pFaxData->HandleTableListHead );

    //
    //  Create new Service handle, in case of an error 
    //  after this function succeeded cleanup code must call CloseFaxHandle()
    //
    pHandleEntry = CreateNewServiceHandle( pFaxData );
    if (!pHandleEntry)
    {
        dwRes = GetLastError ();
        DebugPrintEx(DEBUG_ERR, _T("CreateNewServiceHandle() failed."));

        MemFree(pFaxData);
        return FALSE;
    }

    dwRes = FaxClientBindToFaxServer( lpMachineName, FAX_RPC_ENDPOINT, NULL, &pFaxData->FaxHandle );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxClientBindToFaxServer() failed with %ld."), dwRes);
        pFaxData->FaxHandle = NULL;
        goto ErrorExit;
    }

    if (!bLocalConnection)
    {
        //
        // This is not the local machine, Remove all \\ from machine name
        //
        LPCTSTR lpctstrDelim = _tcsrchr(lpMachineName, TEXT('\\'));
        if (NULL == lpctstrDelim)
        {
            lpctstrDelim = lpMachineName;
        }
        else
        {
            lpctstrDelim = _tcsinc(lpctstrDelim);
        }

        pFaxData->MachineName = StringDup (lpctstrDelim);
        if (!pFaxData->MachineName)
        {
            dwRes = ERROR_NOT_ENOUGH_MEMORY;            
            goto ErrorExit;
        }
    }

    //
    // Ask for the highest level of privacy (autnetication + encryption)
    //
    dwRes = RpcBindingSetAuthInfo (
                FH_FAX_HANDLE(pHandleEntry),    // RPC binding handle
                RPC_SERVER_PRINCIPAL_NAME,      // Server principal name
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,  // Authentication level - fullest
                                                // Authenticates, verifies, and privacy-encrypts the arguments passed
                                                // to every remote call.
                RPC_C_AUTHN_WINNT,              // Authentication service (NTLMSSP)
                NULL,                           // Authentication identity - use currently logged on user
                0);                             // Unused when Authentication service == RPC_C_AUTHN_WINNT
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Couldn't set RPC authentication mode
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcBindingSetAuthInfo (RPC_C_AUTHN_LEVEL_PKT_PRIVACY) failed. (ec: %ld)"),
            dwRes);     
        goto ErrorExit;
    }

    //
    //  On local connections make sure that the fax service is up 
    //
    if (bLocalConnection)
    {
        if (!EnsureFaxServiceIsStarted (NULL))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EnsureFaxServiceIsStarted failed (ec = %ld"),
                dwRes);
            goto ErrorExit;
        }
        else
        {
            //
            // Wait till the RPC service is up an running
            //
            if (!WaitForServiceRPCServer (60 * 1000))
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("WaitForServiceRPCServer failed (ec = %ld"),
                    dwRes);
                goto ErrorExit;
            }
        }
    }

    
    //
    // Here we tries to connect to the Fax service.
    //
    // We try to connect three times, two times using RPC_C_AUTHN_LEVEL_PKT_PRIVACY Authentication level
    // and if we fail we drop to RPC_C_AUTHN_LEVEL_NONE Authentication level.
    //
    // We try twice with RPC_C_AUTHN_LEVEL_PKT_PRIVACY authentication level, because RPC runtime infrastructure might cache 
    // the service handle, and if the service was restarted the first RPC call will use the old cached data, and will fail.
    // RPC cannot internally retry because we dealling with privacy authentication and thus we do the retry.
    //
    // If we fail to connect twice we drop the authentication level and retry. This is done to allow .NET clients to connect to
    // Fax servers that does not use a secure channel.
    // We do not need to retry the connection, beacuse RPC will do that internally.
    //
    dwRes = ConnectToFaxServer(pHandleEntry,pFaxData);
    if (dwRes != ERROR_SUCCESS)
    {
        DebugPrintEx (DEBUG_WRN, 
                      TEXT("fisrt call to ConnectToFaxServer failed with - %lu"),
                      dwRes);

        dwRes = ConnectToFaxServer(pHandleEntry,pFaxData);
        if (dwRes != ERROR_SUCCESS)
        {
            //
            //  We failed twice, Drop authentication level and retry.
            //

            DebugPrintEx (DEBUG_WRN, 
                      TEXT("second call to ConnectToFaxServer failed with - %lu"),
                      dwRes);

            DebugPrintEx (DEBUG_WRN, 
                          TEXT("Warning!!! not using encryption anymore against remote server %s"),
                          lpMachineName);

            dwRes = RpcBindingSetAuthInfo (
                        FH_FAX_HANDLE(pHandleEntry),    // RPC binding handle
                        RPC_SERVER_PRINCIPAL_NAME,      // Server principal name
                        RPC_C_AUTHN_LEVEL_NONE,         // Authentication level - none
                        RPC_C_AUTHN_WINNT,              // Authentication service (NTLMSSP)
                        NULL,                           // Authentication identity - use currently logged on user
                        0);                             // Unused when Authentication service == RPC_C_AUTHN_WINNT
            if (ERROR_SUCCESS != dwRes)
            {
                //
                // Couldn't set RPC authentication mode
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RpcBindingSetAuthInfo (RPC_C_AUTHN_LEVEL_NONE) failed. (ec: %lu)"),
                    dwRes);
                goto ErrorExit;
            }
            dwRes = ConnectToFaxServer(pHandleEntry,pFaxData);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx (DEBUG_ERR, 
                      TEXT("third call to ConnectToFaxServer failed with - %lu"),
                      dwRes);
                goto ErrorExit;
            }
        }
    }

    if (ERROR_SUCCESS == dwRes)
    {
        //
        // Succeeded to connect 
        //
        pFaxData->dwServerAPIVersion = pFaxData->dwReportedServerAPIVersion;
        if (pFaxData->dwReportedServerAPIVersion > CURRENT_FAX_API_VERSION)
        {
            //
            // This is the filtering.
            // Assume we're talking to a Windows XP server since we have no knowledge of future servers.
            //
            pFaxData->dwServerAPIVersion = CURRENT_FAX_API_VERSION;
        }
        
        *FaxHandle = (LPHANDLE) pHandleEntry;
        return TRUE; 
    }
    
ErrorExit:
    Assert (ERROR_SUCCESS != dwRes);

    if (NULL != pFaxData)
    {
        if (NULL != pFaxData->FaxHandle)
        {
            RpcBindingFree(&pFaxData->FaxHandle);            
        }
    }
    
    //
    // clean up for CreateNewServiceHandle
    //
    CloseFaxHandle ( pHandleEntry );

    SetLastError(dwRes);
    return FALSE;
}   // FaxConnectFaxServer



#ifdef UNICODE
BOOL
WINAPI
FaxConnectFaxServerA(
    IN LPCSTR lpMachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )

/*++

Routine Description:

    Creates a connection to a FAX server.  The binding handle that is
    returned is used for all subsequent FAX API calls.

Arguments:

    MachineName - Machine name, NULL, or "."
    FaxHandle   - Pointer to a FAX handle



Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    PWCHAR lpwstrMachineName = NULL;
    BOOL   bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxConnectFaxServerA"));

    if (lpMachineName)
    {
        //
        // Create Unicode machine name
        //
        lpwstrMachineName = AnsiStringToUnicodeString (lpMachineName);
        if (!lpwstrMachineName)
        {
            return FALSE;
        }
    }
    bRes = FaxConnectFaxServerW (lpwstrMachineName, FaxHandle);
    MemFree (lpwstrMachineName);
    return bRes;
}   // FaxConnectFaxServerA



#else
//
// When compiling this code to ANSI we do not want to support the Unicode version.
//
BOOL
WINAPI
FaxConnectFaxServerW(
    IN LPCWSTR lpMachineName OPTIONAL,
    OUT LPHANDLE FaxHandle
    )
{
    UNREFERENCED_PARAMETER(lpMachineName);
    UNREFERENCED_PARAMETER(FaxHandle);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif



BOOL
WINAPI
FaxGetDeviceStatusW(
    IN  const HANDLE FaxHandle,
    OUT PFAX_DEVICE_STATUSW *DeviceStatus
    )

/*++

Routine Description:

    Obtains a status report for the FAX devices being
    used by the FAX server.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    StatusBuffer    - Buffer for the status data
    BufferSize      - Size of the StatusBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    #define FixupString(_s) FixupStringPtrW(DeviceStatus,_s)
    error_status_t ec;
    DWORD BufferSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetDeviceStatusW"));

    if (!ValidateFaxHandle(FaxHandle, FHT_PORT)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!DeviceStatus) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("DeviceStatus is NULL."));
        return FALSE;
    }

    *DeviceStatus = NULL;

    __try
    {
        ec = FAX_GetDeviceStatus(
            FH_PORT_HANDLE(FaxHandle),
            (LPBYTE*)DeviceStatus,
            &BufferSize
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetDeviceStatus. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    FixupString( (*DeviceStatus)->CallerId       );
    FixupString( (*DeviceStatus)->Csid           );
    FixupString( (*DeviceStatus)->DeviceName     );
    FixupString( (*DeviceStatus)->DocumentName   );
    FixupString( (*DeviceStatus)->PhoneNumber    );
    FixupString( (*DeviceStatus)->RoutingString  );
    FixupString( (*DeviceStatus)->SenderName     );
    FixupString( (*DeviceStatus)->RecipientName  );
    FixupString( (*DeviceStatus)->StatusString   );
    FixupString( (*DeviceStatus)->Tsid           );
    FixupString( (*DeviceStatus)->UserName       );

    return TRUE;
}


BOOL
WINAPI
FaxGetDeviceStatusA(
    IN  const HANDLE FaxHandle,
    OUT PFAX_DEVICE_STATUSA *DeviceStatus
    )

/*++

Routine Description:

    Obtains a status report for the FAX devices being
    used by the FAX server.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    StatusBuffer    - Buffer for the status data
    BufferSize      - Size of the StatusBuffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    //
    //  no need to validate parameters, FaxGetDeviceStatusW() will do that
    //
    DEBUG_FUNCTION_NAME(TEXT("FaxGetDeviceStatusA"));
    if (!FaxGetDeviceStatusW( FaxHandle, (PFAX_DEVICE_STATUSW *)DeviceStatus )) 
    {
        return FALSE;
    }

    if (!ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->CallerId       )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->Csid           )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->DeviceName     )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->DocumentName   )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->PhoneNumber    )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->RoutingString  )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->SenderName     )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->RecipientName  )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->StatusString   )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->Tsid           )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*DeviceStatus)->UserName       ))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*DeviceStatus);
        return FALSE;
    }
    (*DeviceStatus)->SizeOfStruct = sizeof(FAX_DEVICE_STATUSA);
    return TRUE;
}   // FaxGetDeviceStatusA



BOOL
WINAPI
FaxClose(
    IN const HANDLE FaxHandle
    )
{
    error_status_t ec;
    PHANDLE_ENTRY pHandleEntry = (PHANDLE_ENTRY) FaxHandle;
    HANDLE TmpFaxPortHandle;
    DWORD CanShare;

    DEBUG_FUNCTION_NAME(TEXT("FaxClose"));

    if (!FaxHandle || IsBadReadPtr ((LPVOID)FaxHandle, sizeof (HANDLE_ENTRY)))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("!FaxHandle || IsBadReadPtr(FaxHandle)."));
        return FALSE;
    }

    switch (pHandleEntry->Type)
    {
        case FHT_SERVICE:

            __try
            {
                ec = FAX_ConnectionRefCount( FH_FAX_HANDLE(FaxHandle), &FH_CONTEXT_HANDLE(FaxHandle), 0, &CanShare );
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                //
                // For some reason we crashed.
                //
                ec = GetExceptionCode();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Exception on RPC call to FAX_ConnectionRefCount. (ec: %ld)"),
                    ec);
            }
            if (ERROR_SUCCESS != ec)
            {
                DumpRPCExtendedStatus ();
            }

            __try
            {
                ec = FaxClientUnbindFromFaxServer( (RPC_BINDING_HANDLE *) pHandleEntry->FaxData->FaxHandle );
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                ec = GetExceptionCode();
            }
            EnterCriticalSection( &pHandleEntry->FaxData->CsHandleTable );
            //
            // Zero the binding handle so that no further RPC calls will be made with floating handles
            // that still hold the FAX_HANDLE_DATA (e.g. from FaxOpenPort).
            //
            pHandleEntry->FaxData->FaxHandle = 0;
#if DBG
            if (pHandleEntry->FaxData->dwRefCount > 1)
            {
                //
                // The user closed the binding handle (called FaxClose (hFax)) before closing all context
                // handles (e.g. FaxClose (hPort)).
                // This is not a real problem - the reference count mechanism will take care of it.
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("User called FaxClose with a service handle but still has live context handles (port or message enum)"));
            }
#endif
            LeaveCriticalSection( &pHandleEntry->FaxData->CsHandleTable );

            CloseFaxHandle ( pHandleEntry );
            return TRUE;

        case FHT_PORT:
            TmpFaxPortHandle = pHandleEntry->hGeneric;
            CloseFaxHandle( pHandleEntry );
            __try
            {
                ec = FAX_ClosePort( &TmpFaxPortHandle );
            }
            __except (EXCEPTION_EXECUTE_HANDLER)
            {
                //
                // For some reason we crashed.
                //
                ec = GetExceptionCode();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Exception on RPC call to FAX_ClosePort. (ec: %ld)"),
                    ec);
            }
            if (ec)
            {
                DumpRPCExtendedStatus ();
                SetLastError( ec );
                return FALSE;
            }
            break;

        default:
            SetLastError( ERROR_INVALID_HANDLE );
            return FALSE;
    }

    return TRUE;
}



BOOL
WINAPI
FaxGetSecurityEx(
    IN HANDLE hFaxHandle,
    IN SECURITY_INFORMATION SecurityInformation,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
/*++

Routine name : FaxGetSecurityEx

Routine description:

    Gets the server's security descriptor

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle              [in ] - Handle to fax server
    SECURITY_INFORMATION    [in ] - Defines the desired entries in the security descriptor (Bit wise OR )
    ppSecurityDescriptor    [out] - Pointer to receive buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DWORD BufferSize = 0;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetSecurityEx"));
    DWORD dwSecInfo = ( OWNER_SECURITY_INFORMATION  |
                        GROUP_SECURITY_INFORMATION  |
                        DACL_SECURITY_INFORMATION   |
                        SACL_SECURITY_INFORMATION );


    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (0 == (SecurityInformation & dwSecInfo))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        DebugPrintEx(DEBUG_ERR, _T("SecurityInformation is invalid - No valid bit type indicated"));
        return FALSE;
    }

    if (0 != (SecurityInformation & ~dwSecInfo))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        DebugPrintEx(DEBUG_ERR, _T("SecurityInformation is invalid - contains invalid securtiy information bits"));
        return FALSE;
    }

    if (!ppSecurityDescriptor)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppSecurityDescriptor is NULL."));
        return FALSE;
    }

    if (FAX_API_VERSION_1 > FH_SERVER_VER(hFaxHandle))
    {
        //
        // Servers of API version 0 don't support FAX_GetSecurityEx
        //
        DebugPrintEx(DEBUG_MSG, 
                     _T("Server version is %ld - doesn't support FAX_GetSecurityEx."), 
                     FH_SERVER_VER(hFaxHandle));
        __try
        {
            ec = FAX_GetSecurity (
                FH_FAX_HANDLE(hFaxHandle),
                (LPBYTE *)ppSecurityDescriptor,
                &BufferSize
                );
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // For some reason we got an exception.
            //
            ec = GetExceptionCode();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Exception on RPC call to FAX_GetSecurity. (ec: %ld)"),
                ec);
        }
    }
    else
    {
        __try
        {
            ec = FAX_GetSecurityEx (
                FH_FAX_HANDLE(hFaxHandle),
                SecurityInformation,
                (LPBYTE *)ppSecurityDescriptor,
                &BufferSize
                );
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // For some reason we got an exception.
            //
            ec = GetExceptionCode();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Exception on RPC call to FAX_GetSecurityEx. (ec: %ld)"),
                ec);
        }
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError(ec);
        return FALSE;
    }
    return TRUE;
}   // FaxGetSecurityEx

BOOL
WINAPI
FaxGetSecurity(
    IN HANDLE hFaxHandle,
    OUT PSECURITY_DESCRIPTOR * ppSecurityDescriptor
    )
/*++

Routine name : FaxGetSecurity

Routine description:

    Gets the server's security descriptor

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle              [in ] - Handle to fax server
    ppSecurityDescriptor    [out] - Pointer to receive buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DWORD BufferSize = 0;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetSecurity"));

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!ppSecurityDescriptor)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppSecurityDescriptor is NULL."));
        return FALSE;
    }

    __try
    {
        ec = FAX_GetSecurity (
            FH_FAX_HANDLE(hFaxHandle),
            (LPBYTE *)ppSecurityDescriptor,
            &BufferSize
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetSecurity. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxGetSecurity


BOOL
WINAPI
FaxSetSecurity(
    IN HANDLE hFaxHandle,
    SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR pSecurityDescriptor
)
/*++

Routine name : FaxGetSecurity

Routine description:

    Sets the server's security descriptor

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle              [in] - Handle to fax server
    SecurityInformation     [in] - Defines the valid entries in the security descriptor (Bit wise OR )
    pSecurityDescriptor     [in] - New security descriptor to set.
                                   Must be self-relative.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DWORD dwBufferSize;
    DWORD dwRevision;
    SECURITY_DESCRIPTOR_CONTROL sdControl;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetSecurity"));

    DWORD dwSecInfo = ( OWNER_SECURITY_INFORMATION  |
                        GROUP_SECURITY_INFORMATION  |
                        DACL_SECURITY_INFORMATION   |
                        SACL_SECURITY_INFORMATION );

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!pSecurityDescriptor)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pSecurityDescriptor is NULL."));
        return FALSE;
    }

    if (0 == (SecurityInformation & dwSecInfo))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        DebugPrintEx(DEBUG_ERR, _T("SecurityInformation is invalid - No valid bit type indicated"));
        return FALSE;
    }

    if (0 != (SecurityInformation & ~dwSecInfo))
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        DebugPrintEx(DEBUG_ERR, _T("SecurityInformation is invalid - contains invalid securtiy information bits"));
        return FALSE;
    }

    if (!IsValidSecurityDescriptor(pSecurityDescriptor))
    {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        DebugPrintEx(DEBUG_ERR, _T("Got invalid security descriptor"));
        return FALSE;
    }

    if (!GetSecurityDescriptorControl (
            pSecurityDescriptor,
            &sdControl,
            &dwRevision
        ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error on GetSecurityDescriptorControl (ec = %ld)"),
            GetLastError());
        return FALSE;
    }

    if (!(sdControl & SE_SELF_RELATIVE))
    {
        //
        // Got a non-self-relative security descriptor - bad!!!
        //
        DebugPrintEx(DEBUG_ERR, _T("Got non-self-relative security descriptor"));
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        return FALSE;
    }

    dwBufferSize = GetSecurityDescriptorLength(pSecurityDescriptor);

    __try
    {
        ec = FAX_SetSecurity(
                FH_FAX_HANDLE(hFaxHandle),
                SecurityInformation,
                (LPBYTE)pSecurityDescriptor,
                dwBufferSize
                );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetSecurity. (ec: %ld)"),
            ec);
    }

    if (ec != ERROR_SUCCESS)
    {
        DumpRPCExtendedStatus ();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxSetSecurity


BOOL
WINAPI
FaxRelease(
    IN const HANDLE FaxHandle
    )
/*++

Routine name : FaxRelease

Routine description:

    The Fax Service counts all the clients connected to it. When this reference count reaches zero,
        the Fax Service can download itself.
    There are some connections that do not want to prevent from the service to download,
        like Task Bar Monitor.
    These clients should call this function.
    It adds the indication on the handle that it is "Released" and decrements the total reference count.

Author:

    Iv Garber (IvG),    Jan, 2001

Arguments:

    FaxHandle       [in]    - the client connection handle that do not want to prevent the service from downloading.

Return Value:

    BOOL                    - TRUE if operation is successfull, otherwise FALSE.

--*/
{
    error_status_t ec;
    DWORD CanShare;

    DEBUG_FUNCTION_NAME(TEXT("FaxRelease"));

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }
    if (FAX_API_VERSION_1 > FH_SERVER_VER(FaxHandle))
    {
        //
        // Servers of API version 0 don't support FAX_ConnectionRefCount(...,2,...)
        //
        DebugPrintEx(DEBUG_ERR, 
                     _T("Server version is %ld - doesn't support this call"), 
                     FH_SERVER_VER(FaxHandle));
        SetLastError(FAX_ERR_VERSION_MISMATCH);
        return FALSE;
    }

    //
    //  Decrement the Reference Count
    //
    __try
    {
        ec = FAX_ConnectionRefCount( FH_FAX_HANDLE(FaxHandle), &FH_CONTEXT_HANDLE(FaxHandle), 2, &CanShare );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(DEBUG_ERR, _T("Exception on RPC call to FAX_ConnectionRefCount. (ec: %ld)"), ec);
    }

    if (ec != ERROR_SUCCESS)
    {
        DumpRPCExtendedStatus ();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}

WINFAXAPI
BOOL
WINAPI
FaxGetReportedServerAPIVersion (
    IN  HANDLE          hFaxHandle,
    OUT LPDWORD         lpdwReportedServerAPIVersion
)
/*++

Routine name : FaxGetReportedServerAPIVersion

Routine description:

    Extracts the reported (non-filtered) fax server API version from an active connection handle

Author:

    Eran Yariv (EranY), Mar, 2001

Arguments:

    hFaxHandle                    [in]     - Connection handle
    lpdwReportedServerAPIVersion  [out]    - Fax server API version

Return Value:

    BOOL  - TRUE if operation is successfull, otherwise FALSE.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetReportedServerAPIVersion"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }
    *lpdwReportedServerAPIVersion = FH_REPORTED_SERVER_VER(hFaxHandle);
    return TRUE;
}   // FaxGetReportedServerAPIVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\config.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    config.c

Abstract:

    This module contains the configuration
    specific WINFAX API functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop

#include <mbstring.h>

BOOL
WINAPI
FaxGetConfigurationW(
    IN HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONW *FaxConfig
    )

/*++

Routine Description:

    Retrieves the FAX configuration from the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value=>= sizeof(FAX_CONFIGURATION).

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    FaxConfig   - Pointer to a FAX_CONFIGURATION structure.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    DWORD FaxConfigSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetConfigurationW"));

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!FaxConfig) {
        SetLastError( ERROR_INVALID_PARAMETER );
        DebugPrintEx(DEBUG_ERR, _T("FaxConfig is NULL."));
        return FALSE;
    }

    *FaxConfig = NULL;

    //
    __try
    {
        ec = FAX_GetConfiguration(
            FH_FAX_HANDLE(FaxHandle),
            (LPBYTE*)FaxConfig,
            &FaxConfigSize
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetConfiguration. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus();
        SetLastError( ec );
        return FALSE;
    }

    FixupStringPtrW( FaxConfig, (*FaxConfig)->ArchiveDirectory );
    (*FaxConfig)->Reserved = NULL;

    return TRUE;
}


BOOL
WINAPI
FaxGetConfigurationA(
    IN HANDLE FaxHandle,
    OUT PFAX_CONFIGURATIONA *FaxConfigA
    )

/*++

Routine Description:

    Retrieves the FAX configuration from the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value=>= sizeof(FAX_CONFIGURATION).

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    FaxConfig   - Pointer to a FAX_CONFIGURATION structure.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetConfigurationA"));
    //
    //  No need to Validate Parameters, FaxGetConfigurationW() will do that
    //

    if (!FaxGetConfigurationW(
            FaxHandle,
            (PFAX_CONFIGURATIONW*) FaxConfigA
            ))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxGetConfigurationW() is failed, ec = %ld."), GetLastError());
        return FALSE;
    }

    if (!ConvertUnicodeStringInPlace((LPWSTR) (*FaxConfigA)->ArchiveDirectory))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*FaxConfigA);
        return FALSE;
    }
    (*FaxConfigA)->SizeOfStruct = sizeof(FAX_CONFIGURATIONA);
    return TRUE;
}   // FaxGetConfigurationA


BOOL
WINAPI
FaxSetConfigurationW(
    IN HANDLE FaxHandle,
    IN const FAX_CONFIGURATIONW *FaxConfig
    )

/*++

Routine Description:

    Changes the FAX configuration on the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value == sizeof(FAX_CONFIGURATION).

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    FaxConfig   - Pointer to a FAX_CONFIGURATION structure.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetConfigurationW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!FaxConfig) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("FaxConfig() is NULL."));
        return FALSE;
    }

    if (FaxConfig->SizeOfStruct != sizeof(FAX_CONFIGURATIONW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("FaxConfig->SizeOfStruct != sizeof(FAX_CONFIGURATIONW)"));
        return FALSE;
    }

    __try
    {
        ec = FAX_SetConfiguration( FH_FAX_HANDLE(FaxHandle), FaxConfig );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(DEBUG_ERR,
            _T("Exception on RPC call to FAX_SetConfiguration. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus();
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetConfigurationA(
    IN HANDLE FaxHandle,
    IN const FAX_CONFIGURATIONA *FaxConfig
    )
{
    error_status_t ec = ERROR_SUCCESS;
    FAX_CONFIGURATIONW FaxConfigW;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetConfigurationA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!FaxConfig) {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("FaxConfig is NULL."));
       return FALSE;
    }

    if (FaxConfig->SizeOfStruct != sizeof(FAX_CONFIGURATIONA)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("FaxConfig->SizeOfStruct != sizeof(FAX_CONFIGURATIONA)."));
        return FALSE;
    }

    //
    // ansi structure is same size as unicode structure, so we can just copy it, then
    // cast the string pointers correctly
    //
    CopyMemory(&FaxConfigW,FaxConfig,sizeof(FAX_CONFIGURATIONA));

    if (FaxConfig->ArchiveDirectory)
    {
        if (NULL == (FaxConfigW.ArchiveDirectory = AnsiStringToUnicodeString(FaxConfig->ArchiveDirectory)))
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR,
                _T("AnsiStringToUnicodeString(FaxConfig->ArchiveDirectory) returns NULL."));
            goto exit;
        }
    }

    //
    //  Set InboundProfile to NULL
    //
    FaxConfigW.Reserved = NULL;


    __try
    {
        ec = FAX_SetConfiguration(  FH_FAX_HANDLE(FaxHandle),
                                    (PFAX_CONFIGURATIONW)&FaxConfigW );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetConfiguration. (ec: %ld)"),
            ec);
    }

exit:
    if (FaxConfigW.ArchiveDirectory) 
    {
       MemFree((PVOID)FaxConfigW.ArchiveDirectory);
    }

    if (ec != ERROR_SUCCESS) 
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}



BOOL
WINAPI
FaxGetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYA *Categories,
    OUT LPDWORD NumberCategories
    )
{
    BOOL retval;
    DWORD i;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetLoggingCategoriesA"));

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) 
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!Categories) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Categories is NULL."));
        return FALSE;
    }

    if (!NumberCategories) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("NumberCategories is NULL."));
        return FALSE;
    }

    retval = FaxGetLoggingCategoriesW(FaxHandle,(PFAX_LOG_CATEGORYW *)Categories , NumberCategories);
    if (!retval) 
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxGetLoggingCategoriesW() is failed."));
        return FALSE;
    }

    for (i=0; i<*NumberCategories; i++) 
    {
        if (!ConvertUnicodeStringInPlace((LPWSTR)(*Categories)[i].Name))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*Categories);
            return FALSE;
        }            
    }
    return TRUE;
}   // FaxGetLoggingCategoriesA

BOOL
WINAPI
FaxGetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    OUT PFAX_LOG_CATEGORYW *Categories,
    OUT LPDWORD NumberCategories
    )
{
    error_status_t ec;
    DWORD BufferSize = 0;
    DWORD i;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetLoggingCategoriesW"));

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!Categories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Categories is NULL."));
        return FALSE;
    }

    if (!NumberCategories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("NumberCategories is NULL."));
        return FALSE;
    }

    *Categories = NULL;
    *NumberCategories = 0;

    //
    __try
    {
        ec = FAX_GetLoggingCategories(
            FH_FAX_HANDLE(FaxHandle),
            (LPBYTE*)Categories,
            &BufferSize,
            NumberCategories
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetLoggingCategories. (ec: %ld)"),
            ec);
    }

    if (ec != ERROR_SUCCESS) 
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    for (i=0; i<*NumberCategories; i++) {
        FixupStringPtrW( Categories, (*Categories)[i].Name );
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetLoggingCategoriesA(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYA *Categories,
    IN  DWORD NumberCategories
    )
{
    DWORD i;
    PFAX_LOG_CATEGORYW CategoryW;
    BOOL retval;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetLoggingCategoriesA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!Categories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Categories is NULL."));
        return FALSE;
    }

    if (!NumberCategories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("NumberCategories is NULL."));
        return FALSE;
    }

    CategoryW = (PFAX_LOG_CATEGORYW) MemAlloc( sizeof(FAX_LOG_CATEGORYW) * NumberCategories );
    if (!CategoryW) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DebugPrintEx(DEBUG_ERR, _T("MemAlloc() returned NULL."));
        return FALSE;
    }

    for (i = 0; i< NumberCategories; i++) {
        CategoryW[i].Category = Categories[i].Category;
        CategoryW[i].Level = Categories[i].Level;
        CategoryW[i].Name = (LPCWSTR) AnsiStringToUnicodeString(Categories[i].Name);
        if (!CategoryW[i].Name && Categories[i].Name) {
            DebugPrintEx(DEBUG_ERR,
                _T("AnsiStringToUnicodeString(Categories[%ld].Name) returns NULL."), i);
            goto error_exit;
        }
    }

    retval = FaxSetLoggingCategoriesW(FaxHandle, CategoryW, NumberCategories);

    for (i = 0; i< NumberCategories; i++) {
        if (CategoryW[i].Name) MemFree((LPBYTE)CategoryW[i].Name);
    }

    MemFree(CategoryW);

    return retval;

error_exit:

    for (i = 0; i< NumberCategories; i++) {
        if (CategoryW[i].Name) MemFree((LPBYTE)CategoryW[i].Name);
    }

    MemFree(CategoryW);

    SetLastError(ERROR_NOT_ENOUGH_MEMORY);

    return FALSE;

}


BOOL
WINAPI
FaxSetLoggingCategoriesW(
    IN  HANDLE FaxHandle,
    IN  const FAX_LOG_CATEGORYW *Categories,
    IN  DWORD NumberCategories
    )
{
    error_status_t ec;
    DWORD BufferSize;
    DWORD i;
    LPBYTE Buffer;
    ULONG_PTR Offset;
    PFAX_LOG_CATEGORY LogCat;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetLoggingCategoriesW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!Categories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Categories is NULL."));
        return FALSE;
    }

    if (!NumberCategories) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("NumberCategories is NULL."));
        return FALSE;
    }

    Offset = sizeof(FAX_LOG_CATEGORY) * NumberCategories;
    BufferSize = DWORD(Offset);

    for (i=0; i<NumberCategories; i++) {
        BufferSize += StringSizeW( Categories[i].Name );
    }

    Buffer = (LPBYTE) MemAlloc( BufferSize );
    if (Buffer == NULL) {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        DebugPrintEx(DEBUG_ERR, _T("MemAlloc() failed."));
        return FALSE;
    }

    LogCat = (PFAX_LOG_CATEGORY) Buffer;

    for (i=0; i<NumberCategories; i++) {
        LogCat[i].Category = Categories[i].Category;
        LogCat[i].Level = Categories[i].Level;

        StoreStringW(
            Categories[i].Name,
            (PULONG_PTR) &LogCat[i].Name,
            Buffer,
            &Offset,
			BufferSize
            );
    }

    __try
    {
        ec = FAX_SetLoggingCategories(
            FH_FAX_HANDLE(FaxHandle),
            Buffer,
            BufferSize,
            NumberCategories
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetLoggingCategories. (ec: %ld)"),
            ec);
    }

    MemFree( Buffer );

    if (ec != ERROR_SUCCESS) 
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}

BOOL
WINAPI
FaxGetCountryListW(
   IN  HANDLE FaxHandle,
   OUT PFAX_TAPI_LINECOUNTRY_LISTW *CountryListBuffer
   )
{
    error_status_t ec;
    DWORD dwNumCountries;
    DWORD dwIndex;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetCountryListW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!CountryListBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("CountryListBuffer is NULL."));
        return FALSE;
    }

    *CountryListBuffer = NULL;
    dwNumCountries = 0;

    //
    __try
    {
        ec = FAX_GetCountryList(
            FH_FAX_HANDLE(FaxHandle),
            (LPBYTE*)CountryListBuffer,
            &dwNumCountries);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetCountryList. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus();
        SetLastError( ec );
        return FALSE;
    }

    (*CountryListBuffer)->LineCountryEntries =
        (PFAX_TAPI_LINECOUNTRY_ENTRYW) ((LPBYTE)*CountryListBuffer +
                                        (ULONG_PTR)(*CountryListBuffer)->LineCountryEntries);

    for (dwIndex=0; dwIndex<(*CountryListBuffer)->dwNumCountries; dwIndex++) {
        if ((*CountryListBuffer)->LineCountryEntries[dwIndex].lpctstrCountryName) {
            (*CountryListBuffer)->LineCountryEntries[dwIndex].lpctstrCountryName =
                (LPWSTR) ((LPBYTE)*CountryListBuffer +
                          (ULONG_PTR)(*CountryListBuffer)->LineCountryEntries[dwIndex].lpctstrCountryName);
        }
        if ((*CountryListBuffer)->LineCountryEntries[dwIndex].lpctstrLongDistanceRule) {
            (*CountryListBuffer)->LineCountryEntries[dwIndex].lpctstrLongDistanceRule =
                (LPWSTR) ((LPBYTE)*CountryListBuffer +
                          (ULONG_PTR)(*CountryListBuffer)->LineCountryEntries[dwIndex].lpctstrLongDistanceRule);
        }
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetCountryListA(
   IN  HANDLE FaxHandle,
   OUT PFAX_TAPI_LINECOUNTRY_LISTA *CountryListBuffer
   )
{
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetCountryListA"));
    //
    //  no need to validate parameters, FaxGetCountryListW() will do that
    //
    if (!FaxGetCountryListW( FaxHandle, (PFAX_TAPI_LINECOUNTRY_LISTW*) CountryListBuffer )) 
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxGetCountryListW() is failed. ec = %ld."), GetLastError());
        return FALSE;
    }
    for (i=0; i<(*CountryListBuffer)->dwNumCountries; i++) 
    {
        if (!ConvertUnicodeStringInPlace((LPWSTR)(*CountryListBuffer)->LineCountryEntries[i].lpctstrCountryName) ||
            !ConvertUnicodeStringInPlace((LPWSTR)(*CountryListBuffer)->LineCountryEntries[i].lpctstrLongDistanceRule))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*CountryListBuffer);
            return FALSE;
        }            
    }
    return TRUE;
}   // FaxGetCountryListA

#ifndef UNICODE

BOOL
WINAPI
FaxGetCountryListX(
   IN  HANDLE FaxHandle,
   OUT PFAX_TAPI_LINECOUNTRY_LISTA *CountryListBuffer
)
{
    UNREFERENCED_PARAMETER (FaxHandle);
    UNREFERENCED_PARAMETER (CountryListBuffer);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE


FaxEnumGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOW *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    PFAX_GLOBAL_ROUTING_INFOW FaxRoutingInfo = NULL;
    error_status_t ec;
    DWORD i;
    DWORD RoutingInfoBufferSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxEnumGlobalRoutingInfoW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!RoutingInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("RoutingInfoBuffer is NULL."));
        return FALSE;
    }

    if (!MethodsReturned) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("MethodsReturned is NULL."));
        return FALSE;
    }

    *RoutingInfoBuffer = NULL;

    __try
    {
        ec = FAX_EnumGlobalRoutingInfo(
            FH_FAX_HANDLE(FaxHandle),
            (LPBYTE*)RoutingInfoBuffer,
            &RoutingInfoBufferSize,
            MethodsReturned
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumGlobalRoutingInfo. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus();
        SetLastError( ec );
        return FALSE;
    }

    FaxRoutingInfo = (PFAX_GLOBAL_ROUTING_INFOW) *RoutingInfoBuffer;

    for (i=0; i<*MethodsReturned; i++) {
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingInfo[i].Guid );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingInfo[i].FunctionName );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingInfo[i].FriendlyName );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingInfo[i].ExtensionImageName );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingInfo[i].ExtensionFriendlyName );
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnumGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    OUT PFAX_GLOBAL_ROUTING_INFOA *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    PFAX_GLOBAL_ROUTING_INFOW FaxRoutingMethod = NULL;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumGlobalRoutingInfoA"));

    //
    //  No need to validate parameters, FaxEnumGlobalRoutingInfoW() will do that
    //

    if (!FaxEnumGlobalRoutingInfoW(
        FaxHandle,
        (PFAX_GLOBAL_ROUTING_INFOW *)RoutingInfoBuffer,
        MethodsReturned
        ))
    {
        DebugPrintEx(DEBUG_ERR, _T("FAX_EnumGlobalRoutingInfoW() failed. ec = %ld."), GetLastError());
        return FALSE;
    }

    FaxRoutingMethod = (PFAX_GLOBAL_ROUTING_INFOW) *RoutingInfoBuffer;

    for (i=0; i<*MethodsReturned; i++) 
    {
        if (!ConvertUnicodeStringInPlace((LPWSTR)FaxRoutingMethod[i].Guid)                ||
            !ConvertUnicodeStringInPlace((LPWSTR)FaxRoutingMethod[i].FunctionName)        ||
            !ConvertUnicodeStringInPlace((LPWSTR)FaxRoutingMethod[i].FriendlyName)        ||
            !ConvertUnicodeStringInPlace((LPWSTR)FaxRoutingMethod[i].ExtensionImageName)  ||
            !ConvertUnicodeStringInPlace((LPWSTR)FaxRoutingMethod[i].ExtensionFriendlyName))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*RoutingInfoBuffer);
            return FALSE;
        }            
    }
    return TRUE;
}   // FaxEnumGlobalRoutingInfoA

BOOL
WINAPI
FaxSetGlobalRoutingInfoW(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    )
{
    error_status_t ec;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetGlobalRoutingInfoW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
       return FALSE;
    }

    if (!RoutingInfo) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("RoutingInfo is NULL."));
        return FALSE;
    }

    if (RoutingInfo->SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFOW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("RoutingInfo->SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFOW)."));
        return FALSE;
    }

    __try
    {
        ec = FAX_SetGlobalRoutingInfo( FH_FAX_HANDLE(FaxHandle), RoutingInfo );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetGlobalRoutingInfo. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus();
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetGlobalRoutingInfoA(
    IN  HANDLE FaxHandle,
    IN  const FAX_GLOBAL_ROUTING_INFOA *RoutingInfo
    )
{
    BOOL Rval;
    FAX_GLOBAL_ROUTING_INFOW RoutingInfoW = {0};

    DEBUG_FUNCTION_NAME(TEXT("FaxSetGlobalRoutingInfoA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
       return FALSE;
    }

    if (!RoutingInfo) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("RoutingInfo is NULL."));
        return FALSE;
    }

    if (RoutingInfo->SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFOA)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("RoutingInfo->SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFOA)."));
        return FALSE;
    }

    RoutingInfoW.SizeOfStruct = sizeof(FAX_GLOBAL_ROUTING_INFOW);
    RoutingInfoW.Priority = RoutingInfo->Priority;

    RoutingInfoW.Guid                  = AnsiStringToUnicodeString(RoutingInfo->Guid);
    if (!RoutingInfoW.Guid && RoutingInfo->Guid)
    {
        Rval = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,
            _T("AnsiStringToUnicodeString(RoutingInfo->Guid) returns NULL."));
        goto exit;
    }

    RoutingInfoW.FriendlyName          = AnsiStringToUnicodeString(RoutingInfo->FriendlyName);
    if (!RoutingInfoW.FriendlyName && RoutingInfo->FriendlyName)
    {
        Rval = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,
            _T("AnsiStringToUnicodeString(RoutingInfo->FriendlyName) returns NULL."));
        goto exit;
    }

    RoutingInfoW.FunctionName          = AnsiStringToUnicodeString(RoutingInfo->FunctionName);
    if (!RoutingInfoW.FunctionName && RoutingInfo->FunctionName)
    {
        Rval = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,
            _T("AnsiStringToUnicodeString(RoutingInfo->FunctionName) returns NULL."));
        goto exit;
    }

    RoutingInfoW.ExtensionImageName    = AnsiStringToUnicodeString(RoutingInfo->ExtensionImageName);
    if (!RoutingInfoW.ExtensionImageName && RoutingInfo->ExtensionImageName)
    {
        Rval = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,
            _T("AnsiStringToUnicodeString(RoutingInfo->ExtensionImageName) returns NULL."));
        goto exit;
    }

    RoutingInfoW.ExtensionFriendlyName = AnsiStringToUnicodeString(RoutingInfo->ExtensionFriendlyName);
    if (!RoutingInfoW.ExtensionFriendlyName && RoutingInfo->ExtensionFriendlyName)
    {
        Rval = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR,
            _T("AnsiStringToUnicodeString(RoutingInfo->ExtensionFriendlyName) returns NULL."));
        goto exit;
    }

    Rval = FaxSetGlobalRoutingInfoW( FaxHandle, &RoutingInfoW);

exit:
    if (RoutingInfoW.Guid)                  MemFree( (LPBYTE) RoutingInfoW.Guid ) ;
    if (RoutingInfoW.FriendlyName)          MemFree( (LPBYTE) RoutingInfoW.FriendlyName ) ;
    if (RoutingInfoW.FunctionName)          MemFree( (LPBYTE) RoutingInfoW.FunctionName ) ;
    if (RoutingInfoW.ExtensionImageName)    MemFree( (LPBYTE) RoutingInfoW.ExtensionImageName ) ;
    if (RoutingInfoW.ExtensionFriendlyName) MemFree( (LPBYTE) RoutingInfoW.ExtensionFriendlyName ) ;

    return Rval;
}


BOOL
WINAPI
FaxAccessCheck(
    IN HANDLE FaxHandle,
    IN DWORD AccessMask
    )
{
    BOOL           fPermission = FALSE;
    error_status_t ec = ERROR_SUCCESS;
    DWORD          dwAccessMaskEx = 0;
    DWORD dwValidMask  = (FAX_JOB_SUBMIT            |
                          FAX_JOB_QUERY             |
                          FAX_CONFIG_QUERY          |
                          FAX_CONFIG_SET            |
                          FAX_PORT_QUERY            |
                          FAX_PORT_SET              |
                          FAX_JOB_MANAGE            |
                          WRITE_DAC                 |
                          WRITE_OWNER               |
                          ACCESS_SYSTEM_SECURITY    |
                          READ_CONTROL              |
                          GENERIC_ALL               |
                          GENERIC_READ              |
                          GENERIC_WRITE             |
                          GENERIC_EXECUTE);
    DEBUG_FUNCTION_NAME(TEXT("FaxAccessCheck"));

    //
    //  Validate Parameters
    //
    if (!ValidateFaxHandle(FaxHandle,FHT_SERVICE))
    {
        SetLastError (ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    //
    // For legacy support - Turn off SYNCHRONIZE and DELETE  (They are part of legacy FAX_ALL_ACCESS)
    //
    AccessMask &= ~(SYNCHRONIZE | DELETE);

    //
    // Validate specific access rights
    //
    if (0 == (AccessMask & dwValidMask))
    {
        SetLastError( ERROR_SUCCESS ); // // means access is denied
        DebugPrintEx(DEBUG_ERR,
            _T("AccessMask is invalid - No valid access bit type indicated"));
        return FALSE;
    }

    if ( 0 != (AccessMask & ~dwValidMask))
    {
        SetLastError( ERROR_SUCCESS );  // means access is denied
        DebugPrintEx(DEBUG_ERR,
            _T("AccessMask is invalid - contains invalid access type bits"));
        return FALSE;
    }
    //
    // Convert the Win2K legacy specific access rights to our new exteneded specific access rights
    // before calling FaxAccessCheckEx().
    //
    if (FAX_JOB_SUBMIT & AccessMask)
    {
        dwAccessMaskEx |= FAX_ACCESS_SUBMIT;
    }
    if (FAX_JOB_QUERY & AccessMask)
    {
        dwAccessMaskEx |= FAX_ACCESS_QUERY_JOBS;
    }
    if (FAX_CONFIG_QUERY & AccessMask)
    {
        dwAccessMaskEx |= FAX_ACCESS_QUERY_CONFIG;
    }
    if (FAX_CONFIG_SET & AccessMask)
    {
        dwAccessMaskEx |= FAX_ACCESS_MANAGE_CONFIG;
    }
    if (FAX_PORT_QUERY & AccessMask)
    {
        dwAccessMaskEx |= FAX_ACCESS_QUERY_CONFIG;
    }
    if (FAX_PORT_SET & AccessMask)
    {
        dwAccessMaskEx |= FAX_ACCESS_MANAGE_CONFIG;
    }
    if (FAX_JOB_MANAGE & AccessMask)
    {
        dwAccessMaskEx |= FAX_ACCESS_MANAGE_JOBS;
    }

    //
    // Add standard and generic access rights
    //
    dwAccessMaskEx |= (AccessMask & ~SPECIFIC_RIGHTS_ALL);

    return FaxAccessCheckEx (FaxHandle, dwAccessMaskEx, NULL);
}

BOOL
WINAPI
FaxAccessCheckEx(
    IN HANDLE hFaxHandle,
    IN DWORD dwAccessMask,
    IN LPDWORD lpdwAccessRights
    )
{
    BOOL fPermission = FALSE;
    error_status_t ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FaxAccessCheckEx"));

    DWORD dwValidMask  = ( FAX_ACCESS_SUBMIT                |
                           FAX_ACCESS_SUBMIT_NORMAL         |
                           FAX_ACCESS_SUBMIT_HIGH           |
                           FAX_ACCESS_QUERY_JOBS            |
                           FAX_ACCESS_MANAGE_JOBS           |
                           FAX_ACCESS_QUERY_CONFIG          |
                           FAX_ACCESS_MANAGE_CONFIG         |
                           FAX_ACCESS_QUERY_IN_ARCHIVE      |
                           FAX_ACCESS_MANAGE_IN_ARCHIVE     |
                           FAX_ACCESS_QUERY_OUT_ARCHIVE     |
                           FAX_ACCESS_MANAGE_OUT_ARCHIVE    |
                           WRITE_DAC                        |
                           WRITE_OWNER                      |
                           ACCESS_SYSTEM_SECURITY           |
                           READ_CONTROL                     |
                           MAXIMUM_ALLOWED                  |
                           GENERIC_ALL                      |
                           GENERIC_READ                     |
                           GENERIC_WRITE                    |
                           GENERIC_EXECUTE);

    //
    //  Validate Parameters
    //
    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError (ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (0 == (dwAccessMask & dwValidMask))
    {
        SetLastError( ERROR_SUCCESS ); // means access is denied
        DebugPrintEx(DEBUG_ERR,
            _T("dwAccessMask is invalid - No valid access bit type indicated"));
        return FALSE;
    }

    if ( 0 != (dwAccessMask & ~dwValidMask))
    {
        SetLastError( ERROR_SUCCESS );  // means access is denied
        DebugPrintEx(DEBUG_ERR,
            _T("dwAccessMask is invalid - contains invalid access type bits"));
        return FALSE;
    }

    __try
    {
        ec = FAX_AccessCheck( FH_FAX_HANDLE(hFaxHandle), dwAccessMask, &fPermission, lpdwAccessRights);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_AccessCheck. (ec: %ld)"),
            ec);
    }

    if (ec != ERROR_SUCCESS)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    SetLastError (ERROR_SUCCESS);
    return fPermission;
}


//************************************
//* Getting / Setting the queue state
//************************************

BOOL
WINAPI
FaxGetQueueStates (
    IN  HANDLE  hFaxHandle,
    OUT PDWORD  pdwQueueStates
)
/*++

Routine name : FaxGetQueueStates

Routine description:

    Retruns the state of the queue

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in]  - Handle to fax server
    pdwQueueStates      [out] - Returned queue state

Return Value:

    TRUE on success, FALSE otherwise

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetQueueStates"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (NULL == pdwQueueStates)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pdwQueueStates is NULL."));
        return FALSE;
    }

    __try
    {
        ec = FAX_GetQueueStates(
            FH_FAX_HANDLE(hFaxHandle),
            pdwQueueStates
        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetQueueStates. (ec: %ld)"),
            ec);
    }

    if (ec != ERROR_SUCCESS)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxGetQueueStates



BOOL
WINAPI
FaxSetQueue (
    IN  HANDLE  hFaxHandle,
    IN CONST DWORD  dwQueueStates
)
/*++

Routine name : FaxSetQueue

Routine description:

    Sets the server's queue state

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server
    dwQueueStates       [in] - New queue state

Return Value:

    TRUE on success, FALSE otherwise

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetQueue"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (dwQueueStates & ~(FAX_INCOMING_BLOCKED | FAX_OUTBOX_BLOCKED | FAX_OUTBOX_PAUSED))
    {
        //
        // Some invalid queue state specified
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Invalid dwQueueStates."));
        return FALSE;
    }

    __try
    {
        ec = FAX_SetQueue(
            FH_FAX_HANDLE(hFaxHandle),
            dwQueueStates
        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetQueue. (ec: %ld)"),
            ec);
    }

    if (ec != ERROR_SUCCESS)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxSetQueue

//************************************************
//* Getting / Setting the receipts configuration
//************************************************

BOOL
WINAPI
FaxGetReceiptsConfigurationA (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGA  *ppReceipts
)
/*++

Routine name : FaxGetReceiptsConfigurationA

Routine description:

    Retrieve receipts configuration - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Fax server handle
    ppReceipts      [out] - New receipts configuration buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetReceiptsConfigurationA"));

    //
    //  no need to validate parameters ,FaxGetReceipsConfigurationW() will do that
    //

    if (!FaxGetReceiptsConfigurationW(
            hFaxHandle,
            (PFAX_RECEIPTS_CONFIGW*) ppReceipts
            ))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxGetReceiptsConfigurationW() is failed. ec = %ld."), GetLastError());
        return FALSE;
    }

    if (!ConvertUnicodeStringInPlace((LPWSTR) (*ppReceipts)->lptstrSMTPServer)    ||
        !ConvertUnicodeStringInPlace((LPWSTR) (*ppReceipts)->lptstrSMTPFrom)      ||
        !ConvertUnicodeStringInPlace((LPWSTR) (*ppReceipts)->lptstrSMTPUserName)  ||
        !ConvertUnicodeStringInPlace((LPWSTR) (*ppReceipts)->lptstrSMTPPassword))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*ppReceipts);
        return FALSE;
    }            
    return TRUE;
}   // FaxGetReceiptsConfigurationA

BOOL
WINAPI
FaxGetReceiptsConfigurationW (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGW  *ppReceipts
)
/*++

Routine name : FaxGetReceiptsConfigurationW

Routine description:

    Retrieve receipts configuration - Unicode version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Fax server handle
    ppReceipts      [out] - New receipts configuration buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DWORD dwConfigSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetReceiptsConfigurationW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!ppReceipts)
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        DebugPrintEx(DEBUG_ERR, _T("ppReceipts is NULL."));
        return FALSE;
    }

    *ppReceipts = NULL;

    __try
    {
        ec = FAX_GetReceiptsConfiguration (
                    FH_FAX_HANDLE(hFaxHandle),
                    (LPBYTE*)ppReceipts,
                    &dwConfigSize
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetReceiptsConfiguration. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError( ec );
        return FALSE;
    }

    FixupStringPtrW( ppReceipts, (*ppReceipts)->lptstrSMTPServer );
    FixupStringPtrW( ppReceipts, (*ppReceipts)->lptstrSMTPFrom );
    FixupStringPtrW( ppReceipts, (*ppReceipts)->lptstrSMTPUserName );
    FixupStringPtrW( ppReceipts, (*ppReceipts)->lptstrSMTPPassword );

    return TRUE;
}   // FaxGetReceiptsConfigurationW

#ifndef UNICODE

BOOL
WINAPI
FaxGetReceiptsConfigurationX (
    IN  HANDLE                  hFaxHandle,
    OUT PFAX_RECEIPTS_CONFIGW  *ppReceipts
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (ppReceipts);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE

BOOL
WINAPI
FaxSetReceiptsConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGA  pReceipts
)
/*++

Routine name : FaxSetReceiptsConfigurationA

Routine description:

    Set receipts configuration - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in] - Handle to fax server
    pReceipts       [in] - New configuration

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    FAX_RECEIPTS_CONFIGW ReceiptsConfigW;
    BOOL bRes = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetReceiptsConfigurationA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!pReceipts)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("pReceipts is NULL."));
       return FALSE;
    }

    if (sizeof (FAX_RECEIPTS_CONFIGA) != pReceipts->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("sizeof (FAX_RECEIPTS_CONFIGA) != pReceipts->dwSizeOfStruct"));
        return FALSE;
    }

    //
    // ansi structure is same size as unicode structure, so we can just copy it, then
    // cast the string pointers correctly
    //
    CopyMemory(&ReceiptsConfigW, pReceipts, sizeof(FAX_RECEIPTS_CONFIGA));
    ReceiptsConfigW.dwSizeOfStruct = sizeof (FAX_RECEIPTS_CONFIGW);
    ReceiptsConfigW.bIsToUseForMSRouteThroughEmailMethod = pReceipts->bIsToUseForMSRouteThroughEmailMethod;
    ReceiptsConfigW.lptstrSMTPFrom = NULL;
    ReceiptsConfigW.lptstrSMTPUserName = NULL;
    ReceiptsConfigW.lptstrSMTPPassword = NULL;
    ReceiptsConfigW.lptstrSMTPServer = NULL;
    ReceiptsConfigW.lptstrReserved = NULL;

    if (pReceipts->lptstrSMTPServer)
    {
        if (NULL ==
            (ReceiptsConfigW.lptstrSMTPServer = AnsiStringToUnicodeString(pReceipts->lptstrSMTPServer))
        )
        {
            DebugPrintEx(DEBUG_ERR,
                _T("AnsiStringToUnicodeString(pReceipts->lptstrSMTPServer) returns NULL."));
            goto exit;
        }
    }
    if (pReceipts->lptstrSMTPFrom)
    {
        if (NULL ==
            (ReceiptsConfigW.lptstrSMTPFrom = AnsiStringToUnicodeString(pReceipts->lptstrSMTPFrom))
        )
        {
            DebugPrintEx(DEBUG_ERR,
                _T("AnsiStringToUnicodeString(pReceipts->lptstrSMTPFrom) returns NULL."));
            goto exit;
        }
    }
    if (pReceipts->lptstrSMTPUserName)
    {
        if (NULL ==
            (ReceiptsConfigW.lptstrSMTPUserName = AnsiStringToUnicodeString(pReceipts->lptstrSMTPUserName))
        )
        {
            DebugPrintEx(DEBUG_ERR,
                _T("AnsiStringToUnicodeString(pReceipts->lptstrSMTPUserName) returns NULL."));
            goto exit;
        }
    }
    if (pReceipts->lptstrSMTPPassword)
    {
        if (NULL ==
            (ReceiptsConfigW.lptstrSMTPPassword = AnsiStringToUnicodeString(pReceipts->lptstrSMTPPassword))
        )
        {
            DebugPrintEx(DEBUG_ERR,
                _T("AnsiStringToUnicodeString(pReceipts->lptstrSMTPPassword) returns NULL."));
            goto exit;
        }
    }

    bRes = FaxSetReceiptsConfigurationW (hFaxHandle, &ReceiptsConfigW);

exit:
    MemFree((PVOID)ReceiptsConfigW.lptstrSMTPServer);
    MemFree((PVOID)ReceiptsConfigW.lptstrSMTPFrom);
    MemFree((PVOID)ReceiptsConfigW.lptstrSMTPUserName);
    SecureZeroMemory((PVOID)ReceiptsConfigW.lptstrSMTPPassword,wcslen(ReceiptsConfigW.lptstrSMTPPassword)*sizeof(WCHAR));
    MemFree((PVOID)ReceiptsConfigW.lptstrSMTPPassword);

    return bRes;
}   // FaxSetReceiptsConfigurationA

BOOL
WINAPI
FaxSetReceiptsConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGW  pReceipts
)
/*++

Routine name : FaxSetReceiptsConfigurationW

Routine description:

    Set receipts configuration - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in] - Handle to fax server
    pReceipts       [in] - New configuration

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetReceiptsConfigurationW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!pReceipts)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("pReceipts is NULL."));
       return FALSE;
    }

    if (sizeof (FAX_RECEIPTS_CONFIGW) != pReceipts->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("sizeof (FAX_RECEIPTS_CONFIGW) != pReceipts->dwSizeOfStruct"));
        return FALSE;
    }

    if ((pReceipts->SMTPAuthOption < FAX_SMTP_AUTH_ANONYMOUS) ||
        (pReceipts->SMTPAuthOption > FAX_SMTP_AUTH_NTLM))
    {
        //
        // SMTP auth type type is invalid
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("SMTP auth type is invalid."));
        return FALSE;
    }
    if ((pReceipts->dwAllowedReceipts) & ~DRT_ALL)
    {
        //
        // Receipts type is invalid
        //
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR,
            _T("Receipts type is invalid : (pReceipts->dwAllowedReceipts) & ~DRT_ALL."));
        return FALSE;
    }

    __try
    {
        ec = FAX_SetReceiptsConfiguration(
                    FH_FAX_HANDLE(hFaxHandle),
                    pReceipts );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetReceiptsConfiguration. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxSetReceiptsConfigurationW

#ifndef UNICODE

BOOL
WINAPI
FaxSetReceiptsConfigurationX (
    IN HANDLE                       hFaxHandle,
    IN CONST PFAX_RECEIPTS_CONFIGW  pReceipts
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (pReceipts);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE


//********************************************
//*             Server version
//********************************************

BOOL
WINAPI
FaxGetVersion (
    IN  HANDLE          hFaxHandle,
    OUT PFAX_VERSION    pVersion
)
/*++

Routine name : FaxGetVersion

Routine description:

    Retrieves the version of the fax server

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in    ] - Handle to fax server
    pVersion            [in\out] - Returned version structure

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetVersion"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!pVersion)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("pVersion is NULL."));
       return FALSE;
    }

    if (sizeof (FAX_VERSION) != pVersion->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("sizeof (FAX_VERSION) != pVersion->dwSizeOfStruct."));
        return FALSE;
    }

    __try
    {
        ec = FAX_GetVersion(
                    FH_FAX_HANDLE(hFaxHandle),
                    pVersion );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetVersion. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxGetVersion

//********************************************
//*            Outbox configuration
//********************************************

BOOL
WINAPI
FaxGetOutboxConfiguration (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_OUTBOX_CONFIG *ppOutboxCfg
)
/*++

Routine name : FaxGetOutboxConfiguration

Routine description:

    Get Outbox configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    ppOutboxCfg     [out] - New Outbox configuration buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DWORD dwConfigSize = 0;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetOutboxConfiguration"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!ppOutboxCfg)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("ppOutboxCfg is NULL."));
       return FALSE;
    }

    *ppOutboxCfg = NULL;

    __try
    {
        ec = FAX_GetOutboxConfiguration(
                    FH_FAX_HANDLE(hFaxHandle),
                    (LPBYTE*)ppOutboxCfg,
                    &dwConfigSize
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetOutboxConfiguration. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxGetOutboxConfiguration

BOOL
WINAPI
FaxSetOutboxConfiguration (
    IN HANDLE                    hFaxHandle,
    IN CONST PFAX_OUTBOX_CONFIG  pOutboxCfg
)
/*++

Routine name : FaxSetOutboxConfiguration

Routine description:

    Set Outbox configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in] - Handle to fax server
    pOutboxCfg      [in] - New configuration

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetOutboxConfiguration"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!pOutboxCfg)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("pOutboxCfg is NULL."));
       return FALSE;
    }

    if (sizeof (FAX_OUTBOX_CONFIG) != pOutboxCfg->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("sizeof (FAX_OUTBOX_CONFIG) != pOutboxCfg->dwSizeOfStruct."));
        return FALSE;
    }

    if ((pOutboxCfg->dtDiscountStart.Hour > 23) ||
        (pOutboxCfg->dtDiscountStart.Minute > 59) ||
        (pOutboxCfg->dtDiscountEnd.Hour > 23) ||
        (pOutboxCfg->dtDiscountEnd.Minute > 59))
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("wrong pOutboxCfg->dwDiscountStart OR ->dwDiscountEnd."));
       return FALSE;
    }

    __try
    {
        ec = FAX_SetOutboxConfiguration(
                    FH_FAX_HANDLE(hFaxHandle),
                    pOutboxCfg );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetOutboxConfiguration. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxSetOutboxConfiguration

//********************************************
//*            Archive configuration
//********************************************


BOOL
WINAPI
FaxGetArchiveConfigurationA (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGA    *ppArchiveCfg
)
/*++

Routine name : FaxGetArchiveConfigurationA

Routine description:

    Gets the archive configuration - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    Folder          [in ] - Folder type
    ppArchiveCfg    [out] - Configuration buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetArchiveConfigurationA"));

    //
    //  no need to validate parameters, FaxGetArchiveConfigurationW() will do that
    //

    if (!FaxGetArchiveConfigurationW(
            hFaxHandle,
            Folder,
            (PFAX_ARCHIVE_CONFIGW*) ppArchiveCfg
            ))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxGetArchiveConfigurationW() is failed."));
        return FALSE;
    }

    if (!ConvertUnicodeStringInPlace((LPWSTR)(*ppArchiveCfg)->lpcstrFolder))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*ppArchiveCfg);
        return FALSE;
    }            
    (*ppArchiveCfg)->dwSizeOfStruct = sizeof(FAX_ARCHIVE_CONFIGA);
    return TRUE;
}   // FaxGetArchiveConfigurationA

BOOL
WINAPI
FaxGetArchiveConfigurationW (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGW    *ppArchiveCfg
)
/*++

Routine name : FaxGetArchiveConfigurationW

Routine description:

    Gets the archive configuration - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    Folder          [in ] - Folder type
    ppArchiveCfg    [out] - Configuration buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD dwConfigSize = 0;
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetArchiveConfigurationA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!ppArchiveCfg)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("ppArchiveCfg is NULL."));
       return FALSE;
    }

    if ((Folder != FAX_MESSAGE_FOLDER_SENTITEMS) &&
        (Folder != FAX_MESSAGE_FOLDER_INBOX)
       )
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("Folder is neither SentItems nor Inbox."));
       return FALSE;
    }

    *ppArchiveCfg = NULL;

    __try
    {
        ec = FAX_GetArchiveConfiguration(
                    FH_FAX_HANDLE(hFaxHandle),
                    Folder,
                    (LPBYTE*)ppArchiveCfg,
                    &dwConfigSize
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetArchiveConfiguration. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    FixupStringPtrW( ppArchiveCfg, (*ppArchiveCfg)->lpcstrFolder );
    return TRUE;
}   // FaxGetArchiveConfigurationW

#ifndef UNICODE

FaxGetArchiveConfigurationX (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder,
    OUT PFAX_ARCHIVE_CONFIGW    *ppArchiveCfg
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (Folder);
    UNREFERENCED_PARAMETER (ppArchiveCfg);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE

BOOL
WINAPI
FaxSetArchiveConfigurationA (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGA   pArchiveCfg
)
/*++

Routine name : FaxSetArchiveConfigurationA

Routine description:

    Sets the archive configuration - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    Folder          [in ] - Folder type
    pArchiveCfg     [in ] - New configuration.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    FAX_ARCHIVE_CONFIGW ConfigW;
    BOOL bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetArchiveConfigurationA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle is failed."));
        return FALSE;
    }

    if (!pArchiveCfg)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pArchiveCfg is NULL."));
        return FALSE;
    }

    if (sizeof(FAX_ARCHIVE_CONFIGA) != pArchiveCfg->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pArchiveCfg->dwSizeOfStruct != sizeof(FAX_ARCHIVE_CONFIGA)."));
        return FALSE;
    }

    //
    // Create a UNICODE structure and pass along to UNICODE function
    // Ansi structure is same size as unicode structure, so we can just copy it, then
    // cast the string pointers correctly
    //
    CopyMemory(&ConfigW, pArchiveCfg, sizeof(FAX_ARCHIVE_CONFIGA));
    ConfigW.lpcstrFolder = NULL;
    ConfigW.dwSizeOfStruct = sizeof (FAX_ARCHIVE_CONFIGW);

    if (pArchiveCfg->lpcstrFolder)
    {
        if (NULL ==
            (ConfigW.lpcstrFolder = AnsiStringToUnicodeString(pArchiveCfg->lpcstrFolder))
        )
        {
            DebugPrintEx(DEBUG_ERR,
                _T("AnsiStringToUnicodeString(pArchiveCfg->lpcstrFolder) returns NULL."));
            return FALSE;
        }
    }

    bRes = FaxSetArchiveConfigurationW (hFaxHandle, Folder, &ConfigW);
    MemFree((PVOID)ConfigW.lpcstrFolder);
    return bRes;
}   // FaxSetArchiveConfigurationA

BOOL
WINAPI
FaxSetArchiveConfigurationW (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGW   pArchiveCfg
)
/*++

Routine name : FaxSetArchiveConfigurationW

Routine description:

    Sets the archive configuration - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    Folder          [in ] - Folder type
    pArchiveCfg     [in ] - New configuration.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetArchiveConfigurationW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!pArchiveCfg)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pArchiveCfg is NULL."));
        return FALSE;
    }

    if ((Folder != FAX_MESSAGE_FOLDER_SENTITEMS) &&
        (Folder != FAX_MESSAGE_FOLDER_INBOX)
       )
    {
        DebugPrintEx(DEBUG_ERR, _T("Invalid folder id (%ld)"), Folder);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (sizeof(FAX_ARCHIVE_CONFIGW) != pArchiveCfg->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("sizeof(FAX_ARCHIVE_CONFIGW) != pArchiveCfg->dwSizeOfStruct."));
        return FALSE;
    }

    if (pArchiveCfg->bUseArchive)
    {
        if (pArchiveCfg->dwSizeQuotaHighWatermark < pArchiveCfg->dwSizeQuotaLowWatermark)
        {
            DebugPrintEx(DEBUG_ERR,
                _T("Watermarks mismatch (high=%ld, low=%ld)"),
                pArchiveCfg->dwSizeQuotaHighWatermark,
                pArchiveCfg->dwSizeQuotaLowWatermark);
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if ((NULL == pArchiveCfg->lpcstrFolder) || (L'\0' == pArchiveCfg->lpcstrFolder[0]))
        {
            DebugPrintEx(DEBUG_ERR, _T("Empty archive folder specified"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (lstrlenW (pArchiveCfg->lpcstrFolder) > MAX_ARCHIVE_FOLDER_PATH)
        {
            DebugPrintEx(DEBUG_ERR, _T("DB file name exceeds MAX_PATH"));
            SetLastError (ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }
    }
    __try
    {
        ec = FAX_SetArchiveConfiguration(
                    FH_FAX_HANDLE(hFaxHandle),
                    Folder,
                    pArchiveCfg );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetArchiveConfiguration. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxSetArchiveConfigurationW

#ifndef UNICODE

FaxSetArchiveConfigurationX (
    IN HANDLE                       hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN CONST PFAX_ARCHIVE_CONFIGW   pArchiveCfg
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (Folder);
    UNREFERENCED_PARAMETER (pArchiveCfg);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE

//********************************************
//*            Activity logging
//********************************************


BOOL
WINAPI
FaxGetActivityLoggingConfigurationA (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGA  *ppLoggingCfg
)
/*++

Routine name : FaxGetActivityLoggingConfigurationA

Routine description:

    Gets the activity logging configuration - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    ppLoggingCfg    [out] - Configuration buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetActivityLoggingConfigurationA"));

    //
    //  no need to validate parameters, FaxGetActivityLoggingConfigurationW() will do that
    //

    if (!FaxGetActivityLoggingConfigurationW(
            hFaxHandle,
            (PFAX_ACTIVITY_LOGGING_CONFIGW*) ppLoggingCfg
            ))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxGetActivityLoggingConfigurationW() is failed."));
        return FALSE;
    }

    if (!ConvertUnicodeStringInPlace((LPWSTR) (*ppLoggingCfg)->lptstrDBPath))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*ppLoggingCfg);
        return FALSE;
    }            
    (*ppLoggingCfg)->dwSizeOfStruct = sizeof(FAX_ACTIVITY_LOGGING_CONFIGA);
    return TRUE;
}   // FaxGetActivityLoggingConfigurationA



BOOL
WINAPI
FaxGetActivityLoggingConfigurationW (
    IN  HANDLE                            hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGW    *ppLoggingCfg
)
/*++

Routine name : FaxGetActivityLoggingConfigurationW

Routine description:

    Gets the activity logging configuration - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    ppLoggingCfg    [out] - Configuration buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD dwConfigSize = 0;
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetActivityLoggingConfigurationW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!ppLoggingCfg)
    {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("ppLoggingCfg is NULL."));
       return FALSE;
    }

    *ppLoggingCfg = NULL;

    __try
    {
        ec = FAX_GetActivityLoggingConfiguration(
                    FH_FAX_HANDLE(hFaxHandle),
                    (LPBYTE*)ppLoggingCfg,
                    &dwConfigSize
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetActivityLoggingConfiguration. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    FixupStringPtrW( ppLoggingCfg, (*ppLoggingCfg)->lptstrDBPath );
    return TRUE;
}   // FaxGetActivityLoggingConfigurationW

#ifndef UNICODE

FaxGetActivityLoggingConfigurationX (
    IN  HANDLE                            hFaxHandle,
    OUT PFAX_ACTIVITY_LOGGING_CONFIGW    *ppLoggingCfg
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (ppLoggingCfg);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxGetActivityLoggingConfigurationX

#endif // #ifndef UNICODE


BOOL
WINAPI
FaxSetActivityLoggingConfigurationA (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGA  pLoggingCfg
)
/*++

Routine name : FaxSetActivityLoggingConfigurationA

Routine description:

    Sets the activity logging configuration - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    pLoggingCfg     [in ] - New configuration

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    FAX_ACTIVITY_LOGGING_CONFIGW ConfigW;
    BOOL bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetActivityLoggingConfigurationA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!pLoggingCfg)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pLoggingCfg is NULL."));
        return FALSE;
    }

    if (sizeof (FAX_ACTIVITY_LOGGING_CONFIGA) != pLoggingCfg->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR,
            _T("sizeof (FAX_ACTIVITY_LOGGING_CONFIGA) != pLoggingCfg->dwSizeOfStruct."));
        return FALSE;
    }

    //
    // Create a UNICODE structure and pass along to UNICODE function
    // Ansi structure is same size as unicode structure, so we can just copy it, then
    // cast the string pointers correctly
    //
    CopyMemory(&ConfigW, pLoggingCfg, sizeof(FAX_ACTIVITY_LOGGING_CONFIGA));
    ConfigW.lptstrDBPath = NULL;
    ConfigW.dwSizeOfStruct = sizeof (FAX_ACTIVITY_LOGGING_CONFIGW);

    if (pLoggingCfg->lptstrDBPath)
    {
        if (NULL ==
            (ConfigW.lptstrDBPath = AnsiStringToUnicodeString(pLoggingCfg->lptstrDBPath))
        )
        {
            DebugPrintEx(DEBUG_ERR,
                _T("AnsiStringToUnicodeString(pLoggingCfg->lptstrDBPath) returns NULL."));
            return FALSE;
        }
    }

    bRes = FaxSetActivityLoggingConfigurationW (hFaxHandle, &ConfigW);
    MemFree((PVOID)ConfigW.lptstrDBPath);

    return bRes;
}   // FaxSetActivityLoggingConfigurationA



BOOL
WINAPI
FaxSetActivityLoggingConfigurationW (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGW  pLoggingCfg
)
/*++

Routine name : FaxSetActivityLoggingConfigurationW

Routine description:

    Sets the activity logging configuration - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Handle to fax server
    pLoggingCfg     [in ] - New configuration

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetActivityLoggingConfigurationW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!pLoggingCfg)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pLoggingCfg is NULL."));
        return FALSE;
    }

    if (sizeof (FAX_ACTIVITY_LOGGING_CONFIGW) != pLoggingCfg->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR,
            _T("sizeof (FAX_ACTIVITY_LOGGING_CONFIGW) != pLoggingCfg->dwSizeOfStruct."));
        return FALSE;
    }

    if (pLoggingCfg->bLogIncoming || pLoggingCfg->bLogOutgoing)
    {
        if ((NULL == pLoggingCfg->lptstrDBPath) || (L'\0' == pLoggingCfg->lptstrDBPath[0]))
        {
            DebugPrintEx(DEBUG_ERR, _T("Empty logging database specified"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (lstrlenW (pLoggingCfg->lptstrDBPath) > MAX_DIR_PATH)  // Limit of directory path length
        {
            DebugPrintEx(DEBUG_ERR, _T("DB file name exceeds MAX_PATH"));
            SetLastError (ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }
    }

    __try
    {
        ec = FAX_SetActivityLoggingConfiguration(
                    FH_FAX_HANDLE(hFaxHandle),
                    pLoggingCfg );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetActivityLoggingConfiguration. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}   // FaxSetActivityLoggingConfigurationW

#ifndef UNICODE

FaxSetActivityLoggingConfigurationX (
    IN HANDLE                               hFaxHandle,
    IN CONST PFAX_ACTIVITY_LOGGING_CONFIGW  pLoggingCfg
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (pLoggingCfg);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxSetActivityLoggingConfigurationX

#endif // #ifndef UNICODE




//********************************************
//*              Outbound routing
//********************************************

BOOL
WINAPI
FaxAddOutboundGroupA (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR lpctstrGroupName
)
{
    LPWSTR lpwstrGroupName;
    BOOL bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxAddOutboundGroupA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!lpctstrGroupName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpctstrGroupName is NULL."));
        return FALSE;
    }

    if (_mbsicmp((PUCHAR)lpctstrGroupName, (PUCHAR)ROUTING_GROUP_ALL_DEVICESA) == 0)
    {
        SetLastError(ERROR_DUP_NAME);
        DebugPrintEx(DEBUG_ERR,
            _T("_mbsicmp((PUCHAR)lpctstrGroupName, (PUCHAR)ROUTING_GROUP_ALL_DEVICESA) == 0."));
        return FALSE;
    }

    if (strlen(lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        DebugPrintEx(DEBUG_ERR, _T("strlen(lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME."));
        return FALSE;
    }

    if (NULL == (lpwstrGroupName = AnsiStringToUnicodeString(lpctstrGroupName)))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AnsiStringToUnicodeString failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    bRes = FaxAddOutboundGroupW (hFaxHandle, lpwstrGroupName);
    MemFree (lpwstrGroupName);
    return bRes;
}

BOOL
WINAPI
FaxAddOutboundGroupW (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
)
/*++

Routine name : FaxAddOutboundGroupW

Routine description:

    Adds an empty outbound routing group for a Fax server

Author:

    Oded Sacher (OdedS),    Nov, 1999

Arguments:

    hFaxHandle          [ in ] - Fax server handle obtained from a call to FaxConnectFaxServer
    lpctstrGroupName    [ in ] - A pointer to a null-terminated string that uniqely identifies a new group name

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxAddOutboundGroupW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!lpctstrGroupName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpctstrGroupName is NULL."));
        return FALSE;
    }

    if (_wcsicmp (lpctstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0)
    {
        SetLastError(ERROR_DUP_NAME);
        DebugPrintEx(DEBUG_ERR,
            _T("_mbsicmp((PUCHAR)lpctstrGroupName, (PUCHAR)ROUTING_GROUP_ALL_DEVICESA) == 0."));
        return FALSE;
    }

    if (wcslen (lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        DebugPrintEx(DEBUG_ERR, _T("strlen(lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME."));
        return FALSE;
    }

    __try
    {
        ec = FAX_AddOutboundGroup( FH_FAX_HANDLE(hFaxHandle),
                                   lpctstrGroupName );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_AddOutboundGroup. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}

#ifndef UNICODE

FaxAddOutboundGroupX (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR lpctstrGroupName
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (lpctstrGroupName);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE


BOOL
WINAPI
FaxSetOutboundGroupA (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPA pGroup
)
{
    FAX_OUTBOUND_ROUTING_GROUPW GroupW;
    BOOL bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetOutboundGroupA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!pGroup)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pGroup is NULL."));
        return FALSE;
    }

    if (sizeof (FAX_OUTBOUND_ROUTING_GROUPA) != pGroup->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("sizeof (FAX_OUTBOUND_ROUTING_GROUPA) != pGroup->dwSizeOfStruct."));
        return FALSE;
    }

    if (!pGroup->lpctstrGroupName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pGroup->lpctstrGroupName is NULL."));
        return FALSE;
    }

    if (strlen (pGroup->lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        DebugPrintEx(DEBUG_ERR, _T("strlen (pGroup->lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME."));
        return FALSE;
    }

    if (!pGroup->lpdwDevices && pGroup->dwNumDevices)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("!pGroup->lpdwDevices && pGroup->dwNumDevices."));
        return FALSE;
    }

    //
    // Create a UNICODE structure and pass along to UNICODE function
    // Ansi structure is same size as unicode structure, so we can just copy it, then
    // cast the string pointers correctly
    //
    CopyMemory(&GroupW, pGroup, sizeof(FAX_OUTBOUND_ROUTING_GROUPA));
    GroupW.dwSizeOfStruct = sizeof (FAX_OUTBOUND_ROUTING_GROUPW);

    if (NULL == (GroupW.lpctstrGroupName = AnsiStringToUnicodeString(pGroup->lpctstrGroupName)))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AnsiStringToUnicodeString failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    bRes = FaxSetOutboundGroupW (hFaxHandle, &GroupW);
    MemFree((PVOID)GroupW.lpctstrGroupName);
    return bRes;
}


BOOL
WINAPI
FaxSetOutboundGroupW (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPW pGroup
)
/*++

Routine name : FaxSetOutboundGroupW

Routine description:

    Sets an outbound routing group settings for a Fax server

Author:

    Oded Sacher (OdedS),    Nov, 1999

Arguments:

    hFaxHandle      [in] - Fax server handle
    pGroup          [in] - Pointer to a FAX_OUTBOUND_ROUTING_GROUP buffer to set

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetOutboundGroupW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!pGroup)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pGroup is NULL."));
        return FALSE;
    }

    if (sizeof (FAX_OUTBOUND_ROUTING_GROUPW) != pGroup->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("sizeof (FAX_OUTBOUND_ROUTING_GROUPW) != pGroup->dwSizeOfStruct."));
        return FALSE;
    }

    if (!pGroup->lpctstrGroupName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pGroup->lpctstrGroupName is NULL."));
        return FALSE;
    }

    if (wcslen (pGroup->lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        DebugPrintEx(DEBUG_ERR, _T("wcslen (pGroup->lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME."));
        return FALSE;
    }

    if (!pGroup->lpdwDevices && pGroup->dwNumDevices)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("!pGroup->lpdwDevices && pGroup->dwNumDevices."));
        return FALSE;
    }

    Assert (sizeof (RPC_FAX_OUTBOUND_ROUTING_GROUPW) == sizeof (FAX_OUTBOUND_ROUTING_GROUPW));

    __try
    {
        ec = FAX_SetOutboundGroup( FH_FAX_HANDLE(hFaxHandle),
                                   (PRPC_FAX_OUTBOUND_ROUTING_GROUPW)pGroup
                                 );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetOutboundGroup. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}


#ifndef UNICODE

FaxSetOutboundGroupX (
    IN  HANDLE                       hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_GROUPW pGroup
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (pGroup);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif // #ifndef UNICODE



WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsA (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPA   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
)
{
    PFAX_OUTBOUND_ROUTING_GROUPW pGroup;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumOutboundGroupsA"));

    //
    //  no need to validate parameters, FaxEnumOutboundGroupsW() will do that
    //

    if (!FaxEnumOutboundGroupsW (hFaxHandle,
                                 (PFAX_OUTBOUND_ROUTING_GROUPW*) ppGroups,
                                 lpdwNumGroups))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxEnumOutboundGroupsW() is failed. (ec: %ld)"), GetLastError());
        return FALSE;
    }

    pGroup = (PFAX_OUTBOUND_ROUTING_GROUPW) *ppGroups;
    for (i = 0; i < *lpdwNumGroups; i++)
    {
        if (!ConvertUnicodeStringInPlace((LPWSTR) pGroup[i].lpctstrGroupName))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*ppGroups);
            return FALSE;
        }            
    }
    return TRUE;
}   //FaxEnumOutboundGroupsA



WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsW (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPW   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
)
/*++

Routine name : FaxEnumOutboundGroupsW

Routine description:

    Enumerates all the outbound routing groups of a fax server.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in    ] - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    ppGroups            [out   ] - A pointer to a buffer of FAX_OUTBOUND_ROUTING_GROUP structures.
                                   This buffer is allocated by the function and the client should call FaxFreeBuffer to free it.
    lpdwNumGroups       [out   ] - Pointer to a DWORD value indicating the number of groups retrieved.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DWORD dwBufferSize = 0;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumOutboundGroupsW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!ppGroups)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppGroups is NULL."));
        return FALSE;
    }

    if (!lpdwNumGroups)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpdwNumGroups is NULL."));
        return FALSE;
    }

    *ppGroups = NULL;
    *lpdwNumGroups = 0;

    __try
    {
        ec = FAX_EnumOutboundGroups( FH_FAX_HANDLE(hFaxHandle),
                                     (LPBYTE*) ppGroups,
                                     &dwBufferSize,
                                     lpdwNumGroups
                                   );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumOutboundGroups. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    //
    // Unpack buffer
    //
    for (i = 0; i < *lpdwNumGroups; i++)
    {
        FixupStringPtrW( ppGroups, (*ppGroups)[i].lpctstrGroupName );
        if ((*ppGroups)[i].lpdwDevices != NULL)
        {
            (*ppGroups)[i].lpdwDevices =
                (LPDWORD)((LPBYTE)(*ppGroups) + (ULONG_PTR)((*ppGroups)[i].lpdwDevices));
        }
    }
    return TRUE;

}//FaxEnumOutboundGroupsW



#ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumOutboundGroupsX (
    IN  HANDLE                          hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_GROUPW   *ppGroups,
    OUT LPDWORD                         lpdwNumGroups
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (ppGroups);
    UNREFERENCED_PARAMETER (lpdwNumGroups);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE



WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupA (
    IN  HANDLE   hFaxHandle,
    IN  LPCSTR   lpctstrGroupName
)
{
    LPWSTR lpwstrGroupName;
    BOOL bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxRemoveOutboundGroupA"));

    if (NULL == (lpwstrGroupName = AnsiStringToUnicodeString(lpctstrGroupName)))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AnsiStringToUnicodeString failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    bRes = FaxRemoveOutboundGroupW (hFaxHandle, lpwstrGroupName);
    MemFree (lpwstrGroupName);
    return bRes;

}//FaxRemoveOutboundGroupA


WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupW (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
)
/*++

Routine name : FaxRemoveOutboundGroupW

Routine description:

    Removes an existing outbound routing group for a Fax server

Author:

    Oded Sacher (OdedS),    Nov, 1999

Arguments:

    hFaxHandle          [ in ] - Fax server handle obtained from a call to FaxConnectFaxServer
    lpctstrGroupName    [ in ] - A pointer to a null-terminated string that uniqely identifies the group name

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxRemoveOutboundGroupW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!lpctstrGroupName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpctstrGroupName is NULL."));
        return FALSE;
    }

    if (_wcsicmp (lpctstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0)
    {
        SetLastError(ERROR_INVALID_OPERATION);
        DebugPrintEx(DEBUG_ERR, _T("_wcsicmp (lpctstrGroupName, ROUTING_GROUP_ALL_DEVICESW) == 0."));
        return FALSE;
    }

    if (wcslen (lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        SetLastError(ERROR_BUFFER_OVERFLOW);
        DebugPrintEx(DEBUG_ERR, _T("wcslen (lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME."));
        return FALSE;
    }

    __try
    {
        ec = FAX_RemoveOutboundGroup( FH_FAX_HANDLE(hFaxHandle),
                                      lpctstrGroupName );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_RemoveOutboundGroup. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;

}//FaxRemoveOutboundGroupW


#ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRemoveOutboundGroupX (
    IN  HANDLE   hFaxHandle,
    IN  LPCWSTR lpctstrGroupName
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (lpctstrGroupName);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE

BOOL
WINAPI
FaxSetDeviceOrderInGroupA (
        IN      HANDLE          hFaxHandle,
        IN      LPCSTR        lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
)
{
    LPWSTR lpwstrGroupName;
    BOOL bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetDeviceOrderInGroupA"));

    if (NULL == (lpwstrGroupName = AnsiStringToUnicodeString(lpctstrGroupName)))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AnsiStringToUnicodeString failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    bRes = FaxSetDeviceOrderInGroupW (hFaxHandle, lpwstrGroupName, dwDeviceId, dwNewOrder);
    MemFree (lpwstrGroupName);
    return bRes;

}//FaxSetDeviceOrderInGroupA


BOOL
WINAPI
FaxSetDeviceOrderInGroupW (
        IN      HANDLE          hFaxHandle,
        IN      LPCWSTR         lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
)
/*++

Routine name : FaxSetDeviceOrderInGroupW

Routine description:

    Sets the order of a single device in a group of outbound routing devices.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in] - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function
    lpctstrGroupName    [in] - A pointer to a null-terminated string that uniquely identifies a group.
    dwDeviceId          [in] - A DWORD value specifying the id of the device in the group. The specified device must exist in the group.
    dwNewOrder          [in] - A DWORD value specifying the new 1-based order of the device in the group. If there are N devices in the group, this value must be between 1 and N (including).

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.
--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetDeviceOrderInGroupW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!dwDeviceId)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("dwDeviceId is ZERO."));
        return FALSE;
    }

    if (!dwNewOrder)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("dwNewOrder is ZERO."));
        return FALSE;
    }

    if (!lpctstrGroupName)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpctstrGroupName is NULL."));
        return FALSE;
    }

    if (wcslen (lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME)
    {
        DebugPrintEx(DEBUG_ERR, _T("Group name length exceeded MAX_ROUTING_GROUP_NAME"));
        SetLastError(ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }

    __try
    {
        ec = FAX_SetDeviceOrderInGroup( FH_FAX_HANDLE(hFaxHandle),
                                        lpctstrGroupName,
                                        dwDeviceId,
                                        dwNewOrder);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetDeviceOrderInGroup. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;

}//FaxSetDeviceOrderInGroupW



#ifndef UNICODE

BOOL
WINAPI
FaxSetDeviceOrderInGroupX (
        IN      HANDLE          hFaxHandle,
        IN      LPCWSTR         lpctstrGroupName,
        IN      DWORD           dwDeviceId,
        IN      DWORD           dwNewOrder
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (lpctstrGroupName);
    UNREFERENCED_PARAMETER (dwDeviceId);
    UNREFERENCED_PARAMETER (dwNewOrder);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif // #ifndef UNICODE


BOOL
WINAPI
FaxAddOutboundRuleA (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCSTR      lpctstrGroupName,
    IN  BOOL        bUseGroup
)
{
    LPWSTR lpwstrGroupName = NULL;
    BOOL bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxAddOutboundRuleA"));

    if (TRUE == bUseGroup)
    {
        if (!lpctstrGroupName)
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("lpctstrGroupName is NULL"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (NULL == (lpwstrGroupName = AnsiStringToUnicodeString(lpctstrGroupName)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("AnsiStringToUnicodeString failed. (ec: %ld)"),
                GetLastError());
            return FALSE;
        }
    }

    bRes = FaxAddOutboundRuleW (hFaxHandle,
                                dwAreaCode,
                                dwCountryCode,
                                dwDeviceID,
                                lpwstrGroupName,
                                bUseGroup);
    MemFree (lpwstrGroupName);
    return bRes;
}



BOOL
WINAPI
FaxAddOutboundRuleW (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCWSTR     lpctstrGroupName,
    IN  BOOL        bUseGroup
)
/*++

Routine name : FaxAddOutboundRuleW

Routine description:

    Adds a new outbound routing rule to the fax service

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in] - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    dwAreaCode          [in] - The area code of the rule.
    dwCountryCode       [in] - The country code of the rule.
    dwDeviceID          [in] - The destination device of the rule.
    lpctstrGroupName    [in] - The destination group of the rule. This value is valid only if the bUseGroup member is TRUE.
    bUseGroup           [in] - A Boolean value specifying whether the group should be used as the destination.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxAddOutboundRuleW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY)
    {
        //
        // *.* can not be added; *.AreaCode is not a valid rule dialing location.
        //
        DebugPrintEx(DEBUG_ERR,
            _T("dwCountryCode = 0; *.* can not be added; *.AreaCode is not a valid rule dialing location"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (TRUE == bUseGroup)
    {
        if (!lpctstrGroupName)
        {
            DebugPrintEx(DEBUG_ERR, _T("lpctstrGroupName is NULL"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (wcslen (lpctstrGroupName) >= MAX_ROUTING_GROUP_NAME)
        {
            DebugPrintEx(DEBUG_ERR, _T("Group name length exceeded MAX_ROUTING_GROUP_NAME"));
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }
    }
    else
    {
        if (!dwDeviceID)
        {
            DebugPrintEx(DEBUG_ERR, _T("dwDeviceId = 0; Not a valid device ID"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        lpctstrGroupName = NULL;
    }


    __try
    {
        ec = FAX_AddOutboundRule( FH_FAX_HANDLE(hFaxHandle),
                                  dwAreaCode,
                                  dwCountryCode,
                                  dwDeviceID,
                                  lpctstrGroupName,
                                  bUseGroup);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_AddOutboundRule. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;

} //FaxAddOutboundRuleW


#ifndef UNICODE

BOOL
WINAPI
FaxAddOutboundRuleX (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode,
    IN  DWORD       dwDeviceID,
    IN  LPCWSTR     lpctstrGroupName,
    IN  BOOL        bUseGroup
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwAreaCode);
    UNREFERENCED_PARAMETER (dwCountryCode);
    UNREFERENCED_PARAMETER (dwDeviceID);
    UNREFERENCED_PARAMETER (lpctstrGroupName);
    UNREFERENCED_PARAMETER (bUseGroup);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif  // #ifndef UNICODE

BOOL
WINAPI
FaxRemoveOutboundRule (
    IN  HANDLE      hFaxHandle,
    IN  DWORD       dwAreaCode,
    IN  DWORD       dwCountryCode
)
/*++

Routine name : FaxRemoveOutboundRule

Routine description:

    Removes an existing outbound routing rule from the fax service

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in] - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    dwAreaCode          [in] - The area code of the rule.
    dwCountryCode       [in] - The country code of the rule.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxRemoveOutboundRule"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY)
    {
        //
        // *.* can not be removed; *.AreaCode is not a valid rule dialing location.
        //
        DebugPrintEx(DEBUG_ERR,
            _T("dwCountryCode = 0; *.* can not be removed; *.AreaCode is not a valid rule dialing location"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try
    {
        ec = FAX_RemoveOutboundRule( FH_FAX_HANDLE(hFaxHandle),
                                     dwAreaCode,
                                     dwCountryCode);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_RemoveOutboundRule. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;

} // FaxRemoveOutboundRule


BOOL
WINAPI
FaxEnumOutboundRulesA (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEA *ppRules,
    OUT LPDWORD                      lpdwNumRules
)
{
    PFAX_OUTBOUND_ROUTING_RULEW pRule;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumOutboundRulesA"));

    //
    //  no need to validate parameters, FaxEnumOutboundRulesW() will do that
    //

    if (!FaxEnumOutboundRulesW (hFaxHandle,
                                (PFAX_OUTBOUND_ROUTING_RULEW*) ppRules,
                                lpdwNumRules))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxEnumOutboundRulesW() is failed. (ec: %ld)"), GetLastError());
        return FALSE;
    }

    pRule = (PFAX_OUTBOUND_ROUTING_RULEW) *ppRules;
    for (i = 0; i < *lpdwNumRules; i++)
    {
        if (TRUE == pRule[i].bUseGroup)
        {
            if (!ConvertUnicodeStringInPlace((LPWSTR) pRule[i].Destination.lpcstrGroupName))
            {
                DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
                MemFree (*ppRules);
                return FALSE;
            }            
        }
        if (!ConvertUnicodeStringInPlace((LPWSTR) pRule[i].lpctstrCountryName))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*ppRules);
            return FALSE;
        }            
    }
    return TRUE;
}   // FaxEnumOutboundRulesA



BOOL
WINAPI
FaxEnumOutboundRulesW (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEW *ppRules,
    OUT LPDWORD                      lpdwNumRules
)
/*++

Routine name : FaxEnumOutboundRulesW

Routine description:

    Enumerates all the outbound routing rules of a fax server.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle          [in] - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    ppRules             [out] - A pointer to a buffer of FAX_OUTBOUND_ROUTING_RULE structures.
                                   This buffer is allocated by the function and the client should call FaxFreeBuffer to free it.
    lpdwNumRules        [out] - Pointer to a DWORD value indicating the number of rules retrieved.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DWORD dwBufferSize = 0;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumOutboundRulesW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
        return FALSE;
    }

    if (!ppRules)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppRules is NULL"));
        return FALSE;
    }

    if (!lpdwNumRules)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpdwNumRules is NULL."));
        return FALSE;
    }

    *ppRules = NULL;
    *lpdwNumRules = 0;

    __try
    {
        ec = FAX_EnumOutboundRules( FH_FAX_HANDLE(hFaxHandle),
                                    (LPBYTE*) ppRules,
                                    &dwBufferSize,
                                    lpdwNumRules
                                   );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumOutboundRules. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    //
    // Unpack buffer
    //
    for (i = 0; i < *lpdwNumRules; i++)
    {
        if (TRUE == (*ppRules)[i].bUseGroup)
        {
            FixupStringPtrW( ppRules, (*ppRules)[i].Destination.lpcstrGroupName );
        }
        FixupStringPtrW( ppRules, (*ppRules)[i].lpctstrCountryName);
    }

    return TRUE;

}  // FaxEnumOutboundRulesW


#ifndef UNICODE

BOOL
WINAPI
FaxEnumOutboundRulesX (
    IN  HANDLE                       hFaxHandle,
    OUT PFAX_OUTBOUND_ROUTING_RULEW *ppRules,
    OUT LPDWORD                      lpdwNumRules
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (ppRules);
    UNREFERENCED_PARAMETER (lpdwNumRules);
    return FALSE;
} // FaxEnumOutboundRulesX

#endif  // #ifndef UNICODE



BOOL
WINAPI
FaxSetOutboundRuleA (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEA pRule
)
{
    FAX_OUTBOUND_ROUTING_RULEW RuleW;
    BOOL bRes;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetOutboundRuleA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE)) {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!pRule) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pRule is NULL."));
        return FALSE;
    }

    if (pRule->dwSizeOfStruct != sizeof(FAX_OUTBOUND_ROUTING_RULEA)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pRule->dwSizeOfStruct != sizeof(FAX_OUTBOUND_ROUTING_RULEA)."));
        return FALSE;
    }

    //
    // Create a UNICODE structure and pass along to UNICODE function
    // Ansi structure is same size as unicode structure, so we can just copy it, then
    // cast the string pointers correctly
    //
    CopyMemory(&RuleW, pRule, sizeof(FAX_OUTBOUND_ROUTING_RULEA));
    RuleW.dwSizeOfStruct = sizeof (FAX_OUTBOUND_ROUTING_RULEW);

    if (TRUE == pRule->bUseGroup)
    {
        if (!(pRule->Destination).lpcstrGroupName)
        {
            DebugPrintEx(DEBUG_ERR, _T("lpcstrGroupName is NULL"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (NULL == (RuleW.Destination.lpcstrGroupName =
            AnsiStringToUnicodeString((pRule->Destination).lpcstrGroupName)))
        {
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString failed. (ec: %ld)"), GetLastError());
            return FALSE;
        }
    }

    bRes = FaxSetOutboundRuleW (hFaxHandle, &RuleW);

    if (TRUE == pRule->bUseGroup)
    {
        MemFree ((void*)(RuleW.Destination.lpcstrGroupName));
    }
    return bRes;


} // FaxSetOutboundRuleA



BOOL
WINAPI
FaxSetOutboundRuleW (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEW pRule
)
/*++

Routine name : FaxSetOutboundRuleW

Routine description:

    Sets an outbound routing rule settings for a fax server.

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    hFaxHandle      [in] - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    pRule           [in] - A pointer to a FAX_OUTBOUND_ROUTING_RULE buffer to set.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    FAX_OUTBOUND_ROUTING_RULEW Rule;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetOutboundRuleW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!pRule) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pRule is NULL."));
        return FALSE;
    }

    if (pRule->dwSizeOfStruct != sizeof(FAX_OUTBOUND_ROUTING_RULEW)) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pRule->dwSizeOfStruct != sizeof(FAX_OUTBOUND_ROUTING_RULEW)."));
        return FALSE;
    }

    if (pRule->dwCountryCode == ROUTING_RULE_COUNTRY_CODE_ANY &&
        pRule->dwAreaCode != ROUTING_RULE_AREA_CODE_ANY)
    {
        //
        //  *.AreaCode is not a valid rule dialing location.
        //
        DebugPrintEx(DEBUG_ERR,
            _T("dwCountryCode = 0 , dwAreaCode != 0; *.AreaCode is not a valid rule dialing location"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (TRUE == pRule->bUseGroup)
    {
        if (!(pRule->Destination).lpcstrGroupName)
        {
            DebugPrintEx(DEBUG_ERR, _T("lpcstrGroupName is NULL"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }

        if (wcslen ((pRule->Destination).lpcstrGroupName) >= MAX_ROUTING_GROUP_NAME)
        {
            DebugPrintEx(DEBUG_ERR, _T("Group name length exceeded MAX_ROUTING_GROUP_NAME"));
            SetLastError(ERROR_BUFFER_OVERFLOW);
            return FALSE;
        }
    }
    else
    {
        if (!(pRule->Destination).dwDeviceId)
        {
            DebugPrintEx(DEBUG_ERR, _T("dwDeviceId = 0; Not a valid device ID"));
            SetLastError(ERROR_INVALID_PARAMETER);
            return FALSE;
        }
    }
    //
    // Zero the country name parameter of the rule before calling the RPC function.
    // This parameter is out only but the RPC client will try to marshal it if we don't NULL it.
    // This should be done in the IDL but due to backwards compatability issues with BOS Fax, we can't change that.
    //
    Rule = *pRule;
    Rule.lpctstrCountryName = NULL;
    __try
    {
        ec = FAX_SetOutboundRule( FH_FAX_HANDLE(hFaxHandle),
                                  (PRPC_FAX_OUTBOUND_ROUTING_RULEW)&Rule);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetOutboundRule. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;

}  // FaxSetOutboundRuleW



#ifndef UNICODE

BOOL
WINAPI
FaxSetOutboundRuleX (
    IN  HANDLE                      hFaxHandle,
    IN  PFAX_OUTBOUND_ROUTING_RULEW pRule
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (pRule);
    return FALSE;
} // FaxSetOutboundRuleX

#endif  //  #ifndef UNICODE


BOOL
WINAPI
FaxGetServerActivity (
    IN  HANDLE               hFaxHandle,
    OUT PFAX_SERVER_ACTIVITY pServerActivity
)
/*++

Routine name : FaxGetServerActivity

Routine description:

    Retrieves the status of the fax server queue activity and event log reports.

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    hFaxHandle      [in] - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    pServerActivity [in] - A pointer to a FAX_SERVER_ACTIVITY object.
                           The object will be allocated and freed by the calling client.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetServerActivity"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!pServerActivity)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pServerActivity is NULL."));
        return FALSE;
    }

    if (sizeof (FAX_SERVER_ACTIVITY) != pServerActivity->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("sizeof (FAX_SERVER_ACTIVITY) != pServerActivity->dwSizeOfStruct."));
        return FALSE;
    }

    __try
    {
        ec = FAX_GetServerActivity( FH_FAX_HANDLE(hFaxHandle),
                                    pServerActivity);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetServerActivity. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}  // FaxGetServerActivity



BOOL
WINAPI
FaxGetReceiptsOptions (
    IN  HANDLE  hFaxHandle,
    OUT PDWORD  pdwReceiptsOptions
)
/*++

Routine name : FaxGetReceiptsOptions

Routine description:

    Retrieves the supported receipt options on the server.

Author:

    Eran Yariv (EranY),    July, 2000

Arguments:

    hFaxHandle          [in]  - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    pdwReceiptsOptions  [out] - Buffer to receive receipts options (bit-wise combination of DRT_* constants)

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetReceiptsOptions"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!pdwReceiptsOptions)
    {
        DebugPrintEx(DEBUG_ERR, _T("pdwReceiptsOptions is NULL"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try
    {
        ec = FAX_GetReceiptsOptions( FH_FAX_HANDLE(hFaxHandle),
                                     pdwReceiptsOptions);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetReceiptsOptions. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}  // FaxGetReceiptsOptions



BOOL
WINAPI
FaxGetPersonalCoverPagesOption (
    IN  HANDLE  hFaxHandle,
    OUT LPBOOL  lpbPersonalCPAllowed
)
/*++

Routine name : FaxGetPersonalCoverPagesOption

Routine description:

    Retrieves if the server supports personal cover pages

Author:

    Eran Yariv (EranY),    July, 2000

Arguments:

    hFaxHandle            [in]  - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    lpbPersonalCPAllowed  [out] - Buffer to receive server support of personal coverpages.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetPersonalCoverPagesOption"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!lpbPersonalCPAllowed)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpbPersonalCPAllowed is NULL"));
        return FALSE;
    }

    __try
    {
        ec = FAX_GetPersonalCoverPagesOption( FH_FAX_HANDLE(hFaxHandle),
                                              lpbPersonalCPAllowed);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetPersonalCoverPagesOption. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}  // FaxGetPersonalCoverPagesOption


BOOL
WINAPI
FaxGetConfigWizardUsed (
    OUT LPBOOL  lpbConfigWizardUsed
)
/*++

Routine name : FaxGetConfigWizardUsed

Routine description:

    Retrieves if the configuration wizard (devices) was run on the server.

Author:

    Eran Yariv (EranY),    July, 2000

Arguments:

    lpbConfigWizardUsed   [out] - Buffer to receive config wizard usage flag.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwRes2;
    HKEY hKey;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetConfigWizardUsed"));

    if (!lpbConfigWizardUsed)
    {
        DebugPrintEx(DEBUG_ERR, _T("lpbConfigWizardUsed is NULL"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    dwRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, REGKEY_FAX_CLIENT, 0, KEY_READ, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening server key (ec = %ld)"),
            dwRes);
        goto exit;
    }
    *lpbConfigWizardUsed = GetRegistryDword (hKey, REGVAL_CFGWZRD_DEVICE);
    dwRes2 = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dwRes2)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing server key (ec = %ld)"),
            dwRes2);
    }

    Assert (ERROR_SUCCESS == dwRes);
exit:
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError(dwRes);
        return FALSE;
    }

    return TRUE;
}  // FaxGetConfigWizardUsed


BOOL
WINAPI
FaxSetConfigWizardUsed (
    IN  HANDLE  hFaxHandle,
    IN  BOOL    bConfigWizardUsed
)
/*++

Routine name : FaxSetConfigWizardUsed

Routine description:

    Sets if the configuration wizard (devices) was run on the server.

Author:

    Eran Yariv (EranY),    July, 2000

Arguments:

    hFaxHandle            [in] - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    bConfigWizardUsed     [in] - Was the configuration wizard used?

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetConfigWizardUsed"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }
    if (!IsLocalFaxConnection(hFaxHandle))
    {
        DebugPrintEx(DEBUG_ERR, _T("Not a local fax connection"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    if (FAX_API_VERSION_1 > FH_SERVER_VER(hFaxHandle))
    {
        //
        // Servers of API version 0 don't support FAX_SetConfigWizardUsed
        //
        ASSERT_FALSE;   // Can't happen - if it's local
        DebugPrintEx(DEBUG_ERR,
                     _T("Server version is %ld - doesn't support this call"),
                     FH_SERVER_VER(hFaxHandle));
        SetLastError(FAX_ERR_VERSION_MISMATCH);
        return FALSE;
    }

    __try
    {
        ec = FAX_SetConfigWizardUsed( FH_FAX_HANDLE(hFaxHandle),
                                      bConfigWizardUsed);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetConfigWizardUsed. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    return TRUE;
}  // FaxSetConfigWizardUsed

//********************************************
//*            Routing extensions
//********************************************

BOOL
WINAPI
FaxEnumRoutingExtensionsA (
    IN  HANDLE                        hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOA *ppExts,
    OUT LPDWORD                       lpdwNumExts
)
/*++

Routine name : FaxEnumRoutingExtensionsA

Routine description:

    Enumerates routing extensions - ANSI version

Author:

    Eran Yariv (EranY), July, 2000

Arguments:

    hFaxHandle       [in ] - Handle to fax server
    ppExts           [out] - Pointer to buffer to return array of extensions.
    lpdwNumExts      [out] - Number of extensions returned in the array.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    PFAX_ROUTING_EXTENSION_INFOW pUnicodeExts;
    DWORD                        dwNumExts;
    DWORD                        dwCur;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumRoutingExtensionsA"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!ppExts)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppExts is NULL."));
        return FALSE;
    }

    if (!lpdwNumExts)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pdwNumExts is NULL."));
        return FALSE;
    }

    //
    // Call the UNICODE version first
    //
    if (!FaxEnumRoutingExtensionsW (hFaxHandle, &pUnicodeExts, &dwNumExts))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxEnumRoutingExtensionsW() is failed. ec = %ld."), GetLastError());
        return FALSE;
    }

    //
    // Convert returned value back into ANSI.
    // We keep the UNICODE structures and do a UNICODE to ANSI convert in place.
    //
    *lpdwNumExts = dwNumExts;
    *ppExts = (PFAX_ROUTING_EXTENSION_INFOA) pUnicodeExts;

    for (dwCur = 0; dwCur < dwNumExts; dwCur++)
    {
        if (!ConvertUnicodeStringInPlace(pUnicodeExts[dwCur].lpctstrFriendlyName) ||
            !ConvertUnicodeStringInPlace(pUnicodeExts[dwCur].lpctstrImageName)    ||
            !ConvertUnicodeStringInPlace(pUnicodeExts[dwCur].lpctstrExtensionName))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (pUnicodeExts);
            return FALSE;
        }            
    }
    return TRUE;
}   // FaxEnumRoutingExtensionsA


BOOL
WINAPI
FaxEnumRoutingExtensionsW (
    IN  HANDLE                        hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOW *ppExts,
    OUT LPDWORD                       lpdwNumExts
)
/*++

Routine name : FaxEnumRoutingExtensionsW

Routine description:

    Enumerates routing extensions - UNICODE version

Author:

    Eran Yariv (EranY), July, 2000

Arguments:

    hFaxHandle       [in ] - Handle to fax server
    ppExts           [out] - Pointer to buffer to return array of extensions.
    lpdwNumExts      [out] - Number of extensions returned in the array.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DWORD dwConfigSize;
    DWORD dwCur;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumRoutingExtensionsW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!ppExts)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppExts is NULL."));
        return FALSE;
    }

    if (!lpdwNumExts)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("pdwNumExts is NULL."));
        return FALSE;
    }

    *ppExts = NULL;

    if (FAX_API_VERSION_1 > FH_SERVER_VER(hFaxHandle))
    {
        //
        // Servers of API version 0 don't support FAX_EnumRoutingExtensions
        // We'll fake it and return an empty list.
        //
        DebugPrintEx(DEBUG_MSG,
                     _T("Server version is %ld - doesn't support this call"),
                     FH_SERVER_VER(hFaxHandle));
        SetLastError(FAX_ERR_VERSION_MISMATCH);
        return FALSE;
    }


    //
    // Call the RPC function
    //
    __try
    {
        ec = FAX_EnumRoutingExtensions(
                    FH_FAX_HANDLE(hFaxHandle),
                    (LPBYTE*)ppExts,
                    &dwConfigSize,
                    lpdwNumExts
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumRoutingExtensions. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    for (dwCur = 0; dwCur < (*lpdwNumExts); dwCur++)
    {
        FixupStringPtrW( ppExts, (*ppExts)[dwCur].lpctstrFriendlyName );
        FixupStringPtrW( ppExts, (*ppExts)[dwCur].lpctstrImageName );
        FixupStringPtrW( ppExts, (*ppExts)[dwCur].lpctstrExtensionName );
    }

    return TRUE;
}   // FaxEnumRoutingExtensionsW

#ifndef UNICODE

BOOL
WINAPI
FaxEnumRoutingExtensionsX (
    IN  HANDLE                        hFaxHandle,
    OUT PFAX_ROUTING_EXTENSION_INFOW *ppExts,
    OUT LPDWORD                       lpdwNumExts
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (ppExts);
    UNREFERENCED_PARAMETER (lpdwNumExts);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxEnumRoutingExtensionsX

#endif // #ifndef UNICODE


WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersA(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOA  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    )
/*++

Routine name : FaxGetServicePrintersA

Routine description:

    Retrieves Information about Printers that are known by the Service

Author:

    Iv Garber (IvG),    August, 2000

Arguments:

    hFaxHandle      [in]  - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    pPrinterInfo    [out] - Buffer to receive the Printers Info
    PrintersReturned[out]   -   Count of the Printers Info structures returned

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetServicePrintersA"));

    //
    //  no need to validate parameters, FaxGetServicePrintersW() will do that
    //

    if (!FaxGetServicePrintersW(hFaxHandle,
            (PFAX_PRINTER_INFOW *)ppPrinterInfo,
            lpdwPrintersReturned))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxGetServicePrintersW() failed. (ec: %ld)"), GetLastError());
        return FALSE;
    }

    DWORD   i;
    for ( i = 0 ; i < (*lpdwPrintersReturned) ; i++ )
    {
        if (!ConvertUnicodeStringInPlace((LPWSTR) (*ppPrinterInfo)[i].lptstrPrinterName)   ||
            !ConvertUnicodeStringInPlace((LPWSTR) (*ppPrinterInfo)[i].lptstrDriverName)    ||
            !ConvertUnicodeStringInPlace((LPWSTR) (*ppPrinterInfo)[i].lptstrServerName))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*ppPrinterInfo);
            return FALSE;
        }            
    }
    return TRUE;
}   // FaxGetServicePrintersA


WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersW(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOW  *ppPrinterInfo,
    OUT LPDWORD lpdwPrintersReturned
    )
/*++

Routine name : FaxGetServicePrintersW

Routine description:

    Retrieves Information about Printers that are known by the Service

Author:

    Iv Garber (IvG),    August, 2000

Arguments:

    hFaxHandle      [in]  - Specifies a fax server handle returned by a call to the FaxConnectFaxServer function.
    pPrinterInfo    [out] - Buffer to receive the Printers Info
    PrintersReturned[out]   -   Count of the Printers Info structures returned

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetServicePrintersW"));

    //
    //  Validate Parameters
    //

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!ppPrinterInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppPrinterInfo is NULL."));
        return FALSE;
    }

    if (!lpdwPrintersReturned)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpdwPrintersReturned is NULL."));
        return FALSE;
    }

    error_status_t ec;
    DWORD   dwBufferSize = 0;

    *ppPrinterInfo = NULL;
    *lpdwPrintersReturned = 0;

    __try
    {
        ec = FAX_GetServicePrinters(FH_FAX_HANDLE(hFaxHandle),
            (LPBYTE *)ppPrinterInfo,
            &dwBufferSize,
            lpdwPrintersReturned);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(DEBUG_ERR, _T("Exception on RPC call to FAX_GetServicePrinters. (ec: %ld)"), ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        SetLastError(ec);
        return FALSE;
    }

    PFAX_PRINTER_INFOW  pPrinter = (PFAX_PRINTER_INFOW) (*ppPrinterInfo);

    for ( DWORD i = 0; i < (*lpdwPrintersReturned) ; i++ )
    {
        FixupStringPtrW( ppPrinterInfo, pPrinter[i].lptstrPrinterName);
        FixupStringPtrW( ppPrinterInfo, pPrinter[i].lptstrDriverName);
        FixupStringPtrW( ppPrinterInfo, pPrinter[i].lptstrServerName);
    }

    return TRUE;
}

#ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetServicePrintersX(
    IN  HANDLE  hFaxHandle,
    OUT PFAX_PRINTER_INFOW  *pPrinterInfo,
    OUT LPDWORD PrintersReturned
    )
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (pPrinterInfo);
    UNREFERENCED_PARAMETER (PrintersReturned);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
} // FaxGetServicePrintersX

#endif  //  #ifndef UNICODE

//********************************************
//*            Manual answer support
//********************************************

BOOL
WINAPI
FaxAnswerCall(
        IN  HANDLE      hFaxHandle,
        IN  CONST DWORD dwDeviceId
)

/*++

Routine Description:

    Tells the server to answer specified call

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    dwDeviceId      - TAPI Permanent Line Id (from event notification)

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FaxAnswerCall"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
       return FALSE;
    }
   
    if (!IsLocalFaxConnection(hFaxHandle))
    {
        //
        //  Only local connections are allowed to do a FaxAnswerCall
        //
        DebugPrintEx(DEBUG_ERR, _T("Not a local fax connection"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }
    
    if (FAX_API_VERSION_1 > FH_SERVER_VER(hFaxHandle))
    {
        //
        // Servers of API version 0 don't support FAX_AnswerCall
        //
        DebugPrintEx(DEBUG_ERR,
                     _T("Server version is %ld - doesn't support this call"),
                     FH_SERVER_VER(hFaxHandle));
        SetLastError(FAX_ERR_VERSION_MISMATCH);
        return FALSE;
    }


    __try
    {
        ec = FAX_AnswerCall (FH_FAX_HANDLE(hFaxHandle), dwDeviceId);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_AnswerCall (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        DebugPrintEx(DEBUG_ERR, _T("FAX_AnswerCall failed. (ec: %ld)"), ec);
    }

    return (ERROR_SUCCESS == ec);
}   // FaxAnswerCall

//********************************************
//*   Ivalidate archive folder
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxRefreshArchive (
    IN  HANDLE                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER  Folder
)
/*++

Routine Description:

    Tells the server that the folder should be refreshed

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    Folder          - Archive folder ID

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FaxRefreshArchive"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
       return FALSE;
    }

    if(Folder != FAX_MESSAGE_FOLDER_INBOX &&
       Folder != FAX_MESSAGE_FOLDER_SENTITEMS)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Folder is invalid."));
        return FALSE;
    }

    __try
    {
        ec = FAX_RefreshArchive (FH_FAX_HANDLE(hFaxHandle), Folder);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_RefreshArchive (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus();
        DebugPrintEx(DEBUG_ERR, _T("FAX_RefreshArchive failed. (ec: %ld)"), ec);
    }

    return (ERROR_SUCCESS == ec);

} // FaxRefreshArchive
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\install.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    install.c

Abstract:

    This module contains installation functions.

Author:

    Andrew Ritz (andrewr) 9-Dec-1997


Revision History:
    4-Dec-1999 Danl Remove CreatePrinterandGroups

--*/

#include "faxapi.h"
#pragma hdrstop

extern HINSTANCE g_MyhInstance;

//
// Notice: FaxRegisterServiceProvider and FaxUnregisterServiceProvider are
// implemented directly in winfax.dll since it must exist
// even before the fax optional component is installed.
//


#ifdef UNICODE
BOOL AddMethodKey(
    HKEY hKey,
    LPCWSTR MethodName,
    LPCWSTR FriendlyName,
    LPCWSTR FunctionName,
    LPCWSTR Guid,
    DWORD Priority
    ) ;
#endif // #ifdef UNICODE


#ifdef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  hFaxHandle,
    IN LPCWSTR lpcwstrExtensionName,
    IN LPCWSTR lpcwstrFriendlyName,
    IN LPCWSTR lpcwstrImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW pCallBack,
    IN LPVOID lpvContext
    )
{
    HKEY hKey = NULL;
    BOOL bRetVal = FALSE;
    DWORD dwRet;
	WCHAR szKeyName[2000];

    PFAX_GLOBAL_ROUTING_INFO pRoutingInfo;
    DWORD dwMethods;
    DWORD dwLastError = ERROR_SUCCESS;

    WCHAR  wszMethodName[101];
    WCHAR  wszMethodFriendlyName[101];
    WCHAR  wszMethodFunctionName[101];
    WCHAR  wszMethodGuid[101];

    DEBUG_FUNCTION_NAME(TEXT("FaxRegisterRoutingExtensionW"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed"));
        SetLastError(ERROR_INVALID_HANDLE);
        return FALSE;
    }

    if (!lpcwstrExtensionName ||
        !lpcwstrFriendlyName  ||
        !lpcwstrImageName     ||
        !pCallBack)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("At least one of the given pointers is NULL."));
        return FALSE;
    }

    //
    // Local installation only
    //
    if (!IsLocalFaxConnection(hFaxHandle) )
    {
        DebugPrintEx(DEBUG_ERR, _T("Not a local fax connection"));
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }

    if ((_wcsicmp( lpcwstrExtensionName, REGKEY_ROUTING_EXTENSION ) != 0) &&
        TRUE == IsDesktopSKU())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("We do not support non MS routing extensions on desktop SKUs"));
        SetLastError (FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU);
        return FALSE;
    }

    //
    // Get the number of current methods for priority
    //
    if (!FaxEnumGlobalRoutingInfo(hFaxHandle, &pRoutingInfo, &dwMethods) )
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("FaxEnumGlobalRoutingInfo() failed, ec = %d"),
                     GetLastError());
        return FALSE;
    }

    //
    //  Store number of methods returned by EnumGlobalRoutingInfo()
    //
    DWORD   dwRegisteredMethods = dwMethods;

    //
    //  Return Value of the Function
    //
    BOOL    bResult = TRUE;

    //
    //  Variables to deal with newly registered Guids, to check their uniqueness
    //
    LPTSTR  *plptstrNewGuids = NULL;
    LPTSTR  lptstrGuid = NULL;
    LPTSTR  *pTmp = NULL;

    //
    //  Variable for different FOR cycles
    //
    DWORD i = 0;

    if (0 > _snwprintf(szKeyName,
                      ARR_SIZE(szKeyName) -1,
                      TEXT("%s\\%s\\%s"),
                      REGKEY_SOFTWARE,
                      REGKEY_ROUTING_EXTENSIONS,
                      lpcwstrExtensionName))
    {
        //
        // Extension name exceeds size
        //
        DebugPrintEx(DEBUG_ERR, _T("Extension name \"%s\" exceeds size"), lpcwstrExtensionName);
        dwLastError = ERROR_INVALID_PARAMETER;
        bResult = FALSE;
        goto FreeRoutingInfo;
    }
	szKeyName[ARR_SIZE(szKeyName) -1] = _T('\0');

    //
    //  Try to open registry key with the Extension Name
    //
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,
                           szKeyName,
                           FALSE,
                           0);
    if (!hKey)
    {
        //
        //  This is new Routing Extension, let's register it
        //
        hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,
            szKeyName,
            TRUE,
            0);

        if (!hKey)
        {
            dwLastError = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                _T("OpenRegistryKey(%s) failed. ec=%ld"),
                szKeyName,
                dwLastError);
            bResult = FALSE;
            goto FreeRoutingInfo;
        }
    }
    else
    {
        //
        //  Such Routing Extension is already registered
        //
        RegCloseKey(hKey);
        DebugPrintEx(DEBUG_ERR, _T("Routing Extension Name is duplicated : %s"), szKeyName);

        dwLastError = ERROR_INVALID_PARAMETER;
        bResult = FALSE;
        goto FreeRoutingInfo;
    }

    //
    // Add values
    //
    if (! (SetRegistryString(hKey, REGVAL_FRIENDLY_NAME, lpcwstrFriendlyName) &&
           SetRegistryStringExpand(hKey, REGVAL_IMAGE_NAME, lpcwstrImageName) ))
    {
        dwLastError = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("SetRegistryString failed. ec=%ld"), dwLastError);
        goto error_exit;
    }

    dwRet = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(DEBUG_ERR, _T("RegCloseKey failed. ec=%ld"), dwRet);
    }

    wcscat(szKeyName, L"\\");
    wcscat(szKeyName, REGKEY_ROUTING_METHODS);
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE,
                           szKeyName,
                           TRUE,
                           0);

    if (!hKey)
    {
        dwLastError = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("OpenRegistryKey(%s) failed. ec=%ld"), szKeyName, dwLastError);
        goto error_exit;
    }

    while (TRUE)
    {
        ZeroMemory( wszMethodName,         sizeof(wszMethodName) );
        ZeroMemory( wszMethodFriendlyName, sizeof(wszMethodFriendlyName) );
        ZeroMemory( wszMethodFunctionName, sizeof(wszMethodFunctionName) );
        ZeroMemory( wszMethodGuid,         sizeof(wszMethodGuid) );

        __try
        {
            bRetVal = pCallBack(hFaxHandle,
                                lpvContext,
                                wszMethodName,
                                wszMethodFriendlyName,
                                wszMethodFunctionName,
                                wszMethodGuid
                               );

            if (!bRetVal)
            {
                break;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            dwLastError = GetExceptionCode();
            DebugPrintEx(DEBUG_ERR, _T("pCallBack caused exception. ec=%ld"), dwLastError);
            goto error_exit;
        }

        //
        //  Check that Method Name is existing
        //
        if (wcslen(wszMethodName) < 1)
        {
            DebugPrintEx(DEBUG_ERR, _T("Callback returned empty MethodName"));
            dwLastError = ERROR_INVALID_PARAMETER;
            goto error_exit;
        }

        //
        //  Check that new Guid is valid GUID
        //
        if ( ERROR_SUCCESS != (dwRet = IsValidGUID(wszMethodGuid)) )
        {
            DebugPrintEx(DEBUG_ERR,
                _T("IsValidGUID failed: %s, ec=%d"),
                wszMethodGuid,
                dwRet);
            dwLastError = dwRet;
            goto error_exit;
        }


        //
        //  Check that new Guid is unique between all already registered Routing Methods
        //
        for ( i = 0 ; i < dwRegisteredMethods ; i++ )
        {
            if ( _tcsicmp(pRoutingInfo[i].Guid, wszMethodGuid) == 0 )
            {
                //
                //  Such Guid already registered
                //
                DebugPrintEx(DEBUG_ERR, _T("Duplicated Guid : %s."), wszMethodGuid);
                dwLastError = ERROR_DS_OBJ_GUID_EXISTS;
                goto error_exit;
            }
        }

        //
        //  Check that new Guid is unique between newly added Routing Methods
        //
        if ( plptstrNewGuids )
        {
            //
            //  There is ( dwMethods - dwRegisteredMethods ) new Methods
            //
            for( i = 0 ; i < (dwMethods - dwRegisteredMethods) ; i++ )
            {
                if ( _tcsicmp(plptstrNewGuids[i], wszMethodGuid) == 0 )
                {
                    //
                    //  Such Guid already registered
                    //
                    DebugPrintEx(DEBUG_ERR, _T("Duplicated Guid : %s."), wszMethodGuid);
                    dwLastError = ERROR_DS_OBJ_GUID_EXISTS;
                    goto error_exit;
                }
            }
        }

        //
        // We're using the dwMethods as priority for new methods
        //
        dwMethods++;
        if (!AddMethodKey(hKey,
                          wszMethodName,
                          wszMethodFriendlyName,
                          wszMethodFunctionName,
                          wszMethodGuid,
                          dwMethods))
        {
            dwLastError = GetLastError();
            DebugPrintEx(DEBUG_ERR, _T("AddMethodKey failed. ec=%ld"), dwLastError);
            goto error_exit;
        }

        //
        //  We succeded to add a method. Store its Guid to compare with next Methods
        //
        lptstrGuid = (LPTSTR)MemAlloc( ( _tcslen(wszMethodGuid) + 1 ) * sizeof(TCHAR));
        if (!lptstrGuid)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(DEBUG_ERR, _T("MemAlloc failed"));
            goto error_exit;
        }

        _tcscpy(lptstrGuid, wszMethodGuid);

        //
        //  ReAllocate Memory for extended pNewGuids
        //
        if (plptstrNewGuids)
        {
            pTmp = (LPTSTR *)MemReAlloc(plptstrNewGuids,
                (sizeof(LPTSTR)) * (dwMethods - dwRegisteredMethods));
        }
        else
        {
            pTmp = (LPTSTR *)MemAlloc((sizeof(LPTSTR)) * (dwMethods - dwRegisteredMethods));
        }
        if (!pTmp)
        {
            dwLastError = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(DEBUG_ERR, _T("MemReAlloc failed"));
            goto error_exit;
        }

        plptstrNewGuids = pTmp;

        //
        //  Put also last added Method's Guid
        //
        plptstrNewGuids[ (dwMethods - dwRegisteredMethods - 1) ] = lptstrGuid;
    }

    dwRet = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        dwLastError = dwRet;
        DebugPrintEx(DEBUG_ERR, _T("RegCloseKey failed. ec=%ld"), dwRet);
    }

    goto FreeRoutingInfo;

error_exit:

    if (hKey)
    {
        dwRet = RegCloseKey (hKey);
        if (ERROR_SUCCESS != dwRet)
        {
            DebugPrintEx(DEBUG_ERR, _T("RegCloseKey failed. ec=%ld"), dwRet);
        }
    }

    //
    // Delete the subkey on failure
    //
    wsprintf(szKeyName, L"%s\\%s", REGKEY_SOFTWARE, REGKEY_ROUTING_EXTENSIONS);
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, szKeyName, FALSE, 0);
    if (hKey)
    {
        //
        //  Delete the Extension Routing Key and all its Subkeys
        //
        dwRet = DeleteRegistryKey(hKey, lpcwstrExtensionName );
        if (ERROR_SUCCESS != dwRet)
        {
            DebugPrintEx(DEBUG_ERR,
                _T("DeleteRegistryKey (%s) failed. ec=%ld"),
                lpcwstrExtensionName,
                dwRet);
        }
        dwRet = RegCloseKey (hKey);
        if (ERROR_SUCCESS != dwRet)
        {
            DebugPrintEx(DEBUG_ERR, _T("RegCloseKey failed. ec=%ld"), dwRet);
        }
    }

    bResult = FALSE;

FreeRoutingInfo:

    FaxFreeBuffer(pRoutingInfo);

    if (plptstrNewGuids)
    {
        for ( i = 0 ; i < ( dwMethods - dwRegisteredMethods ) ; i++ )
        {
            MemFree(plptstrNewGuids[i]);
        }

        MemFree(plptstrNewGuids);
    }

    if (ERROR_SUCCESS != dwLastError)
    {
        SetLastError(dwLastError);
    }
    return bResult;

}   // FaxRegisterRoutingExtensionW


BOOL AddMethodKey(
    HKEY hKey,
    LPCWSTR lpcwstrMethodName,
    LPCWSTR lpcwstrFriendlyName,
    LPCWSTR lpcwstrFunctionName,
    LPCWSTR lpcwstrGuid,
    DWORD   dwPriority
    )
{
    HKEY hKeyNew;
    DWORD dwRet;
    DEBUG_FUNCTION_NAME(TEXT("AddMethodKey"));

    hKeyNew = OpenRegistryKey(hKey,
                              lpcwstrMethodName,
                              TRUE,
                              0);
    if (!hKeyNew)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("OpenRegistryKey(%s) failed. ec=%ld"),
                     lpcwstrMethodName,
                     GetLastError ());
        return FALSE;
    }
    //
    // Add values
    //
    if (!(SetRegistryString(hKeyNew, REGVAL_FRIENDLY_NAME, lpcwstrFriendlyName) &&
          SetRegistryString(hKeyNew, REGVAL_FUNCTION_NAME, lpcwstrFunctionName) &&
          SetRegistryString(hKeyNew, REGVAL_GUID, lpcwstrGuid) &&
          SetRegistryDword (hKeyNew, REGVAL_ROUTING_PRIORITY, dwPriority)
         ))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("SetRegistry failed. ec=%ld"),
                     GetLastError ());
        goto error_exit;
    }

    dwRet = RegCloseKey (hKeyNew);
    if (ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("RegCloseKey failed. ec=%ld"),
                     dwRet);
    }
    return TRUE;

error_exit:
    dwRet = RegCloseKey (hKeyNew);
    if (ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("RegCloseKey failed. ec=%ld"),
                     dwRet);
    }
    dwRet = RegDeleteKey (hKey, lpcwstrMethodName);
    if (ERROR_SUCCESS != dwRet)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("RegDeleteKey (%s) failed. ec=%ld"),
                     lpcwstrMethodName,
                     dwRet);
    }
    return FALSE;
}   // AddMethodKey

#else

WINFAXAPI
BOOL
WINAPI
FaxRegisterRoutingExtensionW(
    IN HANDLE  FaxHandle,
    IN LPCWSTR ExtensionName,
    IN LPCWSTR FriendlyName,
    IN LPCWSTR ImageName,
    IN PFAX_ROUTING_INSTALLATION_CALLBACKW CallBack,
    IN LPVOID Context
    )
{
    UNREFERENCED_PARAMETER (FaxHandle);
    UNREFERENCED_PARAMETER (ExtensionName);
    UNREFERENCED_PARAMETER (FriendlyName);
    UNREFERENCED_PARAMETER (ImageName);
    UNREFERENCED_PARAMETER (CallBack);
    UNREFERENCED_PARAMETER (Context);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}


#endif // #ifdef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionA(
    IN HANDLE         hFaxHandle,
    IN LPCSTR         lpctstrExtensionName
)
/*++

Routine name : FaxUnregisterRoutingExtensionA

Routine description:

    Unregisters a routing extension - ANSI version

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle           [in] - Handle to fax server
    lpctstrExtensionName [in] - Extension unique name

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD dwRes;
    BOOL bRes;
    LPCWSTR lpcwstrExtensionName = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxUnregisterRoutingExtensionA"));

    if (lpctstrExtensionName)
    {
        if (NULL ==
            (lpcwstrExtensionName = AnsiStringToUnicodeString(lpctstrExtensionName))
        )
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to convert Extension unique name to UNICODE (ec = %ld)"),
                dwRes);
            return dwRes;
        }
    }
    bRes = FaxUnregisterRoutingExtensionW (hFaxHandle, lpcwstrExtensionName);
    MemFree((PVOID)lpcwstrExtensionName);
    return bRes;
}   // FaxUnregisterRoutingExtensionA


WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionW(
    IN HANDLE          hFaxHandle,
    IN LPCWSTR         lpctstrExtensionName
)
/*++

Routine name : FaxUnregisterRoutingExtensionW

Routine description:

    Unregisters a routing extension - UNICODE version

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle           [in] - Handle to fax server
    lpctstrExtensionName [in] - Extension unique name

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxUnregisterRoutingExtensionW"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError (ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
        return FALSE;
    }
    if (!lpctstrExtensionName)
    {
        SetLastError (ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpctstrExtensionName is NULL."));
        return FALSE;
    }

    __try
    {
        ec = FAX_UnregisterRoutingExtension(
                    FH_FAX_HANDLE(hFaxHandle),
                    lpctstrExtensionName);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_UnregisterRoutingExtension. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError (ec);
        return FALSE;
    }

    return TRUE;
}   // FaxUnregisterRoutingExtensionW


#ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxUnregisterRoutingExtensionX(
    IN HANDLE          hFaxHandle,
    IN LPCWSTR         lpctstrExtensionName
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (lpctstrExtensionName);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxUnregisterRoutingExtensionX

#endif // #ifndef UNICODE


//********************************************
//*            FSP registration
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExA(
    IN HANDLE         hFaxHandle,
    IN LPCSTR         lpctstrGUID,
    IN LPCSTR         lpctstrFriendlyName,
    IN LPCSTR         lpctstrImageName,
    IN LPCSTR         lpctstrTspName,
    IN DWORD          dwFSPIVersion,
    IN DWORD          dwCapabilities
)
/*++

Routine name : FaxRegisterServiceProviderExA

Routine description:

    Registers an FSP - ANSI version

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server
    lpctstrGUID         [in] - GUID of FSP
    lpctstrFriendlyName [in] - Friendly name of FSP
    lpctstrImageName    [in] - Image name of FSP. May contain environment variables
    lpctstrTspName      [in] - TSP name of FSP.
    dwFSPIVersion       [in] - FSP's API version.
    dwCapabilities      [in] - FSP's extended capabilities.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD   dwRes = ERROR_SUCCESS;
    LPCWSTR lpcwstrGUID = NULL;
    LPCWSTR lpcwstrFriendlyName = NULL;
    LPCWSTR lpcwstrImageName = NULL;
    LPCWSTR lpcwstrTspName = NULL;
    BOOL bRes = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("FaxRegisterServiceProviderExA"));

    if (lpctstrGUID)
    {
        if (NULL ==
            (lpcwstrGUID = AnsiStringToUnicodeString(lpctstrGUID))
        )
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to convert GUID to UNICODE (ec = %ld)"),
                dwRes);
            goto exit;
        }
    }
    if (lpctstrFriendlyName)
    {
        if (NULL ==
            (lpcwstrFriendlyName = AnsiStringToUnicodeString(lpctstrFriendlyName))
        )
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to convert Friendly Name to UNICODE (ec = %ld)"),
                dwRes);
            goto exit;
        }
    }
    if (lpctstrImageName)
    {
        if (NULL ==
            (lpcwstrImageName = AnsiStringToUnicodeString(lpctstrImageName))
        )
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to convert Image Name to UNICODE (ec = %ld)"),
                dwRes);
            goto exit;
        }
    }
    if (lpctstrTspName)
    {
        if (NULL ==
            (lpcwstrTspName = AnsiStringToUnicodeString(lpctstrTspName))
        )
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to convert TSP name to UNICODE (ec = %ld)"),
                dwRes);
            goto exit;
        }
    }

    Assert (ERROR_SUCCESS == dwRes);

    bRes = FaxRegisterServiceProviderExW (
        hFaxHandle,
        lpcwstrGUID,
        lpcwstrFriendlyName,
        lpcwstrImageName,
        lpcwstrTspName,
        dwFSPIVersion,
        dwCapabilities);

exit:
    MemFree((PVOID)lpcwstrGUID);
    MemFree((PVOID)lpcwstrFriendlyName);
    MemFree((PVOID)lpcwstrImageName);
    MemFree((PVOID)lpcwstrTspName);

    return bRes;
}   // FaxRegisterServiceProviderExA

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExW(
    IN HANDLE          hFaxHandle,
    IN LPCWSTR         lpctstrGUID,
    IN LPCWSTR         lpctstrFriendlyName,
    IN LPCWSTR         lpctstrImageName,
    IN LPCWSTR         lpctstrTspName,
    IN DWORD           dwFSPIVersion,
    IN DWORD           dwCapabilities
)
/*++

Routine name : FaxRegisterServiceProviderExW

Routine description:

    Registers an FSP - UNICODE version

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server
    lpctstrGUID         [in] - GUID of FSP
    lpctstrFriendlyName [in] - Friendly name of FSP
    lpctstrImageName    [in] - Image name of FSP. May contain environment variables
    lpctstrTspName      [in] - TSP name of FSP.
    dwFSPIVersion       [in] - FSP's API version.
    dwCapabilities      [in] - FSP's extended capabilities.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxRegisterServiceProviderExW"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError (ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
        return FALSE;
    }

    //
    // Verify version field range
    //
    if (FSPI_API_VERSION_1 != dwFSPIVersion ||
        dwCapabilities)

    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("dwFSPIVersion invalid (0x%08x), or not valid capability (0x%08x)"),
            dwFSPIVersion,
            dwCapabilities);
        return ERROR_INVALID_PARAMETER;
    }

    ec = IsValidGUID (lpctstrGUID);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid GUID (ec: %ld)"),
            ec);
        SetLastError (ec);
        return FALSE;
    }

    __try
    {
        ec = FAX_RegisterServiceProviderEx(
                    FH_FAX_HANDLE(hFaxHandle),
                    lpctstrGUID,
                    lpctstrFriendlyName,
                    lpctstrImageName,
                    lpctstrTspName ? lpctstrTspName : L"",
                    dwFSPIVersion,
                    dwCapabilities);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_RegisterServiceProviderEx. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError (ec);
        return FALSE;
    }
    else if (IsLocalFaxConnection(hFaxHandle))
    {
        //
        // Adding a local FSP.
        // If we don't have a fax printer installed, this is the time to install one.
        //
        AddOrVerifyLocalFaxPrinter();
    }        
    return TRUE;
}   // FaxRegisterServiceProviderExW

#ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRegisterServiceProviderExX(
    IN HANDLE          hFaxHandle,
    IN LPCWSTR         lpctstrGUID,
    IN LPCWSTR         lpctstrFriendlyName,
    IN LPCWSTR         lpctstrImageName,
    IN LPCWSTR         lpctstrTspName,
    IN DWORD           dwFSPIVersion,
    IN DWORD           dwCapabilities
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (lpctstrGUID);
    UNREFERENCED_PARAMETER (lpctstrFriendlyName);
    UNREFERENCED_PARAMETER (lpctstrImageName);
    UNREFERENCED_PARAMETER (lpctstrTspName);
    UNREFERENCED_PARAMETER (dwFSPIVersion);
    UNREFERENCED_PARAMETER (dwCapabilities);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxRegisterServiceProviderExX

#endif // #ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExA(
    IN HANDLE         hFaxHandle,
    IN LPCSTR         lpctstrGUID
)
/*++

Routine name : FaxUnregisterServiceProviderExA

Routine description:

    Unregisters an FSP - ANSI version

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server
    lpctstrGUID         [in] - GUID of FSP
                                (or provider name for legacy FSPs registered
                                 through FaxRegisterServiceProvider)

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD dwRes;
    LPCWSTR lpcwstrGUID = NULL;
    BOOL bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxUnregisterServiceProviderExA"));

    if (lpctstrGUID)
    {
        if (NULL ==
            (lpcwstrGUID = AnsiStringToUnicodeString(lpctstrGUID))
        )
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to convert GUID to UNICODE (ec = %ld)"),
                dwRes);
            return dwRes;
        }
    }
    bRes = FaxUnregisterServiceProviderExW (hFaxHandle, lpcwstrGUID);
    MemFree((PVOID)lpcwstrGUID);
    return bRes;
}   // FaxUnregisterServiceProviderExA


WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExW(
    IN HANDLE          hFaxHandle,
    IN LPCWSTR         lpctstrGUID
)
/*++

Routine name : FaxUnregisterServiceProviderExW

Routine description:

    Unregisters an FSP - UNICODE version

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server
    lpctstrGUID         [in] - GUID of FSP
                                (or provider name for legacy FSPs registered
                                 through FaxRegisterServiceProvider)

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxUnregisterServiceProviderExW"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError (ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!lpctstrGUID)
    {
        SetLastError (ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("lpctstrGUID is NULL."));
        return FALSE;
    }

    __try
    {
        ec = FAX_UnregisterServiceProviderEx(
                    FH_FAX_HANDLE(hFaxHandle),
                    lpctstrGUID);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_UnregisterServiceProviderEx. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError (ec);
        return FALSE;
    }

    return TRUE;
}   // FaxUnregisterServiceProviderExW

#ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxUnregisterServiceProviderExX(
    IN HANDLE          hFaxHandle,
    IN LPCWSTR         lpctstrGUID
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (lpctstrGUID);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxUnregisterServiceProviderExX

#endif // #ifndef UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\sender.h ===
#ifndef __SENDER_H_
#define __SENDER_H_


#include <windows.h>
#include <fxsapip.h>
#include <faxsendw.h>

HRESULT	WINAPI
FaxFreeSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

HRESULT	WINAPI
FaxSetSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

HRESULT	WINAPI
FaxGetSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\job.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the job
    specific WINFAX API functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:
     4-Oct-1999 Danl Fix GetFaxPrinterName to retrieve the proper printer.
                     Fix CreateFinalTiffFile to work with GetFaxPrinterName

    28-Oct-1999 Danl Fix GetFaxPrinterName to return proper name for a client
                     installed on a serer machine.
--*/

#include "faxapi.h"
#include "faxreg.h"
#pragma hdrstop

#include <mbstring.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>


#define InchesToCM(_x)                      (((_x) * 254L + 50) / 100)
#define CMToInches(_x)                      (((_x) * 100L + 127) / 254)

#define LEFT_MARGIN                         1  // ---|
#define RIGHT_MARGIN                        1  //    |
#define TOP_MARGIN                          1  //    |---> in inches
#define BOTTOM_MARGIN                       1  // ---|


static BOOL CopyJobParamEx(PFAX_JOB_PARAM_EX lpDst,LPCFAX_JOB_PARAM_EX lpcSrc);
static void FreeJobParamEx(PFAX_JOB_PARAM_EX lpJobParamEx,BOOL bDestroy);

static BOOL
FaxGetPersonalProfileInfoW (
    IN  HANDLE                          hFaxHandle,
    IN  DWORDLONG                       dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER         Folder,
    IN  FAX_ENUM_PERSONAL_PROF_TYPES    ProfType,
    OUT PFAX_PERSONAL_PROFILEW          *lppPersonalProfile
);

static BOOL
FaxGetPersonalProfileInfoA (
    IN  HANDLE                          hFaxHandle,
    IN  DWORDLONG                       dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER         Folder,
    IN  FAX_ENUM_PERSONAL_PROF_TYPES    ProfType,
    OUT PFAX_PERSONAL_PROFILEA          *lppPersonalProfile
);

static
BOOL
CopyFileToServerQueueA (
    const HANDLE IN  hFaxHandle,
    const HANDLE IN  hLocalFile,
    LPCSTR       IN  lpcstrLocalFileExt,
    LPSTR        OUT lpstrServerFileName,   // Name + extension of file created on the server
    DWORD        IN  cchServerFileName
);

static
BOOL
CopyFileToServerQueueW (
    const HANDLE IN  hFaxHandle,
    const HANDLE IN  hLocaFile,
    LPCWSTR      IN  lpcwstrLocalFileExt,
    LPWSTR       OUT lpwstrServerFileName,    // Name + extension of file created on the server
    DWORD        IN  cchServerFileName
);

#ifdef UNICODE
    #define CopyFileToServerQueue CopyFileToServerQueueW
#else
    #define CopyFileToServerQueue CopyFileToServerQueueA
#endif // #ifdef UNICODE


DWORD WINAPI FAX_SendDocumentEx_A
(
    IN  handle_t                    hBinding,
    IN  LPCSTR                      lpcstrFileName,
    IN  LPCFAX_COVERPAGE_INFO_EXA   lpcCoverPageInfo,
    IN  LPCFAX_PERSONAL_PROFILEA    lpcSenderProfile,
    IN  DWORD                       dwNumRecipients,
    IN  LPCFAX_PERSONAL_PROFILEA    lpcRecipientList,
    IN  LPCFAX_JOB_PARAM_EXA        lpcJobParams,
    OUT LPDWORD                     lpdwJobId,
    OUT PDWORDLONG                  lpdwlMessageId,
    OUT PDWORDLONG                  lpdwlRecipientMessageIds
);


BOOL WINAPI FaxSendDocumentEx2A
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXA       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEA        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXA            lpJobParams,
        OUT     LPDWORD                         lpdwJobId,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
BOOL WINAPI FaxSendDocumentEx2W
(
        IN      HANDLE                          hFaxHandle,
        IN      LPCWSTR                        lpctstrFileName,
        IN      LPCFAX_COVERPAGE_INFO_EXW       lpcCoverPageInfo,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcSenderProfile,
        IN      DWORD                           dwNumRecipients,
        IN      LPCFAX_PERSONAL_PROFILEW        lpcRecipientList,
        IN      LPCFAX_JOB_PARAM_EXW            lpJobParams,
        OUT     LPDWORD                         lpdwJobId,
        OUT     PDWORDLONG                      lpdwlMessageId,
        OUT     PDWORDLONG                      lpdwlRecipientMessageIds
);
#ifdef UNICODE
#define FaxSendDocumentEx2  FaxSendDocumentEx2W
#else
#define FaxSendDocumentEx2  FaxSendDocumentEx2A
#endif // !UNICODE

BOOL WINAPI FaxSendDocumentExW
(
    IN  HANDLE hFaxHandle,
    IN  LPCWSTR lpctstrFileName,
    IN  LPCFAX_COVERPAGE_INFO_EXW lpcCoverPageInfo,
    IN  LPCFAX_PERSONAL_PROFILEW  lpcSenderProfile,
    IN  DWORD dwNumRecipients,
    IN  LPCFAX_PERSONAL_PROFILEW    lpcRecipientList,
    IN  LPCFAX_JOB_PARAM_EXW lpcJobParams,
    OUT PDWORDLONG lpdwlMessageId,
    OUT PDWORDLONG lpdwlRecipientMessageIds
)
{
    return FaxSendDocumentEx2W (hFaxHandle,
                                lpctstrFileName,
                                lpcCoverPageInfo,
                                lpcSenderProfile,
                                dwNumRecipients,
                                lpcRecipientList,
                                lpcJobParams,
                                NULL,
                                lpdwlMessageId,
                                lpdwlRecipientMessageIds
                               );
}

BOOL WINAPI FaxSendDocumentExA
(
    IN  HANDLE hFaxHandle,
    IN  LPCSTR lpctstrFileName,
    IN  LPCFAX_COVERPAGE_INFO_EXA lpcCoverPageInfo,
    IN  LPCFAX_PERSONAL_PROFILEA  lpcSenderProfile,
    IN  DWORD dwNumRecipients,
    IN  LPCFAX_PERSONAL_PROFILEA    lpcRecipientList,
    IN  LPCFAX_JOB_PARAM_EXA lpcJobParams,
    OUT PDWORDLONG lpdwlMessageId,
    OUT PDWORDLONG lpdwlRecipientMessageIds
)
{
    return FaxSendDocumentEx2A (hFaxHandle,
                                lpctstrFileName,
                                lpcCoverPageInfo,
                                lpcSenderProfile,
                                dwNumRecipients,
                                lpcRecipientList,
                                lpcJobParams,
                                NULL,
                                lpdwlMessageId,
                                lpdwlRecipientMessageIds
                               );
}



/*
 -  GetServerNameFromPrinterInfo
 -
 *  Purpose:
 *      Get the Server name, given a PRINTER_INFO_2 structure
 *
 *  Arguments:
 *      [in] ppi2 - Address of PRINTER_INFO_2 structure
 *      [out] lpptszServerName - Address of string pointer for returned name.
 *
 *  Returns:
 *      BOOL - TRUE: sucess , FALSE: failure.
 *
 *  Remarks:
 *      This inline function retrieves the server from a printer info structure
 *      in the appropriate way for win9x and NT.
 */
_inline BOOL
GetServerNameFromPrinterInfo(PPRINTER_INFO_2 ppi2,LPTSTR *lpptszServerName)
{
    if (!ppi2)
    {
        return FALSE;
    }
#ifndef WIN95
    *lpptszServerName = NULL;
    if (ppi2->pServerName)
    {
        if (!(*lpptszServerName = StringDup(ppi2->pServerName + 2)))
        {
            return FALSE;
        }
    }
    return TRUE;
#else //WIN95

    if (!(ppi2->pPortName))
    {
        return FALSE;
    }
    if (!(*lpptszServerName = StringDup(ppi2->pPortName + 2)))
    {
        return FALSE;
    }
    //
    // Formatted: \\Server\port
    //
    _tcstok(*lpptszServerName,TEXT("\\"));

#endif //WIN95

    return TRUE;
}

BOOL
LocalSystemTimeToSystemTime(
    const SYSTEMTIME * LocalSystemTime,
    LPSYSTEMTIME SystemTime
    )
{
    FILETIME LocalFileTime;
    FILETIME UtcFileTime;
    DEBUG_FUNCTION_NAME(TEXT("LocalSystemTimeToSystemTime"));

    if (!SystemTimeToFileTime( LocalSystemTime, &LocalFileTime )) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SystemTimeToFileTime failed. (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    if (!LocalFileTimeToFileTime( &LocalFileTime, &UtcFileTime )) {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("LocalFileTimeToFileTime failed. (ec: %ld)"),
                GetLastError());
        return FALSE;
    }

    if (!FileTimeToSystemTime( &UtcFileTime, SystemTime )) {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("FileTimeToSystemTime failed. (ec: %ld)"),
                GetLastError());
        return FALSE;
    }
    return TRUE;
}


/*
 -  GetFaxPrinterName
 -
 *  Purpose:
 *      Get The Name of a printer associated with the fax handle.
 *
 *  Arguments:
 *      [in] hFax - handle to a fax server (obtained via FaxConnectFaxServer).
 *                  If this parameter is NULL the name of the local fax printer
 *                  is retrieved
 *
 *  Returns:
 *      LPTSTR - name of fax server associated with the fax handle. NULL on
 *               failure
 *
 *  Remarks:
 *      This function utilized GetFaxServerName macro which extracts the server
 *      name out of its handle.
 */
#define GetFaxServerName(hFax) FH_DATA(hFax)->MachineName
LPTSTR
GetFaxPrinterName(
    HANDLE hFax
    )
{
    PPRINTER_INFO_2 ppi2;
    DWORD   dwi,dwCount;
    LPTSTR  lptszServerName = NULL,
            lptszFaxServerName = NULL,
            lptszFaxPrinterName = NULL;
    //
    // Get a list of all printers
    //
    ppi2 = (PPRINTER_INFO_2) MyEnumPrinters( NULL, 2, &dwCount, 0 );
    if (ppi2 != NULL)
    {
        //
        // If a non NULL handle is given get the server name associated with it.
        //
        if (hFax != NULL)
        {
            lptszFaxServerName = GetFaxServerName(hFax);
            if (lptszFaxServerName != NULL)
            {
#ifndef WIN95
                TCHAR   tszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
                DWORD   cbCompName = ARR_SIZE(tszComputerName);
                if (GetComputerName(tszComputerName,&cbCompName))
                {
                    //
                    // Check to see if the Fax Server is local.
                    //
                    if(_tcsicmp(tszComputerName,lptszFaxServerName) == 0)
                    {
                        lptszFaxServerName = NULL;
                    }
                }
                else
                {
                    //
                    // Last error has bee set by GetComputerName
                    //
                    return NULL;
                }
#endif //WIN95
            }
        }
        for (dwi=0; dwi< dwCount; dwi++)
        {
            //
            // Check to see if this one is a fax printer.
            //
            if (_tcscmp(ppi2[dwi].pDriverName, FAX_DRIVER_NAME ) == 0)
            {
                if (!GetServerNameFromPrinterInfo(&ppi2[dwi],&lptszServerName))
                {
                    //
                    // Note: the above function allocates storage for lptszServerName
                    //
                    continue;
                }
                //
                // Check to see if the printer's server is the one associated with
                // the handle we have.
                //
                if ((lptszFaxServerName == lptszServerName) ||
                    ((lptszFaxServerName && lptszServerName) &&
                     _tcsicmp( lptszFaxServerName, lptszServerName) == 0))
                {
                    //
                    // We have found our printer.
                    //
                    lptszFaxPrinterName = (LPTSTR) StringDup( ppi2[dwi].pPrinterName );
                    MemFree(lptszServerName);
                    break;
                }
                MemFree(lptszServerName);
            }
        }
        MemFree( ppi2 );
    }

    //
    //  Set Last Error if we failed to find a Printer
    //
    if (!lptszFaxPrinterName)
    {
        SetLastError(ERROR_OBJECT_NOT_FOUND);
    }

    return lptszFaxPrinterName;
}


BOOL
CreateFinalTiffFile(
    IN  LPTSTR FileName,
    OUT LPTSTR FinalTiffFile,
    IN  DWORD  cchFinalTiffFile,
    IN  HANDLE hFax
    )
/*++

Routine name : CreateFinalTiffFile

Routine description:

    Creates a valid TIFF file for transmission from an arbitrary attachmnet file.

Author:

    Eran Yariv (EranY), Feb, 2002

Arguments:

    FileName         [in]    The file name of the arbitrary attachmnet file.
    FinalTiffFile    [out]   A buffer which will hold, upon success, the name of the valid result TIFF file
    cchFinalTiffFile [in]    The size, in TCHARs, of FinalTiffFile
    hFax             [in]    The connection handle to the fax server

Return Value:

    TRUE on success.
    FALSE on failure (sets last error)

--*/
{
    TCHAR TempPath[MAX_PATH];
    TCHAR FullPath[MAX_PATH];
    TCHAR TempFile[MAX_PATH];
    TCHAR TiffFile[MAX_PATH];
    LPTSTR FaxPrinter = NULL;
    FAX_PRINT_INFO PrintInfo;
    DWORD TmpFaxJobId;
    FAX_CONTEXT_INFO ContextInfo;
    LPTSTR p;
    DWORD Flags = 0;
    BOOL Rslt;
    DWORD ec = ERROR_SUCCESS; // LastError for this function.
    DWORD dwFileSize = 0;
    HRESULT hr;
    DEBUG_FUNCTION_NAME(TEXT("CreateFinalTiffFile"));

    //
    // make sure that the tiff file passed in is a valid tiff file
    //

    if (!GetTempPath( sizeof(TempPath)/sizeof(TCHAR), TempPath )) 
    {
        ec=GetLastError();
        goto Error;
    }

    if (GetTempFileName( TempPath, _T("fax"), 0, TempFile ) == 0 )
    {
        ec=GetLastError();
        goto Error;
    }   
        
    
    DWORD nNeededSize = GetFullPathName( TempFile, sizeof(FullPath)/sizeof(TCHAR), FullPath, &p );
    if ( nNeededSize == 0   || 
         nNeededSize > sizeof(FullPath)/sizeof(TCHAR) )
    {
        //
        //  GetTempFileName created 0 byte file, so we need to delete it before exit
        //
        DeleteFile( TempPath );
        
        if (nNeededSize == 0)
        {
            ec=GetLastError();
        }
        else
        {
            ec=ERROR_BUFFER_OVERFLOW;
        }
        
        goto Error;
    }

    if (!ConvertTiffFileToValidFaxFormat( FileName, FullPath, &Flags )) 
    {
        if ((Flags & TIFFCF_NOT_TIFF_FILE) == 0) 
        {
            Flags = TIFFCF_NOT_TIFF_FILE;
        }
    }

    if (Flags & TIFFCF_NOT_TIFF_FILE)
    {
        //
        // try to output the source file into a tiff file,
        // by printing to the fax printer in "file" mode
        //
        HANDLE hFile = INVALID_HANDLE_VALUE;

        FaxPrinter = GetFaxPrinterName(hFax);
        if (FaxPrinter == NULL) 
        {
            ec=GetLastError();
            DeleteFile( FullPath );
            goto Error;
        }

        if (!PrintRandomDocument( FaxPrinter, FileName, FullPath ))
        {
            ec=GetLastError();
            DeleteFile( FullPath );
            goto Error;
        }

        //
        //  Try to open file
        //      to check its size
        //
        hFile = SafeCreateFile(
                                FullPath, 
                                GENERIC_READ, 
                                FILE_SHARE_READ, 
                                NULL, 
                                OPEN_EXISTING, 
                                FILE_ATTRIBUTE_NORMAL, 
                                NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            ec = GetLastError();
            DeleteFile( FullPath );
            DebugPrintEx(DEBUG_ERR, _T("Opening %s for read failed (ec: %ld)"), FullPath, ec);
            goto Error;
        }

        //
        //  Get the File Size
        //
        dwFileSize = GetFileSize(hFile, NULL);

        //
        //  Close the File Handle
        //
        CloseHandle (hFile);

        //
        //  Check the result of the GetFileSize()
        //
        if (INVALID_FILE_SIZE == dwFileSize)
        {
            ec = GetLastError();
            DeleteFile( FullPath );
            DebugPrintEx(DEBUG_ERR, _T("GetFileSize failed (ec: %ld)"), ec);
            goto Error;
        }

        if (!dwFileSize)
        {
            //
            // Zero-sized file passed to us
            //
            ec = ERROR_INVALID_DATA;
            DeleteFile( FullPath );
            goto Error;
        }

        _tcscpy( TiffFile, FullPath );

    }
    else if (Flags & TIFFCF_UNCOMPRESSED_BITS)
    {
        if (FaxPrinter == NULL)
        {
            FaxPrinter = GetFaxPrinterName(hFax);
            if (FaxPrinter == NULL)
            {
                ec=GetLastError();
                DeleteFile( FullPath );
                goto Error;
            }
        }

        if (Flags & TIFFCF_ORIGINAL_FILE_GOOD) 
        {
            //
            // nothing at fullpath, just delete it and use the original source
            //
            DeleteFile( FullPath );
            _tcscpy( TiffFile, FileName );
        } 
        else 
        {
            _tcscpy( TiffFile, FullPath );
        }

        if (GetTempFileName( TempPath, _T("fax"), 0, TempFile ) == 0 ||
            GetFullPathName( TempFile, sizeof(FullPath)/sizeof(TCHAR), FullPath, &p ) == 0)
        {
            ec=GetLastError();
            DeleteFile( TiffFile );
            goto Error;
        }

        ZeroMemory( &PrintInfo, sizeof(FAX_PRINT_INFO) );

        PrintInfo.SizeOfStruct = sizeof(FAX_PRINT_INFO);
        PrintInfo.OutputFileName = FullPath;

        ZeroMemory( &ContextInfo, sizeof(FAX_CONTEXT_INFO) );
        ContextInfo.SizeOfStruct = sizeof(FAX_CONTEXT_INFO);

        if (!FaxStartPrintJob( FaxPrinter, &PrintInfo, &TmpFaxJobId, &ContextInfo )) 
        {
            ec=GetLastError();
            if ((Flags & TIFFCF_ORIGINAL_FILE_GOOD) == 0) DeleteFile( TiffFile );
            DeleteFile( FullPath );
            goto Error;
        }

        Rslt = PrintTiffFile( ContextInfo.hDC, TiffFile );  // This will call EndDoc
        if (!Rslt)
        {
            ec = GetLastError();
            Assert (ec);
        }

        if ((Flags & TIFFCF_ORIGINAL_FILE_GOOD) == 0) 
        {
            DeleteFile( TiffFile );
        }

        if (!DeleteDC (ContextInfo.hDC))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteDC failed. (ec: %ld)"),
                GetLastError());
        }

        if (!Rslt)
        {
            DeleteFile( FullPath );
            goto Error;
        }

        _tcscpy( TiffFile, FullPath );

    } 
    else if (Flags & TIFFCF_ORIGINAL_FILE_GOOD) 
    {
        //
        // we didn't create anything at FullPath, just use FileName
        //
        DeleteFile( FullPath );
        _tcscpy( TiffFile, FileName );
    } 
    else 
    {
        //
        // should never hit this case
        //
        Assert(FALSE);
        ec=ERROR_INVALID_DATA;
        DeleteFile( FullPath );
        goto Error;
    }
    hr = StringCchCopy (FinalTiffFile, cchFinalTiffFile, TiffFile);
    if (FAILED(hr))
    {
        ASSERT_FALSE;
        ec = HRESULT_CODE(hr);
        goto Error;
    }

Error:
    MemFree (FaxPrinter);
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
        return FALSE;
    }
    return TRUE;
}   // CreateFinalTiffFile

static
BOOL
CopyFileToServerQueueA (
    const HANDLE IN  hFaxHandle,
    const HANDLE IN  hLocalFile,
    LPCSTR       IN  lpcstrLocalFileExt,
    LPSTR        OUT lpstrServerFileName,   // Name + extension of file created on the server
    DWORD        IN  cchServerFileName
)
/*++

Routine name : CopyFileToServerQueueA

Routine description:

    Creates a new file in the server's queue and copies another file to it.

    ANSI version

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in ] - Fax Server Handle
    hLocalFile          [in ] - Open handle of local file (source)
                                The file should be open for read and the file pointer should
                                be located at the beginning of the file.
    lpcstrLocalFileExt  [in ] - Extension of generated queue file
    lpstrServerFileName [out] - Name of queue file created.
                                This is a preallocated buffer that should be big enough
                                to contain MAX_PATH characters.
    cchServerFileName   [in ] - The size, in chars, of lpstrServerFileName

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    LPCWSTR lpcwstrLocalFileExt = NULL;
    WCHAR   wszServerFileName[MAX_PATH];

    DEBUG_FUNCTION_NAME(TEXT("CopyFileToServerQueueA"));

    //
    // Convert input parameter from ANSI to UNICODE
    //
    lpcwstrLocalFileExt = AnsiStringToUnicodeString(lpcstrLocalFileExt); // Allocates Memory !!!
    if (!lpcwstrLocalFileExt)
    {
        ec = GetLastError();
        goto exit;
    }
    if (!CopyFileToServerQueueW (hFaxHandle,
                                 hLocalFile,
                                 lpcwstrLocalFileExt,
                                 wszServerFileName,
                                 ARR_SIZE(wszServerFileName)))
    {
        ec = GetLastError();
        goto exit;
    }
    //
    // Convert output parameter from UNICODE to ANSI
    //
    if (!WideCharToMultiByte (
        CP_ACP,
        0,
        wszServerFileName,
        -1,
        lpstrServerFileName,
        cchServerFileName,
        NULL,
        NULL
        ))
    {
        ec = GetLastError();
        goto exit;
    }
    Assert (ERROR_SUCCESS == ec);

exit:
    //
    // Free temp strings
    //
    MemFree ((LPVOID)lpcwstrLocalFileExt);
    if (ERROR_SUCCESS != ec)
    {
        SetLastError (ec);
        return FALSE;
    }
    return TRUE;
}   // CopyFileToServerQueueA


static
BOOL
CopyFileToServerQueueW (
    const HANDLE IN  hFaxHandle,
    const HANDLE IN  hLocaFile,
    LPCWSTR      IN  lpcwstrLocalFileExt,
    LPWSTR       OUT lpwstrServerFileName,    // Name + extension of file created on the server
    DWORD        IN  cchServerFileName
)
/*++

Routine name : CopyFileToServerQueueW

Routine description:

    Creates a new file in the server's queue and copies another file to it.

    UNICODE version

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle           [in ] - Fax Server Handle
    hLocalFile           [in ] - Open handle of local file (source).
                                 The file should be open for read and the file pointer should
                                 be located at the beginning of the file.
    lpcwstrLocalFileExt  [in ] - Extension of generated queue file
    lpwstrServerFileName [out] - Name of queue file created
                                 This is a preallocated buffer that should be big enough
                                 to contain MAX_PATH characters.
    cchServerFileName    [in ] - The size, in WCHARs, of lpwstrServerFileName

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD  ec = ERROR_SUCCESS;
    HANDLE hCopyContext = NULL;
    PBYTE  aBuffer = NULL ;
    DEBUG_FUNCTION_NAME(TEXT("CopyFileToServerQueueW"));

    Assert (INVALID_HANDLE_VALUE != hLocaFile && lpcwstrLocalFileExt && lpwstrServerFileName);

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError (ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() failed."));
        return FALSE;
    }

    aBuffer = (PBYTE)MemAlloc(RPC_COPY_BUFFER_SIZE);
    if (NULL == aBuffer)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate memory for read/write buffer."));
        goto exit;
    }

    //
    //  We must fill lpwstrServerFileName with MAX_PATH-1 long string
    //  so that the server side FAX_StartCopyToServer will get MAX_PATH buffer as out parameter
    //
    for ( DWORD i=0 ; i<cchServerFileName ; ++i)
    {
        lpwstrServerFileName[i]=L'A';
    }
    lpwstrServerFileName[cchServerFileName-1] = L'\0';

    //
    // Acquire copy context handle
    //
    __try
    {
        ec = FAX_StartCopyToServer (
                FH_FAX_HANDLE(hFaxHandle),
                lpcwstrLocalFileExt,
                lpwstrServerFileName,
                &hCopyContext);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_StartCopyToServer. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        DebugPrintEx(DEBUG_ERR, _T("FAX_StartCopyToServer failed (ec: %ld)"), ec);
        goto exit;
    }

    //
    // Start copy iteration(s)
    //
    for (;;)
    {
        DWORD dwBytesRead;

        if (!ReadFile (hLocaFile,
                       aBuffer,
                       sizeof (BYTE) * RPC_COPY_BUFFER_SIZE,
                       &dwBytesRead,
                       NULL))
        {
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ReadFile failed (ec: %ld)"),
                ec);
            goto exit;
        }
        if (0 == dwBytesRead)
        {
            //
            // EOF situation
            //
            break;
        }
        //
        // Move bytes to server via RPC
        //
        __try
        {
            ec = FAX_WriteFile (
                    hCopyContext,
                    aBuffer,
                    dwBytesRead);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // For some reason we got an exception.
            //
            ec = GetExceptionCode();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Exception on RPC call to FAX_WriteFile. (ec: %ld)"),
                ec);
        }
        if (ERROR_SUCCESS != ec)
        {
            DumpRPCExtendedStatus ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_WriteFile failed (ec: %ld)"),
                ec);
            goto exit;
        }
    }   // End of copy iteration

    Assert (ERROR_SUCCESS == ec);

exit:
    if (NULL != hCopyContext)
    {
        DWORD ec2 = ERROR_SUCCESS;
        //
        // Close RPC copy context
        //
        __try
        {
            ec2 = FAX_EndCopy (&hCopyContext);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // For some reason we got an exception.
            //
            ec2 = GetExceptionCode();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Exception on RPC call to FAX_EndCopy. (ec: %ld)"),
                ec2);
        }
        if (ERROR_SUCCESS != ec2)
        {
            DumpRPCExtendedStatus ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_EndCopy failed (ec: %ld)"),
                ec2);
        }
        if (!ec)
        {
            ec = ec2;
        }
    }

    if (NULL != aBuffer)
    {
        MemFree(aBuffer);
    }
    
    if (ERROR_SUCCESS != ec)
    {
        SetLastError (ec);
        return FALSE;
    }
    return TRUE;
}   // CopyFileToServerQueueW


void
FreePersonalProfileStrings(
    PFAX_PERSONAL_PROFILE pProfile
    )
{
    MemFree(pProfile->lptstrName);
    MemFree(pProfile->lptstrFaxNumber);
    MemFree(pProfile->lptstrCompany);
    MemFree(pProfile->lptstrStreetAddress);
    MemFree(pProfile->lptstrCity);
    MemFree(pProfile->lptstrState);
    MemFree(pProfile->lptstrZip);
    MemFree(pProfile->lptstrCountry);
    MemFree(pProfile->lptstrTitle);
    MemFree(pProfile->lptstrDepartment);
    MemFree(pProfile->lptstrOfficeLocation);
    MemFree(pProfile->lptstrHomePhone);
    MemFree(pProfile->lptstrOfficePhone);
    MemFree(pProfile->lptstrEmail);
    MemFree(pProfile->lptstrBillingCode);
    MemFree(pProfile->lptstrTSID);
}

BOOL
WINAPI
FaxSendDocument(
    IN HANDLE FaxHandle,
    IN LPCTSTR FileName,
    IN FAX_JOB_PARAM *lpcJobParams,
    IN const FAX_COVERPAGE_INFO *lpcCoverPageInfo,
    OUT LPDWORD FaxJobId
    )
{
    FAX_JOB_PARAM_EX JobParamsEx;
    FAX_PERSONAL_PROFILE Sender;
    FAX_PERSONAL_PROFILE Recipient;
    FAX_COVERPAGE_INFO_EX CoverPageEx;
    LPCFAX_COVERPAGE_INFO_EX lpcNewCoverPageInfo;
    BOOL bRes;
    DWORDLONG dwParentId;
    DWORDLONG dwRecipientId;
    DWORD FaxJobIdLocal;

    DEBUG_FUNCTION_NAME(_T("FaxSendDocument"));

    if (!FaxJobId || !lpcJobParams || !FaxJobId)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("FaxJobId or lpcJobParams or FaxJobId is NULL"));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (sizeof (FAX_JOB_PARAM) != lpcJobParams->SizeOfStruct)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("lpcJobParams->SizeOfStruct is %d, expecting %d"),
                     lpcJobParams->SizeOfStruct,
                     sizeof (FAX_JOB_PARAM));
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (lpcCoverPageInfo && (sizeof (FAX_COVERPAGE_INFO) != lpcCoverPageInfo->SizeOfStruct))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("lpcCoverPageInfo->SizeOfStruct is %d, expecting %d"),
                     lpcCoverPageInfo->SizeOfStruct,
                     sizeof (FAX_COVERPAGE_INFO));
        SetLastError (ERROR_INVALID_DATA);
        return FALSE;
    }
    //
    // Copy the legacy job parameters to the new structures used to add
    // parent and recipient job.
    //
    memset(&JobParamsEx,0,sizeof(FAX_JOB_PARAM_EX));
    JobParamsEx.dwSizeOfStruct =sizeof(FAX_JOB_PARAM_EX);
    JobParamsEx.dwScheduleAction=lpcJobParams->ScheduleAction;
    JobParamsEx.tmSchedule=lpcJobParams->ScheduleTime;
    JobParamsEx.dwReceiptDeliveryType=lpcJobParams->DeliveryReportType;
    JobParamsEx.lptstrReceiptDeliveryAddress=StringDup( lpcJobParams->DeliveryReportAddress);
    JobParamsEx.hCall=lpcJobParams->CallHandle;
    JobParamsEx.Priority = FAX_PRIORITY_TYPE_NORMAL;
    memcpy(JobParamsEx.dwReserved, lpcJobParams->Reserved, sizeof(lpcJobParams->Reserved));
    JobParamsEx.lptstrDocumentName=StringDup( lpcJobParams->DocumentName);

    memset(&Sender,0,sizeof(FAX_PERSONAL_PROFILE));
    Sender.dwSizeOfStruct =sizeof(FAX_PERSONAL_PROFILE);
    Sender.lptstrBillingCode=StringDup(lpcJobParams->BillingCode);
    Sender.lptstrCompany=StringDup( lpcJobParams->SenderCompany);
    Sender.lptstrDepartment=StringDup( lpcJobParams->SenderDept);
    Sender.lptstrName=StringDup( lpcJobParams->SenderName);
    Sender.lptstrTSID=StringDup( lpcJobParams->Tsid );

    memset(&CoverPageEx,0,sizeof(FAX_COVERPAGE_INFO_EX));
    if (lpcCoverPageInfo)
    {
        Sender.lptstrCity=StringDup( lpcCoverPageInfo->SdrAddress); // due to structures incompatibility Sender.lptstrCity will
                                                                    // contain the whole address

        if (NULL == Sender.lptstrName)
        {
            Sender.lptstrName=StringDup( lpcCoverPageInfo->SdrName);
        }

        if (NULL == Sender.lptstrCompany)
        {
            Sender.lptstrCompany=StringDup( lpcCoverPageInfo->SdrCompany);
        }

        if (NULL == Sender.lptstrDepartment)
        {
            Sender.lptstrDepartment=StringDup( lpcCoverPageInfo->SdrDepartment);
        }

        Sender.lptstrFaxNumber=StringDup( lpcCoverPageInfo->SdrFaxNumber);
        Sender.lptstrHomePhone=StringDup( lpcCoverPageInfo->SdrHomePhone);
        Sender.lptstrOfficeLocation=StringDup( lpcCoverPageInfo->SdrOfficeLocation);
        Sender.lptstrOfficePhone=StringDup( lpcCoverPageInfo->SdrOfficePhone);
        Sender.lptstrTitle=StringDup( lpcCoverPageInfo->SdrTitle);
        CoverPageEx.dwSizeOfStruct=sizeof(FAX_COVERPAGE_INFO_EX);
        CoverPageEx.dwCoverPageFormat=FAX_COVERPAGE_FMT_COV;
        CoverPageEx.lptstrCoverPageFileName=StringDup(lpcCoverPageInfo->CoverPageName);
        CoverPageEx.lptstrNote=StringDup(lpcCoverPageInfo->Note);
        CoverPageEx.lptstrSubject=StringDup(lpcCoverPageInfo->Subject);
        CoverPageEx.bServerBased=lpcCoverPageInfo->UseServerCoverPage;
        lpcNewCoverPageInfo =&CoverPageEx;
        JobParamsEx.dwPageCount = lpcCoverPageInfo->PageCount;
    }
    else
    {
        lpcNewCoverPageInfo = NULL;
    }

    memset(&Recipient,0,sizeof(FAX_PERSONAL_PROFILE));
    Recipient.dwSizeOfStruct =sizeof(FAX_PERSONAL_PROFILE);
    Recipient.lptstrName=StringDup( lpcJobParams->RecipientName);
    Recipient.lptstrFaxNumber=StringDup( lpcJobParams->RecipientNumber);
    if (lpcCoverPageInfo)
    {
        if (NULL == Recipient.lptstrName)
        {
            Recipient.lptstrName=StringDup( lpcCoverPageInfo->RecName);
        }

        if (NULL == Recipient.lptstrFaxNumber)
        {
            Recipient.lptstrFaxNumber=StringDup( lpcCoverPageInfo->RecFaxNumber);
        }

        Recipient.lptstrCountry=StringDup( lpcCoverPageInfo->RecCountry);
        Recipient.lptstrStreetAddress=StringDup( lpcCoverPageInfo->RecStreetAddress);
        Recipient.lptstrCompany=StringDup( lpcCoverPageInfo->RecCompany);
        Recipient.lptstrDepartment=StringDup( lpcCoverPageInfo->RecDepartment);
        Recipient.lptstrHomePhone=StringDup( lpcCoverPageInfo->RecHomePhone);
        Recipient.lptstrOfficeLocation=StringDup( lpcCoverPageInfo->RecOfficeLocation);
        Recipient.lptstrOfficePhone=StringDup( lpcCoverPageInfo->RecOfficePhone);
        Recipient.lptstrTitle=StringDup( lpcCoverPageInfo->RecTitle);
        Recipient.lptstrZip=StringDup( lpcCoverPageInfo->RecZip);
        Recipient.lptstrCity=StringDup( lpcCoverPageInfo->RecCity);
    }

    bRes=FaxSendDocumentEx2(
        FaxHandle,
        FileName,
        lpcNewCoverPageInfo,
        &Sender,
        1,
        &Recipient,
        &JobParamsEx,
        &FaxJobIdLocal,
        &dwParentId,
        &dwRecipientId);

    if(bRes && FaxJobId)
    {
        *FaxJobId = FaxJobIdLocal;
    }
    //
    // Free everything
    //
    MemFree(JobParamsEx.lptstrReceiptDeliveryAddress);
    MemFree(JobParamsEx.lptstrDocumentName);
    MemFree(CoverPageEx.lptstrCoverPageFileName);
    MemFree(CoverPageEx.lptstrNote);
    MemFree(CoverPageEx.lptstrSubject);
    FreePersonalProfileStrings(&Recipient);
    FreePersonalProfileStrings(&Sender);
    if (ERROR_NO_ASSOCIATION == GetLastError ())
    {
        //
        // We need to support W2K backwards compatability up to the exact error code in case of failure.
        //
        SetLastError (ERROR_INVALID_DATA);
    }
    return bRes;
}

#ifdef UNICODE
// We need to support an ANSI version that calls the Unicode version

BOOL
WINAPI
FaxSendDocumentA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    IN FAX_JOB_PARAMA *JobParamsA,
    IN const FAX_COVERPAGE_INFOA *CoverpageInfoA,
    OUT LPDWORD FaxJobId
    )

/*++

Routine Description:

    Sends a FAX document to the specified recipient.
    This is an asychronous operation.  Use FaxReportStatus
    to determine when the send is completed.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FileName        - File containing the TIFF-F FAX document.
    JobParams       - pointer to FAX_JOB_PARAM structure with transmission params
    CoverpageInfo   - optional pointer to FAX_COVERPAGE_INFO structure
    FaxJobId        - receives the Fax JobId for the job.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    LPWSTR FileNameW = NULL;
    FAX_JOB_PARAMW JobParamsW = {0};
    FAX_COVERPAGE_INFOW CoverpageInfoW = {0};

    DEBUG_FUNCTION_NAME(_T("FaxSendDocumentA"));

    if (!JobParamsA ||
        (sizeof (FAX_JOB_PARAMA) != JobParamsA->SizeOfStruct))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("JobParamsA is NULL or has bad size."));
        return FALSE;
    }

    if (CoverpageInfoA &&
        (sizeof (FAX_COVERPAGE_INFOA) != CoverpageInfoA->SizeOfStruct))
    {
        SetLastError(ERROR_INVALID_DATA);
        DebugPrintEx(DEBUG_ERR, _T("CoverpageInfoA has bad size."));
        return FALSE;
    }

    if (FileName)
    {
        FileNameW = AnsiStringToUnicodeString( FileName );
        if (FileNameW == NULL)
        {
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            ec = ERROR_OUTOFMEMORY;
            goto exit;
        }
    }


    CopyMemory(&JobParamsW, JobParamsA, sizeof(FAX_JOB_PARAMA));
    JobParamsW.SizeOfStruct = sizeof(FAX_JOB_PARAMW);
    JobParamsW.RecipientNumber = AnsiStringToUnicodeString(JobParamsA->RecipientNumber);
    if (!JobParamsW.RecipientNumber && JobParamsA->RecipientNumber)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    JobParamsW.RecipientName = AnsiStringToUnicodeString(JobParamsA->RecipientName);
    if (!JobParamsW.RecipientName && JobParamsA->RecipientName)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    JobParamsW.Tsid = AnsiStringToUnicodeString(JobParamsA->Tsid);
    if (!JobParamsW.Tsid && JobParamsA->Tsid)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    JobParamsW.SenderName = AnsiStringToUnicodeString(JobParamsA->SenderName);
    if (!JobParamsW.SenderName && JobParamsA->SenderName)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    JobParamsW.SenderCompany = AnsiStringToUnicodeString(JobParamsA->SenderCompany);
    if (!JobParamsW.SenderCompany && JobParamsA->SenderCompany)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    JobParamsW.SenderDept = AnsiStringToUnicodeString(JobParamsA->SenderDept);
    if (!JobParamsW.SenderDept && JobParamsA->SenderDept)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    JobParamsW.BillingCode = AnsiStringToUnicodeString(JobParamsA->BillingCode);
    if (!JobParamsW.BillingCode && JobParamsA->BillingCode)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    JobParamsW.DeliveryReportAddress = AnsiStringToUnicodeString(JobParamsA->DeliveryReportAddress);
    if (!JobParamsW.DeliveryReportAddress && JobParamsA->DeliveryReportAddress)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    JobParamsW.DocumentName = AnsiStringToUnicodeString(JobParamsA->DocumentName);
    if (!JobParamsW.DocumentName && JobParamsA->DocumentName)
    {
        ec = ERROR_OUTOFMEMORY;
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto exit;
    }

    if (CoverpageInfoA)
    {
        CoverpageInfoW.SizeOfStruct = sizeof(FAX_COVERPAGE_INFOW);
        CoverpageInfoW.UseServerCoverPage = CoverpageInfoA->UseServerCoverPage;
        CoverpageInfoW.PageCount = CoverpageInfoA->PageCount;
        CoverpageInfoW.TimeSent = CoverpageInfoA->TimeSent;
        CoverpageInfoW.CoverPageName = AnsiStringToUnicodeString( CoverpageInfoA->CoverPageName );
        if (!CoverpageInfoW.CoverPageName && CoverpageInfoA->CoverPageName)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecName = AnsiStringToUnicodeString( CoverpageInfoA->RecName );
        if (!CoverpageInfoW.RecName && CoverpageInfoA->RecName)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecFaxNumber = AnsiStringToUnicodeString( CoverpageInfoA->RecFaxNumber );
        if (!CoverpageInfoW.RecFaxNumber && CoverpageInfoA->RecFaxNumber)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecCompany = AnsiStringToUnicodeString( CoverpageInfoA->RecCompany );
        if (!CoverpageInfoW.RecCompany && CoverpageInfoA->RecCompany)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecStreetAddress = AnsiStringToUnicodeString( CoverpageInfoA->RecStreetAddress );
        if (!CoverpageInfoW.RecStreetAddress && CoverpageInfoA->RecStreetAddress)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecCity = AnsiStringToUnicodeString( CoverpageInfoA->RecCity );
        if (!CoverpageInfoW.RecCity && CoverpageInfoA->RecCity)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecState = AnsiStringToUnicodeString( CoverpageInfoA->RecState );
        if (!CoverpageInfoW.RecState && CoverpageInfoA->RecState)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecZip = AnsiStringToUnicodeString( CoverpageInfoA->RecZip );
        if (!CoverpageInfoW.RecZip && CoverpageInfoA->RecZip)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecCountry = AnsiStringToUnicodeString( CoverpageInfoA->RecCountry );
        if (!CoverpageInfoW.RecCountry && CoverpageInfoA->RecCountry)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecTitle = AnsiStringToUnicodeString( CoverpageInfoA->RecTitle );
        if (!CoverpageInfoW.RecTitle && CoverpageInfoA->RecTitle)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecDepartment = AnsiStringToUnicodeString( CoverpageInfoA->RecDepartment );
        if (!CoverpageInfoW.RecDepartment && CoverpageInfoA->RecDepartment)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecOfficeLocation = AnsiStringToUnicodeString( CoverpageInfoA->RecOfficeLocation );
        if (!CoverpageInfoW.RecOfficeLocation && CoverpageInfoA->RecOfficeLocation)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecHomePhone = AnsiStringToUnicodeString( CoverpageInfoA->RecHomePhone );
        if (!CoverpageInfoW.RecHomePhone && CoverpageInfoA->RecHomePhone)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.RecOfficePhone = AnsiStringToUnicodeString( CoverpageInfoA->RecOfficePhone );
        if (!CoverpageInfoW.RecOfficePhone && CoverpageInfoA->RecOfficePhone)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrName = AnsiStringToUnicodeString( CoverpageInfoA->SdrName );
        if (!CoverpageInfoW.SdrName && CoverpageInfoA->SdrName)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrFaxNumber = AnsiStringToUnicodeString( CoverpageInfoA->SdrFaxNumber );
        if (!CoverpageInfoW.SdrFaxNumber && CoverpageInfoA->SdrFaxNumber)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrCompany = AnsiStringToUnicodeString( CoverpageInfoA->SdrCompany );
        if (!CoverpageInfoW.SdrCompany && CoverpageInfoA->SdrCompany)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrAddress = AnsiStringToUnicodeString( CoverpageInfoA->SdrAddress );
        if (!CoverpageInfoW.SdrAddress && CoverpageInfoA->SdrAddress)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrTitle = AnsiStringToUnicodeString( CoverpageInfoA->SdrTitle );
        if (!CoverpageInfoW.SdrTitle && CoverpageInfoA->SdrTitle)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrDepartment = AnsiStringToUnicodeString( CoverpageInfoA->SdrDepartment );
        if (!CoverpageInfoW.SdrDepartment && CoverpageInfoA->SdrDepartment)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrOfficeLocation = AnsiStringToUnicodeString( CoverpageInfoA->SdrOfficeLocation );
        if (!CoverpageInfoW.SdrOfficeLocation && CoverpageInfoA->SdrOfficeLocation)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrHomePhone = AnsiStringToUnicodeString( CoverpageInfoA->SdrHomePhone );
        if (!CoverpageInfoW.SdrHomePhone && CoverpageInfoA->SdrHomePhone)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.SdrOfficePhone = AnsiStringToUnicodeString( CoverpageInfoA->SdrOfficePhone );
        if (!CoverpageInfoW.SdrOfficePhone && CoverpageInfoA->SdrOfficePhone)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.Note = AnsiStringToUnicodeString( CoverpageInfoA->Note );
        if (!CoverpageInfoW.Note && CoverpageInfoA->Note)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }

        CoverpageInfoW.Subject = AnsiStringToUnicodeString( CoverpageInfoA->Subject );
        if (!CoverpageInfoW.Subject && CoverpageInfoA->Subject)
        {
            ec = ERROR_OUTOFMEMORY;
            DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
            goto exit;
        }
    }


    if (FaxSendDocumentW( FaxHandle,
                          FileNameW,
                          &JobParamsW,
                          CoverpageInfoA ? &CoverpageInfoW : NULL,
                          FaxJobId )) {
        ec = 0;
    }
    else
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("FaxSendDocumentW() is failed. ec = %ld."), ec);
    }

exit:
    MemFree( (LPBYTE) FileNameW );
    MemFree( (LPBYTE) JobParamsW.RecipientNumber );
    MemFree( (LPBYTE) JobParamsW.RecipientName );
    MemFree( (LPBYTE) JobParamsW.Tsid );
    MemFree( (LPBYTE) JobParamsW.SenderName );
    MemFree( (LPBYTE) JobParamsW.SenderDept );
    MemFree( (LPBYTE) JobParamsW.SenderCompany );
    MemFree( (LPBYTE) JobParamsW.BillingCode );
    MemFree( (LPBYTE) JobParamsW.DeliveryReportAddress );
    MemFree( (LPBYTE) JobParamsW.DocumentName );
    if (CoverpageInfoA)
    {
        MemFree( (LPBYTE) CoverpageInfoW.CoverPageName );
        MemFree( (LPBYTE) CoverpageInfoW.RecName );
        MemFree( (LPBYTE) CoverpageInfoW.RecFaxNumber );
        MemFree( (LPBYTE) CoverpageInfoW.RecCompany );
        MemFree( (LPBYTE) CoverpageInfoW.RecStreetAddress );
        MemFree( (LPBYTE) CoverpageInfoW.RecCity );
        MemFree( (LPBYTE) CoverpageInfoW.RecState );
        MemFree( (LPBYTE) CoverpageInfoW.RecZip );
        MemFree( (LPBYTE) CoverpageInfoW.RecCountry );
        MemFree( (LPBYTE) CoverpageInfoW.RecTitle );
        MemFree( (LPBYTE) CoverpageInfoW.RecDepartment );
        MemFree( (LPBYTE) CoverpageInfoW.RecOfficeLocation );
        MemFree( (LPBYTE) CoverpageInfoW.RecHomePhone );
        MemFree( (LPBYTE) CoverpageInfoW.RecOfficePhone );
        MemFree( (LPBYTE) CoverpageInfoW.SdrName );
        MemFree( (LPBYTE) CoverpageInfoW.SdrFaxNumber );
        MemFree( (LPBYTE) CoverpageInfoW.SdrCompany );
        MemFree( (LPBYTE) CoverpageInfoW.SdrAddress );
        MemFree( (LPBYTE) CoverpageInfoW.SdrTitle );
        MemFree( (LPBYTE) CoverpageInfoW.SdrDepartment );
        MemFree( (LPBYTE) CoverpageInfoW.SdrOfficeLocation );
        MemFree( (LPBYTE) CoverpageInfoW.SdrHomePhone );
        MemFree( (LPBYTE) CoverpageInfoW.SdrOfficePhone );
        MemFree( (LPBYTE) CoverpageInfoW.Note );
        MemFree( (LPBYTE) CoverpageInfoW.Subject );
    }

    if (ec)
    {
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}
#else
// When compiling for ANSI (Win9X) we need only to suppot the ANSI version
BOOL
WINAPI
FaxSendDocumentW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    IN FAX_JOB_PARAMW *JobParams,
    IN const FAX_COVERPAGE_INFOW *CoverpageInfo,
    OUT LPDWORD FaxJobId
    )
{
    UNREFERENCED_PARAMETER(FaxHandle);
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(JobParams);
    UNREFERENCED_PARAMETER(CoverpageInfo);
    UNREFERENCED_PARAMETER(FaxJobId);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
CopyCallbackDataAnsiToNeutral(
    PFAX_JOB_PARAMA pJobParamsA,
    PFAX_COVERPAGE_INFOA pCoverPageA,
    PFAX_JOB_PARAM_EX pJobParamsEx,
    PFAX_COVERPAGE_INFO_EX pCoverPageEx,
    PFAX_PERSONAL_PROFILE pSender,
    PFAX_PERSONAL_PROFILE pRecipient
    )
{
    ZeroMemory(pJobParamsEx, sizeof(*pJobParamsEx));
    pJobParamsEx->dwSizeOfStruct = sizeof(*pJobParamsEx);
    pJobParamsEx->dwScheduleAction = pJobParamsA->ScheduleAction;
    pJobParamsEx->tmSchedule = pJobParamsA->ScheduleTime;
    pJobParamsEx->dwReceiptDeliveryType = pJobParamsA->DeliveryReportType;
    pJobParamsEx->Priority = FAX_PRIORITY_TYPE_NORMAL;
    pJobParamsEx->hCall = pJobParamsA->CallHandle;
    memcpy(pJobParamsEx->dwReserved, pJobParamsA->Reserved, sizeof(pJobParamsA->Reserved));

    if(pCoverPageA)
    {
        pJobParamsEx->dwPageCount = pCoverPageA->PageCount;
    }

    ZeroMemory(pCoverPageEx, sizeof(*pCoverPageEx));
    pCoverPageEx->dwSizeOfStruct = sizeof(*pCoverPageEx);
    pCoverPageEx->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;
    if(pCoverPageA)
    {
        pCoverPageEx->bServerBased = pCoverPageA->UseServerCoverPage;
    }

    ZeroMemory(pSender, sizeof(*pSender));
    pSender->dwSizeOfStruct = sizeof(*pSender);

    ZeroMemory(pRecipient, sizeof(*pRecipient));
    pRecipient->dwSizeOfStruct = sizeof(*pRecipient);


#ifdef UNICODE
    pJobParamsEx->lptstrReceiptDeliveryAddress = AnsiStringToUnicodeString(pJobParamsA->DeliveryReportAddress);
    pJobParamsEx->lptstrDocumentName =  AnsiStringToUnicodeString(pJobParamsA->DocumentName);

    pSender->lptstrName  = AnsiStringToUnicodeString(pJobParamsA->SenderName);
    pSender->lptstrCompany = AnsiStringToUnicodeString(pJobParamsA->SenderCompany);
    pSender->lptstrDepartment  = AnsiStringToUnicodeString(pJobParamsA->SenderDept);
    pSender->lptstrBillingCode = AnsiStringToUnicodeString(pJobParamsA->BillingCode);

    pRecipient->lptstrName = AnsiStringToUnicodeString(pJobParamsA->RecipientName);
    pRecipient->lptstrFaxNumber = AnsiStringToUnicodeString(pJobParamsA->RecipientNumber);
    pRecipient->lptstrTSID =  AnsiStringToUnicodeString(pJobParamsA->Tsid);

    if(pCoverPageA)
    {
        pCoverPageEx->lptstrCoverPageFileName = AnsiStringToUnicodeString(pCoverPageA->CoverPageName);
        pCoverPageEx->lptstrNote = AnsiStringToUnicodeString(pCoverPageA->Note);
        pCoverPageEx->lptstrSubject = AnsiStringToUnicodeString(pCoverPageA->Subject);

        pSender->lptstrCity=AnsiStringToUnicodeString(pCoverPageA->SdrAddress); // due to structures incopitabilty pSender.lptstrCity will
                                                                                // contain the whole address
        pSender->lptstrFaxNumber = AnsiStringToUnicodeString(pCoverPageA->SdrFaxNumber);
        pSender->lptstrStreetAddress = AnsiStringToUnicodeString(pCoverPageA->SdrAddress);
        pSender->lptstrTitle = AnsiStringToUnicodeString(pCoverPageA->SdrTitle);
        pSender->lptstrOfficeLocation = AnsiStringToUnicodeString(pCoverPageA->SdrOfficeLocation);
        pSender->lptstrHomePhone = AnsiStringToUnicodeString(pCoverPageA->SdrHomePhone);
        pSender->lptstrOfficePhone = AnsiStringToUnicodeString(pCoverPageA->SdrOfficePhone);

        pRecipient->lptstrCompany = AnsiStringToUnicodeString(pCoverPageA->RecCompany);
        pRecipient->lptstrStreetAddress = AnsiStringToUnicodeString(pCoverPageA->RecStreetAddress);
        pRecipient->lptstrCity = AnsiStringToUnicodeString(pCoverPageA->RecCity);
        pRecipient->lptstrState = AnsiStringToUnicodeString(pCoverPageA->RecState);
        pRecipient->lptstrZip = AnsiStringToUnicodeString(pCoverPageA->RecZip);
        pRecipient->lptstrCountry = AnsiStringToUnicodeString(pCoverPageA->RecCountry);
        pRecipient->lptstrTitle = AnsiStringToUnicodeString(pCoverPageA->RecTitle);
        pRecipient->lptstrDepartment = AnsiStringToUnicodeString(pCoverPageA->RecDepartment);
        pRecipient->lptstrOfficeLocation = AnsiStringToUnicodeString(pCoverPageA->RecOfficeLocation);
        pRecipient->lptstrHomePhone = AnsiStringToUnicodeString(pCoverPageA->RecHomePhone);
        pRecipient->lptstrOfficePhone = AnsiStringToUnicodeString(pCoverPageA->RecOfficePhone);
    }
#else
    pJobParamsEx->lptstrReceiptDeliveryAddress = StringDup(pJobParamsA->DeliveryReportAddress);
    pJobParamsEx->lptstrDocumentName =  StringDup(pJobParamsA->DocumentName);

    pSender->lptstrName  = StringDup(pJobParamsA->SenderName);
    pSender->lptstrCompany = StringDup(pJobParamsA->SenderCompany);
    pSender->lptstrDepartment  = StringDup(pJobParamsA->SenderDept);
    pSender->lptstrBillingCode = StringDup(pJobParamsA->BillingCode);

    pRecipient->lptstrName = StringDup(pJobParamsA->RecipientName);
    pRecipient->lptstrFaxNumber = StringDup(pJobParamsA->RecipientNumber);
    pRecipient->lptstrTSID =  StringDup(pJobParamsA->Tsid);

    if(pCoverPageA)
    {
        pCoverPageEx->lptstrCoverPageFileName = StringDup(pCoverPageA->CoverPageName);
        pCoverPageEx->lptstrNote = StringDup(pCoverPageA->Note);
        pCoverPageEx->lptstrSubject = StringDup(pCoverPageA->Subject);

        pSender->lptstrCity=StringDup(pCoverPageA->SdrAddress); // due to structures incopitabilty Sender.lptstrCity will
                                                                // contain the whole address
        pSender->lptstrFaxNumber = StringDup(pCoverPageA->SdrFaxNumber);
        pSender->lptstrStreetAddress = StringDup(pCoverPageA->SdrAddress);
        pSender->lptstrTitle = StringDup(pCoverPageA->SdrTitle);
        pSender->lptstrOfficeLocation = StringDup(pCoverPageA->SdrOfficeLocation);
        pSender->lptstrHomePhone = StringDup(pCoverPageA->SdrHomePhone);
        pSender->lptstrOfficePhone = StringDup(pCoverPageA->SdrOfficePhone);

        pRecipient->lptstrCompany = StringDup(pCoverPageA->RecCompany);
        pRecipient->lptstrStreetAddress = StringDup(pCoverPageA->RecStreetAddress);
        pRecipient->lptstrCity = StringDup(pCoverPageA->RecCity);
        pRecipient->lptstrState = StringDup(pCoverPageA->RecState);
        pRecipient->lptstrZip = StringDup(pCoverPageA->RecZip);
        pRecipient->lptstrCountry = StringDup(pCoverPageA->RecCountry);
        pRecipient->lptstrTitle = StringDup(pCoverPageA->RecTitle);
        pRecipient->lptstrDepartment = StringDup(pCoverPageA->RecDepartment);
        pRecipient->lptstrOfficeLocation = StringDup(pCoverPageA->RecOfficeLocation);
        pRecipient->lptstrHomePhone = StringDup(pCoverPageA->RecHomePhone);
        pRecipient->lptstrOfficePhone = StringDup(pCoverPageA->RecOfficePhone);
    }
#endif
    return TRUE;
}

BOOL
CopyCallbackDataWideToNeutral(
    PFAX_JOB_PARAMW pJobParamsW,
    PFAX_COVERPAGE_INFOW pCoverPageW,
    PFAX_JOB_PARAM_EX pJobParamsEx,
    PFAX_COVERPAGE_INFO_EX pCoverPageEx,
    PFAX_PERSONAL_PROFILE pSender,
    PFAX_PERSONAL_PROFILE pRecipient
    )
{
    ZeroMemory(pJobParamsEx, sizeof(*pJobParamsEx));
    pJobParamsEx->dwSizeOfStruct = sizeof(*pJobParamsEx);
    pJobParamsEx->dwScheduleAction = pJobParamsW->ScheduleAction;
    pJobParamsEx->tmSchedule = pJobParamsW->ScheduleTime;
    pJobParamsEx->dwReceiptDeliveryType = pJobParamsW->DeliveryReportType;
    pJobParamsEx->Priority = FAX_PRIORITY_TYPE_NORMAL;
    pJobParamsEx->hCall = pJobParamsW->CallHandle;
    memcpy(pJobParamsEx->dwReserved, pJobParamsW->Reserved, sizeof(pJobParamsW->Reserved));

    if(pCoverPageW)
    {
        pJobParamsEx->dwPageCount = pCoverPageW->PageCount;
    }

    ZeroMemory(pCoverPageEx, sizeof(*pCoverPageEx));
    pCoverPageEx->dwSizeOfStruct = sizeof(*pCoverPageEx);
    pCoverPageEx->dwCoverPageFormat = FAX_COVERPAGE_FMT_COV;
    if(pCoverPageW)
    {
        pCoverPageEx->bServerBased = pCoverPageW->UseServerCoverPage;
    }

    ZeroMemory(pSender, sizeof(*pSender));
    pSender->dwSizeOfStruct = sizeof(*pSender);

    ZeroMemory(pRecipient, sizeof(*pRecipient));
    pRecipient->dwSizeOfStruct = sizeof(*pRecipient);


#ifdef UNICODE
    pJobParamsEx->lptstrReceiptDeliveryAddress = StringDup(pJobParamsW->DeliveryReportAddress);
    pJobParamsEx->lptstrDocumentName =  StringDup(pJobParamsW->DocumentName);

    pSender->lptstrName  = StringDup(pJobParamsW->SenderName);
    pSender->lptstrCompany = StringDup(pJobParamsW->SenderCompany);
    pSender->lptstrDepartment  = StringDup(pJobParamsW->SenderDept);
    pSender->lptstrBillingCode = StringDup(pJobParamsW->BillingCode);

    pRecipient->lptstrName = StringDup(pJobParamsW->RecipientName);
    pRecipient->lptstrFaxNumber = StringDup(pJobParamsW->RecipientNumber);
    pRecipient->lptstrTSID =  StringDup(pJobParamsW->Tsid);

    if(pCoverPageW)
    {
        pCoverPageEx->lptstrCoverPageFileName = StringDup(pCoverPageW->CoverPageName);
        pCoverPageEx->lptstrNote = StringDup(pCoverPageW->Note);
        pCoverPageEx->lptstrSubject = StringDup(pCoverPageW->Subject);

        pSender->lptstrCity=StringDup(pCoverPageW->SdrAddress); // due to structures incompitabilty Sender.lptstrCity will
                                                                // contain the whole address
        pSender->lptstrFaxNumber = StringDup(pCoverPageW->SdrFaxNumber);
        pSender->lptstrStreetAddress = StringDup(pCoverPageW->SdrAddress);
        pSender->lptstrTitle = StringDup(pCoverPageW->SdrTitle);
        pSender->lptstrOfficeLocation = StringDup(pCoverPageW->SdrOfficeLocation);
        pSender->lptstrHomePhone = StringDup(pCoverPageW->SdrHomePhone);
        pSender->lptstrOfficePhone = StringDup(pCoverPageW->SdrOfficePhone);

        pRecipient->lptstrCompany = StringDup(pCoverPageW->RecCompany);
        pRecipient->lptstrStreetAddress = StringDup(pCoverPageW->RecStreetAddress);
        pRecipient->lptstrCity = StringDup(pCoverPageW->RecCity);
        pRecipient->lptstrState = StringDup(pCoverPageW->RecState);
        pRecipient->lptstrZip = StringDup(pCoverPageW->RecZip);
        pRecipient->lptstrCountry = StringDup(pCoverPageW->RecCountry);
        pRecipient->lptstrTitle = StringDup(pCoverPageW->RecTitle);
        pRecipient->lptstrDepartment = StringDup(pCoverPageW->RecDepartment);
        pRecipient->lptstrOfficeLocation = StringDup(pCoverPageW->RecOfficeLocation);
        pRecipient->lptstrHomePhone = StringDup(pCoverPageW->RecHomePhone);
        pRecipient->lptstrOfficePhone = StringDup(pCoverPageW->RecOfficePhone);
    }
#else
    pJobParamsEx->lptstrReceiptDeliveryAddress = UnicodeStringToAnsiString(pJobParamsW->DeliveryReportAddress);
    pJobParamsEx->lptstrDocumentName =  UnicodeStringToAnsiString(pJobParamsW->DocumentName);

    pSender->lptstrName  = UnicodeStringToAnsiString(pJobParamsW->SenderName);
    pSender->lptstrCompany = UnicodeStringToAnsiString(pJobParamsW->SenderCompany);
    pSender->lptstrDepartment  = UnicodeStringToAnsiString(pJobParamsW->SenderDept);
    pSender->lptstrBillingCode = UnicodeStringToAnsiString(pJobParamsW->BillingCode);

    pRecipient->lptstrName = UnicodeStringToAnsiString(pJobParamsW->RecipientName);
    pRecipient->lptstrFaxNumber = UnicodeStringToAnsiString(pJobParamsW->RecipientNumber);
    pRecipient->lptstrTSID =  UnicodeStringToAnsiString(pJobParamsW->Tsid);

    if(pCoverPageW)
    {
        pCoverPageEx->lptstrCoverPageFileName = UnicodeStringToAnsiString(pCoverPageW->CoverPageName);
        pCoverPageEx->lptstrNote = UnicodeStringToAnsiString(pCoverPageW->Note);
        pCoverPageEx->lptstrSubject = UnicodeStringToAnsiString(pCoverPageW->Subject);

        pSender->lptstrCity=UnicodeStringToAnsiString(pCoverPageW->SdrAddress);
        pSender->lptstrFaxNumber = UnicodeStringToAnsiString(pCoverPageW->SdrFaxNumber);
        pSender->lptstrStreetAddress = UnicodeStringToAnsiString(pCoverPageW->SdrAddress);
        pSender->lptstrTitle = UnicodeStringToAnsiString(pCoverPageW->SdrTitle);
        pSender->lptstrOfficeLocation = UnicodeStringToAnsiString(pCoverPageW->SdrOfficeLocation);
        pSender->lptstrHomePhone = UnicodeStringToAnsiString(pCoverPageW->SdrHomePhone);
        pSender->lptstrOfficePhone = UnicodeStringToAnsiString(pCoverPageW->SdrOfficePhone);

        pRecipient->lptstrCompany = UnicodeStringToAnsiString(pCoverPageW->RecCompany);
        pRecipient->lptstrStreetAddress = UnicodeStringToAnsiString(pCoverPageW->RecStreetAddress);
        pRecipient->lptstrCity = UnicodeStringToAnsiString(pCoverPageW->RecCity);
        pRecipient->lptstrState = UnicodeStringToAnsiString(pCoverPageW->RecState);
        pRecipient->lptstrZip = UnicodeStringToAnsiString(pCoverPageW->RecZip);
        pRecipient->lptstrCountry = UnicodeStringToAnsiString(pCoverPageW->RecCountry);
        pRecipient->lptstrTitle = UnicodeStringToAnsiString(pCoverPageW->RecTitle);
        pRecipient->lptstrDepartment = UnicodeStringToAnsiString(pCoverPageW->RecDepartment);
        pRecipient->lptstrOfficeLocation = UnicodeStringToAnsiString(pCoverPageW->RecOfficeLocation);
        pRecipient->lptstrHomePhone = UnicodeStringToAnsiString(pCoverPageW->RecHomePhone);
        pRecipient->lptstrOfficePhone = UnicodeStringToAnsiString(pCoverPageW->RecOfficePhone);
    }
#endif
    return TRUE;
}

BOOL
FaxSendDocumentForBroadcastInternal(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileNameW,
    OUT LPDWORD FaxJobId,
    BOOL AnsiCallback,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallbackW,
    IN LPVOID Context
)
{
    BOOL success = FALSE;
    LPSTR FileNameA = NULL;
    TCHAR ExistingFile[MAX_PATH];
    DWORD dwJobId;
    DWORDLONG dwlJobId;
    DWORDLONG dwlParentJobId = 0;
    LPTSTR FileName;
    FAX_JOB_PARAMA JobParamsA;
    FAX_COVERPAGE_INFOA CoverPageA;
    FAX_JOB_PARAMW JobParamsW;
    FAX_COVERPAGE_INFOW CoverPageW;
    FAX_JOB_PARAM_EX JobParamsEx;
    FAX_COVERPAGE_INFO_EX CoverPageEx;
    FAX_PERSONAL_PROFILE Sender;
    FAX_PERSONAL_PROFILE Recipient;
    DWORD rc;
    LPTSTR p;
    DWORD i;

    DEBUG_FUNCTION_NAME(TEXT("FaxSendDocumentForBroadcastInternal"));

    //
    // argument validation
    //
    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       goto Cleanup;
    }

    if(FileNameW == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("FileNameW is NULL."));
        goto Cleanup;
    }

    if(FaxRecipientCallbackW == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("FaxRecipientCallbackW is NULL."));
        goto Cleanup;
    }

    FileNameA = UnicodeStringToAnsiString(FileNameW);
    if(FileNameA == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DebugPrintEx(DEBUG_ERR, _T("UnicodeStringToAnsiString() is failed."));
        goto Cleanup;
    }

#ifdef UNICODE
    FileName = (LPTSTR)FileNameW;
#else
    FileName = FileNameA;
#endif

    // make sure the file is there
    rc = GetFullPathName(FileName, sizeof(ExistingFile) / sizeof(TCHAR), ExistingFile, &p);
    if(rc > MAX_PATH || rc == 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("GetFullPathName failed, ec= %d\n"),GetLastError());
        SetLastError( (rc > MAX_PATH)
                      ? ERROR_BUFFER_OVERFLOW
                      : GetLastError() );
        goto Cleanup;
    }

    if(GetFileAttributes(ExistingFile)==0xFFFFFFFF)
    {
        SetLastError(ERROR_FILE_NOT_FOUND);
        goto Cleanup;
    }

    for(i = 1;;i++) {
        //
        // prepare and execute callback
        //
        if(AnsiCallback)
        {
            ZeroMemory(&JobParamsA, sizeof(JobParamsA));
            JobParamsA.SizeOfStruct = sizeof(JobParamsA);
            ZeroMemory(&CoverPageA, sizeof(CoverPageA));
            CoverPageA.SizeOfStruct = sizeof(CoverPageA);

            if(!(*(PFAX_RECIPIENT_CALLBACKA)FaxRecipientCallbackW)(FaxHandle, i, Context, &JobParamsA, &CoverPageA))
            {
                break;
            }

            if(JobParamsA.RecipientNumber == NULL)
            {
                continue;
            }

            if(!CopyCallbackDataAnsiToNeutral(&JobParamsA, &CoverPageA, &JobParamsEx, &CoverPageEx, &Sender, &Recipient))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("CopyCallbackDataAnsiToNeutral() is failed, ec= %ld."),
                    GetLastError());
                goto Cleanup;
            }
        }
        else
        {
            ZeroMemory(&JobParamsW, sizeof(JobParamsW));
            JobParamsW.SizeOfStruct = sizeof(JobParamsW);
            ZeroMemory(&CoverPageW, sizeof(CoverPageW));
            CoverPageW.SizeOfStruct = sizeof(CoverPageW);

            if(!FaxRecipientCallbackW(FaxHandle, i, Context, &JobParamsW, &CoverPageW))
            {
                break;
            }

            if(JobParamsW.RecipientNumber == NULL)
            {
                continue;
            }

            if(!CopyCallbackDataWideToNeutral(&JobParamsW, &CoverPageW, &JobParamsEx, &CoverPageEx, &Sender, &Recipient))
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("CopyCallbackDataWideToNeutral() is failed, ec= %ld."),
                    GetLastError());
                goto Cleanup;
            }
        }

        if(!FaxSendDocumentEx2(FaxHandle,
                            ExistingFile,
							CoverPageEx.lptstrCoverPageFileName ? &CoverPageEx : NULL,
                            &Sender,
                            1,
                            &Recipient,
                            &JobParamsEx,
                            &dwJobId,
                            &dwlParentJobId,
                            &dwlJobId))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_SendDocumentEx failed with error code 0x%0x"),
                GetLastError());
            goto Cleanup;
        }

        //
        // give caller FIRST job parent's ID
        //
        if (i == 1 && FaxJobId)
        {
            *FaxJobId = (DWORD)dwlParentJobId;
        }

        MemFree(CoverPageEx.lptstrCoverPageFileName);
        MemFree(CoverPageEx.lptstrNote);
        MemFree(CoverPageEx.lptstrSubject);

        MemFree(JobParamsEx.lptstrReceiptDeliveryAddress);
        MemFree(JobParamsEx.lptstrDocumentName);

        FreePersonalProfileStrings(&Sender);
        FreePersonalProfileStrings(&Recipient);
    }

    success = TRUE;

Cleanup:
    MemFree(FileNameA);
    return success;
}


#ifdef UNICODE
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    )
{
    return FaxSendDocumentForBroadcastInternal(
        FaxHandle,
        FileName,
        FaxJobId,
        FALSE,
        FaxRecipientCallback,
        Context);
}

#else
// Not supported on Win9x
BOOL
WINAPI
FaxSendDocumentForBroadcastW(
    IN HANDLE FaxHandle,
    IN LPCWSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKW FaxRecipientCallback,
    IN LPVOID Context
    )
{
    UNREFERENCED_PARAMETER(FileName);
    UNREFERENCED_PARAMETER(FaxJobId);
    UNREFERENCED_PARAMETER(FaxRecipientCallback);
    UNREFERENCED_PARAMETER(Context);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif


BOOL
WINAPI
FaxSendDocumentForBroadcastA(
    IN HANDLE FaxHandle,
    IN LPCSTR FileName,
    OUT LPDWORD FaxJobId,
    IN PFAX_RECIPIENT_CALLBACKA FaxRecipientCallback,
    IN LPVOID Context
    )
{
    LPWSTR FileNameW = NULL;
    BOOL success = FALSE;

    DEBUG_FUNCTION_NAME(_T("FaxSendDocumentForBroadcastA"));

    if(FileName == NULL)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("FileName is NULL."));
        goto Cleanup;
    }

    FileNameW = AnsiStringToUnicodeString(FileName);
    if(FileNameW == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DebugPrintEx(DEBUG_ERR, _T("AnsiStringToUnicodeString() is failed."));
        goto Cleanup;
    }

    success = FaxSendDocumentForBroadcastInternal(
        FaxHandle,
        FileNameW,
        FaxJobId,
        TRUE,
        (PFAX_RECIPIENT_CALLBACKW)FaxRecipientCallback,
        Context);

Cleanup:
    MemFree(FileNameW);

    return success;
}




BOOL
WINAPI
FaxAbort(
    IN HANDLE FaxHandle,
    IN DWORD JobId
    )
/*++

Routine Description:

    Abort the specified FAX job.  All outstanding FAX
    operations are terminated.

Arguments:

    FaxHandle       - FAX Server handle obtained from FaxConnectFaxServer.
    JobId           - job id.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;

    //
    // argument validation
    //
    DEBUG_FUNCTION_NAME(TEXT("FaxAbort"));

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    __try
    {
        ec = FAX_Abort( (handle_t) FH_FAX_HANDLE(FaxHandle),(DWORD) JobId );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_Abort. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        DebugPrintEx(DEBUG_ERR, _T("FAX_Abort() is failed. (ec: %ld)"), ec);
        return FALSE;
    }

    return TRUE;
}



extern "C"
BOOL
WINAPI
FaxEnumJobsW(
   IN  HANDLE FaxHandle,
   OUT PFAX_JOB_ENTRYW *JobEntryBuffer,
   OUT LPDWORD JobsReturned
   )
{
    PFAX_JOB_ENTRYW JobEntry;
    error_status_t ec;
    DWORD BufferSize = 0;
    DWORD i;
    DWORD Size;

    DEBUG_FUNCTION_NAME(TEXT("FaxEnumJobsW"));

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!JobEntryBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("JobEntryBuffer is NULL."));
        return FALSE;
    }

    if (!JobsReturned) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("JobsReturned is NULL."));
        return FALSE;
    }

    *JobEntryBuffer = NULL;
    *JobsReturned = 0;
    Size = 0;

    __try
    {
        ec = FAX_EnumJobs( FH_FAX_HANDLE(FaxHandle), (LPBYTE*)JobEntryBuffer, &Size, JobsReturned );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumJobs. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        DebugPrintEx(DEBUG_ERR, _T("FAX_EnumJobs() is failed. ec = %ld."), ec);
        return FALSE;
    }

    JobEntry = (PFAX_JOB_ENTRYW) *JobEntryBuffer;

    for (i=0; i<*JobsReturned; i++) {
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].UserName );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].RecipientNumber );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].RecipientName );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].DocumentName );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].Tsid );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].SenderName );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].SenderCompany );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].SenderDept );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].BillingCode );
        FixupStringPtrW( JobEntryBuffer, JobEntry[i].DeliveryReportAddress );
    }

    return TRUE;
}


extern "C"
BOOL
WINAPI
FaxEnumJobsA(
   IN HANDLE FaxHandle,
   OUT PFAX_JOB_ENTRYA *JobEntryBuffer,
   OUT LPDWORD JobsReturned
   )
{
    PFAX_JOB_ENTRYW JobEntry;
    DWORD i;

    DEBUG_FUNCTION_NAME(TEXT("FaxEnumJobsA"));

    //
    //  no need to validate parameters, FaxEnumJobsW() will do that
    //

    if (!FaxEnumJobsW( FaxHandle, (PFAX_JOB_ENTRYW *)JobEntryBuffer, JobsReturned)) {
        DebugPrintEx(DEBUG_ERR, _T("FaxEnumJobsW() is failed."));
        return FALSE;
    }

    JobEntry = (PFAX_JOB_ENTRYW) *JobEntryBuffer;

    for (i=0; i<*JobsReturned; i++) 
    {
        if (!ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].UserName )              ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].RecipientNumber )       ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].RecipientName )         ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].DocumentName )          ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].Tsid )                  ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].SenderName )            ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].SenderCompany )         ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].SenderDept )            ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].BillingCode )           ||
            !ConvertUnicodeStringInPlace( (LPCWSTR) JobEntry[i].DeliveryReportAddress ))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*JobEntryBuffer);
            return FALSE;
        }
    }
    return TRUE;
}   // FaxEnumJobsA


BOOL
WINAPI
FaxSetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYW *JobEntry
   )

/*++

Routine Description:

    set job status information for a requested JobId
    Note that this is the fax server JobId, not a spooler job ID.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    JobId               - Fax service Job ID
    Command     - JC_* constant for controlling the job
    JobEntry            - pointer to Buffer holding the job information. This parameter is Unused

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    error_status_t ec;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetJobW"));

    //
    // Validate Parameters
    //
    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (Command > JC_RESTART  || Command == JC_UNKNOWN) {
       SetLastError (ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("Wrong Command."));
       return FALSE;
    }

    __try
    {
        ec = FAX_SetJob( FH_FAX_HANDLE(FaxHandle), JobId, Command );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetJob. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        DebugPrintEx(DEBUG_ERR, _T("FAX_SetJob() is failed. (ec: %ld)"), ec);
        return FALSE;
    }

    UNREFERENCED_PARAMETER(JobEntry);
    return TRUE;
}


BOOL
WINAPI
FaxSetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN DWORD Command,
   IN const FAX_JOB_ENTRYA *JobEntryA
   )
/*++

Routine Description:

    set job status information for a requested JobId
    Note that this is the fax server JobId, not a spooler job ID.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    JobId               - Fax service Job ID
    Command     - JC_* constant for controlling the job
    JobEntryA           - pointer to Buffer holding the job information. This parameter is Unused

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    error_status_t ec = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetJobA"));
    //
    //  No Need to Validate Parameters, because
    //  FaxSetJobW() will do that.
    //
    //  The JobEntry parameter is not used by FaxSetJobW, that's why we place a hard-coded NULL.
    //
    if (!FaxSetJobW( FaxHandle, JobId, Command, NULL))
    {
        DebugPrintEx(DEBUG_ERR, _T("FAxSetJobW() is failed. (ec: %ld)"), GetLastError());
        return FALSE;
    }
    UNREFERENCED_PARAMETER(JobEntryA);
    return TRUE;
}


extern "C"
BOOL
WINAPI
FaxGetJobW(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN PFAX_JOB_ENTRYW *JobEntryBuffer
   )
/*++

Routine Description:

    Returns job status information for a requested JobId
    Note that this is the fax server JobId, not a spooler job ID.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    JobId               - Fax service Job ID
    JobEntryBuffer      - Buffer to hold the job information

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    error_status_t ec = 0;
    PFAX_JOB_ENTRY JobEntry;
    DWORD JobEntrySize = 0;

    //
    // parameter validation
    //

    DEBUG_FUNCTION_NAME(TEXT("FaxGetJobW"));

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!JobEntryBuffer) {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("JobEntryBuffer is NULL."));
       return FALSE;
    }

    *JobEntryBuffer = NULL;

    __try
    {
        ec = FAX_GetJob( FH_FAX_HANDLE(FaxHandle), JobId, (unsigned char **) JobEntryBuffer , &JobEntrySize );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetJob. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        DebugPrintEx(DEBUG_ERR, _T("FAX_GetJob() failed. (ec: %ld)"), ec);
        return FALSE;
    }

    JobEntry = (PFAX_JOB_ENTRY) *JobEntryBuffer;

    FixupStringPtr (JobEntryBuffer, JobEntry->UserName);
    FixupStringPtr (JobEntryBuffer, JobEntry->RecipientNumber );
    FixupStringPtr (JobEntryBuffer, JobEntry->RecipientName );
    FixupStringPtr (JobEntryBuffer, JobEntry->Tsid );
    FixupStringPtr (JobEntryBuffer, JobEntry->SenderName );
    FixupStringPtr (JobEntryBuffer, JobEntry->SenderDept );
    FixupStringPtr (JobEntryBuffer, JobEntry->SenderCompany );
    FixupStringPtr (JobEntryBuffer, JobEntry->BillingCode );
    FixupStringPtr (JobEntryBuffer, JobEntry->DeliveryReportAddress );
    FixupStringPtr (JobEntryBuffer, JobEntry->DocumentName );
    return TRUE;
}


extern "C"
BOOL
WINAPI
FaxGetJobA(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   IN PFAX_JOB_ENTRYA *JobEntryBuffer
   )
/*++

Routine Description:

    Returns job status information for a requested JobId
    Note that this is the fax server JobId, not a spooler job ID.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    JobId               - Fax service Job ID
    JobEntryBuffer      - Buffer to hold the job information

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    PFAX_JOB_ENTRYW JobEntryW;
    DWORD JobEntrySize = 0;
    error_status_t ec = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetJobA"));

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!JobEntryBuffer) {
       SetLastError(ERROR_INVALID_PARAMETER);
       DebugPrintEx(DEBUG_ERR, _T("JobEntryBuffer is NULL."));
       return FALSE;
    }

    *JobEntryBuffer = NULL;

    __try
    {
       ec = FAX_GetJob( FH_FAX_HANDLE(FaxHandle), JobId, (unsigned char **) JobEntryBuffer,&JobEntrySize );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetJob. (ec: %ld)"),
            ec);
    }

    if (ec) 
    {
       DumpRPCExtendedStatus ();
       JobEntryBuffer = NULL;
       SetLastError(ec);
       return FALSE;
    }

    //
    // convert to Ansi
    //
    JobEntryW = (PFAX_JOB_ENTRYW) *JobEntryBuffer;
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->UserName);
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->RecipientNumber );
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->RecipientName );
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->Tsid );
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->SenderName );
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->SenderDept );
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->SenderCompany );
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->BillingCode );
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->DeliveryReportAddress );
    FixupStringPtrW (JobEntryBuffer, (LPCWSTR) JobEntryW->DocumentName );
    if (!ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->UserName)                 ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->RecipientNumber )         ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->RecipientName )           ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->Tsid )                    ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->SenderName )              ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->SenderDept )              ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->SenderCompany )           ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->BillingCode )             ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->DeliveryReportAddress )   ||
        !ConvertUnicodeStringInPlace( (LPCWSTR)JobEntryW->DocumentName ))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (JobEntryW);
        return FALSE;
    }
    (*JobEntryBuffer)->SizeOfStruct = sizeof(FAX_JOB_ENTRYA);
    return TRUE;
}   // FaxGetJobA


BOOL
WINAPI
FaxGetPageData(
   IN HANDLE FaxHandle,
   IN DWORD JobId,
   OUT LPBYTE *Buffer,
   OUT LPDWORD BufferSize,
   OUT LPDWORD ImageWidth,
   OUT LPDWORD ImageHeight
   )
{
    error_status_t ec;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetPageData"));

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!Buffer || !BufferSize || !ImageWidth || !ImageHeight) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some of the parameters is NULL."));
        return FALSE;
    }

    *Buffer = NULL;
    *BufferSize = 0;
    *ImageWidth = 0;
    *ImageHeight = 0;


    __try
    {
        ec = FAX_GetPageData( FH_FAX_HANDLE(FaxHandle), JobId, Buffer, BufferSize, ImageWidth, ImageHeight );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetPageData. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}

#ifdef UNICODE
BOOL WINAPI FaxSendDocumentEx2A
(
    IN  HANDLE                      hFaxHandle,
    IN  LPCSTR                      lpcstrFileName,
    IN  LPCFAX_COVERPAGE_INFO_EXA   lpcCoverPageInfo,
    IN  LPCFAX_PERSONAL_PROFILEA    lpcSenderProfile,
    IN  DWORD                       dwNumRecipients,
    IN  LPCFAX_PERSONAL_PROFILEA    lpcRecipientList,
    IN  LPCFAX_JOB_PARAM_EXA        lpcJobParams,
    OUT LPDWORD                     lpdwJobId,
    OUT PDWORDLONG                  lpdwlMessageId,
    OUT PDWORDLONG                  lpdwlRecipientMessageIds
)
{
    DWORD                       ec = ERROR_SUCCESS;
    LPWSTR                      lpwstrFileNameW = NULL;
    FAX_COVERPAGE_INFO_EXW      CoverpageInfoW ;
    FAX_PERSONAL_PROFILEW       SenderProfileW ;
    PFAX_PERSONAL_PROFILEW      lpRecipientListW = NULL;
    FAX_JOB_PARAM_EXW           JobParamsW ;
    DWORD                       dwIndex;

    DEBUG_FUNCTION_NAME(TEXT("FaxSendDocumentExA"));

    ZeroMemory( &CoverpageInfoW, sizeof(FAX_COVERPAGE_INFO_EXW) );
    ZeroMemory( &SenderProfileW, sizeof(FAX_PERSONAL_PROFILEW) );
    ZeroMemory( &JobParamsW,     sizeof(FAX_JOB_PARAM_EXW));

    //
    // argument validation
    //


    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE)) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid parameters: Fax handle 0x%08X is not valid."),
            hFaxHandle);
       ec=ERROR_INVALID_HANDLE;
       goto Error;
    }

    if (!lpdwlMessageId || !lpdwlRecipientMessageIds)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid output parameters: lpdwlMessageId = 0x%I64X, lpdwlRecipientMessageIds = 0x%I64x"),
            lpdwlMessageId,
            lpdwlRecipientMessageIds);
        ec = ERROR_INVALID_PARAMETER;
        goto Error;
    }

    if (lpcCoverPageInfo)
    {
        if (lpcCoverPageInfo->dwSizeOfStruct != sizeof(FAX_COVERPAGE_INFO_EXA)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: Size of CoverpageInfo (%d) != %ld."),
                lpcCoverPageInfo->dwSizeOfStruct,
                sizeof(FAX_COVERPAGE_INFO_EXA));
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }
    }

    if (lpcSenderProfile)
    {
        if (lpcSenderProfile->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILEA)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: Size of SenderProfile (%d) != %ld."),
                lpcSenderProfile->dwSizeOfStruct,
                sizeof(FAX_PERSONAL_PROFILEA));
            ec = ERROR_INVALID_PARAMETER;
            goto Error;
        }
    }

    if (!dwNumRecipients)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid parameters: dwNumRecipients is ZERO."));
        ec=ERROR_INVALID_PARAMETER;
        goto Error;
    }

    if (!lpcRecipientList)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid parameters: lpcRecipientList is NULL."));
        ec=ERROR_INVALID_PARAMETER;
        goto Error;
    }

    if (lpcJobParams)
    {
        if (lpcJobParams->dwSizeOfStruct != sizeof(FAX_JOB_PARAM_EXA)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: Size of JobParams (%d) != %ld."),
                lpcJobParams->dwSizeOfStruct,
                sizeof(FAX_JOB_PARAM_EXA));
            ec = ERROR_INVALID_PARAMETER;
            goto Error;
        }
    }

    for(dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
    {
        if (lpcRecipientList[dwIndex].dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILEA))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: Size of lpcRecipientList[%d] (%d) != %ld."),
                dwIndex,
                lpcRecipientList[dwIndex].dwSizeOfStruct,
                sizeof(FAX_PERSONAL_PROFILEA));
            ec = ERROR_INVALID_PARAMETER;
            goto Error;
        }
    }


    //
    // convert input parameters
    //

    if (lpcstrFileName)
    {
        if (!(lpwstrFileNameW = AnsiStringToUnicodeString(lpcstrFileName)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for file name"));
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
    }

    if (lpcCoverPageInfo)
    {
        CoverpageInfoW.dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EXW);

        CoverpageInfoW.dwCoverPageFormat    = lpcCoverPageInfo->dwCoverPageFormat;
        CoverpageInfoW.bServerBased         = lpcCoverPageInfo->bServerBased;
        if (!(CoverpageInfoW.lptstrCoverPageFileName = AnsiStringToUnicodeString ( lpcCoverPageInfo->lptstrCoverPageFileName)) && lpcCoverPageInfo->lptstrCoverPageFileName ||
            !(CoverpageInfoW.lptstrNote              = AnsiStringToUnicodeString ( lpcCoverPageInfo->lptstrNote             )) && lpcCoverPageInfo->lptstrNote   ||
            !(CoverpageInfoW.lptstrSubject           = AnsiStringToUnicodeString ( lpcCoverPageInfo->lptstrSubject          )) && lpcCoverPageInfo->lptstrSubject)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for Cover Page Info"));
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
    }

    if (lpcSenderProfile)
    {
        SenderProfileW.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILEW);

        if (!(SenderProfileW.lptstrName             =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrName )) && lpcSenderProfile->lptstrName ||
            !(SenderProfileW.lptstrFaxNumber        =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrFaxNumber )) && lpcSenderProfile->lptstrFaxNumber ||
            !(SenderProfileW.lptstrCompany          =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrCompany )) && lpcSenderProfile->lptstrCompany ||
            !(SenderProfileW.lptstrStreetAddress    =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrStreetAddress )) && lpcSenderProfile->lptstrStreetAddress ||
            !(SenderProfileW.lptstrCity             =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrCity )) && lpcSenderProfile->lptstrCity||
            !(SenderProfileW.lptstrState            =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrState )) && lpcSenderProfile->lptstrState||
            !(SenderProfileW.lptstrZip              =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrZip )) && lpcSenderProfile->lptstrZip||
            !(SenderProfileW.lptstrCountry          =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrCountry )) && lpcSenderProfile->lptstrCountry ||
            !(SenderProfileW.lptstrTitle            =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrTitle )) && lpcSenderProfile->lptstrTitle ||
            !(SenderProfileW.lptstrDepartment       =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrDepartment )) && lpcSenderProfile->lptstrDepartment ||
            !(SenderProfileW.lptstrOfficeLocation   =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrOfficeLocation )) && lpcSenderProfile->lptstrOfficeLocation ||
            !(SenderProfileW.lptstrHomePhone        =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrHomePhone )) && lpcSenderProfile->lptstrHomePhone ||
            !(SenderProfileW.lptstrOfficePhone      =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrOfficePhone )) && lpcSenderProfile->lptstrOfficePhone ||
            !(SenderProfileW.lptstrEmail            =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrEmail )) && lpcSenderProfile->lptstrEmail ||
            !(SenderProfileW.lptstrBillingCode      =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrBillingCode )) && lpcSenderProfile->lptstrBillingCode ||
            !(SenderProfileW.lptstrTSID             =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrTSID )) && lpcSenderProfile->lptstrTSID)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for Sender Profile"));
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

    }

    if (!(lpRecipientListW = (PFAX_PERSONAL_PROFILEW) MemAlloc(sizeof(FAX_PERSONAL_PROFILEW)*dwNumRecipients)))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate memory for recipient list"));
        ec=ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    for(dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
    {
        ZeroMemory( &lpRecipientListW[dwIndex], sizeof(FAX_PERSONAL_PROFILEW) );

        lpRecipientListW[dwIndex].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILEW);

        if (!(lpRecipientListW[dwIndex].lptstrName              = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrName )) && lpcRecipientList[dwIndex].lptstrName ||
            !(lpRecipientListW[dwIndex].lptstrFaxNumber         = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrFaxNumber )) && lpcRecipientList[dwIndex].lptstrFaxNumber ||
            !(lpRecipientListW[dwIndex].lptstrCompany           = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrCompany )) && lpcRecipientList[dwIndex].lptstrCompany ||
            !(lpRecipientListW[dwIndex].lptstrStreetAddress     = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrStreetAddress )) && lpcRecipientList[dwIndex].lptstrStreetAddress ||
            !(lpRecipientListW[dwIndex].lptstrCity              = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrCity )) && lpcRecipientList[dwIndex].lptstrCity ||
            !(lpRecipientListW[dwIndex].lptstrState             = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrState )) && lpcRecipientList[dwIndex].lptstrState ||
            !(lpRecipientListW[dwIndex].lptstrZip               = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrZip )) && lpcRecipientList[dwIndex].lptstrZip ||
            !(lpRecipientListW[dwIndex].lptstrCountry           = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrCountry )) && lpcRecipientList[dwIndex].lptstrCountry ||
            !(lpRecipientListW[dwIndex].lptstrTitle             = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrTitle )) && lpcRecipientList[dwIndex].lptstrTitle ||
            !(lpRecipientListW[dwIndex].lptstrDepartment        = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrDepartment )) && lpcRecipientList[dwIndex].lptstrDepartment ||
            !(lpRecipientListW[dwIndex].lptstrOfficeLocation    = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrOfficeLocation )) && lpcRecipientList[dwIndex].lptstrOfficeLocation ||
            !(lpRecipientListW[dwIndex].lptstrHomePhone         = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrHomePhone )) && lpcRecipientList[dwIndex].lptstrHomePhone ||
            !(lpRecipientListW[dwIndex].lptstrOfficePhone       = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrOfficePhone )) && lpcRecipientList[dwIndex].lptstrOfficePhone ||
            !(lpRecipientListW[dwIndex].lptstrEmail             = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrEmail )) && lpcRecipientList[dwIndex].lptstrEmail ||
            !(lpRecipientListW[dwIndex].lptstrBillingCode       = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrBillingCode )) && lpcRecipientList[dwIndex].lptstrBillingCode ||
            !(lpRecipientListW[dwIndex].lptstrTSID              = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrTSID )) && lpcRecipientList[dwIndex].lptstrTSID )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for recipient list"));
            ec=ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
    }

    if (lpcJobParams)
    {
        JobParamsW.dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EXW);

        JobParamsW.Priority                 = lpcJobParams->Priority;
        JobParamsW.dwScheduleAction         = lpcJobParams->dwScheduleAction;
        JobParamsW.tmSchedule               = lpcJobParams->tmSchedule;
        JobParamsW.dwReceiptDeliveryType    = lpcJobParams->dwReceiptDeliveryType;
        JobParamsW.hCall                    = lpcJobParams->hCall;
        JobParamsW.dwPageCount              = lpcJobParams->dwPageCount;
       
        memcpy(JobParamsW.dwReserved,lpcJobParams->dwReserved, sizeof(lpcJobParams->dwReserved));

        if (!(JobParamsW.lptstrDocumentName         = AnsiStringToUnicodeString ( lpcJobParams->lptstrDocumentName)) && lpcJobParams->lptstrDocumentName||
            !(JobParamsW.lptstrReceiptDeliveryAddress =
                AnsiStringToUnicodeString ( lpcJobParams->lptstrReceiptDeliveryAddress)) &&
                lpcJobParams->lptstrReceiptDeliveryAddress)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for job params"));
            ec=ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

    }

    if (!FaxSendDocumentEx2W(hFaxHandle,
                            lpwstrFileNameW,
                            (lpcCoverPageInfo) ? &CoverpageInfoW : NULL,
                            &SenderProfileW,
                            dwNumRecipients,
                            lpRecipientListW,
                            &JobParamsW,
                            lpdwJobId,
                            lpdwlMessageId,
                            lpdwlRecipientMessageIds))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxSendDocumentExW failed. ec=0x%X"),ec);
        goto Error;
    }

    goto Exit;

Exit:
    Assert (ERROR_SUCCESS == ec);
Error:
    //
    // free JobParamsW
    //
    MemFree ( JobParamsW.lptstrDocumentName );
    MemFree ( JobParamsW.lptstrReceiptDeliveryAddress );
    //
    // free lpRecipientListW
    //
    if (lpRecipientListW)
    {
        for(dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
        {
            MemFree ( lpRecipientListW[dwIndex].lptstrName              );
            MemFree ( lpRecipientListW[dwIndex].lptstrFaxNumber         );
            MemFree ( lpRecipientListW[dwIndex].lptstrCompany           );
            MemFree ( lpRecipientListW[dwIndex].lptstrStreetAddress     );
            MemFree ( lpRecipientListW[dwIndex].lptstrCity              );
            MemFree ( lpRecipientListW[dwIndex].lptstrState             );
            MemFree ( lpRecipientListW[dwIndex].lptstrZip               );
            MemFree ( lpRecipientListW[dwIndex].lptstrCountry           );
            MemFree ( lpRecipientListW[dwIndex].lptstrTitle             );
            MemFree ( lpRecipientListW[dwIndex].lptstrDepartment        );
            MemFree ( lpRecipientListW[dwIndex].lptstrOfficeLocation    );
            MemFree ( lpRecipientListW[dwIndex].lptstrHomePhone         );
            MemFree ( lpRecipientListW[dwIndex].lptstrOfficePhone       );
            MemFree ( lpRecipientListW[dwIndex].lptstrEmail             );
            MemFree ( lpRecipientListW[dwIndex].lptstrBillingCode       );
            MemFree ( lpRecipientListW[dwIndex].lptstrTSID              );
        }
        MemFree (lpRecipientListW);
    }

    //
    // free SenderProfileW
    //
    MemFree ( SenderProfileW.lptstrName             );
    MemFree ( SenderProfileW.lptstrFaxNumber        );
    MemFree ( SenderProfileW.lptstrCompany          );
    MemFree ( SenderProfileW.lptstrStreetAddress    );
    MemFree ( SenderProfileW.lptstrCity             );
    MemFree ( SenderProfileW.lptstrState            );
    MemFree ( SenderProfileW.lptstrZip              );
    MemFree ( SenderProfileW.lptstrCountry          );
    MemFree ( SenderProfileW.lptstrTitle            );
    MemFree ( SenderProfileW.lptstrDepartment       );
    MemFree ( SenderProfileW.lptstrOfficeLocation   );
    MemFree ( SenderProfileW.lptstrHomePhone        );
    MemFree ( SenderProfileW.lptstrOfficePhone      );
    MemFree ( SenderProfileW.lptstrEmail            );
    MemFree ( SenderProfileW.lptstrBillingCode      );
    MemFree ( SenderProfileW.lptstrTSID             );
    //
    // free CoverpageInfoW
    //
    MemFree( CoverpageInfoW.lptstrCoverPageFileName );
    MemFree( CoverpageInfoW.lptstrNote );
    MemFree( CoverpageInfoW.lptstrSubject );
    //
    // free file name
    //
    MemFree( lpwstrFileNameW );
    SetLastError(ec);
    return (ERROR_SUCCESS == ec);
}
#else
BOOL WINAPI FaxSendDocumentEx2W
(
    IN  HANDLE hFaxHandle,
    IN  LPCWSTR lpctstrFileName,
    IN  LPCFAX_COVERPAGE_INFO_EXW lpcCoverPageInfo,
    IN  LPCFAX_PERSONAL_PROFILEW  lpcSenderProfile,
    IN  DWORD dwNumRecipients,
    IN  LPCFAX_PERSONAL_PROFILEW    lpcRecipientList,
    IN  LPCFAX_JOB_PARAM_EXW lpcJobParams,
    OUT LPDWORD lpdwJobId,
    OUT PDWORDLONG lpdwlMessageId,
    OUT PDWORDLONG lpdwlRecipientMessageIds
)
{
    UNREFERENCED_PARAMETER(hFaxHandle);
    UNREFERENCED_PARAMETER(lpctstrFileName);
    UNREFERENCED_PARAMETER(lpcCoverPageInfo);
    UNREFERENCED_PARAMETER(lpcSenderProfile);
    UNREFERENCED_PARAMETER(dwNumRecipients);
    UNREFERENCED_PARAMETER(lpcRecipientList);
    UNREFERENCED_PARAMETER(lpcJobParams);
    UNREFERENCED_PARAMETER(lpdwJobId);
    UNREFERENCED_PARAMETER(lpdwlMessageId);
    UNREFERENCED_PARAMETER(lpdwlRecipientMessageIds);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif


BOOL WINAPI FaxSendDocumentEx2
(
    IN  HANDLE hFaxHandle,
    IN  LPCTSTR lpctstrFileName,
    IN  LPCFAX_COVERPAGE_INFO_EX lpcCoverPageInfo,
    IN  LPCFAX_PERSONAL_PROFILE  lpcSenderProfile,
    IN  DWORD dwNumRecipients,
    IN  LPCFAX_PERSONAL_PROFILE    lpcRecipientList,
    IN  LPCFAX_JOB_PARAM_EX lpcJobParams,
    OUT LPDWORD lpdwJobId,
    OUT PDWORDLONG lpdwlMessageId,
    OUT PDWORDLONG lpdwlRecipientMessageIds
)
{

    LPTSTR lptstrMachineName = NULL;
    LPTSTR lptstrBodyFileName=NULL; // Points to the name of the body file at the server queue directory.
                                    // It is NULL if there is no body file.
    TCHAR szQueueFileName[MAX_PATH];        
    DWORD ec;
    FAX_JOB_PARAM_EX JobParamCopy;    

    FAX_COVERPAGE_INFO_EX newCoverInfo;
    TCHAR szTiffFile[MAX_PATH];
    LPTSTR lptstrFinalTiffFile = NULL; // Points to the fixed temporary TIFF file which is generated from the
                                       // original body file if it is not valid.
                                       // Points to the original body if there was no need to create a fixed TIFF.
                                       // Will remain NULL if no body was specified.
    TCHAR szQueueCoverpageFile[MAX_PATH]; // The name of the generated cover page template file in the queue dir (short name)
    LPCFAX_COVERPAGE_INFO_EX lpcFinalCoverInfo=NULL; // Points to the cover page information structure to be used.
                                                      // This will be the same as lpcCoverPageInfo if the cover page is not personal.
                                                      // It will point to &newCoverInfo if the cover page is personal.

    TCHAR   szLocalCpFile[MAX_PATH] = {0};
    DEBUG_FUNCTION_NAME(TEXT("FaxSendDocumentEx"));   

    memset(&JobParamCopy,0,sizeof(JobParamCopy));

    //
    // argument validation
    //

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid parameters: Fax handle 0x%08X is not valid."),
            hFaxHandle);
       ec=ERROR_INVALID_HANDLE;
       goto Error;
    }

    if (!lpctstrFileName && !lpcCoverPageInfo)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid parameters: Both body and coverpage info are not specified."));
        ec=ERROR_INVALID_PARAMETER;
        goto Error;
    }

    if (lpcCoverPageInfo)
    {
        if (lpcCoverPageInfo->dwSizeOfStruct!= sizeof(FAX_COVERPAGE_INFO_EXW))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: Size of CoverpageInfo (%d) != %ld."),
                lpcCoverPageInfo->dwSizeOfStruct,
                sizeof(FAX_COVERPAGE_INFO_EXW));
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }

        if (FAX_COVERPAGE_FMT_COV != lpcCoverPageInfo->dwCoverPageFormat &&
            FAX_COVERPAGE_FMT_COV_SUBJECT_ONLY != lpcCoverPageInfo->dwCoverPageFormat)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Unsupported Cover Page format (%d)."),
                lpcCoverPageInfo->dwCoverPageFormat);
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }

        if (FAX_COVERPAGE_FMT_COV == lpcCoverPageInfo->dwCoverPageFormat &&
            !lpcCoverPageInfo->lptstrCoverPageFileName)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: CoverpageInfo->CoverPageName is NULL."));
            //
            // Notice: We must return ERROR_FILE_NOT_FOUND and not ERROR_INVALID_PARAMETER.
            //         This is because the MSDN on the legacy FaxSendDocument function explicitly
            //         specifies so, and this function (untimately) gets called from FaxSendDocument ().
            //
            ec=ERROR_FILE_NOT_FOUND;
            goto Error;
        }

    }

    if (lpcSenderProfile)
    {
        if (lpcSenderProfile->dwSizeOfStruct!= sizeof(FAX_PERSONAL_PROFILEW))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: Size of lpcSenderProfile (%d) != %ld."),
                lpcSenderProfile->dwSizeOfStruct,
                sizeof(FAX_PERSONAL_PROFILEW));
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }
    }
    else
    {
        DebugPrintEx(DEBUG_ERR,TEXT("Invalid parameters: lpcSenderProfile is NULL."));
        ec=ERROR_INVALID_PARAMETER;
        goto Error;
    }


    if (lpcJobParams)
    {
        if (lpcJobParams->dwSizeOfStruct!= sizeof(FAX_JOB_PARAM_EXW))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: Size of lpcJobParams (%d) != %ld."),
                lpcSenderProfile->dwSizeOfStruct,
                sizeof(FAX_JOB_PARAM_EXW));
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }
        if (lpcJobParams->dwScheduleAction != JSA_NOW &&
            lpcJobParams->dwScheduleAction != JSA_SPECIFIC_TIME &&
            lpcJobParams->dwScheduleAction != JSA_DISCOUNT_PERIOD)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: lpcJobParams->dwScheduleAction (%ld) is invalid."),
                lpcJobParams->dwScheduleAction);
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }

        if (lpcJobParams->dwReceiptDeliveryType & ~(DRT_ALL | DRT_MODIFIERS))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: lpcJobParams->DeliveryReportType (%ld) is invalid."),
                lpcJobParams->dwReceiptDeliveryType);
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }
        if (((lpcJobParams->dwReceiptDeliveryType & ~DRT_MODIFIERS) != DRT_NONE) &&
            ((lpcJobParams->dwReceiptDeliveryType & ~DRT_MODIFIERS) != DRT_EMAIL) &&
            ((lpcJobParams->dwReceiptDeliveryType & ~DRT_MODIFIERS) != DRT_MSGBOX)
            )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid parameters: lpcJobParams->DeliveryReportType (%ld) has invalid values combination."),
                lpcJobParams->dwReceiptDeliveryType);
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }

    }
    else
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid parameters: lpcJobParams is NULL"));
        ec=ERROR_INVALID_PARAMETER;
        goto Error;
    }


    if (lpctstrFileName)
    {
        TCHAR szExistingFile[MAX_PATH];
        DWORD rc;
        LPTSTR p;
        DWORD  dwFileSize;
        HANDLE hLocalFile = INVALID_HANDLE_VALUE;

        //
        // make sure the file is there
        //
        rc = GetFullPathName(lpctstrFileName,sizeof(szExistingFile)/sizeof(TCHAR),szExistingFile,&p);

        if (rc > MAX_PATH || rc == 0)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFullPathName failed, ec= %d\n"),
                GetLastError() );
            ec=(rc > MAX_PATH) ? ERROR_INVALID_PARAMETER : GetLastError() ;
            goto Error;
        }

        if (GetFileAttributes(szExistingFile) == 0xFFFFFFFF)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFileAttributes for %ws failed (ec= %d)."),
                szExistingFile,
                GetLastError() );
            ec=ERROR_FILE_NOT_FOUND;
            goto Error;
        }

        //
        // Check file size is non-zero and make sure it is not a device
        // Try to open file
        //
        hLocalFile = SafeCreateFile (
                    szExistingFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
        if ( INVALID_HANDLE_VALUE == hLocalFile )
        {
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Opening %s for read failed (ec: %ld)"),
                szExistingFile,
                ec);
            goto Error;
        }

        dwFileSize = GetFileSize (hLocalFile, NULL);
        if (INVALID_FILE_SIZE == dwFileSize)
        {
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFileSize failed (ec: %ld)"),
                ec);
            CloseHandle (hLocalFile);
            goto Error;
        }
        CloseHandle (hLocalFile);
        if (!dwFileSize)
        {
            //
            // Zero-sized file passed to us
            //
            ec = ERROR_INVALID_DATA;
            goto Error;
        }
    }

    if (!dwNumRecipients)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid parameters: dwNumRecipients is ZERO."));
        ec=ERROR_INVALID_PARAMETER;
        goto Error;
    }

    lptstrMachineName = IsLocalFaxConnection(hFaxHandle) ?  NULL : FH_DATA(hFaxHandle)->MachineName;

    // let's check if its allowed to use personal coverpages
    if (lpcCoverPageInfo &&
        FAX_COVERPAGE_FMT_COV == lpcCoverPageInfo->dwCoverPageFormat)
    {
        if (!lpcCoverPageInfo->bServerBased)
        {
            // the requested coverpage is personal
            BOOL bPersonalCPAllowed = TRUE;
            if (!FaxGetPersonalCoverPagesOption(hFaxHandle, &bPersonalCPAllowed))
            {
                DebugPrintEx(   DEBUG_ERR,
                                _T("FaxGetPersonalCoverPagesOption failed with ec = %d"),
                                ec=GetLastError());
                goto Error;
            }
            if (!bPersonalCPAllowed)
            {
                // clients must use cover pages on the server
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("The use of personal cover pages is prohibited"));
                // this is returned in order to be caught by the caller
                // it's unique enough to be understood
                ec = ERROR_CANT_ACCESS_FILE;
                goto Error;
            }
        }        
    }

    if (lpcCoverPageInfo  &&
        FAX_COVERPAGE_FMT_COV == lpcCoverPageInfo->dwCoverPageFormat &&
        !ValidateCoverpage(lpcCoverPageInfo->lptstrCoverPageFileName,
                           lptstrMachineName,
                           lpcCoverPageInfo->bServerBased,
                           szLocalCpFile,
                           ARR_SIZE(szLocalCpFile)))
    {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ValidateCoverPage failed for %ws."),
                lpcCoverPageInfo->lptstrCoverPageFileName);
            ec=ERROR_FILE_NOT_FOUND;
            goto Error;
    }


    if (lpcJobParams->hCall != 0 || lpcJobParams->dwReserved[0]==0xFFFF1234)
    {
        //
        // Handoff is not supported
        //
        DebugPrintEx(DEBUG_ERR,TEXT("Invalid parameter: We do not support handoff."));
        ec = ERROR_NOT_SUPPORTED;
        goto Error;        
    }
    
    //
    // this is a normal fax...validate the fax numbers of all recipients.
    //
    UINT i;

    for (i = 0; i < dwNumRecipients; i++)
    {
        if (!lpcRecipientList[i].lptstrFaxNumber)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("Invalid parameters: recipient %ld does not have a fax number."),i);
            ec=ERROR_INVALID_PARAMETER;
            goto Error;
        }
    }   

    if (lpctstrFileName)
    {
        //
        // Genereate a valid TIFF file from the body file we got if it is not valid.
        // Note that CreateFinalTiffFile will return the ORIGINAL file name
        // and will NOT create a new file if the original TIFF is good.
        //
        ZeroMemory(szTiffFile,sizeof(szTiffFile));
        if (!CreateFinalTiffFile((LPTSTR)lpctstrFileName, szTiffFile, ARR_SIZE(szTiffFile), hFaxHandle)) // No cover page rendering
        {
            ec=GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFinalTiffFile for file %s has failed."),
                lpctstrFileName);
            goto Error;
        }

        lptstrFinalTiffFile = szTiffFile;

    }
    else
    {
        lptstrFinalTiffFile = NULL;
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("FinallTiff (body) file is %s"),
        lptstrFinalTiffFile);

    if (lptstrFinalTiffFile)
    {
        //
        // copy the final body TIFF to the server's queue dir
        //
        HANDLE hLocalFile = INVALID_HANDLE_VALUE;
        //
        // Try to open local file first
        //
        hLocalFile = SafeCreateFile (
                    lptstrFinalTiffFile,
                    GENERIC_READ,
                    FILE_SHARE_READ,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL);
        if ( INVALID_HANDLE_VALUE == hLocalFile )
        {
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Opening %s for read failed (ec: %ld)"),
                lptstrFinalTiffFile,
                ec);
            goto Error;
        }
        if (!CopyFileToServerQueue( hFaxHandle, hLocalFile, FAX_TIF_FILE_EXT, szQueueFileName, ARR_SIZE(szQueueFileName) ))
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to copy body file (%s) to queue dir."),
                lptstrFinalTiffFile);
            CloseHandle (hLocalFile);
            goto Error;
        }
        CloseHandle (hLocalFile);
        lptstrBodyFileName=szQueueFileName;
    }
    else
    {
        lptstrBodyFileName = NULL;
    }


    DebugPrintEx(
        DEBUG_MSG,
        TEXT("BodyFileName (after copying to server queue) is %s"),
        lptstrBodyFileName);



    //
    // queue the fax to be sent
    //

    if (!CopyJobParamEx(&JobParamCopy,lpcJobParams))
    {
        DebugPrintEx(DEBUG_ERR,TEXT("CopyJobParamEx failed."));
        ec=GetLastError();
        goto Error;
    }

    JobParamCopy.dwReserved[0] = 0;   
    JobParamCopy.dwReserved[1] = 0;
    JobParamCopy.dwReserved[2] = 0;    

    if (lpcJobParams->dwScheduleAction == JSA_SPECIFIC_TIME)
    {
        //
        // convert the system time from local to utc
        //
        if (!LocalSystemTimeToSystemTime( &lpcJobParams->tmSchedule, &JobParamCopy.tmSchedule ))
        {
            ec=GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LocalSystemTimeToSystemTime() failed. (ec: %ld)"),
                ec);
            goto Error;
        }
    }

    if (lpcCoverPageInfo)
    {
        //
        // If the cover page is a personal cover page then copy it
        // to the server queue directory. This will allow the server to access it.
        // Note the following rules regarding the cover page file path passed to FAX_SendDocumentEx:
        // Server cover pages are specified by thier FULL path to thier location in the server. This is the
        // way we get them from the client.
        // Personal cover pages are copied to the QUEUE directory at the server. We then pass to the FAX_SendDocumentEx
        // just thier SHORT name. The server will append the QUEUE path.
        //
        if (FAX_COVERPAGE_FMT_COV == lpcCoverPageInfo->dwCoverPageFormat &&
            !lpcCoverPageInfo->bServerBased)
        {
            HANDLE  hLocalFile = INVALID_HANDLE_VALUE;
            BOOL    bRes;
            Assert(lpcCoverPageInfo->lptstrCoverPageFileName);
            //
            // Try to open local file first
            //
            hLocalFile = SafeCreateFile (
                        szLocalCpFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);
            if ( INVALID_HANDLE_VALUE == hLocalFile )
            {
                ec = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Opening %s for read failed (ec: %ld)"),
                    szLocalCpFile,
                    ec);
                goto Error;
            }
            bRes = CopyFileToServerQueue( hFaxHandle, 
                                          hLocalFile, 
                                          FAX_COVER_PAGE_EXT_LETTERS, 
                                          szQueueCoverpageFile, 
                                          ARR_SIZE(szQueueCoverpageFile) );
            if (!bRes)
            {
                ec=GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to copy personal cover page file (%s) to queue dir. (ec: %d)\n"),
                    szLocalCpFile,
                    ec);
                CloseHandle (hLocalFile);
                goto Error;
            }
            else
            {
                //
                // We use newCoverInfo since we do not wish to change the input parameter
                // structure (the client owns it) but we must change the cover page file path.
                //
                memcpy((LPVOID)&newCoverInfo,(LPVOID)lpcCoverPageInfo,sizeof(FAX_COVERPAGE_INFO_EXW));
                newCoverInfo.lptstrCoverPageFileName=szQueueCoverpageFile;
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Personal cover page file (%s) copied to (%s)."),
                    lpcCoverPageInfo->lptstrCoverPageFileName,
                    szQueueCoverpageFile);
            }
            CloseHandle (hLocalFile);
            lpcFinalCoverInfo=&newCoverInfo;
        }
        else
        {
            lpcFinalCoverInfo=lpcCoverPageInfo;
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("A server cover page (%s) is specified. Do not copy to queue dir."),
                lpcCoverPageInfo->lptstrCoverPageFileName);
        }

    }
    else
    {
        //
        // In case of no cover page we send a cover page information structure with
        // everything set to null including the path to the file name.
        // The fax service code checks that the file name is not NULL
        // to determine if a cover page is specified or not.
        //
        memset((LPVOID)&newCoverInfo,0,sizeof(FAX_COVERPAGE_INFO_EXW));
        lpcFinalCoverInfo=&newCoverInfo;
    }

    __try
    {
#ifndef UNICODE
        //
        // Need to convert ANSI parameters to Unicode and Back
        //
        ec=FAX_SendDocumentEx_A(FH_FAX_HANDLE(hFaxHandle),
                            lptstrBodyFileName,
                            lpcFinalCoverInfo,
                            lpcSenderProfile,
                            dwNumRecipients,
                            lpcRecipientList,
                            &JobParamCopy,
                            lpdwJobId,
                            lpdwlMessageId,
                            lpdwlRecipientMessageIds);
#else
        ec=FAX_SendDocumentEx(FH_FAX_HANDLE(hFaxHandle),
                            lptstrBodyFileName,
                            lpcFinalCoverInfo,
                            lpcSenderProfile,
                            dwNumRecipients,
                            lpcRecipientList,
                            &JobParamCopy,
                            lpdwJobId,
                            lpdwlMessageId,
                            lpdwlRecipientMessageIds);
#endif
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SendDocumentEx. (ec: %ld)"),
            ec);
    }
    
    if (ERROR_SUCCESS!=ec)
    {
        DumpRPCExtendedStatus ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_SendDocumentEx failed with error code 0x%0x"),
            ec);
        goto Error;
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("FAX_SendDocumentEx succeeded. Parent Job Id = 0x%I64x."),
        *lpdwlMessageId);

    //
    // we're done if it's a normal call
    //
    ec=ERROR_SUCCESS;
    goto Exit;

Error:
Exit:    
    FreeJobParamEx(&JobParamCopy,FALSE);
    //
    // Delete the Temp Final Tiff file.
    //
    if (lptstrFinalTiffFile)
    {
        if (_tcscmp(lptstrFinalTiffFile,lpctstrFileName))
        {
            //
            // We delete the final tiff file only if it is not the original TIFF file (i.e.
            // a temp file was really created). We DO NOT want to delete the user provided
            // body file !!!
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Deleting temporary Final Tiff file %s"),
                lptstrFinalTiffFile);

            if (!DeleteFile(lptstrFinalTiffFile))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to delete Final Tiff file %s (ec: %ld)"),
                    lptstrFinalTiffFile,
                    GetLastError());
            }
        }
    }
    //
    // Note that FAX_SendDocumentEx will take care of deleting the cover page template
    // in case there was an error. We make sure we copy the cover page just before calling
    // FAX_SendDocumentEx, thus we do not need to delete the cover page template in this
    // function.
    //
    SetLastError(ec);
    return (ERROR_SUCCESS == ec);
}   // FaxSendDocumentEx2

BOOL CopyJobParamEx(PFAX_JOB_PARAM_EX lpDst,LPCFAX_JOB_PARAM_EX lpcSrc)
{

    DEBUG_FUNCTION_NAME(TEXT("CopyJobParamEx"));

    Assert(lpDst);
    Assert(lpcSrc);
    memcpy(lpDst,lpcSrc,sizeof(FAX_JOB_PARAM_EXW));
    if (lpcSrc->lptstrReceiptDeliveryAddress)
    {
        lpDst->lptstrReceiptDeliveryAddress =
            StringDup(lpcSrc->lptstrReceiptDeliveryAddress);
        if (!lpDst->lptstrReceiptDeliveryAddress)
        {
            return FALSE;
        }
    }
    if (lpcSrc->lptstrDocumentName)
    {
        lpDst->lptstrDocumentName=StringDup(lpcSrc->lptstrDocumentName);
        if (!lpDst->lptstrDocumentName)
        {
            MemFree(lpDst->lptstrReceiptDeliveryAddress);
            return FALSE;
        }
    }

    return TRUE;

}


void FreeJobParamEx(PFAX_JOB_PARAM_EX lpJobParamEx,BOOL bDestroy)
{
    Assert(lpJobParamEx);
    MemFree(lpJobParamEx->lptstrReceiptDeliveryAddress);
    MemFree(lpJobParamEx->lptstrDocumentName);
    if (bDestroy) {
        MemFree(lpJobParamEx);
    }

}


#ifndef UNICODE
FaxGetRecipientInfoX (
    IN  HANDLE                     hFaxHandle,
    IN  DWORDLONG                  dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PFAX_PERSONAL_PROFILEW    *lppPersonalProfile
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwlMessageId);
    UNREFERENCED_PARAMETER (Folder);
    UNREFERENCED_PARAMETER (lppPersonalProfile);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif

BOOL
FaxGetRecipientInfoW (
    IN  HANDLE             hFaxHandle,
    IN  DWORDLONG              dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PFAX_PERSONAL_PROFILEW    *lppPersonalProfile
)
/*++

Routine Description:

    Returns the recipient FAX_PERSONAL_PROFILE structure of the specified recipient job.

Arguments:

    hFaxHandle          - FAX handle obtained from FaxConnectFaxServer
    dwRecipientId       - Unique number that identifies a queueud
                          or active fax recipient job.
    lppPersonalProfile    - Pointer to the adress of a FAX_PERSONAL_PROFILE structure
                          to recieve the specified recipient info.
    Return Value:

    Non Zero for success, otherwise a WIN32 error code.

--*/
{
    return FaxGetPersonalProfileInfoW (hFaxHandle,
                                       dwlMessageId,
                                       Folder,
                                       RECIPIENT_PERSONAL_PROF,
                                       lppPersonalProfile);
}


BOOL
FaxGetRecipientInfoA (
    IN  HANDLE             hFaxHandle,
    IN  DWORDLONG              dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PFAX_PERSONAL_PROFILEA    *lppPersonalProfile
)
{
    return FaxGetPersonalProfileInfoA (hFaxHandle,
                                       dwlMessageId,
                                       Folder,
                                       RECIPIENT_PERSONAL_PROF,
                                       lppPersonalProfile);
}

#ifndef UNICODE
FaxGetSenderInfoX (
    IN  HANDLE                     hFaxHandle,
    IN  DWORDLONG                  dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PFAX_PERSONAL_PROFILEW    *lppPersonalProfile
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwlMessageId);
    UNREFERENCED_PARAMETER (Folder);
    UNREFERENCED_PARAMETER (lppPersonalProfile);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif


BOOL
FaxGetSenderInfoW (
    IN  HANDLE             hFaxHandle,
    IN  DWORDLONG              dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PFAX_PERSONAL_PROFILEW    *lppPersonalProfile
)
/*++

Routine Description:

    Returns the sender FAX_PERSONAL_PROFILE structure of the specified recipient job.

Arguments:

    hFaxHandle          - FAX handle obtained from FaxConnectFaxServer
    dwSenderId       - Unique number that identifies a queueud
                          or active fax recipient job.
    lppPersonalProfile    - Pointer to the adress of a FAX_PERSONAL_PROFILE structure
                          to recieve the specified sender info.
    Return Value:

    Non Zero for success, otherwise a WIN32 error code.

--*/
{
    return FaxGetPersonalProfileInfoW (hFaxHandle,
                                       dwlMessageId,
                                       Folder,
                                       SENDER_PERSONAL_PROF,
                                       lppPersonalProfile);
}


BOOL
FaxGetSenderInfoA (
    IN  HANDLE             hFaxHandle,
    IN  DWORDLONG              dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PFAX_PERSONAL_PROFILEA    *lppPersonalProfile
)
{
    return FaxGetPersonalProfileInfoA (hFaxHandle,
                                       dwlMessageId,
                                       Folder,
                                       SENDER_PERSONAL_PROF,
                                       lppPersonalProfile);
}



static BOOL
FaxGetPersonalProfileInfoW (
    IN  HANDLE                          hFaxHandle,
    IN  DWORDLONG                       dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER         Folder,
    IN  FAX_ENUM_PERSONAL_PROF_TYPES    ProfType,
    OUT PFAX_PERSONAL_PROFILEW          *lppPersonalProfile
)
{

    error_status_t ec;
    DWORD dwBufferSize = 0;
    LPBYTE Buffer = NULL;
    PFAX_PERSONAL_PROFILEW lpPersoProf;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetPersonalProfileInfoW"));

    Assert (lppPersonalProfile);
    Assert (RECIPIENT_PERSONAL_PROF == ProfType ||
            SENDER_PERSONAL_PROF    == ProfType);

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (FAX_MESSAGE_FOLDER_SENTITEMS != Folder &&
        FAX_MESSAGE_FOLDER_QUEUE  != Folder)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Wrong Folder."));
        return FALSE;
    }

    //
    // Call RPC function.
    //
    __try
    {
        ec = FAX_GetPersonalProfileInfo (FH_FAX_HANDLE(hFaxHandle),
                                         dwlMessageId,
                                         Folder,
                                         ProfType,
                                         &Buffer,
                                         &dwBufferSize
                                        );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetRecipientInfo. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    *lppPersonalProfile = (PFAX_PERSONAL_PROFILEW)Buffer;

    //
    // Unpack Buffer
    //
    lpPersoProf = (PFAX_PERSONAL_PROFILEW) *lppPersonalProfile;

    Assert(lpPersoProf);

    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrName );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrFaxNumber );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrCompany );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrStreetAddress );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrCity );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrState );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrZip );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrCountry );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrTitle );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrDepartment );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrOfficeLocation );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrHomePhone );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrOfficePhone );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrEmail );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrBillingCode );
    FixupStringPtrW( &lpPersoProf, lpPersoProf->lptstrTSID );

    return TRUE;
}


static BOOL
FaxGetPersonalProfileInfoA (
    IN  HANDLE                          hFaxHandle,
    IN  DWORDLONG                       dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER         Folder,
    IN  FAX_ENUM_PERSONAL_PROF_TYPES    ProfType,
    OUT PFAX_PERSONAL_PROFILEA          *lppPersonalProfile
)
{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetPersonalProfileInfoA"));

    if (!FaxGetPersonalProfileInfoW(
            hFaxHandle,
            dwlMessageId,
            Folder,
            ProfType,
            (PFAX_PERSONAL_PROFILEW*) lppPersonalProfile
            ))
    {
        return FALSE;
    }

    if (!ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrName )          ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrFaxNumber )     ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrStreetAddress ) ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrCity )          ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrState )         ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrZip )           ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrCountry )       ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrCompany )       ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrTitle )         ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrDepartment )    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrOfficeLocation )||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrHomePhone )     ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrOfficePhone )   ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrEmail )         ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrBillingCode )   ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*lppPersonalProfile)->lptstrTSID ))

    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*lppPersonalProfile);
        return FALSE;
    }
    (*lppPersonalProfile)->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILEA);
    return TRUE;
}   // FaxGetPersonalProfileInfoA


DWORD WINAPI FAX_SendDocumentEx_A
(
    IN  handle_t                    hBinding,
    IN  LPCSTR                      lpcstrFileName,
    IN  LPCFAX_COVERPAGE_INFO_EXA   lpcCoverPageInfo,
    IN  LPCFAX_PERSONAL_PROFILEA    lpcSenderProfile,
    IN  DWORD                       dwNumRecipients,
    IN  LPCFAX_PERSONAL_PROFILEA    lpcRecipientList,
    IN  LPCFAX_JOB_PARAM_EXA        lpcJobParams,
    OUT LPDWORD                     lpdwJobId,
    OUT PDWORDLONG                  lpdwlMessageId,
    OUT PDWORDLONG                  lpdwlRecipientMessageIds
)
{
    DWORD                       ec = ERROR_SUCCESS;
    LPWSTR                      lpwstrFileNameW = NULL;
    FAX_COVERPAGE_INFO_EXW      CoverpageInfoW ;
    FAX_PERSONAL_PROFILEW       SenderProfileW ;
    PFAX_PERSONAL_PROFILEW      lpRecipientListW = NULL;
    FAX_JOB_PARAM_EXW           JobParamsW ;
    DWORD                       dwIndex;

    DEBUG_FUNCTION_NAME(TEXT("FAX_SendDocumentEx2_A"));

    ZeroMemory( &CoverpageInfoW, sizeof(FAX_COVERPAGE_INFO_EXW) );
    ZeroMemory( &SenderProfileW, sizeof(FAX_PERSONAL_PROFILEW) );
    ZeroMemory( &JobParamsW,     sizeof(FAX_JOB_PARAM_EXW));

    //
    // convert input parameters
    //

    if (lpcstrFileName)
    {
        if (!(lpwstrFileNameW = AnsiStringToUnicodeString(lpcstrFileName)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for file name"));
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
    }

    if (lpcCoverPageInfo)
    {
        CoverpageInfoW.dwSizeOfStruct = sizeof(FAX_COVERPAGE_INFO_EXW);

        CoverpageInfoW.dwCoverPageFormat    = lpcCoverPageInfo->dwCoverPageFormat;
        CoverpageInfoW.bServerBased         = lpcCoverPageInfo->bServerBased;
        if (!(CoverpageInfoW.lptstrCoverPageFileName = AnsiStringToUnicodeString ( lpcCoverPageInfo->lptstrCoverPageFileName)) && lpcCoverPageInfo->lptstrCoverPageFileName ||
            !(CoverpageInfoW.lptstrNote              = AnsiStringToUnicodeString ( lpcCoverPageInfo->lptstrNote             )) && lpcCoverPageInfo->lptstrNote   ||
            !(CoverpageInfoW.lptstrSubject           = AnsiStringToUnicodeString ( lpcCoverPageInfo->lptstrSubject          )) && lpcCoverPageInfo->lptstrSubject)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for Cover Page Info"));
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
    }

    if (lpcSenderProfile)
    {
        SenderProfileW.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILEW);

        if (!(SenderProfileW.lptstrName             =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrName )) && lpcSenderProfile->lptstrName ||
            !(SenderProfileW.lptstrFaxNumber        =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrFaxNumber )) && lpcSenderProfile->lptstrFaxNumber ||
            !(SenderProfileW.lptstrCompany          =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrCompany )) && lpcSenderProfile->lptstrCompany ||
            !(SenderProfileW.lptstrStreetAddress    =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrStreetAddress )) && lpcSenderProfile->lptstrStreetAddress ||
            !(SenderProfileW.lptstrCity             =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrCity )) && lpcSenderProfile->lptstrCity||
            !(SenderProfileW.lptstrState            =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrState )) && lpcSenderProfile->lptstrState||
            !(SenderProfileW.lptstrZip              =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrZip )) && lpcSenderProfile->lptstrZip||
            !(SenderProfileW.lptstrCountry          =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrCountry )) && lpcSenderProfile->lptstrCountry ||
            !(SenderProfileW.lptstrTitle            =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrTitle )) && lpcSenderProfile->lptstrTitle ||
            !(SenderProfileW.lptstrDepartment       =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrDepartment )) && lpcSenderProfile->lptstrDepartment ||
            !(SenderProfileW.lptstrOfficeLocation   =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrOfficeLocation )) && lpcSenderProfile->lptstrOfficeLocation ||
            !(SenderProfileW.lptstrHomePhone        =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrHomePhone )) && lpcSenderProfile->lptstrHomePhone ||
            !(SenderProfileW.lptstrOfficePhone      =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrOfficePhone )) && lpcSenderProfile->lptstrOfficePhone ||
            !(SenderProfileW.lptstrEmail            =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrEmail )) && lpcSenderProfile->lptstrEmail ||
            !(SenderProfileW.lptstrBillingCode      =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrBillingCode )) && lpcSenderProfile->lptstrBillingCode ||
            !(SenderProfileW.lptstrTSID             =   AnsiStringToUnicodeString ( lpcSenderProfile->lptstrTSID )) && lpcSenderProfile->lptstrTSID)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for Sender Profile"));
            ec = ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

    }

    if (!(lpRecipientListW = (PFAX_PERSONAL_PROFILEW)MemAlloc(sizeof(FAX_PERSONAL_PROFILEW)*dwNumRecipients)))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate memory for recipient list"));
        ec=ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    for(dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
    {
        ZeroMemory( &lpRecipientListW[dwIndex], sizeof(FAX_PERSONAL_PROFILEW) );

        lpRecipientListW[dwIndex].dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILEW);

        if (!(lpRecipientListW[dwIndex].lptstrName              = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrName )) && lpcRecipientList[dwIndex].lptstrName ||
            !(lpRecipientListW[dwIndex].lptstrFaxNumber         = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrFaxNumber )) && lpcRecipientList[dwIndex].lptstrFaxNumber ||
            !(lpRecipientListW[dwIndex].lptstrCompany           = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrCompany )) && lpcRecipientList[dwIndex].lptstrCompany ||
            !(lpRecipientListW[dwIndex].lptstrStreetAddress     = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrStreetAddress )) && lpcRecipientList[dwIndex].lptstrStreetAddress ||
            !(lpRecipientListW[dwIndex].lptstrCity              = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrCity )) && lpcRecipientList[dwIndex].lptstrCity ||
            !(lpRecipientListW[dwIndex].lptstrState             = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrState )) && lpcRecipientList[dwIndex].lptstrState ||
            !(lpRecipientListW[dwIndex].lptstrZip               = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrZip )) && lpcRecipientList[dwIndex].lptstrZip ||
            !(lpRecipientListW[dwIndex].lptstrCountry           = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrCountry )) && lpcRecipientList[dwIndex].lptstrCountry ||
            !(lpRecipientListW[dwIndex].lptstrTitle             = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrTitle )) && lpcRecipientList[dwIndex].lptstrTitle ||
            !(lpRecipientListW[dwIndex].lptstrDepartment        = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrDepartment )) && lpcRecipientList[dwIndex].lptstrDepartment ||
            !(lpRecipientListW[dwIndex].lptstrOfficeLocation    = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrOfficeLocation )) && lpcRecipientList[dwIndex].lptstrOfficeLocation ||
            !(lpRecipientListW[dwIndex].lptstrHomePhone         = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrHomePhone )) && lpcRecipientList[dwIndex].lptstrHomePhone ||
            !(lpRecipientListW[dwIndex].lptstrOfficePhone       = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrOfficePhone )) && lpcRecipientList[dwIndex].lptstrOfficePhone ||
            !(lpRecipientListW[dwIndex].lptstrEmail             = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrEmail )) && lpcRecipientList[dwIndex].lptstrEmail ||
            !(lpRecipientListW[dwIndex].lptstrBillingCode       = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrBillingCode )) && lpcRecipientList[dwIndex].lptstrBillingCode ||
            !(lpRecipientListW[dwIndex].lptstrTSID              = AnsiStringToUnicodeString ( lpcRecipientList[dwIndex].lptstrTSID )) && lpcRecipientList[dwIndex].lptstrTSID )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for recipient list"));
            ec=ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }
    }

    if (lpcJobParams)
    {
        JobParamsW.dwSizeOfStruct = sizeof(FAX_JOB_PARAM_EXW);

        JobParamsW.Priority                 = lpcJobParams->Priority;
        JobParamsW.dwScheduleAction         = lpcJobParams->dwScheduleAction;
        JobParamsW.tmSchedule               = lpcJobParams->tmSchedule;
        JobParamsW.dwReceiptDeliveryType    = lpcJobParams->dwReceiptDeliveryType;
        JobParamsW.hCall                    = lpcJobParams->hCall;
        JobParamsW.dwPageCount              = lpcJobParams->dwPageCount;

        memcpy(JobParamsW.dwReserved,lpcJobParams->dwReserved, sizeof(lpcJobParams->dwReserved));

        if (!(JobParamsW.lptstrDocumentName         = AnsiStringToUnicodeString ( lpcJobParams->lptstrDocumentName)) && lpcJobParams->lptstrDocumentName||
            !(JobParamsW.lptstrReceiptDeliveryAddress =
                AnsiStringToUnicodeString ( lpcJobParams->lptstrReceiptDeliveryAddress)) &&
                lpcJobParams->lptstrReceiptDeliveryAddress)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to allocate memory for job params"));
            ec=ERROR_NOT_ENOUGH_MEMORY;
            goto Error;
        }

    }

    __try
    {
        ec = FAX_SendDocumentEx(hBinding,
                                lpwstrFileNameW,
                                (lpcCoverPageInfo) ? &CoverpageInfoW : NULL,
                                &SenderProfileW,
                                dwNumRecipients,
                                lpRecipientListW,
                                &JobParamsW,
                                lpdwJobId,
                                lpdwlMessageId,
                                lpdwlRecipientMessageIds);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SendDocumentEx. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_SendDocumentEx failed. ec=0x%X"),ec);
        goto Error;
    }

    //
    // No need to convert output parameters back
    //

    goto Exit;

Exit:
    Assert( ERROR_SUCCESS == ec);
Error:
    // free JobParamsW
    MemFree ( JobParamsW.lptstrDocumentName );
    MemFree ( JobParamsW.lptstrReceiptDeliveryAddress );
    if (NULL != lpRecipientListW)
    {
        // free lpRecipientListW
        for(dwIndex = 0; dwIndex < dwNumRecipients; dwIndex++)
        {
            MemFree ( lpRecipientListW[dwIndex].lptstrName              );
            MemFree ( lpRecipientListW[dwIndex].lptstrFaxNumber         );
            MemFree ( lpRecipientListW[dwIndex].lptstrCompany           );
            MemFree ( lpRecipientListW[dwIndex].lptstrStreetAddress     );
            MemFree ( lpRecipientListW[dwIndex].lptstrCity              );
            MemFree ( lpRecipientListW[dwIndex].lptstrState             );
            MemFree ( lpRecipientListW[dwIndex].lptstrZip               );
            MemFree ( lpRecipientListW[dwIndex].lptstrCountry           );
            MemFree ( lpRecipientListW[dwIndex].lptstrTitle             );
            MemFree ( lpRecipientListW[dwIndex].lptstrDepartment        );
            MemFree ( lpRecipientListW[dwIndex].lptstrOfficeLocation    );
            MemFree ( lpRecipientListW[dwIndex].lptstrHomePhone         );
            MemFree ( lpRecipientListW[dwIndex].lptstrOfficePhone       );
            MemFree ( lpRecipientListW[dwIndex].lptstrEmail             );
            MemFree ( lpRecipientListW[dwIndex].lptstrBillingCode       );
            MemFree ( lpRecipientListW[dwIndex].lptstrTSID              );
        }
        MemFree (lpRecipientListW);
    }
    // free SenderProfileW
    MemFree ( SenderProfileW.lptstrName             );
    MemFree ( SenderProfileW.lptstrFaxNumber        );
    MemFree ( SenderProfileW.lptstrCompany          );
    MemFree ( SenderProfileW.lptstrStreetAddress    );
    MemFree ( SenderProfileW.lptstrCity             );
    MemFree ( SenderProfileW.lptstrState            );
    MemFree ( SenderProfileW.lptstrZip              );
    MemFree ( SenderProfileW.lptstrCountry          );
    MemFree ( SenderProfileW.lptstrTitle            );
    MemFree ( SenderProfileW.lptstrDepartment       );
    MemFree ( SenderProfileW.lptstrOfficeLocation   );
    MemFree ( SenderProfileW.lptstrHomePhone        );
    MemFree ( SenderProfileW.lptstrOfficePhone      );
    MemFree ( SenderProfileW.lptstrEmail            );
    MemFree ( SenderProfileW.lptstrBillingCode      );
    MemFree ( SenderProfileW.lptstrTSID             );
    // free CoverpageInfoW
    MemFree( CoverpageInfoW.lptstrCoverPageFileName );
    MemFree( CoverpageInfoW.lptstrNote );
    MemFree( CoverpageInfoW.lptstrSubject );
    // free file name
    MemFree( lpwstrFileNameW );

    return ec;
}

#ifndef UNICODE
BOOL FaxGetJobExX (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntry
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwlMessageID);
    UNREFERENCED_PARAMETER (ppJobEntry);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif


BOOL FaxGetJobExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntry
)
{
    DEBUG_FUNCTION_NAME(TEXT("FaxGetJobExA"));

    if (!FaxGetJobExW( hFaxHandle,
                       dwlMessageID,
                       (PFAX_JOB_ENTRY_EXW*) ppJobEntry))
    {
        return FALSE;
    }

    if (!ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->lpctstrRecipientNumber )          ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->lpctstrRecipientName )            ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->lpctstrSenderUserName )           ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->lpctstrBillingCode )              ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->lpctstrDocumentName )             ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->lpctstrSubject )                  ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->pStatus->lpctstrExtendedStatus )  ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->pStatus->lpctstrTsid )            ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->pStatus->lpctstrCsid )            ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->pStatus->lpctstrDeviceName )      ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->pStatus->lpctstrCallerID )        ||
        !ConvertUnicodeStringInPlace( (LPWSTR) (*ppJobEntry)->pStatus->lpctstrRoutingInfo ))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*ppJobEntry);
        return FALSE;
    }
    (*ppJobEntry)->dwSizeOfStruct = sizeof(FAX_JOB_ENTRY_EXA);
    return TRUE;
}   // FaxGetJobExA



BOOL FaxGetJobExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORDLONG           dwlMessageID,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntry
)
/*++

Routine name : FaxGetJobExW

Routine description:

    Returns FAX_JOB_ENTRY_EX structure of the specified message.
    The caller must call FaxFreeBuffer to deallocate the memory.

Author:

    Oded Sacher (OdedS),    Nov, 1999

Arguments:

    hFaxHandle          [      ] - Fax handle obtained from FaxConnectFaxServer()
    dwlMessageID            [      ] - Unique message ID
    ppJobEntry          [      ] - Buffer to receive the FAX_JOB_ENTRY_EX structure

Return Value:

    BOOL

--*/
{
    error_status_t ec;
    DWORD dwBufferSize = 0;
    LPBYTE Buffer = NULL;
    PFAX_JOB_ENTRY_EXW lpJobEntry;
    PFAX_JOB_STATUSW lpFaxStatus;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetJobExW"));

    Assert (ppJobEntry);

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    //
    // Call RPC function.
    //
    __try
    {
        ec = FAX_GetJobEx (FH_FAX_HANDLE(hFaxHandle),
                           dwlMessageID,
                           &Buffer,
                           &dwBufferSize
                          );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetJobEx. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    *ppJobEntry = (PFAX_JOB_ENTRY_EXW)Buffer;

    //
    // Unpack Buffer
    //
    lpJobEntry = (PFAX_JOB_ENTRY_EXW) *ppJobEntry;
    lpFaxStatus = (PFAX_JOB_STATUSW) ((LPBYTE)*ppJobEntry + sizeof (FAX_JOB_ENTRY_EXW));
    lpJobEntry->pStatus = lpFaxStatus;

    FixupStringPtrW( &lpJobEntry, lpJobEntry->lpctstrRecipientNumber );
    FixupStringPtrW( &lpJobEntry, lpJobEntry->lpctstrRecipientName );
    FixupStringPtrW( &lpJobEntry, lpJobEntry->lpctstrSenderUserName );
    FixupStringPtrW( &lpJobEntry, lpJobEntry->lpctstrBillingCode );
    FixupStringPtrW( &lpJobEntry, lpJobEntry->lpctstrDocumentName );
    FixupStringPtrW( &lpJobEntry, lpJobEntry->lpctstrSubject );

    FixupStringPtrW( &lpJobEntry, lpFaxStatus->lpctstrExtendedStatus );
    FixupStringPtrW( &lpJobEntry, lpFaxStatus->lpctstrTsid );
    FixupStringPtrW( &lpJobEntry, lpFaxStatus->lpctstrCsid );
    FixupStringPtrW( &lpJobEntry, lpFaxStatus->lpctstrDeviceName );
    FixupStringPtrW( &lpJobEntry, lpFaxStatus->lpctstrCallerID );
    FixupStringPtrW( &lpJobEntry, lpFaxStatus->lpctstrRoutingInfo );

    return TRUE;
}


#ifndef UNICODE
BOOL FaxEnumJobsExX (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntries,
    OUT LPDWORD             lpdwJobs
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwJobTypes);
    UNREFERENCED_PARAMETER (ppJobEntries);
    UNREFERENCED_PARAMETER (lpdwJobs);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}
#endif



BOOL FaxEnumJobsExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXA *ppJobEntries,
    OUT LPDWORD             lpdwJobs
)
{
    PFAX_JOB_ENTRY_EXW pJobEntry;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumJobsExA"));

    if (!FaxEnumJobsExW (hFaxHandle,
                         dwJobTypes,
                         (PFAX_JOB_ENTRY_EXW*)ppJobEntries,
                         lpdwJobs))
    {
        return FALSE;
    }

    pJobEntry = (PFAX_JOB_ENTRY_EXW) *ppJobEntries;
    for (i = 0; i < *lpdwJobs; i++)
    {
        if (!ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].lpctstrRecipientNumber )            ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].lpctstrRecipientName )              ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].lpctstrSenderUserName )             ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].lpctstrBillingCode )                ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].lpctstrDocumentName )               ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].lpctstrSubject )                    ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].pStatus->lpctstrExtendedStatus )    ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].pStatus->lpctstrTsid )              ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].pStatus->lpctstrCsid )              ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].pStatus->lpctstrDeviceName )        ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].pStatus->lpctstrCallerID )          ||
            !ConvertUnicodeStringInPlace( (LPWSTR) pJobEntry[i].pStatus->lpctstrRoutingInfo ))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*ppJobEntries);
            return FALSE;
        }
    }
    return TRUE;
}   // FaxEnumJobsExA



BOOL FaxEnumJobsExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwJobTypes,
    OUT PFAX_JOB_ENTRY_EXW *ppJobEntries,
    OUT LPDWORD             lpdwJobs
)
{
    error_status_t ec;
    DWORD dwBufferSize = 0;
    PFAX_JOB_ENTRY_EXW lpJobEntry;
    PFAX_JOB_STATUSW lpFaxStatus;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumJobsExW"));

    Assert (ppJobEntries && lpdwJobs);

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (dwJobTypes & JT_BROADCAST)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("dwJobTypes & JT_BROADCAST."));
        return FALSE;
    }

    if (!(dwJobTypes & JT_SEND      ||
         dwJobTypes & JT_RECEIVE    ||
         dwJobTypes & JT_ROUTING))
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *lpdwJobs = 0;
    *ppJobEntries = NULL;
    //
    // Call RPC function.
    //
    __try
    {
        ec = FAX_EnumJobsEx  (FH_FAX_HANDLE(hFaxHandle),
                              dwJobTypes,
                              (LPBYTE*)ppJobEntries,
                              &dwBufferSize,
                              lpdwJobs
                             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FaxEnumJobsExW. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    //
    // Unpack Buffer
    //
    lpJobEntry = (PFAX_JOB_ENTRY_EXW) *ppJobEntries;
    lpFaxStatus = (PFAX_JOB_STATUSW) ((LPBYTE)*ppJobEntries + (sizeof(FAX_JOB_ENTRY_EXW) * (*lpdwJobs)));
    for (i = 0; i < *lpdwJobs; i++)
    {
        lpJobEntry[i].pStatus = &lpFaxStatus[i];

        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].lpctstrRecipientNumber );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].lpctstrRecipientName );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].lpctstrSenderUserName );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].lpctstrBillingCode );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].lpctstrDocumentName );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].lpctstrSubject );

        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].pStatus->lpctstrExtendedStatus );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].pStatus->lpctstrTsid );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].pStatus->lpctstrCsid );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].pStatus->lpctstrDeviceName );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].pStatus->lpctstrCallerID );
        FixupStringPtrW( &lpJobEntry, lpJobEntry[i].pStatus->lpctstrRoutingInfo );
    }

    return TRUE;
}

//********************************************
//*               Archive jobs
//********************************************

WINFAXAPI
BOOL
WINAPI
FaxStartMessagesEnum (
    IN  HANDLE                  hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PHANDLE                 phEnum
)
/*++

Routine name : FaxStartMessagesEnum

Routine description:

    A fax client application calls the FaxStartMessagesEnum
    function to start enumerating messages in one of the archives

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Specifies a fax server handle returned by a call
                            to the FaxConnectFaxServer function.

    Folder          [in ] - The type of the archive where the message resides.
                            FAX_MESSAGE_FOLDER_QUEUE is an invalid
                            value for this parameter.

    phEnum          [out] - Points to an enumeration handle return value.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    PHANDLE_ENTRY  pHandleEntry;
    HANDLE         hServerContext;
    DEBUG_FUNCTION_NAME(TEXT("FaxStartMessagesEnum"));

    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }
    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(DEBUG_ERR, _T("Bad folder specified (%ld)"), Folder);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    //
    // Create a local handle that will hold the one returned from the service
    //
    pHandleEntry = CreateNewMsgEnumHandle( FH_DATA(hFaxHandle));
    if (!pHandleEntry)
    {
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't create local handle entry (ec = %ld)"),
            ec);
        SetLastError(ec);
        return FALSE;
    }
    __try
    {
        ec = FAX_StartMessagesEnum(
                    FH_FAX_HANDLE(hFaxHandle),
                    Folder,
                    &hServerContext
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_StartMessagesEnum. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        //
        // Free local handle
        //
        DumpRPCExtendedStatus ();
        CloseFaxHandle( pHandleEntry );
        SetLastError(ec);
        return FALSE;
    }
    //
    // Store retuned handle (Fax Server context handle) in our local handle
    //
    FH_MSG_ENUM_HANDLE(pHandleEntry) = hServerContext;
    //
    // Return our local handle instead of server's handle
    //
    *phEnum = pHandleEntry;
    return TRUE;
}   // FaxStartMessagesEnum

WINFAXAPI
BOOL
WINAPI
FaxEndMessagesEnum (
    IN  HANDLE  hEnum
)
/*++

Routine name : FaxEndMessagesEnum

Routine description:

    A fax client application calls the FaxEndMessagesEnum function to stop
    enumerating messages in one of the archives.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hEnum   [in] - The enumeration handle value.
                   This value is obtained by calling FaxStartMessagesEnum.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    HANDLE hMsgEnumContext;
    PHANDLE_ENTRY pHandleEntry = (PHANDLE_ENTRY) hEnum;
    DEBUG_FUNCTION_NAME(TEXT("FaxEndMessagesEnum"));

    if (!ValidateFaxHandle(hEnum, FHT_MSGENUM))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }
    //
    // Retrieved the RPC context handle of the message enumeration from the handle object we got.
    //
    hMsgEnumContext = FH_MSG_ENUM_HANDLE(hEnum);
    __try
    {
        //
        // Attempt to tell the server we are shutting down this enumeration context
        //
        ec = FAX_EndMessagesEnum(&hMsgEnumContext);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EndMessagesEnum. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS == ec)
    {
        //
        // Free local handle object
        //
        DumpRPCExtendedStatus ();
        CloseFaxHandle( pHandleEntry );
        return TRUE;
    }
    //
    // Failure
    //
    SetLastError (ec);
    return FALSE;
}   // FaxEndMessagesEnum

WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesA (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEA  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
)
/*++

Routine name : FaxEnumMessagesA

Routine description:

    A fax client application calls the FaxEnumMessages function to enumerate
    messages in one of the archives.

    This function is incremental. That is, it uses an internal context cursor to
    point to the next set of messages to retrieve for each call.

    The cursor is set to point to the begging of the messages in the archive after a
    successful call to FaxStartMessagesEnum.

    Each successful call to FaxEnumMessages advances the cursor by the number of
    messages retrieved.

    Once the cursor reaches the end of the enumeration,
    the function fails with ERROR_NO_DATA error code.
    The FaxEndMessagesEnum function should be called then.

    This is the ANSI version.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hEnum                       [in ] - The enumeration handle value.
                                        This value is obtained by calling
                                        FAX_StartMessagesEnum.

    dwNumMessages               [in ] - A DWORD value indicating the maximal number
                                        of messages the caller requires to enumerate.
                                        This value cannot be zero.

    ppMsgs                      [out] - A pointer to a buffer of FAX_MESSAGE structures.
                                        This buffer will contain lpdwReturnedMsgs entries.
                                        The buffer will be allocated by the function
                                        and the caller must free it.

    lpdwReturnedMsgs            [out] - Pointer to a DWORD value indicating the actual
                                        number of messages retrieved.
                                        This value cannot exceed dwNumMessages.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD i;
    PFAX_MESSAGEW *ppWMsgs = (PFAX_MESSAGEW*)ppMsgs;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumMessagesA"));

    //
    // Call UNICODE function.
    //
    if (!FaxEnumMessagesW (hEnum, dwNumMessages, ppWMsgs, lpdwReturnedMsgs))
    {
        return FALSE;
    }
    //
    // Convert all strings to ANSI
    //
    for (i = 0; i < *lpdwReturnedMsgs; i++)
    {
        if (!ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrRecipientNumber)     ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrRecipientName)       ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrSenderNumber)        ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrSenderName)          ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrTsid)                ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrCsid)                ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrSenderUserName)      ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrBillingCode)         ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrDeviceName)          ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrDocumentName)        ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrSubject)             ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrCallerID)            ||
            !ConvertUnicodeStringInPlace ((*ppWMsgs)[i].lpctstrRoutingInfo))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (*ppMsgs);
            return FALSE;
        }
    }
    return TRUE;
}   // FaxEnumMessagesA

WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesW (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEW  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
)
/*++

Routine name : FaxEnumMessagesW

Routine description:

    A fax client application calls the FaxEnumMessages function to enumerate
    messages in one of the archives.

    This function is incremental. That is, it uses an internal context cursor to
    point to the next set of messages to retrieve for each call.

    The cursor is set to point to the begging of the messages in the archive after a
    successful call to FaxStartMessagesEnum.

    Each successful call to FaxEnumMessages advances the cursor by the number of
    messages retrieved.

    Once the cursor reaches the end of the enumeration,
    the function fails with ERROR_NO_DATA error code.
    The FaxEndMessagesEnum function should be called then.

    This is the UNICODE version.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hEnum                       [in ] - The enumeration handle value.
                                        This value is obtained by calling
                                        FAX_StartMessagesEnum.

    dwNumMessages               [in ] - A DWORD value indicating the maximal number
                                        of messages the caller requires to enumerate.
                                        This value cannot be zero.

    ppMsgs                      [out] - A pointer to a buffer of FAX_MESSAGE structures.
                                        This buffer will contain lpdwReturnedMsgs entries.
                                        The buffer will be allocated by the function
                                        and the caller must free it.

    lpdwReturnedMsgs            [out] - Pointer to a DWORD value indicating the actual
                                        number of messages retrieved.
                                        This value cannot exceed dwNumMessages.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD dwBufferSize = 0;
    error_status_t ec;
    DWORD dwIndex;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumMessagesW"));

    if (!ValidateFaxHandle(hEnum, FHT_MSGENUM))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!dwNumMessages || !ppMsgs || !lpdwReturnedMsgs)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("At least one of the parameters is NULL."));
        return FALSE;
    }
    *ppMsgs = NULL;

    __try
    {
        ec = FAX_EnumMessages(
            FH_MSG_ENUM_HANDLE(hEnum),  // Enumeration handle
            dwNumMessages,              // Maximal number of messages to get
            (LPBYTE*)ppMsgs,            // Pointer to messages buffer
            &dwBufferSize,              // Size of allocated buffer
            lpdwReturnedMsgs            // Number of messages actually returned
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumMessages. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }
    for (dwIndex = 0; dwIndex < *lpdwReturnedMsgs; dwIndex++)
    {
        PFAX_MESSAGEW pCurMsg = &(((PFAX_MESSAGEW)(*ppMsgs))[dwIndex]);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrRecipientNumber);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrRecipientName);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrSenderNumber);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrSenderName);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrTsid);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrCsid);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrSenderUserName);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrBillingCode);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrDeviceName);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrDocumentName);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrSubject);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrCallerID);
        FixupStringPtrW (ppMsgs, pCurMsg->lpctstrRoutingInfo);
    }
    return TRUE;
}   // FaxEnumMessagesW

#ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxEnumMessagesX (
    IN  HANDLE          hEnum,
    IN  DWORD           dwNumMessages,
    OUT PFAX_MESSAGEW  *ppMsgs,
    OUT LPDWORD         lpdwReturnedMsgs
)
{
    UNREFERENCED_PARAMETER (hEnum);
    UNREFERENCED_PARAMETER (dwNumMessages);
    UNREFERENCED_PARAMETER (ppMsgs);
    UNREFERENCED_PARAMETER (lpdwReturnedMsgs);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxEnumMessagesX

#endif // #ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetMessageA (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEA          *ppMsg
)
/*++

Routine name : FaxGetMessageA

Routine description:

    Removes a message from an archive.

    ANSI version.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Handle to the fax server
    dwlMessageId    [in ] - Unique message id
    Folder          [in ] - Archive folder
    ppMsg           [out] - Pointer to buffer to hold message information

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    PFAX_MESSAGEW *ppWMsg = (PFAX_MESSAGEW*)ppMsg;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetMessageA"));
    //
    // Call UNICODE function.
    //
    if (!FaxGetMessageW (hFaxHandle, dwlMessageId, Folder, ppWMsg))
    {
        return FALSE;
    }
    //
    // Convert all strings to ANSI
    //
    if (!ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrRecipientNumber)    ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrRecipientName)      ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrSenderNumber)       ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrSenderName)         ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrTsid)               ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrCsid)               ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrSenderUserName)     ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrBillingCode)        ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrDeviceName)         ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrDocumentName)       ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrSubject)            ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrCallerID)           ||
        !ConvertUnicodeStringInPlace ((*ppWMsg)->lpctstrRoutingInfo))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*ppMsg);
        return FALSE;
    }
    (*ppMsg)->dwSizeOfStruct = sizeof(FAX_MESSAGEA);
    return TRUE;
}   // FaxGetMessageA


WINFAXAPI
BOOL
WINAPI
FaxGetMessageW (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEW          *ppMsg
)
/*++

Routine name : FaxGetMessageW

Routine description:

    Removes a message from an archive.

    UNICODE version.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Handle to the fax server
    dwlMessageId    [in ] - Unique message id
    Folder          [in ] - Archive folder
    ppMsg           [out] - Pointer to buffer to hold message information

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD dwBufferSize = 0;
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetMessageW"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }
    if (!ppMsg || !dwlMessageId)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppMsg OR dwlMessageId is NULL."));
        return FALSE;
    }
    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    *ppMsg = NULL;

    __try
    {
        ec = FAX_GetMessage(
                    FH_FAX_HANDLE(hFaxHandle),
                    dwlMessageId,
                    Folder,
                    (LPBYTE*)ppMsg,
                    &dwBufferSize);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetMessage. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrRecipientNumber);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrRecipientName);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrSenderNumber);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrSenderName);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrTsid);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrCsid);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrSenderUserName);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrBillingCode);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrDeviceName);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrDocumentName);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrSubject);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrCallerID);
    FixupStringPtrW (ppMsg, (*ppMsg)->lpctstrRoutingInfo);
    return TRUE;
}   // FaxGetMessageW

#ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetMessageX (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    OUT PFAX_MESSAGEW          *ppMsg
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwlMessageId);
    UNREFERENCED_PARAMETER (Folder);
    UNREFERENCED_PARAMETER (ppMsg);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxGetMessageX

#endif // #ifndef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxRemoveMessage (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder
)
/*++

Routine name : FaxRemoveMessage

Routine description:

    Removes a message from an archive

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in] - Handle to the fax server
    dwlMessageId    [in] - Unique message id
    Folder          [in] - Archive folder

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxRemoveMessage"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }
    if (!dwlMessageId)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("dwlMessageId is ZERO."));
        return FALSE;
    }

    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    __try
    {
        ec = FAX_RemoveMessage(
                    FH_FAX_HANDLE(hFaxHandle),
                    dwlMessageId,
                    Folder);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_RemoveMessage. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }
    return TRUE;
}   // FaxRemoveMessage


WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiff (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCTSTR                 lpctstrFilePath
)
/*++

Routine name : FaxGetMessageTiff

Routine description:

    Retrieves a message TIFF from the archive / queue

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in] - handle to fax server
    dwlMessageId    [in] - Unique message id
    Folder          [in] - Archive / queue folder
    lpctstrFilePath [in] - Path to local file to receive TIFF image

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD  ec = ERROR_SUCCESS;
    DWORD  ec2 = ERROR_SUCCESS;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hCopyContext = NULL;
    PBYTE  aBuffer=NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetMessageTiff"));

    //
    //  parameters validation
    //

    if ((FAX_MESSAGE_FOLDER_QUEUE     != Folder) &&
        (FAX_MESSAGE_FOLDER_INBOX     != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (!dwlMessageId)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("zero msg id specified"));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError (ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    
    //
    // start FaxGetMessageTiff implementation
    //
    
    
    //
    // Try to open local file first
    //
    hFile = SafeCreateFile (
                lpctstrFilePath,
                GENERIC_WRITE,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL);
    if ( INVALID_HANDLE_VALUE == hFile )
    {
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Opening %s for write failed (ec: %ld)"),
            lpctstrFilePath,
            ec);
        if (ERROR_ACCESS_DENIED == ec ||
            ERROR_SHARING_VIOLATION == ec)
        {
            ec = FAX_ERR_FILE_ACCESS_DENIED;
        }
        SetLastError (ec);
        return FALSE;
    }

    aBuffer = (PBYTE)MemAlloc(RPC_COPY_BUFFER_SIZE);
    if (NULL == aBuffer)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate memory for read/write buffer."));
        goto exit;
    }

    //
    // Acquire copy context handle
    //
    __try
    {
        ec = FAX_StartCopyMessageFromServer (
                FH_FAX_HANDLE(hFaxHandle),
                dwlMessageId,
                Folder,
                &hCopyContext);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_StartCopyMessageFromServer. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_StartCopyMessageFromServer failed (ec: %ld)"),
            ec);
        goto exit;
    }

    //
    // Start copy iteration(s)
    //
    for (;;)
    {
        //
        // Set dwBytesToWrite to buffer size so that the RPC layer allocates
        // dwBytesToWrite bytes localy on the server and copies them back to us.
        //
        DWORD dwBytesToWrite = sizeof (BYTE) * RPC_COPY_BUFFER_SIZE;    // size of aBuffer in bytes
        DWORD dwBytesWritten;
        //
        // Move bytes from server via RPC
        //
        __try
        {
            ec = FAX_ReadFile (
                    hCopyContext,
                    sizeof (BYTE) * RPC_COPY_BUFFER_SIZE, // size of aBuffer in bytes
                    aBuffer,
                    &dwBytesToWrite);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // For some reason we got an exception.
            //
            ec = GetExceptionCode();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Exception on RPC call to FAX_ReadFile. (ec: %ld)"),
                ec);
        }

        if (ERROR_SUCCESS != ec)
        {
            DumpRPCExtendedStatus ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_ReadFile failed (ec: %ld)"),
                ec);
            goto exit;
        }
        if (0 == dwBytesToWrite)
        {
            //
            // No more bytes to copy from the server - stop the loop
            //
            break;
        }
        //
        // Put data in our local file
        //
        if (!WriteFile (hFile,
                        aBuffer,
                        dwBytesToWrite,
                        &dwBytesWritten,
                        NULL))
        {
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteFile failed (ec: %ld)"),
                ec);
            goto exit;
        }

        if (dwBytesWritten != dwBytesToWrite)
        {
            //
            // Strange situation
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteFile was asked to write %ld bytes but wrote only %ld bytes"),
                dwBytesToWrite,
                dwBytesWritten);
            ec = ERROR_GEN_FAILURE;
            goto exit;
        }
    }   // End of copy iteration

    Assert (ERROR_SUCCESS == ec);

exit:

    if (INVALID_HANDLE_VALUE != hFile)
    {
        //
        // Close the open file
        //
        if (!CloseHandle (hFile))
        {
            ec2 = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle failed (ec: %ld)"),
                ec2);
        }

        if (ERROR_SUCCESS == ec)
        {
            //
            // If we had an error during wrapup, propogate it out
            //
            ec = ec2;
        }
    }
    if (NULL != hCopyContext)
    {
        //
        // Close RPC copy context
        //
        __try
        {
            ec2 = FAX_EndCopy (&hCopyContext);
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // For some reason we got an exception.
            //
            ec2 = GetExceptionCode();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Exception on RPC call to FAX_EndCopy. (ec: %ld)"),
                ec2);
        }
        if (ERROR_SUCCESS != ec2)
        {
            DumpRPCExtendedStatus ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_EndCopy failed (ec: %ld)"),
                ec2);
        }

        if (ERROR_SUCCESS == ec)
        {
            //
            // If we had an error during wrapup, propogate it out
            //
            ec = ec2;
        }
    }

    if (NULL != aBuffer)
    {
        MemFree(aBuffer);
    }

    //
    // On down-level clients (<XP), the default viewer (Kodak imaging) can't
    // display files with more than 54 tags. So call TiffLimitTagNumber, which
    // will cut down any tags beyond 54.
    //
    if (ec == ERROR_SUCCESS)
    {
        if (!IsWinXPOS())
        {
            if (!TiffLimitTagNumber(lpctstrFilePath, 54))
            {
                ec = GetLastError();
                DebugPrintEx(DEBUG_ERR, TEXT("TiffLimitTagNumber failed, ec=%d"), ec);
            }
        }
    }

    if (ERROR_SUCCESS != ec)
    {
        //
        // Some error occured - delete the local file (if exists at all)
        //
        if (!DeleteFile (lpctstrFilePath))
        {
            DWORD dwRes = GetLastError ();
            if (ERROR_FILE_NOT_FOUND != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("DeleteFile (%s) return error %ld"),
                    lpctstrFilePath,
                    dwRes);
            }
        }
        SetLastError (ec);
        return FALSE;
    }

    return TRUE;
}   // FaxGetMessageTiff

#ifdef UNICODE

WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiffA (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCSTR                  lpctstrFilePath
)
/*++

Routine name : FaxGetMessageTiffA

Routine description:

    Retrieves a message TIFF from the archive / queue.

    ANSI version for NT clients

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in] - handle to fax server
    dwlMessageId    [in] - Unique message id
    Folder          [in] - Archive / queue folder
    lpctstrFilePath [in] - Path to local file to receive TIFF image

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    LPWSTR lpwstrFilePath;
    BOOL   bRes;

    lpwstrFilePath = AnsiStringToUnicodeString (lpctstrFilePath);
    if (!lpwstrFilePath)
    {
        return FALSE;
    }
    bRes = FaxGetMessageTiffW (hFaxHandle, dwlMessageId, Folder, lpwstrFilePath);
    MemFree ((LPVOID)lpwstrFilePath);
    return bRes;
}   // FaxGetMessageTiffA

#else

WINFAXAPI
BOOL
WINAPI
FaxGetMessageTiffW (
    IN  HANDLE                  hFaxHandle,
    IN  DWORDLONG               dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER Folder,
    IN  LPCWSTR                 lpctstrFilePath
)
{
    UNREFERENCED_PARAMETER(hFaxHandle);
    UNREFERENCED_PARAMETER(dwlMessageId);
    UNREFERENCED_PARAMETER(Folder);
    UNREFERENCED_PARAMETER(lpctstrFilePath);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxGetMessageTiffW


#endif


//********************************************
//*   Recipients limit in a single broadcast
//********************************************
WINFAXAPI
BOOL
FaxSetRecipientsLimit(
    IN HANDLE   hFaxHandle,
    IN DWORD    dwRecipientsLimit
)
/*++
Routine name : FaxSetRecipientsLimit

Routine description:
    A fax client application calls the FaxSetRecipientsLimit to set the 
    recipients limit of a single broadcast job.

Arguments:
    hFaxHandle                  - unused
    dwRecipientsLimit           - the recipients limit to set
    
Return Value:
    Standard Win32 error code
--*/
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwRecipientsLimit);

    SetLastError(ERROR_NOT_SUPPORTED);
    return FALSE;
} // FaxSetRecipientsLimit


WINFAXAPI
BOOL
FaxGetRecipientsLimit(
    IN HANDLE   hFaxHandle,
    OUT LPDWORD lpdwRecipientsLimit
)
/*++
Routine name : FaxGetRecipientsLimit

Routine description:
    A fax client application calls the FaxGetRecipientsLimit to get the 
    recipients limit of a single broadcast job.

Arguments:
    hFaxHandle                  - handle to fax server
    lpdwRecipientsLimit         - pointer to a DWORD to receive the recipients limit
    
Return Value:
    Standard Win32 error code
--*/
{
    DWORD ec;
    DWORD dwRecipientsLimit;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetRecipientsLimit"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {        
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }    

    if (NULL == lpdwRecipientsLimit)
    {        
        DebugPrintEx(DEBUG_ERR, _T("lpdwRecipientsLimit is NULL."));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (FAX_API_VERSION_2 > FH_SERVER_VER(hFaxHandle))
    {
        //
        // Servers of API version 0,1 don't support FAX_GetRecipientsLimit
        // These servers have no recipients limit.
        //
        DebugPrintEx(DEBUG_MSG, 
                     _T("Server version is %ld - No recipients limit"), 
                     FH_SERVER_VER(hFaxHandle));
        *lpdwRecipientsLimit = 0; // No recipients limit        
        return TRUE;
    }

    //
    // Call RPC function.
    //
    __try
    {
        ec = FAX_GetRecipientsLimit(
            FH_FAX_HANDLE(hFaxHandle),
            &dwRecipientsLimit);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetRecipientsLimit. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }
    *lpdwRecipientsLimit = dwRecipientsLimit;
    
    return TRUE;
} // FaxGetRecipientsLimit


WINFAXAPI
BOOL
FaxGetServerSKU(
    IN HANDLE   hFaxHandle,
    OUT PRODUCT_SKU_TYPE* pServerSKU
)
/*++
Routine name : FaxGetServerSKU

Routine description:
    A fax client application calls the FaxGetRecipientsLimit to get the 
    recipients limit of a single broadcast job.

Arguments:
    hFaxHandle                  - handle to fax server
    pServerSKU                  - pointer to a PRODUCT_SKU_TYPE to receive the fax server SKU
    
Return Value:
    Standard Win32 error code
--*/
{
    DWORD ec;
    PRODUCT_SKU_TYPE ServerSKU;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetServerSKU"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {        
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }    

    if (NULL == pServerSKU)
    {        
        DebugPrintEx(DEBUG_ERR, _T("pServerSKU is NULL."));
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (FAX_API_VERSION_2 > FH_SERVER_VER(hFaxHandle))
    {
        //
        // Servers of API version 0,1 don't support FaxGetServerSKU     
        // Call FaxEnumOutboundRules() and check the error code
        //
        DWORD dwNumRules;
        PFAX_OUTBOUND_ROUTING_RULE pRule = NULL;
        if(!FaxEnumOutboundRules(hFaxHandle, &pRule, &dwNumRules))
        {
            ec = GetLastError();
            DebugPrintEx(DEBUG_WRN, _T("FaxEnumOutboundRules() failed with %ld)"), ec);
            if(FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU == ec)
            {
                //
                // Desktop SKU, return PRO
                //
                *pServerSKU = PRODUCT_SKU_PROFESSIONAL;             
            }
            else
            {               
                *pServerSKU =  PRODUCT_SKU_UNKNOWN;
            }
        }
        else
        {
            //
            // Server SKU, return PRODUCT_SKU_DATA_CENTER
            //
            *pServerSKU = PRODUCT_SKU_DATA_CENTER;
            FaxFreeBuffer(pRule);
        }    
        return TRUE;
    }
    

    //
    // The server supports FaxGetServerSKU, Call RPC function.
    //
    __try
    {
        ec = FAX_GetServerSKU(
            FH_FAX_HANDLE(hFaxHandle),
            &ServerSKU);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetServerSKU. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }
    *pServerSKU = ServerSKU;
    return TRUE;
} // FaxGetServerSKU


WINFAXAPI
BOOL
FaxCheckValidFaxFolder(
    IN HANDLE   hFaxHandle,
    IN LPCWSTR  lpcwstrPath
)
/*++
Routine name : FaxCheckValidFaxFolder

Routine description:
    Used by fax client application to check if a given path is accessible (valid for use)
    by the fax service.

Arguments:
    hFaxHandle  - handle to fax server
    lpcwstrPath	- Path to check    
    
Return Value:

    TRUE if folder if path can be used by the fax service.
    FALSE otherwise, refer to thread's last error for error code.
    
--*/
{
    DWORD ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxCheckValidFaxFolder"));

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {        
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }    

    if (FAX_API_VERSION_2 > FH_SERVER_VER(hFaxHandle))
    {
        //
        // Servers of API version 0,1 don't support FaxCheckValidFaxFolder     
        //
        return ERROR_NOT_SUPPORTED;
    }        
    //
    // The server supports FaxCheckValidFaxFolder, Call RPC function.
    //
    __try
    {
        ec = FAX_CheckValidFaxFolder(
            FH_FAX_HANDLE(hFaxHandle),
            lpcwstrPath);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_CheckValidFaxFolder. (ec: %ld)"),
            ec);
    }

    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError (ec);
        return FALSE;
    }
    return TRUE;
} // FaxCheckValidFaxFolder
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\print.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the print specific WINFAX API functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:
     4-Dec-1999 Danl Use fixed GetFaxPrinterName.

--*/

#include "faxapi.h"
#include "faxreg.h"
#include "faxutil.h"
#pragma hdrstop

#include <mbstring.h>


#define NIL _T('\0')


BOOL
WINAPI
FaxStartPrintJob(
    IN  LPCTSTR                  PrinterName,
    IN  const FAX_PRINT_INFO     *PrintInfo,
    OUT LPDWORD                  FaxJobId,
    OUT PFAX_CONTEXT_INFO        FaxContextInfo
    )
/*++

Routine Description:

    Starts a print job for the specified printer.  This
    function provides functionality beyond what the caller
    can provide by using StartDoc().  This function disables
    the display of the fax send wizard and also passes along
    the information that would otherwise be gathered by the
    fax wizard ui.

Arguments:

    PrinterName         - Fax printer name (must be a fax printer)
    PrintInfo           - Fax print information
    FaxJobId            - Job id of the resulting print job
    FaxContextInfo      - context information including hdc

Return Value:

    TRUE for success.
    FALSE for failure.

--*/
{
    return FaxStartPrintJob2 ( PrinterName,
                               PrintInfo,
                               0, // Default resolution
                               FaxJobId,
                               FaxContextInfo);
}

#ifdef UNICODE
BOOL
WINAPI
FaxStartPrintJobA(
    IN  LPCSTR                    PrinterName,
    IN  const FAX_PRINT_INFOA     *PrintInfo,
    OUT LPDWORD                   FaxJobId,
    OUT FAX_CONTEXT_INFOA         *FaxContextInfo
    )
/*++

Routine Description:

    Starts a print job for the specified printer.  This
    function provides functionality beyond what the caller
    can provide by using StartDoc().  This function disables
    the display of the fax send wizard and also passes along
    the information that would otherwise be gathered by the
    fax wizard ui.

Arguments:

    PrinterName         - Fax printer name (must be a fax printer)
    PrintInfo           - Fax print information
    FaxJobId            - Job id of the resulting print job
    FaxContextInfo      - device context information (hdc, etc.)

Return Value:

    TRUE for success.
    FALSE for failure.

--*/
{
    return FaxStartPrintJob2A ( PrinterName,
                                PrintInfo,
                                0, // Default resolution
                                FaxJobId,
                                FaxContextInfo);;
}
#else
BOOL
WINAPI
FaxStartPrintJobW(
    IN  LPCWSTR                   PrinterName,
    IN  const FAX_PRINT_INFOW     *PrintInfo,
    OUT LPDWORD                   FaxJobId,
    OUT PFAX_CONTEXT_INFOW        FaxContextInfo
    )

{
    UNREFERENCED_PARAMETER(PrinterName);
    UNREFERENCED_PARAMETER(PrintInfo);
    UNREFERENCED_PARAMETER(FaxJobId);
    UNREFERENCED_PARAMETER(FaxContextInfo);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;

}
#endif


PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    )

/*++

Routine Description:

    Wrapper function for spooler API GetJob

Arguments:

    hPrinter - Handle to the printer object
    level - Level of JOB_INFO structure interested
    jobId - Specifies the job ID

Return Value:

    Pointer to a JOB_INFO structure, NULL if there is an error

--*/

{
    PBYTE   pJobInfo = NULL;
    DWORD   cbNeeded;

    if (!GetJob(hPrinter, jobId, level, NULL, 0, &cbNeeded) &&
        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
        (pJobInfo = (PBYTE)MemAlloc(cbNeeded)) &&
        GetJob(hPrinter, jobId, level, pJobInfo, cbNeeded, &cbNeeded))
    {
        return pJobInfo;
    }

    MemFree(pJobInfo);
    return NULL;
}


LPTSTR
GetCpField(
    HKEY hKey,
    LPTSTR SubKey
    )

/*++

Routine Description:

    Retrieves the data for a coverpage field from
    the registry.

Arguments:

    hKey    - Registry handle
    SubKey  - Subkey name

Return Value:

    Pointer to the coverpage field data.

--*/

{
    LONG rVal;
    DWORD RegSize=0;
    DWORD RegType;
    LPBYTE Buffer;


    rVal = RegQueryValueEx( hKey, SubKey, 0, &RegType, NULL, &RegSize );
    if (rVal != ERROR_SUCCESS) {
        return NULL;
    }

    Buffer = (LPBYTE) MemAlloc( RegSize );
    if (!Buffer) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return NULL;
    }

    rVal = RegQueryValueEx( hKey, SubKey, 0, &RegType, Buffer, &RegSize );
    if (rVal != ERROR_SUCCESS) {
        MemFree( Buffer );
        return NULL;
    }

    return (LPTSTR) Buffer;
}

BOOL
GetCpFields(
    PCOVERPAGEFIELDS CpFields
    )

/*++

Routine Description:

    Initializes the coverpage field structure and
    fills in the sender information from the registry.

    This function actually loads only the sender fields.

Arguments:

    CpFields    - Pointer to a coverpage field structure.

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HKEY hKey;
    LONG rVal;


    rVal = RegOpenKey(
        HKEY_CURRENT_USER,
        REGKEY_FAX_USERINFO,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        return FALSE;
    }

    ZeroMemory( CpFields, sizeof(COVERPAGEFIELDS) );
    CpFields->ThisStructSize = sizeof(COVERPAGEFIELDS);

    //
    // sender fields
    //

    CpFields->SdrName           = GetCpField( hKey, REGVAL_FULLNAME     );
    CpFields->SdrFaxNumber      = GetCpField( hKey, REGVAL_FAX_NUMBER   );
    CpFields->SdrCompany        = GetCpField( hKey, REGVAL_COMPANY      );
    CpFields->SdrAddress        = GetCpField( hKey, REGVAL_ADDRESS      );
    CpFields->SdrTitle          = GetCpField( hKey, REGVAL_TITLE        );
    CpFields->SdrDepartment     = GetCpField( hKey, REGVAL_DEPT         );
    CpFields->SdrOfficeLocation = GetCpField( hKey, REGVAL_OFFICE       );
    CpFields->SdrHomePhone      = GetCpField( hKey, REGVAL_HOME_PHONE   );
    CpFields->SdrOfficePhone    = GetCpField( hKey, REGVAL_OFFICE_PHONE );
	CpFields->SdrEmail			= GetCpField( hKey, REGVAL_MAILBOX		);

    RegCloseKey( hKey );

    return TRUE;
}


VOID
FreeCpFields(
    PCOVERPAGEFIELDS CpFields
    )

/*++

Routine Description:

    Frees all memory associated with a coverpage field structure.


Arguments:

    CpFields    - Pointer to a coverpage field structure.

Return Value:

    None.

--*/

{
    DWORD i;
    LPBYTE *p;

    for (i = 0; i < NUM_INSERTION_TAGS; i++) {
        p = (LPBYTE *) ((ULONG_PTR)CpFields + sizeof(LPTSTR)*(i+1));
        if (p && *p) MemFree( *p );
    }
}


BOOL
WINAPI
FaxPrintCoverPage(
    IN const FAX_CONTEXT_INFO    *FaxContextInfo,
    IN const FAX_COVERPAGE_INFO *CoverPageInfo
    )

/*++

Routine Description:

    Prints a coverpage into the printer DC provided.

Arguments:

    FaxContextInfo  - contains servername, Printer DC
    CoverPageInfo   - Cover page information

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    TCHAR CpName[MAX_PATH];
    TCHAR Buffer[MAX_PATH];
    TCHAR TBuffer[MAX_PATH];
    COVERPAGEFIELDS CpFields = {0};
    COVDOCINFO CovDocInfo;
    DWORD dwDateTimeLen;
    DWORD cch;
    LPTSTR s;
    DWORD ec = 0;
    LPCTSTR *src;
    LPCTSTR *dst;
    DWORD i;
    LPCTSTR lpctstrCoverPage,lpctstrServerName;
    BOOL    retVal = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("FaxPrintCoverPage"));

    //
    // do a little argument validation
    //
    if (CoverPageInfo == NULL || CoverPageInfo->SizeOfStruct != sizeof(FAX_COVERPAGE_INFOW) ||
        FaxContextInfo == NULL || FaxContextInfo->hDC == NULL ||
        FaxContextInfo->SizeOfStruct != sizeof (FAX_CONTEXT_INFOW) )
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CoverPageInfo is NULL or Size mismatch.")
                     );
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    lpctstrCoverPage =  CoverPageInfo->CoverPageName;
    lpctstrServerName = FaxContextInfo->ServerName;
    if (!ValidateCoverpage(lpctstrCoverPage,
                           lpctstrServerName,
                           CoverPageInfo->UseServerCoverPage,
                           CpName,
                           ARR_SIZE(CpName)))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("ValidateCoverpage failed. ec = %ld"),
                     GetLastError());
        retVal = FALSE;
        goto exit;
    }

    //
    // get the coverpage fields
    //
    // Initialize the sender fields of CpFields with sender information from the registry
    GetCpFields( &CpFields );

    //
    // fixup the recipient name
    //

    if (CoverPageInfo->RecName)
    {
        if( _tcsncmp(CoverPageInfo->RecName,TEXT("\'"),1) == 0 )
        {
            // The recipient name is single quouted. Copy only the string inside the quotes.
            _tcsncpy(Buffer, _tcsinc(CoverPageInfo->RecName), ARR_SIZE(Buffer)-1);
            TCHAR* eos = _tcsrchr(Buffer,TEXT('\0'));
            eos = _tcsdec(Buffer,eos);
            if( eos )
            {
                _tcsnset(eos,TEXT('\0'),1);
            }
        }
        else
        {
            _tcsncpy(Buffer, CoverPageInfo->RecName, ARR_SIZE(Buffer)-1);
        }
    }
    else
    {
        Buffer[0] = 0;
    }

    //
    // fill in the coverpage fields with the
    // data that the caller passed in
    //
    CpFields.RecName      = StringDup(Buffer);
    CpFields.RecFaxNumber = StringDup(CoverPageInfo->RecFaxNumber);
    CpFields.Subject = StringDup(CoverPageInfo->Subject);
    CpFields.Note = StringDup(CoverPageInfo->Note);
    CpFields.NumberOfPages = StringDup(_itot( CoverPageInfo->PageCount, Buffer, 10 ));

    for (i = 0;
         i <= ((LPBYTE)&CoverPageInfo->SdrOfficePhone -(LPBYTE)&CoverPageInfo->RecCompany)/sizeof(LPCTSTR);
         i++)
    {
        src = (LPCTSTR *) ((LPBYTE)&CoverPageInfo->RecCompany + (i*sizeof(LPCTSTR)));
        dst = (LPCTSTR *) ((LPBYTE)&CpFields.RecCompany + (i*sizeof(LPCTSTR)));

        if (*dst)
        {
            MemFree ( (LPBYTE) *dst ) ;
        }

        *dst = (LPCTSTR) StringDup( *src );

    }

    //
    // the time the fax was sent
    //
    GetLocalTime((LPSYSTEMTIME)&CoverPageInfo->TimeSent);
    //
    // dwDataTimeLen is the size of s in characters
    //
    dwDateTimeLen = sizeof(TBuffer) / sizeof (TCHAR);
    s = TBuffer;
    //
    // Get date into s
    //
    GetY2KCompliantDate( LOCALE_USER_DEFAULT, 0, &CoverPageInfo->TimeSent, s, dwDateTimeLen );
    //
    // Advance s past the date string and attempt to append time
    //
    cch = _tcslen( s );
    s += cch;

    if (++cch < dwDateTimeLen)
    {
        *s++ = ' ';
        //
        // DateTimeLen is the decreased by the size of s in characters
        //
        dwDateTimeLen -= cch;
        //
        // Get the time here
        //
        FaxTimeFormat( LOCALE_USER_DEFAULT, 0, &CoverPageInfo->TimeSent, NULL, s, dwDateTimeLen );
    }

    CpFields.TimeSent = StringDup( TBuffer );

    //
    // start the coverpage on a new page
    //

    StartPage( FaxContextInfo->hDC );

    //
    // print the cover page
    //

    ec = PrintCoverPage(
        FaxContextInfo->hDC,
        &CpFields,
        CpName,
        &CovDocInfo
        );

    //
    // end the page
    //

    EndPage( FaxContextInfo->hDC );

    FreeCpFields( &CpFields );

    if (ec != 0)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("PrintCoverPage failed. ec = %ld"),
                     ec);
        SetLastError( ec );
        retVal = FALSE;
        goto exit;
    }

exit:
    return retVal;
}



#ifdef UNICODE

BOOL
WINAPI
FaxPrintCoverPageA(
    IN const FAX_CONTEXT_INFOA   *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOA *CoverPageInfo
    )

/*++

Routine Description:

    Prints a coverpage into the printer DC provided.

Arguments:

    FaxContextInfo  - fax Printer context info (hdc, etc.)
    CoverPageInfo   - Cover page information

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    //
    // assume all fields between Subject and RecName are LPCTSTR's
    //
    #define COUNT_CP_FIELDS ((LPBYTE) &CoverPageInfoW.Subject - (LPBYTE)&CoverPageInfoW.RecName)/sizeof(LPCTSTR)
    DWORD Rval = ERROR_SUCCESS;
    FAX_COVERPAGE_INFOW CoverPageInfoW = {0};
    FAX_CONTEXT_INFOW ContextInfoW = {0};
    LPWSTR ServerName = NULL;
    LPWSTR *d;
    LPSTR *s;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxPrintCoverPageA"));

    if (!FaxContextInfo || !CoverPageInfo ||
        FaxContextInfo->SizeOfStruct != sizeof(FAX_CONTEXT_INFOA) ||
        CoverPageInfo->SizeOfStruct != sizeof(FAX_COVERPAGE_INFOA))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CoverPageInfo is NULL or Size mismatch.")
                     );
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    ContextInfoW.SizeOfStruct         = sizeof(FAX_CONTEXT_INFOW);
    ContextInfoW.hDC                  = FaxContextInfo->hDC;
    if (FaxContextInfo->ServerName[0] != (CHAR)'\0')
    {
        ServerName                        = AnsiStringToUnicodeString( FaxContextInfo->ServerName );
        if (!ServerName && FaxContextInfo->ServerName)
        {
            Rval = ERROR_OUTOFMEMORY;
            goto exit;
        }
        wcscpy(ContextInfoW.ServerName,ServerName);
    }

    CoverPageInfoW.SizeOfStruct       = sizeof(FAX_COVERPAGE_INFOW);
    CoverPageInfoW.UseServerCoverPage = CoverPageInfo->UseServerCoverPage;
    CoverPageInfoW.PageCount          = CoverPageInfo->PageCount;
    CoverPageInfoW.CoverPageName      = AnsiStringToUnicodeString( CoverPageInfo->CoverPageName );
    if (!CoverPageInfoW.CoverPageName && CoverPageInfo->CoverPageName)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    for (i=0;i<=COUNT_CP_FIELDS;i++)
    {
        d = (LPWSTR*) ((ULONG_PTR)&CoverPageInfoW.RecName + i*sizeof(LPCWSTR));
        s = (LPSTR *) ((LPBYTE)&CoverPageInfo->RecName + i*sizeof(LPSTR));
        DebugPrint(( TEXT(" source: 0x%08x  --> dest: 0x%08x \n"), s, d));
        *d = AnsiStringToUnicodeString( *s );
        if (!(*d) && (*s))
        {
            Rval = ERROR_OUTOFMEMORY;
            goto exit;
        }
    }

    CoverPageInfoW.TimeSent       = CoverPageInfo->TimeSent;
    CoverPageInfoW.PageCount      = CoverPageInfo->PageCount;

    if (!FaxPrintCoverPageW(
        &ContextInfoW,
        &CoverPageInfoW
        ))
    {
        Rval = GetLastError();
        goto exit;
    }

    Assert (ERROR_SUCCESS == Rval);

exit:
    if (CoverPageInfoW.CoverPageName)
    {
        MemFree( (LPBYTE) CoverPageInfoW.CoverPageName );
    }

    if (ServerName)
    {
        MemFree( (LPBYTE) ServerName );
    }

    for (i = 0; i < COUNT_CP_FIELDS; i++)
    {
        d = (LPWSTR *)((ULONG_PTR)&CoverPageInfoW.RecName + i*sizeof(LPWSTR));
        if (d && *d)MemFree( (LPBYTE)*d );
    }

    if (ERROR_SUCCESS != Rval)
    {
        SetLastError(Rval);
        return FALSE;
    }
    return TRUE;
}
#else
BOOL
WINAPI
FaxPrintCoverPageW(
    IN const FAX_CONTEXT_INFOW    *FaxContextInfo,
    IN const FAX_COVERPAGE_INFOW *CoverPageInfo
    )
{

    UNREFERENCED_PARAMETER(FaxContextInfo);
    UNREFERENCED_PARAMETER(CoverPageInfo);

    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

#endif


BOOL
WINAPI
FaxStartPrintJob2(
    IN  LPCTSTR                  PrinterName,
    IN  const FAX_PRINT_INFO     *PrintInfo,
    IN  short                    TiffRes,
    OUT LPDWORD                  FaxJobId,
    OUT PFAX_CONTEXT_INFO        FaxContextInfo
    )

/*++

Routine Description:

    Starts a print job for the specified printer.  This
    function provides functionality beyond what the caller
    can provide by using StartDoc().  This function disables
    the display of the fax send wizard and also passes along
    the information that would otherwise be gathered by the
    fax wizard ui.

Arguments:

    PrinterName         - Fax printer name (must be a fax printer)
    PrintInfo           - Fax print information
    TiffRes             - coverpage resolution. 0 for the printer default
    FaxJobId            - Job id of the resulting print job
    FaxContextInfo      - context information including hdc

Return Value:

    TRUE for success.
    FALSE for failure.

--*/

{
    HANDLE hPrinter = NULL;
    PDEVMODE DevMode = NULL;
    PDMPRIVATE DevModePrivate = NULL;
    DOCINFO DocInfo;
    PJOB_INFO_2 JobInfo = NULL;
    PPRINTER_INFO_2 PrinterInfo = NULL;
    DWORD dwNeeded = 0;
    HDC hDC = NULL;
    INT JobId = 0;
    LPTSTR strParameters = NULL;
    LONG Size;
    LPTSTR lptstrFaxPrinterName = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxStartPrintJob"));
    //
    // do a little argument validation
    //
    Assert (TiffRes == 0 || TiffRes == 98 || TiffRes == 196);

    if (PrintInfo == NULL || PrintInfo->SizeOfStruct != sizeof(FAX_PRINT_INFOW) ||
        !FaxJobId || !FaxContextInfo)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("PrintInfo is NULL or Size mismatch.")
                     );
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (PrintInfo->OutputFileName == NULL &&
        (PrintInfo->RecipientNumber == NULL || PrintInfo->RecipientNumber[0] == 0))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("No valid recipient number.")
                     );
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    if (PrintInfo->Reserved)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Reserved field of FAX_PRINT_INFO should be NULL.")
                     );
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    //
    //  if no printer specified, assume they want a local fax printer
    //
    if (!PrinterName)
    {
        lptstrFaxPrinterName = GetFaxPrinterName(NULL); // Need to free this pointer
        if (!lptstrFaxPrinterName)
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetFaxPrinterName returned NULL.")
                     );
            SetLastError(ERROR_INVALID_PRINTER_NAME);
            goto error_exit;
        }
    }
    else
    {
        lptstrFaxPrinterName = (LPTSTR)PrinterName;
        //
        // verify that the printer is a fax printer, the only type allowed
        //
        if (!IsPrinterFaxPrinter( lptstrFaxPrinterName ))
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("IsPrinterFaxPrinter failed. Printer name = %s"),
                     lptstrFaxPrinterName
                     );
            SetLastError( ERROR_INVALID_PRINTER_NAME );
            goto error_exit;
        }
    }

    //
    // open the printer for normal access (this should always work)
    //

    if (!OpenPrinter( lptstrFaxPrinterName, &hPrinter, NULL ))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("OpenPrinter failed. Printer Name = %s , ec = %ld"),
                     lptstrFaxPrinterName,
                     GetLastError());
        goto error_exit;
    }

    //
    // get the fax server's name if the fax printer isn't local
    //
    if (!GetPrinter(hPrinter,2,(LPBYTE)PrinterInfo,0,&dwNeeded))
    {
        PrinterInfo = (PPRINTER_INFO_2)MemAlloc( dwNeeded );
        if (!PrinterInfo)
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("Cant allocate PPRINTER_INFO_2.")
                     );
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto error_exit;
        }
    }

    if (!GetPrinter(hPrinter,2,(LPBYTE)PrinterInfo,dwNeeded,&dwNeeded))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetPrinter failed. ec = %ld"),
                     GetLastError());
        goto error_exit;
    }

    if (PrinterInfo->pServerName)
    {
        if (PrinterInfo->pServerName == _tcsstr (PrinterInfo->pServerName, TEXT("\\\\")))
        {
            //
            // Server name starts with '\\', remove it
            //
            PrinterInfo->pServerName = _tcsninc (PrinterInfo->pServerName, 2);
        }
        _tcscpy(FaxContextInfo->ServerName, PrinterInfo->pServerName);
    }
    else
    {
        FaxContextInfo->ServerName[0] = NIL;
    }

    //
    // get the required size for the DEVMODE
    //

    Size = DocumentProperties( NULL, hPrinter, NULL, NULL, NULL, 0 );
    if (Size <= 0)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("DocumentProperties failed. ec = %ld"),
                     GetLastError());
        goto error_exit;
    }

    //
    // allocate memory for the DEVMODE
    //

    DevMode = (PDEVMODE) MemAlloc( Size );
    if (!DevMode)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Cant allocate DEVMODE.")
                     );
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        goto error_exit;
    }

    //
    // get the default document properties
    //

    if (DocumentProperties( NULL, hPrinter, NULL, DevMode, NULL, DM_OUT_BUFFER ) != IDOK)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("DocumentProperties failed. ec = %ld"),
                     GetLastError());
        goto error_exit;
    }

#ifndef WIN95
    //
    // be sure we are dealing with the correct DEVMODE
    //
    if (DevMode->dmDriverExtra < sizeof(DMPRIVATE))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Invalid DEVMODE, wrong private data size. DevMode->dmDriverExtra = %ld, sizeof(DMPRIVATE) = %ld"),
                     DevMode->dmDriverExtra,
                     sizeof(DMPRIVATE));
        SetLastError(ERROR_INVALID_DATA);
        goto error_exit;
    }

    //
    // set the private DEVMODE pointer
    //

    DevModePrivate = (PDMPRIVATE) ((LPBYTE) DevMode + DevMode->dmSize);

    //
    // set the necessary stuff in the DEVMODE
    //

    DevModePrivate->sendCoverPage     = FALSE;
    DevModePrivate->flags            |= FAXDM_NO_WIZARD;
    DevModePrivate->flags            &= ~FAXDM_DRIVER_DEFAULT;

#endif //#ifndef WIN95
    //
    // Set the necessary reolution
    //
    if (0 != TiffRes)
    {
        //
        // Set the coverpage resolution to the same value as the body tiff file
        //
        DevMode->dmYResolution = TiffRes;
    }

    //
    // create the device context
    //

    hDC = CreateDC( _T("WINSPOOL"), lptstrFaxPrinterName, NULL, DevMode );
    if (!hDC)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateDC failed. ec = %ld"),
                     GetLastError());
        goto error_exit;
    }

    //
    // set the document information
    //

    DocInfo.cbSize = sizeof(DOCINFO);
    DocInfo.lpszDocName = PrintInfo->DocName;
    DocInfo.lpszOutput  = PrintInfo->OutputFileName;
    DocInfo.lpszDatatype = NULL;
    DocInfo.fwType = 0;

    //
    // start the print job
    //

    JobId = StartDoc( hDC, &DocInfo );
    if (JobId <= 0)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("StartDoc failed. ec = %ld"),
                     GetLastError());
        goto error_exit;
    }

    if (PrintInfo->OutputFileName == NULL)
    {

        //
        // HACK HACK -> pause the print job
        //

        if (FaxJobId && *FaxJobId == 0xffffffff)
        {
            SetJob( hPrinter, JobId, 0, NULL, JOB_CONTROL_PAUSE );
        }

        //
        // set the job tags
        // this is how we communicate the information to
        // the print driver that would otherwise be
        // provided by the fax print wizard
        //

        JobInfo = (PJOB_INFO_2)MyGetJob( hPrinter, 2, JobId );
        if (!JobInfo)
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("MyGetJob failed. ec = %ld"),
                     GetLastError());
            goto error_exit;
        }

        DWORD   dwReceiptFlag = DRT_NONE;
        LPTSTR  strReceiptAddress = NULL;

        if(PrintInfo->DrEmailAddress)
        {
            dwReceiptFlag = DRT_EMAIL;
            strReceiptAddress = LPTSTR(PrintInfo->DrEmailAddress);
        }

		TCHAR   tszNumericData[10] = {0};
        if (0 > _sntprintf (tszNumericData,
            ARR_SIZE(tszNumericData) -1,
            _T("%d"),
            dwReceiptFlag))
        {
            SetLastError(ERROR_BUFFER_OVERFLOW);
            DebugPrintEx(DEBUG_ERR,
                TEXT("_sntprintf failed. ec = %ld"),
                GetLastError());
            goto error_exit;
        }

        FAX_TAG_MAP_ENTRY tagMap[] =
        {
            //
            // Sender info
            //
            { FAXTAG_NEW_RECORD,        FAXTAG_NEW_RECORD_VALUE },
            { FAXTAG_BILLING_CODE,      LPTSTR(PrintInfo->SenderBillingCode) },
            { FAXTAG_RECEIPT_TYPE,      tszNumericData },
            { FAXTAG_RECEIPT_ADDR,      strReceiptAddress },
            { FAXTAG_SENDER_NAME,       LPTSTR(PrintInfo->SenderName) },
            { FAXTAG_SENDER_COMPANY,    LPTSTR(PrintInfo->SenderCompany) },
            { FAXTAG_SENDER_DEPT,       LPTSTR(PrintInfo->SenderDept) },
            { FAXTAG_RECIPIENT_COUNT,   _T("1") },

            //
            // Recipient info
            //
            { FAXTAG_NEW_RECORD,        FAXTAG_NEW_RECORD_VALUE },
            { FAXTAG_RECIPIENT_NAME,    LPTSTR(PrintInfo->RecipientName) },
            { FAXTAG_RECIPIENT_NUMBER,  LPTSTR(PrintInfo->RecipientNumber) }
        };

        //
        //  Call first time to ParamTagToString to find out size of the Parameters string
        //
        DWORD   dwTagCount = sizeof(tagMap)/sizeof(FAX_TAG_MAP_ENTRY);
        DWORD   dwSize = 0;
        ParamTagsToString(tagMap, dwTagCount, NULL, &dwSize);

        //
        //  Allocate the Buffer for the Parameters String
        //
        strParameters = LPTSTR(MemAlloc(dwSize + sizeof(TCHAR)));   //  dwSize does not count last NULL
        if (!strParameters)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            DebugPrintEx(DEBUG_ERR,
                     _T("strParameters = MemAlloc(%d) failed. ec = %ld"),
                     dwSize,
                     GetLastError());
            goto error_exit;
        }

        //
        //  Get the Parameters string from the ParamTagToString
        //
        ParamTagsToString(tagMap, dwTagCount, strParameters, &dwSize);


        //
        // set these fields or the spooler will
        // return ACCESS_DENIED for a non-admin client
        //

        JobInfo->Position    = JOB_POSITION_UNSPECIFIED;
        JobInfo->pDevMode    = NULL;

        //
        // set our new fax tags
        //

        JobInfo->pParameters = strParameters;

        if (!SetJob( hPrinter, JobId, 2, (LPBYTE) JobInfo, 0 ))
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("SetJob failed. ec = %ld"),
                     GetLastError());
            goto error_exit;
        }
    }

    //
    // clean up and return to the caller
    //

    ClosePrinter( hPrinter);
    MemFree( PrinterInfo);
    MemFree( DevMode );
    MemFree( strParameters );
    MemFree( JobInfo );

    if (!PrinterName)
    {
        MemFree (lptstrFaxPrinterName);
    }

    if (FaxJobId)
    {
        *FaxJobId = JobId;
    }
    FaxContextInfo->hDC = hDC;

    return TRUE;

error_exit:
    if (hPrinter) {
        ClosePrinter( hPrinter);
    }
    if (PrinterInfo) {
        MemFree( PrinterInfo);
    }
    if (JobId)
    {
        if (EndDoc( hDC ) <= 0)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EndDoc failed. (ec: %ld)"),
                GetLastError());
        }
    }
    if (hDC)
    {
        if (!DeleteDC (hDC))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteDC failed. (ec: %ld)"),
                GetLastError());
        }
    }
    if (DevMode) {
        MemFree( DevMode );
    }
    if (strParameters) {
        MemFree( strParameters );
    }
    if (JobInfo) {
        MemFree( JobInfo );
    }

    if (!PrinterName) {
        MemFree (lptstrFaxPrinterName);
    }

    return FALSE;
}

#ifdef UNICODE
BOOL
WINAPI
FaxStartPrintJob2A(
    IN  LPCSTR                    PrinterName,
    IN  const FAX_PRINT_INFOA     *PrintInfo,
    IN  short                     TiffRes,
    OUT LPDWORD                   JobId,
    OUT FAX_CONTEXT_INFOA         *FaxContextInfo
    )

/*++

Routine Description:

    Starts a print job for the specified printer.  This
    function provides functionality beyond what the caller
    can provide by using StartDoc().  This function disables
    the display of the fax send wizard and also passes along
    the information that would otherwise be gathered by the
    fax wizard ui.

Arguments:

    PrinterName         - Fax printer name (must be a fax printer)
    PrintInfo           - Fax print information
    TiffRes             - coverpage resolution. 0 for the printer default
    FaxJobId            - Job id of the resulting print job
    FaxContextInfo      - device context information (hdc, etc.)

Return Value:

    TRUE for success.
    FALSE for failure.

--*/
{
    DWORD Rval = ERROR_SUCCESS;
    FAX_PRINT_INFOW PrintInfoW;
    FAX_CONTEXT_INFOW ContextInfoW;
    LPSTR ServerName = NULL;
    LPWSTR PrinterNameW = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxStartPrintJobA"));

    if (!PrintInfo || !JobId || !FaxContextInfo ||
        (PrintInfo->SizeOfStruct != sizeof(FAX_PRINT_INFOA)))
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("PrintInfo is NULL or Size mismatch.")
                     );
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (PrinterName)
    {
        PrinterNameW = AnsiStringToUnicodeString( PrinterName );
        if (!PrinterNameW)
        {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    ZeroMemory( &ContextInfoW, sizeof(FAX_CONTEXT_INFOW) );
    ContextInfoW.SizeOfStruct = sizeof(FAX_CONTEXT_INFOW) ;

    ZeroMemory( &PrintInfoW, sizeof(FAX_PRINT_INFOW) );

    PrintInfoW.SizeOfStruct      = sizeof(FAX_PRINT_INFOW);
    PrintInfoW.DocName           = AnsiStringToUnicodeString( PrintInfo->DocName           );
    if (!PrintInfoW.DocName && PrintInfo->DocName)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.RecipientName     = AnsiStringToUnicodeString( PrintInfo->RecipientName     );
    if (!PrintInfoW.RecipientName && PrintInfo->RecipientName)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.RecipientNumber   = AnsiStringToUnicodeString( PrintInfo->RecipientNumber   );
    if (!PrintInfoW.RecipientNumber && PrintInfo->RecipientNumber)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.SenderName        = AnsiStringToUnicodeString( PrintInfo->SenderName        );
    if (!PrintInfoW.SenderName && PrintInfo->SenderName)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.SenderCompany     = AnsiStringToUnicodeString( PrintInfo->SenderCompany     );
    if (!PrintInfoW.SenderCompany && PrintInfo->SenderCompany)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.SenderDept        = AnsiStringToUnicodeString( PrintInfo->SenderDept        );
    if (!PrintInfoW.SenderDept && PrintInfo->SenderDept)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.SenderBillingCode = AnsiStringToUnicodeString( PrintInfo->SenderBillingCode );
    if (!PrintInfoW.SenderBillingCode && PrintInfo->SenderBillingCode)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.Reserved = AnsiStringToUnicodeString( PrintInfo->Reserved );
    if (!PrintInfoW.Reserved && PrintInfo->Reserved)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.DrEmailAddress    = AnsiStringToUnicodeString( PrintInfo->DrEmailAddress    );
    if (!PrintInfoW.DrEmailAddress && PrintInfo->DrEmailAddress)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PrintInfoW.OutputFileName    = AnsiStringToUnicodeString( PrintInfo->OutputFileName    );
    if (!PrintInfoW.OutputFileName && PrintInfo->OutputFileName)
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    if (!FaxStartPrintJob2W(
                (LPWSTR) PrinterNameW,
                &PrintInfoW,
                TiffRes,
                JobId,
                &ContextInfoW))
    {
        Rval = GetLastError();
        goto exit;
    }

    ServerName = UnicodeStringToAnsiString( ContextInfoW.ServerName);
    if (ServerName)
    {
        _mbscpy((PUCHAR)FaxContextInfo->ServerName,(PUCHAR)ServerName);
    }
    else
    {
        Rval = ERROR_OUTOFMEMORY;
        goto exit;
    }

    FaxContextInfo->SizeOfStruct = sizeof(FAX_CONTEXT_INFOA);
    FaxContextInfo->hDC = ContextInfoW.hDC;

    Assert (ERROR_SUCCESS == Rval);

exit:
    MemFree( (LPBYTE) PrinterNameW );
    MemFree( (LPBYTE) PrintInfoW.DocName           );
    MemFree( (LPBYTE) PrintInfoW.RecipientName     );
    MemFree( (LPBYTE) PrintInfoW.RecipientNumber   );
    MemFree( (LPBYTE) PrintInfoW.SenderName        );
    MemFree( (LPBYTE) PrintInfoW.SenderCompany     );
    MemFree( (LPBYTE) PrintInfoW.SenderDept        );
    MemFree( (LPBYTE) PrintInfoW.SenderBillingCode );
    MemFree( (LPBYTE) PrintInfoW.DrEmailAddress );
    MemFree( (LPBYTE) PrintInfoW.OutputFileName );
    MemFree( (LPBYTE) PrintInfoW.Reserved );

    MemFree( (LPBYTE) ServerName );

    if (ERROR_SUCCESS != Rval)
    {
        SetLastError(Rval);
        return FALSE;
    }
    return TRUE;
}
#else
BOOL
WINAPI
FaxStartPrintJob2W(
    IN  LPCWSTR                   PrinterName,
    IN  const FAX_PRINT_INFOW     *PrintInfo,
    IN  DWORD                     TiffRes,
    OUT LPDWORD                   FaxJobId,
    OUT PFAX_CONTEXT_INFOW        FaxContextInfo
    )

{
    UNREFERENCED_PARAMETER(PrinterName);
    UNREFERENCED_PARAMETER(PrintInfo);
    UNREFERENCED_PARAMETER(TiffRes);
    UNREFERENCED_PARAMETER(FaxJobId);
    UNREFERENCED_PARAMETER(FaxContextInfo);
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\port.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains the port
    specific WINFAX API functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/

#include "faxapi.h"
#pragma hdrstop



int
__cdecl
PortPriorityCompare(
    const void *arg1,
    const void *arg2
    )
{
    if (((PFAX_PORT_INFOW)arg1)->Priority < ((PFAX_PORT_INFOW)arg2)->Priority) {
        return -1;
    }
    if (((PFAX_PORT_INFOW)arg1)->Priority > ((PFAX_PORT_INFOW)arg2)->Priority) {
        return 1;
    }
    return 0;
}

BOOL
WINAPI
FaxEnumPortsW(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOW *PortInfoBuffer,
    OUT LPDWORD PortsReturned
    )

/*++

Routine Description:

    Enumerates all of the FAX devices attached to the
    FAX server.  The port state information is returned
    for each device.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    PortInfoBuffer      - Buffer to hold the port information
    PortInfoBufferSize  - Total size of the port info buffer
    PortsReturned       - The number of ports in the buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    DWORD i;
    PFAX_PORT_INFOW PortInfo;
    DWORD PortInfoBufferSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxEnumPortsW"));

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if (!PortInfoBuffer || !PortsReturned) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("!PortInfoBuffer || !PortsReturned."));
        return FALSE;
    }

    *PortInfoBuffer = NULL;

    __try
    {
        ec = FAX_EnumPorts(
            FH_FAX_HANDLE(FaxHandle),
            (LPBYTE*)PortInfoBuffer,
            &PortInfoBufferSize,
            PortsReturned
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumPorts. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

    for (i=0; i<*PortsReturned; i++) {
        FixupStringPtrW( PortInfoBuffer, PortInfo[i].DeviceName );
        FixupStringPtrW( PortInfoBuffer, PortInfo[i].Tsid );
        FixupStringPtrW( PortInfoBuffer, PortInfo[i].Csid );
    }

    //
    // sort the ports by priority
    //

    qsort(
        (PVOID) *PortInfoBuffer,
        (int) (*PortsReturned),
        sizeof(FAX_PORT_INFOW),
        PortPriorityCompare
        );

    return TRUE;
}


BOOL
WINAPI
FaxEnumPortsA(
    IN  HANDLE FaxHandle,
    OUT PFAX_PORT_INFOA *PortInfoBuffer,
    OUT LPDWORD PortsReturned
    )

/*++

Routine Description:

    Enumerates all of the FAX devices attached to the
    FAX server.  The port state information is returned
    for each device.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    PortInfoBuffer      - Buffer to hold the port information
    PortInfoBufferSize  - Total size of the port info buffer
    BytesNeeded         - Total bytes needed for buffer
    PortsReturned       - The number of ports in the buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    DWORD i;
    PFAX_PORT_INFOW PortInfo;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumPortsA"));

    if (!FaxEnumPortsW(
            FaxHandle,
            (PFAX_PORT_INFOW *)PortInfoBuffer,
            PortsReturned
            )) 
    {
        return FALSE;
    }
    //
    // convert the strings from unicode to ascii
    //
    PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

    for (i=0; i<*PortsReturned; i++) 
    {
        if (!ConvertUnicodeStringInPlace( (LPWSTR) PortInfo[i].DeviceName ) ||
            !ConvertUnicodeStringInPlace( (LPWSTR) PortInfo[i].Tsid )       ||
            !ConvertUnicodeStringInPlace( (LPWSTR) PortInfo[i].Csid ))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (PortInfo);
            return FALSE;
        }
    }
    return TRUE;
}   // FaxEnumPortsA

extern "C"
DWORD
WINAPI
IsDeviceVirtual (
    IN  HANDLE hFaxHandle,
    IN  DWORD  dwDeviceId,
    OUT LPBOOL lpbVirtual
)
/*++

Routine name : IsDeviceVirtual

Routine description:

    Checks if a given device is virtual

Author:

    Eran Yariv (EranY), May, 2001

Arguments:

    hFaxHandle       [in]     - Fax connection handle
    dwDeviceId       [in]     - Device id
    lpbVirtual       [out]    - Result flag

Return Value:

    Standard Win32 error code

--*/
{
    PFAX_PORT_INFO  pPortInfo = NULL;
    HANDLE          hPort = NULL;
    DWORD           dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("IsDeviceVirtual"));


    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE)) 
    {
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return ERROR_INVALID_HANDLE;
    }

    if (!FaxOpenPort (hFaxHandle, dwDeviceId, PORT_OPEN_QUERY, &hPort))
    {
        dwRes = GetLastError ();
        DebugPrintEx(DEBUG_ERR, _T("FaxOpenPort() failed with %ld."), dwRes);
        return dwRes;
    }

    if (!FaxGetPort (hPort, &pPortInfo))
    {
        dwRes = GetLastError ();
        DebugPrintEx(DEBUG_ERR, _T("FaxGetPort() failed with %ld."), dwRes);
        goto exit;
    }
    *lpbVirtual = (pPortInfo->Flags & FPF_VIRTUAL) ? TRUE : FALSE;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    MemFree (pPortInfo);
    if (hPort)
    {
        FaxClose (hPort);
    }
    return dwRes;
}   // IsDeviceVirtual


extern "C"
BOOL
WINAPI
FaxGetPortW(
    IN  HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOW *PortInfoBuffer
    )

/*++

Routine Description:

    Returns port status information for a requested port.
    The device id passed in should be optained from FAXEnumPorts.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    DeviceId            - TAPI device id
    PortInfoBuffer      - Buffer to hold the port information
    PortInfoBufferSize  - Total size of the port info buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    PFAX_PORT_INFOW PortInfo;
    DWORD PortInfoBufferSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetPortW"));

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!PortInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("PortInfoBuffer is NULL."));
        return FALSE;
    }


    *PortInfoBuffer = NULL;

    __try
    {
        ec = FAX_GetPort(
            FH_PORT_HANDLE(FaxPortHandle),
            (LPBYTE*)PortInfoBuffer,
            &PortInfoBufferSize
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetPort. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

    FixupStringPtrW( PortInfoBuffer, PortInfo->DeviceName );
    FixupStringPtrW( PortInfoBuffer, PortInfo->Tsid );
    FixupStringPtrW( PortInfoBuffer, PortInfo->Csid );

    return TRUE;
}


extern "C"
BOOL
WINAPI
FaxGetPortA(
    IN HANDLE FaxPortHandle,
    OUT PFAX_PORT_INFOA *PortInfoBuffer
    )

/*++

Routine Description:

    Returns port status information for a requested port.
    The device id passed in should be optained from FAXEnumPorts.

Arguments:

    FaxHandle           - FAX handle obtained from FaxConnectFaxServer
    DeviceId            - TAPI device id
    PortInfoBuffer      - Buffer to hold the port information
    PortInfoBufferSize  - Total size of the port info buffer
    BytesNeeded         - Total bytes needed for buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    BOOL Rval = FALSE;
    PFAX_PORT_INFOW PortInfo;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetPortA"));

    if (!FaxGetPortW( FaxPortHandle, (PFAX_PORT_INFOW *)PortInfoBuffer)) {
        goto exit;
    }

    PortInfo = (PFAX_PORT_INFOW) *PortInfoBuffer;

    if (!ConvertUnicodeStringInPlace( (LPWSTR)PortInfo->DeviceName )        ||
        !ConvertUnicodeStringInPlace( (LPWSTR)PortInfo->Tsid )              ||
        !ConvertUnicodeStringInPlace( (LPWSTR)PortInfo->Csid ))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (PortInfo);
        return FALSE;
    }
    (*PortInfoBuffer)->SizeOfStruct = sizeof(FAX_PORT_INFOA);
    Rval = TRUE;
exit:
    return Rval;
}   // FaxGetPortA


BOOL
FaxSetPortW(
    IN HANDLE FaxPortHandle,
    IN const FAX_PORT_INFOW *PortInfoBuffer
    )

/*++

Routine Description:

    Changes the port capability mask.  This allows the caller to
    enable or disable sending & receiving on a port basis.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    PortInfo    - PortInfo structure

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    error_status_t ec;
    PHANDLE_ENTRY HandleEntry = (PHANDLE_ENTRY) FaxPortHandle;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetPortW"));

    //
    //  Validate Parameters
    //
    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!PortInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("PortInfoBuffer is NULL."));
        return FALSE;
    }

    if (PortInfoBuffer->SizeOfStruct != sizeof(FAX_PORT_INFOW)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("PortInfoBuffer->SizeOfStruct != sizeof(FAX_PORT_INFOW)."));
        return FALSE;
    }

    if (!(HandleEntry->Flags & PORT_OPEN_MODIFY)) 
    {
        SetLastError(ERROR_ACCESS_DENIED);
        return FALSE;
    }
    __try
    {
        ec = FAX_SetPort(
            FH_PORT_HANDLE(FaxPortHandle),
            (PFAX_PORT_INFO)PortInfoBuffer
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetPort. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
FaxSetPortA(
    IN HANDLE FaxPortHandle,
    IN const FAX_PORT_INFOA *PortInfoBuffer
    )

/*++

Routine Description:

    Changes the port capability mask.  This allows the caller to
    enable or disable sending & receiving on a port basis.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    PortInfo    - PortInfo structure

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    DWORD ec = ERROR_SUCCESS;
    FAX_PORT_INFOW PortInfoW = {0};

    DEBUG_FUNCTION_NAME(_T("FaxSetPortA"));

    //
    //  Validate Parameters
    //
    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!PortInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("PortInfoBuffer is NULL."));
        return FALSE;
    }

    if (PortInfoBuffer->SizeOfStruct != sizeof(FAX_PORT_INFOA)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("(PortInfoBuffer->SizeOfStruct != sizeof(FAX_PORT_INFOA))."));
        return FALSE;
    }

    PortInfoW.SizeOfStruct = sizeof(FAX_PORT_INFOW);
    PortInfoW.DeviceId = PortInfoBuffer->DeviceId;
    PortInfoW.State = PortInfoBuffer->State;
    PortInfoW.Flags = PortInfoBuffer->Flags;
    PortInfoW.Rings = PortInfoBuffer->Rings;
    PortInfoW.Priority = PortInfoBuffer->Priority;

    PortInfoW.DeviceName = AnsiStringToUnicodeString( PortInfoBuffer->DeviceName );
    if (!PortInfoW.DeviceName && PortInfoBuffer->DeviceName)
    {
        ec = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PortInfoW.Csid = AnsiStringToUnicodeString( PortInfoBuffer->Csid );
    if (!PortInfoW.Csid && PortInfoBuffer->Csid)
    {
        ec = ERROR_OUTOFMEMORY;
        goto exit;
    }

    PortInfoW.Tsid = AnsiStringToUnicodeString( PortInfoBuffer->Tsid );
    if (!PortInfoW.Tsid && PortInfoBuffer->Tsid)
    {
        ec = ERROR_OUTOFMEMORY;
        goto exit;
    }

    if (!FaxSetPortW( FaxPortHandle, &PortInfoW ))
    {
        ec = GetLastError();
        goto exit;
    }

    Assert (ERROR_SUCCESS == ec);

exit:
    MemFree( (PBYTE) PortInfoW.DeviceName );
    MemFree( (PBYTE) PortInfoW.Csid );
    MemFree( (PBYTE) PortInfoW.Tsid );

    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
        return FALSE;
    }
    return TRUE;
}

BOOL
WINAPI
FaxOpenPort(
    IN HANDLE FaxHandle,
    IN DWORD DeviceId,
    IN DWORD Flags,
    OUT LPHANDLE FaxPortHandle
    )

/*++

Routine Description:

    Opens a fax port for subsequent use in other fax APIs.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    DeviceId        - Requested device id
    FaxPortHandle   - The resulting FAX port handle.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t ec;
    PHANDLE_ENTRY HandleEntry;

    DEBUG_FUNCTION_NAME(TEXT("FaxOpenPort"));

    if (!ValidateFaxHandle(FaxHandle, FHT_SERVICE)) {
       SetLastError(ERROR_INVALID_HANDLE);
       DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
       return FALSE;
    }

    if ( !FaxPortHandle ||
         (!(Flags & (PORT_OPEN_QUERY | PORT_OPEN_MODIFY) ))) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    __try
    {
        ec = FAX_OpenPort( FH_FAX_HANDLE(FaxHandle), DeviceId, Flags, FaxPortHandle );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_OpenPort. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    HandleEntry = CreateNewPortHandle( FH_DATA(FaxHandle), Flags, *FaxPortHandle );
    if (HandleEntry) {
        HandleEntry->DeviceId = DeviceId;
    }

    *FaxPortHandle = HandleEntry;

    return *FaxPortHandle != NULL;
}


BOOL
WINAPI
FaxEnumRoutingMethodsW(
    IN HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODW *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    PFAX_ROUTING_METHODW FaxRoutingMethod = NULL;
    error_status_t ec;
    DWORD i;
    DWORD RoutingInfoBufferSize = 0;

    DEBUG_FUNCTION_NAME(TEXT("FaxEnumRoutingMethodsW"));

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!RoutingInfoBuffer || !MethodsReturned) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }

    *RoutingInfoBuffer = NULL;
    *MethodsReturned = 0;

    __try
    {
        ec = FAX_EnumRoutingMethods(
            FH_PORT_HANDLE(FaxPortHandle),
            (LPBYTE*)RoutingInfoBuffer,
            &RoutingInfoBufferSize,
            MethodsReturned
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumRoutingMethods. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    FaxRoutingMethod = (PFAX_ROUTING_METHODW) *RoutingInfoBuffer;

    for (i=0; i<*MethodsReturned; i++) {
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingMethod[i].DeviceName );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingMethod[i].Guid );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingMethod[i].FunctionName );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingMethod[i].FriendlyName );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingMethod[i].ExtensionImageName );
        FixupStringPtrW( RoutingInfoBuffer, FaxRoutingMethod[i].ExtensionFriendlyName );
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnumRoutingMethodsA(
    IN HANDLE FaxPortHandle,
    OUT PFAX_ROUTING_METHODA *RoutingInfoBuffer,
    OUT LPDWORD MethodsReturned
    )
{
    PFAX_ROUTING_METHODW FaxRoutingMethod = NULL;
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumRoutingMethodsA"));

    if (!FaxEnumRoutingMethodsW(
        FaxPortHandle,
        (PFAX_ROUTING_METHODW *)RoutingInfoBuffer,
        MethodsReturned
        ))
    {
        return FALSE;
    }

    FaxRoutingMethod = (PFAX_ROUTING_METHODW) *RoutingInfoBuffer;

    for (i=0; i<*MethodsReturned; i++) 
    {
        if (!ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].DeviceName )          ||
            !ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].Guid )                ||
            !ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].FunctionName )        ||
            !ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].FriendlyName )        ||
            !ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].ExtensionImageName )  ||
            !ConvertUnicodeStringInPlace( (LPWSTR)FaxRoutingMethod[i].ExtensionFriendlyName ))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (FaxRoutingMethod);
            return FALSE;
        }
    }
    return TRUE;
}   // FaxEnumRoutingMethodsA


BOOL
WINAPI
FaxEnableRoutingMethodW(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuid,
    IN BOOL Enabled
    )
{
    error_status_t ec;

    DEBUG_FUNCTION_NAME(TEXT("FaxEnableRoutingMethodW"));

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!RoutingGuid) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("RoutingGuid is NULL."));
        return FALSE;
    }

    __try
    {
        ec = FAX_EnableRoutingMethod( FH_PORT_HANDLE(FaxPortHandle), (LPWSTR)RoutingGuid, Enabled);
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnableRoutingMethod. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxEnableRoutingMethodA(
    IN HANDLE FaxPortHandle,
    IN LPCSTR RoutingGuid,
    IN BOOL Enabled
    )
{
    BOOL Rval;


    LPWSTR RoutingGuidW = AnsiStringToUnicodeString( RoutingGuid );
    if (!RoutingGuidW) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Rval = FaxEnableRoutingMethodW( FaxPortHandle, RoutingGuidW, Enabled );

    MemFree( RoutingGuidW );

    return Rval;
}


BOOL
WINAPI
FaxGetRoutingInfoW(
    IN const HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    error_status_t ec;

    DEBUG_FUNCTION_NAME(TEXT("FaxGetRoutingInfoW"));

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!RoutingGuid || !RoutingInfoBuffer || !RoutingInfoBufferSize) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }

    *RoutingInfoBuffer = NULL;
    *RoutingInfoBufferSize = 0;

    __try
    {
        ec = FAX_GetRoutingInfo(
            FH_PORT_HANDLE(FaxPortHandle),
            (LPWSTR)RoutingGuid,
            RoutingInfoBuffer,
            RoutingInfoBufferSize
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetRoutingInfo. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxGetRoutingInfoA(
    IN HANDLE FaxPortHandle,
    IN LPCSTR RoutingGuid,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    BOOL Rval;


    LPWSTR RoutingGuidW = AnsiStringToUnicodeString( RoutingGuid );
    if (!RoutingGuidW) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Rval = FaxGetRoutingInfoW(
        FaxPortHandle,
        RoutingGuidW,
        RoutingInfoBuffer,
        RoutingInfoBufferSize
        );

    MemFree( RoutingGuidW );

    return Rval;
}


BOOL
WINAPI
FaxSetRoutingInfoW(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuid,
    IN const BYTE *RoutingInfoBuffer,
    IN DWORD RoutingInfoBufferSize
    )
{
    error_status_t ec;

    DEBUG_FUNCTION_NAME(TEXT("FaxSetRoutingInfoW"));

    if (!ValidateFaxHandle(FaxPortHandle, FHT_PORT)) {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!RoutingGuid || !RoutingInfoBuffer || !RoutingInfoBufferSize) {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }

    __try
    {
        ec = FAX_SetRoutingInfo(
            FH_PORT_HANDLE(FaxPortHandle),
            (LPWSTR)RoutingGuid,
            RoutingInfoBuffer,
            RoutingInfoBufferSize
            );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we crashed.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetRoutingInfo. (ec: %ld)"),
            ec);
    }
    if (ec) 
    {
        DumpRPCExtendedStatus ();
        SetLastError( ec );
        return FALSE;
    }

    return TRUE;
}


BOOL
WINAPI
FaxSetRoutingInfoA(
    IN HANDLE FaxPortHandle,
    IN LPCSTR RoutingGuid,
    IN const BYTE *RoutingInfoBuffer,
    IN DWORD RoutingInfoBufferSize
    )
{
    BOOL Rval;


    LPWSTR RoutingGuidW = AnsiStringToUnicodeString( RoutingGuid );
    if (!RoutingGuidW) {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    Rval = FaxSetRoutingInfoW(
        FaxPortHandle,
        RoutingGuidW,
        RoutingInfoBuffer,
        RoutingInfoBufferSize
        );

    MemFree( RoutingGuidW );

    return Rval;
}

BOOL
WINAPI
FaxEnumerateProvidersA (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOA *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
)
/*++

Routine name : FaxEnumerateProvidersA

Routine description:

    Enumerates FSPs - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle       [in ] - Handle to fax server
    ppProviders      [out] - Pointer to buffer to return array of providers.
    lpdwNumProviders [out] - Number of providers returned in the array.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    PFAX_DEVICE_PROVIDER_INFOW   pUnicodeProviders;
    DWORD                        dwNumProviders;
    DWORD                        dwCur;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumerateProvidersA"));

    if (!ppProviders || !lpdwNumProviders)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }
    //
    // Call the UNICODE version first
    //
    if (!FaxEnumerateProvidersW (hFaxHandle, &pUnicodeProviders, &dwNumProviders))
    {
        return FALSE;
    }
    //
    // Convert returned value back into ANSI.
    // We keep the UNICODE structures and do a UNICODE to ANSI convert in place.
    //
    *lpdwNumProviders = dwNumProviders;
    *ppProviders = (PFAX_DEVICE_PROVIDER_INFOA) pUnicodeProviders;

    for (dwCur = 0; dwCur < dwNumProviders; dwCur++)
    {
        if (!ConvertUnicodeStringInPlace( pUnicodeProviders[dwCur].lpctstrFriendlyName )    ||
            !ConvertUnicodeStringInPlace( pUnicodeProviders[dwCur].lpctstrImageName )       ||
            !ConvertUnicodeStringInPlace( pUnicodeProviders[dwCur].lpctstrProviderName )    ||
            !ConvertUnicodeStringInPlace( pUnicodeProviders[dwCur].lpctstrGUID ))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (pUnicodeProviders);
            return FALSE;
        }
    }
    return TRUE;
}   // FaxEnumerateProvidersA

BOOL
WINAPI
FaxEnumerateProvidersW (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOW *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
)
/*++

Routine name : FaxEnumerateProvidersW

Routine description:

    Enumerates FSPs - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle       [in ] - Handle to fax server
    ppProviders      [out] - Pointer to buffer to return array of providers.
    lpdwNumProviders [out] - Number of providers returned in the array.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DWORD dwConfigSize;
    DWORD dwCur;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumerateProvidersW"));

    if (!ppProviders || !lpdwNumProviders)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }
    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    *ppProviders = NULL;

    //
    // Call the RPC function
    //
    __try
    {
        ec = FAX_EnumerateProviders(
                    FH_FAX_HANDLE(hFaxHandle),
                    (LPBYTE*)ppProviders,
                    &dwConfigSize,
                    lpdwNumProviders
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumerateProviders. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError(ec);
        return FALSE;
    }
    for (dwCur = 0; dwCur < (*lpdwNumProviders); dwCur++)
    {
        FixupStringPtrW( ppProviders, (*ppProviders)[dwCur].lpctstrFriendlyName );
        FixupStringPtrW( ppProviders, (*ppProviders)[dwCur].lpctstrImageName );
        FixupStringPtrW( ppProviders, (*ppProviders)[dwCur].lpctstrProviderName );
        FixupStringPtrW( ppProviders, (*ppProviders)[dwCur].lpctstrGUID );
    }
    return TRUE;
}   // FaxEnumerateProvidersW

#ifndef UNICODE

BOOL
WINAPI
FaxEnumerateProvidersX (
    IN  HANDLE                      hFaxHandle,
    OUT PFAX_DEVICE_PROVIDER_INFOW *ppProviders,
    OUT LPDWORD                     lpdwNumProviders
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (ppProviders);
    UNREFERENCED_PARAMETER (lpdwNumProviders);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxEnumerateProvidersX

#endif // #ifndef UNICODE

//********************************************
//*              Extended ports
//********************************************

BOOL
WINAPI
FaxGetPortExA (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXA  *ppPortInfo
)
/*++

Routine name : FaxGetPortExA

Routine description:

    Gets port (device) information - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Fax server RPC handle
    dwDeviceId          [in ] - Unique device id
    ppPortInfo          [out] - Port information

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    PFAX_PORT_INFO_EXW   pUnicodePort;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetPortExA"));

    if (!ppPortInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("ppPortInfo is NULL."));
        return FALSE;
    }
    //
    // Call the UNICODE version first
    //
    if (!FaxGetPortExW (hFaxHandle, dwDeviceId, &pUnicodePort))
    {
        return FALSE;
    }
    //
    // Convert returned value back into ANSI.
    // We keep the UNICODE structures and do a UNICODE to ANSI convert in place.
    //
    *ppPortInfo = (PFAX_PORT_INFO_EXA) pUnicodePort;
    if (!ConvertUnicodeStringInPlace( pUnicodePort->lpctstrDeviceName )     ||
        !ConvertUnicodeStringInPlace( pUnicodePort->lptstrDescription )     ||
        !ConvertUnicodeStringInPlace( pUnicodePort->lpctstrProviderName )   ||
        !ConvertUnicodeStringInPlace( pUnicodePort->lpctstrProviderGUID )   ||
        !ConvertUnicodeStringInPlace( pUnicodePort->lptstrCsid )            ||
        !ConvertUnicodeStringInPlace( pUnicodePort->lptstrTsid ))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (pUnicodePort);
        return FALSE;
    }
    (*ppPortInfo)->dwSizeOfStruct = sizeof(FAX_PORT_INFO_EXA);
    return TRUE;
}   // FaxGetPortExA

BOOL
WINAPI
FaxGetPortExW (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXW  *ppPortInfo
)
/*++

Routine name : FaxGetPortExW

Routine description:

    Gets port (device) information - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Fax server RPC handle
    dwDeviceId          [in ] - Unique device id
    ppPortInfo          [out] - Port information

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DWORD dwConfigSize;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetPortExW"));

    if (!ppPortInfo || !dwDeviceId)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }
    if (!ValidateFaxHandle(hFaxHandle,FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    *ppPortInfo = NULL;

    //
    // Call the RPC function
    //
    __try
    {
        ec = FAX_GetPortEx(
                    FH_FAX_HANDLE(hFaxHandle),
                    dwDeviceId,
                    (LPBYTE*)ppPortInfo,
                    &dwConfigSize
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetPortEx. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError(ec);
        return FALSE;
    }
    FixupStringPtrW( ppPortInfo, (*ppPortInfo)->lpctstrDeviceName );
    FixupStringPtrW( ppPortInfo, (*ppPortInfo)->lptstrDescription );
    FixupStringPtrW( ppPortInfo, (*ppPortInfo)->lpctstrProviderName );
    FixupStringPtrW( ppPortInfo, (*ppPortInfo)->lpctstrProviderGUID );
    FixupStringPtrW( ppPortInfo, (*ppPortInfo)->lptstrCsid );
    FixupStringPtrW( ppPortInfo, (*ppPortInfo)->lptstrTsid );
    return TRUE;
}   // FaxGetPortExW

#ifndef UNICODE

BOOL
WINAPI
FaxGetPortExX (
    IN  HANDLE               hFaxHandle,
    IN  DWORD                dwDeviceId,
    OUT PFAX_PORT_INFO_EXW  *ppPortInfo
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwDeviceId);
    UNREFERENCED_PARAMETER (ppPortInfo);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxGetPortExX

#endif // #ifndef UNICODE

BOOL
WINAPI
FaxSetPortExA (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXA  pPortInfo
)
/*++

Routine name : FaxSetPortExA

Routine description:

    Sets port (device) information - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in] - Fax server RPC handle
    dwDeviceId          [in] - Unique device id
    pPortInfo           [in] - New port information

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    FAX_PORT_INFO_EXW PortW;
    BOOL bRes = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetPortExA"));

    //
    //  Validate Parameters
    //  
    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!pPortInfo || !dwDeviceId)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }

    if (sizeof(FAX_PORT_INFO_EXA) != pPortInfo->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("(sizeof(FAX_PORT_INFO_EXA) != pPortInfo->dwSizeOfStruct)."));
        return FALSE;
    }

    //
    // Create a UNICODE structure and pass along to UNICODE function
    // Ansi structure is same size as unicode structure, so we can just copy it, then
    // cast the string pointers correctly
    //
    CopyMemory(&PortW, pPortInfo, sizeof(FAX_PORT_INFO_EXA));
    //
    // We're only setting the strings that get set in the service
    //
    PortW.lptstrCsid = NULL;
    PortW.lptstrDescription = NULL;
    PortW.lptstrTsid = NULL;
    PortW.lpctstrDeviceName = NULL;
    PortW.lpctstrProviderName = NULL;
    PortW.lpctstrProviderGUID = NULL;

    PortW.dwSizeOfStruct = sizeof (FAX_PORT_INFO_EXW);

    if (pPortInfo->lptstrCsid)
    {
        if (NULL ==
            (PortW.lptstrCsid = AnsiStringToUnicodeString(pPortInfo->lptstrCsid))
        )
        {
            goto exit;
        }
    }
    if (pPortInfo->lptstrDescription)
    {
        if (NULL ==
            (PortW.lptstrDescription = AnsiStringToUnicodeString(pPortInfo->lptstrDescription))
        )
        {
            goto exit;
        }
    }
    if (pPortInfo->lptstrTsid)
    {
        if (NULL ==
            (PortW.lptstrTsid = AnsiStringToUnicodeString(pPortInfo->lptstrTsid))
        )
        {
            goto exit;
        }
    }

    bRes = FaxSetPortExW (hFaxHandle, dwDeviceId, &PortW);
exit:
    MemFree((PVOID)PortW.lptstrCsid);
    MemFree((PVOID)PortW.lptstrDescription);
    MemFree((PVOID)PortW.lptstrTsid);
    return bRes;
}   // FaxSetPortExA

BOOL
WINAPI
FaxSetPortExW (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXW  pPortInfo
)
/*++

Routine name : FaxSetPortExW

Routine description:

    Sets port (device) information - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in] - Fax server RPC handle
    dwDeviceId          [in] - Unique device id
    pPortInfo           [in] - New port information

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    error_status_t ec;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetPortExW"));

    //
    //  Validate Parameters
    //
    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    if (!dwDeviceId || !pPortInfo)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }

    if (sizeof (FAX_PORT_INFO_EXW) != pPortInfo->dwSizeOfStruct)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    __try
    {
        ec = FAX_SetPortEx(
                    FH_FAX_HANDLE(hFaxHandle),
                    dwDeviceId,
                    pPortInfo );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetPortEx. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError(ec);
        return FALSE;
    }
    return TRUE;
}   // FaxSetPortExW

#ifndef UNICODE

BOOL
WINAPI
FaxSetPortExX (
    IN  HANDLE              hFaxHandle,
    IN  DWORD               dwDeviceId,
    IN  PFAX_PORT_INFO_EXW  pPortInfo
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwDeviceId);
    UNREFERENCED_PARAMETER (pPortInfo);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxSetPortExX

#endif // #ifndef UNICODE

BOOL
WINAPI
FaxEnumPortsExA (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXA *ppPorts,
    OUT LPDWORD             lpdwNumPorts
)
/*++

Routine name : FaxEnumPortsExA

Routine description:

    Eumerate all the devices (ports) on the server - ANSI version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Fax server RPC handle
    ppPorts         [out] - Array of port information
    lpdwNumPorts    [out] - Size of the returned array

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    PFAX_PORT_INFO_EXW           pUnicodePorts;
    DWORD                        dwNumPorts;
    DWORD                        dwCur;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumPortsExA"));

    if (!ppPorts || !lpdwNumPorts)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }
    //
    // Call the UNICODE version first
    //
    if (!FaxEnumPortsExW (hFaxHandle, &pUnicodePorts, &dwNumPorts))
    {
        DebugPrintEx(DEBUG_ERR, _T("FaxEnumPortsExW() is failed. ec = %ld."), GetLastError());
        return FALSE;
    }
    //
    // Convert returned value back into ANSI.
    // We keep the UNICODE structures and do a UNICODE to ANSI convert in place.
    //
    *lpdwNumPorts = dwNumPorts;
    *ppPorts = (PFAX_PORT_INFO_EXA) pUnicodePorts;

    for (dwCur = 0; dwCur < dwNumPorts; dwCur++)
    {
        if (!ConvertUnicodeStringInPlace( pUnicodePorts[dwCur].lpctstrDeviceName )      ||
            !ConvertUnicodeStringInPlace( pUnicodePorts[dwCur].lpctstrProviderGUID )    ||
            !ConvertUnicodeStringInPlace( pUnicodePorts[dwCur].lpctstrProviderName )    ||
            !ConvertUnicodeStringInPlace( pUnicodePorts[dwCur].lptstrCsid )             ||
            !ConvertUnicodeStringInPlace( pUnicodePorts[dwCur].lptstrDescription )      ||
            !ConvertUnicodeStringInPlace( pUnicodePorts[dwCur].lptstrTsid ))
        {
            DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
            MemFree (pUnicodePorts);
            return FALSE;
        }
    }
    return TRUE;
}   // FaxEnumPortsExA

BOOL
WINAPI
FaxEnumPortsExW (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXW *ppPorts,
    OUT LPDWORD             lpdwNumPorts
)
/*++

Routine name : FaxEnumPortsExW

Routine description:

    Eumerate all the devices (ports) on the server - UNICODE version

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle      [in ] - Fax server RPC handle
    ppPorts         [out] - Array of port information
    lpdwNumPorts    [out] - Size of the returned array

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DWORD dwConfigSize;
    DWORD dwCur;
    DEBUG_FUNCTION_NAME(TEXT("FaxEnumPortsExW"));

    if (!ppPorts || !lpdwNumPorts)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        DebugPrintEx(DEBUG_ERR, _T("Some Params are NULL."));
        return FALSE;
    }

    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
        SetLastError(ERROR_INVALID_HANDLE);
        DebugPrintEx(DEBUG_ERR, _T("ValidateFaxHandle() is failed."));
        return FALSE;
    }

    *ppPorts = NULL;

    //
    // Call the RPC function
    //
    __try
    {
        ec = FAX_EnumPortsEx(
                    FH_FAX_HANDLE(hFaxHandle),
                    (LPBYTE*)ppPorts,
                    &dwConfigSize,
                    lpdwNumPorts
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        ec = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_EnumPortsEx. (ec: %ld)"),
            ec);
    }
    if (ERROR_SUCCESS != ec)
    {
        DumpRPCExtendedStatus ();
        SetLastError(ec);
        return FALSE;
    }
    for (dwCur = 0; dwCur < (*lpdwNumPorts); dwCur++)
    {
        FixupStringPtrW( ppPorts, (*ppPorts)[dwCur].lpctstrDeviceName );
        FixupStringPtrW( ppPorts, (*ppPorts)[dwCur].lpctstrProviderGUID );
        FixupStringPtrW( ppPorts, (*ppPorts)[dwCur].lpctstrProviderName );
        FixupStringPtrW( ppPorts, (*ppPorts)[dwCur].lptstrCsid );
        FixupStringPtrW( ppPorts, (*ppPorts)[dwCur].lptstrDescription );
        FixupStringPtrW( ppPorts, (*ppPorts)[dwCur].lptstrTsid );
    }
    return TRUE;
}   // FaxEnumPortsExW

#ifndef UNICODE

BOOL
WINAPI
FaxEnumPortsExX (
    IN  HANDLE              hFaxHandle,
    OUT PFAX_PORT_INFO_EXW *ppPorts,
    OUT LPDWORD             lpdwNumPorts
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (ppPorts);
    UNREFERENCED_PARAMETER (lpdwNumPorts);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxEnumPortsExX

#endif // #ifndef UNICODE

//********************************************
//*              Extension data
//********************************************

BOOL
WINAPI
FaxGetExtensionDataA (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCSTR   lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
)
/*++

Routine name : FaxGetExtensionDataA

Routine description:

    Read the extension's private data - ANSI version

Author:

    Eran Yariv (EranY),    Nov, 1999

Arguments:

    hFaxHandle          [in ] - Handle to fax server
    dwDeviceId          [in ] - Device identifier.
                                0 = Unassociated data
    lpctstrNameGUID     [in ] - GUID of named data
    ppData              [out] - Pointer to data buffer
    lpdwDataSize        [out] - Returned size of data

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    LPWSTR lpwstrGUID;
    BOOL   bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetExtensionDataA"));

    if (!lpctstrNameGUID)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    lpwstrGUID = AnsiStringToUnicodeString (lpctstrNameGUID);
    if (NULL == lpwstrGUID)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    bRes = FaxGetExtensionDataW (   hFaxHandle,
                                    dwDeviceID,
                                    lpwstrGUID,
                                    ppData,
                                    lpdwDataSize
                                );
    MemFree (lpwstrGUID);
    return bRes;
}   // FaxGetExtensionDataA

BOOL
WINAPI
FaxGetExtensionDataW (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCWSTR  lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
)
/*++

Routine name : FaxGetExtensionDataW

Routine description:

    Read the extension's private data - UNICODE version

Author:

    Eran Yariv (EranY),    Nov, 1999

Arguments:

    hFaxHandle          [in ] - Handle to fax server
    dwDeviceId          [in ] - Device identifier.
                                0 = Unassociated data
    lpctstrNameGUID     [in ] - GUID of named data
    ppData              [out] - Pointer to data buffer
    lpdwDataSize        [out] - Returned size of data

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxGetExtensionDataW"));

    if (!lpctstrNameGUID || !ppData || !lpdwDataSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }
    dwRes = IsValidGUID (lpctstrNameGUID);
    if (ERROR_SUCCESS != dwRes)
    {
       SetLastError(dwRes);
       return FALSE;
    }
    *ppData = NULL;
    //
    // Call the RPC function
    //
    __try
    {
        dwRes = FAX_GetExtensionData(
                    FH_FAX_HANDLE (hFaxHandle),
                    dwDeviceID,
                    lpctstrNameGUID,
                    (LPBYTE*)ppData,
                    lpdwDataSize
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        dwRes = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_GetExtensionData. (ec: %ld)"),
            dwRes);
    }
    if (ERROR_SUCCESS != dwRes)
    {
        DumpRPCExtendedStatus ();
        SetLastError(dwRes);
        return FALSE;
    }
    return TRUE;
}   // FaxGetExtensionDataW

#ifndef UNICODE

BOOL
WINAPI
FaxGetExtensionDataX (
    IN  HANDLE   hFaxHandle,
    IN  DWORD    dwDeviceID,
    IN  LPCWSTR  lpctstrNameGUID,
    OUT PVOID   *ppData,
    OUT LPDWORD  lpdwDataSize
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwDeviceID);
    UNREFERENCED_PARAMETER (lpctstrNameGUID);
    UNREFERENCED_PARAMETER (ppData);
    UNREFERENCED_PARAMETER (lpdwDataSize);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxGetExtensionDataX

#endif // #ifndef UNICODE


BOOL
WINAPI
FaxSetExtensionDataA (
    IN HANDLE       hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCSTR       lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
)
/*++

Routine name : FaxSetExtensionDataA

Routine description:

    Write the extension's private data - ANSI version

Author:

    Eran Yariv (EranY),    Nov, 1999

Arguments:

    hFaxHandle          [in ] - Handle to fax server
    dwDeviceId          [in ] - Device identifier.
                                0 = Unassociated data
    lpctstrNameGUID     [in ] - GUID of named data
    pData               [in ] - Pointer to data
    dwDataSize          [in ] - Size of data

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    LPWSTR lpwstrGUID;
    BOOL   bRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxSetExtensionDataA"));

    if (!lpctstrNameGUID)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    lpwstrGUID = AnsiStringToUnicodeString (lpctstrNameGUID);
    if (NULL == lpwstrGUID)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    bRes = FaxSetExtensionDataW (   hFaxHandle,
                                    dwDeviceID,
                                    lpwstrGUID,
                                    pData,
                                    dwDataSize
                                );
    MemFree (lpwstrGUID);
    return bRes;
}   // FaxSetExtensionDataA

BOOL
WINAPI
FaxSetExtensionDataW (
    IN HANDLE       hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCWSTR      lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
)
/*++

Routine name : FaxSetExtensionDataW

Routine description:

    Write the extension's private data - UNICODE version

Author:

    Eran Yariv (EranY),    Nov, 1999

Arguments:

    hFaxHandle          [in ] - Handle to fax server
    dwDeviceId          [in ] - Device identifier.
                                0 = Unassociated data
    lpctstrNameGUID     [in ] - GUID of named data
    pData               [in ] - Pointer to data
    dwDataSize          [in ] - Size of data

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    DWORD dwRes;
    DWORD dwComputerNameSize;
    WCHAR lpwstrComputerName[MAX_COMPUTERNAME_LENGTH + 1];

    DEBUG_FUNCTION_NAME(TEXT("FaxSetExtensionDataW"));

    if (!lpctstrNameGUID || !pData || !dwDataSize)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    if (!ValidateFaxHandle(hFaxHandle, FHT_SERVICE))
    {
       SetLastError(ERROR_INVALID_HANDLE);
       return FALSE;
    }
    dwRes = IsValidGUID (lpctstrNameGUID);
    if (ERROR_SUCCESS != dwRes)
    {
       SetLastError(dwRes);
       return FALSE;
    }
    //
    // Retrieve the name of the machine for this caller.
    // The machine name will be used (together with the fax handle) to uniquely
    // identify that:
    //    1. The data was set remotely using an RPC call (and not by a local extension).
    //    2. Uniquely identify the module (instance) that called the Set operation.
    //
    // We're doing this to block notifications in the server back to the module that
    // did the data change (called the Set... function).
    //
    dwComputerNameSize = sizeof (lpwstrComputerName) / sizeof (lpwstrComputerName[0]);
    if (!GetComputerNameW (lpwstrComputerName, &dwComputerNameSize))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error calling GetComputerNameW (ec: %ld)"),
            dwRes);
        SetLastError(dwRes);
        return FALSE;
    }


    //
    // Call the RPC function
    //
    __try
    {
        dwRes = FAX_SetExtensionData(
                    FH_FAX_HANDLE (hFaxHandle),
                    lpwstrComputerName,
                    dwDeviceID,
                    lpctstrNameGUID,
                    (LPBYTE)pData,
                    dwDataSize
             );
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        //
        // For some reason we got an exception.
        //
        dwRes = GetExceptionCode();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Exception on RPC call to FAX_SetExtensionData. (ec: %ld)"),
            dwRes);
    }
    if (ERROR_SUCCESS != dwRes)
    {
        DumpRPCExtendedStatus ();
        SetLastError(dwRes);
        return FALSE;
    }
    return TRUE;
}   // FaxSetExtensionDataW

#ifndef UNICODE

BOOL
WINAPI
FaxSetExtensionDataX (
    IN HANDLE       hFaxHandle,
    IN DWORD        dwDeviceID,
    IN LPCWSTR      lpctstrNameGUID,
    IN CONST PVOID  pData,
    IN CONST DWORD  dwDataSize
)
{
    UNREFERENCED_PARAMETER (hFaxHandle);
    UNREFERENCED_PARAMETER (dwDeviceID);
    UNREFERENCED_PARAMETER (lpctstrNameGUID);
    UNREFERENCED_PARAMETER (pData);
    UNREFERENCED_PARAMETER (dwDataSize);
    SetLastError (ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}   // FaxSetExtensionDataX

#endif // #ifndef UNICODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\sender.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

	sender.c

Abstract:
	Implementation of functions work with sender
		FaxSetSenderInformation
		FaxGetSenderInformation

Environment:
		FXSAPI.DLL

Revision History:
    10/13/99 -v-sashab-
        Created it.


--*/

#include "faxapi.h"

#include "faxreg.h"
#include "registry.h"

HRESULT WINAPI
FaxSetSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	)
/*++

Routine Description:

    Save the information about the sender in the registry

Arguments:
	
	  pfppSender - pointer to the sender information
    
Return Value:

    S_OK - if success
	E_FAIL	- otherwise or HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER)

--*/
{
    HKEY hRegKey = NULL;
	HRESULT	hResult = S_OK;

    DEBUG_FUNCTION_NAME(_T("FaxSetSenderInformation"));

	//
	// Validate Parameters
	//
    if (!pfppSender)
    {
        DebugPrintEx(DEBUG_ERR,  _T("pfppSender is NULL."));
        hResult = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto exit;
    }

	if (pfppSender->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	{
        DebugPrintEx(DEBUG_ERR, _T("pfppSender->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE)."));
        hResult = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto exit;
	}

    if ((hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_USERINFO,TRUE, KEY_ALL_ACCESS)))
	{
        SetRegistryString(hRegKey, REGVAL_FULLNAME,			pfppSender->lptstrName);
        SetRegistryString(hRegKey, REGVAL_FAX_NUMBER,		pfppSender->lptstrFaxNumber);
        SetRegistryString(hRegKey, REGVAL_COMPANY,			pfppSender->lptstrCompany);
        SetRegistryString(hRegKey, REGVAL_ADDRESS,			pfppSender->lptstrStreetAddress);
        SetRegistryString(hRegKey, REGVAL_CITY,			    pfppSender->lptstrCity);
        SetRegistryString(hRegKey, REGVAL_STATE,			pfppSender->lptstrState);
        SetRegistryString(hRegKey, REGVAL_ZIP,			    pfppSender->lptstrZip);
        SetRegistryString(hRegKey, REGVAL_COUNTRY,			pfppSender->lptstrCountry);
        SetRegistryString(hRegKey, REGVAL_TITLE,			pfppSender->lptstrTitle);
        SetRegistryString(hRegKey, REGVAL_DEPT,				pfppSender->lptstrDepartment);
        SetRegistryString(hRegKey, REGVAL_OFFICE,			pfppSender->lptstrOfficeLocation);
        SetRegistryString(hRegKey, REGVAL_HOME_PHONE,		pfppSender->lptstrHomePhone);
        SetRegistryString(hRegKey, REGVAL_OFFICE_PHONE,		pfppSender->lptstrOfficePhone);       
        SetRegistryString(hRegKey, REGVAL_BILLING_CODE,		pfppSender->lptstrBillingCode);
        SetRegistryString(hRegKey, REGVAL_MAILBOX,			pfppSender->lptstrEmail);

        RegCloseKey(hRegKey);
    }
	else
	{
		DebugPrintEx(DEBUG_ERR, _T("Can't open registry for READ/WRITE."));
		hResult = E_FAIL;
        goto exit;
	}

    //
    // turn on "user info configured" registry flag
    //
	hRegKey = OpenRegistryKey(HKEY_CURRENT_USER, REGKEY_FAX_SETUP, TRUE, KEY_ALL_ACCESS);
	if(hRegKey)
	{
		SetRegistryDword(hRegKey, REGVAL_CFGWZRD_USER_INFO, TRUE);
		RegCloseKey(hRegKey);
	}
	else
	{
		DebugPrintEx(DEBUG_ERR, _T("OpenRegistryKey() is failed."));
	}

exit:
	return hResult;
}

HRESULT WINAPI
FaxGetSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
    )
/*++

Routine Description:

    Restores the information about the sender from the registry

Arguments:

    ppfppSender - pointer to restored sender informtion

Return Value:

    S_OK if success
	error otherwise (may return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY)
							or  HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER))

--*/
{
    HKEY    hRegKey = NULL;
	HRESULT hResult = S_OK;

    LPCTSTR lpctstrCurrentUserName = NULL;
    LPCTSTR lpctstrRegisteredOrganization = NULL;

    DEBUG_FUNCTION_NAME(_T("FaxGetSenderInformation"));

	//
	// Validate Parameters
	//
    if (!pfppSender)
    {
        DebugPrintEx(DEBUG_ERR,  _T("pfppSender is NULL."));
        hResult = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto exit;
    }

	if (pfppSender->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE))
	{
        DebugPrintEx(DEBUG_ERR, _T("pfppSender->dwSizeOfStruct != sizeof(FAX_PERSONAL_PROFILE)"));
        hResult = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
		goto exit;
	}

	ZeroMemory(pfppSender, sizeof(FAX_PERSONAL_PROFILE));
	pfppSender->dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);

    lpctstrCurrentUserName = GetCurrentUserName();
    lpctstrRegisteredOrganization = GetRegisteredOrganization();

    hRegKey = GetUserInfoRegKey(REGKEY_FAX_USERINFO, REG_READONLY);
    //
    // If we failed to open the reg key, calls to GetRegistryString() will return default values - this is what we want.
    //
	if (!(pfppSender->lptstrName		= GetRegistryString(hRegKey, 
                                                            REGVAL_FULLNAME, 
                                                            lpctstrCurrentUserName ? lpctstrCurrentUserName : TEXT(""))) ||
		!(pfppSender->lptstrFaxNumber	= GetRegistryString(hRegKey, REGVAL_FAX_NUMBER, TEXT(""))) ||
		!(pfppSender->lptstrCompany		= GetRegistryString(hRegKey, 
                                                            REGVAL_COMPANY, 
                                                            lpctstrRegisteredOrganization ? lpctstrRegisteredOrganization : TEXT(""))) ||
		!(pfppSender->lptstrStreetAddress = GetRegistryString(hRegKey, REGVAL_ADDRESS, TEXT(""))) ||
		!(pfppSender->lptstrCity        = GetRegistryString(hRegKey, REGVAL_CITY,    TEXT(""))) ||
		!(pfppSender->lptstrState       = GetRegistryString(hRegKey, REGVAL_STATE,   TEXT(""))) ||
		!(pfppSender->lptstrZip         = GetRegistryString(hRegKey, REGVAL_ZIP,     TEXT(""))) ||
		!(pfppSender->lptstrCountry     = GetRegistryString(hRegKey, REGVAL_COUNTRY, TEXT(""))) ||            
        !(pfppSender->lptstrTitle		= GetRegistryString(hRegKey, REGVAL_TITLE, TEXT(""))) ||
		!(pfppSender->lptstrDepartment	= GetRegistryString(hRegKey, REGVAL_DEPT, TEXT(""))) ||
		!(pfppSender->lptstrOfficeLocation = GetRegistryString(hRegKey, REGVAL_OFFICE, TEXT(""))) ||
		!(pfppSender->lptstrHomePhone	= GetRegistryString(hRegKey, REGVAL_HOME_PHONE, TEXT(""))) ||
		!(pfppSender->lptstrOfficePhone	= GetRegistryString(hRegKey, REGVAL_OFFICE_PHONE, TEXT(""))) ||
        !(pfppSender->lptstrBillingCode = GetRegistryString(hRegKey, REGVAL_BILLING_CODE, TEXT(""))) ||
		!(pfppSender->lptstrEmail       = GetRegistryString(hRegKey, REGVAL_MAILBOX, TEXT(""))))
	{
		DebugPrintEx(DEBUG_ERR, _T("Memory allocation failed."));
		hResult = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		goto error;
	}

	goto exit;
error:
	MemFree( pfppSender->lptstrName	);
	MemFree( pfppSender->lptstrFaxNumber);
	MemFree( pfppSender->lptstrCompany	);
	MemFree( pfppSender->lptstrStreetAddress);
	MemFree( pfppSender->lptstrCity);
	MemFree( pfppSender->lptstrState);
	MemFree( pfppSender->lptstrZip);
	MemFree( pfppSender->lptstrCountry);
	MemFree( pfppSender->lptstrTitle	);
	MemFree( pfppSender->lptstrDepartment);
	MemFree( pfppSender->lptstrOfficeLocation);
	MemFree( pfppSender->lptstrHomePhone);
	MemFree( pfppSender->lptstrOfficePhone);
	MemFree( pfppSender->lptstrBillingCode);
	MemFree( pfppSender->lptstrEmail);

exit:
	if (hRegKey)
    {
		RegCloseKey(hRegKey);
    }

    MemFree((PVOID)lpctstrCurrentUserName);
    MemFree((PVOID)lpctstrRegisteredOrganization);

	return hResult;
}

static HRESULT 
FaxFreePersonalProfileInformation(
		PFAX_PERSONAL_PROFILE	lpPersonalProfileInfo
	)
{
	if (lpPersonalProfileInfo) {
		MemFree(lpPersonalProfileInfo->lptstrName);            
		MemFree(lpPersonalProfileInfo->lptstrFaxNumber);       
		MemFree(lpPersonalProfileInfo->lptstrCompany);         
		MemFree(lpPersonalProfileInfo->lptstrStreetAddress);   
		MemFree(lpPersonalProfileInfo->lptstrCity);            
		MemFree(lpPersonalProfileInfo->lptstrState);           
		MemFree(lpPersonalProfileInfo->lptstrZip);             
		MemFree(lpPersonalProfileInfo->lptstrCountry);         
		MemFree(lpPersonalProfileInfo->lptstrTitle);           
		MemFree(lpPersonalProfileInfo->lptstrDepartment);      
		MemFree(lpPersonalProfileInfo->lptstrOfficeLocation);  
		MemFree(lpPersonalProfileInfo->lptstrHomePhone);       
		MemFree(lpPersonalProfileInfo->lptstrOfficePhone);
		MemFree(lpPersonalProfileInfo->lptstrEmail);
		MemFree(lpPersonalProfileInfo->lptstrBillingCode);	
		MemFree(lpPersonalProfileInfo->lptstrTSID);	
	}		
	return S_OK;
}

HRESULT	WINAPI
FaxFreeSenderInformation(
	PFAX_PERSONAL_PROFILE pfppSender
	)
/*++

Routine Description:

    This function frees sender information

Arguments:
	
	pfppSender - pointer to sender information
	
Return Value:

    S_OK

--*/
{
	return FaxFreePersonalProfileInformation(pfppSender);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\rpcutil.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rpcutil.c

Abstract:

    This module contains high level rpc wrapper apis.
    This code is here because the code in the rpcutil
    project uses NT apis and the WINFAX dll but load
    and run on win95.

Author:

    Wesley Witt (wesw) 13-Aug-1997


Revision History:

--*/

#include "faxapi.h"
#include "CritSec.h"
#pragma hdrstop

typedef RPC_STATUS (*PRPCSERVERUNREGISTERIFEX)(RPC_IF_HANDLE IfSpec, UUID __RPC_FAR * MgrTypeUuid, int RundownContextHandles);

#define MIN_PORT_NUMBER 1024
#define MAX_PORT_NUMBER 65534

#ifdef UNICODE
#define LPUTSTR unsigned short *
#else
#define LPUTSTR unsigned char *
#endif

CFaxCriticalSection g_CsFaxClientRpc;      // This critical section provides mutual exclusion
                                        // for all RPC server initialization operations:
                                        // 1. Registration counter (g_dwFaxClientRpcNumInst).
                                        // 2. Selecting free endpoint.
                                        // 3. Register the RPC interface
                                        // 4. Start listening for remote procedure calls.
                                        // 5. Stop listening for remote procedure calls.
                                        // 6. remove the interface.
                                        //
//
// IMPORTNAT!!! g_CsFaxClientRpc should not be used in the implementation of the RPC calls because it can cause a dead lock.
// because when the RPC server is going down in StopFaxClientRpcServer(), the wait opration (for all active calls to terminate) is inside g_CsFaxClientRpc. 
//
DWORD g_dwFaxClientRpcNumInst;
CFaxCriticalSection g_CsFaxAssyncInfo;	 // used to synchronize access to the assync info structures that are allocated on the heap (notification context).
TCHAR g_tszEndPoint[MAX_ENDPOINT_LEN];   // Buffer to hold selected port (endpoint)
                                                         // for RPC protoqol sequence
static
RPC_STATUS
SafeRpcServerUnregisterIf(
 VOID
)
/*
Routine Description:

    This function calls RpcServerUnregisterIfEx if it is exported from RPCRT4.DLL (WinXP and up).
	Otherwise it calls RpcServerUnregisterIf which is subject to rundown calls even after the interface is unregistered.

Arguments:

    none

Return Value:

    Win32 errors
*/
{
	HMODULE hModule = NULL;
	RPC_STATUS RpcStatus;
	DEBUG_FUNCTION_NAME(TEXT("SafeRpcServerUnregisterIf"));

	if (hModule =  LoadLibrary(TEXT("RPCRT4.DLL")))
	{
		PRPCSERVERUNREGISTERIFEX pRpcServerUnregisterIfEx = NULL;
		if (pRpcServerUnregisterIfEx = (PRPCSERVERUNREGISTERIFEX)GetProcAddress(hModule, "RpcServerUnregisterIfEx"))
		{
			RpcStatus = (*pRpcServerUnregisterIfEx)(faxclient_ServerIfHandle, 0, FALSE);
			goto Exit;
		}
		else
		{
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("GetProcAddress RpcServerUnregisterIfEx failed: %ld"),
				GetLastError());
		}
	}
	else
	{
		DebugPrintEx(
            DEBUG_ERR,
            TEXT("LoadLibrary RPCRT4.DLL failed: %ld"),
            GetLastError());
	}

	DebugPrintEx(
		DEBUG_WRN,
		TEXT("Calling RpcServerUnregisterIf !!!"));
	RpcStatus = RpcServerUnregisterIf(faxclient_ServerIfHandle, 0, FALSE); 
Exit:		
	if (hModule)
	{
		FreeLibrary(hModule);
	}
	return RpcStatus;
}



BOOL
FaxClientInitRpcServer(
    VOID
    )
/*++

Routine Description:

    This function initializes the critical section used to protect the
    global server handle, instance count and assync info structures (notification context).

Arguments:

    none

Return Value:

    none

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxClientInitRpcServer"));

	ZeroMemory (g_tszEndPoint, sizeof(g_tszEndPoint));
	g_dwFaxClientRpcNumInst = 0;

	if (!g_CsFaxClientRpc.Initialize() ||
		!g_CsFaxAssyncInfo.Initialize())    
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection.Initialize (g_CsFaxClientRpc or g_CsFaxAssyncInfo) failed: %ld"),
            GetLastError());
        return FALSE;
    }    
    return TRUE;
}

VOID
FaxClientTerminateRpcServer (VOID)
/*++
Routine Description: Delete critical section when PROCESS_DETACH.


--*/
{
    g_CsFaxClientRpc.SafeDelete();	
	g_CsFaxAssyncInfo.SafeDelete();
    return;
}

DWORD
StopFaxClientRpcServer(
    VOID
    )

/*++

Routine Description:

    Stops the RPC server. Deletes the interface.
    Note that an endpoint is allocated to a process as long as the process lives.

Arguments:    

Return Value:

    NERR_Success, or any RPC error codes that can be returned from
    RpcServerUnregisterIf/Ex.

--*/
{
    RPC_STATUS RpcStatus = RPC_S_OK;
    DEBUG_FUNCTION_NAME(TEXT("StopFaxClientRpcServer"));

    EnterCriticalSection(&g_CsFaxClientRpc);
	if (0 == g_dwFaxClientRpcNumInst)
	{
		//
		// This can happen if the client tried to unregister from events using an invalid handle, or used the same handle twice
		//
		DebugPrintEx(
                DEBUG_ERR,
                TEXT("StopFaxClientRpcServer was called when the clients reference count was 0"));
		LeaveCriticalSection(&g_CsFaxClientRpc);
		return ERROR_INVALID_PARAMETER;
	}

    g_dwFaxClientRpcNumInst--;
    if (g_dwFaxClientRpcNumInst == 0)
    {
        RpcStatus = RpcMgmtStopServerListening(NULL);
        if (RPC_S_OK != RpcStatus)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcMgmtStopServerListening failed. (ec: %ld)"),
                RpcStatus);
        }

        RpcStatus = SafeRpcServerUnregisterIf();
        if (RPC_S_OK != RpcStatus)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SafeRpcServerUnregisterIf failed. (ec: %ld)"),
                RpcStatus);
        }

        RpcStatus = RpcMgmtWaitServerListen();
        if (RPC_S_OK != RpcStatus)
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RpcMgmtStopServerListening failed. (ec: %ld)"),
                    RpcStatus);
            goto exit;
        }

    }

exit:
    LeaveCriticalSection(&g_CsFaxClientRpc);

    return(RpcStatus);
}


DWORD
FaxClientUnbindFromFaxServer(
    IN RPC_BINDING_HANDLE  BindingHandle
    )

/*++

Routine Description:

    Unbinds from the RPC interface.
    If we decide to cache bindings, this routine will do something more
    interesting.

Arguments:

    BindingHandle - This points to the binding handle that is to be closed.


Return Value:


    STATUS_SUCCESS - the unbinding was successful.

--*/
{
    RPC_STATUS       RpcStatus;

    if (BindingHandle != NULL) {
        RpcStatus = RpcBindingFree(&BindingHandle);
    }

    return(ERROR_SUCCESS);
}

#if !defined(WIN95)

RPC_STATUS RPC_ENTRY FaxClientSecurityCallBack(
    IN RPC_IF_HANDLE idIF, 
    IN void *ctx
    ) 
/*++

Routine Description:

    Security callback function is automatically called when
    any RPC server function is called. (usually, once per client - but in some cases, 
                                        the RPC run time may call the security-callback function more than 
                                        once per client-per interface - For example when talking with BOS server
                                        with no authentication).

    The call-back will deny access for:
        o clients with a protocol other then ncacn_ip_tcp

Arguments:

    idIF - UUID and version of the interface.
    ctx  - Pointer to an RPC_IF_ID server binding handle representing the client. 

Return Value:

    The callback function should return RPC_S_OK if the client is allowed to call methods in this interface. 
    Any other return code will cause the client to receive the exception RPC_S_ACCESS_DENIED.

--*/
{
    RPC_STATUS status = RPC_S_OK;    
    RPC_STATUS rpcStatRet = RPC_S_OK;

    LPTSTR lptstrProtSeq = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxClientSecurityCallBack"));
    
    //
    //  Query the client's protseq
    //
    status = GetRpcStringBindingInfo(ctx,
                                     NULL,
                                     &lptstrProtSeq);
    if (status != RPC_S_OK) 
    {
		DebugPrintEx(DEBUG_ERR,
                     TEXT("RpcBindingServerFromClient failed - (ec: %lu)"), 
                     status);
		rpcStatRet = ERROR_ACCESS_DENIED;
        goto exit;
	}


    if (_tcsicmp((TCHAR*)lptstrProtSeq, RPC_PROT_SEQ_TCP_IP))
    {
		DebugPrintEx(DEBUG_ERR,
                     TEXT("Client not using TCP/IP protSeq.")
                     );
		rpcStatRet = ERROR_ACCESS_DENIED;
        goto exit;
    }

exit:
    if(NULL != lptstrProtSeq)
    {
        MemFree(lptstrProtSeq);
    }

	return rpcStatRet;
}   // FaxClientSecurityCallBack

#endif

DWORD
StartFaxClientRpcServer(
	VOID
    )

/*++

Routine Description:

    Starts an RPC Server,  and adds the interface (dispatch table).

Arguments:      

Return Value:

      Standard Win32 or RPC error code.


--*/
{
    DWORD ec = RPC_S_OK;
    DEBUG_FUNCTION_NAME(TEXT("StartFaxClientRpcServer"));

    EnterCriticalSection(&g_CsFaxClientRpc);

    if (0 == _tcslen(g_tszEndPoint))
    {
        //
        // Endpoint not yet allocated for this Fax handle. Find a free endpoint.
        // Note that an endpoint is allocated to a process as long as the process lives.
        TCHAR tszFreeEndPoint[MAX_ENDPOINT_LEN] = {0};
        DWORD i;
        DWORD PortNumber;

        for (i = MIN_PORT_NUMBER; i < MIN_PORT_NUMBER + 10 ; i++ )
        {
            //
            // Search for a free end point.
            // If we fail for an error other than a duplicate endpoint, we loop for nothing.
            // We do so since diffrent platformns (W2K, NT4, Win9X) return diffrent error codes for duplicate enpoint.
            //
            for (PortNumber = i; PortNumber < MAX_PORT_NUMBER; PortNumber += 10)
            {
                _stprintf (tszFreeEndPoint, TEXT("%d"), PortNumber);
                ec = RpcServerUseProtseqEp  ( (LPUTSTR)RPC_PROT_SEQ_TCP_IP,
                                              RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                              (LPUTSTR)tszFreeEndPoint,
                                              NULL);
                if (RPC_S_OK == ec)
                {
                    _tcscpy (g_tszEndPoint, tszFreeEndPoint);
					DebugPrintEx(
                        DEBUG_MSG,
                        TEXT("Found free endpoint - %s"),
                        tszFreeEndPoint);
                    break;
                }
            }
            if (RPC_S_OK == ec)
            {
                break;
            }
        }
    }    

    if (0 == g_dwFaxClientRpcNumInst)
    {
        //
        //  First rpc server instance - register interface, start listening for remote procedure calls
        //

        //
        // Register interface
        //

        //
        //  The logic for registering the interface written below is done to preserve 
        //  BOS capability of sending notifications.
        //  BOS Fax server does not "talk" with it's clients in a secure channel. 
        //
        //  Only on .NET OS we can call RpcServerRegisterIfEx for registering callback function even 
        //  when the RPC client is anonymous (using the RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH flag that 
        //  were introduce only on .NET).
        //
        //  On all other OS we use RpcServerRegisterIf and have no callback.
        //  
        //  The callback will only check for proper ProtSeq. 
        //  We will check for proper authentication level (RPC_C_AUTHN_LEVEL_PKT_PRIVACY from .NET fax server
        //  and no authentication for BOS fax server)
        //


#if defined(WIN95)
        //
        //  Win9x OS
        //
        ec = RpcServerRegisterIf  (faxclient_ServerIfHandle, 
                                    0,
                                    0);
        if (RPC_S_OK != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcServerRegisterIf failed (ec = %lu)"),
                ec);
            goto exit;
        }
#else
        //
        //  NT4 and later OS
        //
        
        
        if (IsWinXPOS())
        {
            //
            //  Running on .NET OS (XP client does not run this code)
            //
            ec = RpcServerRegisterIfEx (faxclient_ServerIfHandle, 
                                        0,
                                        0,
                                        RPC_IF_ALLOW_CALLBACKS_WITH_NO_AUTH,         
                                        RPC_C_LISTEN_MAX_CALLS_DEFAULT,   // Relieves the RPC run-time environment from enforcing an unnecessary restriction
                                        FaxClientSecurityCallBack         // CallBack function address
                                        );
            if (RPC_S_OK != ec)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RpcServerRegisterIfEx failed (ec = %lu)"),
                    ec);
                goto exit;
            }
        }
        else
        {
            //
            //  Running on NT4 or Win2K OS
            //
            ec = RpcServerRegisterIf  (faxclient_ServerIfHandle, 
                                        0,
                                        0);
            if (RPC_S_OK != ec)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RpcServerRegisterIf failed (ec = %lu)"),
                    ec);
                goto exit;
            }
        }
 #endif
        
        //
        // We use NTLM authentication RPC calls
        //
        ec = RpcServerRegisterAuthInfo (
                        (LPUTSTR)TEXT(""),          // Igonred by RPC_C_AUTHN_WINNT
                        RPC_C_AUTHN_WINNT,          // NTLM SPP authenticator
                        NULL,                       // Ignored when using RPC_C_AUTHN_WINNT
                        NULL);                      // Ignored when using RPC_C_AUTHN_WINNT
        if (ec != RPC_S_OK)
        {
            RPC_STATUS RpcStatus;

            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcServerRegisterAuthInfo() failed (ec: %ld)"),
                ec);
            //
            //  Unregister the interface if it is the first instance
            //
            RpcStatus = SafeRpcServerUnregisterIf();
            if (RPC_S_OK != RpcStatus)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SafeRpcServerUnregisterIf failed. (ec: %ld)"),
                    RpcStatus);
            }

            goto exit;
        }


        // The first argument specifies the minimum number of threads to
        // be created to handle calls; the second argument specifies the
        // maximum number of concurrent calls allowed.  The last argument
        // indicates not to wait.
        ec = RpcServerListen (1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, 1);
        if (ec != RPC_S_OK)
        {
            RPC_STATUS RpcStatus;

            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcServerListen failed (ec = %ld"),
                ec);

            //
            //  Unregister the interface if it is the first instance
            //
            RpcStatus = SafeRpcServerUnregisterIf();
            if (RPC_S_OK != RpcStatus)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SafeRpcServerUnregisterIf failed. (ec: %ld)"),
                    RpcStatus);
            }
            goto exit;
        }
    }

    g_dwFaxClientRpcNumInst++;

exit:
    LeaveCriticalSection(&g_CsFaxClientRpc);
    return ec;
}

DWORD
FaxClientBindToFaxServer(
    IN  LPCTSTR               lpctstrServerName,
    IN  LPCTSTR               lpctstrServiceName,
    IN  LPCTSTR               lpctstrNetworkOptions,
    OUT RPC_BINDING_HANDLE   * pBindingHandle
    )
/*++

Routine Description:

    Binds to the RPC server if possible.

Arguments:

    ServerName - Name of server to bind with.

    ServiceName - Name of service to bind with.

    pBindingHandle - Location where binding handle is to be placed

Return Value:

    STATUS_SUCCESS - The binding has been successfully completed.

    STATUS_INVALID_COMPUTER_NAME - The ServerName syntax is invalid.

    STATUS_NO_MEMORY - There is not sufficient memory available to the
        caller to perform the binding.

--*/
{
    RPC_STATUS        RpcStatus;
    LPTSTR            StringBinding;
    LPTSTR            Endpoint;
    LPTSTR            NewServerName = NULL;
    DWORD             dwResult;
    DEBUG_FUNCTION_NAME(TEXT("FaxClientBindToFaxServer"));

    *pBindingHandle = NULL;

    if (IsLocalMachineName (lpctstrServerName))
    {
        NewServerName = NULL;
    }
    else
    {
        NewServerName = (LPTSTR)lpctstrServerName;
    }
    //
    // We need to concatenate \pipe\ to the front of the service
    // name.
    //
    Endpoint = (LPTSTR)LocalAlloc(
                    0,
                    sizeof(NT_PIPE_PREFIX) + TCSSIZE(lpctstrServiceName));
    if (Endpoint == 0)
    {
       dwResult = STATUS_NO_MEMORY;
       goto exit;
    }
    _tcscpy(Endpoint,NT_PIPE_PREFIX);
    _tcscat(Endpoint,lpctstrServiceName);

    if (!NewServerName)
    {
        //
        // Local connection only - Make sure the service is up
        //
        if (!EnsureFaxServiceIsStarted (NULL))
        {
            dwResult = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("EnsureFaxServiceIsStarted failed (ec = %ld"),
                dwResult);
        }
        else
        {
            //
            // Wait till the RPC service is up an running
            //
            if (!WaitForServiceRPCServer (60 * 1000))
            {
                dwResult = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("WaitForServiceRPCServer failed (ec = %ld"),
                    dwResult);
            }
        }
    }
    //
    // Start RPC connection binding
    //
    RpcStatus = RpcStringBindingCompose(
                    0,
                    (LPUTSTR)RPC_PROT_SEQ_NP,
                    (LPUTSTR)NewServerName,
                    (LPUTSTR)Endpoint,
                    (LPUTSTR)lpctstrNetworkOptions,
                    (LPUTSTR *)&StringBinding);
    LocalFree(Endpoint);

    if ( RpcStatus != RPC_S_OK )
    {
        dwResult = STATUS_NO_MEMORY;
        goto exit;
    }

    RpcStatus = RpcBindingFromStringBinding((LPUTSTR)StringBinding, pBindingHandle);
    RpcStringFree((LPUTSTR *)&StringBinding);
    if ( RpcStatus != RPC_S_OK )
    {
        *pBindingHandle = NULL;
        if (   (RpcStatus == RPC_S_INVALID_ENDPOINT_FORMAT)
            || (RpcStatus == RPC_S_INVALID_NET_ADDR) )
        {
            dwResult =  ERROR_INVALID_COMPUTERNAME ;
            goto exit;
        }
        dwResult = STATUS_NO_MEMORY;
        goto exit;
    }
    dwResult = ERROR_SUCCESS;

exit:
    return dwResult;
}   // FaxClientBindToFaxServer
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

Author:

    Wesley Witt (wesw)

!ENDIF

!include ..\..\..\faxsrc.inc

TARGETTYPE=DYNLINK
TARGETNAME=$(WINFAX)

C_DEFINES = $(C_DEFINES) -DTARGET_NAME=$(TARGETNAME)

UMTYPE=windows

DLLDEF=$O\winfax.def
DLLENTRY=_DllMainCRTStartup

SYNCHRONIZE_BLOCK=1
USE_CRTDLL=1

USECXX_FLAG=/Tp
USE_NATIVE_EH=1


INCLUDES=\
  $(INCLUDES);  \
  $(FAXROOT)\print\faxprint\inc; \
  $(FAXROOT)\faxcover\renderer;  \
  ..\..\..\tiff\inc; \
  ..\..\inc;    \
  ..\..\registry


TARGETLIBS=\
  $(BASEDIR)\public\sdk\lib\*\rpcrt4.lib      \
  $(BASEDIR)\public\sdk\lib\*\kernel32.lib    \
  $(BASEDIR)\public\sdk\lib\*\shell32.lib     \
  $(BASEDIR)\public\sdk\lib\*\advapi32.lib    \
  $(BASEDIR)\public\sdk\lib\*\winspool.lib    \
  $(BASEDIR)\public\sdk\lib\*\gdi32.lib       \
  $(BASEDIR)\public\sdk\lib\*\user32.lib      \
  $(BASEDIR)\public\sdk\lib\*\ole32.lib       \
  $(BASEDIR)\public\sdk\lib\*\uuid.lib        \
  $(BASEDIR)\public\sdk\lib\*\oleaut32.lib    \
  $(BASEDIR)\public\sdk\lib\*\version.lib


SOURCES=\
  ..\clirpc.c   \
  ..\config.c   \
  ..\faxapi.c   \
  ..\handle.c   \
  ..\job.c      \
  ..\port.c     \
  ..\print.c    \
  ..\rpcutil.c  \
  ..\util.c     \
  ..\winfax.c   \
  ..\install.c  \
  ..\Sender.c	\
  ..\faxapi.rc
  

PRECOMPILED_INCLUDE=faxapi.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

!ifndef NOUNICODE
PASS1_PUBLISH=\
    {$(FAXLIB)\$(TARGET_DIRECTORY)\$(WINFAX).LIB=$(PRINTSCAN_LIB_PATH)\$(WINFAX).LIB}
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\util.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    print.c

Abstract:

    This module contains utilitarian functions.

Author:

    Wesley Witt (wesw) 29-Nov-1996


Revision History:

--*/
#include "faxapi.h"
#pragma hdrstop

#include <mbstring.h>



BOOL
ConvertUnicodeStringInPlace(
    LPCWSTR lptstrUnicodeString
    )
/*++

Routine name : ConvertUnicodeStringInPlace

Routine description:

    Converts a Unicode string to a multi-byte string and stores that multi-byte string 
    in the original Unicode buffer.
    
    Notice: In some bizarre code pages, with some very bizarre Unicode strings, the 
            converted multi-byte string can be longer (in bytes) than the original Unicode string.
            In that case, it's OK to just detect and fail. 
            The cases where it will fail are rare and odd. 
            The only real threat today is via a hacker who is deliberately looking for these cases.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lptstrUnicodeString [in / out ] - On input, the Unicode string.
                                      On output, the MBCS string.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    LPSTR AnsiString;
    DEBUG_FUNCTION_NAME(TEXT("ConvertUnicodeStringInPlace"));

    if (NULL == lptstrUnicodeString)
    {
        return TRUE;
    }
    AnsiString = UnicodeStringToAnsiString(lptstrUnicodeString);
    if (AnsiString) 
    {
        if (sizeof (WCHAR) * (1 + wcslen(lptstrUnicodeString)) < sizeof (CHAR) * (1 + _mbstrlen(AnsiString)))
        {
            //
            // Ooops! MBCS string takes longer then original Unicode String.
            // In some bizarre code pages, with some very bizarre Unicode strings, the 
            // converted multi-byte string can be longer (in bytes) than the original Unicode string.
            // In that case, it's OK to just detect and fail. 
            // The cases where it will fail are rare and odd. 
            // The only real threat today is via a hacker who is deliberately looking for these cases
            //
            MemFree(AnsiString);
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }            
        _mbscpy((PUCHAR)lptstrUnicodeString, (PUCHAR)AnsiString);
        MemFree(AnsiString);
    }
    else
    {   
        return FALSE;
    }
    return TRUE;
}   // ConvertUnicodeStringInPlace


BOOL
WINAPI
FaxCompleteJobParamsA(
    IN OUT PFAX_JOB_PARAMA *JobParamsBuffer,
    IN OUT PFAX_COVERPAGE_INFOA *CoverpageInfoBuffer
    )
{
    PFAX_JOB_PARAMA JobParams;
    PFAX_COVERPAGE_INFOA CoverpageInfo;
    DEBUG_FUNCTION_NAME(TEXT("FaxCompleteJobParamsA"));

    if (!JobParamsBuffer || !CoverpageInfoBuffer) 
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *JobParamsBuffer = NULL;
    *CoverpageInfoBuffer = NULL;

    if (!FaxCompleteJobParamsW((PFAX_JOB_PARAMW *)JobParamsBuffer,(PFAX_COVERPAGE_INFOW *)CoverpageInfoBuffer) ) 
    {
        return FALSE;
    }

    JobParams = *JobParamsBuffer;
    CoverpageInfo  = *CoverpageInfoBuffer;

    if (!ConvertUnicodeStringInPlace( (LPWSTR) JobParams->Tsid)                 ||
        !ConvertUnicodeStringInPlace( (LPWSTR) JobParams->SenderName)           ||
        !ConvertUnicodeStringInPlace( (LPWSTR) JobParams->SenderCompany)        ||
        !ConvertUnicodeStringInPlace( (LPWSTR) JobParams->SenderDept)           ||
        !ConvertUnicodeStringInPlace( (LPWSTR) JobParams->BillingCode)          ||
        !ConvertUnicodeStringInPlace( (LPWSTR) JobParams->DeliveryReportAddress)||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrName)          ||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrFaxNumber)     ||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrCompany)       ||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrAddress)       ||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrTitle)         ||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrDepartment)    ||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrOfficeLocation)||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrHomePhone)     ||
        !ConvertUnicodeStringInPlace( (LPWSTR) CoverpageInfo->SdrOfficePhone))
    {
        DebugPrintEx(DEBUG_ERR, _T("ConvertUnicodeStringInPlace failed, ec = %ld."), GetLastError());
        MemFree (*JobParamsBuffer);
        MemFree (*CoverpageInfoBuffer);
        return FALSE;
    }
    return TRUE;
}   // FaxCompleteJobParamsA

BOOL
WINAPI
FaxCompleteJobParamsW(
    IN OUT PFAX_JOB_PARAMW *JobParamsBuffer,
    IN OUT PFAX_COVERPAGE_INFOW *CoverpageInfoBuffer
    )

{


#define RegStrLen(pValueName,lpdwNeeded) \
        RegQueryValueEx(hKey,pValueName,NULL,NULL,NULL,lpdwNeeded)


#define RegStrCpy(pValueName, szPointer, Offset) \
        dwNeeded = 256*sizeof(TCHAR); \
        rslt = RegQueryValueEx(hKey,pValueName,NULL,NULL,(LPBYTE)TempBuffer,&dwNeeded);\
        if (rslt == ERROR_SUCCESS) { \
         szPointer = Offset; \
         wcscpy((LPWSTR)Offset,TempBuffer); \
         Offset = Offset + wcslen(Offset) +1; \
        }

    PFAX_JOB_PARAMW JobParams = NULL;
    PFAX_COVERPAGE_INFOW CoverpageInfo = NULL;
    HKEY hKey;
    BOOL fSuccess=FALSE;
    long rslt = ERROR_SUCCESS;
    DWORD dwJobNeeded = sizeof (FAX_JOB_PARAMW);
    DWORD dwCoverNeeded = sizeof (FAX_COVERPAGE_INFOW);
    DWORD dwNeeded = 0;
    WCHAR *CPOffset = NULL, *JobOffset = NULL;
    WCHAR TempBuffer[256];

    if (!JobParamsBuffer || !CoverpageInfoBuffer) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    *JobParamsBuffer = NULL;
    *CoverpageInfoBuffer = NULL;

    //
    // open the key holding our data
    //
    rslt = RegOpenKeyEx(HKEY_CURRENT_USER,REGKEY_FAX_USERINFO,0,KEY_READ,&hKey);

    if (rslt != ERROR_SUCCESS &&
        rslt != ERROR_FILE_NOT_FOUND)
    {
        SetLastError(rslt);
        return FALSE;
    }

    //
    // find out how much space we need
    //
    if (ERROR_SUCCESS == rslt)
    {
        //
        // Copy data from registry only if it available.
        //
        RegStrLen(REGVAL_FULLNAME,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;
        dwJobNeeded +=dwNeeded+1;

        RegStrLen(REGVAL_COMPANY,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;
        dwJobNeeded +=dwNeeded+1;

        RegStrLen(REGVAL_DEPT,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;
        dwJobNeeded +=dwNeeded+1;

        RegStrLen(REGVAL_FAX_NUMBER,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;
        dwJobNeeded +=dwNeeded+1;

        RegStrLen(REGVAL_ADDRESS,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;

        RegStrLen(REGVAL_TITLE,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;

        RegStrLen(REGVAL_OFFICE,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;

        RegStrLen(REGVAL_HOME_PHONE,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;

        RegStrLen(REGVAL_OFFICE_PHONE,&dwNeeded);
        dwCoverNeeded += dwNeeded+1;

        RegStrLen(REGVAL_BILLING_CODE,&dwNeeded);
        dwJobNeeded +=dwNeeded+1;

        RegStrLen(REGVAL_MAILBOX,&dwNeeded);
        // one for email address, one for DR address
        dwJobNeeded +=dwNeeded+1;
        dwJobNeeded +=dwNeeded+1;
    }

    //
    // alloc the space
    //
    JobParams = (PFAX_JOB_PARAMW)MemAlloc(dwJobNeeded*sizeof(WCHAR));
    CoverpageInfo = (PFAX_COVERPAGE_INFOW)MemAlloc(dwCoverNeeded*sizeof(WCHAR));

    if (!JobParams || !CoverpageInfo ) {
       RegCloseKey(hKey);

       if (JobParams) {
           MemFree( JobParams );
       }

       if (CoverpageInfo) {
           MemFree( CoverpageInfo );
       }

       SetLastError (ERROR_NOT_ENOUGH_MEMORY);
       return FALSE;
    }

    //
    // fill in the data
    //

    ZeroMemory(JobParams,sizeof(FAX_JOB_PARAMW) );
    JobParams->SizeOfStruct = sizeof(FAX_JOB_PARAMW);
    JobParams->ScheduleAction = JSA_NOW;
    JobParams->DeliveryReportType = DRT_NONE;

    ZeroMemory(CoverpageInfo,sizeof(FAX_COVERPAGE_INFOW));
    CoverpageInfo->SizeOfStruct = sizeof(FAX_COVERPAGE_INFOW);

    if (ERROR_SUCCESS == rslt)
    {
        //
        // Copy data from registry only if it available.
        //
        CPOffset = (WCHAR *) (  (LPBYTE) CoverpageInfo + sizeof(FAX_COVERPAGE_INFOW));
        JobOffset = (WCHAR *)(  (LPBYTE) JobParams + sizeof(FAX_JOB_PARAMW));


        RegStrCpy(REGVAL_FULLNAME,CoverpageInfo->SdrName,CPOffset);
        RegStrCpy(REGVAL_FULLNAME,JobParams->SenderName,JobOffset);

        RegStrCpy(REGVAL_COMPANY,CoverpageInfo->SdrCompany,CPOffset);
        RegStrCpy(REGVAL_COMPANY,JobParams->SenderCompany,JobOffset);

        RegStrCpy(REGVAL_DEPT,CoverpageInfo->SdrDepartment,CPOffset);
        RegStrCpy(REGVAL_DEPT,JobParams->SenderDept,JobOffset);

        RegStrCpy(REGVAL_FAX_NUMBER,CoverpageInfo->SdrFaxNumber,CPOffset);
        RegStrCpy(REGVAL_FAX_NUMBER,JobParams->Tsid,JobOffset);

        RegStrCpy(REGVAL_ADDRESS,CoverpageInfo->SdrAddress,CPOffset);
        RegStrCpy(REGVAL_TITLE,CoverpageInfo->SdrTitle,CPOffset);
        RegStrCpy(REGVAL_OFFICE,CoverpageInfo->SdrOfficeLocation,CPOffset);
        RegStrCpy(REGVAL_HOME_PHONE,CoverpageInfo->SdrHomePhone,CPOffset);
        RegStrCpy(REGVAL_OFFICE_PHONE,CoverpageInfo->SdrOfficePhone,CPOffset);

        RegStrCpy(REGVAL_BILLING_CODE,JobParams->BillingCode,CPOffset);
        RegStrCpy(REGVAL_MAILBOX,JobParams->DeliveryReportAddress,CPOffset);
    }

    *JobParamsBuffer = (PFAX_JOB_PARAMW)JobParams;
    *CoverpageInfoBuffer = (PFAX_COVERPAGE_INFOW) CoverpageInfo;
    fSuccess = TRUE;

    RegCloseKey(hKey);
    return fSuccess;
}

BOOL
IsLocalFaxConnection(
    HANDLE FaxHandle
    )
{
    DEBUG_FUNCTION_NAME(TEXT("IsLocalFaxConnection"));

    if (!FaxHandle) 
    {
        DebugPrintEx(DEBUG_ERR, TEXT("FaxHandle is NULL."));
        SetLastError( ERROR_INVALID_HANDLE );
        return FALSE;
    }
    return IsLocalMachineName (FH_DATA(FaxHandle)->MachineName);
}   // IsLocalFaxConnection
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\publicnt4\faxapi.h ===
#include "..\faxapip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\public95\faxapi.h ===
#include "..\faxapip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\publicnt\faxapi.h ===
#include "..\faxapip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\client\winfax.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    winfax.c

Abstract:

    This module contains routines for the winfax dllinit.

Author:

    Wesley Witt (wesw) 22-Jan-1996

--*/

#include "faxapi.h"
#pragma hdrstop

HINSTANCE g_MyhInstance;
static BOOL gs_fFXSAPIInit;

#define FAX_API_DEBUG_LOG_FILE  _T("FXSAPIDebugLogFile.txt")

#ifdef __cplusplus
extern "C" {
#endif

DWORD
DllMain(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )

/*++

Routine Description:

    DLL initialization function.

Arguments:

    hInstance   - Instance handle
    Reason      - Reason for the entrypoint being called
    Context     - Context record

Return Value:

    TRUE        - Initialization succeeded
    FALSE       - Initialization failed

--*/
{

    if (Reason == DLL_PROCESS_ATTACH)
    {
		OPEN_DEBUG_FILE(FAX_API_DEBUG_LOG_FILE);
        g_MyhInstance = hInstance;
        DisableThreadLibraryCalls( hInstance );
        gs_fFXSAPIInit = FXSAPIInitialize();
        return gs_fFXSAPIInit;
    }

    if (Reason == DLL_PROCESS_DETACH)
    {
        FXSAPIFree();       
		CLOSE_DEBUG_FILE;
    }

    return TRUE;
}

//
// FXSAPIInitialize and FXSAPIFree are private and are called by the service only
// Becuase the process is not always terminated when the service is stopped, and not all DLL are freed,
// DLL_PROCESS_ATTACH is not always called when the service starts. Therefore it calls FXSAPIInitialize().
//

BOOL
FXSAPIInitialize(
    VOID
    )
{
    if (TRUE == gs_fFXSAPIInit)
    {
        return TRUE;
    }
    if (!FaxClientInitRpcServer())
    {
        return FALSE;
    }
    return TRUE;
}

VOID
FXSAPIFree(
    VOID
    )
{
    FaxClientTerminateRpcServer();  
	HeapCleanup();
    gs_fFXSAPIInit = FALSE;
    return;
}





#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\deviceprop.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    DeviceProp.h

Abstract:

    Holds outbound routing configuraton per single device

Author:

    Eran Yariv (EranY)  Nov, 1999

Revision History:

--*/

#ifndef _DEVICE_PROP_H_
#define _DEVICE_PROP_H_

#include "critsec.h"
/************************************
*                                   *
*      CDeviceRoutingInfo           *
*                                   *
************************************/

class CDeviceRoutingInfo
{
public:

    CDeviceRoutingInfo (DWORD Id);
    ~CDeviceRoutingInfo ();

    DWORD Id ()             { return m_dwId; }

    BOOL IsStoreEnabled ()  { return (m_dwFlags & LR_STORE) ? TRUE : FALSE; }
    BOOL IsPrintEnabled ()  { return (m_dwFlags & LR_PRINT) ? TRUE : FALSE; }
    BOOL IsEmailEnabled ()  { return (m_dwFlags & LR_EMAIL) ? TRUE : FALSE; }

    DWORD ReadConfiguration ();

    DWORD EnableStore (BOOL bEnabled);
    DWORD EnablePrint (BOOL bEnabled);
    DWORD EnableEmail (BOOL bEnabled);

    BOOL GetStoreFolder (wstring &strFolder);
    BOOL GetPrinter (wstring &strPrinter);
    BOOL GetSMTPTo (wstring &strSMTP);

    DWORD   SetStoreFolder (LPCWSTR lpcwstrCfg) 
    { 
        return SetStringValue (m_strStoreFolder, REGVAL_RM_FOLDER_GUID, lpcwstrCfg); 
    }

    DWORD   SetPrinter (LPCWSTR lpcwstrCfg) 
    { 
        return SetStringValue (m_strPrinter, REGVAL_RM_PRINTING_GUID, lpcwstrCfg); 
    }

    DWORD   SetSMTPTo (LPCWSTR lpcwstrCfg) 
    { 
        return SetStringValue (m_strSMTPTo, REGVAL_RM_EMAIL_GUID, lpcwstrCfg); 
    }

    HRESULT ConfigChange (  LPCWSTR     lpcwstrNameGUID,    // Configuration name
                            LPBYTE      lpData,             // New configuration data
                            DWORD       dwDataSize          // Size of new configuration data
                         );

    DWORD RegisterForChangeNotifications ();
    DWORD UnregisterForChangeNotifications ();


private:

    #define NUM_NOTIFICATIONS 4

    DWORD EnableFlag (DWORD dwFlag, BOOL  bEnable);
    DWORD SetStringValue (wstring &wstr, LPCWSTR lpcwstrGUID, LPCWSTR lpcwstrCfg);
    DWORD CheckMailConfig (LPBOOL lpbConfigOk);

    wstring m_strStoreFolder;
    wstring m_strPrinter;
    wstring m_strSMTPTo;  

    DWORD   m_dwFlags;
    DWORD   m_dwId;
    HANDLE  m_NotificationHandles[NUM_NOTIFICATIONS];

};  // CDeviceRoutingInfo


/************************************
*                                   *
*            CDevicesMap            *
*                                   *
************************************/

typedef map <DWORD, CDeviceRoutingInfo *> DEVICES_MAP, *PDEVICES_MAP;

class CDevicesMap
{
public:
    
    CDevicesMap () : m_bInitialized (FALSE) {}
    ~CDevicesMap ();

    DWORD Init ();  // Initialize internals

    CDeviceRoutingInfo *FindDeviceRoutingInfo (DWORD dwDeviceId);   // Just lookup device in map
    CDeviceRoutingInfo *GetDeviceRoutingInfo (DWORD dwDeviceId);    // Lookup and create device not found in map

private:

    BOOL                m_bInitialized; // Was critical section initialized?
    CRITICAL_SECTION    m_CsMap;        // Critical section to protect map access
    DEVICES_MAP         m_Map;          // Map of known devices
};  // CDevicesMap

/************************************
*                                   *
*              Externals            *
*                                   *
************************************/

extern CDevicesMap g_DevicesMap;   // Global map of known devices (used for late discovery).
extern CFaxCriticalSection g_csRoutingStrings;  // Global critical section to protect the access to 
												// the strings of the routing methods.

#endif // _DEVICE_PROP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\faxrtp.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

	faxrtp.h

Abstract:

	Precompiled header of entire project

Author:

	Eran Yariv (EranY)	Nov, 1999

Revision History:

--*/

#ifndef _FAX_RTP_H_
#define _FAX_RTP_H_

#ifndef __cplusplus
#error The Microsoft Fax Routing Extension must be compiled as a C++ module
#endif

#pragma warning (disable : 4786)    // identifier was truncated to '255' characters in the debug information

#include <windows.h>
#include <winspool.h>
#include <mapi.h>
#include <mapix.h>
#include <tchar.h>
#include <shlobj.h>
#include <faxroute.h>
#include <faxext.h>
#include "tifflib.h"
#include "tiff.h"
#include "faxutil.h"
#include "faxevent_messages.h"
#include "faxmsg.h"
#include "fxsapip.h"
#include "resource.h"
#include "faxreg.h"
#include "faxsvcrg.h"
#include "faxevent.h"
#include "faxres.h"
#include "FaxRouteP.h"
#include <map>
#include <string>
using namespace std;
#include "DeviceProp.h"
#include "Dword2Str.h"

typedef struct _MESSAGEBOX_DATA {
    LPCTSTR              Text;                      //
    LPDWORD             Response;                   //
    DWORD               Type;                       //
} MESSAGEBOX_DATA, *PMESSAGEBOX_DATA;


extern HINSTANCE           g_hModule;
extern HINSTANCE		   g_hResource;


VOID
InitializeStringTable(
    VOID
    );

BOOL
TiffRoutePrint(
    LPCTSTR TiffFileName,
    PTCHAR  Printer
    );

BOOL
FaxMoveFile(
    LPCTSTR  TiffFileName,
    LPCTSTR  DestDir
    );

LPCTSTR
GetString(
    DWORD InternalId
    );

DWORD
GetMaskBit(
    LPCWSTR RoutingGuid
    );

#endif // _FAX_RTP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\faxroutep.h ===
#ifndef _FAX_ROUTE_P_H_
#define _FAX_ROUTE_P_H_

//
// Define the FAX_ROUTE_CALLBACKROUTINES_P structure which extends the
// FAX_ROUTE_CALLBACKROUTINES structure (defined in FxsRoute.h) with a pointer
// to a critical section in the service which protects configuration objects.
//

typedef struct _FAX_SERVER_RECEIPTS_CONFIGW
{
    DWORD                           dwSizeOfStruct;         // For version checks
    DWORD                           dwAllowedReceipts;      // Any combination of DRT_EMAIL and DRT_MSGBOX
    FAX_ENUM_SMTP_AUTH_OPTIONS      SMTPAuthOption;         // SMTP server authentication type
    LPWSTR                          lptstrReserved;         // Reserved; must be NULL
    LPWSTR                          lptstrSMTPServer;       // SMTP server name
    DWORD                           dwSMTPPort;             // SMTP port number
    LPWSTR                          lptstrSMTPFrom;         // SMTP sender address
    LPWSTR                          lptstrSMTPUserName;     // SMTP user name (for authenticated connections)
    LPWSTR                          lptstrSMTPPassword;     // SMTP password (for authenticated connections)
                                                            // This value is always NULL on get and may be NULL
                                                            // on set (won't be written in the server).
    BOOL                            bIsToUseForMSRouteThroughEmailMethod;
    HANDLE                          hLoggedOnUser;          // handle to a logged on user token for NTLM authentication
} FAX_SERVER_RECEIPTS_CONFIGW, *PFAX_SERVER_RECEIPTS_CONFIGW;

//
// Private callback for MS Routing Extension
//
typedef DWORD (*PGETRECIEPTSCONFIGURATION)(PFAX_SERVER_RECEIPTS_CONFIGW*, BOOL);

DWORD
GetRecieptsConfiguration(
    PFAX_SERVER_RECEIPTS_CONFIGW* ppServerRecieptConfig,
    BOOL                          bNeedNTLMToken
    );


typedef void ( *PFREERECIEPTSCONFIGURATION)( PFAX_SERVER_RECEIPTS_CONFIGW pServerRecieptConfig, BOOL fDestroy );
void
FreeRecieptsConfiguration(
    PFAX_SERVER_RECEIPTS_CONFIGW pServerRecieptConfig,
    BOOL                         fDestroy
    );

#ifdef _FAXROUTE_

typedef struct _FAX_ROUTE_CALLBACKROUTINES_P {
    DWORD                       SizeOfStruct;                // size of the struct set by the fax service
    PFAXROUTEADDFILE            FaxRouteAddFile;
    PFAXROUTEDELETEFILE         FaxRouteDeleteFile;
    PFAXROUTEGETFILE            FaxRouteGetFile;
    PFAXROUTEENUMFILES          FaxRouteEnumFiles;
    PFAXROUTEMODIFYROUTINGDATA  FaxRouteModifyRoutingData;
    PGETRECIEPTSCONFIGURATION   GetRecieptsConfiguration;
    PFREERECIEPTSCONFIGURATION  FreeRecieptsConfiguration;
	LPTSTR						lptstrFaxQueueDir;
} FAX_ROUTE_CALLBACKROUTINES_P, *PFAX_ROUTE_CALLBACKROUTINES_P;

#endif  //#ifdef _FAXROUTE_


#endif // _FAX_ROUTE_P_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\faxroute.cpp ===
#include "faxrtp.h"
#pragma hdrstop


HINSTANCE           g_hModule;
HINSTANCE			g_hResource;
WCHAR               FaxReceiveDir[MAX_PATH];

CFaxCriticalSection g_csRoutingStrings;

PFAXROUTEADDFILE    FaxRouteAddFile;
PFAXROUTEDELETEFILE FaxRouteDeleteFile;
PFAXROUTEGETFILE    FaxRouteGetFile;
PFAXROUTEENUMFILES  FaxRouteEnumFiles;

//
// Private callback functions
//
PGETRECIEPTSCONFIGURATION   g_pGetRecieptsConfiguration;
PFREERECIEPTSCONFIGURATION  g_pFreeRecieptsConfiguration;

extern PFAX_EXT_GET_DATA       g_pFaxExtGetData;
extern PFAX_EXT_FREE_BUFFER    g_pFaxExtFreeBuffer;

extern "C"
DWORD
DllMain(
    HINSTANCE hInstance,
    DWORD     Reason,
    LPVOID    Context
    )
{
    if (Reason == DLL_PROCESS_ATTACH)
    {
        g_hModule = hInstance;
		g_hResource = GetResInstance(hInstance);
        if(!g_hResource)
        {
            return FALSE;
        }
		FXSEVENTInitialize();
        DisableThreadLibraryCalls( hInstance );
    }

	if (Reason == DLL_PROCESS_DETACH)
    {
		FXSEVENTFree();
        HeapCleanup();
        FreeResInstance();
    }	
    return TRUE;
}

BOOL WINAPI
FaxRouteInitialize(
    IN HANDLE HeapHandle,
    IN PFAX_ROUTE_CALLBACKROUTINES FaxRouteCallbackRoutines
    )
{
    PFAX_ROUTE_CALLBACKROUTINES_P pFaxRouteCallbackRoutinesP = (PFAX_ROUTE_CALLBACKROUTINES_P)FaxRouteCallbackRoutines;
    DEBUG_FUNCTION_NAME(TEXT("FaxRouteInitialize"));

    //
    //  HeapHandle - is unused. We use the process default heap!
    //

	ZeroMemory (FaxReceiveDir, sizeof(FaxReceiveDir));

    FaxRouteAddFile    = FaxRouteCallbackRoutines->FaxRouteAddFile;
    FaxRouteDeleteFile = FaxRouteCallbackRoutines->FaxRouteDeleteFile;
    FaxRouteGetFile    = FaxRouteCallbackRoutines->FaxRouteGetFile;
    FaxRouteEnumFiles  = FaxRouteCallbackRoutines->FaxRouteEnumFiles;

	if (!g_csRoutingStrings.InitializeAndSpinCount())
	{
		DebugPrintEx(DEBUG_ERR, L"InitializeAndSpinCount failed with: %ld", GetLastError());
        return FALSE;
    }

    if (sizeof (FAX_ROUTE_CALLBACKROUTINES_P) == FaxRouteCallbackRoutines->SizeOfStruct)
    {
        //
        // This is a special hack - the service is giving us its private callbacks
        //
        g_pGetRecieptsConfiguration = pFaxRouteCallbackRoutinesP->GetRecieptsConfiguration;
        g_pFreeRecieptsConfiguration = pFaxRouteCallbackRoutinesP->FreeRecieptsConfiguration;
		
		_tcsncpy ( FaxReceiveDir, pFaxRouteCallbackRoutinesP->lptstrFaxQueueDir, ARR_SIZE(FaxReceiveDir)-1 );
    }
    else
    {
        //
        // The service MUST provide us with the private structure containing CsConfig.
        // Otherwise, when we call LoadReceiptsSettings(), we might read half-baked data.
        //
        ASSERT_FALSE;
    }    	
	Assert (_tcslen (FaxReceiveDir));

    PREG_FAX_SERVICE pFaxReg = NULL;

    if (!InitializeEventLog(&pFaxReg))
    {
        DebugPrintEx(DEBUG_ERR, L"InitializeEventLog failed with: %ld", GetLastError());
        return FALSE;
    }
    FreeFaxRegistry(pFaxReg);

    InitializeStringTable();
    DWORD dwRes = g_DevicesMap.Init ();
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }

    return TRUE;
}   // FaxRouteInitialize


BOOL WINAPI
FaxRoutePrint(
    const FAX_ROUTE *FaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )
{
    CDeviceRoutingInfo *pDevInfo;
    WCHAR NameBuffer[MAX_PATH];
    LPCWSTR FBaseName;
    WCHAR TiffFileName[MAX_PATH];
    DWORD Size;
	wstring strPrint;

    DEBUG_FUNCTION_NAME(TEXT("FaxRoutePrint"));

    pDevInfo = g_DevicesMap.GetDeviceRoutingInfo ( FaxRoute->DeviceId );
    if (!pDevInfo)
    {
        DebugPrintEx (DEBUG_ERR,
                      L"GetDeviceRoutingInfo failed with %ld",
                      GetLastError ());
        return FALSE;
    }

    if (!pDevInfo->IsPrintEnabled())
    {
        DebugPrintEx (DEBUG_MSG,
                      L"Routing to printer is disabled for device %ld",
                      FaxRoute->DeviceId);
        return TRUE;
    }

    Size = sizeof(TiffFileName);
    if (!FaxRouteGetFile(
        FaxRoute->JobId,
        1,
        TiffFileName,
        &Size))
    {
        DebugPrintEx (DEBUG_MSG,
                      L"FaxRouteGetFile failed with %ld",
                      GetLastError ());
        return FALSE;
    }

    //
    // print the fax in requested to do so
    //

    //
    // NOTICE: If the supplied printer name is an empty string,
    //         the code retrieves the name of the default printer installed.
    //
	if (!pDevInfo->GetPrinter(strPrint))
	{
		DebugPrintEx (	DEBUG_ERR,
						L"GetPrinter failed with %ld",
						GetLastError ());
        return FALSE;
    }

    if (strPrint.length() == 0)
    {
        GetProfileString( L"windows",
            L"device",
            L",,,",
            (LPWSTR) NameBuffer,
            MAX_PATH
            );
        FBaseName = NameBuffer;
    }
    else
    {
        FBaseName = strPrint.c_str();
    }
    return TiffRoutePrint( TiffFileName, (LPTSTR)FBaseName );
}   // FaxRoutePrint


BOOL WINAPI
FaxRouteStore(
    const FAX_ROUTE *FaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )
{
    CDeviceRoutingInfo *pDevInfo;
    WCHAR TiffFileName[MAX_PATH * 2]={0};
    DWORD Size;
    LPTSTR FullPath = NULL;
    DWORD StrCount;
	wstring strFolder;


    DEBUG_FUNCTION_NAME(TEXT("FaxRouteStore"));

    pDevInfo = g_DevicesMap.GetDeviceRoutingInfo( FaxRoute->DeviceId );
    if (!pDevInfo)
    {
        DebugPrintEx (DEBUG_ERR,
                      L"GetDeviceRoutingInfo failed with %ld",
                      GetLastError ());
        return FALSE;
    }

    if (!pDevInfo->IsStoreEnabled())
    {
        DebugPrintEx (DEBUG_MSG,
                      L"Routing to folder is disabled for device %ld",
                      FaxRoute->DeviceId);
        return TRUE;
    }

    //
    //  Get the file name
    //
    Size = sizeof(TiffFileName);
    if (!FaxRouteGetFile(
        FaxRoute->JobId,
        1,
        TiffFileName,
        &Size))
    {
        DebugPrintEx (DEBUG_MSG,
                      L"FaxRouteGetFile failed with %ld",
                      GetLastError ());
        return FALSE;
    }

	if (!pDevInfo->GetStoreFolder(strFolder))
	{
		DebugPrintEx (	DEBUG_ERR,
						L"GetStoreFolder failed with %ld",
						GetLastError ());
        return FALSE;
    }

    if (strFolder.length() == 0)
    {
        SetLastError (ERROR_BAD_CONFIGURATION);
        DebugPrintEx (DEBUG_MSG,
                      L"Folder name is empty - no configuration",
                      FaxRoute->DeviceId);
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_SAVE_FAILED,
            TiffFileName,
            TEXT(""),
            DWORD2HEX(ERROR_BAD_CONFIGURATION)
            );
        return FALSE;
    }

    StrCount = ExpandEnvironmentStrings( strFolder.c_str(), FullPath, 0 );
    FullPath = (LPWSTR) MemAlloc( StrCount * sizeof(WCHAR) );
    if (!FullPath)
    {
        DebugPrintEx (DEBUG_ERR,
                      L"Failed to allocate %ld bytes",
                      StrCount * sizeof(WCHAR));
        return FALSE;
    }

    ExpandEnvironmentStrings( strFolder.c_str(), FullPath, StrCount );

    if (lstrlen (FullPath) > MAX_PATH)
    {
        DebugPrintEx (DEBUG_ERR,
                      L"Store folder name exceeds MAX_PATH chars");
        SetLastError (ERROR_BUFFER_OVERFLOW);
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_SAVE_FAILED,
            TiffFileName,
            FullPath,
            DWORD2HEX(ERROR_BUFFER_OVERFLOW)
            );
        MemFree( FullPath );
        return FALSE;
    }
    //
    // If we are moving the fax to the directory that is was received into, do nothing to the file
    //

    if (_wcsicmp( FullPath, FaxReceiveDir ) == 0)
    {
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_SAVE_SUCCESS,
            TiffFileName,
            TiffFileName
            );
    }
    else if (!FaxMoveFile ( TiffFileName, FullPath ))
    {
        MemFree( FullPath );
        return FALSE;
    }
    MemFree( FullPath );
    return TRUE;
}   // FaxRouteStore

BOOL
CreateMailBodyAndSubject (
    const FAX_ROUTE *pFaxRoute,
    LPTSTR          *plptstrSubject,
    LPTSTR          *plptstrBody
)
/*++

Routine name : CreateMailBodyAndSubject

Routine description:

    Creates the SMTP mail subject and body.
    Used by route by SMTP routing method

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    pFaxRoute                     [in]     - Routing information
    plptstrSubject                [out]    - Allocated subject. Free with LocalFree
    plptstrBody                   [out]    - Allocated body. Free with LocalFree

Return Value:

    TRUE if successful, FALSE otherwise.

--*/
{
    WCHAR           wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    WCHAR           wszElapsedTimeStr[512];
    WCHAR           wszStartTimeStr[512];
    LPCTSTR         lpctstrRecipientStr;
    LPCTSTR         lpctstrSenderStr;
    LPDWORD         MsgPtr[7];
    DWORD           MsgCount;
    LPWSTR          lpwstrMsgBody = NULL;
    LPWSTR          lpwstrMsgSubject = NULL;

    DEBUG_FUNCTION_NAME(TEXT("CreateMailBodyAndSubject"));

    Assert (pFaxRoute && plptstrSubject && plptstrBody);
    //
    // Get computer name
    //
    DWORD dwComputerNameSize = sizeof (wszComputerName) / sizeof (wszComputerName[0]);
    if (!GetComputerName (wszComputerName, &dwComputerNameSize))
    {
        DebugPrintEx (DEBUG_ERR,
                      L"GetComputerName failed. ec = %ld",
                      GetLastError ());
        goto error;
    }
    //
    // Create elapsed time string
    //
    if (!FormatElapsedTimeStr(
            (FILETIME*)&pFaxRoute->ElapsedTime,
            wszElapsedTimeStr,
            ARR_SIZE(wszElapsedTimeStr)))
    {
        DebugPrintEx (DEBUG_ERR,
                      L"FormatElapsedTimeStr failed. ec = %ld",
                      GetLastError ());
        goto error;
    }
    //
    // Create start time string
    //
    SYSTEMTIME stStartTime;
    FILETIME   tmLocalTime;
    //
    // Convert time from UTC to local time zone
    //
    if (!FileTimeToLocalFileTime( (FILETIME*)&(pFaxRoute->ReceiveTime), &tmLocalTime ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToLocalFileTime failed. (ec: %ld)"),
            GetLastError());
        goto error;
    }
    if (!FileTimeToSystemTime( &tmLocalTime, &stStartTime ))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed. (ec: %ld)"),
            GetLastError());
        goto error;
    }
    if (!FaxTimeFormat (
            LOCALE_SYSTEM_DEFAULT,
            0,
            &stStartTime,
            NULL,
            wszStartTimeStr,
            sizeof (wszStartTimeStr) / sizeof (wszStartTimeStr[0])))
    {
        DebugPrintEx (DEBUG_ERR,
                      L"FaxTimeFormat failed. ec = %ld",
                      GetLastError ());
        goto error;
    }
    //
    // Extract recipient name
    //
    if (!pFaxRoute->RoutingInfo || !pFaxRoute->RoutingInfo[0])
    {
        if (pFaxRoute->Csid && lstrlen (pFaxRoute->Csid))
        {
            //
            // Use CSID as recipient name
            //
            lpctstrRecipientStr = pFaxRoute->Csid;
        }
        else
        {
            //
            // No routing info and no CSID: use string from resource
            //
            lpctstrRecipientStr = GetString (IDS_UNKNOWN_RECIPIENT);
        }
    }
    else
    {
        //
        // Use routing info as recipient name
        //
        lpctstrRecipientStr = pFaxRoute->RoutingInfo;
    }
    //
    // Extract sender name
    //
    if (pFaxRoute->Tsid && lstrlen (pFaxRoute->Tsid))
    {
        //
        // Use TSID as sender
        //
        lpctstrSenderStr = pFaxRoute->Tsid;
    }
    else
    {
        //
        // No TSID: use string from resource
        //
        lpctstrSenderStr = GetString(IDS_UNKNOWN_SENDER);
    }
    //
    // Create mail body
    //
    MsgPtr[0] = (LPDWORD) (lpctstrSenderStr ? lpctstrSenderStr : TEXT(""));             // Sender
    MsgPtr[1] = (LPDWORD) (pFaxRoute->CallerId ? pFaxRoute->CallerId : TEXT(""));       // CallerID
    MsgPtr[2] = (LPDWORD) (lpctstrRecipientStr ? lpctstrRecipientStr : TEXT(""));       // Recipient name
    MsgPtr[3] = (LPDWORD) ULongToPtr((pFaxRoute->PageCount));                           // Pages
    MsgPtr[4] = (LPDWORD) wszStartTimeStr;                                              // Transmission time
    MsgPtr[5] = (LPDWORD) wszElapsedTimeStr;                                            // Transmission duration
    MsgPtr[6] = (LPDWORD) (pFaxRoute->DeviceName ? pFaxRoute->DeviceName : TEXT(""));   // Device name

    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_ARGUMENT_ARRAY |
        FORMAT_MESSAGE_ALLOCATE_BUFFER,
        g_hResource,
        MSG_MAIL_MSG_BODY,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        (LPWSTR)&lpwstrMsgBody,
        0,
        (va_list *) MsgPtr
        );
    if (!MsgCount)
    {
        DebugPrintEx (DEBUG_ERR,
                      L"FormatMessage failed. ec = %ld",
                      GetLastError ());
        goto error;
    }
    //
    // Create subject line
    //
    MsgPtr[0] = (LPDWORD) wszComputerName;                                   // Computer name
    MsgPtr[1] = (LPDWORD) (lpctstrSenderStr ? lpctstrSenderStr : TEXT(""));  // Sender
    MsgCount = FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE |
        FORMAT_MESSAGE_ARGUMENT_ARRAY |
        FORMAT_MESSAGE_ALLOCATE_BUFFER,
        g_hResource,
        MSG_SUBJECT_LINE,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
        (LPWSTR)&lpwstrMsgSubject,
        0,
        (va_list *) MsgPtr
        );
    if (!MsgCount)
    {
        DebugPrintEx (DEBUG_ERR,
                      L"FormatMessage failed. ec = %ld",
                      GetLastError ());
        goto error;
    }
    //
    // Success
    //
    *plptstrSubject = lpwstrMsgSubject;
    *plptstrBody    = lpwstrMsgBody;
    return TRUE;

error:

    if (lpwstrMsgSubject)
    {
        LocalFree (lpwstrMsgSubject);
    }
    if (lpwstrMsgBody)
    {
        LocalFree (lpwstrMsgBody);
    }
    return FALSE;
}   // CreateMailBodyAndSubject


BOOL
MailIncomingJob(
    const FAX_ROUTE *pFaxRoute,
    LPCWSTR          lpcwstrMailTo,
    LPCWSTR          TiffFileName
)
/*++

Routine Description:

    Mails a TIFF file using CDO2

Arguments:

    pFaxRoute            [in] - Routing information
    lpcwstrMailTo        [in] - Email recipient address
    TiffFileName         [in] - Name of TIFF file to mail

Return Value:

    TRUE for success, FALSE on error

--*/
{
    LPWSTR          lpwstrMsgBody = NULL;
    LPWSTR          lpwstrMsgSubject = NULL;
    HRESULT         hr;
    BOOL            bRes = FALSE;
    DWORD           dwRes;
    PFAX_SERVER_RECEIPTS_CONFIGW pReceiptsConfiguration = NULL;
    DEBUG_FUNCTION_NAME(TEXT("MailIncomingJob"));

    //
    // Read current mail configuration
    //
    dwRes = g_pGetRecieptsConfiguration (&pReceiptsConfiguration, TRUE);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetRecieptsConfiguration failed with %ld"),
            dwRes);
        goto exit;
    }
    //
    // Get body and subject
    //
    if (!CreateMailBodyAndSubject (pFaxRoute, &lpwstrMsgSubject, &lpwstrMsgBody))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateMailBodyAndSubject failed with %ld"),
            dwRes);
        goto exit;
    }
    //
    // Send the mail
    //
    hr = SendMail (
        pReceiptsConfiguration->lptstrSMTPFrom,                      // From
        lpcwstrMailTo,                                      // To
        lpwstrMsgSubject,                                   // Subject
        lpwstrMsgBody,                                      // Body
		NULL,												// HTML Body
        TiffFileName,                                       // Attachment
        TEXT("FAX.TIF"),                                    // Attachment description
        pReceiptsConfiguration->lptstrSMTPServer,                    // SMTP server
        pReceiptsConfiguration->dwSMTPPort,                          // SMTP port
        (pReceiptsConfiguration->SMTPAuthOption == FAX_SMTP_AUTH_ANONYMOUS) ?
            CDO_AUTH_ANONYMOUS :
            (pReceiptsConfiguration->SMTPAuthOption == FAX_SMTP_AUTH_BASIC) ?
                CDO_AUTH_BASIC : CDO_AUTH_NTLM,             // Authentication type
        pReceiptsConfiguration->lptstrSMTPUserName,                 // User name
        pReceiptsConfiguration->lptstrSMTPPassword,                 // Password
        pReceiptsConfiguration->hLoggedOnUser);                     // Logged on user token
    if (FAILED(hr))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SendMail failed. (hr: 0x%08x)"),
            hr);
        dwRes = hr;
        goto exit;
    }

    bRes = TRUE;

exit:
    if (lpwstrMsgSubject)
    {
        LocalFree (lpwstrMsgSubject);
    }
    if (lpwstrMsgBody)
    {
        LocalFree (lpwstrMsgBody);
    }
    if (NULL != pReceiptsConfiguration)
    {
        g_pFreeRecieptsConfiguration( pReceiptsConfiguration, TRUE);
    }
    if (bRes)
    {
        //
        //  Mail is sent OK
        //
        FaxLog(FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            1,
            MSG_FAX_ROUTE_EMAIL_SUCCESS,
            TiffFileName);
    }
    else
    {       
        FaxLog(FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            2,
            MSG_FAX_ROUTE_EMAIL_FAILED,
            TiffFileName,
            DWORD2HEX(dwRes));
    }

    return bRes;
}   // MailIncomingJob


BOOL WINAPI
FaxRouteEmail(
    const FAX_ROUTE *pFaxRoute,
    PVOID *FailureData,
    LPDWORD FailureDataSize
    )
{
    CDeviceRoutingInfo *pDevInfo;
    WCHAR wszTiffFileName[MAX_PATH];
    DWORD dwSize;
	wstring strSMTP;

    DEBUG_FUNCTION_NAME(TEXT("FaxRouteEmail"));

    pDevInfo = g_DevicesMap.GetDeviceRoutingInfo( pFaxRoute->DeviceId );
    if (!pDevInfo)
    {
        DebugPrintEx (DEBUG_ERR,
                      L"Could not retrieve routing info for device %ld. ec = %ld",
                      pFaxRoute->DeviceId,
                      GetLastError ());
        return FALSE;
    }
	
	if (!pDevInfo->GetSMTPTo(strSMTP))
	{
		DebugPrintEx (	DEBUG_ERR,
						L"GetSMTPTo failed with %ld",
						GetLastError ());
        return FALSE;
    }

    if (!pDevInfo->IsEmailEnabled())
    {
        DebugPrintEx (DEBUG_MSG,
                      L"email is disabled for device %ld. Not sending",
                      pFaxRoute->DeviceId);
        return TRUE;
    }
    //
    // Get full TIFF file
    //
    dwSize = sizeof(wszTiffFileName);
    if (!FaxRouteGetFile(
        pFaxRoute->JobId,
        1,
        wszTiffFileName,
        &dwSize))
    {
        DebugPrintEx (DEBUG_ERR,
                      L"FaxRouteGetFile for job %ld. ec = %ld",
                      pFaxRoute->JobId,
                      GetLastError ());
        return FALSE;
    }
    if (strSMTP.length() == 0)
    {
        SetLastError (ERROR_BAD_CONFIGURATION);
        DebugPrintEx (DEBUG_MSG,
                      L"address is empty for device %ld. Not sending",
                      pFaxRoute->DeviceId);       

        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_ROUTE_EMAIL_FAILED,
            wszTiffFileName,
            DWORD2HEX(ERROR_BAD_CONFIGURATION)
            );
        return FALSE;
    }
    //
    // Mail the new fax TIFF
    //
    if (!MailIncomingJob( pFaxRoute, strSMTP.c_str(), wszTiffFileName ))
    {
        DebugPrintEx (DEBUG_ERR,
                      L"MailIncomingJob for job %ld. ec = %ld",
                      pFaxRoute->JobId,
                      GetLastError ());
        return FALSE;
    }
    return TRUE;
}   // FaxRouteEmail


BOOL WINAPI
FaxRouteConfigure(
    OUT HPROPSHEETPAGE *PropSheetPage
    )
{
    return TRUE;
}


BOOL WINAPI
FaxRouteDeviceEnable(
    IN  LPCWSTR lpcwstrRoutingGuid,
    IN  DWORD   dwDeviceId,
    IN  LONG    bEnabled
    )
{
    DEBUG_FUNCTION_NAME(TEXT("FaxRouteDeviceEnable"));

    DWORD MaskBit = GetMaskBit( lpcwstrRoutingGuid );
    if (MaskBit == 0)
    {
        return FALSE;
    }

    CDeviceRoutingInfo *pDeviceProp = g_DevicesMap.GetDeviceRoutingInfo (dwDeviceId);
    if (!pDeviceProp)
    {
        return FALSE;
    }
    DWORD dwRes;

    switch (MaskBit)
    {
        case LR_EMAIL:
            if (QUERY_STATUS == bEnabled)
            {
                return pDeviceProp->IsEmailEnabled ();
            }
            dwRes = pDeviceProp->EnableEmail (bEnabled);
            break;
        case LR_STORE:
            if (QUERY_STATUS == bEnabled)
            {
                return pDeviceProp->IsStoreEnabled ();
            }
            dwRes = pDeviceProp->EnableStore (bEnabled);
            break;
        case LR_PRINT:
            if (QUERY_STATUS == bEnabled)
            {
                return pDeviceProp->IsPrintEnabled ();
            }
            dwRes = pDeviceProp->EnablePrint (bEnabled);
            break;
        default:
            ASSERT_FALSE;
            SetLastError (ERROR_GEN_FAILURE);
            return FALSE;
    }
    SetLastError (dwRes);
    return ERROR_SUCCESS == dwRes ? TRUE : FALSE;
}   // FaxRouteDeviceEnable


BOOL WINAPI
FaxRouteDeviceChangeNotification(
    IN  DWORD dwDeviceId,
    IN  BOOL  bNewDevice
    )
{
    DEBUG_FUNCTION_NAME(TEXT("FaxRouteDeviceChangeNotification"));
    //
    // We don't care about new devices now.
    // We're using a late-discovery cache so we'll discover the device once
    // we route something from it or once it is configured for routing.
    //
    return TRUE;
    UNREFERENCED_PARAMETER (dwDeviceId);
    UNREFERENCED_PARAMETER (bNewDevice);
}   // FaxRouteDeviceChangeNotification
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\resource.h ===
//////////////////////////////////////////////////////
//                                                  //
// Fax Route resource ID file                       //
// It compiles as part of FxsRes.dll                //
// All the IDs should be in range                   //
//                                                  //
// [14000 - 14499]                                  //
//                                                  //
//////////////////////////////////////////////////////

#define IDS_UNKNOWN_RECIPIENT       14000 
#define IDS_UNKNOWN_SENDER          14001 
// string in faxres.rc
#include "..\..\admin\faxres\resource.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\print.cpp ===
#include "faxrtp.h"
#pragma hdrstop



BOOL
TiffRoutePrint(
    LPCTSTR lpctstrTiffFileName,
    PTCHAR  ptcPrinter
    )

/*++

Routine Description:

    Prints TIFF file.

Arguments:

    lpctstrTiffFileName [in]  - Name of TIFF file to print
    ptcPrinter          [in]  - Printer to print to

Return Value:

    TRUE for success, FALSE on error

--*/

{
    PTCHAR      ptcDevice = NULL;
    BOOL        bResult;

    DEBUG_FUNCTION_NAME(TEXT("TiffRoutePrint"));


    if( (ptcDevice = _tcstok( ptcPrinter, TEXT(","))) ) 
    {
        if (IsPrinterFaxPrinter( ptcDevice )) 
        {
            //
            // return TRUE here so we don't try to route it to this printer again
            //
            DebugPrintEx (DEBUG_WRN,
                          TEXT("Attempt to print to our fax printer was blocked"));
            FaxLog(
                FAXLOG_CATEGORY_INBOUND,
                FAXLOG_LEVEL_MIN,
                2,
                MSG_FAX_PRINT_TO_FAX,
                lpctstrTiffFileName,
                ptcDevice
                );

			return TRUE;
        }
    }
    bResult = TiffPrint (lpctstrTiffFileName, ptcPrinter);
    if (bResult)
    {
        //
        // Success
        //
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_PRINT_SUCCESS,
            lpctstrTiffFileName,
            ptcPrinter
            );
    }
    else
    {
        DWORD dwLastError = GetLastError ();
        //
        // Failure
        //
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_PRINT_FAILED,
            lpctstrTiffFileName,
            ptcPrinter,
            DWORD2HEX(dwLastError)
            );
        //
        // Restore last error in case FaxLog changed it
        //
        SetLastError (dwLastError); 
    }
    return bResult;
}   // TiffRoutePrint
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\deviceprop.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    DeviceProp.cpp

Abstract:

    Holds outbound routing configuraton per single device

Author:

    Eran Yariv (EranY)  Nov, 1999

Revision History:

--*/

#include "faxrtp.h"
#pragma hdrstop

/************************************
*                                   *
*            Definitions            *
*                                   *
************************************/

//
// Default values for configuration:
//
#define DEFAULT_FLAGS               0       // No routing method is enabled
#define DEFAULT_STORE_FOLDER        TEXT("")
#define DEFAULT_MAIL_PROFILE        TEXT("")
#define DEFAULT_PRINTER_NAME        TEXT("")

//
// The following array of GUID is used for registration / unregistration of notifications
//
LPCWSTR g_lpcwstrGUIDs[NUM_NOTIFICATIONS] =
{
    REGVAL_RM_FLAGS_GUID,           // GUID for routing methods usage flags
    REGVAL_RM_FOLDER_GUID,          // GUID for store method folder
    REGVAL_RM_PRINTING_GUID,        // GUID for print method printer name
    REGVAL_RM_EMAIL_GUID,           // GUID for mail method address
};


static
BOOL
IsUnicodeString (
    LPBYTE lpData,
    DWORD  dwDataSize
)
{
    if ( 0 != (dwDataSize % sizeof(WCHAR))   ||
         TEXT('\0') != ((LPCWSTR)(lpData))[dwDataSize / sizeof(WCHAR) - 1])
    {
        return FALSE;
    }
    return TRUE;         
}   // IsUnicodeString
/************************************
*                                   *
*            CDevicesMap            *
*                                   *
************************************/
DWORD
CDevicesMap::Init ()
/*++

Routine name : CDevicesMap::Init

Routine description:

    Initializes internal variables.
    Call only once before any other calls.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:


Return Value:

    Standard Win32 error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CDevicesMap::Init"));
    if (m_bInitialized)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CDevicesMap::Init called more than once"));
        return ERROR_ALREADY_INITIALIZED;
    }

    m_bInitialized = TRUE;
    
    if (FAILED(SafeInitializeCriticalSection(&m_CsMap)))
    {
        m_bInitialized = FALSE;
        return GetLastError();
    }

    return ERROR_SUCCESS;
}   // CDevicesMap::Init

CDevicesMap::~CDevicesMap ()
{
    DEBUG_FUNCTION_NAME(TEXT("CDevicesMap::~CDevicesMap"));
    if (m_bInitialized)
    {
        DeleteCriticalSection (&m_CsMap);
    }
    try
    {
        for (DEVICES_MAP::iterator it = m_Map.begin(); it != m_Map.end(); ++it)
        {
            CDeviceRoutingInfo *pDevInfo = (*it).second;
            delete pDevInfo;
        }
    }
    catch (exception ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Got an STL exception while clearing the devices map (%S)"),
            ex.what());
    }
}   // CDevicesMap::~CDevicesMap

CDeviceRoutingInfo *
CDevicesMap::FindDeviceRoutingInfo (
    DWORD dwDeviceId
)
/*++

Routine name : CDevicesMap::FindDeviceRoutingInfo

Routine description:

    Finds a device in the map

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId          [in    ] - Device id

Return Value:

    Pointer to device object.
    If NULL, use GetLastError() to retrieve error code.

--*/
{
    DEVICES_MAP::iterator it;
    CDeviceRoutingInfo *pDevice = NULL;
    DEBUG_FUNCTION_NAME(TEXT("CDevicesMap::FindDeviceRoutingInfo"));

    if (!m_bInitialized)
    {
        //
        // Critical section failed to initialized
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CDevicesMap::FindDeviceRoutingInfo called but CS is not initialized."));
        SetLastError (ERROR_GEN_FAILURE);
        return NULL;
    }
    EnterCriticalSection (&m_CsMap);
    try
    {
        if((it = m_Map.find(dwDeviceId)) == m_Map.end())
        {
            //
            // Device not found in map
            //
            SetLastError (ERROR_NOT_FOUND);
            goto exit;
        }
        else
        {
            //
            // Device found in map
            //
            pDevice = (*it).second;
            goto exit;
        }
    }
    catch (exception ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Got an STL exception while searching a devices map(%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        pDevice = NULL;
        goto exit;
    }
exit:
    LeaveCriticalSection (&m_CsMap);
    return pDevice;
}   // CDevicesMap::FindDeviceRoutingInfo


CDeviceRoutingInfo *
CDevicesMap::GetDeviceRoutingInfo (
    DWORD dwDeviceId
)
/*++

Routine name : CDevicesMap::GetDeviceRoutingInfo

Routine description:

    Finds a device in the map.
    If not exists, attempts to create a new map entry.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId          [in] - Device id

Return Value:

    Pointer to device object.
    If NULL, use GetLastError() to retrieve error code.

--*/
{
    DEVICES_MAP::iterator it;
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("CDevicesMap::GetDeviceRoutingInfo"));

    if (!m_bInitialized)
    {
        //
        // Critical section failed to initialized
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CDevicesMap::GetDeviceRoutingInfo called but CS is not initialized."));
        SetLastError (ERROR_GEN_FAILURE);
        return NULL;
    }
    EnterCriticalSection (&m_CsMap);
    //
    // Start by looking up the device in the map
    //
    CDeviceRoutingInfo *pDevice = FindDeviceRoutingInfo (dwDeviceId);
    if (NULL == pDevice)
    {
        //
        // Error finding device in map
        //
        if (ERROR_NOT_FOUND != GetLastError ())
        {
            //
            // Real error
            //
            goto exit;
        }
        //
        // The device is not in the map - add it now
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Adding device %ld to routing map"),
            dwDeviceId);
        //
        // Allocate device
        //
        pDevice = new (std::nothrow) CDeviceRoutingInfo (dwDeviceId);
        if (!pDevice)
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Cannot allocate memory for a CDeviceRoutingInfo"));
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            goto exit;
        }
        //
        // Read configuration
        //
        dwRes = pDevice->ReadConfiguration ();
        if (ERROR_SUCCESS != dwRes)
        {
            delete pDevice;
            pDevice = NULL;
            SetLastError (dwRes);
            goto exit;
        }
        //
        // Add notification requests for the device
        //
        dwRes = pDevice->RegisterForChangeNotifications();
        if (ERROR_SUCCESS != dwRes)
        {
            delete pDevice;
            pDevice = NULL;
            SetLastError (dwRes);
            goto exit;
        }
        //
        // Add device to map
        //
        try
        {
            m_Map[dwDeviceId] = pDevice;
        }
        catch (exception ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Got an STL exception while trying to add a devices map entry (%S)"),
                ex.what());
            SetLastError (ERROR_GEN_FAILURE);
            pDevice->UnregisterForChangeNotifications();
            delete pDevice;
            pDevice = NULL;
            goto exit;
        }
    }
    else
    {
        //
        // Read the device configuration even if it in the map
        // to avoid the situation when the configuration change notification
        // arrive after the GetDeviceRoutingInfo() request.
        //
        dwRes = pDevice->ReadConfiguration ();
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(DEBUG_ERR, TEXT("CDeviceRoutingInfo::ReadConfiguration() failed with %ld"), dwRes);
            SetLastError (dwRes);
            goto exit;
        }
    }
exit:
    LeaveCriticalSection (&m_CsMap);
    return pDevice;
}   // CDevicesMap::GetDeviceRoutingInfo

/************************************
*                                   *
*        Pre-declarations           *
*                                   *
************************************/

static
HRESULT
FaxRoutingExtConfigChange (
    DWORD       dwDeviceId,         // The device for which configuration has changed
    LPCWSTR     lpcwstrNameGUID,    // Configuration name
    LPBYTE      lpData,             // New configuration data
    DWORD       dwDataSize          // Size of new configuration data
);

/************************************
*                                   *
*               Globals             *
*                                   *
************************************/

CDevicesMap g_DevicesMap;   // Global map of known devices (used for late discovery).

//
// Extension data callbacks into the server:
//
PFAX_EXT_GET_DATA               g_pFaxExtGetData = NULL;
PFAX_EXT_SET_DATA               g_pFaxExtSetData = NULL;
PFAX_EXT_REGISTER_FOR_EVENTS    g_pFaxExtRegisterForEvents = NULL;
PFAX_EXT_UNREGISTER_FOR_EVENTS  g_pFaxExtUnregisterForEvents = NULL;
PFAX_EXT_FREE_BUFFER            g_pFaxExtFreeBuffer = NULL;


/************************************
*                                   *
*      Exported DLL function        *
*                                   *
************************************/

HRESULT
FaxExtInitializeConfig (
    PFAX_EXT_GET_DATA               pFaxExtGetData,
    PFAX_EXT_SET_DATA               pFaxExtSetData,
    PFAX_EXT_REGISTER_FOR_EVENTS    pFaxExtRegisterForEvents,
    PFAX_EXT_UNREGISTER_FOR_EVENTS  pFaxExtUnregisterForEvents,
    PFAX_EXT_FREE_BUFFER            pFaxExtFreeBuffer

)
/*++

Routine name : FaxExtInitializeConfig

Routine description:

    Exported function called by the service to initialize extension data mechanism

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pFaxExtGetData               [in] - Pointer to FaxExtGetData
    pFaxExtSetData               [in] - Pointer to FaxExtSetData
    pFaxExtRegisterForEvents     [in] - Pointer to FaxExtRegisterForEvents
    pFaxExtUnregisterForEvents   [in] - Pointer to FaxExtUnregisterForEvents
    pFaxExtFreeBuffer            [in] - Pointer to FaxExtFreeBuffer

Return Value:

    Standard HRESULT code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxExtInitializeConfig"));

    Assert (pFaxExtGetData &&
            pFaxExtSetData &&
            pFaxExtRegisterForEvents &&
            pFaxExtUnregisterForEvents &&
            pFaxExtFreeBuffer);

    g_pFaxExtGetData = pFaxExtGetData;
    g_pFaxExtSetData = pFaxExtSetData;
    g_pFaxExtRegisterForEvents = pFaxExtRegisterForEvents;
    g_pFaxExtUnregisterForEvents = pFaxExtUnregisterForEvents;
    g_pFaxExtFreeBuffer = pFaxExtFreeBuffer;
    return S_OK;
}   // FaxExtInitializeConfig

/************************************
*                                   *
* CDeviceRoutingInfo implementation *
*                                   *
************************************/

CDeviceRoutingInfo::CDeviceRoutingInfo (DWORD dwId) :
    m_dwFlags (0),
    m_dwId (dwId)
{
    memset (m_NotificationHandles, 0, sizeof (m_NotificationHandles));
}

CDeviceRoutingInfo::~CDeviceRoutingInfo ()
{
    UnregisterForChangeNotifications ();
}

BOOL 
CDeviceRoutingInfo::GetStoreFolder (wstring &strFolder)
{
	DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::GetStoreFolder"));
	EnterCriticalSection(&g_csRoutingStrings);
	try
	{
        strFolder = m_strStoreFolder;
	}
	catch(bad_alloc&)
	{
		LeaveCriticalSection(&g_csRoutingStrings);
		DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetStoreFolder failed - not enough memory."));
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
	}
	LeaveCriticalSection(&g_csRoutingStrings);
	return TRUE;
}
    
BOOL 
CDeviceRoutingInfo::GetPrinter (wstring &strPrinter)
{ 
	DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::GetPrinter"));
	EnterCriticalSection(&g_csRoutingStrings);
	try
	{
		strPrinter = m_strPrinter;
	}
	catch(bad_alloc&)
	{
		LeaveCriticalSection(&g_csRoutingStrings);
		DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetPrinter failed - not enough memory."));
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
	}
	LeaveCriticalSection(&g_csRoutingStrings);
	return TRUE;
}

BOOL 
CDeviceRoutingInfo::GetSMTPTo (wstring &strSMTP)
{ 
	DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::GetSMTPTo"));
	EnterCriticalSection(&g_csRoutingStrings);
	try
	{
		strSMTP = m_strSMTPTo;
	}
	catch(bad_alloc&)
	{
		LeaveCriticalSection(&g_csRoutingStrings);
		DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetSMTPTo failed - not enough memory."));
		SetLastError(ERROR_NOT_ENOUGH_MEMORY);
		return FALSE;
	}
	LeaveCriticalSection(&g_csRoutingStrings);
	return TRUE;
}

DWORD
CDeviceRoutingInfo::EnableStore (BOOL bEnabled)
{
    //
    // See if we have a store folder configured
    //
    if (bEnabled)
    {
		EnterCriticalSection(&g_csRoutingStrings);
        if (0 == m_strStoreFolder.size())
        {
            //
            // Folder path name is ""
            //
			LeaveCriticalSection(&g_csRoutingStrings);
            return ERROR_BAD_CONFIGURATION;
        }
        DWORD dwRes = IsValidFaxFolder (m_strStoreFolder.c_str());
		LeaveCriticalSection(&g_csRoutingStrings);
        if (ERROR_SUCCESS != dwRes)
        {
            return ERROR_BAD_CONFIGURATION;
        }
    }
    return EnableFlag (LR_STORE, bEnabled);
}   // CDeviceRoutingInfo::EnableStore

DWORD
CDeviceRoutingInfo::EnablePrint (BOOL bEnabled)
{
    //
    // See if we have a printer name configured
    //
	EnterCriticalSection(&g_csRoutingStrings);
    if (bEnabled && m_strPrinter.size() == 0)
    {
		LeaveCriticalSection(&g_csRoutingStrings);
        return ERROR_BAD_CONFIGURATION;
    }
	LeaveCriticalSection(&g_csRoutingStrings);
    return EnableFlag (LR_PRINT, bEnabled);
}

DWORD
CDeviceRoutingInfo::EnableEmail (BOOL bEnabled)
{
    if(bEnabled)
    {
        BOOL bMailConfigOK;
        DWORD dwRes = CheckMailConfig (&bMailConfigOK);
        if (ERROR_SUCCESS != dwRes)
        {
            return dwRes;
        }
		EnterCriticalSection(&g_csRoutingStrings);
        if (!bMailConfigOK || m_strSMTPTo.size() == 0)
        {
			LeaveCriticalSection(&g_csRoutingStrings);
            return ERROR_BAD_CONFIGURATION;
        }
		LeaveCriticalSection(&g_csRoutingStrings);
    }
    return EnableFlag (LR_EMAIL, bEnabled);
}

DWORD
CDeviceRoutingInfo::CheckMailConfig (
    LPBOOL lpbConfigOk
)
{
    DWORD dwRes = ERROR_SUCCESS;
    PFAX_SERVER_RECEIPTS_CONFIGW pReceiptsConfiguration = NULL;
    DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::CheckMailConfig"));

extern PGETRECIEPTSCONFIGURATION   g_pGetRecieptsConfiguration;
extern PFREERECIEPTSCONFIGURATION  g_pFreeRecieptsConfiguration;

    *lpbConfigOk = FALSE;
    //
    // Read current receipts configuration
    //
    dwRes = g_pGetRecieptsConfiguration (&pReceiptsConfiguration, FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetRecieptsConfiguration failed with %ld"),
            dwRes);
        return dwRes;
    }
    //
    // Check that the user enbaled us (MS route to mail method) to use the receipts configuration
    //
    if (!pReceiptsConfiguration->bIsToUseForMSRouteThroughEmailMethod)
    {
        //
        // MS mail routing methods cannot use receipts SMTP settings
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("MS mail routing methods cannot use receipts SMTP settings"));
        goto exit;
    }
    if (!lstrlen(pReceiptsConfiguration->lptstrSMTPServer))
    {
        //
        // Server name is empty
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Server name is empty"));
        goto exit;
    }
    if (!lstrlen(pReceiptsConfiguration->lptstrSMTPFrom))
    {
        //
        // Sender name is empty
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Sender name is empty"));
        goto exit;
    }
    if (!pReceiptsConfiguration->dwSMTPPort)
    {
        //
        // SMTP port is invalid
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SMTP port is invalid"));
        goto exit;
    }
    if ((FAX_SMTP_AUTH_BASIC == pReceiptsConfiguration->SMTPAuthOption) ||
        (FAX_SMTP_AUTH_NTLM  == pReceiptsConfiguration->SMTPAuthOption))
    {
        //
        // Basic / NTLM authentication selected
        //
        if (!lstrlen(pReceiptsConfiguration->lptstrSMTPUserName) ||
            !lstrlen(pReceiptsConfiguration->lptstrSMTPPassword))
        {
            //
            // Username / password are bad
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Username / password are bad"));
            goto exit;
        }
    }
    //
    // All is ok
    //
    *lpbConfigOk = TRUE;

exit:
    if (NULL != pReceiptsConfiguration)
    {
        g_pFreeRecieptsConfiguration( pReceiptsConfiguration, TRUE);
    }
    return dwRes;
}   // CDeviceRoutingInfo::CheckMailConfig


DWORD
CDeviceRoutingInfo::RegisterForChangeNotifications ()
/*++

Routine name : CDeviceRoutingInfo::RegisterForChangeNotifications

Routine description:

    Registres the device for notifications on configuration changes.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:


Return Value:

    Standard Win23 error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::RegisterForChangeNotifications"));

    Assert (g_pFaxExtRegisterForEvents);

    memset (m_NotificationHandles, 0, sizeof (m_NotificationHandles));

    for (int iCurHandle = 0; iCurHandle < NUM_NOTIFICATIONS; iCurHandle++)
    {
        m_NotificationHandles[iCurHandle] = g_pFaxExtRegisterForEvents (
                                    g_hModule,
                                    m_dwId,
                                    DEV_ID_SRC_FAX,  // Real fax device id
                                    g_lpcwstrGUIDs[iCurHandle],
                                    FaxRoutingExtConfigChange);
        if (NULL == m_NotificationHandles[iCurHandle])
        {
            //
            // Couldn't register this configuration object
            //
            break;
        }
    }
    if (iCurHandle < NUM_NOTIFICATIONS)
    {
        //
        // Error while registering at least one configuration object - undo previous registrations
        //
        DWORD dwErr = GetLastError ();
        UnregisterForChangeNotifications();
        return dwErr;
    }
    return ERROR_SUCCESS;
}   // CDeviceRoutingInfo::RegisterForChangeNotifications

DWORD
CDeviceRoutingInfo::UnregisterForChangeNotifications ()
/*++

Routine name : CDeviceRoutingInfo::UnregisterForChangeNotifications

Routine description:

    Unregistres the device from notifications on configuration changes.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:


Return Value:

    Standard Win23 error code.

--*/
{
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::UnregisterForChangeNotifications"));

    Assert (g_pFaxExtUnregisterForEvents);

    for (int iCurHandle = 0; iCurHandle < NUM_NOTIFICATIONS; iCurHandle++)
    {
        if (NULL != m_NotificationHandles[iCurHandle])
        {
            //
            // Found registred notification - unregister it
            //
            dwRes = g_pFaxExtUnregisterForEvents(m_NotificationHandles[iCurHandle]);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Call to FaxExtUnregisterForEvents on handle 0x%08x failed with %ld"),
                    m_NotificationHandles[iCurHandle],
                    dwRes);
                return dwRes;
            }
            m_NotificationHandles[iCurHandle] = NULL;
        }
    }
    return ERROR_SUCCESS;
}   // CDeviceRoutingInfo::UnregisterForChangeNotifications

DWORD
CDeviceRoutingInfo::ReadConfiguration ()
/*++

Routine name : CDeviceRoutingInfo::ReadConfiguration

Routine description:

    Reasd the routing configuration from the storage.
    If the storage doesn't contain configuration, default values are used.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:


Return Value:

    Standard Win23 error code.

--*/
{
    DWORD   dwRes;
    LPBYTE  lpData = NULL;
    DWORD   dwDataSize;
    DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::ReadConfiguration"));

    //
    // Start by reading the flags data
    //
    dwRes = g_pFaxExtGetData ( m_dwId,
                               DEV_ID_SRC_FAX, // We always use the Fax Device Id
                               REGVAL_RM_FLAGS_GUID,
                               &lpData,
                               &dwDataSize
                             );
    if (ERROR_SUCCESS != dwRes)
    {
        if (ERROR_FILE_NOT_FOUND == dwRes)
        {
            //
            // Data does not exist for this device. Try to read default values from unassociated data.
            //            
			dwRes = g_pFaxExtGetData ( 0,		// unassociated data
                               DEV_ID_SRC_FAX, // We always use the Fax Device Id
                               REGVAL_RM_FLAGS_GUID,
                               &lpData,
                               &dwDataSize
                             );
			if (ERROR_FILE_NOT_FOUND == dwRes)
			{
				//
				// Data does not exist for this device. Use default values.
				//
				DebugPrintEx(
					DEBUG_MSG,
					TEXT("No routing flags configuration - using defaults"));
				m_dwFlags = DEFAULT_FLAGS;
			}
        }

        if (ERROR_SUCCESS != dwRes &&
			ERROR_FILE_NOT_FOUND != dwRes)
        {
            //
            // Can't read configuration
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error reading routing flags (ec = %ld)"),
                dwRes);
            return dwRes;
        }
    }   
    
	if (NULL != lpData)
	{
		//
		// Data read successfully
		//
		if (sizeof (DWORD) != dwDataSize)
		{
			//
			// We're expecting a single DWORD here
			//
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("Routing flags configuration has bad size (%ld) - expecting %ld"),
				dwDataSize,
				sizeof (DWORD));
			g_pFaxExtFreeBuffer (lpData);
			return ERROR_BADDB; // The configuration registry database is corrupt.
		}
		m_dwFlags = DWORD (*lpData);
		g_pFaxExtFreeBuffer (lpData);
	}    

    try
    {
        lpData = NULL;

        //
        // Read store directory
        //
        dwRes = g_pFaxExtGetData ( m_dwId,
                                   DEV_ID_SRC_FAX, // We always use the Fax Device Id
                                   REGVAL_RM_FOLDER_GUID,
                                   &lpData,
                                   &dwDataSize
                                 );
        if (ERROR_SUCCESS != dwRes)
        {
            if (ERROR_FILE_NOT_FOUND == dwRes)
            {
				//
				// Data does not exist for this device. Try to read default values from unassociated data.
				// 
				dwRes = g_pFaxExtGetData ( 0,   // unassociated data
                                   DEV_ID_SRC_FAX, // We always use the Fax Device Id
                                   REGVAL_RM_FOLDER_GUID,
                                   &lpData,
                                   &dwDataSize
                                 );
                
				if (ERROR_FILE_NOT_FOUND == dwRes)
				{
					//
					// Data does not exist for this device. Use default values.
					//
					DebugPrintEx(
						DEBUG_MSG,
						TEXT("No routing store configuration - using defaults"));
					dwRes = SetStringValue(m_strStoreFolder, NULL, DEFAULT_STORE_FOLDER);
					if (dwRes != ERROR_SUCCESS)
					{
						return dwRes;
					}
				}
			}

            if (ERROR_SUCCESS != dwRes &&
				ERROR_FILE_NOT_FOUND != dwRes)
            {
                //
                // Can't read configuration
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Error reading routing store configuration (ec = %ld)"),
                    dwRes);
                return dwRes;
            }
        }

        if (NULL != lpData)
		{
			//
			// Data read successfully        
			// make sure we have terminating NULL (defends from registry curruption)
			//
			if (!IsUnicodeString(lpData, dwDataSize))
			{
				//
				//  No NULL terminator, return failure
				//
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("Error reading routing store configuration, no NULL terminator.")
					);
				g_pFaxExtFreeBuffer (lpData);
				return ERROR_BAD_CONFIGURATION;   
			}	        
			dwRes = SetStringValue(m_strStoreFolder, NULL, LPCWSTR(lpData));
			if (dwRes != ERROR_SUCCESS)
			{
				return dwRes;
			}
			g_pFaxExtFreeBuffer (lpData);
		}
        

        lpData = NULL;

        //
        // Read printer name
        //
        dwRes = g_pFaxExtGetData ( m_dwId,
                                   DEV_ID_SRC_FAX, // We always use the Fax Device Id
                                   REGVAL_RM_PRINTING_GUID,
                                   &lpData,
                                   &dwDataSize
                                 );
        if (ERROR_SUCCESS != dwRes)
        {
            if (ERROR_FILE_NOT_FOUND == dwRes)
            {
				//
				// Data does not exist for this device. Try to read default values from unassociated data.
				// 
				dwRes = g_pFaxExtGetData ( 0,    // unassociated data
                                   DEV_ID_SRC_FAX, // We always use the Fax Device Id
                                   REGVAL_RM_PRINTING_GUID,
                                   &lpData,
                                   &dwDataSize
								   );
				if (ERROR_FILE_NOT_FOUND == dwRes)
				{
					//
					// Data does not exist for this device. Use default values.
					//
					DebugPrintEx(
						DEBUG_MSG,
						TEXT("No routing print configuration - using defaults"));
						dwRes = SetStringValue(m_strPrinter, NULL, DEFAULT_PRINTER_NAME);
						if (dwRes != ERROR_SUCCESS)
						{
							return dwRes;
						}
				}
            }
            
			if (ERROR_SUCCESS != dwRes &&
				ERROR_FILE_NOT_FOUND != dwRes)
            {
                //
                // Can't read configuration
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Error reading routing print configuration (ec = %ld)"),
                    dwRes);
                return dwRes;
            }
        }
        
		if (NULL != lpData)
		{
			//
			// Data read successfully
			// make sure we have terminating NULL (defends from registry curruption)
			//
			if (!IsUnicodeString(lpData, dwDataSize))
			{
				//
				//  No NULL terminator, return failure
				//
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("Error reading routing print configuration, no NULL terminator.")
					);
				g_pFaxExtFreeBuffer (lpData);
				return ERROR_BAD_CONFIGURATION;   
			}
			dwRes = SetStringValue(m_strPrinter, NULL, LPCWSTR (lpData));
			if (dwRes != ERROR_SUCCESS)
			{
				return dwRes;
			}
			g_pFaxExtFreeBuffer (lpData);        
		}

        lpData = NULL;
        //
        // Read email address
        //
        dwRes = g_pFaxExtGetData ( m_dwId,
                                   DEV_ID_SRC_FAX, // We always use the Fax Device Id
                                   REGVAL_RM_EMAIL_GUID,
                                   &lpData,
                                   &dwDataSize
                                );
        if (ERROR_SUCCESS != dwRes)
        {
            if (ERROR_FILE_NOT_FOUND == dwRes)
            {
				//
				// Data does not exist for this device. Try to read default values from unassociated data.
				//
				dwRes = g_pFaxExtGetData ( 0,
                                   DEV_ID_SRC_FAX, // We always use the Fax Device Id
                                   REGVAL_RM_EMAIL_GUID,
                                   &lpData,
                                   &dwDataSize
								   );
				if (ERROR_FILE_NOT_FOUND == dwRes)
				{
					//
					// Data does not exist for this device. Use default values.
					//
					DebugPrintEx(
						DEBUG_MSG,
						TEXT("No routing email configuration - using defaults"));
						dwRes = SetStringValue(m_strSMTPTo, NULL, DEFAULT_MAIL_PROFILE);
						if (dwRes != ERROR_SUCCESS)
						{
							return dwRes;
						}
				}
            }
            
			if (ERROR_SUCCESS != dwRes &&
				ERROR_FILE_NOT_FOUND != dwRes)
            {
                //
                // Can't read configuration
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Error reading routing email configuration (ec = %ld)"),
                    dwRes);
                return dwRes;
            }
        }
        
		if (NULL != lpData)
		{
			//
			// Data read successfully                
			// make sure we have terminating NULL (defends from registry curruption)
			//
			if (!IsUnicodeString(lpData, dwDataSize))
			{
				//
				//  No NULL terminator, return failure
				//
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("Error reading routing email configuration, no NULL terminator.")
					);
				g_pFaxExtFreeBuffer (lpData);
				return ERROR_BAD_CONFIGURATION;   
			}
			dwRes = SetStringValue(m_strSMTPTo, NULL, LPCWSTR(lpData));
			if (dwRes != ERROR_SUCCESS)
			{
				return dwRes;
			}
			g_pFaxExtFreeBuffer (lpData);        
		}
    }
    catch (exception ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Got an STL exception (%S)"),
            ex.what());

        //
        //  prevent leak when exception is thrown
        //
        if ( lpData )
        {
            g_pFaxExtFreeBuffer (lpData);
        }

        return ERROR_GEN_FAILURE;
    }

    return ERROR_SUCCESS;
}   // CDeviceRoutingInfo::ReadConfiguration

HRESULT
CDeviceRoutingInfo::ConfigChange (
    LPCWSTR     lpcwstrNameGUID,    // Configuration name
    LPBYTE      lpData,             // New configuration data
    DWORD       dwDataSize          // Size of new configuration data
)
/*++

Routine name : CDeviceRoutingInfo::ConfigChange

Routine description:

    Handles configuration changes (by notification)

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    lpcwstrNameGUID [in] - Configuration name
    lpData          [in] - New configuration data
    dwDataSize      [in] - Size of new configuration data

Return Value:

    Standard HRESULT code

--*/
{
	DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::ConfigChange"));

    if (!_tcsicmp (lpcwstrNameGUID, REGVAL_RM_FLAGS_GUID))
    {
        //
        // Flags have changed
        //
        if (sizeof (DWORD) != dwDataSize)
        {
            //
            // We're expecting a single DWORD here
            //
            return HRESULT_FROM_WIN32(ERROR_BADDB); // The configuration registry database is corrupt.
        }
        m_dwFlags = DWORD (*lpData);
        return NOERROR;
    }

    //
    // This is one of our routing method's configuration which changed.
    // Verify the new data is a Unicode string.
    //
    if (!IsUnicodeString(lpData, dwDataSize))
    {
        //
        //  No NULL terminator, set to empty string.
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error reading routing method %s string configuration, no NULL terminator."),
            lpcwstrNameGUID
            );
        lpData = (LPBYTE)TEXT("");                
    }
    if (!_tcsicmp (lpcwstrNameGUID, REGVAL_RM_FOLDER_GUID))
    {
        //
        // Store folder has changed
        //
        dwRes = SetStringValue(m_strStoreFolder, NULL, LPCWSTR(lpData));
		return HRESULT_FROM_WIN32(dwRes);
    }
    if (!_tcsicmp (lpcwstrNameGUID, REGVAL_RM_PRINTING_GUID))
    {
        //
        // Printer name has changed
        //
        dwRes = SetStringValue(m_strPrinter, NULL, LPCWSTR(lpData));
		return HRESULT_FROM_WIN32(dwRes);
    }
    if (!_tcsicmp (lpcwstrNameGUID, REGVAL_RM_EMAIL_GUID))
    {
        //
        // Email address has changed
        //
        dwRes = SetStringValue(m_strSMTPTo, NULL, LPCWSTR(lpData));
		return HRESULT_FROM_WIN32(dwRes);
    }
    DebugPrintEx(
        DEBUG_ERR,
        TEXT("Device %ld got configuration change notification for unknown GUID (%s)"),
        m_dwId,
        lpcwstrNameGUID);
    ASSERT_FALSE
    return HRESULT_FROM_WIN32(ERROR_GEN_FAILURE);
}   // CDeviceRoutingInfo::ConfigChange


DWORD
CDeviceRoutingInfo::EnableFlag (
    DWORD dwFlag,
    BOOL  bEnable
)
/*++

Routine name : CDeviceRoutingInfo::EnableFlag

Routine description:

    Sets a new value to the routing methods flags

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwFlag          [in] - Flag id
    bEnable         [in] - Is flag enabled?

Return Value:

    Standard Win32 error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwValue = m_dwFlags;
    DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::EnableFlag"));

    Assert ((LR_STORE == dwFlag) ||
            (LR_PRINT == dwFlag) ||
            (LR_EMAIL == dwFlag));

    if (bEnable == ((dwValue & dwFlag) ? TRUE : FALSE))
    {
        //
        // No change
        //
        return ERROR_SUCCESS;
    }
    //
    // Change temporary flag value
    //
    if (bEnable)
    {
        dwValue |= dwFlag;
    }
    else
    {
        dwValue &= ~dwFlag;
    }
    //
    // Store new value in the extension data storage
    //
    dwRes = g_pFaxExtSetData (g_hModule,
                              m_dwId,
                              DEV_ID_SRC_FAX, // We always use the Fax Device Id
                              REGVAL_RM_FLAGS_GUID,
                              (LPBYTE)&dwValue,
                              sizeof (DWORD)
                             );
    if (ERROR_SUCCESS == dwRes)
    {
        //
        // Registry store successful - Update flags value in memory with new value.
        //
        m_dwFlags = dwValue;
    }    return dwRes;
}   // CDeviceRoutingInfo::EnableFlag

DWORD
CDeviceRoutingInfo::SetStringValue (
    wstring &wstr,
    LPCWSTR lpcwstrGUID,
    LPCWSTR lpcwstrCfg
)
/*++

Routine name : CDeviceRoutingInfo::SetStringValue

Routine description:

    Updates a configuration for a device

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    wstr            [in] - Refrence to internal string configuration
    lpcwstrGUID     [in] - GUID of routing method we configure (for storage purposes)
						If this parameter is NULL, only the memory reference of the member is updated but not the persistance one
    lpcwstrCfg      [in] - New string configuration

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CDeviceRoutingInfo::SetStringValue"));

    //
    // Persist the data
    //
	if (lpcwstrGUID != NULL)
	{
		dwRes = g_pFaxExtSetData (g_hModule,
								m_dwId,
								DEV_ID_SRC_FAX, // We always use the Fax Device Id
								lpcwstrGUID,
								(LPBYTE)lpcwstrCfg,
								StringSize (lpcwstrCfg)
								);
	}
	//
    // Store the data in memory
    //
	EnterCriticalSection(&g_csRoutingStrings);
    try
    {
        wstr = lpcwstrCfg;
    }
    catch (exception ex)
    {
		LeaveCriticalSection(&g_csRoutingStrings);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Got an STL exception while setting a configuration string (%S)"),
            ex.what());
        return ERROR_NOT_ENOUGH_MEMORY;
    }
	LeaveCriticalSection(&g_csRoutingStrings);
    return dwRes;
}   // CDeviceRoutingInfo::SetStringValue



/************************************
*                                   *
*          Implementation           *
*                                   *
************************************/


BOOL WINAPI
FaxRouteSetRoutingInfo(
    IN  LPCWSTR     lpcwstrRoutingGuid,
    IN  DWORD       dwDeviceId,
    IN  const BYTE *lpbRoutingInfo,
    IN  DWORD       dwRoutingInfoSize
    )
/*++

Routine name : FaxRouteSetRoutingInfo

Routine description:

    The FaxRouteSetRoutingInfo function modifies routing configuration data
    for a specific fax device.

    Each fax routing extension DLL must export the FaxRouteSetRoutingInfo function

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    lpcwstrRoutingGuid  [in] - Pointer to the GUID for the routing method
    dwDeviceId          [in] - Identifier of the fax device to modify
    lpbRoutingInfo      [in] - Pointer to the buffer that provides configuration data
    dwRoutingInfoSize   [in] - Size, in bytes, of the buffer

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero.
    To get extended error information, the fax service calls GetLastError().

--*/
{
    DWORD dwRes;
    CDeviceRoutingInfo *pDevInfo;
    BOOL bMethodEnabled;
    LPCWSTR lpcwstrMethodConfig = LPCWSTR(&lpbRoutingInfo[sizeof (DWORD)]);
    DEBUG_FUNCTION_NAME(TEXT("FaxRouteSetRoutingInfo"));

    if (dwRoutingInfoSize < sizeof (DWORD))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Data size is too small (%ld)"),
            dwRoutingInfoSize);
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    pDevInfo = g_DevicesMap.GetDeviceRoutingInfo(dwDeviceId);
    if (NULL == pDevInfo)
    {
        return FALSE;
    }
    //
    // First DWORD tells if method is enabled
    //
    bMethodEnabled = *((LPDWORD)(lpbRoutingInfo)) ? TRUE : FALSE;
    switch( GetMaskBit( lpcwstrRoutingGuid ))
    {
        case LR_PRINT:
            if (bMethodEnabled)
            {
                //
                // Only if the method is enabled, we update the new configuration
                //
                dwRes = pDevInfo->SetPrinter ( lpcwstrMethodConfig );
                if (ERROR_SUCCESS != dwRes)
                {
                    SetLastError (dwRes);
                    return FALSE;
                }
            }
            dwRes = pDevInfo->EnablePrint (bMethodEnabled);
            if (ERROR_SUCCESS != dwRes)
            {
                SetLastError (dwRes);
                return FALSE;
            }
            break;

        case LR_STORE:
            if (bMethodEnabled)
            {
                //
                // Only if the method is enabled, we update the new configuration
                //
                dwRes = pDevInfo->SetStoreFolder ( lpcwstrMethodConfig );
                if (ERROR_SUCCESS != dwRes)
                {
                    SetLastError (dwRes);
                    return FALSE;
                }
            }
            dwRes = pDevInfo->EnableStore (bMethodEnabled);
            if (ERROR_SUCCESS != dwRes)
            {
                SetLastError (dwRes);
                return FALSE;
            }
            break;

        case LR_EMAIL:
           if (bMethodEnabled)
            {
                //
                // Only if the method is enabled, we update the new configuration
                //
                dwRes = pDevInfo->SetSMTPTo ( lpcwstrMethodConfig );
                if (ERROR_SUCCESS != dwRes)
                {
                    SetLastError (dwRes);
                    return FALSE;
                }
            }
            dwRes = pDevInfo->EnableEmail (bMethodEnabled);
            if (ERROR_SUCCESS != dwRes)
            {
                SetLastError (dwRes);
                return FALSE;
            }
             break;

        default:
            //
            // Unknown GUID requested
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Unknown routing method GUID (%s)"),
                lpcwstrRoutingGuid);
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
    }
    return TRUE;
}   // FaxRouteSetRoutingInfo

BOOL WINAPI
FaxRouteGetRoutingInfo(
    IN  LPCWSTR     lpcwstrRoutingGuid,
    IN  DWORD       dwDeviceId,
    IN  LPBYTE      lpbRoutingInfo,
    OUT LPDWORD     lpdwRoutingInfoSize
    )
/*++

Routine name : FaxRouteGetRoutingInfo

Routine description:

    The FaxRouteGetRoutingInfo function queries the fax routing extension
    DLL to obtain routing configuration data for a specific fax device.

    Each fax routing extension DLL must export the FaxRouteGetRoutingInfo function

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    lpcwstrRoutingGuid  [in ] - Pointer to the GUID for the routing method

    dwDeviceId          [in ] - Specifies the identifier of the fax device to query.

    lpbRoutingInfo      [in ] - Pointer to a buffer that receives the fax routing configuration data.

    lpdwRoutingInfoSize [out] - Pointer to an unsigned DWORD variable that specifies the size,
                                in bytes, of the buffer pointed to by the lpbRoutingInfo parameter.

Return Value:

    If the function succeeds, the return value is a nonzero value.

    If the function fails, the return value is zero.
    To get extended error information, the fax service calls GetLastError().

--*/
{
 	wstring				strConfigString;
    DWORD               dwDataSize = sizeof (DWORD);
    CDeviceRoutingInfo *pDevInfo;
    BOOL                bMethodEnabled;
    DEBUG_FUNCTION_NAME(TEXT("FaxRouteGetRoutingInfo"));

    pDevInfo = g_DevicesMap.GetDeviceRoutingInfo(dwDeviceId);
    if (NULL == pDevInfo)
    {
        return FALSE;
    }
    switch( GetMaskBit( lpcwstrRoutingGuid ))
    {
        case LR_PRINT:
            if (!pDevInfo->GetPrinter(strConfigString))
			{
				return FALSE;
			}
            bMethodEnabled = pDevInfo->IsPrintEnabled();
            break;

        case LR_STORE:
            if (!pDevInfo->GetStoreFolder(strConfigString))
			{
				return FALSE;
			}
            bMethodEnabled = pDevInfo->IsStoreEnabled();
            break;

        case LR_EMAIL:
            if (!pDevInfo->GetSMTPTo(strConfigString))				
			{
				return FALSE;
			}
			bMethodEnabled = pDevInfo->IsEmailEnabled ();
            break;

        default:
            //
            // Unknown GUID requested
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Unknown routing method GUID (%s)"),
                lpcwstrRoutingGuid);
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
    }
    dwDataSize += ((strConfigString.length() + 1) * sizeof(WCHAR));

    if (NULL == lpbRoutingInfo)
    {
        //
        // Caller just wants to know the data size
        //
        *lpdwRoutingInfoSize = dwDataSize;
        return TRUE;
    }
    if (dwDataSize > *lpdwRoutingInfoSize)
    {
        //
        // Caller supplied too small a buffer
        //
        *lpdwRoutingInfoSize = dwDataSize;
        SetLastError (ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }
    //
    // First DWORD tells if this method is enabled or not
    //
    *((LPDWORD)lpbRoutingInfo) = bMethodEnabled;
    //
    // Skip to string area
    //
    lpbRoutingInfo += sizeof(DWORD);
    //
    // Copy string
    //
    wcscpy( (LPWSTR)lpbRoutingInfo, strConfigString.c_str());
    //
    // Set actual size used
    //
    *lpdwRoutingInfoSize = dwDataSize;
    return TRUE;
}   // FaxRouteGetRoutingInfo

HRESULT
FaxRoutingExtConfigChange (
    DWORD       dwDeviceId,         // The device for which configuration has changed
    LPCWSTR     lpcwstrNameGUID,    // Configuration name
    LPBYTE      lpData,             // New configuration data
    DWORD       dwDataSize          // Size of new configuration data
)
/*++

Routine name : FaxRoutingExtConfigChange

Routine description:

    Handles configuration change notifications

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId      [in] - The device for which configuration has changed
    lpcwstrNameGUID [in] - Configuration name
    lpData          [in] - New configuration data
    data            [in] - Size of new configuration data

Return Value:

    Standard HRESULT code

--*/
{
    HRESULT hr;
    DEBUG_FUNCTION_NAME(TEXT("FaxRoutingExtConfigChange"));

    CDeviceRoutingInfo *pDevice = g_DevicesMap.FindDeviceRoutingInfo (dwDeviceId);
    if (!pDevice)
    {
        //
        // Device not found in map - can't be
        //
        hr = HRESULT_FROM_WIN32(GetLastError ());
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Got a notification but cant find device %ld (hr = 0x%08x) !!!!"),
            dwDeviceId,
            hr);
        ASSERT_FALSE;
        return hr;
    }

    return pDevice->ConfigChange (lpcwstrNameGUID, lpData, dwDataSize);
}   // FaxRoutingExtConfigChange
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\store.cpp ===
#include "faxrtp.h"
#pragma hdrstop

#include <strsafe.h>

static 
DWORD 
CreateUniqueTIFfile (
    IN  LPCTSTR wszDstDir,
    OUT LPTSTR  wszDstFile,
    IN  DWORD   dwDstFileSize
)
/*++

Routine name : CreateUniqueTIFfile

Routine description:

    Finds a unique TIF file name in the specified directory.
    The file is in the format path\FaxXXXXXXXX.TIF
    where:
        path = wszDstDir
        XXXXXXXX = Hexadecimal representation of a unique ID

Author:

    Eran Yariv (EranY), Jun, 1999

Arguments:

    wszDstDir           [in]  - Destiantion directory fo the file (must exist)
    wszDstFile          [out] - Resulting unique file name
    dwDstFileSize       [in]  - The size of the buffer, pointed to by wszDstFile in TCHARs

Return Value:

    DWORD - Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateUniqueTIFfile"));

    static  DWORD dwLastID  = 0xffffffff;
    DWORD   dwPrevLastID    = dwLastID;

    for (DWORD dwCurID = dwLastID + 1; dwCurID != dwPrevLastID; dwCurID++)
    {
        //
        // Try with the current Id
        //
        HRESULT hr = StringCchPrintf( wszDstFile,
                                      dwDstFileSize,
                                      _T("%s\\Fax%08x.TIF"),
                                      wszDstDir,
                                      dwCurID );
        if (FAILED(hr))
        {
            return HRESULT_CODE(hr);
        }

        HANDLE hFile;

        hFile = SafeCreateFile (
                            wszDstFile, 
                            GENERIC_WRITE, 
                            0,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
        if (INVALID_HANDLE_VALUE == hFile)
        {
            DWORD dwErr = GetLastError ();
            if (ERROR_FILE_EXISTS == dwErr)
            {
                //
                // This ID is already in use
                //
                continue;
            }
            //
            // Otherwise, this is another error
            //
            DebugPrintEx (DEBUG_ERR,
                          L"Error while calling CreateFile on %s (ec = %ld)",
                          wszDstFile,
                          dwErr
                         );
            return dwErr;
        }
        //
        // Otherwise, we succeeded.
        //
        CloseHandle (hFile);
        dwLastID = dwCurID;
        return ERROR_SUCCESS;
    }
    //
    // All IDs are occupied
    //
    DebugPrintEx (DEBUG_ERR,
                  L"All IDs are occupied");
    return ERROR_NO_MORE_FILES;
}   // CreateUniqueTIFfile


BOOL
FaxMoveFile(
    LPCTSTR  TiffFileName,
    LPCTSTR  DestDir
    )

/*++

Routine Description:

    Stores a FAX in the specified directory.  This routine will also
    cached network connections.

Arguments:

    TiffFileName            - Name of TIFF file to store
    DestDir                 - Name of directory to store it in

Return Value:

    TRUE for success, FALSE on error

--*/

{
    WCHAR   TempDstDir [MAX_PATH + 1];
    WCHAR   DstFile[MAX_PATH * 2] = {0};
    DWORD   dwErr = ERROR_SUCCESS;
    int     iDstPathLen;	
    DEBUG_FUNCTION_NAME(TEXT("FaxMoveFile"));

	Assert (DestDir);
    //
    // Remove any '\' characters at end of destination directory
    //
	HRESULT hr = StringCchCopy(
		TempDstDir,
		ARR_SIZE(TempDstDir),		
		DestDir );
    if (FAILED(hr))
    {
		DebugPrintEx (
			DEBUG_ERR,
			L"Store folder name exceeds MAX_PATH chars");
        dwErr =  HRESULT_CODE(hr);
		goto end;
    }

    iDstPathLen = lstrlen (TempDstDir);
    Assert (iDstPathLen);
    if ('\\' == TempDstDir[iDstPathLen - 1])
    {
        TempDstDir[iDstPathLen - 1] = L'\0';
    }

    //
    // Create unique destiantion file name
    //
    dwErr = CreateUniqueTIFfile (TempDstDir, DstFile, ARR_SIZE(TempDstDir));
    if (ERROR_SUCCESS != dwErr)
    {
        goto end;
    }
    //
    // Try to copy the file.
    // We use FALSE as 3rd parameter because CreateUniqueTIFfile creates
    // and empty unique file.
    //
    if (!CopyFile (TiffFileName, DstFile, FALSE)) 
    {
        dwErr = GetLastError ();
        DebugPrintEx (DEBUG_ERR,
                      L"Can't copy file (ec = %ld)",
                      dwErr
                     );
        goto end;
    }

end:
    if (ERROR_SUCCESS != dwErr)
    {
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MIN,
            3,
            MSG_FAX_SAVE_FAILED,
            TiffFileName,
            (*DstFile)?DstFile:TempDstDir,
            DWORD2HEX(dwErr)
            );
        return FALSE;
    }
    else
    {
        FaxLog(
            FAXLOG_CATEGORY_INBOUND,
            FAXLOG_LEVEL_MAX,
            2,
            MSG_FAX_SAVE_SUCCESS,
            TiffFileName,
            (*DstFile)?DstFile:TempDstDir
            );
        return TRUE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\faxroute\util.cpp ===
#include "faxrtp.h"
#pragma hdrstop


typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    DWORD   InternalId;
    LPCTSTR String;
} STRING_TABLE, *PSTRING_TABLE;


static STRING_TABLE StringTable[] =
{
    { IDS_SERVICE_NAME,           IDS_SERVICE_NAME,           NULL },
    { IDS_UNKNOWN_SENDER,         IDS_UNKNOWN_SENDER,         NULL },
    { IDS_UNKNOWN_RECIPIENT,      IDS_UNKNOWN_RECIPIENT,      NULL }
};

#define CountStringTable (sizeof(StringTable)/sizeof(STRING_TABLE))





VOID
InitializeStringTable(
    VOID
    )
{
    DWORD i;
    TCHAR Buffer[256];

    for (i=0; i<CountStringTable; i++) 
    {
        if (LoadString(
            g_hResource,
            StringTable[i].ResourceId,
            Buffer,
            ARR_SIZE(Buffer)
            )) 
        {
            StringTable[i].String = (LPCTSTR) MemAlloc( StringSize( Buffer ) );
            if (!StringTable[i].String) 
            {
                StringTable[i].String = TEXT("");
            } 
            else 
            {
                _tcscpy( (LPTSTR)StringTable[i].String, Buffer );
            }
        } else 
        {
            StringTable[i].String = TEXT("");
        }
    }
}


LPCTSTR
GetString(
    DWORD InternalId
    )

/*++

Routine Description:

    Loads a resource string and returns a pointer to the string.
    The caller must free the memory.

Arguments:

    ResourceId      - resource string id

Return Value:

    pointer to the string

--*/

{
    DWORD i;

    for (i=0; i<CountStringTable; i++) 
    {
        if (StringTable[i].InternalId == InternalId) 
        {
            return StringTable[i].String;
        }
    }
    return NULL;
}


DWORD
GetMaskBit(
    LPCWSTR RoutingGuid
    )
{
    if (_tcsicmp( RoutingGuid, REGVAL_RM_EMAIL_GUID ) == 0) {
        return LR_EMAIL;
    } else if (_tcsicmp( RoutingGuid, REGVAL_RM_FOLDER_GUID ) == 0) {
        return LR_STORE;
    } else if (_tcsicmp( RoutingGuid, REGVAL_RM_PRINTING_GUID ) == 0) {
        return LR_PRINT;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\include\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)        07-May-1991
    Paula Tomlinson (paulat)   06-June-1995    Modified for plug-and-play

Revision History:


--*/
#ifndef _IMPORTS_H
#define _IMPORTS_H

#include <windef.h>
#include <winbase.h>
#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPCWSTR [string] wchar_t*
#define HCALL DWORD
#endif

#include <fxsapip.h>

typedef enum {
    RECIPIENT_PERSONAL_PROF = 1,
    SENDER_PERSONAL_PROF
} FAX_ENUM_PERSONAL_PROF_TYPES;



#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#define LPCTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#define LPCTSTR [string] LPCTSTR
#endif
#define LPSTR [string] LPSTR
#define LPCSTR [string] LPCSTR
#define BOOL DWORD
#endif
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\addfspdlg.cpp ===
// AddFSPDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "AddFSPDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"
#define USE_EXTENDED_FSPI
#include "..\..\..\inc\faxdev.h"
#include "..\..\..\inc\faxdevex.h"
#include "..\..\inc\efspimp.h"

/////////////////////////////////////////////////////////////////////////////
// CAddFSPDlg dialog


CAddFSPDlg::CAddFSPDlg(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CAddFSPDlg::IDD, pParent),
      m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CAddFSPDlg)
	m_cstrFriendlyName = _T("");
	m_bAbortParent = FALSE;
	m_bAbortRecipient = FALSE;
	m_bAutoRetry = FALSE;
	m_bBroadcast = FALSE;
	m_bMultisend = FALSE;
	m_bScheduling = FALSE;
	m_bSimultaneousSendRecieve = FALSE;
	m_cstrGUID = _T("");
	m_cstrImageName = _T("");
	m_cstrTSPName = _T("");
	m_iVersion = 0;
	//}}AFX_DATA_INIT
}


void CAddFSPDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddFSPDlg)
	DDX_Text(pDX, IDC_FRIENDLY_NAME, m_cstrFriendlyName);
	DDX_Check(pDX, IDC_FSPI_CAP_ABORT_PARENT, m_bAbortParent);
	DDX_Check(pDX, IDC_FSPI_CAP_ABORT_RECIPIENT, m_bAbortRecipient);
	DDX_Check(pDX, IDC_FSPI_CAP_AUTO_RETRY, m_bAutoRetry);
	DDX_Check(pDX, IDC_FSPI_CAP_BROADCAST, m_bBroadcast);
	DDX_Check(pDX, IDC_FSPI_CAP_MULTISEND, m_bMultisend);
	DDX_Check(pDX, IDC_FSPI_CAP_SCHEDULING, m_bScheduling);
	DDX_Check(pDX, IDC_FSPI_CAP_SIMULTANEOUS_SEND_RECEIVE, m_bSimultaneousSendRecieve);
	DDX_Text(pDX, IDC_GUID, m_cstrGUID);
	DDX_Text(pDX, IDC_IMAGENAME, m_cstrImageName);
	DDX_Text(pDX, IDC_TSPNAME, m_cstrTSPName);
	DDX_Radio(pDX, IDC_VERSION1, m_iVersion);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddFSPDlg, CDialog)
	//{{AFX_MSG_MAP(CAddFSPDlg)
	ON_BN_CLICKED(IDADD, OnAdd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddFSPDlg message handlers

void CAddFSPDlg::OnAdd() 
{
    if (!UpdateData ())
    {
        return;
    }
    DWORD dwFSPIVersion = m_iVersion ? FSPI_API_VERSION_2 : FSPI_API_VERSION_1;
    DWORD dwCapabilities =   m_bAbortParent ? FSPI_CAP_ABORT_PARENT : 0 |
                             m_bAbortRecipient ? FSPI_CAP_ABORT_RECIPIENT : 0 |
                             m_bAutoRetry ? FSPI_CAP_AUTO_RETRY : 0 |
                             m_bBroadcast ?  FSPI_CAP_BROADCAST : 0 |
                             m_bMultisend ?  FSPI_CAP_MULTISEND : 0 |
                             m_bScheduling ? FSPI_CAP_SCHEDULING : 0 |
                             m_bSimultaneousSendRecieve ? FSPI_CAP_SIMULTANEOUS_SEND_RECEIVE : 0;
    if (!FaxRegisterServiceProviderEx (
            m_hFax,
            m_cstrGUID,
            m_cstrFriendlyName,
            m_cstrImageName,
            m_cstrTSPName,
            dwFSPIVersion,
            dwCapabilities))
    {
        CString cs;
        cs.Format ("Failed while calling FaxRegisterServiceProviderEx (%ld)", 
                   GetLastError ());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    else
    {
        AfxMessageBox ("FSP successfully added. You need to restart the service for the change to take effect", MB_OK | MB_ICONHAND);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\include\rpcutil.h ===
/*++

Copyright (c) 1990,91  Microsoft Corporation

Module Name:

    ntrpcp.h

Abstract:

    This file contains prototypes for commonly used RPC functionality.
    This includes: bind/unbind functions, MIDL user alloc/free functions,
    and server start/stop functions.

Author:

    Dan Lafferty danl 06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created

    26-Apr-1991 JohnRo
        Added IN and OUT keywords to MIDL functions.  Commented-out
        (nonstandard) identifier on endif.  Deleted tabs.

    03-July-1991    JimK
        Commonly used aspects copied from LM specific file.

--*/
#ifndef _NTRPCP_
#define _NTRPCP_

#ifdef __cplusplus
extern "C" {
#endif


#define MAX_ENDPOINT_LEN 11 // Max length of DWORD as a string "4294967296"
#define NT_PIPE_PREFIX      _T("\\PIPE\\")

#define WCSSIZE(s)          ((wcslen(s)+1) * sizeof(WCHAR))
#define TCSSIZE(s)          ((_tcslen(s)+1) * sizeof(TCHAR))


//
// Function Prototypes - routines called by MIDL-generated code:
//

void * __stdcall
MIDL_user_allocate(
    IN size_t NumBytes
    );

void __stdcall
MIDL_user_free(
    IN void *MemPointer
    );

//
// Function Prototypes - routines to go along with the above, but aren't
// needed by MIDL or any other non-network software.
//

void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN unsigned long NewByteCount
    );

unsigned long
MIDL_user_size(
    IN void * Pointer
    );

#ifdef __cplusplus
} //extern "C"
#endif

#ifdef UNICODE
    #define RPC_TCHAR   TCHAR
#else
    #define RPC_TCHAR   unsigned char
#endif
#define RPC_SERVER_PRINCIPAL_NAME   (RPC_TCHAR *)(TEXT("f7a9e6cc-90d5-49c6-accd-6ece99e2779c-SharedFaxServer"))

#define RPC_PROT_SEQ_TCP_IP         (LPCTSTR)_T("ncacn_ip_tcp")
#define RPC_PROT_SEQ_NP             (LPCTSTR)_T("ncacn_np")

#endif // _NTRPCP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\registry\registry.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.cpp

Abstract:

    This header contains the private data structures and
    function prototypes for the fax server registry code.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#include "fxsapip.h"
#include "faxutil.h"
#include "faxreg.h"
#include "faxsvcrg.h"
#include "eventlog.h"


typedef struct _REGISTRY_KEY {
    LPTSTR                      Name;               // key name
    BOOL                        Dynamic;            //
    DWORD                       DynamicDataSize;    //
    LPBYTE                      DynamicData;        //
    DWORD                       DynamicDataCount;   //
    DWORD                       SubKeyOffset;       //
} REGISTRY_KEY, *PREGISTRY_KEY;


typedef struct _REGISTRY_VALUE {
    LPTSTR                      Name;               // key or value name
    ULONG                       Type;               // value type
    DWORD                       DataPtr;            // pointer to the data buffer
    ULONG                       Size;               // data size for strings
    ULONG                       Default;            // default if it doesn't exist
} REGISTRY_VALUE, *PREGISTRY_VALUE;


typedef struct _REGISTRY_KEYVALUE {
    REGISTRY_KEY                RegKey;             // registry key data
    DWORD                       ValueCount;         // number of RegValue entries
    PREGISTRY_VALUE             RegValue;           // registry value data
    struct _REGISTRY_KEYVALUE   *SubKey;            // subkey data, NULL is valid
} REGISTRY_KEYVALUE, *PREGISTRY_KEYVALUE;


typedef struct _REGISTRY_TABLE {
    DWORD                       Count;              // number of RegKeyValue entries
    PREGISTRY_KEYVALUE          RegKeyValue[0];     // registry keys & values
} REGISTRY_TABLE, *PREGISTRY_TABLE;



//
// internal function prototypes
//

BOOL
InitializeRegistryTable(
    LPTSTR          RegKeySoftware,
    PREGISTRY_TABLE RegistryTable
    );

BOOL
ChangeRegistryTable(
    LPTSTR          RegKeySoftware,
    PREGISTRY_TABLE RegistryTable
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\registry\faxsvcrg.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxreg.h

Abstract:

    This header defines all of the fax service
    registry data structures and access functions.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#ifndef _FAXREG_
#define _FAXREG_

#ifdef __cplusplus
extern "C" {
#endif

#include "..\faxroute\FaxRouteP.h"



typedef struct _REG_DEVICE_PROVIDER {

    LPTSTR                  FriendlyName;
    LPTSTR                  ImageName;
    LPTSTR                  ProviderName;
    DWORD                   dwAPIVersion;       // The FSPI API Version.    
    LPTSTR                  lptstrGUID;         // The GUID of the FSP, might be NULL.    
} REG_DEVICE_PROVIDER, *PREG_DEVICE_PROVIDER;


typedef struct _REG_ROUTING_METHOD {

    LPTSTR                  FriendlyName;
    LPTSTR                  FunctionName;
    LPTSTR                  Guid;
    LPTSTR                  InternalName;
    DWORD                   Priority;

} REG_ROUTING_METHOD, *PREG_ROUTING_METHOD;


typedef struct _REG_ROUTING_EXTENSION {

    LPTSTR                  FriendlyName;
    LPTSTR                  ImageName;
    LPTSTR                  InternalName;
    DWORD                   RoutingMethodsCount;
    PREG_ROUTING_METHOD     RoutingMethods;

} REG_ROUTING_EXTENSION, *PREG_ROUTING_EXTENSION;


typedef struct _REG_DEVICE {

    DWORD                   TapiPermanentLineID; // The TAPI permanent line id for TAPI Lines.                                                 
                                                 // For legacy virtual lines this is the same as PermanentLineId.
    LPTSTR                  Name;
    DWORD                   Flags;
    DWORD                   Rings;
    LPTSTR                  Csid;
    LPTSTR                  Tsid;
    LPTSTR                  lptstrDeviceName;   // Device name
    LPTSTR                  lptstrDescription;  // Device free-text description

    BOOL                    DeviceInstalled;    // this is not stored, but is used to validate currently
                                                // installed tapi devices with the devices in the registry
    BOOL                    bValidDevice;       // this indicates that the registry entries are created by FAXSVC
                                                // (and not by some FSP that writes to the registry directly)
    DWORD                   PermanentLineId;    // The Fax Service generated permanent line id for the device (virtual or TAPI).
                                                // This is NOT the TAPI permanent id.
    LPTSTR                  lptstrProviderGuid; // The GUID of the FSP for this line, might be NULL.
    DWORDLONG               dwlLastDetected;    // FILETIME when this device was last detected
} REG_DEVICE, *PREG_DEVICE;


typedef struct _REG_CATEGORY {

    LPTSTR                  CategoryName;
    DWORD                   Number;
    DWORD                   Level;

} REG_CATEGORY, *PREG_CATEGORY;

typedef struct _REG_SETUP {

    LPTSTR                  Csid;
    LPTSTR                  Tsid;
    LPTSTR                  lptstrDescription;
    DWORD                   Rings;
    DWORD                   Flags;

} REG_SETUP, *PREG_SETUP;

typedef struct _REG_FAX_SERVICE {

    DWORD                   Retries;
    DWORD                   RetryDelay;
    DWORD                   DirtyDays;
    BOOL                    NextJobNumber;
    BOOL                    Branding;
    BOOL                    UseDeviceTsid;
    BOOL                    ServerCp;
    FAX_TIME                StartCheapTime;
    FAX_TIME                StopCheapTime;
    PREG_DEVICE_PROVIDER    DeviceProviders;
    DWORD                   DeviceProviderCount;
    PREG_ROUTING_EXTENSION  RoutingExtensions;
    DWORD                   RoutingExtensionsCount;
    PREG_DEVICE             Devices;
    DWORD                   DeviceCount;
    PREG_CATEGORY           Logging;
    DWORD                   LoggingCount;
    DWORD                   dwLastUniqueLineId;
    DWORD                   dwQueueState;
    DWORDLONG               dwlMissingDeviceRegistryLifetime;
    DWORD                   dwMaxLineCloseTime;
	LPTSTR					lptstrQueueDir;
	DWORD					dwRecipientsLimit;
	DWORD					dwAllowRemote;
} REG_FAX_SERVICE, *PREG_FAX_SERVICE;

typedef struct _REG_FAX_DEVICES {

    DWORD                   DeviceCount;
    PREG_DEVICE             Devices;

} REG_FAX_DEVICES, *PREG_FAX_DEVICES;

typedef struct _REG_FAX_LOGGING {

    DWORD                   LoggingCount;
    PREG_CATEGORY           Logging;

} REG_FAX_LOGGING, *PREG_FAX_LOGGING;

typedef enum
{
    FAX_NO_DATA,
    FAX_DATA_ENCRYPTED,
    FAX_DATA_NOT_ENCRYPTED,    
} FAX_ENUM_DATA_ENCRYPTION;



//
// function prototypes
//

DWORD
GetFaxRegistry(
    PREG_FAX_SERVICE *ppFaxReg
    );

VOID
FreeFaxRegistry(
    PREG_FAX_SERVICE FaxReg
    );

BOOL
CreateFaxEventSource(
    PREG_FAX_SERVICE FaxReg,
    PFAX_LOG_CATEGORY DefaultCategories,
    int DefaultCategoryCount
    );

PREG_FAX_DEVICES
GetFaxDevicesRegistry(
    VOID
    );

BOOL
SetFaxRoutingInfo(
    LPTSTR ExtensionName,
    LPTSTR MethodName,
    LPTSTR Guid,
    DWORD  Priority,
    LPTSTR FunctionName,
    LPTSTR FriendlyName
    ) ;

VOID
FreeFaxDevicesRegistry(
    PREG_FAX_DEVICES FaxReg
    );

DWORD
RegSetFaxDeviceFlags(
    DWORD PermanentLineID,
    DWORD Flags
    );

BOOL
DeleteFaxDevice(
    DWORD PermanentLineID,
    DWORD PermanentTapiID
    );

BOOL
UpdateLastDetectedTime(
    DWORD PermanentLineID,
    DWORDLONG TimeNow
    );

BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms,
    LPDWORD ProductType
    );

BOOL
IsModemClass1(
    LPSTR SubKey,
    LPBOOL Class1Fax
    );

BOOL
SaveModemClass(
    LPSTR SubKey,
    BOOL Class1Fax
    );

DWORD
RegAddNewFaxDevice(
    LPDWORD lpdwLastUniqueLineId,
    LPDWORD lpdwPermanentLineId,
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR ProviderGuid,
    LPTSTR Csid,
    LPTSTR Tsid,
    DWORD TapiPermanentLineID,
    DWORD Flags,
    DWORD Rings
    );


BOOL
GetOrigSetupData(
    IN  DWORD       dwPermanentLineId,
    OUT PREG_SETUP  RegSetup
    );

VOID
FreeOrigSetupData(
    PREG_SETUP RegSetup
    );

BOOL
SetFaxGlobalsRegistry(
    PFAX_CONFIGURATION FaxConfig,
    DWORD              dwQueueState
    );

BOOL
GetLoggingCategoriesRegistry(
    PREG_FAX_LOGGING FaxRegLogging
    );

BOOL
SetLoggingCategoriesRegistry(
    PREG_FAX_LOGGING FaxRegLogging
    );

BOOL
SetFaxJobNumberRegistry(
    DWORD NextJobNumber
    );

DWORD
SaveQueueState (DWORD dwNewState);

DWORD
StoreReceiptsSettings (CONST PFAX_RECEIPTS_CONFIG);

DWORD
LoadReceiptsSettings (PFAX_SERVER_RECEIPTS_CONFIGW);

DWORD
StoreOutboxSettings (PFAX_OUTBOX_CONFIG);

DWORD
LoadArchiveSettings (FAX_ENUM_MESSAGE_FOLDER, PFAX_ARCHIVE_CONFIG);

DWORD
StoreArchiveSettings (FAX_ENUM_MESSAGE_FOLDER, PFAX_ARCHIVE_CONFIG);

DWORD
LoadActivityLoggingSettings (PFAX_SERVER_ACTIVITY_LOGGING_CONFIG);

DWORD
StoreActivityLoggingSettings (PFAX_ACTIVITY_LOGGING_CONFIG);

DWORD
StoreDeviceConfig (DWORD dwDeviceId, PFAX_PORT_INFO_EX, BOOL bVirtualDevice);

DWORD
ReadExtensionData (
    DWORD                        dwDeviceId,
    FAX_ENUM_DEVICE_ID_SOURCE    DevIdSrc,
    LPCWSTR                      lpcwstrNameGUID,
    LPBYTE                      *ppData,
    LPDWORD                      lpdwDataSize
);

DWORD
WriteExtensionData (
    DWORD                       dwDeviceId,
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,
    LPCWSTR                     lpcwstrNameGUID,
    LPBYTE                      pData,
    DWORD                       dwDataSize
);

HKEY
OpenOutboundGroupKey (LPCWSTR lpcwstrGroupName, BOOL fNewKey, REGSAM SamDesired);

HKEY
OpenOutboundRuleKey (
    DWORD dwCountryCode,
    DWORD dwAreaCode,
    BOOL fNewKey,
    REGSAM SamDesired
    );

DWORD DeleteOutboundRuleKey (DWORD dwCountryCode, DWORD dwAreaCode);


DWORD
AddNewProviderToRegistry (
    LPCWSTR      lpcwstrGUID,
    LPCWSTR      lpctstrFriendlyName,
    LPCWSTR      lpctstrImageName,
    LPCWSTR      lpctstrTspName,
    DWORD        dwFSPIVersion    
);

BOOL
SetRegistrySecureString (
    HKEY hKey,
    LPCTSTR lpctstrValueName,
    LPCTSTR lpctstrValue,
    BOOL    bOptionallyNonSecure
);


DWORD
RemoveProviderFromRegistry (
    LPCWSTR lpctstrGUID
);

DWORD
WriteManualAnswerDeviceId (
    DWORD dwDeviceId
);

DWORD
ReadManualAnswerDeviceId (
    LPDWORD lpdwDeviceId
);

DWORD
FindServiceDeviceByTapiPermanentLineID(
    DWORD                   dwTapiPermanentLineID,
    LPCTSTR                 strDeviceName,
    PREG_SETUP              pRegSetup,
    const PREG_FAX_DEVICES  pInputFaxReg
);

DWORD
FindCacheEntryByTapiPermanentLineID(
    DWORD               dwTapiPermanentLineID,
    LPCTSTR             strDeviceName,
    const PREG_SETUP    pRegSetup,
    LPDWORD             lpdwLastUniqueLineId,
    BOOL*               pfManualAnswer
);


DWORD
GetNewServiceDeviceID(
    LPDWORD lpdwLastUniqueLineId,
    LPDWORD lpdwPermanentLineId
);

DWORD
MoveDeviceRegIntoDeviceCache (
        DWORD dwServerPermanentID,
        DWORD dwTapiPermanentLineID,
        BOOL  fManualAnswer
);

DWORD
RestoreDeviceRegFromDeviceCache (
        DWORD dwServerPermanentID,
        DWORD dwTapiPermanentLineID
);

DWORD
CleanOldDevicesFromDeviceCache (
        DWORDLONG dwlTimeNow
);

DWORD
DeleteDeviceEntry(
    DWORD dwServerPermanentID
    );

DWORD
DeleteTapiEntry(
    DWORD dwTapiPermanentLineID
    );


DWORD
DeleteCacheEntry(
    DWORD dwTapiPermanentLineID
    );


LPTSTR
GetRegistrySecureString(
    HKEY    hKey,
    LPCTSTR lpctstrValueName,
    LPCTSTR lpctstrDefaultValue,
    BOOL    bOptionallyNonSecure,	
	FAX_ENUM_DATA_ENCRYPTION* pDataEncrypted
    );


#ifdef __cplusplus
} //extern "C"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\addfspdlg.h ===
#if !defined(AFX_ADDFSPDLG_H__2F1C422A_F2F6_45B0_904E_73ACC75311E3__INCLUDED_)
#define AFX_ADDFSPDLG_H__2F1C422A_F2F6_45B0_904E_73ACC75311E3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AddFSPDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddFSPDlg dialog

class CAddFSPDlg : public CDialog
{
// Construction
public:
	CAddFSPDlg(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddFSPDlg)
	enum { IDD = IDD_ADDFSP_DLG };
	CString	m_cstrFriendlyName;
	BOOL	m_bAbortParent;
	BOOL	m_bAbortRecipient;
	BOOL	m_bAutoRetry;
	BOOL	m_bBroadcast;
	BOOL	m_bMultisend;
	BOOL	m_bScheduling;
	BOOL	m_bSimultaneousSendRecieve;
	CString	m_cstrGUID;
	CString	m_cstrImageName;
	CString	m_cstrTSPName;
	int		m_iVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddFSPDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddFSPDlg)
	afx_msg void OnAdd();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    HANDLE                         m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDFSPDLG_H__2F1C422A_F2F6_45B0_904E_73ACC75311E3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\registry\faxreg.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxreg.c

Abstract:

    This module wraps all of the registry access
    for the fax server.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <objbase.h>
#include <wincrypt.h>
#include <Shlwapi.h.>

#include "fxsapip.h"
#include "faxutil.h"
#include "faxext.h"
#include "faxreg.h"
#include "faxsvcrg.h"

#define FAX_CATEGORY_COUNT              4

#define BAD_FOLDER_STRING               TEXT("\\\\\\")

static BYTE const gsc_baEntropy [] = {0x46, 0x41, 0x58, 0x43, 0x4F, 0x56, 0x45, 0x52, 0x2D, 0x56, 0x45, 0x52,
                               0x30, 0x30, 0x35, 0x77, 0x87, 0x00, 0x00, 0x00};

static
BOOL
SetRegistrySecureBinary (
    HKEY hKey,
    LPCTSTR lpctstrValueName,
    LPBYTE  lpbValue,
    DWORD   dwValueSize,
    BOOL    bOptionallyNonSecure
)
/*++

Routine name : SetRegistrySecureBinary

Routine description:

    Stores a binary blob in the registry with encryption

Author:

    Eran Yariv (EranY), Sep, 2001

Arguments:

    hKey                          [in]     - Handle to registry key (open)
    lpctstrValueName              [in]     - Name of value
    lpbValue                      [in]     - Blob to store
    dwValueSize                   [in]     - Size of data blob
    bOptionallyNonSecure          [in]     - Do we allow the registry entry to be non-secure?
                                             If FALSE, the data will always be written encrypted.
                                             If TRUE, the data will be written encrypted but prefixed with 
                                                a string (FAX_REG_SECURITY_PREFIX). 

Return Value:

    TRUE if success, FALSE otherwise.

Remarks:

    Data is stored in REG_BINARY format.

    Encryption has no UI

    Encryption is machine based (if you change the account under which the server is running, it will
       still be able to read and decrypt the encrypted data).

--*/
{
    BOOL bRes = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("SetRegistrySecureBinary"));

    Assert (hKey && lpbValue && dwValueSize);
    //
    // Start by encrypting the value
    //
    DATA_BLOB DataIn;
    DATA_BLOB DataOut = {0};
    DataIn.pbData = lpbValue;
    DataIn.cbData = dwValueSize;
    DATA_BLOB DataEntropy;
    DataEntropy.pbData = (BYTE*)gsc_baEntropy;
    DataEntropy.cbData = sizeof (gsc_baEntropy);

    if (!CryptProtectData(
            &DataIn,
            TEXT("Description"),                // No description sting.
            &DataEntropy,                       // We're using the cover page signature as an additional entropy
            NULL,                               // Reserved.
            NULL,                               // No user prompt
            CRYPTPROTECT_UI_FORBIDDEN,          // Presenting a user interface (UI) is not an option.
            &DataOut))
    {
        DWORD dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CryptProtectData failed with %ld"),
            dwRes);
        return bRes;
    }
    if (bOptionallyNonSecure)
    {
        //
        // Need to prefix the data with FAX_REG_SECURITY_PREFIX.
        // This is done so that the matching reading function can handle secure and non-secure data
        // correctly.
        //
        DWORD dwPrefixSize = sizeof (TCHAR) * wcslen (FAX_REG_SECURITY_PREFIX);
        DWORD dwSize =  dwPrefixSize + DataOut.cbData;
        BYTE *pPrefixedData = (BYTE*)LocalAlloc (LPTR, dwSize);
        if (!pPrefixedData)
        {
            DWORD dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LocalAlloc failed with %ld"),
                dwRes);
            goto exit;
        }
        memcpy (pPrefixedData, FAX_REG_SECURITY_PREFIX, dwPrefixSize);
        memcpy (&pPrefixedData[dwPrefixSize], DataOut.pbData, DataOut.cbData);
        LocalFree (DataOut.pbData);
        DataOut.pbData = pPrefixedData;
        DataOut.cbData = dwSize;
    }        
    //
    // Store the data in the registry (as binary)
    //
    if (!SetRegistryBinary(
                hKey,
                lpctstrValueName,
                DataOut.pbData,
                DataOut.cbData))
    {
        DWORD dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetRegistryBinary failed with %ld"),
            dwRes);
        goto exit;
    }
    bRes = TRUE;

exit:

    LocalFree (DataOut.pbData);
    return bRes;
}   // SetRegistrySecureBinary


BOOL
SetRegistrySecureString (
    HKEY hKey,
    LPCTSTR lpctstrValueName,
    LPCTSTR lpctstrValue,
    BOOL    bOptionallyNonSecure
)
/*++

Routine name : SetRegistrySecureString

Routine description:

    Stores a string in the registry with encryption

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    hKey                          [in]     - Handle to registry key (open)
    lpctstrValueName              [in]     - Name of value
    lpctstrValue                  [in]     - String to store
    bOptionallyNonSecure          [in]     - Do we allow the registry entry to be non-secure?
                                             If FALSE, the data will always be written encrypted.
                                             If TRUE, the data will be written encrypted but prefixed with 
                                                a string (FAX_REG_SECURITY_PREFIX). 

Return Value:

    TRUE if success, FALSE otherwise.

Remarks:

    String is stored in REG_BINARY format.

    Encryption has no UI

    Encryption is machine based (if you change the account under which the server is running, it will
       still be able to read and decrypt the encrypted data).

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SetRegistrySecureString"));

    return SetRegistrySecureBinary (hKey, 
                                    lpctstrValueName,
                                    (LPBYTE)lpctstrValue,
                                    (lstrlen(lpctstrValue) + 1) * sizeof (TCHAR),
                                    bOptionallyNonSecure);
}   // SetRegistrySecureString


static
DWORD
GetRegistrySecureBinary(
    HKEY    hKey,
    LPCTSTR lpctstrValueName,
    LPBYTE *ppData,
    LPDWORD lpdwSize,
    BOOL    bOptionallyNonSecure,
	FAX_ENUM_DATA_ENCRYPTION* pDataDecrypted
)
/*++

Routine name : GetRegistrySecureBinary

Routine description:

    Reads an decrypts a secure registry string

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    hKey                          [in]     - Handle to registry key (open)
    lpctstrValueName              [in]     - Name of value
    ppData                        [out]    - Allocated return buffer
    lpdwSize                      [out]    - Allocated return buffer size (in bytes)
    bOptionallyNonSecure          [in]     - Do we allow the registry entry to be non-secure?
                                             If FALSE, the data will always be read and decrypted.
                                             If TRUE, the data will be read and checked for a prefix
                                                string (FAX_REG_SECURITY_PREFIX) before it is decrypted.
                                                If the prefix string is not there, the data will not be
                                                decrypted and will be returned as-is.
    pDataDecrypted				  [out]    - Points to a FAX_ENUM_DATA_ENCRYPTION that on return is FAX_DATA_ENCRYPTED if the data was decrypted,
											 and FAX_DATA_NOT_ENCRYPTED if the data was not decrypted and was returned as is.
											 FAX_NO_DATA means that this information is not available.
											 Ignored if NULL;

Return Value:

    Win32 error code

Remarks:

    String is stored in REG_BINARY format.

    String was stored by calling SetRegistrySecureBinary().

    Caller should MemFree return value.

--*/
{
    DATA_BLOB DataIn;
    DWORD dwRes = ERROR_SUCCESS;
    DATA_BLOB DataOut = {0};
    DATA_BLOB DataEntropy;
    
    DEBUG_FUNCTION_NAME(TEXT("GetRegistrySecureBinary"));

    Assert (hKey && ppData && lpdwSize);
	if (NULL != pDataDecrypted)
	{
		*pDataDecrypted = FAX_NO_DATA;
	}
    //
    // Get the registry data first
    //
    DataIn.pbData = GetRegistryBinary(
                        hKey,
                        lpctstrValueName,
                        &DataIn.cbData);
    if (!DataIn.pbData)
    {
        //
        // Couldn't read data
        //
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("GetRegistryBinary failed with %ld"),
            dwRes);
        return dwRes;            
    }
    if (1 == DataIn.cbData)
    {
        //
        // Data wasn't found in the registry.
        // Current implementation of GetRegistryBinary returns a 1-byte buffer of 0 in that case.
        // We know for sure that data encrypted with CryptProtectData must be longer than 10 bytes.
        //
        MemFree (DataIn.pbData);
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("GetRegistryBinary found no data for %s"),
            lpctstrValueName);
        return ERROR_FILE_NOT_FOUND;
    }
    //
    // We got the data - decrypt it
    //
    DataEntropy.pbData = (BYTE*)gsc_baEntropy;
    DataEntropy.cbData = sizeof (gsc_baEntropy);

    if (bOptionallyNonSecure)
    {
        //
        // Data is allowed to be non-secure
        //
        DWORD dwPrefixSize = sizeof (TCHAR) * wcslen (FAX_REG_SECURITY_PREFIX);
        if ((DataIn.cbData <= dwPrefixSize) ||
            memcmp (DataIn.pbData, FAX_REG_SECURITY_PREFIX, dwPrefixSize))
        {
            //
            // Data length is too short or data does not start with encryption signature.
            // The data we're reading is non-secure. Just return it as is.
            //
            *lpdwSize = DataIn.cbData;
            *ppData = DataIn.pbData;
			if (pDataDecrypted)
			{
				*pDataDecrypted = FAX_DATA_NOT_ENCRYPTED;
			}
            return ERROR_SUCCESS;
        }
        else
        {
            //
            // The data starts with encryption signature.
            // Actual encrypted data follows signature.
            //
            BYTE *pRealData;

			if (pDataDecrypted)
			{
				*pDataDecrypted = FAX_DATA_ENCRYPTED;            
			}
            DataIn.cbData -= dwPrefixSize;
            pRealData = (LPBYTE)MemAlloc (DataIn.cbData);
            if (!pRealData)
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("MemAlloc failed with %ld"),
                    dwRes);
                goto exit;
            }
            memcpy (pRealData, &(DataIn.pbData[dwPrefixSize]), DataIn.cbData);
            MemFree (DataIn.pbData);
            DataIn.pbData = pRealData;
        }
    }
	else
	{
		//
		// The data is always encrypted
		//
		if (pDataDecrypted)
		{
			*pDataDecrypted = FAX_DATA_ENCRYPTED;
		}
	}
    if (!CryptUnprotectData(
        &DataIn,                        // Data to decrypt
        NULL,                           // Not interested in description
        &DataEntropy,                   // Entropy in use
        NULL,                           // Reserved
        NULL,                           // No prompt
        CRYPTPROTECT_UI_FORBIDDEN,      // Presenting a user interface (UI) is not an option.
        &DataOut))                      // Out data
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CryptUnprotectData failed with %ld"),
            dwRes);
        goto exit;
    }
    //
    // Use our own memory allocation
    //
    *lpdwSize = DataOut.cbData;
    *ppData = (LPBYTE)MemAlloc (DataOut.cbData);
    if (!(*ppData))
    {
        dwRes = GetLastError ();
        goto exit;
    }
    memcpy (*ppData, DataOut.pbData, DataOut.cbData);
    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (DataOut.pbData)
    {
		SecureZeroMemory(DataOut.pbData, DataOut.cbData);
        LocalFree (DataOut.pbData);
    }
    MemFree (DataIn.pbData);
    return dwRes;
}   // GetRegistrySecureBinary


LPTSTR
GetRegistrySecureString(
    HKEY    hKey,
    LPCTSTR lpctstrValueName,
    LPCTSTR lpctstrDefaultValue,
    BOOL    bOptionallyNonSecure,
	FAX_ENUM_DATA_ENCRYPTION*   pDataDecrypted
)
/*++

Routine name : GetRegistrySecureString

Routine description:

    Reads an decrypts a secure registry string

Author:

    Eran Yariv (EranY), Jul, 2000

Arguments:

    hKey                          [in]     - Handle to registry key (open)
    lpctstrValueName              [in]     - Name of value
    lpctstrDefaultValue           [in]     - Default value
    bOptionallyNonSecure          [in]     - Do we allow the registry entry to be non-secure?
                                             If FALSE, the data will always be read and decrypted.
                                             If TRUE, the data will be read and checked for a prefix
                                                string (FAX_REG_SECURITY_PREFIX) before it is decrypted.
                                                If the prefix string is not there, the data will not be
                                                decrypted and will be returned as-is.
	pDataDecrypted				  [out]    - Points to a FAX_ENUM_DATA_ENCRYPTION that on return is FAX_DATA_ENCRYPTED if the data was decrypted,
											 and FAX_DATA_NOT_ENCRYPTED if the data was not decrypted and was returned as is.
											 FAX_NO_DATA means that this information is not available.
											 Ignored if NULL;

Return Value:

    String read or NULL on error

Remarks:

    String is stored in REG_BINARY format.

    String was stored by calling SetRegistrySecureString().

    Caller should MemFree return value.

--*/
{
    LPTSTR lptstrResult = NULL;
    DWORD  dwRes;
    DWORD  dwSize;
    DEBUG_FUNCTION_NAME(TEXT("GetRegistrySecureString"));
    
    dwRes = GetRegistrySecureBinary (hKey, 
                                     lpctstrValueName, 
                                     (LPBYTE*)&lptstrResult, 
                                     &dwSize,
                                     bOptionallyNonSecure,
									 pDataDecrypted);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Error reading or decrypting data - return default
        //
        return StringDup (lpctstrDefaultValue);
    }
    //
    // Assert the read binary blob is indeed a string by checing for EOSTR at the end.
    //
    Assert (lptstrResult[dwSize / sizeof (TCHAR) - 1] == TEXT('\0'));
    return lptstrResult;
}   // GetRegistrySecureString

static
DWORD
OpenExtensionKey (
    DWORD                       dwDeviceId,
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,
    PHKEY                       lphKey
);

BOOL
EnumDeviceProviders(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpFaxReg
    )
{
    PREG_FAX_SERVICE FaxReg = (PREG_FAX_SERVICE) lpFaxReg;
    DEBUG_FUNCTION_NAME(TEXT("EnumDeviceProviders"));

    if (SubKeyName == NULL) {
        //
        // The enumeration function has called us with the parent key.
        // Index should contain the number of subkeys. In this case this is the number of
        // providers subkeys.
        //
        if (Index) {
            FaxReg->DeviceProviders = (PREG_DEVICE_PROVIDER) MemAlloc( Index * sizeof(REG_DEVICE_PROVIDER) );
            if (!FaxReg->DeviceProviders) {
                return FALSE;
            }
        }
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->DeviceProviders == NULL) {
        return FALSE;
    }

    memset(&FaxReg->DeviceProviders[Index],0,sizeof(REG_DEVICE_PROVIDER));

    //
    // Check the APIVersion and see if this is an EFSP
    //
    FaxReg->DeviceProviders[Index].dwAPIVersion = GetRegistryDword(hSubKey, REGVAL_PROVIDER_API_VERSION);
    
    if (FSPI_API_VERSION_1 == FaxReg->DeviceProviders[Index].dwAPIVersion ||
        0 == FaxReg->DeviceProviders[Index].dwAPIVersion)
    {
        LPTSTR lptstrGUID;
        //
        // This is a legacy FSP
        //
        FaxReg->DeviceProviders[Index].FriendlyName = GetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, EMPTY_STRING );
        FaxReg->DeviceProviders[Index].ImageName    = GetRegistryStringExpand( hSubKey, REGVAL_IMAGE_NAME, EMPTY_STRING );
        FaxReg->DeviceProviders[Index].ProviderName = GetRegistryString( hSubKey, REGVAL_PROVIDER_NAME,EMPTY_STRING );
        FaxReg->DeviceProviders[Index].dwAPIVersion = FSPI_API_VERSION_1;

        lptstrGUID = GetRegistryString( hSubKey, REGVAL_PROVIDER_GUID,EMPTY_STRING );
        if ( (NULL == lptstrGUID) || (0 == _tcscmp(lptstrGUID , EMPTY_STRING)) )
        {
            //
            // This FSP was registerd using the legacy registration API
            // Use the provider unique name as a "GUID"
            //
            MemFree (lptstrGUID);
            lptstrGUID = StringDup(SubKeyName);
        }
        FaxReg->DeviceProviders[Index].lptstrGUID = lptstrGUID;
    }    
    else
    {
        //
        // API_VERSION we do not support
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Unknown API version : 0x%08X"),
            FaxReg->DeviceProviders[Index].dwAPIVersion);
    }

    return TRUE;
}


BOOL
EnumDeviceProvidersChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpFaxReg
    )
{
    PREG_FAX_SERVICE FaxReg = (PREG_FAX_SERVICE) lpFaxReg;
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->DeviceProviders == NULL) {
        return FALSE;
    }

    SetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, FaxReg->DeviceProviders[Index].FriendlyName );
    SetRegistryStringExpand( hSubKey, REGVAL_IMAGE_NAME, FaxReg->DeviceProviders[Index].ImageName );
    SetRegistryString( hSubKey, REGVAL_PROVIDER_NAME, FaxReg->DeviceProviders[Index].ProviderName );

    return TRUE;
}


BOOL
EnumRoutingMethods(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID pvRoutingExtension
    )
{

    PREG_ROUTING_EXTENSION RoutingExtension = (PREG_ROUTING_EXTENSION) pvRoutingExtension;
    if (SubKeyName == NULL) {
        if (Index) {
            RoutingExtension->RoutingMethods = (PREG_ROUTING_METHOD) MemAlloc( Index * sizeof(REG_ROUTING_METHOD) );
            if (!RoutingExtension->RoutingMethods) {
                return FALSE;
            }
        }
        return TRUE;
    }

    if (RoutingExtension == NULL || RoutingExtension->RoutingMethods == NULL) {
        return FALSE;
    }

    RoutingExtension->RoutingMethods[Index].InternalName = StringDup( SubKeyName );
    RoutingExtension->RoutingMethods[Index].FriendlyName = GetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, EMPTY_STRING );
    RoutingExtension->RoutingMethods[Index].FunctionName = GetRegistryString( hSubKey, REGVAL_FUNCTION_NAME, EMPTY_STRING );
    RoutingExtension->RoutingMethods[Index].Guid   = GetRegistryString( hSubKey, REGVAL_GUID, EMPTY_STRING );
    RoutingExtension->RoutingMethods[Index].Priority     = GetRegistryDword( hSubKey, REGVAL_ROUTING_PRIORITY );
    return TRUE;
}


BOOL
EnumRoutingMethodsChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpRoutingExtension
    )
{
    PREG_ROUTING_EXTENSION RoutingExtension = (PREG_ROUTING_EXTENSION) lpRoutingExtension;
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (RoutingExtension == NULL || RoutingExtension->RoutingMethods) {
        return FALSE;
    }

    SetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME,    RoutingExtension->RoutingMethods[Index].FriendlyName );
    SetRegistryString( hSubKey, REGVAL_FUNCTION_NAME,    RoutingExtension->RoutingMethods[Index].FunctionName );
    SetRegistryString( hSubKey, REGVAL_GUID,             RoutingExtension->RoutingMethods[Index].Guid         );
    SetRegistryDword ( hSubKey, REGVAL_ROUTING_PRIORITY, RoutingExtension->RoutingMethods[Index].Priority     );

    return TRUE;
}


BOOL
EnumRoutingExtensions(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpFaxReg
    )
{
    PREG_FAX_SERVICE FaxReg = (PREG_FAX_SERVICE) lpFaxReg;
    if (SubKeyName == NULL) {
        if (Index) {
            FaxReg->RoutingExtensions = (PREG_ROUTING_EXTENSION) MemAlloc( Index * sizeof(REG_ROUTING_EXTENSION) );
            if (!FaxReg->RoutingExtensions) {
                return FALSE;
            }
        }
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->RoutingExtensions == NULL) {
        return FALSE;
    }

    FaxReg->RoutingExtensions[Index].InternalName   = StringDup( SubKeyName );
    FaxReg->RoutingExtensions[Index].FriendlyName = GetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, EMPTY_STRING );
    FaxReg->RoutingExtensions[Index].ImageName    = GetRegistryStringExpand( hSubKey, REGVAL_IMAGE_NAME, EMPTY_STRING );

    //
    // load the routing methods for this extension
    //

    FaxReg->RoutingExtensions[Index].RoutingMethodsCount = EnumerateRegistryKeys(
        hSubKey,
        REGKEY_ROUTING_METHODS,
        FALSE,
        EnumRoutingMethods,
        &FaxReg->RoutingExtensions[Index]
        );

    return TRUE;
}


BOOL
EnumRoutingExtensionsChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpFaxReg
    )
{
    PREG_FAX_SERVICE FaxReg = (PREG_FAX_SERVICE) lpFaxReg;
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->RoutingExtensions == NULL) {
        return FALSE;
    }

    SetRegistryString( hSubKey, REGVAL_FRIENDLY_NAME, FaxReg->RoutingExtensions[Index].FriendlyName );
    SetRegistryStringExpand( hSubKey, REGVAL_IMAGE_NAME, FaxReg->RoutingExtensions[Index].ImageName );

    //
    // load the routing methods for this extension
    //

    EnumerateRegistryKeys(
        hSubKey,
        REGKEY_ROUTING_METHODS,
        TRUE,
        EnumRoutingMethodsChange,
        &FaxReg->RoutingExtensions[Index]
        );

    return TRUE;
}


BOOL
EnumDevices(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpFaxReg
    )
{
    PREG_FAX_SERVICE FaxReg = (PREG_FAX_SERVICE) lpFaxReg;
    HKEY hNewSubKey = NULL;

    if (SubKeyName == NULL) {
        if (Index) {
            FaxReg->Devices = (PREG_DEVICE) MemAlloc( Index * sizeof(REG_DEVICE) );
            if (!FaxReg->Devices) {
                return FALSE;
            }
            ZeroMemory(FaxReg->Devices, Index * sizeof(REG_DEVICE));
        }
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->Devices == NULL) {
        return FALSE;
    }

    FaxReg->Devices[Index].PermanentLineId = GetRegistryDword( hSubKey, REGVAL_PERMANENT_LINEID);

    hNewSubKey = OpenRegistryKey( hSubKey, REGKEY_FAXSVC_DEVICE_GUID, FALSE, NULL );
    if(hNewSubKey)
    {
        DWORDLONG *pTemp;
        DWORD dwDataSize = sizeof(DWORDLONG);

        FaxReg->Devices[Index].bValidDevice    = TRUE;
        FaxReg->Devices[Index].Flags           = GetRegistryDword( hNewSubKey, REGVAL_FLAGS );
        FaxReg->Devices[Index].Rings           = GetRegistryDword( hNewSubKey, REGVAL_RINGS );
        FaxReg->Devices[Index].Name            = GetRegistryString( hNewSubKey, REGVAL_DEVICE_NAME, EMPTY_STRING );
        FaxReg->Devices[Index].Csid            = GetRegistryString( hNewSubKey, REGVAL_ROUTING_CSID, EMPTY_STRING );
        FaxReg->Devices[Index].Tsid            = GetRegistryString( hNewSubKey, REGVAL_ROUTING_TSID, EMPTY_STRING );
        FaxReg->Devices[Index].TapiPermanentLineID = GetRegistryDword( hNewSubKey, REGVAL_TAPI_PERMANENT_LINEID );
        FaxReg->Devices[Index].lptstrDeviceName = GetRegistryString( hNewSubKey, REGVAL_DEVICE_NAME, EMPTY_STRING);
        FaxReg->Devices[Index].lptstrDescription = GetRegistryString( hNewSubKey, REGVAL_DEVICE_DESCRIPTION, EMPTY_STRING);
        FaxReg->Devices[Index].lptstrProviderGuid = GetRegistryString( hNewSubKey, REGVAL_PROVIDER_GUID, EMPTY_STRING );

        pTemp = (DWORDLONG *)GetRegistryBinary(hNewSubKey, REGVAL_LAST_DETECTED_TIME, &dwDataSize);
        if(pTemp && dwDataSize == sizeof(DWORDLONG))
        {
            FaxReg->Devices[Index].dwlLastDetected = *pTemp;
            MemFree(pTemp);
        }

        RegCloseKey(hNewSubKey);
    }
    else
    {
        FaxReg->Devices[Index].bValidDevice    = FALSE;
    }
    return TRUE;
}

VOID
SetDevicesValues(
    HKEY hSubKey,
    DWORD dwPermanentLineId,
    DWORD TapiPermanentLineID,
    DWORD Flags,
    DWORD Rings,
    LPCTSTR DeviceName,
    LPCTSTR ProviderGuid,
    LPCTSTR Csid,
    LPCTSTR Tsid
    )
{
    HKEY hNewSubKey = NULL;

    SetRegistryDword(  hSubKey, REGVAL_PERMANENT_LINEID, dwPermanentLineId );


    hNewSubKey = OpenRegistryKey( hSubKey, REGKEY_FAXSVC_DEVICE_GUID, TRUE, NULL );
    if(hNewSubKey)
    {
        SetRegistryDword(  hNewSubKey, REGVAL_TAPI_PERMANENT_LINEID, TapiPermanentLineID );
        SetRegistryDword(  hNewSubKey, REGVAL_FLAGS,            Flags           );
        SetRegistryDword(  hNewSubKey, REGVAL_RINGS,            Rings           );
        if (DeviceName)
        {
            SetRegistryString( hNewSubKey, REGVAL_DEVICE_NAME,      DeviceName      );
        }
        if (ProviderGuid)
        {
            if (ProviderGuid[0])
            {
                SetRegistryString( hNewSubKey, REGVAL_PROVIDER_GUID,    ProviderGuid   );
            }
        }
        SetRegistryString( hNewSubKey, REGVAL_ROUTING_CSID,     Csid            );
        SetRegistryString( hNewSubKey, REGVAL_ROUTING_TSID,     Tsid            );

        RegCloseKey(hNewSubKey);
    }

}


BOOL
EnumDevicesChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpFaxReg
    )
{
    PREG_FAX_SERVICE FaxReg = (PREG_FAX_SERVICE) lpFaxReg;
    if (SubKeyName == NULL) {
        //
        // called once for the subkey
        //
        return TRUE;
    }

    if (FaxReg == NULL || FaxReg->Devices == NULL) {
        return FALSE;
    }

    SetDevicesValues(
        hSubKey,
        FaxReg->Devices[Index].PermanentLineId,
        FaxReg->Devices[Index].TapiPermanentLineID,
        FaxReg->Devices[Index].Flags,
        FaxReg->Devices[Index].Rings,
        FaxReg->Devices[Index].Name,
        FaxReg->Devices[Index].lptstrProviderGuid,
        FaxReg->Devices[Index].Csid,
        FaxReg->Devices[Index].Tsid
        );

    return TRUE;
}


BOOL
EnumLogging(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpFaxReg
    )
{
    PREG_FAX_SERVICE FaxReg = (PREG_FAX_SERVICE) lpFaxReg;
    if (SubKeyName == NULL)
    {
        if (Index)
        {
            FaxReg->Logging = (PREG_CATEGORY) MemAlloc( Index * sizeof(REG_CATEGORY) );
            if (!FaxReg->Logging)
            {
                return FALSE;
            }
        }

        return TRUE;
    }

    if (FaxReg->Logging == NULL)
    {
        return FALSE;
    }

    FaxReg->Logging[Index].CategoryName = GetRegistryString( hSubKey, REGVAL_CATEGORY_NAME, EMPTY_STRING );
    FaxReg->Logging[Index].Level        = GetRegistryDword( hSubKey, REGVAL_CATEGORY_LEVEL );
    FaxReg->Logging[Index].Number       = GetRegistryDword( hSubKey, REGVAL_CATEGORY_NUMBER );

    return TRUE;
}


BOOL
EnumLoggingChange(
    HKEY hSubKey,
    LPWSTR SubKeyName,
    DWORD Index,
    LPVOID lpFaxReg
    )
{
    PREG_FAX_SERVICE FaxReg = (PREG_FAX_SERVICE) lpFaxReg;
    if (SubKeyName == NULL) {
        return TRUE;
    }

    SetRegistryString( hSubKey, REGVAL_CATEGORY_NAME, FaxReg->Logging[Index].CategoryName );
    SetRegistryDword( hSubKey, REGVAL_CATEGORY_LEVEL, FaxReg->Logging[Index].Level );
    SetRegistryDword( hSubKey, REGVAL_CATEGORY_NUMBER, FaxReg->Logging[Index].Number );

    return TRUE;
}


DWORD
GetFaxRegistry(
    PREG_FAX_SERVICE* ppFaxReg
    )
{
    HKEY                hKey;
    DWORD               Tmp;
    DWORD ec;

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey)
    {
        ec = GetLastError();
        return ec;
    }

    if (NULL == *ppFaxReg)
    {
        //
        // First call - Allocate FaxReg and read only what is needed for event log
        //
        *ppFaxReg = (PREG_FAX_SERVICE) MemAlloc( sizeof(REG_FAX_SERVICE) );
        if (!*ppFaxReg)
        {
            RegCloseKey( hKey );
            return ERROR_OUTOFMEMORY;
        }
        ZeroMemory (*ppFaxReg, sizeof(REG_FAX_SERVICE)); 

        //
        // load the logging categories
        //
        (*ppFaxReg)->LoggingCount = EnumerateRegistryKeys(
            hKey,
            REGKEY_LOGGING,
            FALSE,
            EnumLogging,
            *ppFaxReg
            );

       RegCloseKey( hKey );
       return ERROR_SUCCESS;
    }

    //
    //  load the fax service values
    //
    (*ppFaxReg)->Retries                 = GetRegistryDword( hKey, REGVAL_RETRIES );
    (*ppFaxReg)->RetryDelay              = GetRegistryDword( hKey, REGVAL_RETRYDELAY );
    (*ppFaxReg)->DirtyDays               = GetRegistryDword( hKey, REGVAL_DIRTYDAYS );
    (*ppFaxReg)->dwQueueState            = GetRegistryDword (hKey, REGVAL_QUEUE_STATE);
    (*ppFaxReg)->NextJobNumber           = GetRegistryDword( hKey, REGVAL_JOB_NUMBER );
    (*ppFaxReg)->Branding                = GetRegistryDword( hKey, REGVAL_BRANDING );
    (*ppFaxReg)->UseDeviceTsid           = GetRegistryDword( hKey, REGVAL_USE_DEVICE_TSID );
    (*ppFaxReg)->ServerCp                = GetRegistryDword( hKey, REGVAL_SERVERCP );
    Tmp                             = GetRegistryDword( hKey, REGVAL_STARTCHEAP );
    (*ppFaxReg)->StartCheapTime.Hour     = LOWORD(Tmp);
    (*ppFaxReg)->StartCheapTime.Minute   = HIWORD(Tmp);
    Tmp                             = GetRegistryDword( hKey, REGVAL_STOPCHEAP );
    (*ppFaxReg)->StopCheapTime.Hour      = LOWORD(Tmp);
    (*ppFaxReg)->StopCheapTime.Minute    = HIWORD(Tmp);

    (*ppFaxReg)->dwLastUniqueLineId = GetRegistryDword( hKey, REGVAL_LAST_UNIQUE_LINE_ID );
    (*ppFaxReg)->dwMaxLineCloseTime = GetRegistryDword( hKey, REGVAL_MAX_LINE_CLOSE_TIME );
    (*ppFaxReg)->lptstrQueueDir = GetRegistryString( hKey, REGVAL_QUEUE_DIRECTORY, NULL );
	(*ppFaxReg)->dwRecipientsLimit = GetRegistryDword( hKey, REGVAL_RECIPIENTS_LIMIT );
	(*ppFaxReg)->dwAllowRemote = GetRegistryDword( hKey, REGVAL_ALLOW_REMOTE );	
    //
    // load the device providers
    //

    (*ppFaxReg)->DeviceProviderCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICE_PROVIDERS,
        FALSE,
        EnumDeviceProviders,
        *ppFaxReg
        );

    //
    // load the routing extensions
    //

    (*ppFaxReg)->RoutingExtensionsCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_ROUTING_EXTENSIONS,
        FALSE,
        EnumRoutingExtensions,
        *ppFaxReg
        );

    //
    // load the devices
    //

    (*ppFaxReg)->DeviceCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES,
        FALSE,
        EnumDevices,
        *ppFaxReg
        );

    RegCloseKey( hKey );
    return ERROR_SUCCESS;
}

VOID
FreeFaxRegistry(
    PREG_FAX_SERVICE FaxReg
    )
{
    DWORD i,j;


    if (!FaxReg) {
        return;
    }

    for (i=0; i<FaxReg->DeviceProviderCount; i++) {
        MemFree( FaxReg->DeviceProviders[i].FriendlyName );
        MemFree( FaxReg->DeviceProviders[i].ImageName );
        MemFree( FaxReg->DeviceProviders[i].ProviderName );
    }

    for (i=0; i<FaxReg->RoutingExtensionsCount; i++) {
        MemFree( FaxReg->RoutingExtensions[i].FriendlyName );
        MemFree( FaxReg->RoutingExtensions[i].ImageName );
        for (j=0; j<FaxReg->RoutingExtensions[i].RoutingMethodsCount; j++) {
            MemFree( FaxReg->RoutingExtensions[i].RoutingMethods[j].FriendlyName );
            MemFree( FaxReg->RoutingExtensions[i].RoutingMethods[j].FunctionName );
            MemFree( FaxReg->RoutingExtensions[i].RoutingMethods[j].Guid );
        }
        MemFree( FaxReg->RoutingExtensions[i].RoutingMethods );
    }

    MemFree( FaxReg->DeviceProviders );
    MemFree( FaxReg->RoutingExtensions );

    for (i=0; i<FaxReg->DeviceCount; i++) {
        MemFree( FaxReg->Devices[i].Name );
    }

    MemFree( FaxReg->Devices );


    for (i=0; i<FaxReg->LoggingCount; i++) {
        MemFree( FaxReg->Logging[i].CategoryName );
    }

    MemFree( FaxReg->Logging );
    MemFree( FaxReg->lptstrQueueDir );

    MemFree( FaxReg );
}


//
// This functions is provided to support the legacy FaxSetConfiguration API call.
//
BOOL
SetFaxGlobalsRegistry(
    PFAX_CONFIGURATION FaxConfig,
    DWORD              dwQueueState
    )
{
    DEBUG_FUNCTION_NAME(TEXT("SetFaxGlobalsRegistry"));
    DWORD dwRes = SaveQueueState (dwQueueState);

    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }

    HKEY    hKey;
    HKEY    hSentItemsArchiveKey;
    HKEY    hReceiptsKey;
    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                            REGKEY_SOFTWARE,
                            TRUE,
                            KEY_WRITE );
    if (!hKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open server's registry key : %ld"),
            dwRes);
        return FALSE;
    }
    hSentItemsArchiveKey = OpenRegistryKey( hKey,
                                            REGKEY_ARCHIVE_SENTITEMS_CONFIG,
                                            TRUE,
                                            KEY_WRITE );
    if (!hSentItemsArchiveKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open server's sent items archive registry key : %ld"),
            dwRes);
        RegCloseKey( hKey );
        return FALSE;
    }

    hReceiptsKey = OpenRegistryKey( hKey,
                                    REGKEY_RECEIPTS_CONFIG,
                                    TRUE,
                                    KEY_WRITE );
    if (!hReceiptsKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open server's Receipts registry key : %ld"),
            dwRes);
        RegCloseKey( hKey );
        RegCloseKey( hSentItemsArchiveKey );
        return FALSE;
    }
    SetRegistryDword(  hKey, REGVAL_RETRIES,          FaxConfig->Retries );
    SetRegistryDword(  hKey, REGVAL_RETRYDELAY,       FaxConfig->RetryDelay );
    SetRegistryDword(  hKey, REGVAL_DIRTYDAYS,        FaxConfig->DirtyDays );
    SetRegistryDword(  hKey, REGVAL_BRANDING,         FaxConfig->Branding );
    SetRegistryDword(  hKey, REGVAL_USE_DEVICE_TSID,  FaxConfig->UseDeviceTsid );
    SetRegistryDword(  hKey, REGVAL_SERVERCP,         FaxConfig->ServerCp );
    SetRegistryDword(  hKey, REGVAL_STARTCHEAP,       MAKELONG( FaxConfig->StartCheapTime.Hour, FaxConfig->StartCheapTime.Minute ) );
    SetRegistryDword(  hKey, REGVAL_STOPCHEAP,        MAKELONG( FaxConfig->StopCheapTime.Hour, FaxConfig->StopCheapTime.Minute ) );
    SetRegistryDword(  hSentItemsArchiveKey,
                       REGVAL_ARCHIVE_USE,
                       FaxConfig->ArchiveOutgoingFaxes);
    SetRegistryString( hSentItemsArchiveKey,
                       REGVAL_ARCHIVE_FOLDER,
                       FaxConfig->ArchiveDirectory );
    RegCloseKey( hReceiptsKey );
    RegCloseKey( hSentItemsArchiveKey );
    RegCloseKey( hKey );

    return TRUE;
}


/******************************************************************************
* Name: SetFaxJobNumberRegistry
* Author:
*******************************************************************************
DESCRIPTION:
    Saves the value of the next job id to the registry at the
    REGKEY_FAXSERVER\NextJobId value.
PARAMETERS:
    NextJobNumber
        A DWORD value of the next job id.
RETURN VALUE:
    TRUE if no error occured.
    FALSE otherwise.
REMARKS:
    NONE.
*******************************************************************************/

BOOL
SetFaxJobNumberRegistry(
    DWORD NextJobNumber
    )
{
    HKEY    hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, TRUE, KEY_WRITE );
    if (!hKey) {
        return FALSE;
    }

    SetRegistryDword( hKey, REGVAL_JOB_NUMBER, NextJobNumber );

    RegCloseKey( hKey );

    return TRUE;
}


BOOL
GetLoggingCategoriesRegistry(
    PREG_FAX_LOGGING FaxRegLogging
    )
{
    REG_FAX_SERVICE FaxReg = {0};
    HKEY    hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey) {
        return FALSE;
    }

    FaxRegLogging->LoggingCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_LOGGING,
        FALSE,
        EnumLogging,
        &FaxReg
        );

    RegCloseKey( hKey );

    FaxRegLogging->Logging = FaxReg.Logging;

    return TRUE;
}


BOOL
SetLoggingCategoriesRegistry(
    PREG_FAX_LOGGING FaxRegLogging
    )
{
    REG_FAX_SERVICE FaxReg = {0};
    HKEY    hKey;


    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, TRUE, KEY_READ | KEY_WRITE );
    if (!hKey) {
        return FALSE;
    }

    FaxReg.Logging = FaxRegLogging->Logging;
    FaxReg.LoggingCount = FaxRegLogging->LoggingCount;

    EnumerateRegistryKeys(
        hKey,
        REGKEY_LOGGING,
        TRUE,
        EnumLoggingChange,
        &FaxReg
        );

    RegCloseKey( hKey );

    return TRUE;
}


PREG_FAX_DEVICES
GetFaxDevicesRegistry(
    VOID
    )
{
    PREG_FAX_SERVICE    FaxReg;
    PREG_FAX_DEVICES    FaxRegDevices;
    HKEY                hKey;

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey) {
        return NULL;
    }

    FaxReg = (PREG_FAX_SERVICE) MemAlloc( sizeof(REG_FAX_SERVICE) );
    if (!FaxReg) {
        RegCloseKey( hKey );
        return NULL;
    }

    FaxRegDevices = (PREG_FAX_DEVICES) MemAlloc( sizeof(REG_FAX_DEVICES) );
    if (!FaxRegDevices) {
        MemFree( FaxReg );
        RegCloseKey( hKey );
        return NULL;
    }

    //
    // load the devices
    //

    FaxReg->DeviceCount = EnumerateRegistryKeys(
        hKey,
        REGKEY_DEVICES,
        FALSE,
        EnumDevices,
        FaxReg
        );

    RegCloseKey( hKey );

    FaxRegDevices->Devices = FaxReg->Devices;
    FaxRegDevices->DeviceCount = FaxReg->DeviceCount;

    MemFree( FaxReg );

    return FaxRegDevices;
}


//
// Note: This function requires mutual execlusion. Use CsLine to sync access to it.
//
DWORD
RegAddNewFaxDevice(
    LPDWORD lpdwLastUniqueLineId,
    LPDWORD lpdwPermanentLineId,
    LPTSTR DeviceName,
    LPTSTR ProviderName,
    LPTSTR ProviderGuid,
    LPTSTR Csid,
    LPTSTR Tsid,
    DWORD TapiPermanentLineID,
    DWORD Flags,
    DWORD Rings
    )
{
    HKEY hKey;
    TCHAR SubKeyName[128];
    DWORD dwNewUniqueLineId;
    DWORD dwAttempt = 0;
    DWORD dwRes = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("RegAddNewFaxDevice"));

    Assert( lpdwLastUniqueLineId);
    Assert( lpdwPermanentLineId);


    if (0 == *(lpdwPermanentLineId))
    {
        if( ERROR_SUCCESS != GetNewServiceDeviceID(lpdwLastUniqueLineId,lpdwPermanentLineId) )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to generate next uniqueu line id."));
            return E_FAIL;
        }
    }


    //
    // The caller provider the unique line id. This is an update operation.
    //
    dwNewUniqueLineId = *lpdwPermanentLineId;

    //
    // create the device's registry key
    //
    _stprintf( SubKeyName, TEXT("%s\\%010d"), REGKEY_FAX_DEVICES, dwNewUniqueLineId );

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, TRUE, KEY_WRITE );
    if (!hKey) {
        dwRes = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey failed for [%s] (ec: %ld)"),
                SubKeyName,
                dwRes);
        return dwRes;
    }

    SetDevicesValues(
        hKey,
        *lpdwPermanentLineId,
        TapiPermanentLineID,
        Flags,
        Rings,
        DeviceName,
        ProviderGuid,
        Csid,
        Tsid
        );

    RegCloseKey( hKey );
    //
    // close the handles and leave
    //

    return dwRes;
}


DWORD
RegSetFaxDeviceFlags(
    DWORD dwPermanentLineID,
    DWORD dwFlags
    )
{
    HKEY hKey;
    TCHAR SubKeyName[256] = {0};
    DWORD dwRes = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("RegSetFaxDeviceFlags"));

    //
    // Open the device's registry key
    //
    _sntprintf( SubKeyName,
                ARR_SIZE(SubKeyName) - 1,
                TEXT("%s\\%010d\\%s"),
                REGKEY_FAX_DEVICES,
                dwPermanentLineID,
                REGKEY_FAXSVC_DEVICE_GUID);

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, FALSE, KEY_WRITE );
    if (NULL == hKey)
    {
        dwRes = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey failed for [%s] (ec: %ld)"),
                SubKeyName,
                dwRes);
        return dwRes;
    }

    if (!SetRegistryDword(hKey, REGVAL_FLAGS, dwFlags))
    {
        dwRes = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetRegistryDword failed (ec: %ld)"),
                dwRes);
    }

    RegCloseKey( hKey );
    //
    // close the handles and leave
    //
    return dwRes;
}

BOOL
SetFaxRoutingInfo(
    LPTSTR ExtensionName,
    LPTSTR MethodName,
    LPTSTR Guid,
    DWORD  Priority,
    LPTSTR FunctionName,
    LPTSTR FriendlyName
    )
{
   HKEY hKey;
   LPTSTR KeyName = NULL;

   // calculate string size and allocate memory.
   // the string sizes includes the terminating NULL which is replaced with '\\' and terminating NULL of the KeyName String
   KeyName = (LPTSTR) MemAlloc( StringSize(REGKEY_ROUTING_EXTENSION_KEY) +
                                StringSize(ExtensionName) +
                                StringSize(REGKEY_ROUTING_METHODS) +
                                StringSize(MethodName)
                               );

   if ( !KeyName )
       return FALSE;

   wsprintf( KeyName, L"%s\\%s\\%s\\%s", REGKEY_ROUTING_EXTENSION_KEY, ExtensionName,REGKEY_ROUTING_METHODS, MethodName );

   hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, KeyName, FALSE, KEY_WRITE );
   if (!hKey) {
        MemFree( KeyName );
        return FALSE;
   }

   MemFree ( KeyName );

   SetRegistryString( hKey, REGVAL_FRIENDLY_NAME,    FriendlyName );
   SetRegistryString( hKey, REGVAL_FUNCTION_NAME,    FunctionName );
   SetRegistryString( hKey, REGVAL_GUID,             Guid         );
   SetRegistryDword ( hKey, REGVAL_ROUTING_PRIORITY, Priority     );

   RegCloseKey( hKey );

   return TRUE;
}



BOOL
DeleteFaxDevice(
    DWORD PermanentLineID,
    DWORD TapiPermanentLineID
    )
{
    BOOL success = TRUE;
    TCHAR SubKey[512];

    // delete any extension configuration data
    _stprintf( SubKey, TEXT("%s\\%08x"), REGKEY_TAPIDEVICES, TapiPermanentLineID );
    if(!DeleteRegistryKey( HKEY_LOCAL_MACHINE, SubKey ))
        success = FALSE;

    // delete any device data
    _stprintf( SubKey, TEXT("%s\\%s\\%010d"), REGKEY_SOFTWARE, REGKEY_DEVICES, PermanentLineID);
    if(!DeleteRegistryKey( HKEY_LOCAL_MACHINE, SubKey ))
        success = FALSE;

    return success;
}




VOID
FreeFaxDevicesRegistry(
    PREG_FAX_DEVICES FaxReg
    )
{
    DWORD i;


    if (!FaxReg) {
        return;
    }

    for (i=0; i<FaxReg->DeviceCount; i++) {
        MemFree( FaxReg->Devices[i].Name );
    }

    MemFree( FaxReg->Devices );

    MemFree( FaxReg );
}


BOOL
CreateFaxEventSource(
    PREG_FAX_SERVICE FaxReg,
    PFAX_LOG_CATEGORY DefaultCategories,
    int DefaultCategoryCount
    )
{
    HKEY hKey;
    HKEY hKeyLogging;
    DWORD i;

    DEBUG_FUNCTION_NAME(TEXT("CreateFaxEventSource"));

    if (FaxReg->LoggingCount == 0)
    {
        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_LOGGING, TRUE, KEY_WRITE );
        if (!hKey)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey failed with %ld."),
                GetLastError ());
            return FALSE;
        }

        FaxReg->Logging = (PREG_CATEGORY) MemAlloc(DefaultCategoryCount * sizeof(REG_CATEGORY) );
        if (!FaxReg->Logging)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("MemAlloc (%ld) failed."),
                DefaultCategoryCount * sizeof(REG_CATEGORY));
            RegCloseKey( hKey );
            return FALSE;
        }

        for (i=0; i< (DWORD) DefaultCategoryCount; i++)
        {
            TCHAR szKeyName[16] = {0};
            _itot(i+1,szKeyName,10);
            hKeyLogging = OpenRegistryKey( hKey, szKeyName, TRUE, KEY_WRITE );
            if (hKeyLogging)
            {
                SetRegistryString( hKeyLogging, REGVAL_CATEGORY_NAME, DefaultCategories[i].Name );
                FaxReg->Logging[i].CategoryName = StringDup( DefaultCategories[i].Name);

                SetRegistryDword( hKeyLogging, REGVAL_CATEGORY_LEVEL, DefaultCategories[i].Level );
                FaxReg->Logging[i].Level = DefaultCategories[i].Level;

                SetRegistryDword( hKeyLogging, REGVAL_CATEGORY_NUMBER, DefaultCategories[i].Category );
                FaxReg->Logging[i].Number = DefaultCategories[i].Category;

                RegCloseKey( hKeyLogging );
            }
        }

        FaxReg->LoggingCount = DefaultCategoryCount;

        RegCloseKey( hKey );
    }

    return TRUE;
}


BOOL
GetInstallationInfo(
    LPDWORD Installed,
    LPDWORD InstallType,
    LPDWORD InstalledPlatforms,
    LPDWORD ProductType
    )
{
    HKEY hKey;
    LONG rVal;
    DWORD RegType;
    DWORD RegSize;
    TCHAR ProductTypeStr[32];
    DWORD Bytes;
    DWORD Type;


    if (Installed == NULL || InstallType == NULL || InstalledPlatforms == NULL || ProductType == NULL) {
        return FALSE;
    }

    rVal = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        REGKEY_FAX_SETUP,
        0,
        KEY_READ,
        &hKey
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not open setup registry key, ec=0x%08x"), rVal ));
        return FALSE;
    }

    RegSize = sizeof(DWORD);

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED,
        0,
        &RegType,
        (LPBYTE) Installed,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query installed registry value, ec=0x%08x"), rVal ));
        *Installed = 0;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALL_TYPE,
        0,
        &RegType,
        (LPBYTE) InstallType,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query install type registry value, ec=0x%08x"), rVal ));
        *InstallType = 0;
    }

    rVal = RegQueryValueEx(
        hKey,
        REGVAL_FAXINSTALLED_PLATFORMS,
        0,
        &RegType,
        (LPBYTE) InstalledPlatforms,
        &RegSize
        );
    if (rVal != ERROR_SUCCESS) {
        DebugPrint(( TEXT("Could not query install platforms mask registry value, ec=0x%08x"), rVal ));
        *InstalledPlatforms = 0;
    }

    RegCloseKey( hKey );

    //
    // get the product type
    //

    *ProductType = PRODUCT_TYPE_WINNT;

    rVal = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        TEXT("System\\CurrentControlSet\\Control\\ProductOptions"),
        0,
        KEY_READ,
        &hKey
        );
    if (rVal == ERROR_SUCCESS) {
        Bytes = sizeof(ProductTypeStr);

        rVal = RegQueryValueEx(
            hKey,
            TEXT("ProductType"),
            NULL,
            &Type,
            (LPBYTE) ProductTypeStr,
            &Bytes
            );
        if (rVal == ERROR_SUCCESS) {
            if ((_tcsicmp( ProductTypeStr, TEXT("SERVERNT") ) == 0) ||
                (_tcsicmp( ProductTypeStr, TEXT("LANMANNT") ) == 0)) {
                *ProductType = PRODUCT_TYPE_SERVER;
            }
        }

        RegCloseKey( hKey );
    }

    return TRUE;
}


BOOL
IsModemClass1(
    LPSTR SubKey,
    LPBOOL Class1Fax
    )
{
    BOOL rVal = TRUE;
    LONG Rslt;
    HKEY hKey;
    DWORD Type;
    DWORD Size;


    *Class1Fax = 0;

    Rslt = RegOpenKeyExA(
        HKEY_LOCAL_MACHINE,
        SubKey,
        0,
        KEY_READ,
        &hKey
        );
    if (Rslt == ERROR_SUCCESS) {
        Size = sizeof(DWORD);
        Rslt = RegQueryValueEx(
            hKey,
            TEXT("FaxClass1"),
            0,
            &Type,
            (LPBYTE) Class1Fax,
            &Size
            );
        if (Rslt != ERROR_SUCCESS) {
            rVal = FALSE;
        }
        RegCloseKey( hKey );
    }

    return rVal;
}


BOOL
SaveModemClass(
    LPSTR SubKey,
    BOOL Class1Fax
    )
{
    BOOL rVal = FALSE;
    LONG Rslt;
    HKEY hKey;


    Rslt = RegOpenKeyExA(
        HKEY_LOCAL_MACHINE,
        SubKey,
        0,
        KEY_WRITE,
        &hKey
        );
    if (Rslt == ERROR_SUCCESS) {
        Rslt = RegSetValueEx(
            hKey,
            TEXT("FaxClass1"),
            0,
            REG_DWORD,
            (LPBYTE) &Class1Fax,
            sizeof(DWORD)
            );
        if (Rslt == ERROR_SUCCESS) {
            rVal = TRUE;
        }
        RegCloseKey( hKey );
    }

    return rVal;
}


BOOL
GetOrigSetupData(
    IN  DWORD       dwPermanentLineId,
    OUT PREG_SETUP  RegSetup
    )
/*++

Routine name : GetOrigSetupData

Routine description:

    Read from the Registry Device's data. At upgrades, Setup writes some Devices's data,
    and this function reads this and fills RegSetup.
        Devices are recognized by their Permanent Line Id, which should not change during the
        upgrade. After a specific device information is read, the key is deleted.

Author:

    Iv Garber (IvG),    Mar, 2001

Arguments:

    dwPermanentLineId             [IN]     - Permanent Line Id of the Device
    RegSetup                      [OUT]    - the structure to be returned

Return Value:

    TRUE if succeded, FALSE otherwise.

--*/
{
    HKEY    hKey = NULL;
    BOOL    fDeviceKey = TRUE;
    TCHAR   tszKeyName[256] = {0};
    DEBUG_FUNCTION_NAME(TEXT("GetOrigSetupData"));


    //
    //  see if some data is stored for this Permanent Line Id
    //
    _stprintf(tszKeyName, TEXT("%s\\%010d"), REGKEY_FAX_SETUP_ORIG, dwPermanentLineId);
    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, tszKeyName, FALSE, KEY_READ);
    if (!hKey)
    {
        //
        //  This Permanent Line Id is new, so take default values
        //
        fDeviceKey = FALSE;
        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_SETUP_ORIG, FALSE, KEY_READ);
        if (!hKey)
        {
            //
            //  Registry is corrupted
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cann't open key SETUP_ORIG, ec = %ld"),
                GetLastError());
            return FALSE;
        }
    }

    RegSetup->lptstrDescription = StringDup(EMPTY_STRING);
    RegSetup->Csid  = GetRegistryString(hKey, REGVAL_ROUTING_CSID, REGVAL_DEFAULT_CSID);
    RegSetup->Tsid  = GetRegistryString(hKey, REGVAL_ROUTING_TSID, REGVAL_DEFAULT_TSID);
    RegSetup->Rings = GetRegistryDword(hKey, REGVAL_RINGS);
    RegSetup->Flags = GetRegistryDword(hKey, REGVAL_FLAGS);


    RegCloseKey(hKey);

    //
    // Delete the key if it is a key of a device after upgrade from W2K.
    //
    if (TRUE == fDeviceKey)
    {
        DWORD dwRes = RegDeleteKey (HKEY_LOCAL_MACHINE, tszKeyName);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegDeleteKey failed, error %ld"),
                dwRes);
        }
    }
    return TRUE;
}


VOID
FreeOrigSetupData(
    PREG_SETUP RegSetup
    )
{
    MemFree( RegSetup->Csid );
    MemFree( RegSetup->Tsid );
    MemFree( RegSetup->lptstrDescription );
}

DWORD
SaveQueueState (
    DWORD dwNewState
)
/*++

Routine name : SaveQueueState

Routine description:

    Saves the queue state bits to the registry

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwNewState          [in] - New state to save

Return Value:

    Standard Win32 error codes

--*/
{
    HKEY    hKey;
    DWORD   dwRes;
    DEBUG_FUNCTION_NAME(TEXT("SaveQueueState"));

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_WRITE );
    if (!hKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open key : %ld"),
            dwRes);
        return dwRes;
    }
    //
    // Set the fax queue value
    //
    if (!SetRegistryDword( hKey, REGVAL_QUEUE_STATE, dwNewState))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        RegCloseKey( hKey );
        return dwRes;
    }
    RegCloseKey( hKey );
    return ERROR_SUCCESS;
}   // SaveQueueState

DWORD
StoreReceiptsSettings (
    CONST PFAX_RECEIPTS_CONFIG pReceiptsConfig
)
/*++

Routine name : StoreReceiptsSettings

Routine description:

    Stores Receipts configuration in the registry.
    Create the Receipts subkey if not existent.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pReceiptsConfig         [in] - Receipts configuration to store

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hServerKey = NULL;
    HKEY hReceiptsKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("StoreReceiptsSettings"));

    hServerKey = OpenRegistryKey( HKEY_LOCAL_MACHINE,
                                  REGKEY_SOFTWARE,
                                  FALSE,
                                  KEY_WRITE );
    if (NULL == hServerKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open key : %ld"),
            dwRes);
        return dwRes;
    }
    dwRes = RegCreateKey (hServerKey, REGKEY_RECEIPTS_CONFIG, &hReceiptsKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't create or open key : %ld"),
            dwRes);
        goto exit;
    }

    if (!SetRegistryDword( hReceiptsKey, REGVAL_ISFOR_MSROUTE, pReceiptsConfig->bIsToUseForMSRouteThroughEmailMethod))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }

    if (!SetRegistryDword( hReceiptsKey, REGVAL_RECEIPTS_TYPE, pReceiptsConfig->dwAllowedReceipts))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }

    if(
        (pReceiptsConfig->dwAllowedReceipts & DRT_EMAIL)
       ||
        pReceiptsConfig->bIsToUseForMSRouteThroughEmailMethod
      )
    {
        if (!SetRegistryDword( hReceiptsKey, REGVAL_RECEIPTS_PORT, pReceiptsConfig->dwSMTPPort))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't write value : %ld"),
                dwRes);
            goto exit;
        }
        if (!SetRegistryDword( hReceiptsKey, REGVAL_RECEIPTS_SMTP_AUTH_TYPE, pReceiptsConfig->SMTPAuthOption))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't write value : %ld"),
                dwRes);
            goto exit;
        }
        if (!SetRegistryString( hReceiptsKey,
                                REGVAL_RECEIPTS_SERVER,
                                pReceiptsConfig->lptstrSMTPServer ?
                                    pReceiptsConfig->lptstrSMTPServer :
                                    EMPTY_STRING))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't write value : %ld"),
                dwRes);
            goto exit;
        }
        if (!SetRegistryString( hReceiptsKey,
                                REGVAL_RECEIPTS_FROM,
                                pReceiptsConfig->lptstrSMTPFrom ?
                                    pReceiptsConfig->lptstrSMTPFrom : EMPTY_STRING))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't write value : %ld"),
                dwRes);
            goto exit;
        }
        if (!SetRegistryString( hReceiptsKey,
                                REGVAL_RECEIPTS_USER,
                                pReceiptsConfig->lptstrSMTPUserName ?
                                    pReceiptsConfig->lptstrSMTPUserName : EMPTY_STRING))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Can't write value : %ld"),
                dwRes);
            goto exit;
        }
        if (pReceiptsConfig->lptstrSMTPPassword)
        {
            if (!SetRegistrySecureString(
                                    hReceiptsKey,
                                    REGVAL_RECEIPTS_PASSWORD,
                                    pReceiptsConfig->lptstrSMTPPassword ?
                                        pReceiptsConfig->lptstrSMTPPassword : EMPTY_STRING,
                                    TRUE // Optionally non-encrypted
                                    ))
            {
                dwRes = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Can't write value : %ld"),
                    dwRes);
                goto exit;
            }
        }
    }


    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hReceiptsKey)
    {
        RegCloseKey (hReceiptsKey);
    }
    if (NULL != hServerKey)
    {
        RegCloseKey (hServerKey);
    }
    return dwRes;
}   // StoreReceiptsSettings

DWORD
LoadReceiptsSettings (
    PFAX_SERVER_RECEIPTS_CONFIGW pReceiptsConfig
)
/*++

Routine name : LoadReceiptsSettings

Routine description:

    Reads Receipts configuration from the registry.
    Ovverride destination strings without freeing anything.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pReceiptsConfig         [out] - Receipts configuration to read

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hReceiptsKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("LoadReceiptsSettings"));

    hReceiptsKey = OpenRegistryKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_SOFTWARE TEXT("\\") REGKEY_RECEIPTS_CONFIG,
        FALSE,
        KEY_READ | KEY_WRITE );
    if (NULL == hReceiptsKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open key : %ld"),
            dwRes);
        return dwRes;
    }
    pReceiptsConfig->dwSMTPPort = GetRegistryDword (hReceiptsKey, REGVAL_RECEIPTS_PORT);
    if (0 == pReceiptsConfig->dwSMTPPort)
    {
        //
        // A zero port is invalid
        //
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SMTPPort invalid value read : %ld"),
            dwRes);
        goto exit;
    }
    pReceiptsConfig->bIsToUseForMSRouteThroughEmailMethod =
        GetRegistryDword (hReceiptsKey, REGVAL_ISFOR_MSROUTE);

    pReceiptsConfig->SMTPAuthOption =
        (FAX_ENUM_SMTP_AUTH_OPTIONS)GetRegistryDword (hReceiptsKey, REGVAL_RECEIPTS_SMTP_AUTH_TYPE);
    if ((FAX_SMTP_AUTH_ANONYMOUS > pReceiptsConfig->SMTPAuthOption) ||
        (FAX_SMTP_AUTH_NTLM < pReceiptsConfig->SMTPAuthOption))
    {
        //
        // Value out of range
        //
        dwRes = ERROR_BADDB;
        SetLastError (dwRes);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SMTPAuthOption value out of range"));
        goto exit;
    }
    pReceiptsConfig->dwAllowedReceipts =GetRegistryDword (hReceiptsKey, REGVAL_RECEIPTS_TYPE);
    if (pReceiptsConfig->dwAllowedReceipts & ~DRT_ALL)
    {
        //
        // Value out of range
        //
        dwRes = ERROR_BADDB;
        SetLastError (dwRes);
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AllowedReceipts value out of range"));
        goto exit;
    }
    pReceiptsConfig->lptstrSMTPServer = GetRegistryString (hReceiptsKey, REGVAL_RECEIPTS_SERVER, EMPTY_STRING);
    pReceiptsConfig->lptstrSMTPFrom = GetRegistryString (hReceiptsKey, REGVAL_RECEIPTS_FROM, EMPTY_STRING);
    pReceiptsConfig->lptstrSMTPPassword = NULL; // we do not hold the password in memory - we read it only when we need to
    pReceiptsConfig->lptstrSMTPUserName = GetRegistryString (hReceiptsKey, REGVAL_RECEIPTS_USER, EMPTY_STRING);
    pReceiptsConfig->lptstrReserved = NULL;

    if (TRUE == IsDesktopSKU())
    {
        //
        // We do not support SMTP receipts on desktop SKUs
        //
        pReceiptsConfig->dwAllowedReceipts &= ~DRT_EMAIL;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hReceiptsKey)
    {
        RegCloseKey (hReceiptsKey);
    }
    return dwRes;
}   // LoadReceiptsSettings

DWORD
StoreOutboxSettings (
    PFAX_OUTBOX_CONFIG pOutboxCfg
)
/*++

Routine name : StoreOutboxSettings

Routine description:

    Stores Outbox configuration to the registry.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pOutboxCfg          [in] - Outbox configuration to write

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("StoreOutboxSettings"));

    hKey = OpenRegistryKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_SOFTWARE,
        FALSE,
        KEY_WRITE );
    if (NULL == hKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open key : %ld"),
            dwRes);
        return dwRes;
    }
    if (!SetRegistryDword( hKey, REGVAL_RETRIES, pOutboxCfg->dwRetries ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't SetRegistryDword(REGVAL_RETRIES) : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_RETRYDELAY, pOutboxCfg->dwRetryDelay ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't SetRegistryDword(REGVAL_RETRYDELAY) : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_DIRTYDAYS, pOutboxCfg->dwAgeLimit ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't SetRegistryDword(REGVAL_DIRTYDAYS) : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_BRANDING, pOutboxCfg->bBranding ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't SetRegistryDword(REGVAL_BRANDING) : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_USE_DEVICE_TSID, pOutboxCfg->bUseDeviceTSID ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't SetRegistryDword(REGVAL_USE_DEVICE_TSID) : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_SERVERCP, !pOutboxCfg->bAllowPersonalCP ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't SetRegistryDword(REGVAL_SERVERCP) : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey,
                           REGVAL_STARTCHEAP,
                           MAKELONG(pOutboxCfg->dtDiscountStart.Hour,
                                    pOutboxCfg->dtDiscountStart.Minute) ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't SetRegistryDword(REGVAL_STARTCHEAP) : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey,
                           REGVAL_STOPCHEAP,
                           MAKELONG(pOutboxCfg->dtDiscountEnd.Hour,
                                    pOutboxCfg->dtDiscountEnd.Minute) ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't SetRegistryDword(REGVAL_STOPCHEAP) : %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hKey)
    {
        RegCloseKey (hKey);
    }
    return dwRes;

}   // StoreOutboxSettings

DWORD
LoadArchiveSettings (
    FAX_ENUM_MESSAGE_FOLDER Folder,
    PFAX_ARCHIVE_CONFIG     pCfg
)
/*++

Routine name : LoadArchiveSettings

Routine description:

    Reads archive configuration from the registry.
    Ovverride destination strings without freeing anything.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    Folder          [in ] - Archive folder type
    pCfg            [out] - Archive configuration to read

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("LoadArchiveSettings"));

    Assert (FAX_MESSAGE_FOLDER_INBOX == Folder ||
            FAX_MESSAGE_FOLDER_SENTITEMS == Folder);
    Assert (pCfg);

    hKey = OpenRegistryKey(
        HKEY_LOCAL_MACHINE,
        FAX_MESSAGE_FOLDER_INBOX == Folder ?
            REGKEY_SOFTWARE TEXT("\\") REGKEY_ARCHIVE_INBOX_CONFIG :
            REGKEY_SOFTWARE TEXT("\\") REGKEY_ARCHIVE_SENTITEMS_CONFIG,
        FALSE,
        KEY_READ | KEY_WRITE );
    if (NULL == hKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open key : %ld"),
            dwRes);
        return dwRes;
    }
    pCfg->dwSizeOfStruct = sizeof (FAX_ARCHIVE_CONFIG);
    pCfg->bUseArchive = GetRegistryDword (hKey, REGVAL_ARCHIVE_USE);
    pCfg->bSizeQuotaWarning = GetRegistryDword (hKey, REGVAL_ARCHIVE_SIZE_QUOTA_WARNING);
    pCfg->dwSizeQuotaHighWatermark = GetRegistryDword (hKey, REGVAL_ARCHIVE_HIGH_WATERMARK);
    pCfg->dwSizeQuotaLowWatermark = GetRegistryDword (hKey, REGVAL_ARCHIVE_LOW_WATERMARK);
    pCfg->dwAgeLimit = GetRegistryDword (hKey, REGVAL_ARCHIVE_AGE_LIMIT);
    if (pCfg->bUseArchive &&
        (pCfg->dwSizeQuotaHighWatermark < pCfg->dwSizeQuotaLowWatermark))
    {
        //
        // Invalid value
        //
        DebugPrintEx(DEBUG_ERR, TEXT("Invalid archive watermarks"));
        dwRes = ERROR_INVALID_DATA;
        goto exit;
    }

    pCfg->lpcstrFolder = GetRegistryString (hKey, REGVAL_ARCHIVE_FOLDER, BAD_FOLDER_STRING);
    if (pCfg->bUseArchive && !lstrcmp (BAD_FOLDER_STRING, pCfg->lpcstrFolder))
    {
        //
        // Invalid value
        //
        DebugPrintEx(DEBUG_ERR, TEXT("Invalid archive folder"));
        dwRes = ERROR_INVALID_DATA;
        MemFree (pCfg->lpcstrFolder);
        pCfg->lpcstrFolder = NULL;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hKey)
    {
        RegCloseKey (hKey);
    }
    return dwRes;
}   // LoadArchiveSettings

DWORD
StoreArchiveSettings (
    FAX_ENUM_MESSAGE_FOLDER Folder,
    PFAX_ARCHIVE_CONFIG     pCfg
)
/*++

Routine name : StoreArchiveSettings

Routine description:

    Writes archive configuration to the registry.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    Folder          [in] - Archive folder type
    pCfg            [in] - Archive configuration to write

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hServerKey = NULL;
    HKEY hKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("StoreArchiveSettings"));

    Assert (FAX_MESSAGE_FOLDER_INBOX == Folder ||
            FAX_MESSAGE_FOLDER_SENTITEMS == Folder);
    Assert (pCfg);

    hServerKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_WRITE );
    if (NULL == hServerKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open key : %ld"),
            dwRes);
        return dwRes;
    }
    dwRes = RegCreateKey (  hServerKey,
                            FAX_MESSAGE_FOLDER_INBOX == Folder ?
                                REGKEY_ARCHIVE_INBOX_CONFIG :
                                REGKEY_ARCHIVE_SENTITEMS_CONFIG,
                            &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't create or open key : %ld"),
            dwRes);
        goto exit;
    }

    if (!SetRegistryDword( hKey, REGVAL_ARCHIVE_USE, pCfg->bUseArchive))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_ARCHIVE_SIZE_QUOTA_WARNING, pCfg->bSizeQuotaWarning))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_ARCHIVE_HIGH_WATERMARK, pCfg->dwSizeQuotaHighWatermark))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_ARCHIVE_LOW_WATERMARK, pCfg->dwSizeQuotaLowWatermark))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_ARCHIVE_AGE_LIMIT, pCfg->dwAgeLimit))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryString( hKey,
                            REGVAL_ARCHIVE_FOLDER,
                            pCfg->lpcstrFolder ? pCfg->lpcstrFolder : EMPTY_STRING))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hKey)
    {
        RegCloseKey (hKey);
    }
    if (NULL != hServerKey)
    {
        RegCloseKey (hServerKey);
    }
    return dwRes;
}   // StoreArchiveSettings

DWORD
LoadActivityLoggingSettings (
    PFAX_SERVER_ACTIVITY_LOGGING_CONFIG pLogCfg
)
/*++

Routine name : LoadActivityLoggingSettings

Routine description:

    Reads activity logging configuration from the registry.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pLogCfg         [in] - Activity logging configuration to read

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("LoadActivityLoggingSettings"));

    Assert (pLogCfg);

    hKey = OpenRegistryKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_SOFTWARE TEXT("\\") REGKEY_ACTIVITY_LOG_CONFIG,
        FALSE,
        KEY_READ | KEY_WRITE );
    if (NULL == hKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open key : %ld"),
            dwRes);
        return dwRes;
    }
    pLogCfg->dwSizeOfStruct = sizeof (FAX_ACTIVITY_LOGGING_CONFIG);
    pLogCfg->bLogIncoming = GetRegistryDword (hKey, REGVAL_ACTIVITY_LOG_IN);
    pLogCfg->bLogOutgoing = GetRegistryDword (hKey, REGVAL_ACTIVITY_LOG_OUT);
    

    //
    //  read Activity log file limit criterions setting
    //
    //  Notice: This settings are not configurable through UI nor RPC calls. 
    //          The only way to configure them is through directly registry settings.
    //          Hence StoreActivityLoggingSettings() will not persist this settings back to the registry
    //
    pLogCfg->dwLogLimitCriteria     = GetRegistryDword (hKey, REGVAL_ACTIVITY_LOG_LIMIT_CRITERIA);
    pLogCfg->dwLogSizeLimit         = GetRegistryDword (hKey, REGVAL_ACTIVITY_LOG_SIZE_LIMIT);
    pLogCfg->dwLogAgeLimit          = GetRegistryDword (hKey, REGVAL_ACTIVITY_LOG_AGE_LIMIT);
    pLogCfg->dwLimitReachedAction   = GetRegistryDword (hKey, REGVAL_ACTIVITY_LOG_LIMIT_REACHED_ACTION);

    if ( 0 == pLogCfg->dwLogSizeLimit)
    {
        //
        //  Illegal value, set default value
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Illegal value in dwLogSizeLimit. Default value  of %ld Mbytes is used."),
            ACTIVITY_LOG_DEFAULT_SIZE_LIMIT);

        pLogCfg->dwLogSizeLimit = ACTIVITY_LOG_DEFAULT_SIZE_LIMIT;
    }

    if ( 0 == pLogCfg->dwLogAgeLimit )
    {
        //
        //  Illegal value, set default value
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Illegal value in dwLogAgeLimit. Default value  of %ld months is used."),
            ACTIVITY_LOG_DEFAULT_AGE_LIMIT);

        pLogCfg->dwLogAgeLimit = ACTIVITY_LOG_DEFAULT_AGE_LIMIT;
    }

    if ( ACTIVITY_LOG_LIMIT_CRITERIA_NONE   != pLogCfg->dwLogLimitCriteria &&
         ACTIVITY_LOG_LIMIT_CRITERIA_SIZE   != pLogCfg->dwLogLimitCriteria &&
         ACTIVITY_LOG_LIMIT_CRITERIA_AGE    != pLogCfg->dwLogLimitCriteria )
    {
        //
        //  Illegal value, set default value
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Illegal value in dwLogLimitCriteria. Default value (not using logging limit) - is used.")
            );

        pLogCfg->dwLogLimitCriteria = ACTIVITY_LOG_LIMIT_CRITERIA_NONE;

    }

    if ( ACTIVITY_LOG_LIMIT_REACHED_ACTION_COPY     != pLogCfg->dwLimitReachedAction &&
         ACTIVITY_LOG_LIMIT_REACHED_ACTION_DELETE   != pLogCfg->dwLimitReachedAction )
    {
        //
        //  Illegal value, set default value
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Illegal value in dwLogLimitCriteria. Default value (copy log file) is used.")
            );

        pLogCfg->dwLimitReachedAction = ACTIVITY_LOG_LIMIT_REACHED_ACTION_COPY;

    }

    if (pLogCfg->bLogIncoming || pLogCfg->bLogOutgoing)
    {
        pLogCfg->lptstrDBPath = GetRegistryString (hKey, REGVAL_ACTIVITY_LOG_DB, BAD_FOLDER_STRING);
    }
    else
    {
        //
        // No logging => DB path is NULL
        //
        pLogCfg->lptstrDBPath = NULL;
    }
    if ((pLogCfg->bLogIncoming || pLogCfg->bLogOutgoing) &&
        !lstrcmp (BAD_FOLDER_STRING, pLogCfg->lptstrDBPath))
    {
        //
        // Invalid value
        //
        DebugPrintEx(DEBUG_ERR, TEXT("Invalid activity logging database"));
        dwRes = ERROR_INVALID_DATA;
        MemFree (pLogCfg->lptstrDBPath);
        pLogCfg->lptstrDBPath = NULL;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hKey)
    {
        RegCloseKey (hKey);
    }
    return dwRes;
}   // LoadActivityLoggingSettings


DWORD
StoreActivityLoggingSettings (
    PFAX_ACTIVITY_LOGGING_CONFIG pLogCfg
)
/*++

Routine name : StoreActivityLoggingSettings

Routine description:

    Writes activity logging configuration to the registry.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pLogCfg         [in] - Activity logging configuration to write

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hServerKey = NULL;
    HKEY hKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("StoreActivityLoggingSettings"));

    Assert (pLogCfg);

    hServerKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_WRITE );
    if (NULL == hServerKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open key : %ld"),
            dwRes);
        return dwRes;
    }
    dwRes = RegCreateKey (  hServerKey,
                            REGKEY_ACTIVITY_LOG_CONFIG,
                            &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't create or open key : %ld"),
            dwRes);
        goto exit;
    }

    if (!SetRegistryDword( hKey, REGVAL_ACTIVITY_LOG_IN, pLogCfg->bLogIncoming))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_ACTIVITY_LOG_OUT, pLogCfg->bLogOutgoing))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryString( hKey,
                            REGVAL_ACTIVITY_LOG_DB,
                            pLogCfg->lptstrDBPath ? pLogCfg->lptstrDBPath : EMPTY_STRING))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hKey)
    {
        RegCloseKey (hKey);
    }
    if (NULL != hServerKey)
    {
        RegCloseKey (hServerKey);
    }
    return dwRes;
}   // StoreActivityLoggingSettings


DWORD
StoreDeviceConfig (
    DWORD dwDeviceId,
    PFAX_PORT_INFO_EX pPortInfo,
    BOOL              bVirtualDevice
)
/*++

Routine name : StoreDeviceConfig

Routine description:

    Writes device configuration to the registry.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId  [in] - Device identifier
    pPortInfo   [in] - Configuration bloack to write.
                       Writes: Enable send flag
                               Enable receive flag
                               Rings for answer count
                               CSID
                               TSID
                               Description
    bVirtualDevice [in] - Should we set FPF_VIRTUAL ?

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    HKEY hKey = NULL;
    TCHAR wszSubKeyName[MAX_PATH];
    DWORD dwFlags = 0;
    DEBUG_FUNCTION_NAME(TEXT("StoreDeviceConfig"));

    Assert (pPortInfo);

    _stprintf( wszSubKeyName, TEXT("%s\\%010d\\%s"), REGKEY_FAX_DEVICES, dwDeviceId, REGKEY_FAXSVC_DEVICE_GUID );

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, wszSubKeyName, FALSE, KEY_WRITE );
    if (NULL == hKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open device key : %ld"),
            dwRes);
        ASSERT_FALSE;   // The device must exist !!!
        return dwRes;
    }

    if (bVirtualDevice)
    {
        dwFlags |= FPF_VIRTUAL;
    }
    if (FAX_DEVICE_RECEIVE_MODE_AUTO == pPortInfo->ReceiveMode)
    {
        dwFlags |= FPF_RECEIVE;
    }
    if (pPortInfo->bSend)
    {
        dwFlags |= FPF_SEND;
    }
    if (!SetRegistryDword( hKey, REGVAL_FLAGS, dwFlags))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword( hKey, REGVAL_RINGS, pPortInfo->dwRings))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryString( hKey, REGVAL_ROUTING_CSID, pPortInfo->lptstrCsid))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryString( hKey, REGVAL_ROUTING_TSID, pPortInfo->lptstrTsid))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryString( hKey, REGVAL_DEVICE_DESCRIPTION, pPortInfo->lptstrDescription))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't write value : %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (NULL != hKey)
    {
        RegCloseKey (hKey);
    }
    return dwRes;
}   // StoreDeviceConfig

static
DWORD
OpenExtensionKey (
    DWORD                       dwDeviceId,
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,
    PHKEY                       lphKey
)
/*++

Routine name : OpenExtensionKey

Routine description:

    Opens the extension's configuration key according to the device id

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId      [in ] - Device identifier
    DevIdSrc        [in ] - Class of device id (Fax / TAPI)
    lphKey          [out] - Registry handle to open key

Return Value:

    Standard Win32 error code

--*/
{
    DWORD   dwRes = ERROR_SUCCESS;
    TCHAR   wszSubKeyName[MAX_PATH];
    DEBUG_FUNCTION_NAME(TEXT("OpenExtensionKey"));

    Assert (lphKey);

    if (0 == dwDeviceId)
    {
        //
        // Non-associated data is always written under the fax devices key
        //
        DevIdSrc = DEV_ID_SRC_FAX;
    }
    switch (DevIdSrc)
    {
        case DEV_ID_SRC_FAX:
            if (!dwDeviceId)
            {
                //
                // We're dealing with an unassociated device here
                //
                _stprintf(  wszSubKeyName,
                            TEXT("%s\\%s"),
                            REGKEY_FAX_DEVICES,
                            REGKEY_UNASSOC_EXTENSION_DATA );
            }
            else
            {
                //
                // Extension data associated with a device , saved under service GUID !!!
                //
                _stprintf( wszSubKeyName, TEXT("%s\\%010d\\%s"), REGKEY_FAX_DEVICES, dwDeviceId, REGKEY_FAXSVC_DEVICE_GUID );
            }
            break;

        case DEV_ID_SRC_TAPI:
            Assert (dwDeviceId);
            {
                //
                // Make sure the key of TAPI devices configuration exists - create if needed.
                //
                HKEY hkeyTAPIConfig = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                                                       REGKEY_TAPIDEVICES,
                                                       TRUE,
                                                       KEY_READ);
                if (NULL == hkeyTAPIConfig)
                {
                    dwRes = GetLastError ();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("Can't open / create TAPI devices configuration key : %ld"),
                        dwRes);
                    return dwRes;
                }
                RegCloseKey (hkeyTAPIConfig);
            }
            _stprintf( wszSubKeyName, TEXT("%s\\%08lx"), REGKEY_TAPIDEVICES, dwDeviceId );
            break;

        default:
            ASSERT_FALSE;
            return ERROR_GEN_FAILURE;
    }
    //
    // Try to open device key (create if needed)
    //
    *lphKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, wszSubKeyName, TRUE, KEY_READ | KEY_WRITE );
    if (NULL == *lphKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open device (%ld) key : %ld"),
            dwDeviceId,
            dwRes);
    }
    return dwRes;
}   // OpenExtensionKey

DWORD
ReadExtensionData (
    DWORD                        dwDeviceId,
    FAX_ENUM_DEVICE_ID_SOURCE    DevIdSrc,
    LPCWSTR                      lpcwstrNameGUID,
    LPBYTE                      *ppData,
    LPDWORD                      lpdwDataSize
)
/*++

Routine name : ReadExtensionData

Routine description:

    Reads extesnion configuration data from the registry

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId      [in ]   - Device identifier
                                0 = Data is not associated with any given device
    DevIdSrc        [in ]   - Class of device id (Fax / TAPI)
    lpcwstrNameGUID [in ]   - Name of data (GUID format)
    ppData          [out]   - Pointer to block that receives the data.
    lpdwDataSize    [out]   - Points to data size

Return Value:

    Standard Win32 error code

--*/
{
    DWORD   dwRes = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("ReadExtensionData"));

    Assert (ppData);
    Assert (lpdwDataSize);

    dwRes = OpenExtensionKey (dwDeviceId, DevIdSrc, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    dwRes = GetRegistrySecureBinary(hKey,
                                    lpcwstrNameGUID,
                                    ppData,
                                    lpdwDataSize,
                                    TRUE, // Optionally non-ecrypted
									NULL  // Dont care if the data was decrypted or not
                                    );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetRegistrySecureBinary on device %ld and GUID %s failed with %ld"),
            dwDeviceId,
            lpcwstrNameGUID,
            dwRes);
        goto exit;
    }
    //
    // Success
    //
    Assert (ERROR_SUCCESS == dwRes);

exit:

    if (hKey)
    {
        RegCloseKey (hKey);
    }
    return dwRes;
}   // ReadExtensionData

DWORD
WriteExtensionData (
    DWORD                       dwDeviceId,
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,
    LPCWSTR                     lpcwstrNameGUID,
    LPBYTE                      pData,
    DWORD                       dwDataSize
)
/*++

Routine name : WriteExtensionData

Routine description:

    Writes extesnion configuration data to the registry

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId      [in ]   - Device identifier
                                0 = Data is not associated with any given device
    DevIdSrc        [in ]   - Class of device id (Fax / TAPI)
    lpcwstrNameGUID [in ]   - Name of data (GUID format)
    pData           [out]   - Pointer to data.
    dwDataSize      [out]   - Data size

Return Value:

    Standard Win32 error code

--*/
{
    DWORD   dwRes = ERROR_SUCCESS;
    HKEY    hKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("WriteExtensionData"));

    Assert (pData);
    Assert (dwDataSize);

    dwRes = OpenExtensionKey (dwDeviceId, DevIdSrc, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        return dwRes;
    }
    //
    // Write data
    //
    if (!SetRegistrySecureBinary (hKey,
                                  lpcwstrNameGUID,
                                  pData,
                                  dwDataSize,
                                  TRUE // Optionally non-ecrypted
                                  ))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SetRegistrySecureBinary on device %ld and GUID %s failed with %ld"),
            dwDeviceId,
            lpcwstrNameGUID,
            dwRes);
    }
    RegCloseKey (hKey);
    return dwRes;
}   // WriteExtensionData


//********************************************
//*            Outbound routing
//********************************************

HKEY
OpenOutboundGroupKey (
    LPCWSTR lpcwstrGroupName,
    BOOL fNewKey,
    REGSAM SamDesired
    )
/*++

Routine name : OpenOutboundGroupKey

Routine description:

    Opens an outbound routing group key

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    lpcwstrGroupName    [in] - The outbound routing group name
    fNewKey             [in] - Flag that indicates to create a new key
    SamDesired          [in] - Desired access (See OpenRegistryKey)

Return Value:

    Handle to the opened key. If this is NULL call GetLastError() for more info.

--*/
{
    HKEY    hGroupkey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("OpenOutboundGroupKey"));
	WCHAR wszSubKeyName[2*MAX_PATH] = {0};
    int Count;

    Assert (lpcwstrGroupName);

    Count = _snwprintf ( wszSubKeyName,
                         ARR_SIZE(wszSubKeyName) - 1,
                         TEXT("%s\\%s"),
                         REGKEY_FAX_OUTBOUND_ROUTING_GROUPS,
                         lpcwstrGroupName );
    if (Count < 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("File Name exceded MAX_PATH"));
        SetLastError (ERROR_BUFFER_OVERFLOW);
        return NULL;
    }

    hGroupkey = OpenRegistryKey( HKEY_LOCAL_MACHINE, wszSubKeyName, fNewKey, SamDesired );
    if (NULL == hGroupkey)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't create group key, OpenRegistryKey failed  : %ld"),
            GetLastError());
    }
    return hGroupkey;

}  //OpenOutboundGroupKey


HKEY
OpenOutboundRuleKey (
    DWORD dwCountryCode,
    DWORD dwAreaCode,
    BOOL fNewKey,
    REGSAM SamDesired
    )
/*++

Routine name : OpenOutboundRuleKey

Routine description:

    Opens an outbound routing group key

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwCountryCode       [in] - The outbound routing rule country code
    dwAreaCode          [in] - The outbound routing rule area code
    fNewKey             [in] - Flag that indicates to create a new key
    SamDesired          [in] - Desired access (See OpenRegistryKey)

Return Value:

    Handle to the opened key. If this is NULL call GetLastError() for more info.

--*/
{
    HKEY    hRulekey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("OpenOutboundRuleKey"));
	WCHAR wszSubKeyName[2*MAX_PATH] = {0};
    int Count;


    Count = _snwprintf ( wszSubKeyName,
                         ARR_SIZE(wszSubKeyName) - 1,
                         TEXT("%s\\%ld:%ld"),
                         REGKEY_FAX_OUTBOUND_ROUTING_RULES,
                         dwCountryCode,
                         dwAreaCode );

    if (Count < 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("File Name exceded MAX_PATH"));
        SetLastError (ERROR_BUFFER_OVERFLOW);
        return NULL;
    }

    hRulekey = OpenRegistryKey( HKEY_LOCAL_MACHINE, wszSubKeyName, fNewKey, SamDesired );
    if (NULL == hRulekey)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't create rule key, OpenRegistryKey failed  : %ld"),
            GetLastError());
    }
    return hRulekey;
} //  OpenOutboundRuleKey



DWORD
DeleteOutboundRuleKey (DWORD dwCountryCode, DWORD dwAreaCode)
/*++

Routine name : DeleteOutboundRuleKey

Routine description:

    Deletes an existing outbound routing rule key

Author:

    Oded Sacher (OdedS),    Dec, 1999

Arguments:

    dwCountryCode           [in    ] - The rule's country code
    dwAreaCode          [in    ] - The rule's area code

Return Value:

    Standard Win32 error code

--*/
{
    HKEY    hRulekey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("DeleteOutboundRuleKey"));
    WCHAR wszSubKeyName[MAX_PATH];
    DWORD dwRes = ERROR_SUCCESS;
    int iCount;

    iCount = _snwprintf ( wszSubKeyName,
                           MAX_PATH - 1,
                           TEXT("%ld:%ld"),
                           dwCountryCode,
                           dwAreaCode );

    if (iCount < 0)
    {
        DebugPrintEx(DEBUG_ERR, TEXT("File Name exceded MAX_PATH"));
        return ERROR_BUFFER_OVERFLOW;
    }

    hRulekey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAX_OUTBOUND_ROUTING_RULES, FALSE, DELETE );
    if (NULL == hRulekey)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Can't open rule key, OpenRegistryKey failed  : %ld"),
            dwRes);
        return dwRes;
    }

    dwRes = RegDeleteKey (hRulekey, wszSubKeyName);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RegDeleteKey failed, error %ld"),
            dwRes);
    }

    RegCloseKey (hRulekey);
    return dwRes;

} //   DeleteOutboundRuleKey




DWORD
AddNewProviderToRegistry (
    LPCWSTR      lpctstrGUID,
    LPCWSTR      lpctstrFriendlyName,
    LPCWSTR      lpctstrImageName,
    LPCWSTR      lpctstrTspName,
    DWORD        dwFSPIVersion    
)
/*++

Routine name : AddNewProviderToRegistry

Routine description:

    Adds a new FSP entry to the registry

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpctstrGUID         [in] - GUID of FSP
    lpctstrFriendlyName [in] - Friendly name of FSP
    lpctstrImageName    [in] - Image name of FSP. May contain environment variables
    lpctstrTspName      [in] - TSP name of FSP.
    dwFSPIVersion       [in] - FSP's API version.    

Return Value:

    Standard Win32 error code

--*/
{
    HKEY   hKey = NULL;
    HKEY   hProviderKey = NULL;    
    DWORD  dwRes;
    DWORD  dw;
    DEBUG_FUNCTION_NAME(TEXT("AddNewProviderToRegistry"));

    //
    // Open providers key
    //
    dwRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, REGKEY_DEVICE_PROVIDER_KEY, 0, KEY_WRITE, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening providers key (ec = %ld)"),
            dwRes);
        return dwRes;
    }
    //
    // Create key for provider
    //
    dwRes = RegCreateKey (hKey, lpctstrGUID, &hProviderKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error creating provider key (%s) (ec = %ld)"),
            lpctstrFriendlyName,
            dwRes);
        goto exit;
    }
    //
    // Write provider's data into the key
    //
    if (!SetRegistryString (hProviderKey, REGVAL_FRIENDLY_NAME, lpctstrFriendlyName))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing string value (ec = %ld)"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryStringExpand (hProviderKey, REGVAL_IMAGE_NAME, lpctstrImageName))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing auto-expand string value (ec = %ld)"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryString (hProviderKey, REGVAL_PROVIDER_NAME, lpctstrTspName))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing string value (ec = %ld)"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryString (hProviderKey, REGVAL_PROVIDER_GUID, lpctstrGUID))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing string value (ec = %ld)"),
            dwRes);
        goto exit;
    }
    if (!SetRegistryDword (hProviderKey, REGVAL_PROVIDER_API_VERSION, dwFSPIVersion))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error writing DWORD value (ec = %ld)"),
            dwRes);
        goto exit;
    }    
    
    DebugPrintEx(
        DEBUG_MSG,
        TEXT("Provider %s successfuly added."),
        lpctstrFriendlyName);


    Assert (ERROR_SUCCESS == dwRes);

exit:

    if (ERROR_SUCCESS != dwRes && hKey)
    {
        //
        // Try to remove half-cooked key
        //
        dw = RegDeleteKey (hKey, lpctstrGUID);
        if (ERROR_SUCCESS != dw)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error deleting provider's key (ec = %ld)"),
                dw);
        }
    }
    if (hKey)
    {
        dw = RegCloseKey (hKey);
        if (ERROR_SUCCESS != dw)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error closing providers key (ec = %ld)"),
                dw);
        }
    }
    if (hProviderKey)
    {
        dw = RegCloseKey (hProviderKey);
        if (ERROR_SUCCESS != dw)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error closing provider's key (ec = %ld)"),
                dw);
        }
    }
    return dwRes;
}   // AddNewProviderToRegistry

DWORD
RemoveProviderFromRegistry (
    LPCWSTR      lpctstrGUID
)
/*++

Routine name : RemoveProviderFromRegistry

Routine description:

    Removes an existing FSP entry from the registry

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpctstrGUID [in] - GUID of FSP

Return Value:

    Standard Win32 error code

--*/
{
    HKEY   hKey = NULL;
    DWORD  dwRes;
    DWORD  dw;
    DEBUG_FUNCTION_NAME(TEXT("RemoveProviderFromRegistry"));

    dwRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, REGKEY_DEVICE_PROVIDER_KEY,0, DELETE, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening providers key (ec = %ld)"),
            dwRes);
        return dwRes;
    }
    dwRes = RegDeleteKey (hKey, lpctstrGUID);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error deleting provider key ( %s ) (ec = %ld)"),
            lpctstrGUID,
            dwRes);
    }
    dw = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dw)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing providers key (ec = %ld)"),
            dw);
    }
    return dwRes;
}   // RemoveProviderFromRegistry

DWORD
WriteManualAnswerDeviceId (
    DWORD dwDeviceId
)
/*++

Routine name : WriteManualAnswerDeviceId

Routine description:

    Write the manual-answer device id to the registry

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    dwDeviceId [in] - Device id (0 = None)

Return Value:

    Standard Win32 error code

--*/
{
    HKEY  hKey = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("WriteManualAnswerDeviceId"));

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_WRITE );
    if (!hKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening server key (ec = %ld)"),
            dwRes);
        return dwRes;
    }
    if (!SetRegistryDword (hKey, REGVAL_MANUAL_ANSWER_DEVICE, dwDeviceId))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error setting registry value (ec = %ld)"),
            dwRes);
    }
    dwRes = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing providers key (ec = %ld)"),
            dwRes);
    }
    return dwRes;
}   // WriteManualAnswerDeviceId

DWORD
ReadManualAnswerDeviceId (
    LPDWORD lpdwDeviceId
)
/*++

Routine name : ReadManualAnswerDeviceId

Routine description:

    Read the manual-answer device id from the registry

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    lpdwDeviceId [out] - Device id (0 = None)

Return Value:

    Standard Win32 error code

--*/
{
    HKEY  hKey = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("ReadManualAnswerDeviceId"));

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_SOFTWARE, FALSE, KEY_READ );
    if (!hKey)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening server key (ec = %ld)"),
            dwRes);
        return dwRes;
    }
    *lpdwDeviceId = GetRegistryDword (hKey, REGVAL_MANUAL_ANSWER_DEVICE);
    dwRes = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing providers key (ec = %ld)"),
            dwRes);
    }
    return dwRes;
}   // ReadManualAnswerDeviceId


DWORD
FaxCopyRegSubkeys(
    LPCTSTR strDestSubKeyName,
    HKEY    hKeySrcHive,
    LPCTSTR strSrcSubKeyName
    )
/*++

Routine name : FaxCopyRegSubkeys


Routine description:

    Copy a content of one registry key into another
    using shell function SHCopyKey

    Caller must supply the source key handle *AND* a subkey whose subkeys and values are to be copied
Author:

    Caliv Nir (t-nicali), Mar, 2002

Arguments:

    strDestSubKeyName      [in]    - Destination registry key name
    strSrcSubKeyName       [in]    - Source registry key name
    hKeySrcHive            [in]    - Handle to the source key (for example, HKEY_LOCAL_MACHINE).  

Return Value:

    ERROR_SUCCESS - on succesful move

    win32 error code on failure

--*/
{
    DWORD   dwRet = ERROR_SUCCESS;
    HKEY    hKeyDest = NULL;

    DEBUG_FUNCTION_NAME(TEXT("FaxCopyRegSubkeys"));

    //
    //  Create destination Key
    //
    hKeyDest = OpenRegistryKey( 
                    HKEY_LOCAL_MACHINE, 
                    strDestSubKeyName, 
                    TRUE,                  // create
                    KEY_WRITE);
    if (!hKeyDest)
    {
        dwRet = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed [%lu], Can't copy keys."),
            dwRet
            );  
        goto exit;
    }

    //
    //  copy subkeys recursively
    //
    dwRet = SHCopyKey(
                hKeySrcHive,
                strSrcSubKeyName,
                hKeyDest,
                0);
    if ( ERROR_SUCCESS != dwRet )
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("SHCopyKey failed with [%ld]"),
                dwRet);
        goto exit;
    }

    Assert(ERROR_SUCCESS == dwRet);

exit:

    if (NULL != hKeyDest)
    {
        if(ERROR_SUCCESS != RegCloseKey(hKeyDest))
        {
            DebugPrintEx(DEBUG_ERR, 
                         TEXT("RegCloseKey failed (ec=%iu)"),
                         GetLastError());
        }
    }

    return dwRet;
} // FaxCopyRegSubkeys

/*++

Routine name : MoveDeviceRegIntoDeviceCache


Routine description:

    Move device's service and TAPI data into device cache

Author:

    Caliv Nir (t-nicali), Apr, 2001

Arguments:

    dwServerPermanentID         [in]    - service device ID
    dwTapiPermanentLineID       [in]    - tapi devive ID
    fManualAnswer               [in]    - TRUE if the device was set to manual answer


Return Value:

    ERROR_SUCCESS - on succesful move

    win32 error code on failure

--*/
DWORD
MoveDeviceRegIntoDeviceCache(
    DWORD dwServerPermanentID,
    DWORD dwTapiPermanentLineID,
    BOOL  fManualAnswer
)
{
    DWORD   ec = ERROR_SUCCESS; // LastError for this function.
    HKEY    hKey = NULL;
    TCHAR strSrcSubKeyName [MAX_PATH];
    TCHAR strDestSubKeyName[MAX_PATH];

    DWORDLONG dwlTimeNow;

    DEBUG_FUNCTION_NAME(TEXT("MoveDeviceRegIntoDeviceCache"));

    //
    //  open/create - "fax\Device Cache\GUID" Registry Key
    //  and create new key for the device using the dwTapiPermanentLineID as a key
    //  server data is stored under service GUID
    //
    _stprintf( strDestSubKeyName, TEXT("%s\\%08lx\\%s"), REGKEY_FAX_DEVICES_CACHE, dwTapiPermanentLineID, REGKEY_FAXSVC_DEVICE_GUID );

    //
    //  open - "fax\Devices" Registry Key
    //
    _stprintf( strSrcSubKeyName, TEXT("%s\\%010lu\\%s"), REGKEY_FAX_DEVICES, dwServerPermanentID, REGKEY_FAXSVC_DEVICE_GUID );

    ec = FaxCopyRegSubkeys(strDestSubKeyName,HKEY_LOCAL_MACHINE,strSrcSubKeyName);
    if ( ERROR_SUCCESS != ec )
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxCopyRegSubkeys of service data failed with [%ld] for tapi ID [%lu]. abort movement"),
                ec,
                dwTapiPermanentLineID
                );
        return ec;
    }

    //
    // If the device was a manual answer device, set it in the registry
    // open - "fax\Device Cache\dwTapiPermanentLineID" Registry Key
    //
    _stprintf( strDestSubKeyName, TEXT("%s\\%08lx"), REGKEY_FAX_DEVICES_CACHE, dwTapiPermanentLineID);
    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, strDestSubKeyName, FALSE, KEY_WRITE );
    if (hKey)
    {
        SetRegistryDword( hKey, REGVAL_MANUAL_ANSWER, fManualAnswer );
        RegCloseKey(hKey);
    }
    else
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("OpenRegistryKey failed with [%lu] for [%s]."),
                      GetLastError(),
                      strDestSubKeyName);
    }

    ec = DeleteDeviceEntry(dwServerPermanentID);
    if ( ERROR_SUCCESS != ec )
    {
        DebugPrintEx(
                DEBUG_WRN,
                TEXT("DeleteDeviceEntry of service data failed with [%ld] for tapi ID [%lu]. continue movement"),
                ec,
                dwTapiPermanentLineID
                );
    }

    //
    //  open/create - "fax\Device Cache\TAPI Data" Registry Key
    //  and create new key for the device using the dwTapiPermanentLineID as a key
    //
    _stprintf( strDestSubKeyName, TEXT("%s\\%08lx\\%s"), REGKEY_FAX_DEVICES_CACHE, dwTapiPermanentLineID, REGKEY_TAPI_DATA );

    //
    //  open - "fax\TAPIDevices" Registry Key
    //
    _stprintf( strSrcSubKeyName, TEXT("%s\\%08lx"), REGKEY_TAPIDEVICES, dwTapiPermanentLineID );

    ec = FaxCopyRegSubkeys(strDestSubKeyName,HKEY_LOCAL_MACHINE,strSrcSubKeyName);
    if ( ERROR_SUCCESS != ec )
    {
        DebugPrintEx(
                DEBUG_WRN,
                TEXT("FaxCopyRegSubkeys of TAPI data failed with [%ld] for tapi ID [%lu]."),
                ec,
                dwTapiPermanentLineID
                );
    }


    ec = DeleteTapiEntry(dwTapiPermanentLineID);

    if ( ERROR_SUCCESS != ec )
    {
        DebugPrintEx(
                DEBUG_WRN,
                TEXT("DeleteTapiEntry of service data failed with [%ld] for tapi ID [%lu]."),
                ec,
                dwTapiPermanentLineID
                );
    }

    //
    //  Mark cache entry creation time
    //
    GetSystemTimeAsFileTime((FILETIME *)&dwlTimeNow);

    if ( FALSE == UpdateLastDetectedTime(dwTapiPermanentLineID,dwlTimeNow) )
    {
        // the entry will be delete in the next service startup
        DebugPrintEx(
                DEBUG_WRN,
                TEXT("UpdateLastDetectedTime failed for device cache ID no. [%lu]."),
                dwTapiPermanentLineID
                );
    }

    // service device data has been moved
    return ERROR_SUCCESS;
}



/*++

Routine name : RestoreDeviceRegFromDeviceCache


Routine description:

    restore a device data from device cache, into devices

Author:

    Caliv Nir (t-nicali), Apr, 2001

Arguments:

    dwServerPermanentID         [in]    - service device ID
    dwTapiPermanentLineID       [in]    - tapi devive ID


Return Value:

    ERROR_SUCCESS - on succesful move

    win32 error code on failure

--*/
DWORD
RestoreDeviceRegFromDeviceCache(DWORD dwServerPermanentID,DWORD dwTapiPermanentLineID)
{
    DWORD   ec = ERROR_SUCCESS; // LastError for this function.

    HKEY    hKey = NULL;
    HKEY    hKeySrc = NULL;
    TCHAR   strSrcSubKeyName [MAX_PATH];
    TCHAR   strDestSubKeyName[MAX_PATH];
    BOOL    fFaxDevicesKeyCreated = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("RestoreDeviceRegFromDeviceCache"));

    //
    //  Restore Service date
    //

    //
    //  "fax\Device Cache\dwTapiPermanentLineID\REGKEY_FAXSVC_DEVICE_GUID" Registry Key
    //
    _stprintf( strSrcSubKeyName, TEXT("%s\\%08lx\\%s"), REGKEY_FAX_DEVICES_CACHE, dwTapiPermanentLineID, REGKEY_FAXSVC_DEVICE_GUID );

    //
    //  "fax\Devices\dwServerPermanentID\REGKEY_FAXSVC_DEVICE_GUID" Registry Key
    //
    _stprintf( strDestSubKeyName, TEXT("%s\\%010lu\\%s"), REGKEY_FAX_DEVICES, dwServerPermanentID, REGKEY_FAXSVC_DEVICE_GUID );

    ec = FaxCopyRegSubkeys(strDestSubKeyName,HKEY_LOCAL_MACHINE,strSrcSubKeyName);
    if ( ERROR_SUCCESS != ec )
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxCopyRegSubkeys of service data failed with [%lu] for tapi ID [%lu]. abort movement"),
                ec,
                dwTapiPermanentLineID
                );
        goto Exit;
    }
    fFaxDevicesKeyCreated = TRUE;

    //
    //  open - "fax\Devices\dwServerPermanentID" Registry Key
    //
    _stprintf( strSrcSubKeyName, TEXT("%s\\%010lu"), REGKEY_FAX_DEVICES, dwServerPermanentID);

    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, strSrcSubKeyName, FALSE, KEY_WRITE);
    if (!hKey)
    {
        ec = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey failed with [%lu] for [%s]. abort movement"),
                ec,
                strSrcSubKeyName
                );
        goto Exit;

    }

    //
    //  store "Permanent Lineid" value
    //
    if ( FALSE == SetRegistryDword(hKey, REGVAL_PERMANENT_LINEID, dwServerPermanentID) )
    {
        ec = GetLastError();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetRegistryDword failed for [%s]. abort movement"),
                REGVAL_PERMANENT_LINEID
                );
        goto Exit;
    }

    //
    //  Restore TAPI data
    //

    //
    //  open - "fax\Device Cache\dwTapiPermanentLineID\TAPI Data" Registry Key
    //
    _stprintf( strSrcSubKeyName, TEXT("%s\\%08lx\\%s"), REGKEY_FAX_DEVICES_CACHE, dwTapiPermanentLineID, REGKEY_TAPI_DATA );

    //
    //  open/create - "fax\TAPIDevices\dwTapiPermanentLineID" Registry Key
    //
    _stprintf( strDestSubKeyName, TEXT("%s\\%08lx"), REGKEY_TAPIDEVICES, dwTapiPermanentLineID );

    //
    // See if fax\Device Cache\dwTapiPermanentLineID\TAPI Data exists
    //
    hKeySrc = OpenRegistryKey( HKEY_LOCAL_MACHINE, strSrcSubKeyName, FALSE, KEY_READ );
    if (!hKeySrc)
    {
        //
        // This data does not have to be there
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("OpenRegistryKey failed with [%lu], Can't copy keys."),
            GetLastError());
    }
    else
    {
        //
        // fax\Device Cache\dwTapiPermanentLineID\TAPI Data exists, try to copy data
        //
        RegCloseKey(hKeySrc);
        ec = FaxCopyRegSubkeys(strDestSubKeyName,HKEY_LOCAL_MACHINE, strSrcSubKeyName);
        if ( ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("FaxCopyRegSubkeys of TAPI data failed with [%lu] for tapi ID [%lu]."),
                    ec,
                    dwTapiPermanentLineID
                    );
            goto Exit;
        }
    }

    Assert (ERROR_SUCCESS == ec);

Exit:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    if (ERROR_SUCCESS != ec &&
        TRUE == fFaxDevicesKeyCreated)
    {
        //
        // Delete the registry entry  fax\Devices\dwServerPermanentID
        //
        DWORD dwRes = DeleteDeviceEntry(dwServerPermanentID);
        if (ERROR_SUCCESS != dwRes)
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteDeviceEntry failed with [%lu] for server ID [%lu]."),
                dwRes,
                dwServerPermanentID
                );
        }
    }
    DeleteCacheEntry(dwTapiPermanentLineID);
    return ec;
}




/*++

Routine name : FindServiceDeviceByTapiPermanentLineID

Routine description:

    Search for a device configuration in the registry with a given "Tapi Permanent Line ID"
    and the device's name. and return it's service ID and REG_SETUP data

Author:

    Caliv Nir (t-nicali), Mar, 2001

Updated:

    Apr, 2001   - Device cache re-implementation


Arguments:

    dwTapiPermanentLineID       [in]  - Tapi Permanent Line ID to search
    strDeviceName               [in]  - Device name
    pRegSetup                   [out] - Parameter, for returning registry stored Csid, Tsid, Flags, Rings
    pInputFaxReg                [in]  - Devices list (from GetFaxDevicesRegistry() )


Return Value:

    Permanent Line ID (server's ID) or 0 if not found

--*/
DWORD
FindServiceDeviceByTapiPermanentLineID(
    DWORD                   dwTapiPermanentLineID,
    LPCTSTR                 strDeviceName,
    PREG_SETUP              pRegSetup,
    const PREG_FAX_DEVICES  pInputFaxReg
    )
{
    DWORD dwDevice;
    DWORD dwServiceID = 0;

    DEBUG_FUNCTION_NAME(TEXT("FindServiceDeviceByTapiPermanentLineID"));

    Assert( pRegSetup );
    Assert( pInputFaxReg );


    // iterate through all devices and try to find the device with the given TapiPermanentLineID and name
    for ( dwDevice = 0 ; dwDevice < pInputFaxReg->DeviceCount ; ++dwDevice )
    {
        PREG_DEVICE pRegDevice = &(pInputFaxReg->Devices[dwDevice]);

        if(!pRegDevice->bValidDevice)
        {
            // the device's registry record is not valid
            continue;
        }

        // it's the same device if permanent Tapi line ID and the device name are equal.
        if  ( pRegDevice->TapiPermanentLineID == dwTapiPermanentLineID &&
              (0 == _tcscmp(strDeviceName,pRegDevice->lptstrDeviceName))   )
        {
            // update REG_SETUP record with the registry values
            LPTSTR strTemp = NULL;
            if ( NULL != (strTemp = StringDup(pRegDevice->Csid) ) )
            {
                MemFree(pRegSetup->Csid);
                pRegSetup->Csid = strTemp;
            }

            if ( NULL != (strTemp = StringDup(pRegDevice->Tsid) ) )
            {
                MemFree(pRegSetup->Tsid);
                pRegSetup->Tsid = strTemp;
            }

            if ( NULL != (strTemp = StringDup(pRegDevice->lptstrDescription) ) )
            {
                MemFree(pRegSetup->lptstrDescription);
                pRegSetup->lptstrDescription = strTemp;
            }

            pRegSetup->Flags = pRegDevice->Flags;
            pRegSetup->Rings = pRegDevice->Rings;


            dwServiceID = pRegDevice->PermanentLineId;  // server's line ID (also the key of the device in the registry)

            pRegDevice->DeviceInstalled = TRUE; // mark as installed, will be needed later for registry clean-up

            break;  // found it no need to continue
        }
    }

    return dwServiceID;
}


/*++

Routine name : FindCacheEntryByTapiPermanentLineID

Routine description:

    Search for a device configuration in the registry Device cache with a given "Tapi Permanent Line ID"
    and the device's name.

Author:

    Caliv Nir (t-nicali), Apr, 2001


Arguments:

    dwTapiPermanentLineID           [in]  - Tapi Permanent Line ID to search
    strDeviceName                   [in]  - Device name
    pRegSetup                       [out] - Parameter, for returning registry stored Csid, Tsid, Flags, Rings
    lpdwLastUniqueLineId            [in]  - last unique Server device ID (from registry), for assigning the device with new ID
    pfManualAnswer                  [out] - TRUE if the device was wet to manual answer when moved to the cache

Return Value:

    Permanent Line ID (server's ID) or 0 if not found

--*/
DWORD
FindCacheEntryByTapiPermanentLineID(
    DWORD               dwTapiPermanentLineID,
    LPCTSTR             strDeviceName,
    PREG_SETUP          pRegSetup,
    LPDWORD             lpdwLastUniqueLineId,
    BOOL*               pfManualAnswer
    )
{
    DWORD   dwNewServiceID = 0;
    HKEY    hKey     = NULL;
    TCHAR   SubKeyName[MAX_PATH];
    LPTSTR  strDeviceNameFromCache=NULL;
    BOOL    fManualAnswer = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("FindCacheEntryByTapiPermanentLineID"));

    //
    //  open - "fax\Device Cache\dwTapiPermanentLineID\REGKEY_FAXSVC_DEVICE_GUID" Registry Key
    //
    _stprintf( SubKeyName, TEXT("%s\\%08lx\\%s"), REGKEY_FAX_DEVICES_CACHE, dwTapiPermanentLineID, REGKEY_FAXSVC_DEVICE_GUID );
    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, FALSE, KEY_READ );
    if (!hKey)
    {
        return  dwNewServiceID;
    }

    //
    //  found the dwTapiPermanentLineID inside the cache now check the device's name
    //
    Assert(strDeviceName);

    strDeviceNameFromCache=GetRegistryString(hKey,REGVAL_DEVICE_NAME,NULL);
    if ( (NULL != strDeviceNameFromCache) &&
         (0 == _tcscmp(strDeviceName,strDeviceNameFromCache)) )
    {
        //
        // found the device entry in cache
        //
        if ( ERROR_SUCCESS != GetNewServiceDeviceID(lpdwLastUniqueLineId, &dwNewServiceID))
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("GetNewServiceDeviceID failed and couldn't assign new Service ID")
                );
            dwNewServiceID = 0;
        }
    }

    if (hKey)
    {
        RegCloseKey(hKey);
    }
    MemFree(strDeviceNameFromCache);

    if ( dwNewServiceID )
    {
        //
        // Chcek if the device was set to manual answer
        // open - "fax\Device Cache\dwTapiPermanentLineID" Registry Key
        //
        _stprintf( SubKeyName, TEXT("%s\\%08lx"), REGKEY_FAX_DEVICES_CACHE, dwTapiPermanentLineID);
        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, FALSE, KEY_READ );
        if (hKey)
        {
            fManualAnswer = GetRegistryDword( hKey, REGVAL_MANUAL_ANSWER );
            RegCloseKey(hKey);

        }
        *pfManualAnswer = fManualAnswer;

        //
        // move the cahce entry into devices
        //
        if ( ERROR_SUCCESS == RestoreDeviceRegFromDeviceCache(dwNewServiceID,dwTapiPermanentLineID) )
        {
            //
            // update REG_SETUP record with the registry values
            //
            Assert( pRegSetup );

            _stprintf( SubKeyName, TEXT("%s\\%010lu\\%s"), REGKEY_FAX_DEVICES, dwNewServiceID, REGKEY_FAXSVC_DEVICE_GUID );
            hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, FALSE, KEY_READ );

            if (!hKey) {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("OpenRegistryKey failed for [%s]. REG_SETUP was not updated."),
                    SubKeyName
                );

                //
                // return the new service ID but REG_SETUP will contains it's default values
                //
                return dwNewServiceID;
            }


            LPTSTR strTemp = NULL;

            if ( NULL != (strTemp = GetRegistryString( hKey, REGVAL_ROUTING_CSID, REGVAL_DEFAULT_CSID )) )
            {
                MemFree(pRegSetup->Csid);
                pRegSetup->Csid = strTemp;
            }

            if ( NULL != (strTemp = GetRegistryString( hKey, REGVAL_ROUTING_TSID, REGVAL_DEFAULT_TSID )) )
            {
                MemFree(pRegSetup->Tsid);
                pRegSetup->Tsid = strTemp;
            }

            if ( NULL != (strTemp = GetRegistryString( hKey, REGVAL_DEVICE_DESCRIPTION, EMPTY_STRING )) )
            {
                MemFree(pRegSetup->lptstrDescription);
                pRegSetup->lptstrDescription = strTemp;
            }

            pRegSetup->Flags = GetRegistryDword( hKey, REGVAL_FLAGS );
            pRegSetup->Rings = GetRegistryDword( hKey, REGVAL_RINGS );

            RegCloseKey(hKey);
        }
        else
        {
            //
            // couldn't restore the device cache entry
            //
            dwNewServiceID = 0;
        }

    }

    return dwNewServiceID;
}


/*++

Routine name : GetNewServiceDeviceID


Routine description:

    The routine search and return new Service device ID.
    The routine also update this new ID in registry

ReImplemented By:

    Caliv Nir (t-nicali), Apr, 2001

Arguments:

    lpdwLastUniqueLineId    [in/out] - last ID given to service device (from registry)
    lpdwPermanentLineId     [out]    - on success will contain the new ID

Return Value:

    ERROR_SUCCESS - when ID was successfully assigned

    on failue  - win32 error code

--*/
DWORD
GetNewServiceDeviceID(
    LPDWORD lpdwLastUniqueLineId,
    LPDWORD lpdwPermanentLineId
    )
{
        //
        // Create a new UniqueLineInd.
        // A fax unique line id is always below the base of the FSP line ids.
        //
        DWORD   dwUniqueDeviceIdsSpace = DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE - DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE;
        DWORD   bGeneratedId = FALSE;
        DWORD   dwRes = ERROR_SUCCESS;
        TCHAR   SubKeyName[MAX_PATH];
        HKEY    hKey     = NULL;

        DEBUG_FUNCTION_NAME(TEXT("GetNewServiceDeviceID"));

        //
        // Scan through all available space
        //
        if (*lpdwLastUniqueLineId < DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE)
        {
            //
            // Set to minimum. May happen only in first attempt.
            //
            *lpdwLastUniqueLineId = DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE;
        }


        DWORD dwAttempt;

        for (dwAttempt = 0; dwAttempt< dwUniqueDeviceIdsSpace; dwAttempt++)
        {
            (*lpdwLastUniqueLineId)++;
            if (*lpdwLastUniqueLineId >= DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE)
            {
                //
                // Reached space height limit, loop back to lower limit.
                //
                *lpdwLastUniqueLineId = DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE;
                continue;
            }
            Assert(*lpdwLastUniqueLineId != 0);
            Assert(*lpdwLastUniqueLineId < DEFAULT_REGVAL_PROVIDER_DEVICE_ID_PREFIX_BASE);
            Assert(*lpdwLastUniqueLineId >= DEFAULT_REGVAL_FAX_UNIQUE_DEVICE_ID_BASE);

            _stprintf( SubKeyName, TEXT("%s\\%010d"), REGKEY_FAX_DEVICES, *lpdwLastUniqueLineId );
            hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKeyName, FALSE, KEY_READ );
            if (!hKey)
            {
                bGeneratedId = TRUE;
                break;
            }
            else
            {
                RegCloseKey( hKey );
            }
        }

        if (hKey)
        {
            RegCloseKey( hKey );
        }

        if (!bGeneratedId)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to generate next uniqueu line id."));
            return E_FAIL;
        }

        //
        // Persiste the new line id
        //
        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_FAXSERVER, TRUE, KEY_WRITE );
        if (!hKey)
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("OpenRegistryKey Failed for %s while persisting new unique line id (%010d) (ec: %ld)"),
                REGKEY_FAX_DEVICES,
                *lpdwLastUniqueLineId,
                dwRes);
            return dwRes;
        }
        if (!SetRegistryDword( hKey, REGVAL_LAST_UNIQUE_LINE_ID, *lpdwLastUniqueLineId))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetRegistryDword to value [%s] failed while writing new unique line id (%010d) (ec: %ld)"),
                REGVAL_LAST_UNIQUE_LINE_ID,
                *lpdwLastUniqueLineId,
                dwRes );
            RegCloseKey (hKey);
            return dwRes;
        }

        RegCloseKey (hKey);

        *lpdwPermanentLineId = *lpdwLastUniqueLineId;

        return dwRes;
}



/*++

Routine name : UpdateLastDetectedTime


Routine description:

    Write creation time of a cache entry for a given TAPI line ID

ReImplemented By:

    Caliv Nir (t-nicali), Apr, 2001

Arguments:

    dwPermanentTapiLineID       [in]    -   Permanent Tapi Line ID to update in cache
    dwlTimeNow                  [in]    -   Current time in UTC

Return Value:
    TRUE    - on success update.
    FALSE   - on failure

--*/
BOOL
UpdateLastDetectedTime(
    DWORD       dwPermanentTapiLineID,
    DWORDLONG   dwlTimeNow
    )
{
    BOOL success = FALSE;
    TCHAR SubKey[MAX_PATH];
    HKEY hKey;

    DEBUG_FUNCTION_NAME(TEXT("UpdateLastDetectedTime"));

    _stprintf( SubKey, TEXT("%s\\%08lx"),
               REGKEY_FAX_DEVICES_CACHE,
               dwPermanentTapiLineID);

    // open the device cache entry
    hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, SubKey, FALSE, KEY_WRITE );
    if(hKey)
    {
        // try to update the creation time
        success = SetRegistryBinary(hKey, REGVAL_LAST_DETECTED_TIME, (BYTE *)&dwlTimeNow, sizeof(dwlTimeNow));
        RegCloseKey(hKey);
    }

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\archiveaccessdlg.cpp ===
// ArchiveAccessDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "ArchiveAccessDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

#include "ArchiveMsgDlg.h"

/////////////////////////////////////////////////////////////////////////////
// CArchiveAccessDlg dialog


CArchiveAccessDlg::CArchiveAccessDlg(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CArchiveAccessDlg::IDD, pParent),
      m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CArchiveAccessDlg)
	m_cstrNumMsgs = _T("0");
	m_iFolder = 0;
	m_dwMsgsPerCall = 5;
	//}}AFX_DATA_INIT
}


void CArchiveAccessDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CArchiveAccessDlg)
	DDX_Control(pDX, IDC_SPIN, m_spin);
	DDX_Control(pDX, IDC_LIST, m_lstArchive);
	DDX_Text(pDX, IDC_NUMSGS, m_cstrNumMsgs);
	DDX_Radio(pDX, IDC_INBOX, m_iFolder);
	DDX_Text(pDX, IDC_MSGSPERCALL, m_dwMsgsPerCall);
	DDV_MinMaxUInt(pDX, m_dwMsgsPerCall, 1, 9999);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CArchiveAccessDlg, CDialog)
	//{{AFX_MSG_MAP(CArchiveAccessDlg)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArchiveAccessDlg message handlers

BOOL CArchiveAccessDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
    m_spin.SetRange (1, 9999);


    m_lstArchive.InsertColumn ( 0, "Message id");
    m_lstArchive.InsertColumn ( 1, "Type");
    m_lstArchive.InsertColumn ( 2, "Size");
    m_lstArchive.InsertColumn ( 3, "Pages");
    m_lstArchive.InsertColumn ( 4, "Recipient number");
    m_lstArchive.InsertColumn ( 5, "Recipient name");
    m_lstArchive.InsertColumn ( 6, "Sender number");
    m_lstArchive.InsertColumn ( 7, "Sender name");
    m_lstArchive.InsertColumn ( 8, "Tsid");
    m_lstArchive.InsertColumn ( 9, "Csid");
    m_lstArchive.InsertColumn (10, "Sender user");
    m_lstArchive.InsertColumn (11, "Billing code");
    m_lstArchive.InsertColumn (12, "Original time");
    m_lstArchive.InsertColumn (13, "Submit time");
    m_lstArchive.InsertColumn (14, "Start time");
    m_lstArchive.InsertColumn (15, "End time");
    m_lstArchive.InsertColumn (16, "Device name");
    m_lstArchive.InsertColumn (17, "Priority");
    m_lstArchive.InsertColumn (18, "Retries");
    m_lstArchive.InsertColumn (19, "Document");
    m_lstArchive.InsertColumn (20, "Subject");
    m_lstArchive.InsertColumn (21, "Caller id");
    m_lstArchive.InsertColumn (22, "Routing");
	CHeaderCtrl* pHeader = (CHeaderCtrl*)m_lstArchive.GetDlgItem(0);
	DWORD dwCount = pHeader->GetItemCount();
	for (DWORD col = 0; col <= dwCount; col++) 
	{
		m_lstArchive.SetColumnWidth(col, LVSCW_AUTOSIZE);
		int wc1 = m_lstArchive.GetColumnWidth(col);
		m_lstArchive.SetColumnWidth(col,LVSCW_AUTOSIZE_USEHEADER);
		int wc2 = m_lstArchive.GetColumnWidth(col);
		int wc = max(20,max(wc1,wc2));
		m_lstArchive.SetColumnWidth(col,wc);
	}
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void 
CArchiveAccessDlg::SetNumber (
    int iIndex, 
    DWORD dwColumn, 
    DWORD dwValue, 
    BOOL bAvail)
{
    CString cs;
    if (!bAvail)
    {
        cs = "N/A";
    }
    else
    {
        cs.Format ("%ld", dwValue);
    }
    m_lstArchive.SetItemText (iIndex, dwColumn, cs);
}

void 
CArchiveAccessDlg::SetTime (
    int iIndex, 
    DWORD dwColumn, 
    SYSTEMTIME dwTime, 
    BOOL bAvail)
{
    CString cs;
    if (!bAvail)
    {
        cs = "N/A";
    }
    else
    {
        cs.Format ("%02d:%02d:%02d", dwTime.wHour, dwTime.wMinute, dwTime.wSecond);
    }
    m_lstArchive.SetItemText (iIndex, dwColumn, cs);
}


void CArchiveAccessDlg::OnRefresh() 
{
    HANDLE h;

    if (!UpdateData ())
    {
        return;
    }
	
	m_lstArchive.DeleteAllItems ();

    if (!FaxStartMessagesEnum (m_hFax, 
                               m_iFolder ? FAX_MESSAGE_FOLDER_SENTITEMS : FAX_MESSAGE_FOLDER_INBOX, 
                               &h))
    {
        CString cs;
        cs.Format ("Failed while calling FaxStartMessagesEnum (%ld)", 
                   GetLastError ());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwNumMsgs = 0;
    while (ERROR_SUCCESS == dwRes)
    {
        PFAX_MESSAGE pMsgs;
        DWORD dwReturnedMsgs;
        if (!FaxEnumMessages (h, m_dwMsgsPerCall, &pMsgs, &dwReturnedMsgs))
        {
            CString cs;
            dwRes = GetLastError ();
			if (ERROR_NO_MORE_ITEMS != dwRes)
			{
				//
				// Real error
				//
				cs.Format ("Failed while calling FaxEnumMessages (%ld)", 
						   dwRes);
				AfxMessageBox (cs, MB_OK | MB_ICONHAND);
			}
        }
        else
        {
            //
            // Success in enumeration
            //
            dwNumMsgs += dwReturnedMsgs;
            for (DWORD dw = 0; dw < dwReturnedMsgs; dw++)
            {
                CString cs;
                cs.Format ("0x%016I64x", pMsgs[dw].dwlMessageId);
                int iIndex = m_lstArchive.InsertItem (0, cs);
                DWORDLONG *pdwl = new DWORDLONG;
                *pdwl = pMsgs[dw].dwlMessageId;
                m_lstArchive.SetItemData (iIndex, (DWORD)pdwl);
				if (!(pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_TYPE))
				{
					m_lstArchive.SetItemText (iIndex, 1, "N/A");
				}
				else
				{
					if (JT_SEND == pMsgs[dw].dwJobType)
					{
						m_lstArchive.SetItemText (iIndex, 1, "Send");
					}
					else if (JT_RECEIVE == pMsgs[dw].dwJobType)
					{
						m_lstArchive.SetItemText (iIndex, 1, "Receive");
					}
					else
					{
						cs.Format ("Bad (%ld)", pMsgs[dw].dwJobType);
						m_lstArchive.SetItemText (iIndex, 1, cs);
					}
				}			
                SetNumber (iIndex, 2, pMsgs[dw].dwSize, pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_SIZE);
                SetNumber (iIndex, 3, pMsgs[dw].dwPageCount, pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_PAGE_COUNT);
                m_lstArchive.SetItemText (iIndex, 4, pMsgs[dw].lpctstrRecipientNumber);
                m_lstArchive.SetItemText (iIndex, 5, pMsgs[dw].lpctstrRecipientName);
                m_lstArchive.SetItemText (iIndex, 6, pMsgs[dw].lpctstrSenderNumber);
                m_lstArchive.SetItemText (iIndex, 7, pMsgs[dw].lpctstrSenderName);
                m_lstArchive.SetItemText (iIndex, 8, pMsgs[dw].lpctstrTsid);
                m_lstArchive.SetItemText (iIndex, 9, pMsgs[dw].lpctstrCsid);
                m_lstArchive.SetItemText (iIndex,10, pMsgs[dw].lpctstrSenderUserName);
                m_lstArchive.SetItemText (iIndex,11, pMsgs[dw].lpctstrBillingCode);
                SetTime (iIndex, 12, pMsgs[dw].tmOriginalScheduleTime, pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME);
                SetTime (iIndex, 13, pMsgs[dw].tmSubmissionTime, pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME);
                SetTime (iIndex, 14, pMsgs[dw].tmTransmissionStartTime, pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME);
                SetTime (iIndex, 15, pMsgs[dw].tmTransmissionEndTime, pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME);
                m_lstArchive.SetItemText (iIndex,16, pMsgs[dw].lpctstrDeviceName);
				if (!(pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_PRIORITY))
				{
					m_lstArchive.SetItemText (iIndex, 17, "N/A");
				}
				else
				{
					if (FAX_PRIORITY_TYPE_LOW == pMsgs[dw].Priority)
					{
						m_lstArchive.SetItemText (iIndex, 17, "Low");
					}
					else if (FAX_PRIORITY_TYPE_NORMAL == pMsgs[dw].Priority)
					{
						m_lstArchive.SetItemText (iIndex, 17, "Normal");
					}
					else if (FAX_PRIORITY_TYPE_HIGH == pMsgs[dw].Priority)
					{
						m_lstArchive.SetItemText (iIndex, 17, "High");
					}
					else
					{
						cs.Format ("Bad (%ld)", pMsgs[dw].Priority);
						m_lstArchive.SetItemText (iIndex, 17, cs);
					}
				}			

                SetNumber (iIndex, 18, pMsgs[dw].dwRetries, pMsgs[dw].dwValidityMask & FAX_JOB_FIELD_RETRIES);
                m_lstArchive.SetItemText (iIndex,19, pMsgs[dw].lpctstrDocumentName);
                m_lstArchive.SetItemText (iIndex,20, pMsgs[dw].lpctstrSubject);
                m_lstArchive.SetItemText (iIndex,21, pMsgs[dw].lpctstrCallerID);
                m_lstArchive.SetItemText (iIndex,22, pMsgs[dw].lpctstrRoutingInfo);
            }
            FaxFreeBuffer ((LPVOID)pMsgs);
        }
    }
    m_cstrNumMsgs.Format ("%ld", dwNumMsgs);
    UpdateData (FALSE);

    if (!FaxEndMessagesEnum (h))
    {
        CString cs;
        cs.Format ("Failed while calling FaxEndMessagesEnum (%ld)", 
                   GetLastError ());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
}

void CArchiveAccessDlg::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    *pResult = 0;
	NM_LISTVIEW     *pnmListView = (NM_LISTVIEW *)pNMHDR;

	if (pnmListView->iItem < 0)
	{	
		return;
	}
	DWORDLONG dwlMsgID = *((DWORDLONG *)(m_lstArchive.GetItemData (pnmListView->iItem)));
    if (!dwlMsgID) 
    {
        return;
    }
    CArchiveMsgDlg dlg(m_hFax, 
                       m_iFolder ? FAX_MESSAGE_FOLDER_SENTITEMS : FAX_MESSAGE_FOLDER_INBOX,
                       dwlMsgID);
    if (99 == dlg.DoModal ())
    {
        //
        // Msg was erased - refresh list
        //
        OnRefresh ();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\archivemsgdlg.cpp ===
// ArchiveMsgDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "ArchiveMsgDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CArchiveMsgDlg dialog


CArchiveMsgDlg::CArchiveMsgDlg(HANDLE hFax, 
                               FAX_ENUM_MESSAGE_FOLDER Folder,
                               DWORDLONG dwlMsgId,
                               CWnd* pParent /*=NULL*/)
	: CDialog(CArchiveMsgDlg::IDD, pParent),
      m_Folder (Folder),
      m_dwlMsgId (dwlMsgId),
      m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CArchiveMsgDlg)
	m_cstrBillingCode = _T("*");
	m_cstrCallerId = _T("");
	m_cstrCSID = _T("*");
	m_cstrDeviceName = _T("*");
	m_cstrDocumentName = _T("*");
	m_cstrTransmissionEndTime = _T("*");
	m_cstrFolderName = _T("*");
	m_cstrMsgId = _T("*");
	m_cstrOrigirnalSchedTime = _T("*");
	m_cstrNumPages = _T("*");
	m_cstrPriority = _T("*");
	m_cstrRecipientName = _T("*");
	m_cstrRecipientNumber = _T("*");
	m_cstrRetries = _T("*");
	m_cstrRoutingInfo = _T("*");
	m_cstrSenderName = _T("*");
	m_cstrSenderNumber = _T("*");
	m_cstrSendingUser = _T("*");
	m_cstrTransmissionStartTime = _T("*");
	m_cstrSubject = _T("*");
	m_cstrSumbissionTime = _T("*");
	m_cstrTSID = _T("*");
	m_cstrJobType = _T("*");
	m_cstrMsgSize = _T("*");
	//}}AFX_DATA_INIT
}


void CArchiveMsgDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CArchiveMsgDlg)
	DDX_Text(pDX, IDC_BILLING, m_cstrBillingCode);
	DDX_Text(pDX, IDC_CALLERID, m_cstrCallerId);
	DDX_Text(pDX, IDC_CSID_VAL, m_cstrCSID);
	DDX_Text(pDX, IDC_DEVICE, m_cstrDeviceName);
	DDX_Text(pDX, IDC_DOCUMENT, m_cstrDocumentName);
	DDX_Text(pDX, IDC_END_TIME, m_cstrTransmissionEndTime);
	DDX_Text(pDX, IDC_FOLDER, m_cstrFolderName);
	DDX_Text(pDX, IDC_ID, m_cstrMsgId);
	DDX_Text(pDX, IDC_ORIGTIME, m_cstrOrigirnalSchedTime);
	DDX_Text(pDX, IDC_PAGES, m_cstrNumPages);
	DDX_Text(pDX, IDC_PRIORITY, m_cstrPriority);
	DDX_Text(pDX, IDC_R_NAME, m_cstrRecipientName);
	DDX_Text(pDX, IDC_R_NUMBER, m_cstrRecipientNumber);
	DDX_Text(pDX, IDC_RETRIES, m_cstrRetries);
	DDX_Text(pDX, IDC_ROUTINGINFO, m_cstrRoutingInfo);
	DDX_Text(pDX, IDC_S_NAME, m_cstrSenderName);
	DDX_Text(pDX, IDC_S_NUMBER, m_cstrSenderNumber);
	DDX_Text(pDX, IDC_SEND_USER, m_cstrSendingUser);
	DDX_Text(pDX, IDC_START_TIME, m_cstrTransmissionStartTime);
	DDX_Text(pDX, IDC_SUBJECT, m_cstrSubject);
	DDX_Text(pDX, IDC_SUBMITTIME, m_cstrSumbissionTime);
	DDX_Text(pDX, IDC_TSID_VAL, m_cstrTSID);
	DDX_Text(pDX, IDC_TYPE, m_cstrJobType);
	DDX_Text(pDX, IDS_SIZE, m_cstrMsgSize);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CArchiveMsgDlg, CDialog)
	//{{AFX_MSG_MAP(CArchiveMsgDlg)
	ON_BN_CLICKED(IDREMOVE, OnRemove)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArchiveMsgDlg message handlers

void CArchiveMsgDlg::OnRemove() 
{
    if (!FaxRemoveMessage (m_hFax, 
                        m_dwlMsgId,
                        m_Folder))
    {
        CString cs;
        cs.Format ("Failed while calling FaxRemoveMessage (%ld)", 
                   GetLastError ());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
    }
    else
    {
        EndDialog (99);
    }
}

void 
CArchiveMsgDlg::SetNumber (
    CString &cstrDest, 
    DWORD dwValue, 
    BOOL bAvail)
{
    if (!bAvail)
    {
        cstrDest = "N/A";
    }
    else
    {
        cstrDest.Format ("%ld", dwValue);
    }
}

void 
CArchiveMsgDlg::SetTime (
    CString &cstrDest, 
    SYSTEMTIME dwTime, 
    BOOL bAvail)
{
    if (!bAvail)
    {
        cstrDest = "N/A";
    }
    else
    {
        cstrDest.Format ("%02d:%02d:%02d", dwTime.wHour, dwTime.wMinute, dwTime.wSecond);
    }
}

BOOL CArchiveMsgDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    PFAX_MESSAGE pMsg;
    CString cs;

    if (!FaxGetMessage (m_hFax, 
                        m_dwlMsgId,
                        m_Folder,
                        &pMsg))
    {
        cs.Format ("Failed while calling FaxGetMessage (%ld)", 
                   GetLastError ());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return FALSE;
    }

    m_cstrFolderName = m_Folder == FAX_MESSAGE_FOLDER_INBOX ? "Inbox" : "Sent items";
    m_cstrMsgId.Format ("0x%016I64x", pMsg->dwlMessageId);
	if (!(pMsg->dwValidityMask & FAX_JOB_FIELD_TYPE))
	{
		m_cstrJobType = "N/A";
	}
	else
	{
		if (JT_SEND == pMsg->dwJobType)
		{
			m_cstrJobType =  "Send";
		}
		else if (JT_RECEIVE == pMsg->dwJobType)
		{
			m_cstrJobType = "Receive";
		}
		else
		{
			m_cstrJobType.Format ("Bad (%ld)", pMsg->dwJobType);
		}
	}			
    SetNumber (m_cstrMsgSize, pMsg->dwSize, pMsg->dwValidityMask & FAX_JOB_FIELD_SIZE);
    SetNumber (m_cstrNumPages, pMsg->dwPageCount, pMsg->dwValidityMask & FAX_JOB_FIELD_PAGE_COUNT);
    m_cstrRecipientNumber =  pMsg->lpctstrRecipientNumber;
    m_cstrRecipientName =  pMsg->lpctstrRecipientName;
    m_cstrSenderNumber =  pMsg->lpctstrSenderNumber;
    m_cstrSenderName =  pMsg->lpctstrSenderName;
    m_cstrTSID = pMsg->lpctstrTsid;
    m_cstrCSID = pMsg->lpctstrCsid;
    m_cstrSendingUser = pMsg->lpctstrSenderUserName;
    m_cstrBillingCode = pMsg->lpctstrBillingCode;
    SetTime (m_cstrOrigirnalSchedTime, pMsg->tmOriginalScheduleTime, pMsg->dwValidityMask & FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME);
    SetTime (m_cstrSumbissionTime, pMsg->tmSubmissionTime, pMsg->dwValidityMask & FAX_JOB_FIELD_SUBMISSION_TIME);
    SetTime (m_cstrTransmissionStartTime, pMsg->tmTransmissionStartTime, pMsg->dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_START_TIME);
    SetTime (m_cstrTransmissionEndTime, pMsg->tmTransmissionEndTime, pMsg->dwValidityMask & FAX_JOB_FIELD_TRANSMISSION_END_TIME);
    m_cstrDeviceName = pMsg->lpctstrDeviceName;
	if (!(pMsg->dwValidityMask & FAX_JOB_FIELD_PRIORITY))
	{
		m_cstrPriority = "N/A";
	}
	else
	{
		if (FAX_PRIORITY_TYPE_LOW == pMsg->Priority)
		{
			m_cstrPriority = "Low";
		}
		else if (FAX_PRIORITY_TYPE_NORMAL == pMsg->Priority)
		{
			m_cstrPriority = "Normal";
		}
		else if (FAX_PRIORITY_TYPE_HIGH == pMsg->Priority)
		{
			m_cstrPriority = "High";
		}
		else
		{
			m_cstrPriority.Format ("Bad (%ld)", pMsg->Priority);
		}
	}			

    SetNumber (m_cstrRetries, pMsg->dwRetries, pMsg->dwValidityMask & FAX_JOB_FIELD_RETRIES);
    m_cstrDocumentName = pMsg->lpctstrDocumentName;
    m_cstrSubject = pMsg->lpctstrSubject;
    m_cstrCallerId = pMsg->lpctstrCallerID;
    m_cstrRoutingInfo = pMsg->lpctstrRoutingInfo;
    FaxFreeBuffer ((LPVOID)pMsg);
	UpdateData (FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\addgroupdlg.cpp ===
// AddGroupDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "AddGroupDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CAddGroupDlg dialog


CAddGroupDlg::CAddGroupDlg(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CAddGroupDlg::IDD, pParent),
      m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CAddGroupDlg)
	m_cstrGroupName = _T("<All devices>");
	//}}AFX_DATA_INIT
}


void CAddGroupDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddGroupDlg)
	DDX_Text(pDX, IDC_GROUP_NAME, m_cstrGroupName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddGroupDlg, CDialog)
	//{{AFX_MSG_MAP(CAddGroupDlg)
	ON_BN_CLICKED(ID_ADD, OnAdd)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddGroupDlg message handlers

void CAddGroupDlg::OnAdd() 
{
    UpdateData ();
    if (!FaxAddOutboundGroup (m_hFax, m_cstrGroupName))
    {
        CString cs;
        cs.Format ("Failed while calling FaxAddOutboundGroup (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\archivedlg.cpp ===
// ArchiveDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"
#include "ArchiveDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CArchiveDlg dialog


CArchiveDlg::CArchiveDlg(HANDLE hFax, FAX_ENUM_MESSAGE_FOLDER Folder, CWnd* pParent /*=NULL*/)
	: CDialog(CArchiveDlg::IDD, pParent),
      m_hFax (hFax),
      m_Folder (Folder)  
{
	//{{AFX_DATA_INIT(CArchiveDlg)
	m_dwAgeLimit = 0;
	m_cstrFolder = _T("");
	m_dwHighWatermark = 0;
	m_dwLowWatermark = 0;
	m_bUseArchive = FALSE;
	m_bWarnSize = FALSE;
	//}}AFX_DATA_INIT
}


void CArchiveDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CArchiveDlg)
	DDX_Text(pDX, IDC_AGE_LIMIT, m_dwAgeLimit);
	DDX_Text(pDX, IDC_FOLDER, m_cstrFolder);
	DDX_Text(pDX, IDC_HIGH_WM, m_dwHighWatermark);
	DDX_Text(pDX, IDC_LOW_WM, m_dwLowWatermark);
	DDX_Check(pDX, IDC_USE, m_bUseArchive);
	DDX_Check(pDX, IDC_WARN, m_bWarnSize);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CArchiveDlg, CDialog)
	//{{AFX_MSG_MAP(CArchiveDlg)
	ON_BN_CLICKED(IDC_READ, OnRead)
	ON_BN_CLICKED(IDC_WRITE, OnWrite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CArchiveDlg message handlers

void CArchiveDlg::OnRead() 
{
    PFAX_ARCHIVE_CONFIG pCfg;
    if (!FaxGetArchiveConfiguration (m_hFax, m_Folder, &pCfg))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetArchiveConfiguration (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }

    m_dwAgeLimit =          pCfg->dwAgeLimit;
    m_cstrFolder =          pCfg->lpcstrFolder;
    m_dwHighWatermark =     pCfg->dwSizeQuotaHighWatermark;
    m_dwLowWatermark =      pCfg->dwSizeQuotaLowWatermark;
    m_bUseArchive =         pCfg->bUseArchive;
    m_bWarnSize =           pCfg->bSizeQuotaWarning;
    UpdateData (FALSE);
    FaxFreeBuffer (LPVOID(pCfg));
	
}

void CArchiveDlg::OnWrite() 
{
    UpdateData ();
    FAX_ARCHIVE_CONFIG cfg;
    cfg.dwSizeOfStruct = sizeof (FAX_ARCHIVE_CONFIG);
    cfg.dwAgeLimit = m_dwAgeLimit;
    cfg.lpcstrFolder = LPTSTR(LPCTSTR(m_cstrFolder));
    cfg.dwSizeQuotaHighWatermark = m_dwHighWatermark;
    cfg.dwSizeQuotaLowWatermark = m_dwLowWatermark;
    cfg.bUseArchive = m_bUseArchive;
    cfg.bSizeQuotaWarning = m_bWarnSize;

    if (!FaxSetArchiveConfiguration (m_hFax, m_Folder, &cfg))
    {
        CString cs;
        cs.Format ("Failed while calling FaxSetArchiveConfiguration (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
}

BOOL CArchiveDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    if (m_Folder == FAX_MESSAGE_FOLDER_INBOX)
    {
        SetWindowText ("Inbox archive configuration test");
    }
    else
    {
        SetWindowText ("SentItems archive configuration test");
    }
           	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\addgroupdlg.h ===
#if !defined(AFX_ADDGROUPDLG_H__9E9A80AB_5836_4F23_AE9F_FB48BA62F9B3__INCLUDED_)
#define AFX_ADDGROUPDLG_H__9E9A80AB_5836_4F23_AE9F_FB48BA62F9B3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// AddGroupDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddGroupDlg dialog

class CAddGroupDlg : public CDialog
{
// Construction
public:
	CAddGroupDlg(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddGroupDlg)
	enum { IDD = IDD_ADDGROUP_DLG };
	CString	m_cstrGroupName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddGroupDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddGroupDlg)
	afx_msg void OnAdd();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    HANDLE                         m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ADDGROUPDLG_H__9E9A80AB_5836_4F23_AE9F_FB48BA62F9B3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\archiveaccessdlg.h ===
#if !defined(AFX_ARCHIVEACCESSDLG_H__04737768_1F4E_4212_A9F3_EACDB3B2C5F4__INCLUDED_)
#define AFX_ARCHIVEACCESSDLG_H__04737768_1F4E_4212_A9F3_EACDB3B2C5F4__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ArchiveAccessDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CArchiveAccessDlg dialog

class CArchiveAccessDlg : public CDialog
{
// Construction
public:
	CArchiveAccessDlg(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CArchiveAccessDlg)
	enum { IDD = IDD_ARCHIVE_ACCESS };
	CSpinButtonCtrl	m_spin;
	CListCtrl	m_lstArchive;
	CString	m_cstrNumMsgs;
	int		m_iFolder;
	UINT	m_dwMsgsPerCall;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArchiveAccessDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CArchiveAccessDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnRefresh();
	afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    void SetNumber (int iIndex, DWORD dwColumn, DWORD dwValue, BOOL bAvail);
    void SetTime (int iIndex, DWORD dwColumn, SYSTEMTIME, BOOL bAvail);
    HANDLE                         m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARCHIVEACCESSDLG_H__04737768_1F4E_4212_A9F3_EACDB3B2C5F4__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\archivedlg.h ===
#if !defined(AFX_ARCHIVEDLG1_H__5BE3306A_6359_4B22_8C01_068AE1EFD1E7__INCLUDED_)
#define AFX_ARCHIVEDLG1_H__5BE3306A_6359_4B22_8C01_068AE1EFD1E7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ArchiveDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CArchiveDlg dialog

class CArchiveDlg : public CDialog
{
// Construction
public:
	CArchiveDlg(HANDLE hFax, FAX_ENUM_MESSAGE_FOLDER Folder, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CArchiveDlg)
	enum { IDD = IDD_ARCHIVEDLG };
	UINT	m_dwAgeLimit;
	CString	m_cstrFolder;
	UINT	m_dwHighWatermark;
	UINT	m_dwLowWatermark;
	BOOL	m_bUseArchive;
	BOOL	m_bWarnSize;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArchiveDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CArchiveDlg)
	afx_msg void OnRead();
	afx_msg void OnWrite();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
    HANDLE                         m_hFax;
    FAX_ENUM_MESSAGE_FOLDER        m_Folder;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARCHIVEDLG1_H__5BE3306A_6359_4B22_8C01_068AE1EFD1E7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\archivemsgdlg.h ===
#if !defined(AFX_ARCHIVEMSGDLG_H__8AA02C3E_2D0A_4756_8E5B_1AF62397712B__INCLUDED_)
#define AFX_ARCHIVEMSGDLG_H__8AA02C3E_2D0A_4756_8E5B_1AF62397712B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// ArchiveMsgDlg.h : header file
//
typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CArchiveMsgDlg dialog

class CArchiveMsgDlg : public CDialog
{
// Construction
public:
	CArchiveMsgDlg(HANDLE hFax, 
                   FAX_ENUM_MESSAGE_FOLDER Folder,
                   DWORDLONG dlgMsgId,
                   CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CArchiveMsgDlg)
	enum { IDD = IDD_MSG_DLG };
	CString	m_cstrBillingCode;
	CString	m_cstrCallerId;
	CString	m_cstrCSID;
	CString	m_cstrDeviceName;
	CString	m_cstrDocumentName;
	CString	m_cstrTransmissionEndTime;
	CString	m_cstrFolderName;
	CString	m_cstrMsgId;
	CString	m_cstrOrigirnalSchedTime;
	CString	m_cstrNumPages;
	CString	m_cstrPriority;
	CString	m_cstrRecipientName;
	CString	m_cstrRecipientNumber;
	CString	m_cstrRetries;
	CString	m_cstrRoutingInfo;
	CString	m_cstrSenderName;
	CString	m_cstrSenderNumber;
	CString	m_cstrSendingUser;
	CString	m_cstrTransmissionStartTime;
	CString	m_cstrSubject;
	CString	m_cstrSumbissionTime;
	CString	m_cstrTSID;
	CString	m_cstrJobType;
	CString	m_cstrMsgSize;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CArchiveMsgDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CArchiveMsgDlg)
	afx_msg void OnRemove();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    void SetNumber (CString &cstrDest, DWORD dwValue, BOOL bAvail);
    void SetTime (CString &cstrDest, SYSTEMTIME dwTime, BOOL bAvail);

    HANDLE      m_hFax;
    DWORDLONG   m_dwlMsgId;
    FAX_ENUM_MESSAGE_FOLDER m_Folder;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ARCHIVEMSGDLG_H__8AA02C3E_2D0A_4756_8E5B_1AF62397712B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\configtest.cpp ===
// ConfigTest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "ConfigTestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConfigTestApp

BEGIN_MESSAGE_MAP(CConfigTestApp, CWinApp)
	//{{AFX_MSG_MAP(CConfigTestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigTestApp construction

CConfigTestApp::CConfigTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CConfigTestApp object

CConfigTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CConfigTestApp initialization

BOOL CConfigTestApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CConfigTestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\configtest.h ===
// ConfigTest.h : main header file for the CONFIGTEST application
//

#if !defined(AFX_CONFIGTEST_H__7E514233_646D_4FA4_958A_C4AB6A84D7AE__INCLUDED_)
#define AFX_CONFIGTEST_H__7E514233_646D_4FA4_958A_C4AB6A84D7AE__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CConfigTestApp:
// See ConfigTest.cpp for the implementation of this class
//

class CConfigTestApp : public CWinApp
{
public:
	CConfigTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigTestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CConfigTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONFIGTEST_H__7E514233_646D_4FA4_958A_C4AB6A84D7AE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgactivitylogging.cpp ===
// DlgActivityLogging.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "DlgActivityLogging.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgActivityLogging dialog


CDlgActivityLogging::CDlgActivityLogging(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CDlgActivityLogging::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CDlgActivityLogging)
	m_bIn = FALSE;
	m_bOut = FALSE;
	m_strDBFile = _T("");
	//}}AFX_DATA_INIT
}


void CDlgActivityLogging::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgActivityLogging)
	DDX_Check(pDX, IDC_CHK_IN, m_bIn);
	DDX_Check(pDX, IDC_CHK_OUT, m_bOut);
	DDX_Text(pDX, IDC_DBFILE, m_strDBFile);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgActivityLogging, CDialog)
	//{{AFX_MSG_MAP(CDlgActivityLogging)
	ON_BN_CLICKED(IDC_READ, OnRead)
	ON_BN_CLICKED(IDC_WRITE, OnWrite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgActivityLogging message handlers

void CDlgActivityLogging::OnRead() 
{
    PFAX_ACTIVITY_LOGGING_CONFIG pCfg;
    if (!FaxGetActivityLoggingConfiguration (m_hFax, &pCfg))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetActivityLoggingConfiguration (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    m_strDBFile = pCfg->lptstrDBPath;
    m_bIn       = pCfg->bLogIncoming;
    m_bOut      = pCfg->bLogOutgoing;
    UpdateData (FALSE);
    FaxFreeBuffer (LPVOID(pCfg));
	
}

void CDlgActivityLogging::OnWrite() 
{
    UpdateData ();
    FAX_ACTIVITY_LOGGING_CONFIG cfg;
    cfg.dwSizeOfStruct = sizeof (FAX_ACTIVITY_LOGGING_CONFIG);
    cfg.lptstrDBPath    = LPTSTR(LPCTSTR(m_strDBFile));
    cfg.bLogIncoming    = m_bIn;
    cfg.bLogOutgoing    = m_bOut;
    if (!FaxSetActivityLoggingConfiguration (m_hFax, &cfg))
    {
        CString cs;
        cs.Format ("Failed while calling FaxSetActivityLoggingConfiguration (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\configtestdlg.cpp ===
// ConfigTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "ConfigTestDlg.h"
#include "QueueState.h"
#include "SMTPDlg.h"
#include "DlgVersion.h"
#include "OutboxDlg.h"
#include "DlgActivityLogging.h"
#include "DlgProviders.h"
#include "DlgDevices.h"
#include "DlgExtensionData.h"
#include "AddGroupDlg.h"
#include "AddFSPDlg.h"
#include "RemoveFSPDlg.h"
#include "ArchiveAccessDlg.h"
#include "DlgTiff.h"
#include "RemoveRtExt.h"
//#include "ManualAnswer.h"


typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"
#include "ArchiveDLg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigTestDlg dialog

CConfigTestDlg::CConfigTestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfigTestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConfigTestDlg)
	m_cstrServerName = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
    m_FaxHandle = INVALID_HANDLE_VALUE;
}

CConfigTestDlg::~CConfigTestDlg ()
{
    if (INVALID_HANDLE_VALUE != m_FaxHandle)
    {
        //
        // Disconnect upon termination
        //
        FaxClose (m_FaxHandle);
    }
}

void CConfigTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CConfigTestDlg)
	DDX_Control(pDX, IDC_CONNECT, m_btnConnect);
	DDX_Text(pDX, IDC_EDIT1, m_cstrServerName);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CConfigTestDlg, CDialog)
	//{{AFX_MSG_MAP(CConfigTestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_QUEUESTATE, OnQueueState)
	ON_BN_CLICKED(IDC_CONNECT, OnConnect)
	ON_BN_CLICKED(IDC_SMTP, OnSmtp)
	ON_BN_CLICKED(IDC_VERSION, OnVersion)
	ON_BN_CLICKED(IDC_OUTBOX, OnOutbox)
	ON_BN_CLICKED(IDC_SENTITEMS, OnSentitems)
	ON_BN_CLICKED(IDC_INBOX, OnInbox)
	ON_BN_CLICKED(IDC_ACTIVITY, OnActivity)
	ON_BN_CLICKED(IDC_FSPS, OnFsps)
	ON_BN_CLICKED(IDC_DEVICES, OnDevices)
	ON_BN_CLICKED(IDC_EXTENSION, OnExtension)
	ON_BN_CLICKED(IDC_ADDGROUP, OnAddGroup)
	ON_BN_CLICKED(IDC_ADDFSP, OnAddFSP)
	ON_BN_CLICKED(IDC_REMOVEFSP, OnRemoveFSP)
	ON_BN_CLICKED(IDC_ARCHIVEACCESS, OnArchiveAccess)
	ON_BN_CLICKED(IDC_TIFF, OnGerTiff)
	ON_BN_CLICKED(IDC_REMOVERR, OnRemoveRtExt)
//	ON_BN_CLICKED(IDC_MANUAL_ANSWER, OnManualAnswer)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfigTestDlg message handlers

BOOL CConfigTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
    EnableTests (FALSE);
    	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CConfigTestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CConfigTestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CConfigTestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CConfigTestDlg::OnQueueState() 
{
    CQueueState dlg(m_FaxHandle);
    dlg.DoModal ();	
}


void CConfigTestDlg::EnableTests (BOOL bEnable)
{
    GetDlgItem (IDC_QUEUESTATE)->EnableWindow (bEnable);
    GetDlgItem (IDC_SMTP)->EnableWindow (bEnable);
    GetDlgItem (IDC_VERSION)->EnableWindow (bEnable);
    GetDlgItem (IDC_OUTBOX)->EnableWindow (bEnable);
    GetDlgItem (IDC_INBOX)->EnableWindow (bEnable);
    GetDlgItem (IDC_SENTITEMS)->EnableWindow (bEnable);
    GetDlgItem (IDC_ACTIVITY)->EnableWindow (bEnable);
    GetDlgItem (IDC_FSPS)->EnableWindow (bEnable);
    GetDlgItem (IDC_DEVICES)->EnableWindow (bEnable);
    GetDlgItem (IDC_EXTENSION)->EnableWindow (bEnable);
    GetDlgItem (IDC_ADDGROUP)->EnableWindow (bEnable);
    GetDlgItem (IDC_ADDFSP)->EnableWindow (bEnable);
    GetDlgItem (IDC_REMOVEFSP)->EnableWindow (bEnable);
    GetDlgItem (IDC_ARCHIVEACCESS)->EnableWindow (bEnable);
    GetDlgItem (IDC_TIFF)->EnableWindow (bEnable);
    GetDlgItem (IDC_REMOVERR)->EnableWindow (bEnable);
    GetDlgItem (IDC_MANUAL_ANSWER)->EnableWindow (bEnable);
}


void CConfigTestDlg::OnConnect() 
{
    UpdateData ();
    if (INVALID_HANDLE_VALUE == m_FaxHandle)
    {
        //
        // Connect
        //
        if (!FaxConnectFaxServer (m_cstrServerName, &m_FaxHandle))
        {
            //
            // Failed to connect
            //
            CString cs;
            cs.Format ("Failed to connect to %s (%ld)", m_cstrServerName, GetLastError());
            AfxMessageBox (cs, MB_OK | MB_ICONHAND);
            return;
        }
        //
        // Connection succeeded
        //
        EnableTests (TRUE);
        m_btnConnect.SetWindowText ("Disconnect");
    }
    else
    {
        //
        // Disconnect
        //
        if (!FaxClose (m_FaxHandle))
        {
            //
            // Failed to disconnect
            //
            CString cs;
            cs.Format ("Failed to disconnect from server (%ld)", GetLastError());
            AfxMessageBox (cs, MB_OK | MB_ICONHAND);
            return;
        }
        //
        // Disconnection succeeded
        //
        EnableTests (FALSE);
        m_btnConnect.SetWindowText ("Connect");
    }
}

void CConfigTestDlg::OnSmtp() 
{
    CSMTPDlg dlg(m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnVersion() 
{
    CDlgVersion dlg(m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnOutbox() 
{
    COutboxDlg dlg(m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnSentitems() 
{
    CArchiveDlg dlg(m_FaxHandle, FAX_MESSAGE_FOLDER_SENTITEMS);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnInbox() 
{
    CArchiveDlg dlg(m_FaxHandle, FAX_MESSAGE_FOLDER_INBOX);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnActivity() 
{
    CDlgActivityLogging dlg(m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnFsps() 
{
    CDlgProviders dlg(m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnDevices() 
{
    CDlgDevices dlg(m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnExtension() 
{
    CDlgExtensionData dlg(m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnAddGroup() 
{
    CAddGroupDlg dlg (m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnAddFSP() 
{
    CAddFSPDlg dlg (m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnRemoveFSP() 
{
    CRemoveFSPDlg dlg (m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnArchiveAccess() 
{
    CArchiveAccessDlg dlg (m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnGerTiff() 
{
    CDlgTIFF dlg (m_FaxHandle);
    dlg.DoModal ();	
}

void CConfigTestDlg::OnRemoveRtExt() 
{
    CRemoveRtExt dlg(m_FaxHandle);
    dlg.DoModal ();	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\configtestdlg.h ===
// ConfigTestDlg.h : header file
//

#if !defined(AFX_CONFIGTESTDLG_H__97485B4A_141A_443C_BF54_AC5A9C54E3BB__INCLUDED_)
#define AFX_CONFIGTESTDLG_H__97485B4A_141A_443C_BF54_AC5A9C54E3BB__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CConfigTestDlg dialog

class CConfigTestDlg : public CDialog
{
// Construction
public:
	CConfigTestDlg(CWnd* pParent = NULL);	// standard constructor
    virtual ~CConfigTestDlg();

// Dialog Data
	//{{AFX_DATA(CConfigTestDlg)
	enum { IDD = IDD_CONFIGTEST_DIALOG };
	CButton	m_btnConnect;
	CString	m_cstrServerName;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfigTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CConfigTestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnQueueState();
	afx_msg void OnConnect();
	afx_msg void OnSmtp();
	afx_msg void OnVersion();
	afx_msg void OnOutbox();
	afx_msg void OnSentitems();
	afx_msg void OnInbox();
	afx_msg void OnActivity();
	afx_msg void OnFsps();
	afx_msg void OnDevices();
	afx_msg void OnExtension();
	afx_msg void OnAddGroup();
	afx_msg void OnAddFSP();
	afx_msg void OnRemoveFSP();
	afx_msg void OnArchiveAccess();
	afx_msg void OnGerTiff();
	afx_msg void OnRemoveRtExt();
	afx_msg void OnManualAnswer();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    void EnableTests (BOOL);

    HANDLE m_FaxHandle;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CONFIGTESTDLG_H__97485B4A_141A_443C_BF54_AC5A9C54E3BB__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgdevice.cpp ===
// DlgDevice.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"
#include "DlgDevice.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgDevice dialog


CDlgDevice::CDlgDevice(HANDLE hFax, DWORD dwDeviceID, CWnd* pParent /*=NULL*/)
	: CDialog(CDlgDevice::IDD, pParent), m_hFax (hFax), m_dwDeviceID (dwDeviceID)
{
	//{{AFX_DATA_INIT(CDlgDevice)
	m_cstrCSID = _T("");
	m_cstrDescription = _T("");
	m_cstrDeviceID = _T("0");
	m_cstrDeviceName = _T("");
	m_cstrProviderGUID = _T("");
	m_m_cstrProviderName = _T("");
	m_ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
	m_dwRings = 0;
	m_bSend = FALSE;
	m_cstrTSID = _T("");
	//}}AFX_DATA_INIT
}


void CDlgDevice::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgDevice)
	DDX_Text(pDX, IDC_CSID, m_cstrCSID);
	DDX_Text(pDX, IDC_DESCRIPTION, m_cstrDescription);
	DDX_Text(pDX, IDC_DEVID, m_cstrDeviceID);
	DDX_Text(pDX, IDC_DEVNAME, m_cstrDeviceName);
	DDX_Text(pDX, IDC_PROVGUID, m_cstrProviderGUID);
	DDX_Text(pDX, IDC_PROVNAME, m_m_cstrProviderName);
	DDX_Check(pDX, IDC_RECEIVE, (int&)m_ReceiveMode);
	DDX_Text(pDX, IDC_RINGS, m_dwRings);
	DDX_Check(pDX, IDC_SEND, m_bSend);
	DDX_Text(pDX, IDC_TSID, m_cstrTSID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgDevice, CDialog)
	//{{AFX_MSG_MAP(CDlgDevice)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	ON_BN_CLICKED(IDC_WRITE, OnWrite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgDevice message handlers

BOOL CDlgDevice::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    OnRefresh();	

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgDevice::OnRefresh() 
{
    PFAX_PORT_INFO_EX pDevice;
    if (!FaxGetPortEx (m_hFax, m_dwDeviceID, &pDevice))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetPortEx (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }

	m_cstrCSID = pDevice->lptstrCsid;
	m_cstrDescription = pDevice->lptstrDescription;
	m_cstrDeviceID.Format ("%08x", pDevice->dwDeviceID);
	m_cstrDeviceName = pDevice->lpctstrDeviceName;
	m_cstrProviderGUID = pDevice->lpctstrProviderGUID;
	m_m_cstrProviderName = pDevice->lpctstrProviderName;
	m_ReceiveMode = pDevice->ReceiveMode;
	m_dwRings = pDevice->dwRings;
	m_bSend = pDevice->bSend;
	m_cstrTSID = pDevice->lptstrTsid;

    UpdateData (FALSE);
    FaxFreeBuffer (LPVOID(pDevice));
}

void CDlgDevice::OnWrite() 
{
    UpdateData ();
    FAX_PORT_INFO_EX Device;
    Device.dwSizeOfStruct = sizeof (FAX_PORT_INFO_EX);
	Device.lptstrCsid = LPTSTR(LPCTSTR(m_cstrCSID));
	Device.lptstrDescription = LPTSTR(LPCTSTR(m_cstrDescription));
	Device.ReceiveMode = m_ReceiveMode;
	Device.dwRings = m_dwRings;
	Device.bSend = m_bSend;
	Device.lptstrTsid = LPTSTR(LPCTSTR(m_cstrTSID));
	Device.lpctstrDeviceName = NULL;
	Device.lpctstrProviderName = NULL;
	Device.lpctstrProviderGUID = NULL;

    if (!FaxSetPortEx (m_hFax, m_dwDeviceID, &Device))
    {
        CString cs;
        cs.Format ("Failed while calling FaxSetPortEx (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgactivitylogging.h ===
#if !defined(AFX_DLGACTIVITYLOGGING_H__EB7E3620_9656_47BC_BC4E_4A4A65F1CC32__INCLUDED_)
#define AFX_DLGACTIVITYLOGGING_H__EB7E3620_9656_47BC_BC4E_4A4A65F1CC32__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgActivityLogging.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgActivityLogging dialog

class CDlgActivityLogging : public CDialog
{
// Construction
public:
	CDlgActivityLogging(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgActivityLogging)
	enum { IDD = IDD_ACTIVITYLOGGING_DLG };
	BOOL	m_bIn;
	BOOL	m_bOut;
	CString	m_strDBFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgActivityLogging)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgActivityLogging)
	afx_msg void OnRead();
	afx_msg void OnWrite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGACTIVITYLOGGING_H__EB7E3620_9656_47BC_BC4E_4A4A65F1CC32__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgextensiondata.cpp ===
// DlgExtensionData.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "DlgExtensionData.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgExtensionData dialog


CDlgExtensionData::CDlgExtensionData(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CDlgExtensionData::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CDlgExtensionData)
	m_cstrData = _T("");
	m_cstrGUID = _T("");
	//}}AFX_DATA_INIT
}


void CDlgExtensionData::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgExtensionData)
	DDX_Control(pDX, IDC_CMDDEVICES, m_cmbDevices);
	DDX_Text(pDX, IDC_DATA, m_cstrData);
	DDX_Text(pDX, IDC_GUID, m_cstrGUID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgExtensionData, CDialog)
	//{{AFX_MSG_MAP(CDlgExtensionData)
	ON_BN_CLICKED(IDC_READ, OnRead)
	ON_BN_CLICKED(IDC_WRITE, OnWrite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgExtensionData message handlers

BOOL CDlgExtensionData::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    //
    // Fill list of devices
    //
    PFAX_PORT_INFO_EX pDevices;
    DWORD   dwNumDevices;
    CString cs;

    if (!FaxEnumPortsEx (m_hFax, &pDevices, &dwNumDevices))
    {
        CString cs;
        cs.Format ("Failed while calling FaxEnumPortsEx (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return TRUE;
    }
	m_cmbDevices.ResetContent();
    int iIndex = m_cmbDevices.AddString ("<Unassigned>");
    m_cmbDevices.SetItemData (iIndex, 0);
    for (DWORD dw = 0; dw < dwNumDevices; dw++)
    {
        //
        // Insert device
        //
        cs.Format ("%s (%ld)", pDevices[dw].lpctstrDeviceName, pDevices[dw].dwDeviceID);
        iIndex = m_cmbDevices.AddString (cs);
        m_cmbDevices.SetItemData (iIndex, pDevices[dw].dwDeviceID);
    }
    UpdateData (FALSE);
    m_cmbDevices.SetCurSel (0);
    FaxFreeBuffer (LPVOID(pDevices));
    	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgExtensionData::OnRead() 
{
    UpdateData ();
    LPVOID lpData = NULL;
    DWORD dwSize;
    char sz[1024];

    DWORD dwDeviceId = m_cmbDevices.GetItemData(m_cmbDevices.GetCurSel());
    if (!FaxGetExtensionData (  m_hFax, 
                                dwDeviceId, 
                                m_cstrGUID, 
                                &lpData, 
                                &dwSize
                             ))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetExtensionData (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    if (!WideCharToMultiByte (CP_ACP,
                              0,
                              (LPCWSTR)(lpData),
                              -1,
                              sz,
                              sizeof (sz),
                              NULL,
                              NULL))
    {
        CString cs;
        cs.Format ("Failed while calling WideCharToMultiByte (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        FaxFreeBuffer (lpData);
        return;
    }
    m_cstrData = sz;
    UpdateData (FALSE);
    FaxFreeBuffer (lpData);
}

void CDlgExtensionData::OnWrite() 
{
    UpdateData ();
    WCHAR wsz[1024];

    DWORD dwDeviceId = m_cmbDevices.GetItemData(m_cmbDevices.GetCurSel());
    if (!MultiByteToWideChar (CP_ACP,
                              0,
                              (LPCTSTR)(m_cstrData),
                              -1,
                              wsz,
                              sizeof (wsz) / sizeof (wsz[0])))
    {
        CString cs;
        cs.Format ("Failed while calling MulityByteToWideChar (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }

    if (!FaxSetExtensionData (  m_hFax, 
                                dwDeviceId, 
                                m_cstrGUID, 
                                (LPVOID)(wsz), 
                                sizeof (WCHAR) * (m_cstrData.GetLength () + 1)
                             ))
    {
        CString cs;
        cs.Format ("Failed while calling FaxSetExtensionData (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgdevices.h ===
#if !defined(AFX_DLGDEVICES_H__75765D25_8B24_482A_9DDD_3854A5886184__INCLUDED_)
#define AFX_DLGDEVICES_H__75765D25_8B24_482A_9DDD_3854A5886184__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgDevices.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgDevices dialog

class CDlgDevices : public CDialog
{
// Construction
public:
	CDlgDevices(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgDevices)
	enum { IDD = IDD_DLGDEVICES };
	CListCtrl	m_lstDevices;
	CString	m_cstrNumDevices;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgDevices)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgDevices)
	virtual BOOL OnInitDialog();
	afx_msg void OnRefresh();
	afx_msg void OnDblclkDevs(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGDEVICES_H__75765D25_8B24_482A_9DDD_3854A5886184__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgextensiondata.h ===
#if !defined(AFX_DLGEXTENSIONDATA_H__1BC856D5_F2DD_4462_AF33_729F0EE63015__INCLUDED_)
#define AFX_DLGEXTENSIONDATA_H__1BC856D5_F2DD_4462_AF33_729F0EE63015__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgExtensionData.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgExtensionData dialog

class CDlgExtensionData : public CDialog
{
// Construction
public:
	CDlgExtensionData(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgExtensionData)
	enum { IDD = IDD_DLGEXTENSION };
	CComboBox	m_cmbDevices;
	CString	m_cstrData;
	CString	m_cstrGUID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgExtensionData)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgExtensionData)
	virtual BOOL OnInitDialog();
	afx_msg void OnRead();
	afx_msg void OnWrite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGEXTENSIONDATA_H__1BC856D5_F2DD_4462_AF33_729F0EE63015__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgproviders.cpp ===
// DlgProviders.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "DlgProviders.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgProviders dialog


CDlgProviders::CDlgProviders(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CDlgProviders::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CDlgProviders)
	m_cstrNumProviders = _T("0");
	//}}AFX_DATA_INIT
}


void CDlgProviders::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgProviders)
	DDX_Control(pDX, IDC_FSPS, m_lstFSPs);
	DDX_Text(pDX, IDC_NUMFSP, m_cstrNumProviders);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgProviders, CDialog)
	//{{AFX_MSG_MAP(CDlgProviders)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgProviders message handlers

void CDlgProviders::OnRefresh() 
{
    PFAX_DEVICE_PROVIDER_INFO pFSPs;
    DWORD   dwNumFSPs;
    CString cs;

	m_lstFSPs.DeleteAllItems();
    if (!FaxEnumerateProviders (m_hFax, &pFSPs, &dwNumFSPs))
    {
        CString cs;
        cs.Format ("Failed while calling FaxEnumerateProviders (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    for (DWORD dw = 0; dw < dwNumFSPs; dw++)
    {
        int iIndex = m_lstFSPs.InsertItem (0, pFSPs[dw].lpctstrFriendlyName);
        m_lstFSPs.SetItemText (iIndex, 1, pFSPs[dw].lpctstrImageName);
        m_lstFSPs.SetItemText (iIndex, 2, pFSPs[dw].lpctstrProviderName);
        m_lstFSPs.SetItemText (iIndex, 3, pFSPs[dw].lpctstrGUID);
        cs.Format ("%08x", pFSPs[dw].dwCapabilities);
        m_lstFSPs.SetItemText (iIndex, 4, cs);
        if (pFSPs[dw].Version.bValid)
        {
            //
            // Version info exists
            //
            cs.Format ("%ld.%ld.%ld.%ld (%s)", 
                       pFSPs[dw].Version.wMajorVersion,
                       pFSPs[dw].Version.wMinorVersion,
                       pFSPs[dw].Version.wMajorBuildNumber,
                       pFSPs[dw].Version.wMinorBuildNumber,
                       (pFSPs[dw].Version.dwFlags & FAX_VER_FLAG_CHECKED) ? "checked" : "free");
        }
        else
        {
            cs = "<no version data>";
        }
        m_lstFSPs.SetItemText (iIndex, 5, cs);
        switch (pFSPs[dw].Status)
        {
            case FAX_PROVIDER_STATUS_SUCCESS:
                cs = "Success";
                break;

            case FAX_PROVIDER_STATUS_BAD_GUID:
                cs = "Bad GUID";
                break;

            case FAX_PROVIDER_STATUS_BAD_VERSION:
                cs = "Bad API version";
                break;

            case FAX_PROVIDER_STATUS_SERVER_ERROR:
                cs = "Internal server error";
                break;

            case FAX_PROVIDER_STATUS_CANT_LOAD:
                cs = "Can't load";
                break;

            case FAX_PROVIDER_STATUS_CANT_LINK:
                cs = "Can't link";
                break;

            case FAX_PROVIDER_STATUS_CANT_INIT:
                cs = "Can't init";
                break;

            default:
                ASSERT (FALSE);
                break;
        }    
        m_lstFSPs.SetItemText (iIndex, 6, cs);
        cs.Format ("%ld", pFSPs[dw].dwLastError);
        m_lstFSPs.SetItemText (iIndex, 7, cs);
    }
    m_cstrNumProviders.Format ("%ld", dwNumFSPs);
    UpdateData (FALSE);
    FaxFreeBuffer (LPVOID(pFSPs));
}

BOOL CDlgProviders::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    m_lstFSPs.InsertColumn (0, "Friendly name");
    m_lstFSPs.InsertColumn (1, "Image name");
    m_lstFSPs.InsertColumn (2, "Provider name");
    m_lstFSPs.InsertColumn (3, "GUID");
    m_lstFSPs.InsertColumn (4, "Capabilities");
    m_lstFSPs.InsertColumn (5, "Version");
    m_lstFSPs.InsertColumn (6, "Load status");
    m_lstFSPs.InsertColumn (7, "Load error code");
	CHeaderCtrl* pHeader = (CHeaderCtrl*)m_lstFSPs.GetDlgItem(0);
	DWORD dwCount = pHeader->GetItemCount();
	for (DWORD col = 0; col <= dwCount; col++) 
	{
		m_lstFSPs.SetColumnWidth(col, LVSCW_AUTOSIZE);
		int wc1 = m_lstFSPs.GetColumnWidth(col);
		m_lstFSPs.SetColumnWidth(col,LVSCW_AUTOSIZE_USEHEADER);
		int wc2 = m_lstFSPs.GetColumnWidth(col);
		int wc = max(20,max(wc1,wc2));
		m_lstFSPs.SetColumnWidth(col,wc);
	}
	
	OnRefresh();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgdevice.h ===
#if !defined(AFX_DLGDEVICE_H__253A5CFA_A7D5_49FC_8107_D67F2EF3278E__INCLUDED_)
#define AFX_DLGDEVICE_H__253A5CFA_A7D5_49FC_8107_D67F2EF3278E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgDevice.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgDevice dialog

class CDlgDevice : public CDialog
{
// Construction
public:
	CDlgDevice(HANDLE hFax, DWORD dwDeviceID, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgDevice)
	enum { IDD = IDD_DLGDEVICE };
	CString	m_cstrCSID;
	CString	m_cstrDescription;
	CString	m_cstrDeviceID;
	CString	m_cstrDeviceName;
	CString	m_cstrProviderGUID;
	CString	m_m_cstrProviderName;
	FAX_ENUM_DEVICE_RECEIVE_MODE m_ReceiveMode;
	UINT	m_dwRings;
	BOOL	m_bSend;
	CString	m_cstrTSID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgDevice)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgDevice)
	virtual BOOL OnInitDialog();
	afx_msg void OnRefresh();
	afx_msg void OnWrite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    HANDLE      m_hFax;
    DWORD       m_dwDeviceID;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGDEVICE_H__253A5CFA_A7D5_49FC_8107_D67F2EF3278E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgproviders.h ===
#if !defined(AFX_DLGPROVIDERS_H__FEBCFFB5_E92D_4C3C_8314_C586F2A9BA15__INCLUDED_)
#define AFX_DLGPROVIDERS_H__FEBCFFB5_E92D_4C3C_8314_C586F2A9BA15__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgProviders.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgProviders dialog

class CDlgProviders : public CDialog
{
// Construction
public:
	CDlgProviders(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgProviders)
	enum { IDD = IDD_DLG_ENUM_FSP };
	CListCtrl	m_lstFSPs;
	CString	m_cstrNumProviders;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgProviders)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgProviders)
	afx_msg void OnRefresh();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGPROVIDERS_H__FEBCFFB5_E92D_4C3C_8314_C586F2A9BA15__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgdevices.cpp ===
// DlgDevices.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "DlgDevices.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"
#include "DlgDevice.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgDevices dialog


CDlgDevices::CDlgDevices(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CDlgDevices::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CDlgDevices)
	m_cstrNumDevices = _T("0");
	//}}AFX_DATA_INIT
}


void CDlgDevices::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgDevices)
	DDX_Control(pDX, IDC_DEVS, m_lstDevices);
	DDX_Text(pDX, IDC_NUMDEVS, m_cstrNumDevices);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgDevices, CDialog)
	//{{AFX_MSG_MAP(CDlgDevices)
	ON_BN_CLICKED(IDC_REFRESH, OnRefresh)
	ON_NOTIFY(NM_DBLCLK, IDC_DEVS, OnDblclkDevs)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgDevices message handlers

BOOL CDlgDevices::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    m_lstDevices.InsertColumn (0, "Device id");
    m_lstDevices.InsertColumn (1, "Device name");
    m_lstDevices.InsertColumn (2, "Description");
    m_lstDevices.InsertColumn (3, "Provider name");
    m_lstDevices.InsertColumn (4, "Provider GUID");
    m_lstDevices.InsertColumn (5, "Send");
    m_lstDevices.InsertColumn (6, "Receive");
    m_lstDevices.InsertColumn (7, "Rings");
    m_lstDevices.InsertColumn (8, "Csid");
    m_lstDevices.InsertColumn (9, "Tsid");
	CHeaderCtrl* pHeader = (CHeaderCtrl*)m_lstDevices.GetDlgItem(0);
	DWORD dwCount = pHeader->GetItemCount();
	for (DWORD col = 0; col <= dwCount; col++) 
	{
		m_lstDevices.SetColumnWidth(col, LVSCW_AUTOSIZE);
		int wc1 = m_lstDevices.GetColumnWidth(col);
		m_lstDevices.SetColumnWidth(col,LVSCW_AUTOSIZE_USEHEADER);
		int wc2 = m_lstDevices.GetColumnWidth(col);
		int wc = max(20,max(wc1,wc2));
		m_lstDevices.SetColumnWidth(col,wc);
	}
	
	OnRefresh();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDlgDevices::OnRefresh() 
{
    PFAX_PORT_INFO_EX pDevices;
    DWORD   dwNumDevices;
    CString cs;

	m_lstDevices.DeleteAllItems();
    if (!FaxEnumPortsEx (m_hFax, &pDevices, &dwNumDevices))
    {
        CString cs;
        cs.Format ("Failed while calling FaxEnumPortsEx (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    for (DWORD dw = 0; dw < dwNumDevices; dw++)
    {
        //
        // Insert device id
        //
        cs.Format ("%08x", pDevices[dw].dwDeviceID);
        int iIndex = m_lstDevices.InsertItem (0, cs);
        m_lstDevices.SetItemData (iIndex, pDevices[dw].dwDeviceID);
        //
        // Insert device name
        //
        m_lstDevices.SetItemText (iIndex, 1, pDevices[dw].lpctstrDeviceName);
        //
        // Insert device description
        //
        m_lstDevices.SetItemText (iIndex, 2, pDevices[dw].lptstrDescription);
        //
        // Insert provider name
        //
        m_lstDevices.SetItemText (iIndex, 3, pDevices[dw].lpctstrProviderName);
        //
        // Insert provider GUID
        //
        m_lstDevices.SetItemText (iIndex, 4, pDevices[dw].lpctstrProviderGUID);
        //
        // Insert send flag
        //
        cs.Format ("%s", pDevices[dw].bSend ? "Yes" : "No");
        m_lstDevices.SetItemText (iIndex, 5, cs);
        //
        // Insert receive flag
        //
        cs.Format ("%s", pDevices[dw].ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF ? "Yes" : "No");
        m_lstDevices.SetItemText (iIndex, 6, cs);
        //
        // Insert rings count
        //
        cs.Format ("%ld", pDevices[dw].dwRings);
        m_lstDevices.SetItemText (iIndex, 7, cs);
        //
        // Insert Csid
        //
        m_lstDevices.SetItemText (iIndex, 8, pDevices[dw].lptstrCsid);
        //
        // Insert Tsid
        //
        m_lstDevices.SetItemText (iIndex, 9, pDevices[dw].lptstrTsid);
    }
    m_cstrNumDevices.Format ("%ld", dwNumDevices);
    UpdateData (FALSE);
    FaxFreeBuffer (LPVOID(pDevices));
}

void CDlgDevices::OnDblclkDevs(NMHDR* pNMHDR, LRESULT* pResult) 
{
    *pResult = 0;
	NM_LISTVIEW     *pnmListView = (NM_LISTVIEW *)pNMHDR;

	if (pnmListView->iItem < 0)
	{	
		return;
	}
	DWORD dwDeviceID = m_lstDevices.GetItemData (pnmListView->iItem);
    if (!dwDeviceID) 
    {
        return;
    }
    CDlgDevice dlg(m_hFax, dwDeviceID);
    dlg.DoModal ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\queuestate.cpp ===
// QueueState.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "QueueState.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CQueueState dialog


CQueueState::CQueueState(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CQueueState::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CQueueState)
	m_bInboxBlocked = FALSE;
	m_bOutboxBlocked = FALSE;
	m_bOutboxPaused = FALSE;
	//}}AFX_DATA_INIT
}


void CQueueState::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CQueueState)
	DDX_Check(pDX, IDC_INCOMING_BLOCKED, m_bInboxBlocked);
	DDX_Check(pDX, IDC_OUTBOX_BLOCKED, m_bOutboxBlocked);
	DDX_Check(pDX, IDC_OUTBOX_PAUSED, m_bOutboxPaused);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CQueueState, CDialog)
	//{{AFX_MSG_MAP(CQueueState)
	ON_BN_CLICKED(IDC_WRITE, OnWrite)
	ON_BN_CLICKED(IDC_READ, OnRead)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CQueueState message handlers

void CQueueState::OnWrite() 
{
    UpdateData ();
    DWORD dwState = (m_bInboxBlocked ? FAX_INCOMING_BLOCKED : 0) |
                    (m_bOutboxBlocked ? FAX_OUTBOX_BLOCKED : 0) |
                    (m_bOutboxPaused ? FAX_OUTBOX_PAUSED : 0);
    if (!FaxSetQueue	(m_hFax, dwState))
    {
        CString cs;
        cs.Format ("Failed while calling FaxSetQueue (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
}

void CQueueState::OnRead() 
{
    DWORD dwState;
    if (!FaxGetQueueStates	(m_hFax, &dwState))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetQueueStates (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    m_bInboxBlocked = (dwState & FAX_INCOMING_BLOCKED) ? TRUE : FALSE;
    m_bOutboxBlocked = (dwState & FAX_OUTBOX_BLOCKED) ? TRUE : FALSE;
    m_bOutboxPaused = (dwState & FAX_OUTBOX_PAUSED) ? TRUE : FALSE;
    UpdateData (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgversion.cpp ===
// DlgVersion.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "DlgVersion.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgVersion dialog


CDlgVersion::CDlgVersion(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CDlgVersion::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CDlgVersion)
	m_cstrVersion = _T("");
	//}}AFX_DATA_INIT
}


void CDlgVersion::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgVersion)
	DDX_Text(pDX, IDC_SERVERVERSION, m_cstrVersion);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgVersion, CDialog)
	//{{AFX_MSG_MAP(CDlgVersion)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgVersion message handlers

BOOL CDlgVersion::OnInitDialog() 
{
	CDialog::OnInitDialog();

    FAX_VERSION ver;
    ver.dwSizeOfStruct = sizeof (FAX_VERSION);
    
    if (!FaxGetVersion (m_hFax, &ver))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetVersion (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        EndDialog (-1);
        return FALSE;
    }
    if (ver.bValid)
    {
        //
        // Version info exists
        //
        m_cstrVersion.Format ("%ld.%ld.%ld.%ld (%s)", 
                   ver.wMajorVersion,
                   ver.wMinorVersion,
                   ver.wMajorBuildNumber,
                   ver.wMinorBuildNumber,
                   (ver.dwFlags & FAX_VER_FLAG_CHECKED) ? "checked" : "free");
    }
    else
    {
        m_cstrVersion = "<no version data>";
    }

    UpdateData (FALSE);
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\outboxdlg.cpp ===
// OutboxDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "OutboxDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"
/////////////////////////////////////////////////////////////////////////////
// COutboxDlg dialog


COutboxDlg::COutboxDlg(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(COutboxDlg::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(COutboxDlg)
	m_bBranding = FALSE;
	m_dwAgeLimit = 0;
	m_dwEndHour = 0;
	m_dwEndMinute = 0;
	m_bPersonalCP = FALSE;
	m_dwRetries = 0;
	m_dwRetryDelay = 0;
	m_dwStartHour = 0;
	m_dwStartMinute = 0;
	m_bUseDeviceTsid = FALSE;
	//}}AFX_DATA_INIT
}


void COutboxDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(COutboxDlg)
	DDX_Check(pDX, IDC_BRANDING, m_bBranding);
	DDX_Text(pDX, IDC_AGELIMIT, m_dwAgeLimit);
	DDX_Text(pDX, IDC_ENDH, m_dwEndHour);
	DDV_MinMaxUInt(pDX, m_dwEndHour, 0, 23);
	DDX_Text(pDX, IDC_ENDM, m_dwEndMinute);
	DDV_MinMaxUInt(pDX, m_dwEndMinute, 0, 59);
	DDX_Check(pDX, IDC_PERSONALCP, m_bPersonalCP);
	DDX_Text(pDX, IDC_RETRIES, m_dwRetries);
	DDX_Text(pDX, IDC_RETRYDELAY, m_dwRetryDelay);
	DDX_Text(pDX, IDC_STARTH, m_dwStartHour);
	DDV_MinMaxUInt(pDX, m_dwStartHour, 0, 23);
	DDX_Text(pDX, IDC_STARTM, m_dwStartMinute);
	DDV_MinMaxUInt(pDX, m_dwStartMinute, 0, 59);
	DDX_Check(pDX, IDC_USERDEVICETSID, m_bUseDeviceTsid);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(COutboxDlg, CDialog)
	//{{AFX_MSG_MAP(COutboxDlg)
	ON_BN_CLICKED(IDC_READ, OnRead)
	ON_BN_CLICKED(IDC_WRITE, OnWrite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COutboxDlg message handlers

void COutboxDlg::OnRead() 
{
    PFAX_OUTBOX_CONFIG pCfg;
    if (!FaxGetOutboxConfiguration (m_hFax, &pCfg))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetOutboxConfiguration (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    m_bPersonalCP =         pCfg->bAllowPersonalCP;
    m_bUseDeviceTsid =      pCfg->bUseDeviceTSID;
    m_dwRetries =           pCfg->dwRetries;
    m_dwRetryDelay =        pCfg->dwRetryDelay;
    m_dwStartHour =         pCfg->dtDiscountStart.Hour;
    m_dwStartMinute =       pCfg->dtDiscountStart.Minute;
    m_dwEndHour =           pCfg->dtDiscountEnd.Hour;
    m_dwEndMinute =         pCfg->dtDiscountEnd.Minute;
    m_dwAgeLimit =          pCfg->dwAgeLimit;
    m_bBranding =           pCfg->bBranding;
    UpdateData (FALSE);
    FaxFreeBuffer (LPVOID(pCfg));
	
}

void COutboxDlg::OnWrite() 
{
    UpdateData ();
    FAX_OUTBOX_CONFIG cfg;
    cfg.dwSizeOfStruct = sizeof (FAX_OUTBOX_CONFIG);
    cfg.bAllowPersonalCP        = m_bPersonalCP;
    cfg.bUseDeviceTSID          = m_bUseDeviceTsid;
    cfg.dwRetries               = m_dwRetries;
    cfg.dwRetryDelay            = m_dwRetryDelay;
    cfg.dtDiscountStart.Hour    = m_dwStartHour;
    cfg.dtDiscountStart.Minute  = m_dwStartMinute;
    cfg.dtDiscountEnd.Hour      = m_dwEndHour;
    cfg.dtDiscountEnd.Minute    = m_dwEndMinute;
    cfg.dwAgeLimit              = m_dwAgeLimit;
    cfg.bBranding               = m_bBranding;
    if (!FaxSetOutboxConfiguration (m_hFax, &cfg))
    {
        CString cs;
        cs.Format ("Failed while calling FaxSetOutboxConfiguration (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgtiff.cpp ===
// DlgTIFF.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "DlgTIFF.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CDlgTIFF dialog


CDlgTIFF::CDlgTIFF(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CDlgTIFF::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CDlgTIFF)
	m_cstrDstFile = _T("");
	m_iFolder = 0;
	m_cstrMsgId = _T("");
	//}}AFX_DATA_INIT
}


void CDlgTIFF::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDlgTIFF)
	DDX_Text(pDX, IDC_DESTFILE, m_cstrDstFile);
	DDX_Radio(pDX, IDC_INBOX, m_iFolder);
	DDX_Text(pDX, IDC_MGSID, m_cstrMsgId);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDlgTIFF, CDialog)
	//{{AFX_MSG_MAP(CDlgTIFF)
	ON_BN_CLICKED(IDC_COPY, OnCopy)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDlgTIFF message handlers

void CDlgTIFF::OnCopy() 
{
    if (!UpdateData ())
    {
        return;
    }
    DWORDLONG dwlMsgId;
    if (1 != sscanf (m_cstrMsgId, "%I64ld", &dwlMsgId))
    {
        return;
    }
    if (!strlen (m_cstrDstFile))
    {
        return;
    }
    FAX_ENUM_MESSAGE_FOLDER Folder;
    switch (m_iFolder)
    {
        case 0:
            Folder = FAX_MESSAGE_FOLDER_INBOX;
            break;
        case 1:
            Folder = FAX_MESSAGE_FOLDER_SENTITEMS;
            break;
        case 2:
            Folder = FAX_MESSAGE_FOLDER_QUEUE;
            break;
        default:
            return;
    }
    if (!FaxGetMessageTiff (m_hFax, dwlMsgId, Folder, m_cstrDstFile))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetMessageTiff (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    else
    {
        AfxMessageBox ("TIFF successfully copied", MB_OK | MB_ICONHAND);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgtiff.h ===
#if !defined(AFX_DLGTIFF_H__1A1E8CB2_15A9_41AB_9753_765EF0AEF2CF__INCLUDED_)
#define AFX_DLGTIFF_H__1A1E8CB2_15A9_41AB_9753_765EF0AEF2CF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgTIFF.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgTIFF dialog

class CDlgTIFF : public CDialog
{
// Construction
public:
	CDlgTIFF(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgTIFF)
	enum { IDD = IDD_TIFF_DLG };
	CString	m_cstrDstFile;
	int		m_iFolder;
	CString	m_cstrMsgId;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgTIFF)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgTIFF)
	afx_msg void OnCopy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGTIFF_H__1A1E8CB2_15A9_41AB_9753_765EF0AEF2CF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\dlgversion.h ===
#if !defined(AFX_DLGVERSION_H__172A5C20_028D_4853_8395_1B6E4727C5C0__INCLUDED_)
#define AFX_DLGVERSION_H__172A5C20_028D_4853_8395_1B6E4727C5C0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// DlgVersion.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDlgVersion dialog

class CDlgVersion : public CDialog
{
// Construction
public:
	CDlgVersion(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDlgVersion)
	enum { IDD = IDD_DLGVERSION };
	CString	m_cstrVersion;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDlgVersion)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDlgVersion)
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLGVERSION_H__172A5C20_028D_4853_8395_1B6E4727C5C0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\outboxdlg.h ===
#if !defined(AFX_OUTBOXDLG_H__AE05E7AB_8CB0_4AE7_BD5D_21B17C332CF0__INCLUDED_)
#define AFX_OUTBOXDLG_H__AE05E7AB_8CB0_4AE7_BD5D_21B17C332CF0__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// OutboxDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COutboxDlg dialog

class COutboxDlg : public CDialog
{
// Construction
public:
	COutboxDlg(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(COutboxDlg)
	enum { IDD = IDD_DLGOUTBOX };
	BOOL	m_bBranding;
	UINT	m_dwAgeLimit;
	UINT	m_dwEndHour;
	UINT	m_dwEndMinute;
	BOOL	m_bPersonalCP;
	UINT	m_dwRetries;
	UINT	m_dwRetryDelay;
	UINT	m_dwStartHour;
	UINT	m_dwStartMinute;
	BOOL	m_bUseDeviceTsid;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(COutboxDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(COutboxDlg)
	afx_msg void OnRead();
	afx_msg void OnWrite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_OUTBOXDLG_H__AE05E7AB_8CB0_4AE7_BD5D_21B17C332CF0__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\queuestate.h ===
#if !defined(AFX_QUEUESTATE_H__08A972D1_1BAF_4523_98AC_0309F8600775__INCLUDED_)
#define AFX_QUEUESTATE_H__08A972D1_1BAF_4523_98AC_0309F8600775__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// QueueState.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CQueueState dialog

class CQueueState : public CDialog
{
// Construction
public:
	CQueueState(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CQueueState)
	enum { IDD = IDD_QUEUESTATE };
	BOOL	m_bInboxBlocked;
	BOOL	m_bOutboxBlocked;
	BOOL	m_bOutboxPaused;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CQueueState)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CQueueState)
	afx_msg void OnWrite();
	afx_msg void OnRead();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_QUEUESTATE_H__08A972D1_1BAF_4523_98AC_0309F8600775__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\removefspdlg.cpp ===
// RemoveFSPDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "RemoveFSPDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CRemoveFSPDlg dialog


CRemoveFSPDlg::CRemoveFSPDlg(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CRemoveFSPDlg::IDD, pParent),
      m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CRemoveFSPDlg)
	m_cstrGUID = _T("");
	//}}AFX_DATA_INIT
}


void CRemoveFSPDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRemoveFSPDlg)
	DDX_Control(pDX, IDC_COMBO, m_cbFSPs);
	DDX_Text(pDX, IDC_GUID, m_cstrGUID);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemoveFSPDlg, CDialog)
	//{{AFX_MSG_MAP(CRemoveFSPDlg)
	ON_BN_CLICKED(IDREMOVE, OnRemove)
	ON_CBN_SELCHANGE(IDC_COMBO, OnSelChangeCombo)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRemoveFSPDlg message handlers

void CRemoveFSPDlg::OnRemove() 
{
    if (!UpdateData ())
    {
        return;
    }
    if (!FaxUnregisterServiceProviderEx(m_hFax, m_cstrGUID))
    {
        CString cs;
        cs.Format ("Failed while calling FaxUnregisterServiceProviderEx (%ld)", 
                   GetLastError ());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    else
    {
        AfxMessageBox ("FSP successfully removed. You need to restart the service for the change to take effect", MB_OK | MB_ICONHAND);
    }
}

void
CRemoveFSPDlg::RefreshList ()
{
    PFAX_DEVICE_PROVIDER_INFO pFSPs;
    DWORD   dwNumFSPs;
    CString cs;

    m_cbFSPs.ResetContent ();
    if (!FaxEnumerateProviders (m_hFax, &pFSPs, &dwNumFSPs))
    {
        cs.Format ("Failed while calling FaxEnumerateProviders (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    for (DWORD dw = 0; dw < dwNumFSPs; dw++)
    {
                
        int iIndex = m_cbFSPs.AddString (pFSPs[dw].lpctstrFriendlyName);
		CString *pCString = new CString (pFSPs[dw].lpctstrGUID);
        m_cbFSPs.SetItemData (iIndex, (DWORD) pCString);
    }
    if (!dwNumFSPs)
    {
        m_cbFSPs.EnableWindow (FALSE);
    }
    else
    {
        m_cbFSPs.SetCurSel (0);
		DWORD dwData = m_cbFSPs.GetItemData (0);
        m_cstrGUID = *((CString *)(dwData));
    }           
    UpdateData (FALSE);
    FaxFreeBuffer (LPVOID(pFSPs));
}

BOOL CRemoveFSPDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	
    RefreshList ();
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CRemoveFSPDlg::OnSelChangeCombo() 
{
    int iIndex = m_cbFSPs.GetCurSel ();	
    if (CB_ERR == iIndex)
    {
        return;
    }
    m_cstrGUID = *((CString *)(m_cbFSPs.GetItemData (iIndex)));
    UpdateData (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\removertext.cpp ===
// RemoveRtExt.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "RemoveRtExt.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

#include "..\..\..\inc\fxsapip.h"
#define USE_EXTENDED_FSPI
#include "..\..\..\inc\faxdev.h"
#include "..\..\inc\efspimp.h"


/////////////////////////////////////////////////////////////////////////////
// CRemoveRtExt dialog


CRemoveRtExt::CRemoveRtExt(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CRemoveRtExt::IDD, pParent),
      m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CRemoveRtExt)
	m_cstrExtName = _T("");
	//}}AFX_DATA_INIT
}


void CRemoveRtExt::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CRemoveRtExt)
	DDX_Text(pDX, IDC_EXTNAME, m_cstrExtName);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRemoveRtExt, CDialog)
	//{{AFX_MSG_MAP(CRemoveRtExt)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRemoveRtExt message handlers

void CRemoveRtExt::OnOK() 
{
    if (!UpdateData ())
    {
        return;
    }
    if (!FaxUnregisterRoutingExtension(m_hFax, m_cstrExtName))
    {
        CString cs;
        cs.Format ("Failed while calling FaxUnregisterRoutingExtension (%ld)", 
                   GetLastError ());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    else
    {
        AfxMessageBox ("Routing extension successfully removed. You need to restart the service for the change to take effect", MB_OK | MB_ICONHAND);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\removefspdlg.h ===
#if !defined(AFX_REMOVEFSPDLG_H__3B29E60C_7CE3_484D_9E80_B2B610E9B53D__INCLUDED_)
#define AFX_REMOVEFSPDLG_H__3B29E60C_7CE3_484D_9E80_B2B610E9B53D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RemoveFSPDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRemoveFSPDlg dialog

class CRemoveFSPDlg : public CDialog
{
// Construction
public:
	CRemoveFSPDlg(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRemoveFSPDlg)
	enum { IDD = IDD_REMOVEFSP_DLG };
	CComboBox	m_cbFSPs;
	CString	m_cstrGUID;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRemoveFSPDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRemoveFSPDlg)
	afx_msg void OnRemove();
	virtual BOOL OnInitDialog();
	afx_msg void OnSelChangeCombo();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
    HANDLE                         m_hFax;

    void RefreshList ();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMOVEFSPDLG_H__3B29E60C_7CE3_484D_9E80_B2B610E9B53D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\smtpdlg.h ===
#if !defined(AFX_SMTPDLG_H__8192D075_4E05_4E2D_BA89_1C8F55A29EEA__INCLUDED_)
#define AFX_SMTPDLG_H__8192D075_4E05_4E2D_BA89_1C8F55A29EEA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// SMTPDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CSMTPDlg dialog

class CSMTPDlg : public CDialog
{
// Construction
public:
	CSMTPDlg(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CSMTPDlg)
	enum { IDD = IDD_SMTP };
	CString	m_cstrPassword;
	CString	m_cstrServerName;
	UINT	m_dwServerPort;
	CString	m_cstrUserName;
	CString	m_cstrMAPIProfile;
	CString	m_cstrSender;
	UINT	m_dwReceiptsOpts;
	UINT	m_dwSMTPAuth;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSMTPDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CSMTPDlg)
	afx_msg void OnRead();
	afx_msg void OnWrite();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:

    HANDLE      m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SMTPDLG_H__8192D075_4E05_4E2D_BA89_1C8F55A29EEA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ConfigTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\smtpdlg.cpp ===
// SMTPDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ConfigTest.h"
#include "SMTPDlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

typedef unsigned long ULONG_PTR, *PULONG_PTR;
typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;
#include "..\..\..\inc\fxsapip.h"

/////////////////////////////////////////////////////////////////////////////
// CSMTPDlg dialog


CSMTPDlg::CSMTPDlg(HANDLE hFax, CWnd* pParent /*=NULL*/)
	: CDialog(CSMTPDlg::IDD, pParent), m_hFax (hFax)
{
	//{{AFX_DATA_INIT(CSMTPDlg)
	m_cstrPassword = _T("");
	m_cstrServerName = _T("");
	m_dwServerPort = 0;
	m_cstrUserName = _T("");
	m_cstrMAPIProfile = _T("");
	m_cstrSender = _T("");
	m_dwReceiptsOpts = 0;
	m_dwSMTPAuth = 0;
	//}}AFX_DATA_INIT
}


void CSMTPDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CSMTPDlg)
	DDX_Text(pDX, IDC_EDIT_PASSWORD, m_cstrPassword);
	DDX_Text(pDX, IDC_EDIT_SERVER_NAME, m_cstrServerName);
	DDX_Text(pDX, IDC_EDIT_SERVER_PORT, m_dwServerPort);
	DDV_MinMaxUInt(pDX, m_dwServerPort, 1, 65535);
	DDX_Text(pDX, IDC_EDIT_USER_NAME, m_cstrUserName);
	DDX_Text(pDX, IDC_EDIT_MAPI_PROFILE, m_cstrMAPIProfile);
	DDX_Text(pDX, IDC_EDIT_SENDER, m_cstrSender);
	DDX_Text(pDX, IDC_REC_OPTIONS, m_dwReceiptsOpts);
	DDV_MinMaxUInt(pDX, m_dwReceiptsOpts, 0, 7);
	DDX_Text(pDX, IDC_SMTP_AUTH, m_dwSMTPAuth);
	DDV_MinMaxUInt(pDX, m_dwSMTPAuth, 0, 2);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CSMTPDlg, CDialog)
	//{{AFX_MSG_MAP(CSMTPDlg)
	ON_BN_CLICKED(IDC_READ, OnRead)
	ON_BN_CLICKED(IDC_WRITE, OnWrite)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CSMTPDlg message handlers

void CSMTPDlg::OnRead() 
{
    PFAX_RECEIPTS_CONFIG pCfg;
    if (!FaxGetReceiptsConfiguration (m_hFax, &pCfg))
    {
        CString cs;
        cs.Format ("Failed while calling FaxGetReceiptsConfiguration (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
    m_cstrServerName = pCfg->lptstrSMTPServer;
    m_dwServerPort   = pCfg->dwSMTPPort;
    m_cstrUserName   = pCfg->lptstrSMTPUserName;
    m_cstrPassword   = pCfg->lptstrSMTPPassword;
//	m_cstrMAPIProfile = pCfg->lptstrMAPIProfile;
	m_cstrSender = pCfg->lptstrSMTPFrom;
	m_dwReceiptsOpts = pCfg->dwAllowedReceipts;
	m_dwSMTPAuth = pCfg->SMTPAuthOption;

    UpdateData (FALSE);
    FaxFreeBuffer (LPVOID(pCfg));
}

void CSMTPDlg::OnWrite() 
{
    UpdateData ();
    FAX_RECEIPTS_CONFIG cfg;
    cfg.dwSizeOfStruct = sizeof (FAX_RECEIPTS_CONFIG);
    cfg.lptstrSMTPServer = LPTSTR(LPCTSTR(m_cstrServerName));
    cfg.dwSMTPPort    = m_dwServerPort;
    cfg.lptstrSMTPUserName = LPTSTR(LPCTSTR(m_cstrUserName));
    cfg.lptstrSMTPPassword = LPTSTR(LPCTSTR(m_cstrPassword));
//	cfg.lptstrMAPIProfile = LPTSTR(LPCTSTR(m_cstrMAPIProfile));
	cfg.lptstrSMTPFrom = LPTSTR(LPCTSTR(m_cstrSender));
	cfg.dwAllowedReceipts = m_dwReceiptsOpts;
	cfg.SMTPAuthOption = (FAX_ENUM_SMTP_AUTH_OPTIONS)m_dwSMTPAuth;
    if (!FaxSetReceiptsConfiguration (m_hFax, &cfg))
    {
        CString cs;
        cs.Format ("Failed while calling FaxSetReceiptsConfiguration (%ld)", GetLastError());
        AfxMessageBox (cs, MB_OK | MB_ICONHAND);
        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ConfigTest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_CONFIGTEST_DIALOG           102
#define IDR_MAINFRAME                   128
#define IDD_QUEUESTATE                  129
#define IDD_SMTP                        130
#define IDD_DLGVERSION                  131
#define IDD_DLGOUTBOX                   132
#define IDD_ARCHIVEDLG                  133
#define IDD_ACTIVITYLOGGING_DLG         134
#define IDD_DLG_ENUM_FSP                135
#define IDD_DLGDEVICES                  136
#define IDD_DLGDEVICE                   137
#define IDD_DLGEXTENSION                138
#define IDD_ADDGROUP_DLG                140
#define IDD_ADDFSP_DLG                  141
#define IDD_REMOVEFSP_DLG               142
#define IDD_ARCHIVE_ACCESS              144
#define IDD_MSG_DLG                     145
#define IDD_TIFF_DLG                    146
#define IDD_REMOVE_R_EXT                147
#define IDD_MANUAL_ANSWER               148
#define IDC_QUEUESTATE                  1000
#define IDC_INCOMING_BLOCKED            1001
#define IDC_SMTP                        1001
#define IDC_OUTBOX_BLOCKED              1002
#define IDC_VERSION                     1002
#define IDC_OUTBOX_PAUSED               1003
#define IDC_OUTBOX                      1003
#define IDC_WRITE                       1004
#define IDC_SENTITEMS                   1004
#define IDC_READ                        1005
#define IDC_INBOX                       1005
#define IDC_EDIT1                       1006
#define IDC_SENDITEMS                   1006
#define IDC_CONNECT                     1007
#define IDC_QUEUE                       1007
#define IDC_EDIT_SERVER_NAME            1008
#define IDC_ACTIVITY                    1008
#define IDC_EDIT_SERVER_PORT            1009
#define IDC_TIFF                        1009
#define IDC_EDIT_USER_NAME              1010
#define IDC_MANUAL_ANSWER               1010
#define IDC_EDIT_PASSWORD               1011
#define IDC_EDIT_MAPI_PROFILE           1012
#define IDC_SERVERVERSION               1013
#define IDC_EDIT_SENDER                 1013
#define IDC_PERSONALCP                  1014
#define IDC_USERDEVICETSID              1015
#define IDC_RETRIES                     1016
#define IDC_RETRYDELAY                  1017
#define IDC_STARTH                      1018
#define IDC_STARTM                      1019
#define IDC_ENDH                        1020
#define IDC_ENDM                        1021
#define IDC_AGELIMIT                    1022
#define IDC_BRANDING                    1023
#define IDC_USE                         1025
#define IDC_FOLDER                      1026
#define IDC_WARN                        1027
#define IDC_FOLDER2                     1027
#define IDC_ID                          1027
#define IDC_HIGH_WM                     1028
#define IDC_FOLDER3                     1028
#define IDC_TYPE                        1028
#define IDC_LOW_WM                      1029
#define IDC_FOLDER4                     1029
#define IDS_SIZE                        1029
#define IDC_AGE_LIMIT                   1030
#define IDC_FOLDER5                     1031
#define IDC_PAGES                       1031
#define IDC_CHK_OUT                     1032
#define IDC_CHK_IN                      1033
#define IDC_FOLDER7                     1033
#define IDC_R_NUMBER                    1033
#define IDC_DBFILE                      1034
#define IDC_FOLDER8                     1034
#define IDC_R_NAME                      1034
#define IDC_FOLDER9                     1035
#define IDC_S_NUMBER                    1035
#define IDC_NUMFSP                      1036
#define IDC_FOLDER10                    1036
#define IDC_S_NAME                      1036
#define IDC_FSPS                        1037
#define IDC_FOLDER11                    1037
#define IDC_TSID_VAL                    1037
#define IDC_REFRESH                     1038
#define IDC_DEVICES                     1038
#define IDC_FOLDER12                    1038
#define IDC_CSID_VAL                    1038
#define IDC_NUMDEVS                     1039
#define IDC_EXTENSION                   1039
#define IDC_FOLDER13                    1039
#define IDC_SEND_USER                   1039
#define IDC_DEVS                        1040
#define IDC_ADDGROUP                    1040
#define IDC_FOLDER14                    1040
#define IDC_BILLING                     1040
#define IDC_ADDFSP                      1041
#define IDC_FOLDER15                    1041
#define IDC_ORIGTIME                    1041
#define IDC_DEVID                       1042
#define IDC_REMOVEFSP                   1042
#define IDC_FOLDER16                    1042
#define IDC_SUBMITTIME                  1042
#define IDC_DEVNAME                     1043
#define IDC_ARCHIVEACCESS               1043
#define IDC_FOLDER17                    1043
#define IDC_START_TIME                  1043
#define IDC_DESCRIPTION                 1044
#define IDC_FOLDER18                    1044
#define IDC_END_TIME                    1044
#define IDC_REMOVERR                    1044
#define IDC_SEND                        1045
#define IDC_PROVNAME                    1046
#define IDC_PROVGUID                    1047
#define IDC_FOLDER19                    1047
#define IDC_DEVICE                      1047
#define IDC_RECEIVE                     1048
#define IDC_FOLDER20                    1048
#define IDC_PRIORITY                    1048
#define IDC_RINGS                       1049
#define IDC_FOLDER21                    1049
#define IDC_SENDJOBS                    1050
#define IDC_FOLDER22                    1050
#define IDC_DOCUMENT                    1050
#define IDC_RECEIVEJOBS                 1051
#define IDC_FOLDER23                    1051
#define IDC_SUBJECT                     1051
#define IDC_CSID                        1052
#define IDC_FOLDER24                    1052
#define IDC_CALLERID                    1052
#define IDC_TSID                        1053
#define IDC_FOLDER25                    1053
#define IDC_ROUTINGINFO                 1053
#define IDC_CMDDEVICES                  1056
#define IDC_GUID                        1057
#define IDC_DATA                        1058
#define IDC_FRIENDLY_NAME               1058
#define ID_ADD                          1060
#define IDC_IMAGENAME                   1060
#define IDC_GROUP_NAME                  1061
#define IDC_TSPNAME                     1061
#define IDADD                           1062
#define IDC_VERSION1                    1063
#define IDC_VERSION2                    1064
#define IDC_FSPI_CAP_BROADCAST          1065
#define IDC_FSPI_CAP_MULTISEND          1066
#define IDREMOVE                        1066
#define IDC_FSPI_CAP_SCHEDULING         1067
#define IDC_COMBO                       1067
#define IDC_FSPI_CAP_ABORT_RECIPIENT    1068
#define IDC_FSPI_CAP_ABORT_PARENT       1069
#define IDC_FSPI_CAP_AUTO_RETRY         1070
#define IDC_FSPI_CAP_SIMULTANEOUS_SEND_RECEIVE 1071
#define IDC_NUMSGS                      1071
#define IDC_LIST                        1072
#define IDC_MSGSPERCALL                 1073
#define IDC_SPIN                        1074
#define IDC_DESTFILE                    1075
#define IDC_MGSID                       1076
#define IDC_COPY                        1077
#define IDC_EXTNAME                     1078
#define IDC_REC_OPTIONS                 1079
#define IDC_SMTP_AUTH                   1080
#define IDC_MAN_ANSWER_DEV_ID           1082
#define IDC_ANSWER_NEXT_CALL            1085

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        149
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1086
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\removertext.h ===
#if !defined(AFX_REMOVERTEXT_H__10E8F1F5_B418_40F5_B4C2_A6D0F837AA4B__INCLUDED_)
#define AFX_REMOVERTEXT_H__10E8F1F5_B418_40F5_B4C2_A6D0F837AA4B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// RemoveRtExt.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CRemoveRtExt dialog

class CRemoveRtExt : public CDialog
{
// Construction
public:
	CRemoveRtExt(HANDLE hFax, CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CRemoveRtExt)
	enum { IDD = IDD_REMOVE_R_EXT };
	CString	m_cstrExtName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CRemoveRtExt)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CRemoveRtExt)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
    HANDLE                         m_hFax;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_REMOVERTEXT_H__10E8F1F5_B418_40F5_B4C2_A6D0F837AA4B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\faxsvc\nt4client\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)        07-May-1991
    Paula Tomlinson (paulat)   06-June-1995    Modified for plug-and-play

Revision History:


--*/
#ifndef _IMPORTS_H
#define _IMPORTS_H

#include <windef.h>
#include <winbase.h>
#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPCWSTR [string] wchar_t*
#define HCALL DWORD
#endif

#include <fxsapip.h>

typedef enum {
    RECIPIENT_PERSONAL_PROF = 1,
    SENDER_PERSONAL_PROF
} FAX_ENUM_PERSONAL_PROF_TYPES;



#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#define LPCTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#define LPCTSTR [string] LPCTSTR
#endif
#define LPSTR [string] LPSTR
#define LPCSTR [string] LPCSTR
#define BOOL DWORD
#endif
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\faxsvc\ntclient\imports.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    imports.h

Abstract:

    This file allows us to include standard system header files in the
    .idl file.  The main .idl file imports a file called import.idl.
    This allows the .idl file to use the types defined in these header
    files.  It also causes the following line to be added in the
    MIDL generated header file:

    #include "imports.h"

    Thus these types are available to the RPC stub routines as well.

Author:

    Dan Lafferty (danl)        07-May-1991
    Paula Tomlinson (paulat)   06-June-1995    Modified for plug-and-play

Revision History:


--*/
#ifndef _IMPORTS_H
#define _IMPORTS_H

#include <windef.h>
#include <winbase.h>
#ifdef MIDL_PASS
#define LPWSTR [string] wchar_t*
#define LPCWSTR [string] wchar_t*
#define HCALL DWORD
#endif

#include <fxsapip.h>

typedef enum {
    RECIPIENT_PERSONAL_PROF = 1,
    SENDER_PERSONAL_PROF
} FAX_ENUM_PERSONAL_PROF_TYPES;



#ifdef MIDL_PASS
#ifdef UNICODE
#define LPTSTR [string] wchar_t*
#define LPCTSTR [string] wchar_t*
#else
#define LPTSTR [string] LPTSTR
#define LPCTSTR [string] LPCTSTR
#endif
#define LPSTR [string] LPSTR
#define LPCSTR [string] LPCSTR
#define BOOL DWORD
#endif
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\configtest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__02DD6606_0B2E_48E0_9917_055A6B606F38__INCLUDED_)
#define AFX_STDAFX_H__02DD6606_0B2E_48E0_9917_055A6B606F38__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__02DD6606_0B2E_48E0_9917_055A6B606F38__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\faxcli\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw) 10-Jan-96

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

!include ..\..\..\..\faxsrc.inc

TARGETPATH=obj
TARGETTYPE=NOTARGET

IDL_TYPE=RPC

MIDL_FLAGS=$(MIDL_FLAGS) -oldnames -out $(PASS0_HEADERDIR)\$(O) -I$(PASS0_HEADERDIR) -I$(FAXROOT)\service\rpc\faxcli

SOURCES= ..\faxcli.idl

SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\rpc\faxsvc\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Wesley Witt (wesw) 10-Jan-96

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF


!include ..\..\..\..\faxsrc.inc

TARGETPATH=obj
TARGETTYPE=NOTARGET

IDL_TYPE=RPC


MIDL_FLAGS=$(MIDL_FLAGS) -oldnames -out $(PASS0_HEADERDIR)\$(O) -I$(PASS0_HEADERDIR) -I$(FAXROOT)\service\rpc\faxsvc

SOURCES=..\faxrpc.idl

SYNCHRONIZE_BLOCK=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\events.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Events.h

Abstract:

    This file provides declaration of the service
    notification mechanism.

Author:

    Oded Sacher (OdedS)  Jan, 2000

Revision History:

--*/

#ifndef _SERVER_EVENTS_H
#define _SERVER_EVENTS_H

#include <map>
#include <queue>
#include <algorithm>
#include <string>

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
using namespace std;
#pragma hdrstop

#pragma warning (disable : 4786)    // identifier was truncated to '255' characters in the debug information
// This pragma does not work KB ID: Q167355

#define MAX_EVENTS_THREADS 2
#define TOTAL_EVENTS_THREADS    (MAX_EVENTS_THREADS * 2)
#define EVENT_COMPLETION_KEY					0x00000001
#define CLIENT_COMPLETION_KEY                   0x00000002
#define CLIENT_OPEN_CONN_COMPLETION_KEY         0x00000003


/************************************
*                                   *
*         CFaxEvent                 *
*                                   *
************************************/

class CFaxEvent
{
public:

    CFaxEvent() {}
    virtual ~CFaxEvent() {}
    virtual DWORD GetEvent (LPBYTE* lppBuffer, LPDWORD lpdwBufferSize) const = 0;
	virtual CFaxEvent* Clone() const = 0;	
	virtual BOOL MatchEvent(PSID pUserSid, DWORD dwEventType, BOOL , BOOL bAllOutArchiveMessages) const = 0;
	void RemoveOffendingExtendedJobStatus() {}

};  // CFaxEvent



/************************************
*                                   *
*        CFaxEventExtended          *
*                                   *
************************************/

class CFaxEventExtended : public CFaxEvent
{
public:

    CFaxEventExtended(const FAX_EVENT_EX* pEvent, DWORD dwEventSize, PSID pSid);    

    virtual ~CFaxEventExtended ()
    {
        MemFree ((void*)m_pEvent);
        m_pEvent = NULL;
		MemFree (m_pSid);
		m_pSid = NULL;
        m_dwEventSize = 0;
    }    

	virtual CFaxEvent* Clone() const
	{
        DEBUG_FUNCTION_NAME(TEXT("CFaxEventExtended::Clone"));
		CFaxEventExtended* pFaxExtendedEvent = NULL;

		try
		{
			pFaxExtendedEvent = new (std::nothrow) CFaxEventExtended (m_pEvent, m_dwEventSize, m_pSid);
		}
        catch (exception &ex)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("Exception: %S"),
                         ex.what()
                         );
        }
		return pFaxExtendedEvent;
	}

    virtual DWORD GetEvent (LPBYTE* lppBuffer, LPDWORD lpdwBufferSize) const;

	void RemoveOffendingExtendedJobStatus();

	virtual BOOL MatchEvent(PSID pUserSid, DWORD dwEventType, BOOL bAllQueueMessages, BOOL bAllOutArchiveMessages) const;


private:
    const FAX_EVENT_EX*     m_pEvent;
    DWORD                   m_dwEventSize;
	PSID					m_pSid;                   // Pointer to the SID associated with the event
};  // CFaxEventExtended


/************************************
*                                   *
*        CFaxEventLegacy            *
*                                   *
************************************/

class CFaxEventLegacy : public CFaxEvent
{
public:

    CFaxEventLegacy(const FAX_EVENT* pEvent);    

    virtual ~CFaxEventLegacy ()
    {
        MemFree ((void*)m_pEvent);
        m_pEvent = NULL;		
    }    

	virtual CFaxEvent* Clone() const
	{
        DEBUG_FUNCTION_NAME(TEXT("CFaxEventLegacy::Clone"));
	
		CFaxEventLegacy* pFaxLegacyEvent = NULL;

		try
		{
			pFaxLegacyEvent = new (std::nothrow) CFaxEventLegacy (m_pEvent);
		}
        catch (exception &ex)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("Exception: %S"),
                         ex.what()
                         );
        }
		return pFaxLegacyEvent;		
	}

    virtual DWORD GetEvent (LPBYTE* lppBuffer, LPDWORD lpdwBufferSize) const;		

	virtual BOOL MatchEvent(PSID pUserSid, DWORD dwEvenTtype, BOOL bAllQueueMessages, BOOL bAllOutArchiveMessages) const;

private:
    const FAX_EVENT*     m_pEvent;
};  // CFaxEventExtended


/************************************
*                                   *
*         CClientID                 *
*                                   *
************************************/
class CClientID
{
public:
    CClientID (DWORDLONG dwlClientID, LPCWSTR lpcwstrMachineName, LPCWSTR lpcwstrEndPoint, ULONG64 Context)
    {
        HRESULT hr;

		Assert (lpcwstrMachineName && lpcwstrEndPoint && Context);           

        m_dwlClientID = dwlClientID;
        hr = StringCchCopy (m_wstrMachineName, ARR_SIZE(m_wstrMachineName), lpcwstrMachineName);
		if (FAILED(hr))
		{
			ASSERT_FALSE;
		}

		hr = StringCchCopy (m_wstrEndPoint, ARR_SIZE(m_wstrEndPoint), lpcwstrEndPoint);
		if (FAILED(hr))
		{
			ASSERT_FALSE;
		}        
        m_Context = Context;
    }

    CClientID (const CClientID& rhs)
    {
        m_dwlClientID = rhs.m_dwlClientID;
        wcscpy (m_wstrMachineName, rhs.m_wstrMachineName);
        wcscpy (m_wstrEndPoint, rhs.m_wstrEndPoint);
        m_Context = rhs.m_Context;
    }

    ~CClientID ()
    {
        ZeroMemory (this, sizeof(CClientID));
    }

    bool operator < ( const CClientID &other ) const;

    CClientID& operator= (const CClientID& rhs)
    {
        if (this == &rhs)
        {
            return *this;
        }
        m_dwlClientID = rhs.m_dwlClientID;
        wcscpy (m_wstrMachineName, rhs.m_wstrMachineName);
        wcscpy (m_wstrEndPoint, rhs.m_wstrEndPoint);
        m_Context = rhs.m_Context;
        return *this;
    }

    ULONG64 GetContext() const { return m_Context; }
    DWORDLONG GetID() const { return m_dwlClientID; }

private:
    DWORDLONG           m_dwlClientID;
    WCHAR               m_wstrMachineName[MAX_COMPUTERNAME_LENGTH + 1]; // Machine name
    WCHAR               m_wstrEndPoint[MAX_ENDPOINT_LEN];               // End point used for RPC connection
    ULONG64             m_Context;                                      // context  (Client assync info)

};  // CClientID



typedef queue<CFaxEvent*> CLIENT_EVENTS, *PCLIENT_EVENTS;

/************************************
*                                   *
*         CClient                   *
*                                   *
************************************/
class CClient
{
public:
    CClient (CClientID ClientID,
             PSID pUserSid,
             DWORD dwEventTypes,
             HANDLE hFaxHandle,
             BOOL bAllQueueMessages,
             BOOL bAllOutArchiveMessages,
             DWORD dwAPIVersion);

    CClient (const CClient& rhs);

    ~CClient ();
    

    CClient& operator= (const CClient& rhs);
    const CClientID& GetClientID () const { return m_ClientID; }
    DWORD AddEvent (CFaxEvent* pFaxEvent);    
    DWORD GetEvent (LPBYTE* lppBuffer, LPDWORD lpdwBufferSize, PHANDLE phClientContext) const;
    DWORD DelEvent ();
    BOOL  IsConnectionOpened() const { return (m_hFaxClientContext != NULL); }
    VOID  SetContextHandle(HANDLE hContextHandle) { m_hFaxClientContext = hContextHandle; }
	HANDLE GetContextHandle () const { return m_hFaxClientContext; } 
    HANDLE GetFaxHandle() const { return m_FaxHandle; }
    DWORD GetAPIVersion() const { return m_dwAPIVersion; }
	BOOL IsLegacyClient() const { return (FAX_EVENT_TYPE_LEGACY == m_dwEventTypes); }
	DWORD Release() { return (m_dwRefCount ? --m_dwRefCount : 1); }  // There might be race between 2 or more threads trying to destroy the same client
	VOID Lock() { m_dwRefCount++; }
	DWORD GetRefCount()const { return m_dwRefCount; }

private:
    HANDLE              m_FaxHandle;                  // binding handle FaxBindToFaxClient
    DWORD               m_dwEventTypes;               // Bit wise combination of FAX_ENUM_EVENT_TYPE
    PSID                m_pUserSid;                   // Pointer to the user SID
    CLIENT_EVENTS       m_Events;
    HANDLE              m_hFaxClientContext;          // Client context handle
    CClientID           m_ClientID;
    BOOL                m_bPostClientID;              // Flag that indicates whether to notify the service (using the events
                                                      // completion port) that this client has events.
    BOOL                m_bAllQueueMessages;          //  flag that indicates Outbox view rights.
    BOOL                m_bAllOutArchiveMessages;     //  flag that indicates Sent items view rights.
    DWORD               m_dwAPIVersion;               // API version of the client
	DWORD				m_dwRefCount;				  // Handles the object refernce count
};  // CClient

typedef CClient  *PCCLIENT;


/***********************************\
*                                   *
*     CClientsMap                   *
*                                   *
\***********************************/

typedef map<CClientID, CClient>  CLIENTS_MAP, *PCLIENTS_MAP;

//
// The CClientsMap class maps between client ID and a specific client
//
class CClientsMap
{
public:
    CClientsMap () {}
    ~CClientsMap () {}

    DWORD AddClient (const CClient& Client);
    DWORD ReleaseClient (const CClientID& ClientID, BOOL fRunDown = FALSE);
    PCCLIENT  FindClient (const CClientID& ClientID) const;
    DWORD AddEvent (CFaxEvent* pFaxEvent);
    DWORD Notify (const CClientID& ClientID);
    DWORD OpenClientConnection (const CClientID& ClientID);

private:
    CLIENTS_MAP   m_ClientsMap;	
};  // CClientsMap



/************************************
*                                   *
*         Externes                  *
*                                   *
************************************/

extern CClientsMap* g_pClientsMap;					// Map of clients ID to client.
extern HANDLE       g_hDispatchEventsCompPort;		// Events completion port. The events are dispatched to the client in the client map.
extern HANDLE		g_hSendEventsCompPort;			// Completion port of client IDs that have events in their queue.
//The events mechanism uses 2 completion ports. 
//	1.	g_hDispatchEventsCompPort, is monitored by 1 thread only!!!, and is responsible for dispatching the events to each one of the registered clients events queue. It is important that only 1 thread will dispatch the events, so the order of the events will be retained.
//	2.	g_hSendEventsCompPort is monitored by TOTAL_EVENTS_THREADS, and is responsible for sending the events to the remote clients over RPC.

extern DWORDLONG    g_dwlClientID;					// Client ID


//
//  IMPORTANT - No locking mechanism - USE g_CsClients to serialize calls to g_pClientsMap
//

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\archive.h ===
#ifndef _FAX_ARCHIVE
#define _FAX_ARCHIVE


const FMTID FMTID_FaxProperties  = { 0x6c77ed37, 0x1f3e, 0x4b0a, { 0x9b, 0x89, 0xcd, 0x7f, 0x35, 0xbb, 0x42, 0x82 } };
// 6c77ed37-1f3e-4b0a-9b89-cd7f35bb4282

typedef struct _FAX_QUOTA_WARN {
    BOOL    bLoggedQuotaEvent;     // TRUE if an archive quota warning event was alreagy logged
    BOOL    bConfigChanged;        // TRUE when ever the archive configuration has changed.
                                   // The quota warning thread sets it to FASLE when he wakes up.
} FAX_QUOTA_WARN;

extern FAX_QUOTA_WARN      g_FaxQuotaWarn[2];
extern HANDLE    g_hArchiveQuotaWarningEvent;

#define PID_FAX_MESSAGE_START            100

#define PID_FAX_CSID                     100
#define PID_FAX_TSID                     101
#define PID_FAX_PORT                     102
#define PID_FAX_ROUTING                  103
#define PID_FAX_CALLERID                 104
#define PID_FAX_DOCUMENT                 105
#define PID_FAX_SUBJECT                  106
#define PID_FAX_RETRIES                  107
#define PID_FAX_PRIORITY                 108
#define PID_FAX_PAGES                    109
#define PID_FAX_TYPE                     110
#define PID_FAX_START_TIME               111
#define PID_FAX_END_TIME                 112
#define PID_FAX_SUBMISSION_TIME          113
#define PID_FAX_ORIGINAL_SCHED_TIME      114
#define PID_FAX_SENDER_USER_NAME         115
#define PID_FAX_STATUS                   116
#define PID_FAX_STATUS_EX                117
#define PID_FAX_STATUS_STR_EX            118
#define PID_FAX_BROADCAST_ID             119

#define PID_FAX_MESSAGE_END              119


#define PID_FAX_RECIP_START              200

#define PID_FAX_RECIP_NAME               200
#define PID_FAX_RECIP_NUMBER             201
#define PID_FAX_RECIP_COMPANY            202
#define PID_FAX_RECIP_STREET             203
#define PID_FAX_RECIP_CITY               204
#define PID_FAX_RECIP_STATE              205
#define PID_FAX_RECIP_ZIP                206
#define PID_FAX_RECIP_COUNTRY            207
#define PID_FAX_RECIP_TITLE              208
#define PID_FAX_RECIP_DEPARTMENT         209
#define PID_FAX_RECIP_OFFICE_LOCATION    210
#define PID_FAX_RECIP_HOME_PHONE         211
#define PID_FAX_RECIP_OFFICE_PHONE       212
#define PID_FAX_RECIP_EMAIL              213

#define PID_FAX_RECIP_END                213


#define PID_FAX_SENDER_START             300

#define PID_FAX_SENDER_BILLING           300
#define PID_FAX_SENDER_NAME              301
#define PID_FAX_SENDER_NUMBER            302
#define PID_FAX_SENDER_COMPANY           303
#define PID_FAX_SENDER_STREET            304
#define PID_FAX_SENDER_CITY              305
#define PID_FAX_SENDER_STATE             306
#define PID_FAX_SENDER_ZIP               307
#define PID_FAX_SENDER_COUNTRY           308
#define PID_FAX_SENDER_TITLE             309
#define PID_FAX_SENDER_DEPARTMENT        310
#define PID_FAX_SENDER_OFFICE_LOCATION   311
#define PID_FAX_SENDER_HOME_PHONE        312
#define PID_FAX_SENDER_OFFICE_PHONE      313
#define PID_FAX_SENDER_EMAIL             314
#define PID_FAX_SENDER_TSID              315

#define PID_FAX_SENDER_END               315


BOOL GetUniqueJobIdFromFileName (
    LPCWSTR lpctstrFileName,
    DWORDLONG* pdwlUniqueJobId
    );

BOOL GetMessageMsTags(
    LPCTSTR         lpctstrFileName,
    PFAX_MESSAGE    pMessage
    );

BOOL GetFaxSenderMsTags(
    LPCTSTR                 lpctstrFileName,
    PFAX_PERSONAL_PROFILE   pPersonalProfile
    );

BOOL GetFaxRecipientMsTags(
    LPCTSTR                 lpctstrFileName,
    PFAX_PERSONAL_PROFILE   pPersonalProfile
    );

BOOL
AddNTFSStorageProperties(
    LPTSTR          FileName,
    PMS_TAG_INFO    MsTagInfo,
    BOOL            fSendJob
    );

BOOL GetMessageNTFSStorageProperties(
    LPCTSTR         lpctstrFileName,
    PFAX_MESSAGE    pMessage
    );

BOOL GetPersonalProfNTFSStorageProperties(
    LPCTSTR                         lpctstrFileName,
    FAX_ENUM_PERSONAL_PROF_TYPES    PersonalProfType,
    PFAX_PERSONAL_PROFILE           pPersonalProfile
    );


LPWSTR
GetRecievedMessageFileName(
    IN DWORDLONG                dwlUniqueId
    );

LPWSTR
GetSentMessageFileName(
    IN DWORDLONG                dwlUniqueId,
    IN PSID                     pSid
    );

DWORD
IsValidArchiveFolder (
    LPWSTR                      lpwstrFolder,
    FAX_ENUM_MESSAGE_FOLDER     Folder
);

BOOL
GetMessageIdAndUserSid (
    LPCWSTR lpcwstrFullPathFileName,
    FAX_ENUM_MESSAGE_FOLDER Folder,
    PSID*   lppUserSid,
    DWORDLONG* pdwlMessageId
    );

DWORD
InitializeServerQuota ();

BOOL
GetArchiveSize(
    LPCWSTR lpcwstrArchive,
    DWORDLONG* lpdwlArchiveSize
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\archive.c ===
#include "faxsvc.h"
#include "faxreg.h"
#include "archive.h"

static PROPSPEC const pspecFaxMessage[] =
{
    {PRSPEC_PROPID, PID_FAX_CSID},
    {PRSPEC_PROPID, PID_FAX_TSID},
    {PRSPEC_PROPID, PID_FAX_PORT},
    {PRSPEC_PROPID, PID_FAX_ROUTING},
    {PRSPEC_PROPID, PID_FAX_CALLERID},
    {PRSPEC_PROPID, PID_FAX_DOCUMENT},
    {PRSPEC_PROPID, PID_FAX_SUBJECT},
    {PRSPEC_PROPID, PID_FAX_RETRIES},
    {PRSPEC_PROPID, PID_FAX_PRIORITY},
    {PRSPEC_PROPID, PID_FAX_PAGES},
    {PRSPEC_PROPID, PID_FAX_TYPE},
    {PRSPEC_PROPID, PID_FAX_START_TIME},
    {PRSPEC_PROPID, PID_FAX_END_TIME},
    {PRSPEC_PROPID, PID_FAX_SUBMISSION_TIME},
    {PRSPEC_PROPID, PID_FAX_ORIGINAL_SCHED_TIME},
    {PRSPEC_PROPID, PID_FAX_SENDER_USER_NAME},
    {PRSPEC_PROPID, PID_FAX_RECIP_NAME},
    {PRSPEC_PROPID, PID_FAX_RECIP_NUMBER},
    {PRSPEC_PROPID, PID_FAX_SENDER_NAME},
    {PRSPEC_PROPID, PID_FAX_SENDER_NUMBER},
    {PRSPEC_PROPID, PID_FAX_SENDER_BILLING},
    {PRSPEC_PROPID, PID_FAX_STATUS},
    {PRSPEC_PROPID, PID_FAX_STATUS_EX},
    {PRSPEC_PROPID, PID_FAX_STATUS_STR_EX},
    {PRSPEC_PROPID, PID_FAX_BROADCAST_ID}
};
#define FAX_MESSAGE_PROPERTIES (sizeof(pspecFaxMessage)/sizeof(pspecFaxMessage[0]))

static PROPSPEC const pspecFaxRecipient[] =
{
    {PRSPEC_PROPID, PID_FAX_RECIP_NAME},
    {PRSPEC_PROPID, PID_FAX_RECIP_NUMBER},
    {PRSPEC_PROPID, PID_FAX_RECIP_COMPANY},
    {PRSPEC_PROPID, PID_FAX_RECIP_STREET},
    {PRSPEC_PROPID, PID_FAX_RECIP_CITY},
    {PRSPEC_PROPID, PID_FAX_RECIP_STATE},
    {PRSPEC_PROPID, PID_FAX_RECIP_ZIP},
    {PRSPEC_PROPID, PID_FAX_RECIP_COUNTRY},
    {PRSPEC_PROPID, PID_FAX_RECIP_TITLE},
    {PRSPEC_PROPID, PID_FAX_RECIP_DEPARTMENT},
    {PRSPEC_PROPID, PID_FAX_RECIP_OFFICE_LOCATION},
    {PRSPEC_PROPID, PID_FAX_RECIP_HOME_PHONE},
    {PRSPEC_PROPID, PID_FAX_RECIP_OFFICE_PHONE},
    {PRSPEC_PROPID, PID_FAX_RECIP_EMAIL}
};
#define FAX_RECIP_PROPERTIES (sizeof(pspecFaxRecipient)/sizeof(pspecFaxRecipient[0]))


static PROPSPEC const pspecFaxSender[] =
{
    {PRSPEC_PROPID, PID_FAX_SENDER_BILLING},
    {PRSPEC_PROPID, PID_FAX_SENDER_NAME},
    {PRSPEC_PROPID, PID_FAX_SENDER_NUMBER},
    {PRSPEC_PROPID, PID_FAX_SENDER_COMPANY},
    {PRSPEC_PROPID, PID_FAX_SENDER_STREET},
    {PRSPEC_PROPID, PID_FAX_SENDER_CITY},
    {PRSPEC_PROPID, PID_FAX_SENDER_STATE},
    {PRSPEC_PROPID, PID_FAX_SENDER_ZIP},
    {PRSPEC_PROPID, PID_FAX_SENDER_COUNTRY},
    {PRSPEC_PROPID, PID_FAX_SENDER_TITLE},
    {PRSPEC_PROPID, PID_FAX_SENDER_DEPARTMENT},
    {PRSPEC_PROPID, PID_FAX_SENDER_OFFICE_LOCATION},
    {PRSPEC_PROPID, PID_FAX_SENDER_HOME_PHONE},
    {PRSPEC_PROPID, PID_FAX_SENDER_OFFICE_PHONE},
    {PRSPEC_PROPID, PID_FAX_SENDER_EMAIL},
    {PRSPEC_PROPID, PID_FAX_SENDER_TSID}
};
#define FAX_SENDER_PROPERTIES (sizeof(pspecFaxSender)/sizeof(pspecFaxSender[0]))


#define MAX_FAX_PROPERTIES  FAX_MESSAGE_PROPERTIES + FAX_RECIP_PROPERTIES + FAX_SENDER_PROPERTIES

#define QUOTA_WARNING_TIME_OUT          (1000*60*60*24) // 1 day,
                                                    // The quota warning thread checks the archive size each QUOTA_WARNING_TIME_OUT
#define QUOTA_REFRESH_COUNT             10          // Every QUOTA_REFRESH_COUNT the quota warning thread
                                                    // recalculate the archive folder size using FindFirst, FindNext
#define QUOTA_AUTO_DELETE_TIME_OUT      (1000*60*60*24) // 1 day,
                                                        // The quota auto delete thread deletes the archive old files each QUOTA_AUTO_DELETE_TIME_OUT

FAX_QUOTA_WARN  g_FaxQuotaWarn[2];
HANDLE    g_hArchiveQuotaWarningEvent;



//*********************************************************************************
//* Name:   GetMessageMsTags()
//* Author: Oded Sacher
//* Date:   Nov 8, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Fills FAX_MESSAGE structure.
//*     The caller must free all strings.
//*
//* PARAMETERS:
//*     [IN ]   LPCTSTR         lpctstrFileName
//*                 pointer to the file name.
//*
//*     [OUT]   PFAX_MESSAGE    pMessage
//*                 The FAX_MESSAGE structure to be filled.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*********************************************************************************
BOOL GetMessageMsTags(
    LPCTSTR         lpctstrFileName,
    PFAX_MESSAGE    pMessage
    )
{
    WORD                NumDirEntries;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    HANDLE              hMap = NULL;
    LPBYTE              fPtr = NULL;
    BOOL                RetVal = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("GetMessageMsTags"));
    PTIFF_TAG           pTiffTags;
    DWORD               i;
    DWORD               PrevTagId;
    FAX_MESSAGE         FaxMessage = {0};
    FILETIME            FaxTime;
    DWORD               ec = ERROR_SUCCESS;
    BOOL                fUnMapTiff = FALSE;
    DWORD               dwIfdOffset;

    Assert (pMessage != NULL);

    if (!MemoryMapTiffFile (lpctstrFileName, &FaxMessage.dwSize, &fPtr, &hFile, &hMap, &dwIfdOffset))
    {
        ec = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                  TEXT("MemoryMapTiffFile Failed, error: %ld"),
                  ec);
        goto error_exit;
    }
    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_SIZE;

    //
    // get the count of tags in this IFD
    //
    NumDirEntries = *(LPWORD)(fPtr + dwIfdOffset);
    pTiffTags = (PTIFF_TAG)(fPtr + dwIfdOffset +sizeof(WORD));

    //
    // walk the tags and pick out the info we need
    //
    for (i = 0, PrevTagId = 0; i < NumDirEntries; i++) {

        //
        // verify that the tags are in ascending order
        //
        if (pTiffTags[i].TagId < PrevTagId) {
            DebugPrintEx( DEBUG_ERR, TEXT("File %s, Invalid TIFF format"), lpctstrFileName);
            ec = ERROR_BAD_FORMAT;
            goto error_exit;
        }

        PrevTagId = pTiffTags[i].TagId;

        switch( pTiffTags[i].TagId ) {

            case TIFFTAG_TYPE:
                FaxMessage.dwJobType = pTiffTags[i].DataOffset;
                FaxMessage.dwValidityMask |= FAX_JOB_FIELD_TYPE;
                break;

            case TIFFTAG_PAGES:
                FaxMessage.dwPageCount = pTiffTags[i].DataOffset;
                FaxMessage.dwValidityMask |= FAX_JOB_FIELD_PAGE_COUNT;
                break;

            case TIFFTAG_PRIORITY:
                FaxMessage.Priority = (FAX_ENUM_PRIORITY_TYPE)pTiffTags[i].DataOffset;
                FaxMessage.dwValidityMask |= FAX_JOB_FIELD_PRIORITY;
                break;

            case TIFFTAG_STATUS:
                FaxMessage.dwQueueStatus = pTiffTags[i].DataOffset;
                FaxMessage.dwValidityMask |= FAX_JOB_FIELD_QUEUE_STATUS;
                break;

            case TIFFTAG_EXTENDED_STATUS:
                FaxMessage.dwExtendedStatus = pTiffTags[i].DataOffset;
                FaxMessage.dwValidityMask |= FAX_JOB_FIELD_STATUS_EX;
                break;

            case TIFFTAG_EXTENDED_STATUS_TEXT:
                FaxMessage.lpctstrExtendedStatus = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrExtendedStatus == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_BROADCAST_ID:
                if (!GetMsTagDwordLong(fPtr, FaxMessage.dwSize, &pTiffTags[i], &FaxMessage.dwlBroadcastId))
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagDwordLong failed"));
                    goto error_exit;
                }
                
                if(FaxMessage.dwlBroadcastId != 0)
                {
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_BROADCAST_ID;
                }
                break;

            case TIFFTAG_RECIP_NUMBER:
                FaxMessage.lpctstrRecipientNumber = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrRecipientNumber == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_NAME:
                FaxMessage.lpctstrRecipientName = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrRecipientName == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_TSID:
                FaxMessage.lpctstrTsid = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrTsid == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_CSID:
                FaxMessage.lpctstrCsid = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrCsid == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_USER_NAME:
                FaxMessage.lpctstrSenderUserName = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrSenderUserName == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_BILLING:
                FaxMessage.lpctstrBillingCode = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrBillingCode == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_FAX_START_TIME:
                if (!GetMsTagFileTime(fPtr, FaxMessage.dwSize, &pTiffTags[i], &FaxTime))
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagFileTime failed"));
                    goto error_exit;
                }
                if((DWORDLONG)0 != *(DWORDLONG*)&FaxTime)
                {
                    if (!FileTimeToSystemTime(&FaxTime, &FaxMessage.tmTransmissionStartTime))
                    {
                        ec = GetLastError();
                        DebugPrintEx( DEBUG_ERR, TEXT("FileTimeToSystemTime failed"));
                        goto error_exit;
                    }
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_TRANSMISSION_START_TIME;
                }
                break;

            case TIFFTAG_FAX_END_TIME:
                if (!GetMsTagFileTime(fPtr, FaxMessage.dwSize, &pTiffTags[i], &FaxTime))
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagFileTime failed"));
                    goto error_exit;
                }
                if((DWORDLONG)0 != *(DWORDLONG*)&FaxTime)
                {
                    if (!FileTimeToSystemTime(&FaxTime, &FaxMessage.tmTransmissionEndTime))
                    {
                        ec = GetLastError();
                        DebugPrintEx( DEBUG_ERR, TEXT("FileTimeToSystemTime failed"));
                        goto error_exit;
                    }
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_TRANSMISSION_END_TIME;
                }
                break;

            case TIFFTAG_FAX_SUBMISSION_TIME:
                if (!GetMsTagFileTime(fPtr, FaxMessage.dwSize, &pTiffTags[i], &FaxTime))
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagFileTime failed"));
                    goto error_exit;
                }
                if((DWORDLONG)0 != *(DWORDLONG*)&FaxTime)
                {
                    if (!FileTimeToSystemTime(&FaxTime, &FaxMessage.tmSubmissionTime))
                    {
                        ec = GetLastError();
                        DebugPrintEx( DEBUG_ERR, TEXT("FileTimeToSystemTime failed"));
                        goto error_exit;
                    }
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_SUBMISSION_TIME;
                }
                break;


            case TIFFTAG_FAX_SCHEDULED_TIME:
                if (!GetMsTagFileTime(fPtr, FaxMessage.dwSize, &pTiffTags[i], &FaxTime))
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagFileTime failed"));
                    goto error_exit;
                }
                if((DWORDLONG)0 != *(DWORDLONG*)&FaxTime)
                {
                    if (!FileTimeToSystemTime(&FaxTime, &FaxMessage.tmOriginalScheduleTime))
                    {
                        ec = GetLastError();
                        DebugPrintEx( DEBUG_ERR, TEXT("FileTimeToSystemTime failed"));
                        goto error_exit;
                    }
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME;
                }
                break;

            case TIFFTAG_PORT:
                FaxMessage.lpctstrDeviceName = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrDeviceName == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RETRIES:
                FaxMessage.dwRetries = pTiffTags[i].DataOffset;
                FaxMessage.dwValidityMask |= FAX_JOB_FIELD_RETRIES;
                break;

            case TIFFTAG_DOCUMENT:
                FaxMessage.lpctstrDocumentName = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrDocumentName == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SUBJECT:
                FaxMessage.lpctstrSubject = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrSubject == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_CALLERID:
                FaxMessage.lpctstrCallerID = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrCallerID == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_ROUTING:
                FaxMessage.lpctstrRoutingInfo = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrRoutingInfo == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_NAME:
                FaxMessage.lpctstrSenderName = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrSenderName == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_NUMBER:
                FaxMessage.lpctstrSenderNumber = GetMsTagString( fPtr, FaxMessage.dwSize, &pTiffTags[i]);
                if (FaxMessage.lpctstrSenderNumber == NULL)
                {
                    ec = GetLastError();
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            default:
                ;
                // There was an unknown tag (and it's ok,
                //cause we do not have to handle all the possible tags)
        }

    }

    //Get Unique JobId out of FileName
    if (!GetUniqueJobIdFromFileName( lpctstrFileName, &FaxMessage.dwlMessageId))
    {
       ec = ERROR_BAD_FORMAT;
       DebugPrintEx( DEBUG_ERR, TEXT("GetUniqueJobIdFromFileName Failed"));
       goto error_exit;
    }

    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_MESSAGE_ID;

    FaxMessage.dwSizeOfStruct = sizeof(FAX_MESSAGE);
    CopyMemory (pMessage, &FaxMessage, sizeof(FAX_MESSAGE));
    RetVal = TRUE;

    Assert (ec == ERROR_SUCCESS);

error_exit:
    if (fPtr != NULL)
    {
        if (!UnmapViewOfFile( fPtr))
        {
            DebugPrintEx( DEBUG_ERR,
                  TEXT("UnMapViewOfFile Failed, error: %d"),
                  GetLastError());
        }
    }

    if (hMap != NULL)
    {
        CloseHandle( hMap );
    }

    if (hFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hFile );
    }

    if (RetVal == FALSE)
    {
        MemFree((void*)FaxMessage.lpctstrExtendedStatus);
        MemFree((void*)FaxMessage.lpctstrRecipientNumber);
        MemFree((void*)FaxMessage.lpctstrRecipientName);
        MemFree((void*)FaxMessage.lpctstrTsid);
        MemFree((void*)FaxMessage.lpctstrCsid);
        MemFree((void*)FaxMessage.lpctstrSenderUserName);
        MemFree((void*)FaxMessage.lpctstrBillingCode);
        MemFree((void*)FaxMessage.lpctstrDeviceName);
        MemFree((void*)FaxMessage.lpctstrDocumentName);
        MemFree((void*)FaxMessage.lpctstrSubject);
        MemFree((void*)FaxMessage.lpctstrCallerID);
        MemFree((void*)FaxMessage.lpctstrRoutingInfo);
        MemFree((void*)FaxMessage.lpctstrSenderName);
        MemFree((void*)FaxMessage.lpctstrSenderNumber);

        Assert (ERROR_SUCCESS != ec);
        SetLastError(ec);
    }
    return RetVal;

}

//*********************************************************************************
//* Name:   GetFaxSenderMsTags()
//* Author: Oded Sacher
//* Date:   Nov 8, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Fills PFAX_PERSONAL_PROFILE structure with sender information.
//*     The caller must free all strings.
//*
//* PARAMETERS:
//*     [IN ]   LPCTSTR         lpctstrFileName
//*                 pointer to the file name.
//*
//*     [OUT]   PFAX_PERSONAL_PROFILE   pPersonalProfile
//*                 The PFAX_PERSONAL_PROFILE structure to be filled.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*********************************************************************************
BOOL GetFaxSenderMsTags(
    LPCTSTR                 lpctstrFileName,
    PFAX_PERSONAL_PROFILE   pPersonalProfile
    )
{
    WORD                    NumDirEntries;
    HANDLE                  hFile;
    HANDLE                  hMap = NULL;
    LPBYTE                  fPtr = NULL;
    BOOL                    RetVal = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("GetFaxSenderMsTags"));
    PTIFF_TAG               pTiffTags;
    DWORD                   i;
    DWORD                   PrevTagId;
    FAX_PERSONAL_PROFILE    FaxPersonalProfile = {0};
    DWORD                   dwSize;
    DWORD                   ec = ERROR_SUCCESS;
    DWORD                   dwIfdOffset;

    Assert (pPersonalProfile != NULL);

    if (!MemoryMapTiffFile (lpctstrFileName, &dwSize, &fPtr, &hFile, &hMap, &dwIfdOffset))
    {
        ec = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                  TEXT("MemoryMapTiffFile Failed, error: %ld"),
                  ec);
        goto error_exit;
    }

    //
    // get the count of tags in this IFD
    //
    NumDirEntries = *(LPWORD)(fPtr + dwIfdOffset);
    pTiffTags = (PTIFF_TAG)(fPtr + dwIfdOffset + sizeof(WORD));

    //
    // walk the tags and pick out the info we need
    //
    for (i = 0, PrevTagId = 0; i < NumDirEntries; i++) {

        //
        // verify that the tags are in ascending order
        //
        if (pTiffTags[i].TagId < PrevTagId) {
            DebugPrintEx( DEBUG_ERR, TEXT("File %s, Invalid TIFF format"), lpctstrFileName);
            goto error_exit;
        }

        PrevTagId = pTiffTags[i].TagId;

        switch( pTiffTags[i].TagId ) {

            case TIFFTAG_SENDER_NAME:
                FaxPersonalProfile.lptstrName = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrName == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_NUMBER:
                FaxPersonalProfile.lptstrFaxNumber = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrFaxNumber == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_COMPANY:
                FaxPersonalProfile.lptstrCompany = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrCompany == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_STREET:
                FaxPersonalProfile.lptstrStreetAddress = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrStreetAddress == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_CITY:
                FaxPersonalProfile.lptstrCity = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrCity == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_STATE:
                FaxPersonalProfile.lptstrState = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrState == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_ZIP:
                FaxPersonalProfile.lptstrZip = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrZip == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_COUNTRY:
                FaxPersonalProfile.lptstrCountry = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrCountry == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_TITLE:
                FaxPersonalProfile.lptstrTitle = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrTitle == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_DEPARTMENT:
                FaxPersonalProfile.lptstrDepartment = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrDepartment == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_OFFICE_LOCATION:
                FaxPersonalProfile.lptstrOfficeLocation = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrOfficeLocation == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_HOME_PHONE:
                FaxPersonalProfile.lptstrHomePhone = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrHomePhone == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_OFFICE_PHONE:
                FaxPersonalProfile.lptstrOfficePhone = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrOfficePhone == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_EMAIL:
                FaxPersonalProfile.lptstrEmail = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrEmail == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_BILLING:
                FaxPersonalProfile.lptstrBillingCode = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrBillingCode == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_SENDER_TSID:
                FaxPersonalProfile.lptstrTSID = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrTSID == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            default:
                ;
                // There was an unknown tag (and it's ok,
                //cause we do not have to handle all the possible tags)
        }

    }

    FaxPersonalProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    CopyMemory (pPersonalProfile, &FaxPersonalProfile, sizeof(FAX_PERSONAL_PROFILE));
    RetVal = TRUE;

error_exit:
    if (fPtr != NULL)
    {
        if (!UnmapViewOfFile( fPtr))
        {
            DebugPrintEx( DEBUG_ERR,
                  TEXT("UnMapViewOfFile Failed, error: %d"),
                  GetLastError());
        }
    }

    if (hMap != NULL)
    {
        CloseHandle( hMap );
    }

    if (hFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hFile );
    }

    if (RetVal == FALSE)
    {
        FreePersonalProfile (&FaxPersonalProfile, FALSE);
    }
    return RetVal;
}



//*********************************************************************************
//* Name:   GetFaxRecipientMsTags()
//* Author: Oded Sacher
//* Date:   Nov 8, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Fills PFAX_PERSONAL_PROFILE structure with recipient information.
//*     The caller must free all strings.
//*
//* PARAMETERS:
//*     [IN ]   LPCTSTR         lpctstrFileName
//*                 pointer to the file name.
//*
//*     [OUT]   PFAX_PERSONAL_PROFILE   pPersonalProfile
//*                 The PFAX_PERSONAL_PROFILE structure to be filled.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*********************************************************************************
BOOL GetFaxRecipientMsTags(
    LPCTSTR                 lpctstrFileName,
    PFAX_PERSONAL_PROFILE   pPersonalProfile
    )
{
    WORD                    NumDirEntries;
    HANDLE                  hFile;
    HANDLE                  hMap = NULL;
    LPBYTE                  fPtr = NULL;
    BOOL                    RetVal = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("GetRecipientMsTags"));
    PTIFF_TAG               pTiffTags;
    DWORD                   i;
    DWORD                   PrevTagId;
    FAX_PERSONAL_PROFILE    FaxPersonalProfile = {0};
    DWORD                   dwSize;
    DWORD                   ec = ERROR_SUCCESS;
    DWORD                   dwIfdOffset;

    Assert (pPersonalProfile != NULL);

    if (!MemoryMapTiffFile (lpctstrFileName, &dwSize, &fPtr, &hFile, &hMap, &dwIfdOffset))
    {
        ec = GetLastError();
        DebugPrintEx( DEBUG_ERR,
                  TEXT("MemoryMapTiffFile Failed, error: %ld"),
                  ec);
        goto error_exit;
    }

    //
    // get the count of tags in this IFD
    //
    NumDirEntries = *(LPWORD)(fPtr + dwIfdOffset);
    pTiffTags = (PTIFF_TAG)(fPtr + dwIfdOffset + sizeof(WORD));

    //
    // walk the tags and pick out the info we need
    //
    for (i = 0, PrevTagId = 0; i < NumDirEntries; i++) {

        //
        // verify that the tags are in ascending order
        //
        if (pTiffTags[i].TagId < PrevTagId) {
            DebugPrintEx( DEBUG_ERR, TEXT("File %s, Invalid TIFF format"), lpctstrFileName);
            goto error_exit;
        }

        PrevTagId = pTiffTags[i].TagId;

        switch( pTiffTags[i].TagId ) {

            case TIFFTAG_RECIP_NAME:
                FaxPersonalProfile.lptstrName = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrName == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_NUMBER:
                FaxPersonalProfile.lptstrFaxNumber = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrFaxNumber == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_COMPANY:
                FaxPersonalProfile.lptstrCompany = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrCompany == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_STREET:
                FaxPersonalProfile.lptstrStreetAddress = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrStreetAddress == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_CITY:
                FaxPersonalProfile.lptstrCity = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrCity == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_STATE:
                FaxPersonalProfile.lptstrState = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrState == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_ZIP:
                FaxPersonalProfile.lptstrZip = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrZip == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_COUNTRY:
                FaxPersonalProfile.lptstrCountry = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrCountry == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_TITLE:
                FaxPersonalProfile.lptstrTitle = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrTitle == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_DEPARTMENT:
                FaxPersonalProfile.lptstrDepartment = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrDepartment == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_OFFICE_LOCATION:
                FaxPersonalProfile.lptstrOfficeLocation = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrOfficeLocation == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_HOME_PHONE:
                FaxPersonalProfile.lptstrHomePhone = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrHomePhone == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_OFFICE_PHONE:
                FaxPersonalProfile.lptstrOfficePhone = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrOfficePhone == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            case TIFFTAG_RECIP_EMAIL:
                FaxPersonalProfile.lptstrEmail = GetMsTagString( fPtr, dwSize, &pTiffTags[i]);
                if (FaxPersonalProfile.lptstrEmail == NULL)
                {
                    DebugPrintEx( DEBUG_ERR, TEXT("GetMsTagString failed"));
                    goto error_exit;
                }
                break;

            default:
                ;
                // There was an unknown tag (and it's ok,
                //cause we do not have to handle all the possible tags)
        }

    }

    FaxPersonalProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    CopyMemory (pPersonalProfile, &FaxPersonalProfile, sizeof(FAX_PERSONAL_PROFILE));
    RetVal = TRUE;

error_exit:
    if (fPtr != NULL)
    {
        if (!UnmapViewOfFile( fPtr))
        {
            DebugPrintEx( DEBUG_ERR,
                  TEXT("UnMapViewOfFile Failed, error: %d"),
                  GetLastError());
        }
    }

    if (hMap != NULL)
    {
        CloseHandle( hMap );
    }

    if (hFile != INVALID_HANDLE_VALUE) {

        CloseHandle( hFile );
    }

    if (RetVal == FALSE)
    {
        FreePersonalProfile (&FaxPersonalProfile, FALSE);
    }
    return RetVal;
}



//*********************************************************************************
//* Name:   AddNTFSStorageProperties()
//* Author: Oded Sacher
//* Date:   Nov 8, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Adds NTFS Properties to a file
//*
//* PARAMETERS:
//*     [IN ]   LPTSTR          FileName
//*                 pointer to the file name.
//*
//*     [IN ]   PMS_TAG_INFO    MsTagInfo
//*                 pointer to a structure containing all info to be written.
//*
//*
//*     [IN ]   BOOL            fSendJob
//*                 Flag that indicates an outbound job.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*********************************************************************************
BOOL
AddNTFSStorageProperties(
    LPTSTR          FileName,
    PMS_TAG_INFO    MsTagInfo,
    BOOL            fSendJob
    )
{
    HRESULT hr;
    IPropertySetStorage* pPropertySetStorage = NULL;
    IPropertyStorage* pPropertyStorage = NULL;
    PROPSPEC rgpspec[MAX_FAX_PROPERTIES];
    PROPVARIANT rgvar [MAX_FAX_PROPERTIES];
    DWORD i;
    DEBUG_FUNCTION_NAME(TEXT("AddNTFSStorageProperties"));
    BOOL RetVal = FALSE;
    DWORD ec = ERROR_SUCCESS;

    for (i = 0; i < MAX_FAX_PROPERTIES; i++)
    {
        PropVariantInit (&rgvar[i]);
    }

    hr = StgOpenStorageEx(  FileName,    //Points to path of compound file to create
                            STGM_READWRITE | STGM_SHARE_EXCLUSIVE  | STGM_DIRECT,//Specifies the access mode for opening the storage object
                            STGFMT_FILE, //Specifies the storage file format
                            0,            //Reserved; must be zero
                            NULL,  //Points to STGOPTIONS structure which specifies features of the storage object
                            0,          //Reserved; must be zero
                            IID_IPropertySetStorage ,//Specifies the GUID of the interface pointer
                            (void**)&pPropertySetStorage   //Address of an interface pointer
                         );
    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("StgOpenStorageEx Failed, err : 0x%08X"), hr);
        ec = ERROR_OPEN_FAILED;
        goto exit;
    }

    hr = pPropertySetStorage->Create( FMTID_FaxProperties, //Format identifier of the property set to be created
                                      NULL, //Pointer to initial CLSID for this property set
                                      PROPSETFLAG_DEFAULT, //PROPSETFLAG values
                                      STGM_READWRITE | STGM_SHARE_EXCLUSIVE  | STGM_DIRECT, //Storage mode of new property set
                                      &pPropertyStorage //Address of output variable that receivesthe IPropertyStorage interface pointer
                                    );
    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("IPropertySetStorage::Create Failed, err : 0x%08X"), hr);
        ec = ERROR_OPEN_FAILED;
        goto exit;
    }


    //
    // write out the data
    //
    i = 0;

    if (MsTagInfo->Csid) {
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_CSID;
        rgvar[i].vt = VT_LPWSTR;
        rgvar[i].pwszVal = MsTagInfo->Csid;
        i++;
    }

    if (MsTagInfo->Tsid) {
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_TSID;
        rgvar[i].vt = VT_LPWSTR;
        rgvar[i].pwszVal = MsTagInfo->Tsid;
        i++;
    }

    if (MsTagInfo->Port) {
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_PORT;
        rgvar[i].vt = VT_LPWSTR;
        rgvar[i].pwszVal = MsTagInfo->Port;
        i++;
    }

    if (fSendJob == FALSE)
    {
        // Receive job
        if (MsTagInfo->Routing) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_ROUTING;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->Routing;
            i++;
        }

        if (MsTagInfo->CallerId) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_CALLERID;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->CallerId;
            i++;
        }
    }
    else
    {
        // Send job
        if (MsTagInfo->RecipName) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_NAME;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipName;
            i++;

        }

        if (MsTagInfo->RecipNumber) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_NUMBER;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipNumber;
            i++;
        }

        if (MsTagInfo->RecipCompany) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_COMPANY;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipCompany;
            i++;
        }

        if (MsTagInfo->RecipStreet) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_STREET;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipStreet;
            i++;
        }

        if (MsTagInfo->RecipCity) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_CITY;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipCity;
            i++;
        }

        if (MsTagInfo->RecipState) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_STATE;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipState;
            i++;
        }

        if (MsTagInfo->RecipZip) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_ZIP;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipZip;
            i++;
        }

        if (MsTagInfo->RecipCountry) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_COUNTRY;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipCountry;
            i++;
        }

        if (MsTagInfo->RecipTitle) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_TITLE;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipTitle;
            i++;
        }

        if (MsTagInfo->RecipDepartment) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_DEPARTMENT;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipDepartment;
            i++;
        }

        if (MsTagInfo->RecipOfficeLocation) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_OFFICE_LOCATION;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipOfficeLocation;
            i++;
        }

        if (MsTagInfo->RecipHomePhone) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_HOME_PHONE;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipHomePhone;
            i++;
        }

        if (MsTagInfo->RecipOfficePhone) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_OFFICE_PHONE;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipOfficePhone;
            i++;
        }

        if (MsTagInfo->RecipEMail) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_RECIP_EMAIL;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->RecipEMail;
            i++;
        }

        if (MsTagInfo-> SenderName) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_NAME;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderName;
            i++;
        }

        if (MsTagInfo-> SenderNumber) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_NUMBER;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderNumber;
            i++;
        }

        if (MsTagInfo-> SenderCompany) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_COMPANY;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderCompany;
            i++;
        }

        if (MsTagInfo-> SenderStreet) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_STREET;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderStreet;
            i++;
        }

        if (MsTagInfo-> SenderCity) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_CITY;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderCity;
            i++;
        }

        if (MsTagInfo-> SenderState) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_STATE;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderState;
            i++;
        }

        if (MsTagInfo-> SenderZip) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_ZIP;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderZip;
            i++;
        }

        if (MsTagInfo-> SenderCountry) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_COUNTRY;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderCountry;
            i++;
        }

        if (MsTagInfo-> SenderTitle) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_TITLE;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderTitle;
            i++;
        }

        if (MsTagInfo-> SenderDepartment) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_DEPARTMENT;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderDepartment;
            i++;
        }

        if (MsTagInfo-> SenderOfficeLocation) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_OFFICE_LOCATION;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderOfficeLocation;
            i++;
        }

        if (MsTagInfo-> SenderHomePhone) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_HOME_PHONE;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderHomePhone;
            i++;
        }

        if (MsTagInfo-> SenderOfficePhone) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_OFFICE_PHONE;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderOfficePhone;
            i++;
        }

        if (MsTagInfo-> SenderEMail) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_EMAIL;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderEMail;
            i++;
        }

        if (MsTagInfo->SenderBilling) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_BILLING;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderBilling;
            i++;
        }

        if (MsTagInfo->SenderUserName) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_USER_NAME;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderUserName;
            i++;
        }

        if (MsTagInfo->SenderTsid) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SENDER_TSID;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->SenderTsid;
            i++;
        }

        if (MsTagInfo->Document) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_DOCUMENT;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->Document;
            i++;
        }

        if (MsTagInfo->Subject) {
            rgpspec[i].ulKind = PRSPEC_PROPID;
            rgpspec[i].propid  = PID_FAX_SUBJECT;
            rgvar[i].vt = VT_LPWSTR;
            rgvar[i].pwszVal = MsTagInfo->Subject;
            i++;
        }

        // Deal with Retries
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_RETRIES;
        rgvar[i].vt = VT_UI4;
        rgvar[i].ulVal = MsTagInfo->Retries;
        i++;

        // Deal with Priority
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_PRIORITY;
        rgvar[i].vt = VT_UI4;
        rgvar[i].ulVal = MsTagInfo->Priority;
        i++;

        // Deal with Submission time
        Assert (MsTagInfo->SubmissionTime != 0);

        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_SUBMISSION_TIME;
        rgvar[i].vt = VT_FILETIME;
        rgvar[i].filetime = *(FILETIME*)&MsTagInfo->SubmissionTime;
        i++;

        // Deal with Originaly scheduled time
        Assert (MsTagInfo->OriginalScheduledTime);

        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_ORIGINAL_SCHED_TIME;
        rgvar[i].vt = VT_FILETIME;
        rgvar[i].filetime = *(FILETIME*)&MsTagInfo->OriginalScheduledTime;
        i++;

        // Deal with Broadcast id
        Assert (MsTagInfo->dwlBroadcastId != 0);

        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_BROADCAST_ID;
        rgvar[i].vt = VT_UI8;
        rgvar[i].uhVal = *(ULARGE_INTEGER*)&MsTagInfo->dwlBroadcastId;
        i++;

    }

    // Deal with Pages
    rgpspec[i].ulKind = PRSPEC_PROPID;
    rgpspec[i].propid  = PID_FAX_PAGES;
    rgvar[i].vt = VT_UI4;
    rgvar[i].ulVal = MsTagInfo->Pages;
    i++;

    // Deal with Type
    rgpspec[i].ulKind = PRSPEC_PROPID;
    rgpspec[i].propid  = PID_FAX_TYPE;
    rgvar[i].vt = VT_UI4;
    rgvar[i].ulVal = MsTagInfo->Type;
    i++;

    // Deal with Status
    if (MsTagInfo->dwStatus == JS_COMPLETED) {
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_STATUS;
        rgvar[i].vt = VT_UI4;
        rgvar[i].ulVal = MsTagInfo->dwStatus;
        i++;
    }

    // Deal with Extended status
    if (MsTagInfo->dwExtendedStatus) {
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_STATUS_EX;
        rgvar[i].vt = VT_UI4;
        rgvar[i].ulVal = MsTagInfo->dwExtendedStatus;
        i++;
    }

    // Deal with Extended status string
    if (MsTagInfo->lptstrExtendedStatus) {        
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_STATUS_STR_EX;
        rgvar[i].vt = VT_LPWSTR;
        rgvar[i].pwszVal = MsTagInfo->lptstrExtendedStatus;
        i++;
    }

    // Deal with StartTime
    if (MsTagInfo->StartTime != 0)
    {
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_START_TIME;
        rgvar[i].vt = VT_FILETIME;
        rgvar[i].filetime = *(FILETIME*)&MsTagInfo->StartTime;
        i++;
    }

    // Deal with EndTime
    if (MsTagInfo->EndTime != 0)
    {
        rgpspec[i].ulKind = PRSPEC_PROPID;
        rgpspec[i].propid  = PID_FAX_END_TIME;
        rgvar[i].vt = VT_FILETIME;
        rgvar[i].filetime = *(FILETIME*)&MsTagInfo->EndTime;
        i++;
    }


    hr = pPropertyStorage->WriteMultiple( i, //The number of properties being set
                                          rgpspec,   //Property specifiers
                                          rgvar,  //Array of PROPVARIANT values
                                          0      //Minimum value for property identifiers when they must be allocated
                                         );
    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("IPropertySetStorage::WriteMultiple Failed, err : 0x%08X"), hr);
        ec = ERROR_WRITE_FAULT;
        goto exit;
    }

    RetVal = TRUE;
    Assert (ec == ERROR_SUCCESS);
exit:

    if (NULL != pPropertyStorage)
    {
        pPropertyStorage->Release();
    }

    if (NULL != pPropertySetStorage)
    {
        pPropertySetStorage->Release();
    }

    if (!RetVal)
    {
        SetLastError (ec);
    }

    return RetVal;
}


//*********************************************************************************
//* Name:   GetMessageNTFSStorageProperties()
//* Author: Oded Sacher
//* Date:   Nov 8, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Fills FAX_MESSAGE structure.
//*     The caller must free all strings.
//*
//* PARAMETERS:
//*     [IN ]   LPCTSTR         lpctstrFileName
//*                 pointer to the file name.
//*
//*     [OUT]   PFAX_MESSAGE    pMessage
//*                 The FAX_MESSAGE structure to be filled.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*********************************************************************************
BOOL GetMessageNTFSStorageProperties(
    LPCTSTR         lpctstrFileName,
    PFAX_MESSAGE    pMessage
    )
{
    HRESULT hr;
    IPropertySetStorage* pPropertySetStorage = NULL;
    IPropertyStorage* pPropertyStorage = NULL;
    PROPVARIANT rgvar[FAX_MESSAGE_PROPERTIES];
    DEBUG_FUNCTION_NAME(TEXT("GetMessageNTFSStorageProperties"));
    BOOL RetVal = FALSE;
    DWORD i;
    FAX_MESSAGE FaxMessage = {0};
    HANDLE hFind;
    WIN32_FIND_DATA FindFileData;
    FILETIME FaxTime;
    BOOL fFreePropVariant = FALSE;
    DWORD ec = ERROR_SUCCESS;

    Assert (pMessage && lpctstrFileName);

    hFind = FindFirstFile( lpctstrFileName, &FindFileData);
    if (INVALID_HANDLE_VALUE == hFind)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FindFirstFile failed (ec: %ld), File %s"),
            GetLastError(),
            lpctstrFileName);
    }
    else
    {
        Assert (0 == FindFileData.nFileSizeHigh);

        FaxMessage.dwSize = FindFileData.nFileSizeLow;
        FaxMessage.dwValidityMask |= FAX_JOB_FIELD_SIZE;
        if (!FindClose(hFind))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindClose failed (ec: %ld)"),
                GetLastError());
        }
    }

    hr = StgOpenStorageEx(  lpctstrFileName,  //Points to path of compound file to create
                            STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT, //Specifies the access mode for opening the storage object
                            STGFMT_FILE, //Specifies the storage file format
                            0,            //Reserved; must be zero
                            NULL,  //Points to STGOPTIONS structure which specifies features of the storage object
                            0,          //Reserved; must be zero
                            IID_IPropertySetStorage ,//Specifies the GUID of the interface pointer
                            (void**)&pPropertySetStorage   //Address of an interface pointer
                         );
    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("StgOpenStorageEx Failed, err : 0x%08X"), hr);
        ec = ERROR_OPEN_FAILED;
        goto exit;
    }

    hr = pPropertySetStorage->Open( FMTID_FaxProperties, //Format identifier of the property set to be created
                                    STGM_READ | STGM_SHARE_EXCLUSIVE, //Storage mode of new property set
                                    &pPropertyStorage //Address of output variable that receivesthe IPropertyStorage interface pointer
                                  );

    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("IPropertySetStorage::Create Failed, err : 0x%08X"), hr);
        ec = ERROR_OPEN_FAILED;
        goto exit;
    }

    hr = pPropertyStorage->ReadMultiple( FAX_MESSAGE_PROPERTIES, //Count of properties being read
                                         pspecFaxMessage,  //Array of the properties to be read
                                         rgvar  //Array of PROPVARIANTs containing the property values on return
                                       );
    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("IPropertySetStorage::ReadMultiple Failed, err : 0x%08X"), hr);
        ec = ERROR_READ_FAULT;
        goto exit;
    }
    fFreePropVariant = TRUE;



    for (i = 0; i < FAX_MESSAGE_PROPERTIES; i++)
    {
        if (rgvar[i].vt != VT_EMPTY)
        {
            switch (pspecFaxMessage[i].propid)
            {

                case PID_FAX_CSID:
                    FaxMessage.lpctstrCsid = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrCsid == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_TSID:
                    FaxMessage.lpctstrTsid = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrTsid == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_PORT:
                    FaxMessage.lpctstrDeviceName = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrDeviceName == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_ROUTING:
                    FaxMessage.lpctstrRoutingInfo = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrRoutingInfo == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_CALLERID:
                    FaxMessage.lpctstrCallerID = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrCallerID == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_DOCUMENT:
                    FaxMessage.lpctstrDocumentName = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrDocumentName == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_SUBJECT:
                    FaxMessage.lpctstrSubject = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrSubject == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RETRIES:
                    FaxMessage.dwRetries = rgvar[i].ulVal;
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_RETRIES;
                    break;

                case PID_FAX_PAGES:
                    FaxMessage.dwPageCount = rgvar[i].ulVal;
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_PAGE_COUNT;
                    break;

                case PID_FAX_TYPE:
                    FaxMessage.dwJobType = rgvar[i].ulVal;
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_TYPE;
                    break;

                case PID_FAX_PRIORITY:
                    FaxMessage.Priority = (FAX_ENUM_PRIORITY_TYPE)rgvar[i].ulVal;
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_PRIORITY;
                    break;


                case PID_FAX_START_TIME:
                    FaxTime = rgvar[i].filetime;
                    if (!FileTimeToSystemTime(&FaxTime, &FaxMessage.tmTransmissionStartTime))
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_TRANSMISSION_START_TIME;
                    break;

                case PID_FAX_END_TIME:
                    FaxTime = rgvar[i].filetime;
                    if (!FileTimeToSystemTime(&FaxTime, &FaxMessage.tmTransmissionEndTime))
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_TRANSMISSION_END_TIME;
                    break;

                case PID_FAX_SUBMISSION_TIME:
                    FaxTime = rgvar[i].filetime;
                    if (!FileTimeToSystemTime(&FaxTime, &FaxMessage.tmSubmissionTime))
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_SUBMISSION_TIME;
                    break;

                case PID_FAX_ORIGINAL_SCHED_TIME:
                    FaxTime = rgvar[i].filetime;
                    if (!FileTimeToSystemTime(&FaxTime, &FaxMessage.tmOriginalScheduleTime))
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME;
                    break;

                case PID_FAX_SENDER_USER_NAME:
                    FaxMessage.lpctstrSenderUserName = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrSenderUserName == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_NAME:
                    FaxMessage.lpctstrRecipientName = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrRecipientName == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_NUMBER:
                    FaxMessage.lpctstrRecipientNumber = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrRecipientNumber == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_SENDER_NAME:
                    FaxMessage.lpctstrSenderName = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrSenderName == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_SENDER_NUMBER:
                    FaxMessage.lpctstrSenderNumber = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrSenderNumber == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_SENDER_BILLING:
                    FaxMessage.lpctstrBillingCode = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrBillingCode == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_STATUS:
                    FaxMessage.dwQueueStatus = rgvar[i].ulVal;
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_QUEUE_STATUS;
                    break;

                case PID_FAX_STATUS_EX:
                    FaxMessage.dwExtendedStatus = rgvar[i].ulVal;
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_STATUS_EX;
                    break;

                case PID_FAX_STATUS_STR_EX:
                    FaxMessage.lpctstrExtendedStatus = StringDup (rgvar[i].pwszVal);
                    if (FaxMessage.lpctstrExtendedStatus == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed, err : %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_BROADCAST_ID:
                    FaxMessage.dwlBroadcastId = *(DWORDLONG*)&rgvar[i].uhVal;
                    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_BROADCAST_ID;
                    break;

                default:
                    Assert (pspecFaxMessage[i].propid == PID_FAX_SENDER_BILLING); //Assert (FALSE);
            }
        }
    }

    // Get Unique JobId out of FileName
    if (!GetUniqueJobIdFromFileName( lpctstrFileName, &FaxMessage.dwlMessageId))
    {
       ec = GetLastError();
       DebugPrintEx( DEBUG_ERR, TEXT("GetUniqueJobIdFromFileName Failed, err : %ld"), ec);
       goto exit;
    }
    FaxMessage.dwValidityMask |= FAX_JOB_FIELD_MESSAGE_ID;


    FaxMessage.dwSizeOfStruct = sizeof(FAX_MESSAGE);
    CopyMemory (pMessage, &FaxMessage, sizeof(FAX_MESSAGE));
    RetVal = TRUE;

    Assert (ec == ERROR_SUCCESS);

exit:
    if (NULL != pPropertyStorage)
    {
        pPropertyStorage->Release();
    }

    if (NULL != pPropertySetStorage)
    {
        pPropertySetStorage->Release();
    }

    if (fFreePropVariant == TRUE)
    {
        hr = FreePropVariantArray( FAX_MESSAGE_PROPERTIES,     //Count of elements in the structure
                                   rgvar  //Pointer to the PROPVARIANT structure
                                 );
        if (FAILED(hr))
        {
            DebugPrintEx( DEBUG_ERR,TEXT("FreePropVariantArray Failed, err : 0x%08X"), hr);
        }
    }

    if (RetVal == FALSE)
    {
        FreeMessageBuffer (&FaxMessage, FALSE);
        SetLastError (ec);
    }
    return RetVal;
}


BOOL
GetUniqueJobIdFromFileName (
                                 LPCWSTR lpctstrFileName,
                                 DWORDLONG* pdwlUniqueJobId)
{
    WCHAR   lpwstrTmp[MAX_PATH];
    DWORDLONG dwlJobId = 0;
    LPWSTR  lpwstrJobId = NULL;

    _wsplitpath (lpctstrFileName, NULL, NULL, lpwstrTmp, NULL);
    lpwstrJobId = wcschr( lpwstrTmp, L'$');

    if (lpwstrJobId == NULL)
    {
        if (!swscanf(lpwstrTmp, TEXT("%I64x"), &dwlJobId))
        {
            return FALSE;
        }
    }
    else
    {
        if (!swscanf((lpwstrJobId+1), TEXT("%I64x"), &dwlJobId))
        {
            return FALSE;
        }
    }

    *pdwlUniqueJobId = dwlJobId;
    return TRUE;
}

//*********************************************************************************
//* Name:   GetPersonalProfNTFSStorageProperties()
//* Author: Oded Sacher
//* Date:   Nov 8, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Fills PFAX_PERSONAL_PROFILE structure with sender or recipient information.
//*     The caller must free all strings.
//*
//* PARAMETERS:
//*     [IN ]   LPCTSTR         lpctstrFileName
//*                 pointer to the file name.
//*     [IN ]   FAX_ENUM_PERSONAL_PROF_TYPES      PersonalProfType
//*                 Can be RECIPIENT_PERSONAL_PROF or SENDER_PERSONAL_PROF
//*
//*     [OUT]   PFAX_PERSONAL_PROFILE   pPersonalProfile
//*                 The PFAX_PERSONAL_PROFILE structure to be filled.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*********************************************************************************
BOOL GetPersonalProfNTFSStorageProperties(
    LPCTSTR                         lpctstrFileName,
    FAX_ENUM_PERSONAL_PROF_TYPES    PersonalProfType,
    PFAX_PERSONAL_PROFILE           pPersonalProfile
    )
{
    HRESULT hr;
    IPropertySetStorage* pPropertySetStorage = NULL;
    IPropertyStorage* pPropertyStorage = NULL;
    const PROPSPEC*  pspec;
    DWORD dwPropertiesCnt;
    DEBUG_FUNCTION_NAME(TEXT("GetPersonalProfNTFSStorageProperties"));
    BOOL RetVal = FALSE;
    DWORD i;
    FAX_PERSONAL_PROFILE FaxPersonalProfile = {0};
    BOOL fFreePropVariant = FALSE;
    PROPVARIANT* rgvar;
    DWORD ec = ERROR_SUCCESS;

    Assert (PersonalProfType == RECIPIENT_PERSONAL_PROF ||
            PersonalProfType == SENDER_PERSONAL_PROF);

    if (PersonalProfType == RECIPIENT_PERSONAL_PROF)
    {
        pspec = pspecFaxRecipient;
        dwPropertiesCnt = FAX_RECIP_PROPERTIES;
    }
    else
    {
        pspec = pspecFaxSender;
        dwPropertiesCnt = FAX_SENDER_PROPERTIES;
    }

    rgvar = (PROPVARIANT*) MemAlloc( dwPropertiesCnt * sizeof(PROPVARIANT) );
    if (!rgvar) {
        DebugPrintEx( DEBUG_ERR,TEXT("Failed to allocate array of PROPVARIANT values"));
        ec = ERROR_OUTOFMEMORY;
        goto exit;
    }

    hr = StgOpenStorageEx(  lpctstrFileName,  //Points to path of compound file to create
                            STGM_READ | STGM_SHARE_DENY_WRITE | STGM_DIRECT, //Specifies the access mode for opening the storage object
                            STGFMT_FILE, //Specifies the storage file format
                            0,            //Reserved; must be zero
                            NULL,  //Points to STGOPTIONS structure which specifies features of the storage object
                            0,          //Reserved; must be zero
                            IID_IPropertySetStorage ,//Specifies the GUID of the interface pointer
                            (void**)&pPropertySetStorage   //Address of an interface pointer
                         );
    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("StgOpenStorageEx Failed, err :"), hr);
        ec = ERROR_OPEN_FAILED;
        goto exit;
    }

    hr = pPropertySetStorage->Open( FMTID_FaxProperties, //Format identifier of the property set to be created
                                    STGM_READ|STGM_SHARE_EXCLUSIVE, //Storage mode of new property set
                                    &pPropertyStorage //Address of output variable that receivesthe IPropertyStorage interface pointer
                                  );
    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("IPropertySetStorage::Create Failed, err :"), hr);
        ec = ERROR_OPEN_FAILED;
        goto exit;
    }

    hr = pPropertyStorage->ReadMultiple( dwPropertiesCnt, //Count of properties being read
                                         pspec,  //Array of the properties to be read
                                         rgvar  //Array of PROPVARIANTs containing the property values on return
                                       );
    if (FAILED(hr))
    {
        DebugPrintEx( DEBUG_ERR,TEXT("IPropertySetStorage::ReadMultiple Failed, err :"), hr);
        ec = ERROR_READ_FAULT;
        goto exit;
    }
    fFreePropVariant = TRUE;

    for (i = 0; i < dwPropertiesCnt; i++)
    {
        if (rgvar[i].vt != VT_EMPTY)
        {
            switch (pspec[i].propid)
            {
                case PID_FAX_RECIP_NAME:
                case PID_FAX_SENDER_NAME:
                    FaxPersonalProfile.lptstrName = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrName == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_NUMBER:
                case PID_FAX_SENDER_NUMBER:
                    FaxPersonalProfile.lptstrFaxNumber = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrFaxNumber == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_COMPANY:
                case PID_FAX_SENDER_COMPANY:
                    FaxPersonalProfile.lptstrCompany = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrCompany == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_STREET:
                case PID_FAX_SENDER_STREET:
                    FaxPersonalProfile.lptstrStreetAddress = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrStreetAddress == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_CITY:
                case PID_FAX_SENDER_CITY:
                    FaxPersonalProfile.lptstrCity = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrCity == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;


                case PID_FAX_RECIP_STATE:
                case PID_FAX_SENDER_STATE:
                    FaxPersonalProfile.lptstrState = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrState == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_ZIP:
                case PID_FAX_SENDER_ZIP:
                    FaxPersonalProfile.lptstrZip = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrZip == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_COUNTRY:
                case PID_FAX_SENDER_COUNTRY:
                    FaxPersonalProfile.lptstrCountry = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrCountry == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                         goto exit;
                    }
                    break;

                case PID_FAX_RECIP_TITLE:
                case PID_FAX_SENDER_TITLE:
                    FaxPersonalProfile.lptstrTitle = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrTitle == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_DEPARTMENT:
                case PID_FAX_SENDER_DEPARTMENT:
                    FaxPersonalProfile.lptstrDepartment = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrDepartment == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_OFFICE_LOCATION:
                case PID_FAX_SENDER_OFFICE_LOCATION:
                    FaxPersonalProfile.lptstrOfficeLocation = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrOfficeLocation == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_HOME_PHONE:
                case PID_FAX_SENDER_HOME_PHONE:
                    FaxPersonalProfile.lptstrHomePhone = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrHomePhone == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_OFFICE_PHONE:
                case PID_FAX_SENDER_OFFICE_PHONE:
                    FaxPersonalProfile.lptstrOfficePhone = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrOfficePhone == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_RECIP_EMAIL:
                case PID_FAX_SENDER_EMAIL:
                    FaxPersonalProfile.lptstrEmail = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrEmail == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_SENDER_BILLING:
                    FaxPersonalProfile.lptstrBillingCode = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrBillingCode == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                case PID_FAX_SENDER_TSID:
                    FaxPersonalProfile.lptstrTSID = StringDup (rgvar[i].pwszVal);
                    if (FaxPersonalProfile.lptstrTSID == NULL)
                    {
                        ec = GetLastError ();
                        DebugPrintEx( DEBUG_ERR,TEXT("StringDup Failed,  error %ld"), ec);
                        goto exit;
                    }
                    break;

                default:
                    Assert (pspecFaxMessage[i].propid == PID_FAX_SENDER_TSID); //Assert (FALSE);
            }
        }
    }

    FaxPersonalProfile.dwSizeOfStruct = sizeof(FAX_PERSONAL_PROFILE);
    CopyMemory (pPersonalProfile, &FaxPersonalProfile, sizeof(FAX_PERSONAL_PROFILE));
    RetVal = TRUE;

    Assert (ec == ERROR_SUCCESS);

exit:
    if (NULL != pPropertyStorage)
    {
        pPropertyStorage->Release();
    }

    if (NULL != pPropertySetStorage)
    {
        pPropertySetStorage->Release();
    }

    if (fFreePropVariant == TRUE)
    {
        hr = FreePropVariantArray( dwPropertiesCnt,     //Count of elements in the structure
                                   rgvar  //Pointer to the PROPVARIANT structure
                                 );
        if (FAILED(hr))
        {
            DebugPrintEx( DEBUG_ERR,TEXT("FreePropVariantArray Failed, err :"), hr);
        }
    }
    MemFree(rgvar);

    if (RetVal == FALSE)
    {
        FreePersonalProfile (&FaxPersonalProfile, FALSE);
        SetLastError (ec);
    }
    return RetVal;
}



/******************************************************************************
* Name:   GetRecievedMessageFileName
* Author: Oded Sacher
*******************************************************************************
DESCRIPTION:
    Returns the file name of the specified message from the Inbox archive.


PARAMETERS:
    [IN] DWORDLONG dwlUniqueId [IN/OUT]
            The message unique ID.


RETURN VALUE:
        Pointer to the file name on success. Null if failed

REMARKS:
    Returns a pointer to the file name specified by unique message ID.
    If the function fails the function returns NULL.
    The caller must call MemFree to deallocate the returned string
*******************************************************************************/
LPWSTR
GetRecievedMessageFileName(
    IN DWORDLONG                dwlUniqueId
    )
{
    WCHAR wszFileName[MAX_PATH];
    WCHAR wszFullPathFileName[MAX_PATH];
    DWORD dwCount;
    DEBUG_FUNCTION_NAME(TEXT("GetRecievedMessageFileName"));
    DWORD ec = ERROR_SUCCESS;
    WCHAR wszArchiveFolder [MAX_PATH];
    LPWSTR lpwstrFilePart;

    EnterCriticalSection (&g_CsConfig);
    lstrcpyn (wszArchiveFolder, g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder, MAX_PATH);
    LeaveCriticalSection (&g_CsConfig);

    swprintf (wszFileName, L"%I64x", dwlUniqueId);

    dwCount = SearchPath (wszArchiveFolder,     // search path
                          wszFileName,          // file name
                          FAX_TIF_FILE_DOT_EXT, // file extension
                          MAX_PATH,             // size of buffer
                          wszFullPathFileName,  // found file name buffer
                          &lpwstrFilePart       // file component
                         );

    if (0 == dwCount)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SearchPath Failed, Error %ld"), GetLastError());
        return NULL;
    }

    if (dwCount > MAX_PATH)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("SearchPath Failed, File name bigger than MAX_PATH"));
        SetLastError (E_FAIL);
        return NULL;
    }

    return StringDup (wszFullPathFileName);
}

/******************************************************************************
* Name:   GetSentMessageFileName
* Author: Oded Sacher
*******************************************************************************
DESCRIPTION:
    Returns the file name of the specified message from the Sent items archive.


PARAMETERS:
    [IN] DWORDLONG dwlUniqueId
            The message unique ID.

    [IN] PSID pSid
            Pointer to the sending user SID.
            If this value is NULL - the caller has access to everyone's sent items archive
            and can get the file name of all the messages in that archive.

RETURN VALUE:
    Pointer to the file name on success. Null if failed.

REMARKS:
    Returns a pointer to the file name specified by unique message ID and sending user SID.
    If the function fails the function returns NULL.
    The caller must call MemFree to deallocate the returned string
*******************************************************************************/
LPWSTR
GetSentMessageFileName(
    IN DWORDLONG                dwlUniqueId,
    IN PSID                     pSid
    )
{
	WCHAR wszFileName[MAX_PATH] = {0};
	WCHAR wszFullPathFileName[MAX_PATH] = {0};
    int Count;
    DWORD dwCount;
    DEBUG_FUNCTION_NAME(TEXT("GetSentMessageFileName"));
    WCHAR wszArchiveFolder [MAX_PATH];


    EnterCriticalSection (&g_CsConfig);
    lstrcpyn (wszArchiveFolder, g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder, MAX_PATH);
    LeaveCriticalSection (&g_CsConfig);

    if (pSid != NULL)
    {
        LPWSTR lpwstrFilePart;
        LPWSTR lpwstrUserSid;

        if (!ConvertSidToStringSid (pSid, &lpwstrUserSid))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ConvertSidToStringSid Failed, error : %ld"),
                GetLastError());
            return NULL;
        }

        Count = _snwprintf (wszFileName,
                            ARR_SIZE(wszFileName) -1,
                            L"%s$%I64x",
                            lpwstrUserSid,
                            dwlUniqueId);
        if (Count < 0)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));
            SetLastError (E_FAIL);
            LocalFree (lpwstrUserSid);
            return NULL;
        }
        LocalFree (lpwstrUserSid);

        dwCount = SearchPath (wszArchiveFolder, // search path
                              wszFileName,  // file name
                              FAX_TIF_FILE_DOT_EXT, // file extension
                              MAX_PATH,        // size of buffer
                              wszFullPathFileName,        // found file name buffer
                              &lpwstrFilePart   // file component
                             );
        if (0 == dwCount)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SearchPath Failed, Error %ld"), GetLastError());
            return NULL;
        }

        if (dwCount > MAX_PATH)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SearchPath Failed, File name bigger than MAX_PATH"));
            SetLastError (E_FAIL);
            return NULL;
        }

        return StringDup (wszFullPathFileName);
     }
     else
     {
        HANDLE hSearch = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA FindFileData;
        DWORD ec = ERROR_SUCCESS;

        Count = _snwprintf (wszFullPathFileName,
                            MAX_PATH -1,
                            L"%s\\*$%I64x.%s",
                            wszArchiveFolder,
                            dwlUniqueId,
                            FAX_TIF_FILE_EXT);
        if (Count < 0)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));
            SetLastError (E_FAIL);
            return NULL;
        }

        hSearch =  FindFirstFile (wszFullPathFileName, // file name
                                  &FindFileData        // data buffer
                                 );
        if (INVALID_HANDLE_VALUE == hSearch)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindFirstFile Failed, error : %ld"),
                GetLastError());
            return NULL;
        }

        Count = _snwprintf (wszFullPathFileName,
                            MAX_PATH -1,
                            L"%s\\%s",
                            wszArchiveFolder,
                            FindFileData.cFileName);
        if (Count < 0)
        {
            ec = E_FAIL;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));
        }

        if (!FindClose (hSearch))
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FindClose Failed, error : %ld"),
                ec);
        }

        if (ERROR_SUCCESS != ec)
        {
            SetLastError(ec);
            return NULL;
        }

        return StringDup (wszFullPathFileName);
    }
}

DWORD
IsValidArchiveFolder (
    LPWSTR                      lpwstrFolder,
    FAX_ENUM_MESSAGE_FOLDER     Folder
)
/*++

Routine name : IsValidArchiveFolder

Routine description:

    Validates a folder is good for archiving. Make sure to lock g_CsConfig

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    lpwstrFolder            [in] - Folder in quetion
    Folder                  [in] - 'Inbox' or 'Sent items'

Return Value:

    Win32 error code. ERROR_SUCCESS if the folder can be used for archiving.
    Otherwise, the Win32 error code to return to the caller.

--*/
{
    DWORD dwLen;
    DWORD ec = ERROR_SUCCESS;
    BOOL IsSameDir;

    FAX_ENUM_MESSAGE_FOLDER OtherFolder;
    DEBUG_FUNCTION_NAME(TEXT("IsValidArchiveFolder"));

    Assert (FAX_MESSAGE_FOLDER_SENTITEMS == Folder ||
            FAX_MESSAGE_FOLDER_INBOX == Folder);

    if ((NULL == lpwstrFolder) || (L'\0' == lpwstrFolder[0]))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Empty archive folder specified"));

        return ERROR_INVALID_PARAMETER;
    }

    if ((dwLen = lstrlenW (lpwstrFolder)) > MAX_ARCHIVE_FOLDER_PATH)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("DB file name exceeds MAX_PATH"));
        
        return ERROR_BUFFER_OVERFLOW;
    }

    if (L'\\' == lpwstrFolder[dwLen - 1])
    {
        //
        // Archive name should not end with a backslash.
        //
        lpwstrFolder[dwLen - 1] = (WCHAR)'\0';
    }

    //
    // Compare Sent items and Inbox directory
    //
    if (FAX_MESSAGE_FOLDER_SENTITEMS == Folder)
    {
        OtherFolder = FAX_MESSAGE_FOLDER_INBOX;
    }
    else
    {
        OtherFolder = FAX_MESSAGE_FOLDER_SENTITEMS;
    }

    ec = IsValidFaxFolder(lpwstrFolder);
    if(ERROR_SUCCESS != ec)
    {
        //
        //  The folder does not exist or we don't
        //  have access rights
        //
        DebugPrintEx(  DEBUG_ERR,
                        TEXT("IsValidFaxFolder failed for folder : %s (ec=%lu)."),
                        lpwstrFolder,
                        ec);
        return ec;
    }

	//
	// Check Queue folder conflict
	//
	ec = CheckToSeeIfSameDir(
		lpwstrFolder,
		g_wszFaxQueueDir,
		&IsSameDir);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CheckToSeeIfSameDir with %ld"), ec);
        return ec;
    }

    if (TRUE == IsSameDir)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Inbox / Sent items point to the queue directory directory. %s and %s"),
            lpwstrFolder,
            g_wszFaxQueueDir);
        return FAX_ERR_DIRECTORY_IN_USE;
    }

    if (g_ArchivesConfig[OtherFolder].bUseArchive)
    {
        //
        // Check the other folder path
        //
        Assert (g_ArchivesConfig[OtherFolder].lpcstrFolder);
        ec = CheckToSeeIfSameDir( lpwstrFolder,
                                  g_ArchivesConfig[OtherFolder].lpcstrFolder,
                                  &IsSameDir);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CheckToSeeIfSameDir with %ld"), ec);
            return ec;
        }

        if (TRUE == IsSameDir)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Inbox and Sent items point to the same directory. %s and %s"),
                lpwstrFolder,
                g_ArchivesConfig[OtherFolder].lpcstrFolder);
            return FAX_ERR_DIRECTORY_IN_USE;
        }
    }

    Assert (ERROR_SUCCESS == ec);
    return ERROR_SUCCESS;
}   // IsValidArchiveFolder


BOOL
GetMessageIdAndUserSid (
    LPCWSTR lpcwstrFullPathFileName,
    FAX_ENUM_MESSAGE_FOLDER Folder,
    PSID*   lppUserSid,
    DWORDLONG* pdwlMessageId
/*++

Routine name : GetSentMessageUserSid

Routine description:

    Returns the user sid associated with a sent message - optional.
    Returns the message unique id - optional.
    The caller must call  LocalFree to deallocate the SID bufffer

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    lpcwstrFullPathFileName         [in] -  The message full path name  .
    Folder                          [in] -  Specifies if it is sent or received message.
    lppUserSid                      [out] - Address of a pointer to SID to receive the user sid.
    pdwlMessageId                   [out] - Address of a DWORDLONG to receive the message id.

Return Value:

    BOOL

--*/
    )
{
    WCHAR wszUserSid[MAX_PATH] = {0};
    LPCWSTR lpcwstrFileName = NULL;
    DWORDLONG dwlMessageId;
    DEBUG_FUNCTION_NAME(TEXT("GetSentMessageUserSid"));

    Assert (lpcwstrFullPathFileName && (wcslen(lpcwstrFullPathFileName) < 2*MAX_PATH));

    lpcwstrFileName = wcsrchr (lpcwstrFullPathFileName, L'\\');
    if (NULL == lpcwstrFileName)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad file name (No '\\' delimitor found)"));
        SetLastError (ERROR_INVALID_PARAMETER);
        ASSERT_FALSE;
        return FALSE;
    }

    lpcwstrFileName++;

    if (FAX_MESSAGE_FOLDER_SENTITEMS == Folder)
    {
        if (2 != swscanf (lpcwstrFileName,
                          L"%[^'$']$%I64x.TIF",
                          wszUserSid,
                          &dwlMessageId))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Bad sent items file name"));
            SetLastError (ERROR_BADDB);
            return FALSE;
        }
    }
    else
    {
        // Inbox
        Assert (FAX_MESSAGE_FOLDER_INBOX == Folder);
        if (1 != swscanf (lpcwstrFileName,
                          L"%I64x.TIF",
                          &dwlMessageId))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Bad inbox file name"));
            SetLastError (ERROR_BADDB);
            return FALSE;
        }
    }

    if (NULL != lppUserSid)
    {
        Assert (FAX_MESSAGE_FOLDER_SENTITEMS == Folder);

        if (!ConvertStringSidToSid (wszUserSid, lppUserSid))
        {
            DWORD dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ConvertStringSidToSid failed with %ld"), dwRes);
            return FALSE;
        }
    }

    if (NULL != pdwlMessageId)
    {
        *pdwlMessageId = dwlMessageId;
    }

    return TRUE;
}


BOOL
ArchiveAutoDelete(
    LPCWSTR lpcwstrArchive,
    DWORD dwAgeLimit,
    FAX_ENUM_MESSAGE_FOLDER Folder
    )
/*++

Routine name : ArchiveAutoDelete

Routine description:

    Automatically deletes any files that are older than the age limit specified in days.

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    lpcwstrArchive      [in] - Full path to the archive folder to search for files to delete.
    dwAgeLimit          [in] - The files age limit specified in days, any file older than the limit will be deleted.
    Folder              [in] - Specifies if it is inbox or sent items folder

Return Value:

    BOOL , Call GetLastError() for additional info.

--*/
{
    DWORD dwRes = ERROR_NO_MORE_FILES;
    DEBUG_FUNCTION_NAME(TEXT("ArchiveAutoDelete"));
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    Assert (lpcwstrArchive && dwAgeLimit);
    WCHAR  szFileName[MAX_PATH*2] = {0};
    BOOL bAnyDeleted = FALSE;

    wsprintf( szFileName, TEXT("%s\\*.TIF"), lpcwstrArchive );

    hFind = FindFirstFile( szFileName, &FindFileData );
    if (hFind == INVALID_HANDLE_VALUE)
    {
        //
        // No files found at archive dir
        //
        dwRes = GetLastError();
        if (ERROR_FILE_NOT_FOUND != dwRes)
        {
            DebugPrintEx( DEBUG_WRN,
                          TEXT("FindFirstFile failed (ec = %ld) for archive dir %s"),
                          GetLastError(),
                          lpcwstrArchive);
            return FALSE;
        }
        return TRUE;
    }
    do
    {
        //
        // Get rid of old files
        //
        FILETIME CurrentTime;
        DWORDLONG dwlAgeLimit, dwlCurrentTime, dwlFileTime;

        GetSystemTimeAsFileTime (&CurrentTime);
        dwlCurrentTime = MAKELONGLONG(CurrentTime.dwLowDateTime,
                                      CurrentTime.dwHighDateTime);

        dwlAgeLimit = MAKELONGLONG(dwAgeLimit, 0);
        dwlAgeLimit = (dwlAgeLimit * 24 * 60 * 60 * 10000000);

        dwlFileTime = MAKELONGLONG(FindFileData.ftCreationTime.dwLowDateTime,
                                   FindFileData.ftCreationTime.dwHighDateTime);

        if ( (dwlCurrentTime - dwlFileTime) > dwlAgeLimit)
        {
            // Old file - delete it
            wsprintf( szFileName, TEXT("%s\\%s"), lpcwstrArchive, FindFileData.cFileName );
            if (!DeleteFile (szFileName))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("DeleteFile [FileName %s], Failed with %ld"),
                    szFileName,
                    GetLastError());
            }
            else
            {
                //
                // Files were deleted - Send event to the registered clients
                //
                DWORD rVal = ERROR_SUCCESS;
                PSID lpUserSid = NULL;
                FAX_ENUM_EVENT_TYPE EventType;
                DWORDLONG dwlMessageId;
                PSID* lppUserSid = NULL;

                bAnyDeleted = TRUE;  // Refresh Archive size

                if (FAX_MESSAGE_FOLDER_INBOX == Folder)
                {
                    EventType = FAX_EVENT_TYPE_IN_ARCHIVE;
                }
                else
                {
                    EventType = FAX_EVENT_TYPE_OUT_ARCHIVE;
                    lppUserSid = &lpUserSid;
                }

                if (!GetMessageIdAndUserSid (szFileName, Folder, lppUserSid, &dwlMessageId))
                {
                    rVal = GetLastError();
                    DebugPrintEx(DEBUG_ERR,
                                 TEXT("GetMessageIdAndUserSid Failed, Error : %ld"),
                                 rVal);
                }

                if (ERROR_SUCCESS == rVal)
                {
                    rVal = CreateArchiveEvent (dwlMessageId, EventType, FAX_JOB_EVENT_TYPE_REMOVED, lpUserSid);
                    if (ERROR_SUCCESS != rVal)
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_*_ARCHIVE) failed (ec: %lc)"),
                            rVal);
                    }
                }

                if (NULL != lpUserSid)
                {
                    LocalFree (lpUserSid);
                    lpUserSid = NULL;
                }
            }
        }
    } while(FindNextFile( hFind, &FindFileData ));

    dwRes = GetLastError();
    if (ERROR_NO_MORE_FILES != dwRes)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("FindNextFilefaild with ec=%ld, at archive dir %s"),
                      dwRes,
                      lpcwstrArchive);
    }

    if (!FindClose(hFind))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("FindClose with ec=%ld, at archive dir %s"),
                      dwRes,
                      lpcwstrArchive);
    }

    if (TRUE == bAnyDeleted)
    {
        //
        // Refresh archive size
        //
        EnterCriticalSection (&g_CsConfig);
        g_ArchivesConfig[Folder].dwlArchiveSize = FAX_ARCHIVE_FOLDER_INVALID_SIZE;
        LeaveCriticalSection (&g_CsConfig);

        //
        // Wake up quota warning thread
        //
        if (!SetEvent (g_hArchiveQuotaWarningEvent))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set quota warning event, SetEvent failed (ec: %lc)"),
                GetLastError());
        }
    }

    return (ERROR_NO_MORE_FILES == dwRes);
} //ArchiveAutoDelete


BOOL
GetArchiveSize(
    LPCWSTR lpcwstrArchive,
    DWORDLONG* lpdwlArchiveSize
    )
/*++

Routine name : GetArchiveSize

Routine description:

    Returnes the archive folder total size in bytes.

Author:

    Oded Sacher (OdedS),    Feb, 2000

Arguments:

    lpcwstrArchive          [in ] - Full path to the archive folder.
    lpdwlArchiveSize        [out] - Pointer to a DWORDLONG to receive the archive folder size.

Return Value:

    BOOL , Call GetLastError() for additional info.

--*/
{
    DWORD dwRes = ERROR_NO_MORE_FILES;
    DEBUG_FUNCTION_NAME(TEXT("GetArchiveSize"));
    WIN32_FIND_DATA FindFileData;
    HANDLE hFind;
    DWORDLONG dwlArchiveSize = 0;
    Assert (lpcwstrArchive && lpdwlArchiveSize);
    WCHAR  szFileName[MAX_PATH*2] = {0};

    wsprintf( szFileName, TEXT("%s\\*.*"), lpcwstrArchive );

    hFind = FindFirstFile( szFileName, &FindFileData );
    if (hFind == INVALID_HANDLE_VALUE)
    {
        //
        // No files found at archive dir
        //
        DebugPrintEx( DEBUG_WRN,
                      TEXT("FindFirstFile failed (ec = %ld) for archive dir %s"),
                      GetLastError(),
                      lpcwstrArchive);
        return FALSE;
    }
    do
    {
        dwlArchiveSize += (MAKELONGLONG(FindFileData.nFileSizeLow ,FindFileData.nFileSizeHigh));
    } while(FindNextFile( hFind, &FindFileData ));

    dwRes = GetLastError();
    if (ERROR_NO_MORE_FILES != dwRes)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("FindNextFilefaild with ec=%ld, at archive dir %s"),
                      dwRes,
                      lpcwstrArchive);
    }

    if (!FindClose(hFind))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("FindClose with ec=%ld, at archive dir %s"),
                      dwRes,
                      lpcwstrArchive);
    }

    if (ERROR_NO_MORE_FILES == dwRes)
    {
        *lpdwlArchiveSize = dwlArchiveSize;
        return TRUE;
    }
    return FALSE;
} //GetArchiveSize


DWORD
FaxArchiveQuotaWarningThread(
    LPVOID UnUsed
    )
/*++

Routine Description:

    This fuction runs as a separate thread to
    watch the archives quota and send event to the event log

Arguments:

    UnUsed          - UnUsed pointer

Return Value:

    Always zero.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxArchiveQuotaWarningThread"));
    DWORD dwCount[2] = {QUOTA_REFRESH_COUNT, QUOTA_REFRESH_COUNT};
    HANDLE Handles[2];

    Assert (g_hArchiveQuotaWarningEvent && g_hServiceShutDownEvent);

    Handles[0] = g_hArchiveQuotaWarningEvent;
    Handles[1] = g_hServiceShutDownEvent;

    for (;;)
    {
        for (DWORD i = 0; i < 2; i++)
        {
            WCHAR wszArchive[MAX_PATH] = {0};
            DWORDLONG dwlArchiveSize;
            DWORDLONG dwlHighMark, dwlLowMark;
            BOOL bLoggedQuotaEvent;

            EnterCriticalSection (&g_CsConfig);
            if (TRUE == g_ArchivesConfig[i].bUseArchive &&
                TRUE == g_ArchivesConfig[i].bSizeQuotaWarning)
            {
                //
                // The user asked for archive monitoring
                //
                Assert (g_ArchivesConfig[i].lpcstrFolder);

                dwlHighMark = MAKELONGLONG(g_ArchivesConfig[i].dwSizeQuotaHighWatermark, 0);
                dwlHighMark = (dwlHighMark << 20); // convert MB to bytes

                dwlLowMark =  MAKELONGLONG(g_ArchivesConfig[i].dwSizeQuotaLowWatermark, 0);
                dwlLowMark = (dwlLowMark << 20); // convert MB to bytes

                wcscpy (wszArchive, g_ArchivesConfig[i].lpcstrFolder);

                bLoggedQuotaEvent = g_FaxQuotaWarn[i].bLoggedQuotaEvent;

                dwlArchiveSize = g_ArchivesConfig[i].dwlArchiveSize;

                g_FaxQuotaWarn[i].bConfigChanged = FALSE;  // We will check this flag if we need to update  g_ArchivesConfig
            }
            else
            {
                // do not warn
                LeaveCriticalSection (&g_CsConfig);
                continue;
            }
            LeaveCriticalSection (&g_CsConfig);

            // The client asked for quota warnings
            //
            // Compare archive size and water mark
            //
            if (FAX_ARCHIVE_FOLDER_INVALID_SIZE == dwlArchiveSize ||
                dwCount[i] >= QUOTA_REFRESH_COUNT)
            {
                //
                // We want to refresh the archive size
                //

                //
                // Check if service is going down before starting to delete
                //
                if (TRUE == g_bServiceIsDown)
                {
                    //
                    // Server is shutting down - Do not refresh archives size
                    //
                    DebugPrintEx(
                        DEBUG_WRN,
                        TEXT("Server is shutting down - Do not refresh archives size"));
                    break;
                }

                if (!GetArchiveSize (wszArchive, &dwlArchiveSize))
                {
                    DebugPrintEx( DEBUG_ERR,
                                  TEXT("GetArchiveSize with ec=%ld, at archive dir %s"),
                                  GetLastError(),
                                  wszArchive);
                    continue;
                }
                else
                {
                    // Update folder size
                    EnterCriticalSection (&g_CsConfig);
                    if (FALSE == g_FaxQuotaWarn[i].bConfigChanged)
                    {
                        // The configuration did not change - we can update g_ArchivesConfig
                        g_ArchivesConfig[i].dwlArchiveSize = dwlArchiveSize;
                    }
                    LeaveCriticalSection (&g_CsConfig);
                    dwCount[i] = 0;
                }
            }


            if (FALSE == bLoggedQuotaEvent)
            {
                //We did not logged an archive quota warning yet
                if (dwlArchiveSize > dwlHighMark)
                {
                    //
                    // Create event log
                    //
                    if (FAX_MESSAGE_FOLDER_INBOX == i)
                    {
                        DWORD dwHighMark = (DWORD)(dwlHighMark >> 20); // size in MB                        
                        FaxLog(
                            FAXLOG_CATEGORY_INBOUND,
                            FAXLOG_LEVEL_MED,
                            2,
                            MSG_FAX_EXEEDED_INBOX_QUOTA,
                            wszArchive,
                            DWORD2DECIMAL(dwHighMark)
                            );
                    }
                    else
                    {
                        Assert (FAX_MESSAGE_FOLDER_SENTITEMS == i);
                        DWORD dwHighMark = (DWORD)(dwlHighMark >> 20); // size in MB                        
                        FaxLog(
                            FAXLOG_CATEGORY_OUTBOUND,
                            FAXLOG_LEVEL_MED,
                            2,
                            MSG_FAX_EXEEDED_SENTITEMS_QUOTA,
                            wszArchive,
                            DWORD2DECIMAL(dwHighMark)
                            );
                    }
                    EnterCriticalSection (&g_CsConfig);
                    if (FALSE == g_FaxQuotaWarn[i].bConfigChanged)
                    {
                        // The configuration did not change - we can update g_ArchivesConfig
                        g_FaxQuotaWarn[i].bLoggedQuotaEvent = TRUE;
                    }
                    LeaveCriticalSection (&g_CsConfig);
                }
            }
            else
            {
                // An archive quota warning was already logged
                if (dwlArchiveSize < dwlLowMark)
                {
                    EnterCriticalSection (&g_CsConfig);
                    if (FALSE == g_FaxQuotaWarn[i].bConfigChanged)
                    {
                        // The configuration did not change - we can update g_ArchivesConfig
                        g_FaxQuotaWarn[i].bLoggedQuotaEvent = FALSE;
                    }
                    LeaveCriticalSection (&g_CsConfig);
                }
            }

            dwCount[i] ++;
        } // end of for loop

        DWORD dwWaitRes = WaitForMultipleObjects( 2, Handles, FALSE, QUOTA_WARNING_TIME_OUT);
        if (WAIT_FAILED == dwWaitRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WaitForMultipleObjects() failed, (LastErorr: %ld)"),
                GetLastError());
        }
        else
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("WaitForMultipleObjects() returned Wait result: %ld)"),
                dwWaitRes);
        }


        if ((dwWaitRes - WAIT_OBJECT_0) == 1)
        {
            //
            // We got the service shut down event
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Service is shutting down"));
            break;
        }
    }  // end of outer for(;;)  loop


    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }

    return ERROR_SUCCESS;
} // FaxArchiveQuotaWarningThread


DWORD
FaxArchiveQuotaAutoDeleteThread(
    LPVOID UnUsed
    )
/*++

Routine Description:

    This fuction runs as a separate thread to
    watch the archives quota and automaticlly delete old files

Arguments:

    UnUsed          - UnUsed pointer

Return Value:

    Always zero.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxArchiveQuotaAutoDeleteThread"));

    Assert(g_hServiceShutDownEvent);

    for (;;)
    {
        for (DWORD i = 0; i < 2; i++)
        {
            WCHAR wszArchive[MAX_PATH] = {0};
            DWORD dwAgeLimit;

            EnterCriticalSection (&g_CsConfig);
            if (TRUE == g_ArchivesConfig[i].bUseArchive &&
                0 != g_ArchivesConfig[i].dwAgeLimit)
            {
                //
                // The user asked for archive auto delete
                //
                Assert (g_ArchivesConfig[i].lpcstrFolder);

                wcscpy (wszArchive, g_ArchivesConfig[i].lpcstrFolder);
                dwAgeLimit = g_ArchivesConfig[i].dwAgeLimit;
            }
            else
            {
                // Do not auto delete
                LeaveCriticalSection (&g_CsConfig);
                continue;
            }
            LeaveCriticalSection (&g_CsConfig);

            //
            // Check if service is going down before starting to delete
            //
            if (TRUE == g_bServiceIsDown)
            {
                //
                // Server is shutting down - Do not auto delete archives
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Server is shutting down - Do not auto delete archives"));
                break;
            }

            if (!ArchiveAutoDelete (wszArchive, dwAgeLimit, (FAX_ENUM_MESSAGE_FOLDER)i))
            {
                DWORD dwRes = GetLastError();
                DebugPrintEx( DEBUG_ERR,
                              TEXT("ArchiveAutoDelete with ec=%ld, at archive dir %s"),
                              dwRes,
                              wszArchive);
            }
        } // end of inner for loop

        DWORD dwWaitRes = WaitForSingleObject( g_hServiceShutDownEvent, QUOTA_AUTO_DELETE_TIME_OUT);
        if (WAIT_FAILED == dwWaitRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WaitForSingleObject() failed, (LastErorr: %ld)"),
                GetLastError());
        }
        else
        {
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("WaitForSingleObject() returned Wait result: %ld)"),
                dwWaitRes);
        }

        if (WAIT_OBJECT_0 == dwWaitRes)
        {
            //
            // We got the service shut down event
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Service is shutting down"));
            break;
        }
    }  // end of outer for loop

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return ERROR_SUCCESS;
} // FaxArchiveQuotaAutoDeleteThread





DWORD
InitializeServerQuota ()
/*++

Routine name : InitializeServerQuota

Routine description:

    Creates the threads that watches the archives quota

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("InitializeServerQuota"));
    DWORD ThreadId;
    HANDLE hQuotaWarningThread = NULL;
    HANDLE hQuotaAutoDeleteThread = NULL;

    //
    //  Create Archive Config events
    //
    g_hArchiveQuotaWarningEvent =  CreateEvent( NULL,     // Secutity descriptor
                                                FALSE,    // flag for manual-reset event
                                                FALSE,    // flag for initial state
                                                NULL      // pointer to event-object name
                                              );
    if (NULL == g_hArchiveQuotaWarningEvent)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create archive config event - quota warning (CreateEvent) (ec=0x%08x)."),
            dwRes);
        goto exit;
    }

    //
    // Initialize Archive folders sizes
    //
    Assert (g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder);

    g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].dwlArchiveSize = FAX_ARCHIVE_FOLDER_INVALID_SIZE;
    if (TRUE == g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].bUseArchive)
    {
        //
        // Archive is in use
        //

        //
        //  Check archive folder validity
        //
        DWORD dwRet = IsValidArchiveFolder(g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder,FAX_MESSAGE_FOLDER_INBOX);
        if(ERROR_SUCCESS != dwRet)
        {
            //
            //  The folder is not valid for archiving
            //
            DebugPrintEx(  DEBUG_ERR,
                            TEXT("IsValidArchiveFolder failed for folder : %s (ec=%lu)."),
                            g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder,
                            dwRet);

            //
            //  Log event and disable - receive and routing activity  - for inbox
            //
            FaxLog( FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_FAX_ARCHIVE_INBOX_FOLDER_ERR,
                g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder,
                DWORD2DECIMAL(dwRet)
              );

            EnterCriticalSection (&g_CsConfig);
            g_dwQueueState |= FAX_INCOMING_BLOCKED;
            LeaveCriticalSection (&g_CsConfig);

        }
        else
        if (!GetArchiveSize (g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder, &g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].dwlArchiveSize))
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("GetArchiveSize with ec=%ld, at archive dir %s"),
                          GetLastError(),
                          g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder);
        }
    }
        

    Assert (g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder);

    g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].dwlArchiveSize = FAX_ARCHIVE_FOLDER_INVALID_SIZE;
    if (TRUE == g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].bUseArchive)
    {
        //
        // Archive is in use
        //

        //
        // Check archive folder validity
        //
        DWORD dwRet = IsValidArchiveFolder(g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder,FAX_MESSAGE_FOLDER_SENTITEMS);
        if(ERROR_SUCCESS != dwRet)
        {
            //
            //  The folder is not valid for archiving
            //
            DebugPrintEx(  DEBUG_ERR,
                            TEXT("IsValidArchiveFolder failed for folder : %s (ec=%lu)."),
                            g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder,
                            dwRet);

            //
            //  Log event and disable - submission and send activity  - for outbox
            //
            FaxLog( FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                1,
                MSG_FAX_ARCHIVE_OUTBOX_FOLDER_ERR,
                g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder
              );

            EnterCriticalSection (&g_CsConfig);
            g_dwQueueState |= FAX_OUTBOX_BLOCKED | FAX_OUTBOX_PAUSED;
            LeaveCriticalSection (&g_CsConfig);

        }
        else
        if (!GetArchiveSize (g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder, &g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].dwlArchiveSize))
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("GetArchiveSize with ec=%ld, at archive dir %s"),
                          GetLastError(),
                          g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder);
        }
    }
       

    //
    // Create the archives quata warning thread
    //
    hQuotaWarningThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxArchiveQuotaWarningThread,
        NULL,
        0,
        &ThreadId
        );

    if (!hQuotaWarningThread)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create quota warning thread (CreateThreadAndRefCount) (ec=0x%08x)."),
            dwRes);
        goto exit;
    }

    //
    // Create the archives quata auto delete thread
    //
    hQuotaAutoDeleteThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxArchiveQuotaAutoDeleteThread,
        NULL,
        0,
        &ThreadId
        );

    if (!hQuotaAutoDeleteThread)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create quota auto delete thread (CreateThreadAndRefCount) (ec=0x%08x)."),
            dwRes);
        goto exit;
    }


    Assert (ERROR_SUCCESS == dwRes);

exit:
    //
    // Close the thread handle we no longer need it
    //
    if (NULL != hQuotaWarningThread)
    {
        if (!CloseHandle(hQuotaWarningThread))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to close quota warning thread handle [handle = %p] (ec=0x%08x)."),
                hQuotaWarningThread,
                GetLastError());
        }
    }

    if (NULL != hQuotaAutoDeleteThread)
    {
        if (!CloseHandle(hQuotaAutoDeleteThread))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to close quota auto delete thread handle [handle = %p] (ec=0x%08x)."),
                hQuotaAutoDeleteThread,
                GetLastError());
        }
    }

    if (ERROR_SUCCESS != dwRes)
    {
        if (NULL != g_hArchiveQuotaWarningEvent)
        {
            if (!CloseHandle(g_hArchiveQuotaWarningEvent))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to close archive config event handle - quota warnings [handle = %p] (ec=0x%08x)."),
                    g_hArchiveQuotaWarningEvent,
                    GetLastError());
            }
            g_hArchiveQuotaWarningEvent = NULL;
        }
    }
    return dwRes;
}  // InitializeServerQuota
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\events.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    Events.cpp

Abstract:

    This file provides implementation of the service
    notification mechanism.

Author:

    Oded Sacher (OdedS)  Jan, 2000

Revision History:

--*/

#include "faxsvc.h"

static
DWORD
FaxCloseConnection(
	HANDLE	hContext
	)
{
	DWORD rVal = ERROR_SUCCESS;
	HANDLE hClientContext = hContext; 
	DEBUG_FUNCTION_NAME(TEXT("FaxCloseConnection"));

	RpcTryExcept
	{
		//
		// Close the context handle
		//
		rVal = FAX_CloseConnection( &hClientContext );
		if (ERROR_SUCCESS != rVal)
		{
			DumpRPCExtendedStatus();
			DebugPrintEx(DEBUG_ERR,TEXT("FAX_CloseConnection() failed, ec=0x%08x"), rVal );
		}			
	}
	RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
	{
		DumpRPCExtendedStatus();
		rVal = GetExceptionCode();
		DebugPrintEx(
				DEBUG_ERR,
				TEXT("FAX_CloseConnection failed (exception = %ld)"),
				rVal);
	}
	RpcEndExcept
	return rVal;
}

/************************************
*                                   *
*             Globals               *
*                                   *
************************************/

CClientsMap*    g_pClientsMap;                      // Map of clients ID to client.
HANDLE       g_hDispatchEventsCompPort;     // Events completion port. Te events are dispatched to the client in the client map.
HANDLE      g_hSendEventsCompPort;          // Completion port of client IDs that have events in their queue.
DWORDLONG       g_dwlClientID;                      // Client ID




/***********************************
*                                  *
*  CFaxEventExtended  Methodes     *
*                                  *
***********************************/


void
CFaxEventExtended::RemoveOffendingExtendedJobStatus ()
{   
    //
    // Client talks with API version 0
    // We can't send JS_EX_CALL_COMPLETED and JS_EX_CALL_ABORTED
    //
    if ((FAX_EVENT_TYPE_IN_QUEUE  == m_pEvent->EventType) ||
        (FAX_EVENT_TYPE_OUT_QUEUE == m_pEvent->EventType))
    {
        //
        // Queue event
        //
        if (FAX_JOB_EVENT_TYPE_STATUS == m_pEvent->EventInfo.JobInfo.Type)
        {
            //
            // This is a status event
            //
            PFAX_JOB_STATUS pStatus = PFAX_JOB_STATUS(DWORD_PTR(m_pEvent) + DWORD_PTR(m_pEvent->EventInfo.JobInfo.pJobData));
            if (FAX_API_VER_0_MAX_JS_EX < pStatus->dwExtendedStatus)
            {
                //
                // Offending extended status - clear it
                //
                pStatus->dwExtendedStatus = 0;
                pStatus->dwValidityMask &= ~FAX_JOB_FIELD_STATUS_EX;
            }
        }
    }    
    return;
}


DWORD
CFaxEventExtended::GetEvent (LPBYTE* lppBuffer, LPDWORD lpdwBufferSize) const
/*++

Routine name : CFaxEventExtended::GetEvent

Routine description:

    Returns a buffer filled with serialized FAX_EVENT_EX.
    The caller must call MemFree to deallocate memory.
    Must be called inside critical section g_CsClients.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    lppBuffer           [out] - Address of a pointer to a buffer to recieve the serialized info.
    lpdwBufferSize      [out] - Pointer to a DWORD to recieve the allocated buffer size.

Return Value:

    Standard Win32 error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CFaxEventExtended::GetEvent"));
    Assert (lppBuffer && lpdwBufferSize);

    *lppBuffer = (LPBYTE)MemAlloc(m_dwEventSize);
    if (NULL == *lppBuffer)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocating event buffer"));
        return ERROR_OUTOFMEMORY;
    }

    CopyMemory (*lppBuffer, m_pEvent, m_dwEventSize);
    *lpdwBufferSize = m_dwEventSize;
    return ERROR_SUCCESS;
}   // CFaxEventExtended::GetEvent


CFaxEventExtended::CFaxEventExtended(
    const FAX_EVENT_EX* pEvent,
    DWORD dwEventSize,
    PSID pSid) : m_dwEventSize(dwEventSize), m_pSid(NULL)
{
    Assert (pEvent != NULL);
    Assert (dwEventSize != 0);  

    m_pEvent = (PFAX_EVENT_EX)MemAlloc (dwEventSize);
    if (NULL == m_pEvent)
    {
        throw runtime_error("CFaxEventExtended::CFaxEventExtended Can not allocate FAX_EVENT_EX");
    }
    CopyMemory ((void*)m_pEvent, pEvent, dwEventSize);   
    
    if (NULL != pSid)
    {
        if (!IsValidSid(pSid))
        {
            MemFree ((void*)m_pEvent);
            throw runtime_error ("CFaxEventExtended:: CFaxEventExtended Invalid Sid");
        }

        DWORD dwSidLength = GetLengthSid(pSid);
        m_pSid = (PSID)MemAlloc (dwSidLength);
        if (NULL == m_pSid)
        {
            MemFree ((void*)m_pEvent);
            throw runtime_error ("CFaxEventExtended:: CFaxEventExtended Can not allocate Sid");
        }

        if (!CopySid(dwSidLength, m_pSid, pSid))
        {
            MemFree ((void*)m_pEvent);
            MemFree (m_pSid);            
            throw runtime_error ("CFaxEventExtended:: CFaxEventExtended CopySid failed Sid");
        }
    }
}

BOOL
CFaxEventExtended::MatchEvent(PSID pUserSid, DWORD dwEventTypes, BOOL bAllQueueMessages, BOOL bAllOutArchiveMessages) const
{
    BOOL bViewAllMessages;
    //
    // Extended event
    //
    if (0 == (m_pEvent->EventType & dwEventTypes))
    {
        //
        // Client is not registered for this kind of evevnts
        //
        return FALSE;
    }

    //
    // Client is  registered for this kind of evevnts
    //

    switch (m_pEvent->EventType)
    {
        case FAX_EVENT_TYPE_OUT_QUEUE:
            bViewAllMessages = bAllQueueMessages;
            break;

        case FAX_EVENT_TYPE_OUT_ARCHIVE:
            bViewAllMessages = bAllOutArchiveMessages;
            break;

        default:
            // Other kind of event - bViewAllMessages is not relevant
            bViewAllMessages = TRUE;
    }

    //
    // Check if the user is allowed to see this event
    //
    if (FALSE == bViewAllMessages)
    {
        Assert (pUserSid && m_pSid);
        //
        // The user is not allowed to see all messages
        //
        if (!EqualSid (pUserSid, m_pSid))
        {
            //
            // Do not send the event to this client.
            //
            return FALSE;
        }
    }   
    return TRUE;
}


/***********************************
*                                  *
*  CFaxEventLegacy  Methodes       *
*                                  *
***********************************/

DWORD
CFaxEventLegacy::GetEvent (LPBYTE* lppBuffer, LPDWORD lpdwBufferSize) const
/*++

Routine name : CFaxEventLegacy::GetEvent

Routine description:

    Returns a buffer filled with serialized FAX_EVENT.
    The caller must call MemFree to deallocate memory.
    Must be called inside critical section g_CsClients.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    lppBuffer           [out] - Address of a pointer to a buffer to recieve the serialized info.
    lpdwBufferSize      [out] - Pointer to a DWORD to recieve the allocated buffer size.

Return Value:

    Standard Win32 error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CFaxEventLegacy::GetEvent"));
    Assert (lppBuffer && lpdwBufferSize);

    *lppBuffer = (LPBYTE)MemAlloc(sizeof(FAX_EVENT));
    if (NULL == *lppBuffer)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocating event buffer"));
        return ERROR_OUTOFMEMORY;
    }

    CopyMemory (*lppBuffer, m_pEvent, sizeof(FAX_EVENT));
    *lpdwBufferSize = sizeof(FAX_EVENT);
    return ERROR_SUCCESS;
}   // CFaxEventLegacy::GetEvent


CFaxEventLegacy::CFaxEventLegacy(
    const FAX_EVENT* pEvent)
{
    Assert (pEvent != NULL);
    
    m_pEvent = (PFAX_EVENT)MemAlloc (sizeof(FAX_EVENT));
    if (NULL == m_pEvent)
    {
        throw runtime_error("CFaxEventExtended::CFaxEventExtended Can not allocate FAX_EVENT_EX");
    }
    CopyMemory ((void*)m_pEvent, pEvent, sizeof(FAX_EVENT));    
}

BOOL
CFaxEventLegacy::MatchEvent(PSID pUserSid, DWORD dwEventTypes, BOOL bAllQueueMessages, BOOL bAllOutArchiveMessages) const
{
    if (FAX_EVENT_TYPE_LEGACY == dwEventTypes)
    {
        //
        // Client is registered for this kind of evevnts
        //
        return TRUE;
    }
    return FALSE;
}




/***********************************
*                                  *
*  CClientID  Methodes             *
*                                  *
***********************************/

bool
CClientID::operator < ( const CClientID &other ) const
/*++

Routine name : operator <

Class: CClientID

Routine description:

    Compares myself with another client ID key

Author:

    Oded Sacher (Odeds), Jan, 2000

Arguments:

    other           [in] - Other key

Return Value:

    true only is i'm less than the other key

--*/
{
    if (m_dwlClientID < other.m_dwlClientID)
    {
        return true;
    }

    return false;
}   // CClientID::operator <



/***********************************
*                                  *
*  CClient  Methodes               *
*                                  *
***********************************/

//
// Ctor
//
CClient::CClient (CClientID ClientID,
             PSID pUserSid,
             DWORD dwEventTypes,
             handle_t hFaxHandle,
             BOOL bAllQueueMessages,
             BOOL bAllOutArchiveMessages,
             DWORD dwAPIVersion) :
                m_dwEventTypes(dwEventTypes),
                m_ClientID(ClientID),
                m_bPostClientID(TRUE),
                m_bAllQueueMessages(bAllQueueMessages),
                m_bAllOutArchiveMessages(bAllOutArchiveMessages),
                m_dwAPIVersion(dwAPIVersion),
				m_dwRefCount(1)
{
    m_FaxHandle = hFaxHandle;
    m_hFaxClientContext = NULL;
    m_pUserSid = NULL;

    if (NULL != pUserSid)
    {
        if (!IsValidSid(pUserSid))
        {
            throw runtime_error ("CClient:: CClient Invalid Sid");
        }

        DWORD dwSidLength = GetLengthSid(pUserSid);
        m_pUserSid = (PSID)MemAlloc (dwSidLength);
        if (NULL == m_pUserSid)
        {
            throw runtime_error ("CClient:: CClient Can not allocate Sid");
        }

        if (!CopySid(dwSidLength, m_pUserSid, pUserSid))
        {
            MemFree (m_pUserSid);
            m_pUserSid = NULL;
            throw runtime_error ("CClient:: CClient CopySid failed Sid");
        }
    }
}

//
// Assignment
//
CClient& CClient::operator= (const CClient& rhs)
{
    if (this == &rhs)
    {
        return *this;
    }
    m_FaxHandle = rhs.m_FaxHandle;
    m_dwEventTypes = rhs.m_dwEventTypes;
    m_Events = rhs.m_Events;
    m_ClientID = rhs.m_ClientID;
    m_hFaxClientContext = rhs.m_hFaxClientContext;
    m_bPostClientID = rhs.m_bPostClientID;
    m_bAllQueueMessages = rhs.m_bAllQueueMessages;
    m_bAllOutArchiveMessages = rhs.m_bAllOutArchiveMessages;
    m_dwAPIVersion = rhs.m_dwAPIVersion;
	m_dwRefCount = rhs.m_dwRefCount;

    MemFree (m_pUserSid);
    m_pUserSid = NULL;

    if (NULL != rhs.m_pUserSid)
    {
        if (!IsValidSid(rhs.m_pUserSid))
        {
            throw runtime_error ("CClient::operator= Invalid Sid");
        }

        DWORD dwSidLength = GetLengthSid(rhs.m_pUserSid);
        m_pUserSid = (PSID)MemAlloc (dwSidLength);
        if (NULL == m_pUserSid)
        {
            throw runtime_error ("CClient::operator= Can not allocate Sid");
        }

        if (!CopySid(dwSidLength, m_pUserSid, rhs.m_pUserSid))
        {
            throw runtime_error ("CClient::operator= CopySid failed Sid");
        }
    }
    return *this;
}

//
// Copy Ctor
//
CClient::CClient (const CClient& rhs) : m_ClientID(rhs.m_ClientID)
{
    m_FaxHandle = rhs.m_FaxHandle;
    m_dwEventTypes = rhs.m_dwEventTypes;
    m_Events = rhs.m_Events;
    m_hFaxClientContext = rhs.m_hFaxClientContext;
    m_bPostClientID = rhs.m_bPostClientID;
    m_bAllQueueMessages = rhs.m_bAllQueueMessages;
    m_bAllOutArchiveMessages = rhs.m_bAllOutArchiveMessages;
    m_dwAPIVersion = rhs.m_dwAPIVersion;
	m_dwRefCount = rhs.m_dwRefCount;
    m_pUserSid = NULL;

    if (NULL != rhs.m_pUserSid)
    {
        if (!IsValidSid(rhs.m_pUserSid))
        {
            throw runtime_error("CClient::CopyCtor Invalid Sid");
        }

        DWORD dwSidLength = GetLengthSid(rhs.m_pUserSid);
        m_pUserSid = (PSID)MemAlloc (dwSidLength);
        if (NULL == m_pUserSid)
        {
            throw runtime_error("CClient::CopyCtor Can not allocate Sid");
        }

        if (!CopySid(dwSidLength, m_pUserSid, rhs.m_pUserSid))
        {
            throw runtime_error("CClient::CopyCtor CopySid failed");
        }
    }
    return;
}

//
// Dtor
//
CClient::~CClient ()
{
    DEBUG_FUNCTION_NAME(TEXT("CClient::~CClient"));

    try
    {   
        while (FALSE == m_Events.empty())
        {
            CFaxEvent* pFaxEvent = m_Events.front();
            m_Events.pop();
            delete pFaxEvent;
        }       
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("queue or CFaxEvent caused exception (%S)"),
            ex.what());              
    }

    MemFree (m_pUserSid);
    m_pUserSid = NULL;
    return;
}


DWORD
CClient::AddEvent(CFaxEvent* pFaxEvent)
/*++

Routine name : CClient::AddEvent

Routine description:

    Adds CFaxEvent object to the client's events queue.
    Must be called inside critical section g_CsClients.
    The function frees pFaxEvent if it is not added to the client queue.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    pFaxEvent       [in] - Pointer to CFaxEvnet object        

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CClient::AddEvent"));
    BOOL bEventAdded = FALSE;       

    if (!pFaxEvent->MatchEvent(m_pUserSid, m_dwEventTypes, m_bAllQueueMessages, m_bAllOutArchiveMessages))
    {
        //
        // Client is not registered for this event. Free the event report success
        //      
        goto exit;
    }

    if (FAX_API_VERSION_1 > m_dwAPIVersion)
    {
        //
        // Client talks with API version 0
        // We can't send JS_EX_CALL_COMPLETED and JS_EX_CALL_ABORTED        
        pFaxEvent->RemoveOffendingExtendedJobStatus();
    }

    try
    {
        //
        // Add the event to the client queue
        //
        m_Events.push(pFaxEvent);

        if (TRUE == m_bPostClientID)
        {
            //
            // events in queue - Notify the completion port threads of the client's queued events
            //
            CClientID* pClientID = new (std::nothrow) CClientID(m_ClientID);
            if (NULL == pClientID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Can not allocate CClientID object"));
                dwRes = ERROR_OUTOFMEMORY;
                m_Events.pop();
                goto exit;
            }

            //
            // post CLIENT_COMPLETION_KEY to the completion port
            //
            if (!PostQueuedCompletionStatus( g_hSendEventsCompPort,
                                             sizeof(CClientID),
                                             CLIENT_COMPLETION_KEY,
                                             (LPOVERLAPPED) pClientID))
            {
                dwRes = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PostQueuedCompletionStatus failed. (ec: %ld)"),
                    dwRes);                
                delete pClientID;
                pClientID = NULL;
                m_Events.pop();
                goto exit;
            }
            m_bPostClientID = FALSE;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("queue or CFaxEvent caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    bEventAdded = TRUE;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (FALSE == bEventAdded)
    {
        delete pFaxEvent;
    }    
    return dwRes;
}  //  CClient::AddEvent


DWORD
CClient::GetEvent (LPBYTE* lppBuffer, LPDWORD lpdwBufferSize, PHANDLE phClientContext) const
/*++

Routine name : CClient::GetEvent

Routine description:

    Gets a serialized FAX_EVENT_EX buffer to be sent
    to a client using the client context handle (obtained from OpenConnection()).
    The caller must call MemFree to deallocate memory.
    Must be called inside critical section g_CsClients.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    lppBuffer           [out] - Address of a pointer to a buffer to recieve the serialized info.
    lpdwBufferSize      [out] - Pointer to a DWORD to recieve the allocated buffer size.
    phClientContext     [out] - Pointer to a HANDLE to recieve the client context handle.

Return Value:

    Standard Win32 error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CClient::GetEvent"));

    Assert ( lppBuffer && phClientContext);

    try
    {
        // get a reference to the top event
        const CFaxEvent* pFaxEvent = m_Events.front();

        //
        // get the serialized FAX_EVENT_EX or FAX_EVENT buffer
        //
        dwRes = pFaxEvent->GetEvent(lppBuffer ,lpdwBufferSize);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CFaxEvent::GetEvent failed with error =  %ld)"),
                dwRes);
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("queue or CFaxEvent caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    //
    // Get the client context handle
    //
    *phClientContext = m_hFaxClientContext;
    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
} // CClient::GetEvent




DWORD
CClient::DelEvent ()
/*++

Routine name : CClient::DelEvent

Routine description:

    Removes the first event from the queue.
    Must be called inside critical section g_CsClients.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CClient::DelEvent"));

    Assert (m_bPostClientID == FALSE);

    try
    {
        CFaxEvent* pFaxEvent = m_Events.front();
        m_Events.pop();
        delete pFaxEvent;

        if (m_Events.empty())
        {
            // last event was poped ,next event will notify of client queued events
            m_bPostClientID = TRUE;
        }
        else
        {
            //
            // More events in queue - Notify the completion port of queued events
            //
            CClientID* pClientID = new (std::nothrow) CClientID(m_ClientID);
            if (NULL == pClientID)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Can not allocate CClientID object"));
                dwRes = ERROR_OUTOFMEMORY;
                goto exit;
            }

            if (!PostQueuedCompletionStatus( g_hSendEventsCompPort,
                                             sizeof(CClientID),
                                             CLIENT_COMPLETION_KEY,
                                             (LPOVERLAPPED) pClientID))
            {
                dwRes = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PostQueuedCompletionStatus failed. (ec: %ld)"),
                    dwRes);
                delete pClientID;
                pClientID = NULL;
                m_bPostClientID = TRUE; // try to notify when the next event is queued
                goto exit;
            }
            m_bPostClientID = FALSE;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("queue caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;

}  // CClient::DelEvent




/***********************************
*                                  *
*  CClientsMap  Methodes           *
*                                  *
***********************************/


DWORD
CClientsMap::AddClient (const CClient& Client)
/*++

Routine name : CClientsMap::AddClient

Routine description:

    Adds a new client to the global map.
    Must be called inside critical section g_CsClients.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    Client            [in    ] - A reference to the new client object

Return Value:

    Standard Win32 error code

--*/
{
    CLIENTS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CClientsMap::AddClient"));
    pair <CLIENTS_MAP::iterator, bool> p;

    try
    {
        //
        // Add new map entry
        //
        p = m_ClientsMap.insert (CLIENTS_MAP::value_type(Client.GetClientID(), Client));

        //
        // See if entry exists in map
        //
        if (p.second == FALSE)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Client allready in the clients map"));
            dwRes = ERROR_DUP_NAME;
            Assert (p.second == TRUE); // Assert FALSE
            goto exit;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map or Client caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    return dwRes;
}  // CClientsMap::AddClient


DWORD
CClientsMap::ReleaseClient (const CClientID& ClientID, BOOL fRunDown /* = FALSE */)
/*++

Routine name : CClientsMap::ReleaseClient

Routine description:

    Decrease a client refertnce count. If refcount is 0, Deletes it from the global clients map.    
	DO NOT call ReleaseClient when holding g_CsClients!
	A call to ReleaseClient can cause FaxCloseConnection to be called. As FaxCloseConnection is 
	a RPC call, it (ReleaseClient) must be called when g_CsClients is NOT held.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    ClientID            [in ] - Reference to the client ID key
	fRunDown			[in ] - The call is a result of RPC rundown

Return Value:

    Standard Win32 error code

--*/
{    
	DWORD dwRes = ERROR_SUCCESS;    
    CClient* pClient = NULL;	
	CLIENTS_MAP::iterator it;
	DWORD dwRefCount;
	HANDLE hClientContext = NULL;
	HANDLE hBindingHandle = NULL;
	DWORD rVal = ERROR_SUCCESS;
	DEBUG_FUNCTION_NAME(TEXT("CClientsMap::ReleaseClient"));
    //
    // Enter g_CsClients while searching for the client.
    //
    EnterCriticalSection (&g_CsClients);
	try
    {
        //
        // See if entry exists in map
        //
        if((it = m_ClientsMap.find(ClientID)) == m_ClientsMap.end())
        {
			dwRes = ERROR_SUCCESS; // Client was removed from map
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("client not found, Client ID %I64"),
                ClientID.GetID());            
            goto exit;
        }        
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }
    pClient = &((*it).second);
	Assert (pClient);  

	if (TRUE == fRunDown)
	{
		//
		// Prevent further RPC calls to this client
		//
		pClient->SetContextHandle(NULL);
	}
	dwRefCount = pClient->Release();
	if (dwRefCount > 0)
	{
		//
		// Client can not be removed from the map yet
		//
		goto exit;
	}

    hClientContext = pClient->GetContextHandle();
	if (NULL != hClientContext)	
	{		
		//
		// Block other threads from sending events to this client
		//
		pClient->SetContextHandle(NULL);

		//
		// A connection to the client was opened.
		// leave g_CsClients while trying to close the connection
		//
		LeaveCriticalSection (&g_CsClients);		
		rVal = FaxCloseConnection(hClientContext);		
		if (ERROR_SUCCESS != rVal)
		{
			DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxCloseConnection failed with ec = %ld"),
                rVal);
		}
		EnterCriticalSection (&g_CsClients);
	}	

	hBindingHandle = pClient->GetFaxHandle();
	Assert (hBindingHandle);

	dwRes = RpcBindingFree(&hBindingHandle);
	if (ERROR_SUCCESS != dwRes)
	{
		DebugPrintEx(
			DEBUG_WRN,
			TEXT("RpcBindingFree failed, ec: %ld"),
			dwRes);
	}
	//
	// Delete the map entry
	//
	m_ClientsMap.erase (it);
	
exit:
    LeaveCriticalSection (&g_CsClients);    
    return ((ERROR_SUCCESS != rVal) ? rVal : dwRes);    
}  //  CClientsMap::ReleaseClient



PCCLIENT
CClientsMap::FindClient (const CClientID& ClientID) const
/*++

Routine name : CClientsMap::FindClient

Routine description:

    Returns a pointer to a client object specified by its ID object.    

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    ClientID            [in] - The clients's ID object

Return Value:

    Pointer to the found rule object. If it is null the client was not found.
	If the client object was returned, the caller must call CClientsMap::ReleaseClient to release the client object.


--*/
{
    CLIENTS_MAP::iterator it;
	PCCLIENT pClient = NULL;
	DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CClientsMap::FindClient"));

	EnterCriticalSection (&g_CsClients);
    try
    {
        //
        // See if entry exists in map
        //
        if((it = m_ClientsMap.find(ClientID)) == m_ClientsMap.end())
        {
            ec = ERROR_NOT_FOUND;
            goto exit;
        }
        pClient =  &((*it).second);
		if (0 != pClient->GetRefCount())
		{			
			// 
			// Increase the client reference count, so it will not be deleted.
			//
			pClient->Lock();  
		}
		else
		{
			//
			// The client is being deleted. 
			//
			pClient = NULL;
			ec = ERROR_NOT_FOUND;
		}
		goto exit;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        ec = ERROR_GEN_FAILURE;        
    }
exit:
	LeaveCriticalSection (&g_CsClients);
	if (NULL == pClient)
	{
		Assert (ERROR_SUCCESS != ec);
		SetLastError(ec);
	}
	return pClient;
}  //  CClientsMap::FindClient



DWORD
CClientsMap::AddEvent(CFaxEvent* pFaxEvent)
/*++

Routine name : CClientsMap::AddEvent

Routine description:

    Adds event to the events queue of each client that is registered for this kind of event

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    pFaxEvent       [in] - Pointer to CFaxEvnet object        
   
Return Value:

    Standard Win32 error code

--*/
{
    CLIENTS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CClientsMap::AddEvent"));
    CClient* pClient;
    
    EnterCriticalSection (&g_CsClients);

    try
    {
        for (it = m_ClientsMap.begin(); it != m_ClientsMap.end(); it++)
        {
            pClient = &((*it).second);

            if (pClient->IsConnectionOpened())
            {
                CFaxEvent* pNewFaxEvent = pFaxEvent->Clone();
                if (NULL == pNewFaxEvent)
                {
                    dwRes = ERROR_OUTOFMEMORY;
                    DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CCLient::AddEvent failed)"));
                        goto exit;
                }
                else
                {
                    dwRes = pClient->AddEvent (pNewFaxEvent);
                    if (ERROR_SUCCESS != dwRes)
                    {
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("CCLient::AddEvent failed with error =  %ld)"),
                            dwRes);
                        goto exit;                      
                    }
                }
            }
        }

    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsClients);
    return dwRes;

}  //  CClientsMap::AddEvent



DWORD
CClientsMap::Notify (const CClientID& ClientID)
/*++

Routine name : CClientsMap::Notify

Routine description:

    Sends the first event in the specified client events queue

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    pClientID           [in    ] - Pointer to the client ID object

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DWORD rVal = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CClientsMap::Notify"));
    CClient* pClient = NULL;
    HANDLE hClientContext;
    LPBYTE pBuffer = NULL;
    DWORD dwBufferSize = 0;
    BOOL fLegacyClient;

	//
	// Find the client in the map, this will also lock the client
	//
    pClient = FindClient (ClientID);
    if (NULL == pClient)
    {
        dwRes = GetLastError();
        if (ERROR_NOT_FOUND != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CClientsMap::FindClient failed with ec = %ld"),
                dwRes);
        }
        else
        {
            dwRes = ERROR_SUCCESS; // Client was removed from map
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("CClientsMap::FindClient client not found, Client ID %I64"),
                ClientID.GetID());
        }
        return dwRes;
    }

	//
	// Client is locked (will not be deleted), we must call ReleaseClient 
	// When getting the client data (event and context handle, we must lock g_CsClients as well).
	//
	EnterCriticalSection (&g_CsClients);
	if (FALSE == pClient->IsConnectionOpened())
	{
		dwRes = ERROR_SUCCESS; // Client closed the connection
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Client already closed the connection, Client ID %I64"),
            ClientID.GetID());
		LeaveCriticalSection (&g_CsClients);
		goto exit;
	}

    dwRes = pClient->GetEvent (&pBuffer, &dwBufferSize, &hClientContext);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CClient::GetEvent failed with ec = %ld"),
            dwRes);
		LeaveCriticalSection (&g_CsClients);
        goto exit;
    }

    fLegacyClient = pClient->IsLegacyClient();    
	//
	// Leave g_CsClients before calling RPC
	//
	LeaveCriticalSection (&g_CsClients);

    RpcTryExcept
    {
        //
        // post the event to the client
        //
        if (FALSE == fLegacyClient)
        {
            dwRes = FAX_ClientEventQueueEx( hClientContext, pBuffer, dwBufferSize);
            if (ERROR_SUCCESS != dwRes)
            {
                DumpRPCExtendedStatus ();
                DebugPrintEx(DEBUG_ERR,TEXT("FAX_ClientEventQueueEX() failed, ec=0x%08x"), dwRes );
            }
        }
        else
        {
            dwRes = FAX_ClientEventQueue( hClientContext, *((PFAX_EVENT)pBuffer));
            if (ERROR_SUCCESS != dwRes)
            {
                DumpRPCExtendedStatus ();
                DebugPrintEx(DEBUG_ERR,TEXT("FAX_ClientEventQueue() failed, ec=0x%08x"), dwRes );
            }
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        DumpRPCExtendedStatus ();
        dwRes = GetExceptionCode();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_ClientEventQueueEX failed (exception = %ld)"),
                dwRes);
    }
    RpcEndExcept
    
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to post event, Client context handle 0X%x, (ec: %ld)"),
            hClientContext,
            dwRes);
    }
    rVal = dwRes;

exit:
    
	//
	// Remove the event from the client's queue. CClient::DelEvent must be called so CClient::m_bPostClientID will be set.
	//
	EnterCriticalSection (&g_CsClients);
    dwRes = pClient->DelEvent ();
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CClient::DelEvent failed with ec = %ld"),
            dwRes);
    }    
	LeaveCriticalSection (&g_CsClients);

    DWORD ec = ReleaseClient(ClientID);
	if (ERROR_SUCCESS != ec)
	{
		DebugPrintEx(
            DEBUG_ERR,
            TEXT("CClientsMap::ReleaseClient failed with ec = %ld"),
            ec);
	}
    MemFree(pBuffer);
    pBuffer = NULL;
    return ((ERROR_SUCCESS != rVal) ? rVal : dwRes);
} // CClientsMap::Notify


DWORD
CClientsMap::OpenClientConnection (const CClientID& ClientID)
/*++

Routine name : CClientsMap::OpenClientConnection

Routine description:

    Opens a connection to a client

Author:

    Oded Sacher (OdedS),    Sep, 2000

Arguments:

    pClientID           [in    ] - Pointer to the client ID object

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CClientsMap::OpenClientConnection"));
    CClient* pClient;
    handle_t hFaxHandle = NULL;
    ULONG64 Context = 0;
    HANDLE hFaxClientContext = NULL;
    BOOL fLegacyClient;    

    pClient = FindClient (ClientID);
    if (NULL == pClient)
    {
        dwRes = GetLastError();
        if (ERROR_NOT_FOUND != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CClientsMap::FindClient failed with ec = %ld"),
                dwRes);
        }
        else
        {
            dwRes = ERROR_SUCCESS; // Client was removed from map
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("CClientsMap::FindClient client not found, Client ID %I64"),
                ClientID.GetID());
        }
        return dwRes;
    }

	//
	// Client is now locked, we must call ReleaseClient
	// Aquire g_CsClients when reading the client data
	//
	EnterCriticalSection (&g_CsClients);

    hFaxHandle = pClient->GetFaxHandle();
    Context = (pClient->GetClientID()).GetContext();
	fLegacyClient = pClient->IsLegacyClient();
    //
    // leave g_CsClients while trying to send the notification
    //
    LeaveCriticalSection (&g_CsClients);

    RpcTryExcept
    {
        //
        // Get a context handle from the client
        //
        dwRes = FAX_OpenConnection( hFaxHandle, Context, &hFaxClientContext );
        if (ERROR_SUCCESS != dwRes)
        {
            DumpRPCExtendedStatus();
            DebugPrintEx(DEBUG_WRN,TEXT("First attempt of FAX_OpenConnection() failed, ec=0x%08x"), dwRes );

            //
            //  We are trying again.
            //
            //  This is why we shuld retry,
            //
            //  When using secure channle we sometimes manage to establish a connection, but failing when we checke the state of the connection.
            //  This is usually indicative of old connections to the server which we just discovered were broken
            //
            //  The server could have come down, but RPC still save the connection (for ~2 minutes).
            //  On secure channel the RPC can't retry the connection attemp, so we must try to connect again.
            //

            //
            //  Retry to open connection to fax client
            //
            dwRes = FAX_OpenConnection( hFaxHandle, Context, &hFaxClientContext );
            if (ERROR_SUCCESS != dwRes)
            {
                DumpRPCExtendedStatus();
                DebugPrintEx(DEBUG_WRN,TEXT("second attempt of FAX_OpenConnection() failed, ec=0x%08x"), dwRes );

                //
                //  We are dropping the authenticate level to RPC_C_AUTHN_LEVEL_NONE trying again.
                //  We probably talking to a down-level client running on Windows 2000 RTM (SP1 and above are excluded) or earlier OS.
                //
                //
                //    We might get access denied while trying to connect to a remote fax server.
                //    This is probably the RPC infrastructure failing us.
                //    This only happens because we're using RPC_C_AUTHN_LEVEL_PKT_PRIVACY authentication level
                //    and the calling user is not trusted.
                //    This is usally happens when talking to Windows NT4 (all flavors) and Windows 2000 RTM (SP1 and above are excluded).
                //
                //    We might get RPC_S_INVALID_AUTH_IDENTITY:
                //    This means the client cannot get credentials to authenticate.
                //    In this case, drop the RPC authentication level back to RPC_C_AUTHN_LEVEL_NONE
                //
                //    We might get RPC_S_UNKNOWN_AUTHN_SERVICE:
                //    We probably dealing with Win9x or winMe OS.
                //    Drop the authenticate level to RPC_C_AUTHN_LEVEL_NONE when talking to this downlevel client
                //
                //    Or we might get another error code and we should try to drop the auth level
                //
                //    There is no security hole here - the down level clients that supports private channel will
                //    reject unsecured notifications

                //
                // Ask for no privacy.
                //
                RPC_SECURITY_QOS    rpcSecurityQOS = {  RPC_C_SECURITY_QOS_VERSION,
                                                        RPC_C_QOS_CAPABILITIES_DEFAULT,
                                                        RPC_C_QOS_IDENTITY_STATIC,
                                                        RPC_C_IMP_LEVEL_IDENTIFY    // Server can obtain information about 
                                                                                    // client security identifiers and privileges, 
                                                                                    // but cannot impersonate the client. 
                };

                dwRes  = RpcBindingSetAuthInfoEx (
                            hFaxHandle,    			        // RPC binding handle
                            TEXT(""),  						// Server principal name - ignored for RPC_C_AUTHN_WINNT
                            RPC_C_AUTHN_LEVEL_NONE,         // Authentication level - NONE
                                                            // Authenticates, verifies, and privacy-encrypts the arguments passed
                                                            // to every remote call.
                            RPC_C_AUTHN_WINNT,              // Authentication service (NTLMSSP)
                            NULL,                           // Authentication identity - use currently logged on user
                            0,                              // Unused when Authentication service == RPC_C_AUTHN_WINNT
                            &rpcSecurityQOS);               // Defines the security quality-of-service
                if (RPC_S_OK != dwRes)
                {
                    //
                    // Couldn't set RPC authentication mode
                    //
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("RpcBindingSetAuthInfoEx (RPC_C_AUTHN_LEVEL_NONE) failed. (ec: %lu)"),
                        dwRes);     
                }
                else
                {
                    dwRes = FAX_OpenConnection( hFaxHandle, Context, &hFaxClientContext );
                    if (ERROR_SUCCESS != dwRes)
                    {
                        DumpRPCExtendedStatus();
                        DebugPrintEx(DEBUG_ERR,TEXT("third attempt of FAX_OpenConnection() with RPC_C_AUTHN_LEVEL_NONE failed, ec=0x%08x"), dwRes );
                    }
                }
            }
        }
    }
    RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
    {
        dwRes = GetExceptionCode();
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_OpenConnection failed (exception = %ld)"),
                dwRes);
    }
    RpcEndExcept
    if (ERROR_SUCCESS != dwRes)
    {
        DumpRPCExtendedStatus();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to open connection with ec=0x%08x"),
            dwRes);
        goto exit;
    }   
    
    //
    // For legacy clients we need to send FEI_FAXSVC_STARTED
    //
    if (TRUE == fLegacyClient)
    {
        FAX_EVENT FaxEvent = {0};
        DWORD ec;

        FaxEvent.SizeOfStruct = sizeof(FAX_EVENT);
        GetSystemTimeAsFileTime( &FaxEvent.TimeStamp );
        FaxEvent.EventId = FEI_FAXSVC_STARTED;
        FaxEvent.DeviceId = 0;
        FaxEvent.JobId = 0xffffffff;

        RpcTryExcept
        {
            //
            // Send FEI_FAXSVC_STARTED to the client
            //
            ec = FAX_ClientEventQueue( hFaxClientContext, FaxEvent );                   
        }
        RpcExcept(I_RpcExceptionFilter(RpcExceptionCode()))
        {
            ec  = GetExceptionCode();
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("FAX_ClientEventQueue failed (exception = %ld)"),
                    ec);
        }
        RpcEndExcept
        if (ERROR_SUCCESS != ec)
        {
            DumpRPCExtendedStatus ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FAX_ClientEventQueue Failed with ec = %ld"),
                ec);            
        }
    }
    
    //
    // success  - Set the context handle in the client object
    //
    EnterCriticalSection (&g_CsClients);    
    pClient->SetContextHandle(hFaxClientContext);
    LeaveCriticalSection (&g_CsClients);

    Assert (ERROR_SUCCESS == dwRes);    

exit:
	DWORD rVal = ReleaseClient(ClientID);
	if (ERROR_SUCCESS != rVal)
	{
		DebugPrintEx(
                DEBUG_ERR,
				TEXT("CClientsMap::ReleaseClient Failed with ec = %ld"),
                rVal); 
	}
    return dwRes;
} // CClientsMap::OpenClientConnection





/************************************
*                                   *
*         Functions                 *
*                                   *
************************************/
DWORD
FaxSendEventThread(
    LPVOID UnUsed
    )
/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    query the send events completion port

Arguments:

    UnUsed          - UnUsed pointer

Return Value:

    Always zero.

--*/

{
    DWORD dwBytes;
    ULONG_PTR CompletionKey;    
    DWORD dwRes;    
    CClientID* pClientID=NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxSendEventThread"));

    while( TRUE )
    {
        if (!GetQueuedCompletionStatus( g_hSendEventsCompPort,
                                        &dwBytes,
                                        &CompletionKey,
                                        (LPOVERLAPPED*) &pClientID,
                                        INFINITE
                                      ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"),
            GetLastError());
            continue;
        }

        Assert (CLIENT_COMPLETION_KEY == CompletionKey              ||
                CLIENT_OPEN_CONN_COMPLETION_KEY == CompletionKey    ||
                SERVICE_SHUT_DOWN_KEY == CompletionKey);                

        //
        // if service is going down skip the notification
        //

        if (CLIENT_COMPLETION_KEY == CompletionKey      && 
            FALSE == g_bServiceIsDown   )
        {
            //
            // Send notification to the client
            //           

            dwRes = g_pClientsMap->Notify (*pClientID);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CClientsMap::Notify() failed, ec=0x%08x"),
                    dwRes);
            }
            delete pClientID;
            pClientID = NULL;
            continue;
        }
        else if (CLIENT_OPEN_CONN_COMPLETION_KEY == CompletionKey    &&
                 FALSE == g_bServiceIsDown   )   
        {
            //
            // Open connection to the client - Get context handle
            // 
            dwRes = g_pClientsMap->OpenClientConnection (*pClientID);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CClientsMap::OpenClientConnection() failed, ec=0x%08x"),
                    dwRes);

                //
                // Remove this client fromm the map
                //				
                dwRes = g_pClientsMap->ReleaseClient(*pClientID);				
				if (ERROR_SUCCESS != dwRes)
				{
					DebugPrintEx(
						DEBUG_ERR,
						TEXT("CClientsMap::ReleaseClient() failed, ec=0x%08x"),
						dwRes);
				}
            }
            delete pClientID;
            pClientID = NULL;
            continue;
        }
        else if (SERVICE_SHUT_DOWN_KEY == CompletionKey)
        {
            //
            // Terminate events thread - Notify another event thread
            //
            if (!PostQueuedCompletionStatus(
                g_hSendEventsCompPort,
                0,
                SERVICE_SHUT_DOWN_KEY,
                (LPOVERLAPPED) NULL))
            {
                dwRes = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY). (ec: %ld)"),
                    dwRes);
            }
            break;
        }
        else
        {
            //
            // if service is going down skip the event adding
            //

            delete pClientID;
            pClientID = NULL;
        }
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return ERROR_SUCCESS;
} // FaxSendEventThread


DWORD
FaxDispatchEventThread(
    LPVOID UnUsed
    )
/*++

Routine Description:

    This fuction runs asychronously as a separate thread to
    query the dispatch events completion port

Arguments:

    UnUsed          - UnUsed pointer

Return Value:

    Always zero.

--*/
{
    DWORD dwBytes;
    ULONG_PTR CompletionKey;    
    DWORD dwRes;
    CFaxEvent* pFaxEvent = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxDispatchEventThread"));

    while( TRUE )
    {
        if (!GetQueuedCompletionStatus( g_hDispatchEventsCompPort,
                                        &dwBytes,
                                        &CompletionKey,
                                        (LPOVERLAPPED*) &pFaxEvent,
                                        INFINITE
                                      ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"),
            GetLastError());
            continue;
        }
        Assert (EVENT_COMPLETION_KEY == CompletionKey               ||              
                SERVICE_SHUT_DOWN_KEY == CompletionKey);                

        //
        // if service is going down skip the notification
        //

        if (EVENT_COMPLETION_KEY == CompletionKey   &&
            FALSE == g_bServiceIsDown   )
        {
            //
            // Add event to the clients in the clients map
            //          
            dwRes = g_pClientsMap->AddEvent(pFaxEvent);
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("GetQueuedCompletionStatus() failed, ec=0x%08x"),
                    dwRes);
            }
            delete pFaxEvent;
            pFaxEvent = NULL;
            continue;
        }
        else if (SERVICE_SHUT_DOWN_KEY == CompletionKey)
        {            
            break;
        }
        else
        {
            //
            // if service is going down skip the event adding
            //

            delete pFaxEvent;
            pFaxEvent = NULL;
        }
    }

    if (!DecreaseServiceThreadsCount())
    {
        DebugPrintEx(
                DEBUG_ERR,
                TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                GetLastError());
    }
    return ERROR_SUCCESS;
} // FaxDispatchEventThread


DWORD
InitializeServerEvents ()
/*++

Routine name : InitializeServerEvents

Routine description:

    Creates the events completion ports and the Event Threads

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("InitializeServerEvents"));
    DWORD i;
    DWORD ThreadId;
    HANDLE hSendEventThreads[TOTAL_EVENTS_THREADS] = {0};
    HANDLE hDispatchEventThread = NULL;

    //
    // create send event completion port.
    //
    g_hSendEventsCompPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,
                                                NULL,
                                                0,
                                                MAX_EVENTS_THREADS
                                                );
    if (!g_hSendEventsCompPort)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create g_hSendEventsCompPort (ec: %ld)"),
            dwRes);
        return dwRes;
    }

    //
    // create dispatch event completion port.
    //
    g_hDispatchEventsCompPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE,
                                                NULL,
                                                0,
                                                1);
    if (!g_hDispatchEventsCompPort)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create g_hDispatchEventsCompPort (ec: %ld)"),
            dwRes);
        return dwRes;
    }

    //
    // Create FaxSendEventThread
    //
    for (i = 0; i < TOTAL_EVENTS_THREADS; i++)
    {
        hSendEventThreads[i] = CreateThreadAndRefCount(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE) FaxSendEventThread,
            NULL,
            0,
            &ThreadId
            );

        if (!hSendEventThreads[i])
        {
            dwRes = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to create send event thread %d (CreateThreadAndRefCount)(ec=0x%08x)."),
                i,
                dwRes);
            goto exit;
        }
    }

    //
    // Create FaxDispatchEventThread
    //    
    
    hDispatchEventThread = CreateThreadAndRefCount(
        NULL,
        0,
        (LPTHREAD_START_ROUTINE) FaxDispatchEventThread,
        NULL,
        0,
        &ThreadId
        );

    if (!hDispatchEventThread)
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create dispatch event(CreateThreadAndRefCount)(ec=0x%08x)."),            
            dwRes);
        goto exit;
    }    

    Assert (ERROR_SUCCESS == dwRes);

exit:
    //
    // Close the thread handles we no longer need them
    //
    for (i = 0; i < TOTAL_EVENTS_THREADS; i++)
    {
        if (NULL != hSendEventThreads[i])
        {
            if (!CloseHandle(hSendEventThreads[i]))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to close thread handle at index %ld [handle = 0x%08X] (ec=0x%08x)."),
                    i,
                    hSendEventThreads[i],
                    GetLastError());
            }
       }
    }

    if (NULL != hDispatchEventThread)
    {
        if (!CloseHandle(hDispatchEventThread))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to close thread handle [handle = 0x%08X] (ec=0x%08x)."),                
                hDispatchEventThread,
                GetLastError());
        }
    }

    return dwRes;
}  // InitializeServerEvents


DWORD
PostFaxEventEx (
    PFAX_EVENT_EX pFaxEvent,
    DWORD dwEventSize,
    PSID pUserSid)
/*++

Routine name : PostFaxEventEx

Routine description:

    Posts a CFaxEventExtended object to the events completion port.
    FaxSendEventThread must call delete to deallocate the object.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    pFaxEvent           [in] - Pointer to the serialized FAX_EVENT_EX buffer
    dwEventSize         [in] - The FAX_EVENT_EX buffer size
    pUserSid            [in] - The user sid to associate with the event

Return Value:

    Standard Win32 error code

--*/
{

    DEBUG_FUNCTION_NAME(TEXT("PostFaxEventEx"));
    Assert (pFaxEvent && (dwEventSize >= sizeof(FAX_EVENT_EX)));
    DWORD dwRes = ERROR_SUCCESS;    

    if (TRUE == g_bServiceIsDown)
    {
        //
        // The service is going down, no need to post this Event
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Service is going down, no need to post this Event.")
            );                          

        return ERROR_SERVICE_NOT_ACTIVE;
    }

    CFaxEventExtended* pExtendedEvent = NULL;
    try
    {
        pExtendedEvent = new (std::nothrow) CFaxEventExtended(
            pFaxEvent,
            dwEventSize,
            pUserSid);        
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxEventExtended caused exception (%S)"),
            ex.what());                         
    }
    
    if (NULL == pExtendedEvent)
    {       
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate new CFaxEventExtended"));
        return ERROR_OUTOFMEMORY;
    }

    //
    // post the CFaxEventExtended object to the event completion port
    //
    if (!PostQueuedCompletionStatus( g_hDispatchEventsCompPort,
                                     sizeof(CFaxEventExtended*),
                                     EVENT_COMPLETION_KEY,
                                     (LPOVERLAPPED) pExtendedEvent))
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostQueuedCompletionStatus failed. (ec: %ld)"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        delete pExtendedEvent;
    }
    return dwRes;
}   // PostFaxEventEx




DWORD
CreateQueueEvent (
    FAX_ENUM_JOB_EVENT_TYPE JobEventType,
    const PJOB_QUEUE lpcJobQueue
    )
/*++

Routine name : CreateQueueEvent

Routine description:

    Creates FAX_EVENT_TYPE_*_QUEUE event.
    Must be called inside critical section and g_CsQueue and if there is job status inside g_CsJob also.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    JobEventType        [in] - Specifies the job event type FAX_ENUM_JOB_EVENT_TYPE
    lpcJobQueue         [in] - Pointer to the job queue entry

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateQueueEvent"));
    ULONG_PTR dwOffset = sizeof(FAX_EVENT_EX);
    DWORD dwRes = ERROR_SUCCESS;
    PFAX_EVENT_EXW pEvent = NULL;
    FAX_ENUM_EVENT_TYPE EventType;
    PSID pUserSid = NULL;
    DWORDLONG dwlMessageId;

    Assert (lpcJobQueue);

    dwlMessageId = lpcJobQueue->UniqueId;
    if (JT_SEND == lpcJobQueue->JobType)
    {
        // outbound job
        Assert (lpcJobQueue->lpParentJob);

        EventType = FAX_EVENT_TYPE_OUT_QUEUE;
        pUserSid = lpcJobQueue->lpParentJob->UserSid;
    }
    else
    {
        // Inbound job
        Assert (JT_RECEIVE          == lpcJobQueue->JobType ||
                JT_ROUTING          == lpcJobQueue->JobType);

        EventType = FAX_EVENT_TYPE_IN_QUEUE;
    }

    if (FAX_JOB_EVENT_TYPE_ADDED == JobEventType ||
        FAX_JOB_EVENT_TYPE_REMOVED == JobEventType)
    {
        // No job status
        pEvent = (PFAX_EVENT_EX)MemAlloc (dwOffset);
        if (NULL == pEvent)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error allocatin FAX_EVENT_EX"));
            return ERROR_OUTOFMEMORY;
        }
        (pEvent->EventInfo).JobInfo.pJobData = NULL;
    }
    else
    {
        //
        // Status change
        //
        Assert (FAX_JOB_EVENT_TYPE_STATUS == JobEventType);

        //
        // Get the needed buffer size to hold FAX_JOB_STATUSW serialized info
        //
        if (!GetJobStatusDataEx (NULL,
                                 NULL,
                                 FAX_API_VERSION_1, // Always pick full data
                                 lpcJobQueue,
                                 &dwOffset,
								 0))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("GetJobStatusDataEx failed (ec: %ld)"),
                       dwRes);
            return dwRes;
        }

        //
        // Allocate the buffer
        //
		DWORD dwEventSize = dwOffset;
        pEvent = (PFAX_EVENT_EXW)MemAlloc (dwEventSize);
        if (NULL == pEvent)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error allocatin FAX_EVENT_EX"));
            return ERROR_OUTOFMEMORY;
        }

        //
        // Fill the buffer
        //
        dwOffset = sizeof(FAX_EVENT_EXW);
        (pEvent->EventInfo).JobInfo.pJobData = (PFAX_JOB_STATUSW)dwOffset;
        PFAX_JOB_STATUSW pFaxStatus = (PFAX_JOB_STATUSW) ((LPBYTE)pEvent + (ULONG_PTR)dwOffset);
        dwOffset += sizeof(FAX_JOB_STATUSW);
        if (!GetJobStatusDataEx ((LPBYTE)pEvent,
                                 pFaxStatus,
                                 FAX_API_VERSION_1, // Always pick full data
                                 lpcJobQueue,
                                 &dwOffset,
								 dwEventSize
								 ))
        {
            dwRes = GetLastError();
            DebugPrintEx(
                       DEBUG_ERR,
                       TEXT("GetJobStatusDataEx failed (ec: %ld)"),
                       dwRes);
            goto exit;
        }
    }

    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EXW);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );
    pEvent->EventType = EventType;
    (pEvent->EventInfo).JobInfo.dwlMessageId = dwlMessageId;
    (pEvent->EventInfo).JobInfo.Type = JobEventType;

    dwRes = PostFaxEventEx (pEvent, dwOffset, pUserSid);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("PostFaxEventEx failed (ec: %ld)"),
                   dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:    
    MemFree (pEvent);
    return dwRes;
}  //  CreateQueueEvent


DWORD
CreateConfigEvent (
    FAX_ENUM_CONFIG_TYPE ConfigType
    )
/*++

Routine name : CreateConfigEvent

Routine description:

    Creates FAX_EVENT_TYPE_CONFIG event.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    ConfigType          [in ] - The configuration event type FAX_ENUM_CONFIG_TYPE

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateConfigEvent"));
    PFAX_EVENT_EX pEvent = NULL;
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwEventSize = sizeof(FAX_EVENT_EX);

    pEvent = (PFAX_EVENT_EX)MemAlloc (dwEventSize);
    if (NULL == pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin FAX_EVENT_EX"));
        return ERROR_OUTOFMEMORY;
    }

    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );

    pEvent->EventType = FAX_EVENT_TYPE_CONFIG;
    (pEvent->EventInfo).ConfigType = ConfigType;

    dwRes = PostFaxEventEx (pEvent, dwEventSize, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("PostFaxEventEx failed (ec: %ld)"),
                   dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:  
    MemFree (pEvent);    
    return dwRes;
}  //  CreateConfigEvent



DWORD
CreateQueueStateEvent (
    DWORD dwQueueState
    )
    /*++

Routine name : CreateQueueStateEvent

Routine description:

    Creates FAX_EVENT_TYPE_QUEUE_STATE event.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    dwQueueState            [in ] - The new queue state

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateQueueStateEvent"));
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwEventSize = sizeof(FAX_EVENT_EX);
    PFAX_EVENT_EX pEvent = NULL;

    Assert ( (dwQueueState == 0) ||
             (dwQueueState & FAX_INCOMING_BLOCKED) ||
             (dwQueueState & FAX_OUTBOX_BLOCKED) ||
             (dwQueueState & FAX_OUTBOX_PAUSED) );

    pEvent = (PFAX_EVENT_EX)MemAlloc (dwEventSize);
    if (NULL == pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin FAX_EVENT_EX"));
        return ERROR_OUTOFMEMORY;
    }

    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );

    pEvent->EventType = FAX_EVENT_TYPE_QUEUE_STATE;
    (pEvent->EventInfo).dwQueueStates = dwQueueState;

    dwRes = PostFaxEventEx (pEvent, dwEventSize, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("PostFaxEventEx failed (ec: %ld)"),
                   dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:    
    MemFree (pEvent);    
    return dwRes;
}  //  CreateQueueStateEvent

DWORD
CreateDeviceEvent (
    PLINE_INFO pLine,
    BOOL       bRinging
)
/*++

Routine name : CreateDeviceEvent

Routine description:

    Creates FAX_EVENT_TYPE_DEVICE_STATUS event.

Author:

    Eran Yariv (EranY), July, 2000

Arguments:

    pLine            [in] - Device
    bRinging         [in] - Is the device ringing now?

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateDeviceEvent"));
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwEventSize = sizeof(FAX_EVENT_EX);
    PFAX_EVENT_EX pEvent = NULL;

    pEvent = (PFAX_EVENT_EX)MemAlloc (dwEventSize);
    if (NULL == pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin FAX_EVENT_EX"));
        return ERROR_OUTOFMEMORY;
    }

    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );

    pEvent->EventType = FAX_EVENT_TYPE_DEVICE_STATUS;
    EnterCriticalSection (&g_CsLine);
    (pEvent->EventInfo).DeviceStatus.dwDeviceId = pLine->PermanentLineID;;
    (pEvent->EventInfo).DeviceStatus.dwNewStatus =
        (pLine->dwReceivingJobsCount      ? FAX_DEVICE_STATUS_RECEIVING   : 0) |
        (pLine->dwSendingJobsCount        ? FAX_DEVICE_STATUS_SENDING     : 0) |
        (bRinging                         ? FAX_DEVICE_STATUS_RINGING     : 0);

    LeaveCriticalSection (&g_CsLine);

    dwRes = PostFaxEventEx (pEvent, dwEventSize, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("PostFaxEventEx failed (ec: %ld)"),
                   dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:    
    MemFree (pEvent);    
    return dwRes;
}  //  CreateDeviceEvent



DWORD
CreateArchiveEvent (
    DWORDLONG dwlMessageId,
    FAX_ENUM_EVENT_TYPE EventType,
    FAX_ENUM_JOB_EVENT_TYPE MessageEventType,
    PSID pUserSid
    )
/*++

Routine name : CreateArchiveEvent

Routine description:

    Creates archive event.

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    dwlMessageId        [in] - The message unique id
    EventType           [in] - Specifies the event type (In or Out archive)
    pUserSid            [in] - The user sid to associate with the event
    MessageEventType    [in] - Message event type (added or removed).

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateArchiveEvent"));
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwEventSize = sizeof(FAX_EVENT_EX);
    PFAX_EVENT_EX pEvent = NULL;

    Assert ( EventType == FAX_EVENT_TYPE_IN_ARCHIVE ||
             EventType == FAX_EVENT_TYPE_OUT_ARCHIVE);

    Assert ( MessageEventType == FAX_JOB_EVENT_TYPE_ADDED ||
             MessageEventType == FAX_JOB_EVENT_TYPE_REMOVED );

    pEvent = (PFAX_EVENT_EX)MemAlloc (dwEventSize);
    if (NULL == pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin FAX_EVENT_EX"));
        return ERROR_OUTOFMEMORY;
    }

    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );

    pEvent->EventType = EventType;
    (pEvent->EventInfo).JobInfo.pJobData = NULL;
    (pEvent->EventInfo).JobInfo.dwlMessageId = dwlMessageId;
    (pEvent->EventInfo).JobInfo.Type = MessageEventType;

    dwRes = PostFaxEventEx (pEvent, dwEventSize, pUserSid);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("PostFaxEventEx failed (ec: %ld)"),
                   dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:        
    MemFree (pEvent);        
    return dwRes;

}  //  CreateArchiveEvent



DWORD
CreateActivityEvent ()
/*++

Routine name : CreateActivityEvent

Routine description:

    Creates FAX_EVENT_TYPE_ACTIVITY event.
    Must be called inside critical section g_CsActivity

Author:

    Oded Sacher (OdedS),    Jan, 2000

Arguments:

    None

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateActivityEvent"));
    DWORD dwRes = ERROR_SUCCESS;
    DWORD dwEventSize = sizeof(FAX_EVENT_EX);
    PFAX_EVENT_EX pEvent = NULL;

    pEvent = (PFAX_EVENT_EX)MemAlloc (dwEventSize);
    if (NULL == pEvent)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error allocatin FAX_EVENT_EX"));
        return ERROR_OUTOFMEMORY;
    }

    pEvent->dwSizeOfStruct = sizeof(FAX_EVENT_EX);
    GetSystemTimeAsFileTime( &(pEvent->TimeStamp) );

    pEvent->EventType = FAX_EVENT_TYPE_ACTIVITY;
    CopyMemory (&((pEvent->EventInfo).ActivityInfo), &g_ServerActivity, sizeof(FAX_SERVER_ACTIVITY));
    GetEventsCounters ( &((pEvent->EventInfo).ActivityInfo.dwErrorEvents),
                        &((pEvent->EventInfo).ActivityInfo.dwWarningEvents),
                        &((pEvent->EventInfo).ActivityInfo.dwInformationEvents));


    dwRes = PostFaxEventEx (pEvent, dwEventSize, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("PostFaxEventEx failed (ec: %ld)"),
                   dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:    
    MemFree (pEvent);    
    return dwRes;
}  //  CreateActivityEvent


#ifdef DBG
LPWSTR  lpszEventCodes[]= {
    L"FEI_DIALING",
    L"FEI_SENDING",
    L"FEI_RECEIVING",
    L"FEI_COMPLETED",
    L"FEI_BUSY",
    L"FEI_NO_ANSWER",
    L"FEI_BAD_ADDRESS",
    L"FEI_NO_DIAL_TONE",
    L"FEI_DISCONNECTED",
    L"FEI_FATAL_ERROR",
    L"FEI_NOT_FAX_CALL",
    L"FEI_CALL_DELAYED",
    L"FEI_CALL_BLACKLISTED",
    L"FEI_RINGING",
    L"FEI_ABORTING",
    L"FEI_ROUTING",
    L"FEI_MODEM_POWERED_ON",
    L"FEI_MODEM_POWERED_OFF",
    L"FEI_IDLE",
    L"FEI_FAXSVC_ENDED",
    L"FEI_ANSWERED",
    L"FEI_JOB_QUEUED",
    L"FEI_DELETED",
    L"FEI_INITIALIZING",
    L"FEI_LINE_UNAVAILABLE",
    L"FEI_HANDLED",
    L"FEI_FAXSVC_STARTED"};


LPTSTR GetEventCodeString(DWORD dwEventCode)
{
    if (dwEventCode<FEI_DIALING || dwEventCode>FEI_FAXSVC_STARTED)
    {
        return L"*** INVALID EVENT CODE ***";
    }
    else
    {
        return lpszEventCodes[dwEventCode-1];
    }
}
#endif



//*********************************************************************************
//* Name:   CreateFaxEvent()
//* Author: Ronen Barenboim
//* Date:   March 21, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates a CFaxEventLegacy object. Initializes it and posts it to the
//*     events completion port with completion key EVENT_COMPLETION_KEY.
//*     FaxDispatchEventThread should call delete to deallocate the object.
//* PARAMETERS:
//*     DeviceId
//*
//*     EventId
//*
//*     DWORD JobId
//*
//* RETURN VALUE:
//*     FALSE
//*         If not enough memory is available to allocated the FAX_EVENT structure
//*     TRUE
//*         If the operation completed successfully
//*
//*     To get extended error information, call GetLastError .
//*
//* REMARKS:
//*
//*********************************************************************************
BOOL CreateFaxEvent(
    DWORD DeviceId,
    DWORD EventId,
    DWORD JobId
    )
{
    CFaxEventLegacy* pFaxLegacyEvent = NULL;
    FAX_EVENT FaxEvent = {0};
    DEBUG_FUNCTION_NAME(TEXT("CreateFaxEvent"));

    if (TRUE == g_bServiceIsDown)
    {
        //
        // The service is going down, no need to post this Event
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Service is going down, no need to post this Event.")
            );                          

        return FALSE;
    }

    if (NULL == g_hDispatchEventsCompPort)
    {
        //
        // Events mechanism is not yet initialized
        //
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("Events mechanism is not yet initialized"));
        return TRUE;
    }
    
    //
    // Note: W2K Fax did issue notifications with EventId == 0 whenever an
    // FSP reported proprietry status code. To keep backward compatability
    // we keep up this behaviour although it might be regarded as a bug
    //
    FaxEvent.SizeOfStruct = sizeof(FAX_EVENT);
    GetSystemTimeAsFileTime( &FaxEvent.TimeStamp );
    FaxEvent.EventId = EventId;
    FaxEvent.DeviceId = DeviceId;
    FaxEvent.JobId = JobId;
#if DBG
    WCHAR szTime[256] = {0};
    DebugDateTime(*(DWORDLONG *)&FaxEvent.TimeStamp, szTime, ARR_SIZE(szTime));
    DebugPrintEx(DEBUG_MSG,TEXT("Sending notification. Event = %s(0x%0X), Device Id = 0x%0X , Time = %s"), GetEventCodeString(EventId), EventId, DeviceId, szTime);
#endif

    try
    {
        pFaxLegacyEvent = new (std::nothrow) CFaxEventLegacy(&FaxEvent);        
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxEventLegacy caused exception (%S)"),
            ex.what());                         
    }
    
    if (NULL == pFaxLegacyEvent)
    {       
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate new pFaxLegacyEvent"));
        return FALSE;
    }

    if (!PostQueuedCompletionStatus(
            g_hDispatchEventsCompPort,
            sizeof(CFaxEventLegacy*),
            EVENT_COMPLETION_KEY,  
            (LPOVERLAPPED) pFaxLegacyEvent))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostQueuedCompletionStatus failed. (ec: %ld)"),
            GetLastError());
        delete  pFaxLegacyEvent;        
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\extensiondata.cpp ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ExtensionData.cpp

Abstract:

    This file provides implementation of the named
    extension data functions (get / set / notify)

Author:

    Eran Yariv (EranY)  Nov, 1999

Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

static
DWORD
FAXGetExtensionData (
    IN DWORD                        dwOrigDeviceId,
    IN FAX_ENUM_DEVICE_ID_SOURCE    DevIdSrc,
    IN LPCWSTR                      lpctstrNameGUID,
    IN OUT LPBYTE                  *ppData,
    IN OUT LPDWORD                  lpdwDataSize
);


static
DWORD
FAXSetExtensionData (
    IN HINSTANCE                    hInst,
    IN LPCWSTR                      lpcwstrComputerName,
    IN DWORD                        dwOrigDeviceId,
    IN FAX_ENUM_DEVICE_ID_SOURCE    DevIdSrc,
    IN LPCWSTR                      lpctstrNameGUID,
    IN LPBYTE                       pData,
    IN DWORD                        dwDataSize
);

static
BOOL
FindTAPIPermanentLineIdFromFaxDeviceId (
    IN  DWORD   dwFaxDeviceId,
    OUT LPDWORD lpdwTapiLineId
);



BOOL CExtNotifyCallbackPacket::Init(
       PFAX_EXT_CONFIG_CHANGE pCallback,
       DWORD dwDeviceId,
       LPCWSTR lpcwstrDataGuid,
       LPBYTE lpbData,
       DWORD dwDataSize)

{
    DEBUG_FUNCTION_NAME(TEXT("CExtNotifyCallbackPacket::Init"));
    DWORD ec = ERROR_SUCCESS;

    Assert(pCallback);
    Assert(lpcwstrDataGuid);
    Assert(lpbData);
    Assert(dwDataSize);

    Assert(m_lpbData == NULL);

    m_pCallback = pCallback;
    m_dwDeviceId = dwDeviceId;

    m_lpwstrGUID = StringDup (lpcwstrDataGuid);
    if (!m_lpwstrGUID)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Cannot allocate memory to copy string %s"),
            lpcwstrDataGuid);
        goto Error;
    }

    m_dwDataSize = dwDataSize;

    m_lpbData = (LPBYTE)MemAlloc(m_dwDataSize);
    if (!m_lpbData)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate data for callback packet. Size (%ld)"),
            m_dwDataSize);
        goto Error;

    }

    memcpy(m_lpbData, lpbData, m_dwDataSize);
    goto Exit;

Error:
    MemFree(m_lpwstrGUID);
    MemFree(m_lpbData);
    m_lpwstrGUID = NULL;
    m_lpbData = NULL;
Exit:
    return (ERROR_SUCCESS == ec);
};

CExtNotifyCallbackPacket::CExtNotifyCallbackPacket()
{
    m_lpwstrGUID = NULL;
    m_lpbData = NULL;
}


CExtNotifyCallbackPacket::~CExtNotifyCallbackPacket()
{
    MemFree(m_lpwstrGUID);
    MemFree(m_lpbData);
}


/************************************
*                                   *
*         CDeviceAndGUID            *
*                                   *
************************************/

bool
CDeviceAndGUID::operator < ( const CDeviceAndGUID &other ) const
/*++

Routine name : operator <

Class: CDeviceAndGUID

Routine description:

    Compares myself with another Device and GUID key

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    other           [in] - Other key

Return Value:

    true only is i'm less than the other key

--*/
{
    if (m_dwDeviceId < other.m_dwDeviceId)
    {
        return true;
    }
    if (m_dwDeviceId > other.m_dwDeviceId)
    {
        return false;
    }
    //
    // Equal device id, comapre GUIDs
    //
    return (m_strGUID.compare (other.m_strGUID) < 0);
}   // CDeviceAndGUID::operator <



/************************************
*                                   *
*      CLocalNotificationSink       *
*                                   *
************************************/


CLocalNotificationSink::CLocalNotificationSink (
    PFAX_EXT_CONFIG_CHANGE lpConfigChangeCallback,
    DWORD                  dwNotifyDeviceId,
    HINSTANCE              hInst) :
        CNotificationSink (),
        m_lpConfigChangeCallback (lpConfigChangeCallback),
        m_dwNotifyDeviceId (dwNotifyDeviceId),
        m_hInst (hInst)
/*++

Routine name : CLocalNotificationSink::CLocalNotificationSink

Class: CLocalNotificationSink

Routine description:

    CEtensionNotificationSink constractor

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    lpConfigChangeCallback    [in] - Pointer to notification callback
    dwNotifyDeviceId          [in] - Device id to notify with


Return Value:

    None.

--*/
{
    m_type = SINK_TYPE_LOCAL;
}   // CLocalNotificationSink::CLocalNotificationSink


bool
CLocalNotificationSink::operator == (
    const CNotificationSink &rhs
) const
{
    Assert (SINK_TYPE_UNKNOWN != rhs.Type());
    //
    // Comapre types and then downcast to CLocalNotificationSink and compare pointers
    //
    return ((SINK_TYPE_LOCAL == rhs.Type()) &&
            (m_lpConfigChangeCallback ==
             (static_cast<const CLocalNotificationSink&>(rhs)).m_lpConfigChangeCallback
            )
           );
}   // CLocalNotificationSink::operator ==

HRESULT
CLocalNotificationSink::Notify (
    DWORD   dwDeviceId,
    LPCWSTR lpcwstrNameGUID,
    LPCWSTR lpcwstrComputerName,
    HANDLE  hModule,
    LPBYTE  lpData,
    DWORD   dwDataSize,
    LPBOOL  lpbRemove
)
/*++

Routine name : CLocalNotificationSink::Notify

Class: CLocalNotificationSink

Routine description:

    Notify the sink

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId      [in ] - Device id
    lpcwstrNameGUID [in ] - Data name
    lpData          [in ] - Pointer to data
    dwDataSize      [in ] - Data size
    lpbRemove       [out] - Set to TRUE if this sink cannot be used and must be removed.

Return Value:

    Standard HRESULT.

--*/
{
    HRESULT hr = NOERROR;

    CExtNotifyCallbackPacket * pCallbackPacket = NULL;
    DEBUG_FUNCTION_NAME(TEXT("CLocalNotificationSink::Notify"));

    Assert (m_lpConfigChangeCallback);  // Should have caught it in FaxExtRegisterForExtensionEvents
    *lpbRemove = FALSE;
    if (!lstrcmp (TEXT(""), lpcwstrComputerName))
    {
        //
        // The source of the data change was local (extension)
        //
        if (hModule == m_hInst)
        {
            //
            // The source of the data change is the same module this sink notifies to.
            // Don't notify and return success.
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Local extension (hInst = %ld) set data and the notification for it was blocked"),
                m_hInst);
            return hr;
        }
    }


    pCallbackPacket = new (std::nothrow) CExtNotifyCallbackPacket();
    if (!pCallbackPacket)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate callback packet"));

        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Error;
    }

    if (!pCallbackPacket->Init(
                        m_lpConfigChangeCallback,
                        m_dwNotifyDeviceId,
                        lpcwstrNameGUID,
                        lpData,
                        dwDataSize))
    {
        DWORD ec;
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to initialize callback packet (ec: %ld)"),
            ec);
        hr = HRESULT_FROM_WIN32(ec);
        goto Error;
    }


    if (!PostQueuedCompletionStatus (
            g_pNotificationMap->m_hCompletionPort,
            0,
            0,
            (LPOVERLAPPED)pCallbackPacket
        ))
    {
        DWORD dwRes;
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PostQueuedCompletionStatus failed. (ec: %ld)"),
            dwRes);
        hr = HRESULT_FROM_WIN32(dwRes);
        goto Error;
    }


goto Exit;
Error:
    if (pCallbackPacket)
    {
        delete pCallbackPacket;
    }

Exit:
    return hr;
}   // CLocalNotificationSink::Notify

/************************************
*                                   *
*            CSinksList             *
*                                   *
************************************/

CSinksList::~CSinksList ()
{
    DEBUG_FUNCTION_NAME(TEXT("CSinksList::~CSinksList"));
    try
    {
        for (SINKS_LIST::iterator it = m_List.begin(); it != m_List.end(); ++it)
        {
            CNotificationSink *pSink = *it;
            delete pSink;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Got an STL exception while clearing a sinks list (%S)"),
            ex.what());
    }
}   // CSinksList::~CSinksList ()

/************************************
*                                   *
*         CNotificationMap          *
*                                   *
************************************/

CNotificationMap::~CNotificationMap ()
{
    DEBUG_FUNCTION_NAME(TEXT("CNotificationMap::~CNotificationMap"));
    try
    {
        for (NOTIFY_MAP::iterator it = m_Map.begin(); it != m_Map.end(); ++it)
        {
            CSinksList *pSinksList = (*it).second;
            delete pSinksList;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Got an STL exception while clearing the notifications map (%S)"),
            ex.what());
    }
    //
    // Handle our completion port threads now
    //
    if (m_hCompletionPort)
    {        
        CloseHandle (m_hCompletionPort);
    }


    //
    // Close our critical section
    //
    m_CsExtensionData.SafeDelete();

}   // CNotificationMap::~CNotificationMap


void
CNotificationMap::Notify (
    DWORD   dwDeviceId,
    LPCWSTR lpcwstrNameGUID,
    LPCWSTR lpcwstrComputerName,
    HANDLE  hModule,
    LPBYTE  lpData,
    DWORD   dwDataSize)
/*++

Routine name : CNotificationMap::Notify

Class: CNotificationMap

Routine description:

    Notify the all the sinks (in a list) for a map lookup value.
    Each sink that returns a failure code (FALSE) is deleted and removed from
    the list.

    After the list is traversed, if it becomes empty, it is deleted and
    removed from the map.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    dwDeviceId          [in] - Device id
    lpcwstrNameGUID     [in] - Data name
    lpcwstrComputerName [in] - Computer where data changing module runs
    hModule             [in] - Handle of the module that changed the data
    lpData              [in] - Pointer to new data
    dwDataSize          [in] - New data size

Return Value:

    None.

--*/
{
    SINKS_LIST::iterator ListIter;
    CSinksList *pList;
    DEBUG_FUNCTION_NAME(TEXT("CNotificationMap::Notify"));

    //
    // We're notifying now - block calls to Add*Sink and Remove*Sink
    //
    if (g_bServiceIsDown)
    {
        //
        // We don't supply extension data services when the service is going down
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Called while service is shutting - operation canceled"));
        return;
    }
    Assert (!m_bNotifying);
    m_bNotifying = TRUE;
    CDeviceAndGUID key (dwDeviceId, lpcwstrNameGUID);
    NOTIFY_MAP::iterator it;

    if((it = m_Map.find(key)) == m_Map.end())
    {
        //
        // Key not found in map - no one to notify
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("No one to notify"));
        goto exit;
    }
    //
    // Retrieve list
    //
    pList = (*it).second;
    //
    // If the list is already being notified, we're in a loop here - quit now
    //
    if (pList->m_bNotifying)
    {
        //
        // OK, here's what happened.
        // We were walking the list and notifying each sink. One sink, while processing
        // it's notification, called FaxExtSetData on the same GUID + device ID.
        // This resulted in a 2nd notification attempt that we're now catching.
        // The second notification will not be sent !!!
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Notification loop caught on device ID = %ld, GUID = %s. 2nd notification cancelled"),
            dwDeviceId,
            lpcwstrNameGUID);
        goto exit;
    }
    //
    // Mark map value as busy notifying
    //
    pList->m_bNotifying = TRUE;
    //
    // Walk the list and notify each element
    //
    for (ListIter = pList->m_List.begin(); ListIter != pList->m_List.end(); ++ListIter)
    {
        CNotificationSink *pSink = (*ListIter);
        BOOL bRemove;


        pSink->Notify ( dwDeviceId,
                        lpcwstrNameGUID,
                        lpcwstrComputerName,
                        hModule,
                        lpData,
                        dwDataSize,
                        &bRemove
                      );
        if (bRemove)
        {
            //
            // The notification indicates that the sink became invalid.
            // This is a good time to remove it from the list.
            //
            //
            // Tell the sink to gracefully disconnect
            //
            HRESULT hr = pSink->Disconnect ();
            delete pSink;
            //
            // Remove item from list, advancing the iterator to next item (or end)
            //
            ListIter = pList->m_List.erase (ListIter);
        }
    }
    //
    // Mark map value as not busy notifying
    //
    pList->m_bNotifying = FALSE;
    //
    // We might get an empty list here at the end
    //
    if (pList->m_List.empty())
    {
        //
        // Remove empty list from map
        //
        delete pList;
        m_Map.erase (key);
    }
exit:
    //
    // We're not notifying any more - allow calls to Add*Sink and Remove*Sink
    //
    m_bNotifying = FALSE;
}   // CNotificationMap::Notify

CNotificationSink *
CNotificationMap::AddLocalSink (
    HINSTANCE               hInst,
    DWORD                   dwDeviceId,
    DWORD                   dwNotifyDeviceId,
    LPCWSTR                 lpcwstrNameGUID,
    PFAX_EXT_CONFIG_CHANGE  lpConfigChangeCallback
)
/*++

Routine name : CNotificationMap::AddLocalSink

Class: CNotificationMap

Routine description:

    Adds a local sink to the list of sinks for a given device id + GUID

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hInst                   [in] - Instance of extension
    dwDeviceId              [in] - Device id to listen to
    dwNotifyDeviceId        [in] - Device id to report in callback
    lpcwstrNameGUID         [in] - Data name
    lpConfigChangeCallback  [in] - Pointer to notification callback

Return Value:

    Pointer to newly created sink.
    If NULL, sets the last error.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    SINKS_LIST::iterator ListIter;
    NOTIFY_MAP::iterator it;
    CSinksList *pList;
    CNotificationSink *pSink = NULL;

    DEBUG_FUNCTION_NAME(TEXT("CNotificationMap::AddLocalSink"));

    Assert (lpConfigChangeCallback);    // Should have caught it in FaxExtRegisterForExtensionEvents

    if (m_bNotifying)
    {
        //
        // We're notifying now - can't change the list.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Caller tried to to add a local sink to a notification list while notifying"));
        SetLastError (ERROR_BUSY);  // The requested resource is in use.
        return NULL;
    }
    //
    // See if entry exists in map
    //
    CDeviceAndGUID key (dwDeviceId, lpcwstrNameGUID);
    if((it = m_Map.find(key)) == m_Map.end())
    {
        //
        // Key not found in map - add it with a new list
        //
        pList = new (std::nothrow) CSinksList;
        if (!pList)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Cannot allocate a new sinks list"));
            SetLastError (ERROR_NOT_ENOUGH_MEMORY);
            return NULL;
        }
        m_Map[key] = pList;
    }
    else
    {
        //
        // Get the existing list
        //
        pList = (*it).second;
    }
    //
    // Create new sink
    //
    pSink = new (std::nothrow) CLocalNotificationSink (lpConfigChangeCallback, dwNotifyDeviceId, hInst);
    if (!pSink)
    {
        //
        // Can't crate sink
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Cannot allocate a notification sink"));
        SetLastError (ERROR_NOT_ENOUGH_MEMORY);
        goto exit;
    }
    //
    // Scan the list to see if an identical sink already exists.
    //
    for (ListIter = pList->m_List.begin(); ListIter != pList->m_List.end(); ++ListIter)
    {
        CNotificationSink *pCurSink = (*ListIter);
        if (*pSink == *pCurSink)
        {
            //
            // Ooops, same sink already exists
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Caller tried to to add an indetical local sink to a notification list"));
            SetLastError (ERROR_ALREADY_ASSIGNED);
            //
            // Tell the sink to gracefully disconnect
            //
            HRESULT hr = pSink->Disconnect ();
            delete pSink;
            pSink = NULL;
            goto exit;
        }
    }
    //
    // Add the new sink
    //
    pList->m_List.insert (pList->m_List.end(), pSink);

exit:
    if (pList->m_List.empty())
    {
        //
        // Remove empty list from map
        //
        delete pList;
        m_Map.erase (key);
    }
    return pSink;
}   // CNotificationMap::AddLocalSink

DWORD
CNotificationMap::RemoveSink (
    CNotificationSink *pSinkToRemove
)
/*++

Routine name : CNotificationMap::RemoveSink

Class: CNotificationMap

Routine description:

    Removes a sink from the list of sinks for a given sink pointer.
    If the list is empty, it is deleted and removed from the map.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:


Return Value:

    Standard Win32 error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CNotificationMap::RemoveSink"));

    if (m_bNotifying)
    {
        //
        // We're notifying now - can't change the list.
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Caller tried to to add a local sink to a notification list while notifying"));
        return ERROR_BUSY;  // The requested resource is in use.
    }
    //
    // Lookup the sink
    //
    NOTIFY_MAP::iterator it;
    BOOL bFound = FALSE;
    for (it = m_Map.begin(); it != m_Map.end (); ++it)
    {
        //
        // Get map value (list of sinks)
        //
        CSinksList *pList = (*it).second;
        //
        // Lookup sink in list
        //
        SINKS_LIST::iterator ListIter;
        CNotificationSink *pSink = NULL;
        for (ListIter = pList->m_List.begin(); ListIter != pList->m_List.end(); ++ListIter)
        {
            pSink = (*ListIter);
            if (pSinkToRemove == pSink) // Pointer comparison !!!!
            {
                //
                // Found the sink - remove it
                //
                pList->m_List.erase (ListIter);
                HRESULT hr = pSinkToRemove->Disconnect ();
                delete pSinkToRemove;
                bFound = TRUE;
                break;
            }
        }
        if (bFound)
        {
            //
            // Since we removed a sink from the list, the list may become empty now
            //
            if (pList->m_List.empty())
            {
                //
                // Remove empty list
                //
                m_Map.erase (it);
                delete pList;
            }
            //
            // Break the map search
            //
            break;
        }
    }
    if (!bFound)
    {
        //
        // Reached the end of the map but the requested sink could not be found
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Caller tried to to remove a non-existent sink"));
        return ERROR_NOT_FOUND; // Element not found.
    }
    return ERROR_SUCCESS;
}   // CNotificationMap::RemoveSink


DWORD
CNotificationMap::ExtNotificationThread(
    LPVOID UnUsed
    )
/*++

Routine name : CNotificationMap::ExtNotificationThread

Routine description:

    This is the main thread function of the thread(s)
    that dequeue the notification completion port.

    This is a static class function !!!!

    Pointers to instances of ExtNotificationDataPacket are dequeued
    by this function and the map notificiation function is called on them.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    UnUsed          [in] - Unused

Return Value:

    Standard Win32 Error code

--*/
{
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("CNotificationMap::ExtNotificationThread"));

    for (;;)
    {
        DWORD        dwNumBytes;
        ULONG_PTR    CompletionKey;
        CExtNotifyCallbackPacket *pPacket;

        if (!GetQueuedCompletionStatus (
                g_pNotificationMap->m_hCompletionPort,
                &dwNumBytes,
                &CompletionKey,
                (LPOVERLAPPED*) &pPacket,
                INFINITE
            ))
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetQueuedCompletionStatus failed with error = %ld. Aborting thread"),
                dwRes);
            return dwRes;
        }
        if (SERVICE_SHUT_DOWN_KEY == CompletionKey)
        {
            //
            // This is a special signal from the service that all thread should die now. Tell all other notification threads to die
            //
            if (!PostQueuedCompletionStatus( 
                g_pNotificationMap->m_hCompletionPort,
                0,
                SERVICE_SHUT_DOWN_KEY,
                (LPOVERLAPPED) NULL))
            {
                dwRes = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PostQueuedCompletionStatus failed (SERVICE_SHUT_DOWN_KEY). (ec: %ld)"),
                    dwRes);
            }

            if (!DecreaseServiceThreadsCount())
            {
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("DecreaseServiceThreadsCount() failed (ec: %ld)"),
                        GetLastError());
            }
            return ERROR_SUCCESS;
        }
        Assert (pPacket && pPacket->m_lpbData && pPacket->m_dwDataSize && pPacket->m_lpwstrGUID );

        //
        // Do the notification
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Calling notification callback %p. DeviceId: %ld GUID: %s Data: %p DataSize: %ld"),
            pPacket->m_pCallback,
            pPacket->m_dwDeviceId,
            pPacket->m_lpwstrGUID,
            pPacket->m_lpbData,
            pPacket->m_dwDataSize);



        pPacket->m_pCallback(pPacket->m_dwDeviceId, // Notify with internal device id.
                                pPacket->m_lpwstrGUID,
                                pPacket->m_lpbData,
                                pPacket->m_dwDataSize);

        //
        // Kill notification object
        //
        delete pPacket;
    }   // Dequeue loop

    UNREFERENCED_PARAMETER (UnUsed);
}   // CNotificationMap::ExtNotificationThread

DWORD
CNotificationMap::Init ()
/*++

Routine name : CNotificationMap::Init

Routine description:

    Initialize the notification map

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:


Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DWORD dwNumThreads = 0;
    DEBUG_FUNCTION_NAME(TEXT("CNotificationMap::Init"));

    //
    // Try to init our critical section
    //
    if (!m_CsExtensionData.Initialize())
    {
        dwRes = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::Initialize(&m_CsExtensionData) failed: err = %d"),
            dwRes);
        return dwRes;
    }
    //
    // Create the completion port
    //
    m_hCompletionPort = CreateIoCompletionPort (
        INVALID_HANDLE_VALUE,   // No device
        NULL,                   // New one
        0,                      // Key
        MAX_CONCURRENT_EXT_DATA_SET_THREADS);
    if (NULL == m_hCompletionPort)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateIoCompletionPort failed with %ld"),
            dwRes);
        return dwRes;
    }
    //
    // Create completion port dequeueing thread(s)
    //
    for (DWORD dw = 0; dw < NUM_EXT_DATA_SET_THREADS; dw++)
    {
        HANDLE hThread = CreateThreadAndRefCount (
                     NULL,                                      // Security
                     0,                                         // Stack size
                     g_pNotificationMap->ExtNotificationThread,   // Start routine
                     0,                                         // Parameter
                     0,                                         // Creation flag(s)
                     NULL);                                     // Don't want thread id
        if (NULL == hThread)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateThreadAndRefCount failed with %ld"),
                dwRes);
        }
        else
        {
            dwNumThreads++;
            CloseHandle(hThread);
        }
    }
    if (!dwNumThreads)
    {
        //
        // Not even a single thread was created
        //
        CloseHandle (m_hCompletionPort);
        m_hCompletionPort = NULL;
        return dwRes;
    }
    return ERROR_SUCCESS;
}   // CNotificationMap::Init

/************************************
*                                   *
*           CMapDeviceId            *
*                                   *
************************************/

DWORD
CMapDeviceId::AddDevice (
    DWORD dwDeviceId,
    DWORD dwFaxId
)
/*++

Routine name : CMapDeviceId::AddDevice

Routine description:

    Adds a new device to the devices map

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    dwDeviceId      [in] - The source id of the device
    dwFaxId         [in] - The unique fax device id (destination id)

Return Value:

    Standard Win32 error code

--*/
{
    DEVICE_IDS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CMapDeviceId::AddDevice"));

    EnterCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    try
    {
        //
        // See if entry exists in map
        //
        if((it = m_Map.find(dwDeviceId)) != m_Map.end())
        {
            dwRes = ERROR_ALREADY_ASSIGNED;
            goto exit;
        }
        //
        // Add new map entry
        //
        m_Map[dwDeviceId] = dwFaxId;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }

exit:
    LeaveCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    return dwRes;
}   // CMapDeviceId::AddDevice

DWORD
CMapDeviceId::RemoveDevice (
    DWORD dwDeviceId
)
/*++

Routine name : CMapDeviceId::RemoveDevice

Routine description:

    Removes an existing device from the devices map

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    dwDeviceId      [in] - The source id of the device

Return Value:

    Standard Win32 error code

--*/
{
    DEVICE_IDS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CMapDeviceId::RemoveDevice"));

    EnterCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    try
    {
        //
        // See if entry exists in map
        //
        if((it = m_Map.find(dwDeviceId)) == m_Map.end())
        {
            dwRes = ERROR_NOT_FOUND;
            goto exit;
        }
        //
        // Remove map entry
        //
        m_Map.erase (it);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }

exit:
    LeaveCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    return dwRes;
}   // CMapDeviceId::RemoveDevice

DWORD
CMapDeviceId::LookupUniqueId (
    DWORD   dwOtherId,
    LPDWORD lpdwFaxId
) const
/*++

Routine name : CMapDeviceId::LookupUniqueId

Routine description:

    Looks up a unique fax device id from a given device id

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    dwOtherId           [in ] - Given device it (lookup source)
    lpdwFaxId           [out] - Fax unique device id

Return Value:

    Standard Win32 error code

--*/
{
    DEVICE_IDS_MAP::iterator it;
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CMapDeviceId::LookupUniqueId"));

    if (!dwOtherId)
    {
        //
        // Special device id == 0 case
        //
        *lpdwFaxId = 0;
        return dwRes;
    }
    EnterCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    try
    {
        //
        // See if entry exists in map
        //
        if((it = m_Map.find(dwOtherId)) == m_Map.end())
        {
            dwRes = ERROR_NOT_FOUND;
            goto exit;
        }
        *lpdwFaxId = (*it).second;
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("map caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }

exit:
    LeaveCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    return dwRes;
}   // CMapDeviceId::LookupUniqueId


/************************************
*                                   *
*             Globals               *
*                                   *
************************************/

CNotificationMap* g_pNotificationMap;  // Map of DeviceId+GUID to list of notification sinks

/*
    The map maps between TAPI permanent line ids to fax unique ids.
    TAPI-based FSPs / EFPSs talk to us using TAPI-permamnet line ids and have no clue of the
    fax unique device ids. This map is here for quick lookup for TAPI-based FSPs.
*/

CMapDeviceId*     g_pTAPIDevicesIdsMap;      // Map between TAPI permanent line id and fax unique device id.



DWORD
LookupUniqueFaxDeviceId (
    DWORD                     dwDeviceId,
    LPDWORD                   lpdwResult,
    FAX_ENUM_DEVICE_ID_SOURCE DevIdSrc)
/*++

Routine name : LookupUniqueFaxDeviceId

Routine description:

    Looks up a fax unique device id from a general device id.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    dwDeviceId          [in ] - Original device id
    lpdwResult          [out] - Looked up device id
    DevIdSrc            [in ] - Source of device id

Return Value:

    Standard Win32 error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("LookupUniqueFaxDeviceId"));

    switch (DevIdSrc)
    {
        case DEV_ID_SRC_FAX:    // No maping required
            *lpdwResult = dwDeviceId;
            return ERROR_SUCCESS;

        case DEV_ID_SRC_TAPI:
            return g_pTAPIDevicesIdsMap->LookupUniqueId (dwDeviceId, lpdwResult);

        default:
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid device id source (%ld)"),
                DevIdSrc);
            ASSERT_FALSE;
            return ERROR_INVALID_PARAMETER;
    }
}   // LookupUniqueFaxDeviceId





/************************************
*                                   *
*     Get/Set Data                  *
*                                   *
************************************/

static
BOOL
FindTAPIPermanentLineIdFromFaxDeviceId (
    IN  DWORD   dwFaxDeviceId,
    OUT LPDWORD lpdwTapiLineId
)
/*++

Routine name : FindTAPIPermanentLineIdFromFaxDeviceId

Routine description:

    Given a fax device id, returns the TAPI permanent line id associated with this fax device.
    If the fax device is not found or is a virtual fax (no TAPI association), the search fails.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    dwFaxDeviceId     [in]     - Fax device id
    lpdwTapiLineId    [out]    - TAPI permanent line id

Return Value:

    TRUE if the search succeeed. FALSE otherwise.

--*/
{
    BOOL bRes = FALSE;

    DEBUG_FUNCTION_NAME(TEXT("FindTAPIPermanentLineIdFromFaxDeviceId"));

    EnterCriticalSection(&g_CsLine);
    PLINE_INFO pLine = GetTapiLineFromDeviceId (dwFaxDeviceId, FALSE);
    if (!pLine)
    {
        goto exit;
    }
    if (pLine->Flags & FPF_VIRTUAL)
    {
        //
        // This fax device is virtual. It does not have a corresponding TAPI line.
        //
        goto exit;
    }
    *lpdwTapiLineId = pLine->TapiPermanentLineId;
    bRes = TRUE;
exit:
    LeaveCriticalSection(&g_CsLine);
    return bRes;
}   // FindTAPIPermanentLineIdFromFaxDeviceId


DWORD
FAXGetExtensionData (
    IN DWORD                        dwOrigDeviceId,
    IN FAX_ENUM_DEVICE_ID_SOURCE    DevIdSrc,
    IN LPCWSTR                      lpctstrNameGUID,
    IN OUT LPBYTE                  *ppData,
    IN OUT LPDWORD                  lpdwDataSize
)
/*++

Routine name : FAXGetExtensionData

Routine description:

    Gets the extension data for a device (internal)

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    dwOrigDeviceId                [in]     - Original device id (as arrived from extension)
    DevIdSrc                      [in]     - Device id source (Fax / TAPI)
    lpctstrNameGUID               [in]     - Data GUID
    ppData                        [out]    - Pointer to data buffer
    lpdwDataSize                  [out]    - Pointer to retrieved data size

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("FAXGetExtensionData"));

    if (!lpctstrNameGUID || !ppData || !lpdwDataSize)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ((DevIdSrc != DEV_ID_SRC_FAX) && (DevIdSrc != DEV_ID_SRC_TAPI))
    {
        //
        // Invalid device id class
        //
        return ERROR_INVALID_PARAMETER;
    }

    dwRes = IsValidGUID (lpctstrNameGUID);
    if (ERROR_SUCCESS != dwRes)
    {
        if (ERROR_WMI_GUID_NOT_FOUND == dwRes)
        {
            //
            // Return a more conservative error code
            //
            dwRes = ERROR_INVALID_PARAMETER;
        }
        return dwRes;
    }
    if (DEV_ID_SRC_FAX == DevIdSrc)
    {
        //
        // Try to see if this fax device has a matching tapi line id.
        //
        DWORD dwTapiLineId;
        if (FindTAPIPermanentLineIdFromFaxDeviceId (dwOrigDeviceId, &dwTapiLineId))
        {
            //
            // Matching tapi line id found. Use it to read the data.
            //
            DevIdSrc = DEV_ID_SRC_TAPI;
            dwOrigDeviceId = dwTapiLineId;
        }
    }
    EnterCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    dwRes = ReadExtensionData ( dwOrigDeviceId,
                                DevIdSrc,
                                lpctstrNameGUID,
                                ppData,
                                lpdwDataSize
                              );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Reading extension data for device id %ld, GUID %s failed with %ld"),
            dwOrigDeviceId,
            lpctstrNameGUID,
            dwRes);
    }
    LeaveCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    return dwRes;
}   // FAXGetExtensionData

DWORD
FAXSetExtensionData (
    IN HINSTANCE                    hInst,
    IN LPCWSTR                      lpcwstrComputerName,
    IN DWORD                        dwOrigDeviceId,
    IN FAX_ENUM_DEVICE_ID_SOURCE    DevIdSrc,
    IN LPCWSTR                      lpctstrNameGUID,
    IN LPBYTE                       pData,
    IN DWORD                        dwDataSize
)
/*++

Routine name : FAXSetExtensionData

Routine description:

    Writes the extension data for a device (internal)

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    hInst                         [in]     - Caller's instance
    lpcwstrComputerName           [in]     - Calling module computer name
    dwOrigDeviceId                [in]     - Original device id (as arrived from extension)
    DevIdSrc                      [in]     - Device id source (Fax / TAPI)
    lpctstrNameGUID               [in]     - Data GUID
    pData                         [in]     - Pointer to data buffer
    dwDataSize                    [in]     - Data size

Return Value:

    Standard Win32 error code

--*/
{
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("FAXSetExtensionData"));

    if (!lpctstrNameGUID || !pData || !dwDataSize || !lpcwstrComputerName)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ((DevIdSrc != DEV_ID_SRC_FAX) && (DevIdSrc != DEV_ID_SRC_TAPI))
    {
        //
        // Invalid device id class
        //
        return ERROR_INVALID_PARAMETER;
    }

    dwRes = IsValidGUID (lpctstrNameGUID);
    if (ERROR_SUCCESS != dwRes)
    {
        if (ERROR_WMI_GUID_NOT_FOUND == dwRes)
        {
            //
            // Return a more conservative error code
            //
            dwRes = ERROR_INVALID_PARAMETER;
        }
        return dwRes;
    }
    FAX_ENUM_DEVICE_ID_SOURCE RegistryDeviceIdSource = DevIdSrc;
    DWORD                     dwRegistryDeviceId = dwOrigDeviceId;
    if (DEV_ID_SRC_FAX == DevIdSrc)
    {
        //
        // Try to see if this fax device has a matching tapi line id.
        //
        DWORD dwTapiLineId;
        if (FindTAPIPermanentLineIdFromFaxDeviceId (dwOrigDeviceId, &dwTapiLineId))
        {
            //
            // Matching tapi line id found. Use it to read the data.
            //
            RegistryDeviceIdSource = DEV_ID_SRC_TAPI;
            dwRegistryDeviceId = dwTapiLineId;
        }
    }
    EnterCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    dwRes = WriteExtensionData (dwRegistryDeviceId,
                                RegistryDeviceIdSource,
                                lpctstrNameGUID,
                                pData,
                                dwDataSize
                               );
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Writing extension data for device id %ld (registry device id = %ld), GUID %s failed with %ld"),
            dwOrigDeviceId,
            dwRegistryDeviceId,
            lpctstrNameGUID,
            dwRes);
        goto exit;
    }
    //
    // Notification is always done using the fax id (not the TAPI device id).
    // We must lookup the fax id from the TAPI id before we attempt notification registration.
    //
    DWORD dwFaxUniqueID;
    dwRes = LookupUniqueFaxDeviceId (dwOrigDeviceId, &dwFaxUniqueID, DevIdSrc);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LookupUniqueFaxDeviceId failed for device id %ld (ec: %ld). No write notification will be performed."),
            dwOrigDeviceId,
            dwRes);
        //
        // We support writing to non-exiting devices configuration data
        //
    }


    if (ERROR_SUCCESS == dwRes)
    {

        try
        {
            g_pNotificationMap->Notify (
                    dwFaxUniqueID,         // Device for which data has changed
                    lpctstrNameGUID,    // Name of data
                    lpcwstrComputerName,// Computer name from which data has chnaged
                    hInst,            // Module handle from which data has changed
                    pData,              // Pointer to new data
                    dwDataSize);        // Size of new data
        }
        catch (exception &ex)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Notify() caused exception (%S)"),
                ex.what());
        }
    }


exit:
    LeaveCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    return dwRes;
}   // FAXSetExtensionData


/************************************
*                                   *
*         RPC handlers              *
*                                   *
************************************/
extern "C"
error_status_t
FAX_GetExtensionData (
    IN handle_t     hFaxHandle,
    IN DWORD        dwDeviceId,
    IN LPCWSTR      lpctstrNameGUID,
    IN OUT LPBYTE  *ppData,
    IN OUT LPDWORD  lpdwDataSize
)
/*++

Routine name : FAX_GetExtensionData

Routine description:

    Read the extension's private data - Implements FaxGetExtensionData

Author:

    Eran Yariv (EranY),    Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    dwDeviceId          [in ] - Device identifier.
                                0 = Unassociated data
    lpctstrNameGUID     [in ] - GUID of named data
    ppData              [out] - Pointer to data buffer
    lpdwDataSize        [out] - Returned size of data

Return Value:

    Standard RPC error codes

--*/
{
    DWORD dwRes;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetExtensionData"));

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    return FAXGetExtensionData (dwDeviceId,
                                DEV_ID_SRC_FAX, // RPC clients do not know the TAPI line ids
                                lpctstrNameGUID,
                                ppData,
                                lpdwDataSize);
}   // FAX_GetExtensionData

extern "C"
error_status_t
FAX_SetExtensionData (
    IN handle_t     hFaxHandle,
    IN LPCWSTR      lpcwstrComputerName,
    IN DWORD        dwDeviceId,
    IN LPCWSTR      lpctstrNameGUID,
    IN LPBYTE       pData,
    IN DWORD        dwDataSize
)
/*++

Routine name : FAX_SetExtensionData

Routine description:

    Write the extension's private data - Implements FaxSetExtensionData

Author:

    Eran Yariv (EranY),    Nov, 1999

Arguments:

    hFaxHandle          [in] - The handle of the module that sets the data
    lpcwstrComputerName [in] - The computer name of the module that sets the data
    dwDeviceId          [in] - Device identifier.
                               0 = Unassociated data
    lpctstrNameGUID     [in] - GUID of named data
    pData               [in] - Pointer to data
    dwDataSize          [in] - Size of data

Return Value:

    Standard RPC error codes

--*/
{
    DWORD dwRes;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetExtensionData"));

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    return FAXSetExtensionData ((HINSTANCE)hFaxHandle,
                                lpcwstrComputerName,
                                dwDeviceId,
                                DEV_ID_SRC_FAX, // RPC clients do not know the TAPI line ids
                                lpctstrNameGUID,
                                pData,
                                dwDataSize);
}   // FAX_SetExtensionData

/************************************
*                                   *
*  Callback functions (fxsext.h)    *
*                                   *
************************************/

DWORD
FaxExtGetData (
    DWORD                       dwDeviceId,     // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,       // The source of the device id
    LPCWSTR                     lpcwstrNameGUID,// GUID of data
    LPBYTE                     *ppData,         // (Out) Pointer to allocated data
    LPDWORD                     lpdwDataSize    // (Out) Pointer to data size
)
/*++

Routine name : FaxExtGetData

Routine description:

    Callback function (called from the fax extension).
    Gets data for a device + GUID

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    dwDeviceId      [in] - Device id (0 = No device)
    DevIdSrc        [in] - The source of the device id
    lpcwstrNameGUID [in] - GUID of data
    ppData          [in] - Pointer to data buffer
    lpdwDataSize    [in] - Data size retrieved

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxExtGetData"));
    if (g_bServiceIsDown)
    {
        //
        // We don't supply extension data services when the service is going down
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Called while service is shutting - operation canceled"));
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }
    return FAXGetExtensionData (   dwDeviceId,
                                   DevIdSrc,
                                   lpcwstrNameGUID,
                                   ppData,
                                   lpdwDataSize
                                );
}   // FaxExtGetData

DWORD
FaxExtSetData (
    HINSTANCE                   hInst,
    DWORD                       dwDeviceId,
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,
    LPCWSTR                     lpcwstrNameGUID,
    LPBYTE                      pData,
    DWORD                       dwDataSize
)
/*++

Routine name : FaxExtSetData

Routine description:

    Callback function (called from the fax extension).
    Sets data for a device + GUID

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hInst           [in] - Extension DLL instance
    dwDeviceId      [in] - Device id (0 = No device)
    DevIdSrc        [in] - The source of the device id
    lpcwstrNameGUID [in] - GUID of data
    pData           [in] - Pointer to data
    size            [in] - Data size

Return Value:

    Standard Win32 error code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FaxExtSetData"));
    if (g_bServiceIsDown)
    {
        //
        // We don't supply extension data services when the service is going down
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Called while service is shutting - operation canceled"));
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }
    return FAXSetExtensionData (   hInst,
                                   TEXT (""),      // No computer name - a local extension sets the data
                                   dwDeviceId,
                                   DevIdSrc,
                                   lpcwstrNameGUID,
                                   pData,
                                   dwDataSize
                                );
}   // FaxExtSetData

HANDLE
FaxExtRegisterForEvents (
    HINSTANCE                   hInst,
    DWORD                       dwDeviceId,            // Device id (0 = No device)
    FAX_ENUM_DEVICE_ID_SOURCE   DevIdSrc,              // The source of the device id
    LPCWSTR                     lpcwstrNameGUID,       // GUID of data
    PFAX_EXT_CONFIG_CHANGE      lpConfigChangeCallback // Notification callback function
)
/*++

Routine name : FaxExtRegisterForEvents

Routine description:

    Register a local callback for notifications on a data change for a device and GUID

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hInst                   [in] - Instance of calling extension
    dwDeviceId              [in] - Device id
    bTapiDevice             [in] - If TRUE, the function attempts to convert to a
                                   Fax unique device id.
                                   The callback will receive the device id specified in
                                   dwDeviceId regardless of the lookup.
    lpcwstrNameGUID         [in] - Data name
    lpConfigChangeCallback  [in] - Pointer to notification callback function

Return Value:

    Notification HANDLE.
    If NULL, call GetLastError () to retrieve error code.

--*/
{
    HANDLE h = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxExtRegisterForEvents"));

    if (g_bServiceIsDown)
    {
        //
        // We don't supply extension data services when the service is going down
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Called while service is shutting - operation canceled"));
        SetLastError (ERROR_SHUTDOWN_IN_PROGRESS);
        return NULL;
    }

    if (!lpConfigChangeCallback)
    {
        SetLastError (ERROR_INVALID_PARAMETER);
        return NULL;
    }
    DWORD dwRes = IsValidGUID (lpcwstrNameGUID);
    if (ERROR_SUCCESS != dwRes)
    {
        if (ERROR_WMI_GUID_NOT_FOUND == dwRes)
        {
            //
            // Return a more conservative error code
            //
            dwRes = ERROR_INVALID_PARAMETER;
        }
        SetLastError (dwRes);
        return NULL;
    }
    //
    // Notification is always done using the fax id (not the TAPI device id).
    // We must lookup the fax id from the TAPI id before we attempt notification registration.
    //
    DWORD dwFaxUniqueID;
    dwRes = LookupUniqueFaxDeviceId (dwDeviceId, &dwFaxUniqueID, DevIdSrc);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("LookupUniqueFaxDeviceId failed for device id %ld (ec: %ld)"),
            dwDeviceId,
            dwRes);
        SetLastError (dwRes);
        return NULL;
    }
    EnterCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    try
    {
        //
        // STL throws exceptions
        //
        h = (HANDLE) g_pNotificationMap->AddLocalSink (
                    hInst,          // Instance of extension
                    dwFaxUniqueID,  // Listen to fax device unique id
                    dwDeviceId,     // Report the id specified by the caller.
                    lpcwstrNameGUID,
                    lpConfigChangeCallback);
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AddLocalSink() caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
    }
    LeaveCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    return h;
}   // FaxExtRegisterForEvents

DWORD
FaxExtUnregisterForEvents (
    HANDLE      hNotification
)
/*++

Routine name : FaxExtUnregisterForEvents

Routine description:

    Unregsiters a local callback for notifications on a data change for a device and GUID.

    The functions succeeds only if the same callback function was previously registered
    (by calling FaxExtRegisterForEvents) to the same device id and GUID.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hNotification   [in] - Notification handle
                           returned by FaxExtRegisterForExtensionEvents

Return Value:

    Standard Win32 error code.

--*/
{
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("FaxExtUnregisterForEvents"));

    if (g_bServiceIsDown)
    {
        //
        // We don't supply extension data services when the service is going down
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Called while service is shutting - operation canceled"));
        return ERROR_SHUTDOWN_IN_PROGRESS;
    }
    EnterCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    try
    {
        //
        // STL throws exceptions
        //
        dwRes = g_pNotificationMap->RemoveSink ( (CNotificationSink *)(hNotification) );
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RemoveLocalSink() caused exception (%S)"),
            ex.what());
        dwRes = ERROR_GEN_FAILURE;
    }
    LeaveCriticalSection (&g_pNotificationMap->m_CsExtensionData);
    return dwRes;
}   // FaxExtUnregisterForEvents
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\faxdev.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxdev.c

Abstract:

    This module contains all access to the
    FAX device providers.

Author:

    Wesley Witt (wesw) 22-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

#ifdef DBG
#define DebugDumpProviderRegistryInfo(lpcProviderInfo,lptstrPrefix)\
    DebugDumpProviderRegistryInfoFunc(lpcProviderInfo,lptstrPrefix)
BOOL DebugDumpProviderRegistryInfoFunc(const REG_DEVICE_PROVIDER * lpcProviderInfo, LPTSTR lptstrPrefix);
#else
    #define DebugDumpProviderRegistryInfo(lpcProviderInfo,lptstrPrefix)
#endif




typedef struct STATUS_CODE_MAP_tag
{
    DWORD dwDeviceStatus;
    DWORD dwExtendedStatus;
} STATUS_CODE_MAP;

STATUS_CODE_MAP const gc_CodeMap[]=
{
  { FPS_INITIALIZING, FSPI_ES_INITIALIZING },
    { FPS_DIALING, FSPI_ES_DIALING },
    { FPS_SENDING, FSPI_ES_TRANSMITTING },
    { FPS_RECEIVING, FSPI_ES_RECEIVING },
    { FPS_SENDING, FSPI_ES_TRANSMITTING },
    { FPS_HANDLED, FSPI_ES_HANDLED },
    { FPS_UNAVAILABLE, FSPI_ES_LINE_UNAVAILABLE },
    { FPS_BUSY, FSPI_ES_BUSY },
    { FPS_NO_ANSWER, FSPI_ES_NO_ANSWER  },
    { FPS_BAD_ADDRESS, FSPI_ES_BAD_ADDRESS },
    { FPS_NO_DIAL_TONE, FSPI_ES_NO_DIAL_TONE },
    { FPS_DISCONNECTED, FSPI_ES_DISCONNECTED },
    { FPS_FATAL_ERROR, FSPI_ES_FATAL_ERROR },
    { FPS_NOT_FAX_CALL, FSPI_ES_NOT_FAX_CALL },
    { FPS_CALL_DELAYED, FSPI_ES_CALL_DELAYED },
    { FPS_CALL_BLACKLISTED, FSPI_ES_CALL_BLACKLISTED },
    { FPS_ANSWERED, FSPI_ES_ANSWERED },
    { FPS_COMPLETED, -1},
    { FPS_ABORTING, -1}
};



static BOOL GetLegacyProviderEntryPoints(HMODULE hModule, PDEVICE_PROVIDER lpProvider);

LIST_ENTRY g_DeviceProvidersListHead;


void
UnloadDeviceProvider(
    PDEVICE_PROVIDER pDeviceProvider
    )
{
    DEBUG_FUNCTION_NAME(TEXT("UnloadDeviceProvider"));

    Assert (pDeviceProvider);

    if (pDeviceProvider->hModule)
    {
        FreeLibrary( pDeviceProvider->hModule );
    }

    if (pDeviceProvider->HeapHandle &&
        FALSE == pDeviceProvider->fMicrosoftExtension)
    {
        HeapDestroy(pDeviceProvider->HeapHandle);
    }

    MemFree (pDeviceProvider);
    return;
}


void
UnloadDeviceProviders(
    void
    )

/*++

Routine Description:

    Unloads all loaded device providers.

Arguments:

    None.

Return Value:

    TRUE    - The device providers are initialized.
    FALSE   - The device providers could not be initialized.

--*/

{
    PLIST_ENTRY         pNext;
    PDEVICE_PROVIDER    pProvider;

    pNext = g_DeviceProvidersListHead.Flink;
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        pProvider = CONTAINING_RECORD( pNext, DEVICE_PROVIDER, ListEntry );
        pNext = pProvider->ListEntry.Flink;
        RemoveEntryList(&pProvider->ListEntry);
        UnloadDeviceProvider(pProvider);
    }
    return;
}  // UnloadDeviceProviders


BOOL
LoadDeviceProviders(
    PREG_FAX_SERVICE FaxReg
    )

/*++

Routine Description:

    Initializes all registered device providers.
    This function read the system registry to
    determine what device providers are available.
    All registered device providers are given the
    opportunity to initialize.  Any failure causes
    the device provider to be unloaded.


Arguments:

    None.

Return Value:

    TRUE    - The device providers are initialized.
    FALSE   - The device providers could not be initialized.

--*/

{
    DWORD i;
    HMODULE hModule = NULL;
    PDEVICE_PROVIDER DeviceProvider = NULL;
    BOOL bAllLoaded = TRUE;
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("LoadDeviceProviders"));

    for (i = 0; i < FaxReg->DeviceProviderCount; i++)
    {
        WCHAR wszImageFileName[_MAX_FNAME] = {0};
        WCHAR wszImageFileExt[_MAX_EXT] = {0};

        DeviceProvider = NULL; // so we won't attempt to free it on cleanup
        hModule = NULL; // so we won't attempt to free it on cleanup

        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Loading provider #%d."),
            i);

        //
        // Allocate buffer for provider data
        //

        DeviceProvider = (PDEVICE_PROVIDER) MemAlloc( sizeof(DEVICE_PROVIDER) );
        if (!DeviceProvider)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Could not allocate memory for device provider [%s] (ec: %ld)"),
                FaxReg->DeviceProviders[i].ImageName ,
                GetLastError());

                FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    2,
                    MSG_FSP_INIT_FAILED_MEM,
                    FaxReg->DeviceProviders[i].FriendlyName,
                    FaxReg->DeviceProviders[i].ImageName
                  );

            goto InitializationFailure;
        }
        //
        // Init the provider's data
        //
        memset(DeviceProvider,0,sizeof(DEVICE_PROVIDER));
        wcsncpy( DeviceProvider->FriendlyName,
                 FaxReg->DeviceProviders[i].FriendlyName ?
                    FaxReg->DeviceProviders[i].FriendlyName :
                    EMPTY_STRING,
                 ARR_SIZE(DeviceProvider->FriendlyName)-1);
        wcsncpy( DeviceProvider->ImageName,
                 FaxReg->DeviceProviders[i].ImageName ?
                    FaxReg->DeviceProviders[i].ImageName :
                    EMPTY_STRING,
                 ARR_SIZE(DeviceProvider->ImageName)-1);
        wcsncpy( DeviceProvider->ProviderName,
                 FaxReg->DeviceProviders[i].ProviderName ?
                    FaxReg->DeviceProviders[i].ProviderName :
                    EMPTY_STRING,
                 ARR_SIZE(DeviceProvider->ProviderName)-1);
        wcsncpy( DeviceProvider->szGUID,
                 FaxReg->DeviceProviders[i].lptstrGUID ?
                    FaxReg->DeviceProviders[i].lptstrGUID :
                    EMPTY_STRING,
                 ARR_SIZE(DeviceProvider->szGUID)-1);

        _wsplitpath( DeviceProvider->ImageName, NULL, NULL, wszImageFileName, wszImageFileExt );
        if (_wcsicmp( wszImageFileName, FAX_T30_MODULE_NAME ) == 0 &&
            _wcsicmp( wszImageFileExt, TEXT(".DLL") ) == 0)
        {
            DeviceProvider->fMicrosoftExtension = TRUE;
        }

        DeviceProvider->dwAPIVersion = FaxReg->DeviceProviders[i].dwAPIVersion;       

        if (FSPI_API_VERSION_1 != DeviceProvider->dwAPIVersion)
        {
            //
            // We do not support this API version. Could only happen if some one messed up the registry
            //        

            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FSPI API version [0x%08x] unsupported."),
                DeviceProvider->dwAPIVersion);
            FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    3,
                    MSG_FSP_INIT_FAILED_UNSUPPORTED_FSPI,
                    FaxReg->DeviceProviders[i].FriendlyName,
                    FaxReg->DeviceProviders[i].ImageName,
                    DWORD2HEX(DeviceProvider->dwAPIVersion)
                  );
            DeviceProvider->Status = FAX_PROVIDER_STATUS_BAD_VERSION;
            DeviceProvider->dwLastError = ERROR_GEN_FAILURE;
            goto InitializationFailure;
        }        
        //
        // Try to load the module
        //
        DebugDumpProviderRegistryInfo(&FaxReg->DeviceProviders[i],TEXT("\t"));

        hModule = LoadLibrary( DeviceProvider->ImageName );

        if (!hModule)
        {           
            ec = GetLastError();

            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LoadLibrary() failed: [%s] (ec: %ld)"),
                FaxReg->DeviceProviders[i].ImageName,
                ec);

            FaxLog(
                FAXLOG_CATEGORY_INIT,
                FAXLOG_LEVEL_MIN,
                3,
                MSG_FSP_INIT_FAILED_LOAD,
                FaxReg->DeviceProviders[i].FriendlyName,
                FaxReg->DeviceProviders[i].ImageName,
                DWORD2DECIMAL(ec)
                );

            DeviceProvider->Status = FAX_PROVIDER_STATUS_CANT_LOAD;
            DeviceProvider->dwLastError = ec;
            goto InitializationFailure;
        }
        DeviceProvider->hModule = hModule;

        //
        // Retrieve the FSP's version from the DLL
        //
        DeviceProvider->Version.dwSizeOfStruct = sizeof (FAX_VERSION);
        ec = GetFileVersion ( FaxReg->DeviceProviders[i].ImageName,
                              &DeviceProvider->Version
                            );
        if (ERROR_SUCCESS != ec)
        {
            //
            // If the FSP's DLL does not have version data or the
            // version data is non-retrievable, we consider this a
            // warning (debug print) but carry on with the DLL's load.
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFileVersion() failed: [%s] (ec: %ld)"),
                FaxReg->DeviceProviders[i].ImageName,
                ec);
        }        

        //
        // Link - find the entry points and store them
        //
        if (FSPI_API_VERSION_1 == DeviceProvider->dwAPIVersion)
        {
            if (!GetLegacyProviderEntryPoints(hModule,DeviceProvider))
            {               
                ec = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("GetLegacyProviderEntryPoints() failed. (ec: %ld)"),
                    ec);
                FaxLog(
                        FAXLOG_CATEGORY_INIT,
                        FAXLOG_LEVEL_MIN,
                        3,
                        MSG_FSP_INIT_FAILED_INVALID_FSPI,
                        FaxReg->DeviceProviders[i].FriendlyName,
                        FaxReg->DeviceProviders[i].ImageName,
                        DWORD2DECIMAL(ec)
                      );
                DeviceProvider->Status = FAX_PROVIDER_STATUS_CANT_LINK;
                DeviceProvider->dwLastError = ec;
                goto InitializationFailure;
            }
            //
            // create the device provider's heap
            //
            DeviceProvider->HeapHandle = DeviceProvider->fMicrosoftExtension ?
                                            GetProcessHeap() : HeapCreate( 0, 1024*100, 1024*1024*2 );
            if (!DeviceProvider->HeapHandle)
            {
                ec = GetLastError ();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("HeapCreate() failed for device provider heap handle (ec: %ld)"),
                    ec);
                FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    2,
                    MSG_FSP_INIT_FAILED_MEM,
                    FaxReg->DeviceProviders[i].FriendlyName,
                    FaxReg->DeviceProviders[i].ImageName
                  );
                DeviceProvider->Status = FAX_PROVIDER_STATUS_SERVER_ERROR;
                DeviceProvider->dwLastError = ec;
                goto InitializationFailure;
            }
        }        
        else
        {
            //
            // Unknown API version
            //            
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FSPI API version [0x%08x] unsupported."),
                DeviceProvider->dwAPIVersion);
            FaxLog(
                    FAXLOG_CATEGORY_INIT,
                    FAXLOG_LEVEL_MIN,
                    3,
                    MSG_FSP_INIT_FAILED_UNSUPPORTED_FSPI,
                    FaxReg->DeviceProviders[i].FriendlyName,
                    FaxReg->DeviceProviders[i].ImageName,
                    DWORD2HEX(DeviceProvider->dwAPIVersion)
                  );
            DeviceProvider->Status = FAX_PROVIDER_STATUS_BAD_VERSION;
            DeviceProvider->dwLastError = ERROR_GEN_FAILURE;
            goto InitializationFailure;
        }
        //
        // Success on load (we still have to init)
        //
        InsertTailList( &g_DeviceProvidersListHead, &DeviceProvider->ListEntry );
        DeviceProvider->Status = FAX_PROVIDER_STATUS_SUCCESS;
        DeviceProvider->dwLastError = ERROR_SUCCESS;
        goto next;

InitializationFailure:
        //
        // the device provider dll does not have a complete export list
        //
        bAllLoaded = FALSE;
        if (DeviceProvider)
        {
            if (DeviceProvider->hModule)
            {
                FreeLibrary( hModule );
                DeviceProvider->hModule = NULL;
            }

            if (DeviceProvider->HeapHandle &&
                FALSE == DeviceProvider->fMicrosoftExtension)
            {
                if (!HeapDestroy(DeviceProvider->HeapHandle))
                {
                     DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("HeapDestroy() failed (ec: %ld)"),
                        GetLastError());
                }
                DeviceProvider->HeapHandle = NULL;
            }

            //
            // We keep the device provider's record intact because we want
            // to return init failure data on RPC calls to FAX_EnumerateProviders
            //
            Assert (FAX_PROVIDER_STATUS_SUCCESS != DeviceProvider->Status);
            Assert (ERROR_SUCCESS != DeviceProvider->dwLastError);
            InsertTailList( &g_DeviceProvidersListHead, &DeviceProvider->ListEntry );
        }
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Device provider [%s] FAILED to initialized "),
            FaxReg->DeviceProviders[i].FriendlyName );

next:
    ;
    }

    return bAllLoaded;

}

VOID
HandleFSPInitializationFailure(
	PDEVICE_PROVIDER    pDeviceProvider,
	BOOL				fExtensionConfigFail
	)
//*********************************************************************************
//* Name:   HandleFSPInitializationFailure()
//* Author: Oded Sacher
//* Date:   Jul 4, 2002
//*********************************************************************************
//* DESCRIPTION:
//*     Handles a FSP initialization failure.
//*    
//* PARAMETERS:
//*     pDeviceProvider - points to a DEVICE_PROVIDER structure of a loaded FSP.
//*						  The status and the last error must be updated with the failure info.
//*		fExtensionConfigFail - TRUE if FaxExtInitializeConfig failed, FALSE if FaxDevInitialize failed
//*		
//* RETURN VALUE:
//*     None.
//*********************************************************************************
{
	DEBUG_FUNCTION_NAME(TEXT("HandleFSPInitializationFailure"));

	//
	// Issue an event log
	//
	FaxLog(
		FAXLOG_CATEGORY_INIT,
		FAXLOG_LEVEL_MIN,
		4,
		MSG_FSP_INIT_FAILED,
		pDeviceProvider->FriendlyName,
		DWORD2DECIMAL(fExtensionConfigFail),				// 1 = Failed during FaxExtInitializeConfig                                                    
															// 0 = Failed during FaxDevInitialize
		DWORD2DECIMAL(pDeviceProvider->dwLastError),
		pDeviceProvider->ImageName
	);

	//	
	// Unload the DLL
	//
	Assert (pDeviceProvider->hModule);
	if (!FreeLibrary( pDeviceProvider->hModule ))
	{
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Failed to free library [%s] (ec: %ld)"),
			pDeviceProvider->ImageName,
			GetLastError());
		Assert(FALSE);
	}	
	pDeviceProvider->hModule = NULL;
	
	//
	// We weed to get rid of the lines we already created.
	//
	PLIST_ENTRY pNext = NULL;
	PLINE_INFO LineInfo;

	pNext = g_TapiLinesListHead.Flink;
	while ((ULONG_PTR)pNext != (ULONG_PTR)&g_TapiLinesListHead)
	{
		LineInfo = CONTAINING_RECORD( pNext, LINE_INFO, ListEntry );
		pNext = LineInfo->ListEntry.Flink;
		if (!_tcscmp(LineInfo->Provider->ProviderName, pDeviceProvider->ProviderName))
		{
			DebugPrintEx(
				DEBUG_WRN,
				TEXT("Removing Line: [%s] due to provider initialization failure."),
				LineInfo->DeviceName);
			RemoveEntryList(&LineInfo->ListEntry);
			if (TRUE == IsDeviceEnabled(LineInfo))
			{
				Assert (g_dwDeviceEnabledCount);
				g_dwDeviceEnabledCount -=1;
			}
			g_dwDeviceCount -=1;
			FreeTapiLine(LineInfo);
		}
	}                       

	//
	// We keep the device provider's record intact because we want
	// to return init failure data on RPC calls to FAX_EnumerateProviders
	//
	return;
} // HandleFSPInitializationFailure



//*********************************************************************************
//* Name:   InitializeDeviceProvidersConfiguration()
//* Author: Oded Sacher
//* Date:   Jul 4, 2002
//*********************************************************************************
//* DESCRIPTION:
//*     Initializes the extension configuration for all loaded providers by calling FaxExtInitializeConfig()
//*     If the initialization fails the FSP is unloaded.
//*
//* PARAMETERS:
//*     None.
//*
//* RETURN VALUE:
//*     TRUE if the initialization succeeded for ALL providers. FALSE otherwise.
//*********************************************************************************
BOOL
InitializeDeviceProvidersConfiguration(
    VOID
    )
{
    PLIST_ENTRY         Next;
    PDEVICE_PROVIDER    pDeviceProvider;
    BOOL bAllSucceeded = TRUE;    
    HRESULT hr;

    DEBUG_FUNCTION_NAME(TEXT("InitializeDeviceProvidersConfiguration"));
    Next = g_DeviceProvidersListHead.Flink;
    Assert (Next);
    
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
		pDeviceProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        Next = pDeviceProvider->ListEntry.Flink;
        if (pDeviceProvider->Status != FAX_PROVIDER_STATUS_SUCCESS)
        {
            //
            // This FSP wasn't loaded successfully - skip it
            //
            continue;
        }
        //
        // Assert the loading succeeded
        //
        Assert (ERROR_SUCCESS == pDeviceProvider->dwLastError);

        //
        // Start with ext. configuration initialization call
        //
        if (!pDeviceProvider->pFaxExtInitializeConfig)
        {
			//
            // This FSP does not export FaxExtInitializeConfig - skip it
            //
            continue;
		}

        //
        // If the FSP exports FaxExtInitializeConfig(), call it 1st before any other call.
        //
        __try
        {

            hr = pDeviceProvider->pFaxExtInitializeConfig(
                FaxExtGetData,
                FaxExtSetData,
                FaxExtRegisterForEvents,
                FaxExtUnregisterForEvents,
                FaxExtFreeBuffer);
        }
        __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, pDeviceProvider->FriendlyName, GetExceptionCode()))
        {
            ASSERT_FALSE;
        }
        if (FAILED(hr))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxExtInitializeConfig() failed (hr = 0x%08x) for provider [%s]"),
                hr,
                pDeviceProvider->FriendlyName );
           pDeviceProvider->Status = FAX_PROVIDER_STATUS_CANT_INIT;
           pDeviceProvider->dwLastError = hr;         
		   bAllSucceeded = FALSE;   

		   //
		   // handle the initialization failure
		   //
		   HandleFSPInitializationFailure(pDeviceProvider, TRUE);
        }
    }
    return bAllSucceeded;
} // InitializeDeviceProvidersConfiguration



//*********************************************************************************
//* Name:   InitializeDeviceProviders()
//* Author: Ronen Barenboim
//* Date:   May 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Initializes all loaded providers by calling FaxDevInitialize()
//*     If the initialization fails the FSP is unloaded.
//*     For legacy virtual FSP the function also removes all the vitrual devices
//*     that belong to the FSP that failed to initialize.
//*
//* PARAMETERS:
//*     None.
//*
//* RETURN VALUE:
//*     TRUE if the initialization succeeded for ALL providers. FALSE otherwise.
//*********************************************************************************
BOOL
InitializeDeviceProviders(
    VOID
    )
{
    PLIST_ENTRY         Next;
    PDEVICE_PROVIDER    pDeviceProvider;
    BOOL bAllSucceeded = TRUE;
    DWORD ec = ERROR_SUCCESS;      
    DEBUG_FUNCTION_NAME(TEXT("InitializeDeviceProviders"));

	Next = g_DeviceProvidersListHead.Flink;
    Assert (Next);

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        BOOL bRes = FALSE;

        pDeviceProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        Next = pDeviceProvider->ListEntry.Flink;
        if (pDeviceProvider->Status != FAX_PROVIDER_STATUS_SUCCESS)
        {
            //
            // This FSP wasn't loaded successfully or failed to initilaize extension configuration - skip it
            //
            continue;
        }        
        //
        // the device provider exports ALL the requisite functions
        // now try to initialize it            
        // Assert the loading succeeded
        //
        Assert (ERROR_SUCCESS == pDeviceProvider->dwLastError);
      
        __try
        {			
            bRes = pDeviceProvider->FaxDevInitialize(
                    g_hLineApp,
                    pDeviceProvider->HeapHandle,
                    &pDeviceProvider->FaxDevCallback,
                    FaxDeviceProviderCallback);

        }
        __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, pDeviceProvider->FriendlyName, GetExceptionCode()))
        {
            ASSERT_FALSE;
        }
		if (TRUE == bRes)
		{
            //
            // all is ok
            //
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Device provider [%s] initialized "),
                pDeviceProvider->FriendlyName );
			//
			// mark the fact that FaxDevInitialize was called, so the service will call
			// FaxDevShutDown when it is going down
			//
			pDeviceProvider->bInitializationSucceeded = TRUE;
        }
        else
        {
            ec = GetLastError();
            //
            // initialization failed
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FaxDevInitialize FAILED for provider [%s] (ec: %ld)"),
                pDeviceProvider->FriendlyName,
                ec);
            pDeviceProvider->Status = FAX_PROVIDER_STATUS_CANT_INIT;
            pDeviceProvider->dwLastError = ec;
			bAllSucceeded = FALSE;
			//
			// handle the initialization failure
			//
			HandleFSPInitializationFailure(pDeviceProvider, FALSE);
		}			
    }
    return bAllSucceeded;
} // InitializeDeviceProviders



PDEVICE_PROVIDER
FindDeviceProvider(
    LPTSTR lptstrProviderName,
    BOOL   bSuccessfullyLoaded /* = TRUE */
    )

/*++

Routine Description:

    Locates a device provider in the linked list
    of device providers based on the provider name (TSP name).
    The device provider name is case insensitive.

Arguments:

    lptstrProviderName  - Specifies the device provider name to locate.
    bSuccessfullyLoaded - To we only look for successfuly loaded providers?

Return Value:

    Pointer to a DEVICE_PROVIDER structure, or NULL for failure.

--*/

{
    PLIST_ENTRY         pNext;
    PDEVICE_PROVIDER    pProvider;

    if (!lptstrProviderName || !lstrlen (lptstrProviderName))
    {
        //
        // NULL TSP name or empty string TSP name never matches any list entry.
        //
        return NULL;
    }

    pNext = g_DeviceProvidersListHead.Flink;
    if (!pNext)
    {
        return NULL;
    }

    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        pProvider = CONTAINING_RECORD( pNext, DEVICE_PROVIDER, ListEntry );
        pNext = pProvider->ListEntry.Flink;

        if (bSuccessfullyLoaded &&
            (FAX_PROVIDER_STATUS_SUCCESS != pProvider->Status))
        {
            //
            // We're only looking for successfully loaded providers and this one isn't
            //
            continue;
        }
        if (!lstrcmpi( pProvider->ProviderName, lptstrProviderName ))
        {
            //
            // Match found
            //
            return pProvider;
        }
    }
    return NULL;
}


BOOL CALLBACK
FaxDeviceProviderCallback(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    )
{
    return TRUE;
}


#ifdef DBG


//*********************************************************************************
//* Name:   DebugDumpProviderRegistryInfo()
//* Author: Ronen Barenboim
//* Date:   May 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*         Dumps the information for a legacy or new FSP.
//* PARAMETERS:
//*     [IN]    const REG_DEVICE_PROVIDER * lpcProviderInfo
//*
//*     [IN]    LPTSTR lptstrPrefix
//*
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL DebugDumpProviderRegistryInfoFunc(const REG_DEVICE_PROVIDER * lpcProviderInfo, LPTSTR lptstrPrefix)
{
    Assert(lpcProviderInfo);
    Assert(lptstrPrefix);

    DEBUG_FUNCTION_NAME(TEXT("DebugDumpProviderRegistryInfo"));

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("%sProvider GUID: %s"),
        lptstrPrefix,
        lpcProviderInfo->lptstrGUID);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("%sProvider Name: %s"),
        lptstrPrefix,
        lpcProviderInfo->FriendlyName);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("%sProvider image: %s"),
        lptstrPrefix,
        lpcProviderInfo->ImageName);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("%sFSPI Version: 0x%08X"),
        lptstrPrefix,
        lpcProviderInfo->dwAPIVersion);

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("%sTAPI Provider : %s"),
        lptstrPrefix,
        lpcProviderInfo->ProviderName);    

    return TRUE;
}
#endif


//*********************************************************************************
//* Name: GetLegacyProviderEntryPoints()
//* Author: Ronen Barenboim
//* Date:   May 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Sets the legacy function entry points in the DEVICE_PROVIDER structure.
//* PARAMETERS:
//*     [IN]        HMODULE hModule
//*         The instance handle for the DLL from which the entry points are to be
//*         set.
//*     [OUT]       PDEVICE_PROVIDER lpProvider
//*         A pointer to a Legacy DEVICE_PROVIDER structure whose function entry points
//*         are to be set.
//*
//* RETURN VALUE:
//*     TRUE
//*
//*     FALSE
//*
//*********************************************************************************
BOOL GetLegacyProviderEntryPoints(HMODULE hModule, PDEVICE_PROVIDER lpProvider)
{
    DEBUG_FUNCTION_NAME(TEXT("GetLegacyProviderEntryPoints"));

    Assert(hModule);
    Assert(lpProvider);

    lpProvider->FaxDevInitialize = (PFAXDEVINITIALIZE) GetProcAddress(
        hModule,
        "FaxDevInitialize"
        );
    if (!lpProvider->FaxDevInitialize) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetProcAddress(FaxDevInitialize) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpProvider->FaxDevStartJob = (PFAXDEVSTARTJOB) GetProcAddress(
        hModule,
        "FaxDevStartJob"
        );
    if (!lpProvider->FaxDevStartJob) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetProcAddress(FaxDevStartJob) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpProvider->FaxDevEndJob = (PFAXDEVENDJOB) GetProcAddress(
        hModule,
        "FaxDevEndJob"
        );
    if (!lpProvider->FaxDevEndJob) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetProcAddress(FaxDevEndJob) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }
    lpProvider->FaxDevSend = (PFAXDEVSEND) GetProcAddress(
        hModule,
        "FaxDevSend"
        );
    if (!lpProvider->FaxDevSend) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetProcAddress(FaxDevSend) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }

    lpProvider->FaxDevReceive = (PFAXDEVRECEIVE) GetProcAddress(
        hModule,
        "FaxDevReceive"
        );
    if (!lpProvider->FaxDevReceive) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetProcAddress(FaxDevReceive) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }
    lpProvider->FaxDevReportStatus = (PFAXDEVREPORTSTATUS) GetProcAddress(
        hModule,
        "FaxDevReportStatus"
        );
    if (!lpProvider->FaxDevReportStatus) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetProcAddress(FaxDevReportStatus) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }


    lpProvider->FaxDevAbortOperation = (PFAXDEVABORTOPERATION) GetProcAddress(
        hModule,
        "FaxDevAbortOperation"
        );

    if (!lpProvider->FaxDevAbortOperation) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetProcAddress(FaxDevAbortOperation) failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }
    lpProvider->FaxDevVirtualDeviceCreation = (PFAXDEVVIRTUALDEVICECREATION) GetProcAddress(
        hModule,
        "FaxDevVirtualDeviceCreation"
        );
    //
    // lpProvider->FaxDevVirtualDeviceCreation is optional so we don't fail if it does
    // not exist.

    if (!lpProvider->FaxDevVirtualDeviceCreation) {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("FaxDevVirtualDeviceCreation() not found. This is not a virtual FSP."));
    }

    lpProvider->pFaxExtInitializeConfig = (PFAX_EXT_INITIALIZE_CONFIG) GetProcAddress(
        hModule,
        "FaxExtInitializeConfig"
        );
    //
    // lpProvider->pFaxExtInitializeConfig is optional so we don't fail if it does
    // not exist.
    //
    if (!lpProvider->pFaxExtInitializeConfig)
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("FaxExtInitializeConfig() not found. This is not an error."));
    }

    lpProvider->FaxDevShutdown = (PFAXDEVSHUTDOWN) GetProcAddress(
        hModule,
        "FaxDevShutdown"
        );
    if (!lpProvider->FaxDevShutdown) {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("FaxDevShutdown() not found. This is not an error."));
    }
    goto Exit;
Error:
    return FALSE;
Exit:
    return TRUE;
}


//*********************************************************************************
//* Name:   GetSuccessfullyLoadedProvidersCount()
//* Author: Ronen Barenboim
//* Date:   May 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Returns the number of loaded providers in the DeviceProviders list.
//* PARAMETERS:
//*     NONE
//* RETURN VALUE:
//*     a DWORD containing the number of elements (providers) in the
//*     DeviceProviders list.
//*********************************************************************************
DWORD GetSuccessfullyLoadedProvidersCount()
{
    PLIST_ENTRY         Next;
    DWORD dwCount;

    Next = g_DeviceProvidersListHead.Flink;

    Assert (Next);
    dwCount = 0;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        PDEVICE_PROVIDER    DeviceProvider;

        DeviceProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        if (FAX_PROVIDER_STATUS_SUCCESS == DeviceProvider->Status)
        {
            //
            // Count only successfuly loaded FSPs
            //
            dwCount++;
        }
        Next = Next->Flink;
        Assert(Next);
    }
    return dwCount;
}



//*********************************************************************************
//* Name:   ShutdownDeviceProviders()
//* Author: Ronen Barenboim
//* Date:   May 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Calls FaxDevShutdown() for each FSP
//* PARAMETERS:
//*     NONE
//* RETURN VALUE:
//*     ERROR_SUCCESS
//*         FaxDevShutdown() succeeded for all FSPs
//*     ERROR_FUNCTION_FAILED
//*         FaxDevShutdown() failed for at least one FSP.
//*********************************************************************************
DWORD ShutdownDeviceProviders(LPVOID lpvUnused)
{
    PLIST_ENTRY         Next;
    PDEVICE_PROVIDER DeviceProvider = NULL;
    DWORD dwAllSucceeded = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("ShutdownDeviceProviders"));

    Next = g_DeviceProvidersListHead.Flink;

    if (!Next)
    {
        DebugPrintEx(   DEBUG_WRN,
                        _T("There are no Providers at shutdown! this is valid only if startup failed"));
        return dwAllSucceeded;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        DeviceProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        Next = Next->Flink;
        if (!DeviceProvider->bInitializationSucceeded)
        {
            //
            // This FSP wasn't initialized successfully - skip it
            //
            continue;
        }
        if (DeviceProvider->FaxDevShutdown && !DeviceProvider->bShutDownAttempted)
        {
            Assert(DeviceProvider->FaxDevShutdown);
            DebugPrintEx(
                DEBUG_MSG,
                TEXT("Calling FaxDevShutdown() for FSP [%s] [GUID: %s]"),
                DeviceProvider->FriendlyName,
                DeviceProvider->szGUID);
            __try
            {
                HRESULT hr;
                DeviceProvider->bShutDownAttempted = TRUE;
                hr = DeviceProvider->FaxDevShutdown();
                if (FAILED(hr))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("FaxDevShutdown() failed (hr: 0x%08X) for FSP [%s] [GUID: %s]"),
                        hr,
                        DeviceProvider->FriendlyName,
                        DeviceProvider->szGUID);
                        dwAllSucceeded = ERROR_FUNCTION_FAILED;
                }

            }
            __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, DeviceProvider->FriendlyName, GetExceptionCode()))
            {
                ASSERT_FALSE;
            }
        }
    }
    return dwAllSucceeded;
}



//*********************************************************************************
//* Name:   FreeFSPIJobStatus()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Frees the content of a FSPI_JOB_STATUS structure. Can be instructre to
//*     free the structure itself too.
//*
//* PARAMETERS:
//*     [IN ]   LPFSPI_JOB_STATUS lpJobStatus
//*         A pointer to the structure to free.
//*
//*     [IN ]    BOOL bDestroy
//*         TRUE if the memory occupied by the structure itself should be freed.
//*         FALSE if only the memeory occupied by the structure fields should
//*         be freed.
//*
//* RETURN VALUE:
//*     TRUE if the operation succeeded.
//*     FALSE if it failed. Call GetLastError() for extended error information.
//*********************************************************************************

BOOL FreeFSPIJobStatus(LPFSPI_JOB_STATUS lpJobStatus, BOOL bDestroy)
{

    if (!lpJobStatus)
    {
        return TRUE;
    }
    Assert(lpJobStatus);

    MemFree(lpJobStatus->lpwstrRemoteStationId);
    lpJobStatus->lpwstrRemoteStationId = NULL;
    MemFree(lpJobStatus->lpwstrCallerId);
    lpJobStatus->lpwstrCallerId = NULL;
    MemFree(lpJobStatus->lpwstrRoutingInfo);
    lpJobStatus->lpwstrRoutingInfo = NULL;
    if (bDestroy)
    {
        MemFree(lpJobStatus);
    }
    return TRUE;

}


//*********************************************************************************
//* Name:   DuplicateFSPIJobStatus()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Allocates a new FSPI_JOB_STATUS structure and initializes with
//*     a copy of the specified FSPI_JOB_STATUS structure fields.
//*
//* PARAMETERS:
//*     [IN ]   LPCFSPI_JOB_STATUS lpcSrc
//*         The structure to duplicated.
//*
//* RETURN VALUE:
//*     On success teh function returns a  pointer to the newly allocated
//*     structure. On failure it returns NULL.
//*********************************************************************************
LPFSPI_JOB_STATUS DuplicateFSPIJobStatus(LPCFSPI_JOB_STATUS lpcSrc)
{
    LPFSPI_JOB_STATUS lpDst;
    DWORD ec = 0;
    DEBUG_FUNCTION_NAME(TEXT("DuplicateFSPIJobStatus"));

    Assert(lpcSrc);

    lpDst = (LPFSPI_JOB_STATUS)MemAlloc(sizeof(FSPI_JOB_STATUS));
    if (!lpDst)
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to allocate FSPI_JOB_STATUS (ec: %ld)"),
            GetLastError());
        goto Error;
    }
    memset(lpDst, 0, sizeof(FSPI_JOB_STATUS));
    if (!CopyFSPIJobStatus(lpDst,lpcSrc, sizeof(FSPI_JOB_STATUS)))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CopyFSPIJobStatus() failed (ec: %ld)"),
            GetLastError());
        goto Error;
    }
    Assert(0 == ec);
    goto Exit;

Error:
    Assert (0 != ec);
    FreeFSPIJobStatus(lpDst, TRUE);
    lpDst = NULL;
Exit:
    if (ec)
    {
        SetLastError(ec);
    }

    return lpDst;

}



//*********************************************************************************
//* Name:   CopyFSPIJobStatus()
//* Author: Ronen Barenboim
//* Date:   June 03, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Copies a FSPI_JOB_STATUS content into the a destination (pre allocated)
//*     FSPI_JOB_STATUS structure.
//*
//* PARAMETERS:
//*     [IN ]   LPFSPI_JOB_STATUS lpDst
//*         The destinatione structure for the copy operation. This structure must
//*         be allocated before this function is called.
//*
//*     [IN ]    LPCFSPI_JOB_STATUS lpcSrc
//*         The source structure for the copy operation.
//*
//*     [IN ]    DWORD dwDstSize
//*         The size, in bytes, of the buffer pointed by lpDst
//*
//* RETURN VALUE:
//*     TRUE
//*         If the operation succeeded.
//*     FALSE
//*         If the operation failed. Call GetLastError() for extended information.
//*         In case of a failure the destination structure is all set to 0.
//*********************************************************************************
BOOL CopyFSPIJobStatus(LPFSPI_JOB_STATUS lpDst, LPCFSPI_JOB_STATUS lpcSrc, DWORD dwDstSize)
{
        STRING_PAIR pairs[]=
        {
            {lpcSrc->lpwstrCallerId, &lpDst->lpwstrCallerId},
            {lpcSrc->lpwstrRoutingInfo, &lpDst->lpwstrRoutingInfo},
            {lpcSrc->lpwstrRemoteStationId, &lpDst->lpwstrRemoteStationId}
        };
        int nRes;

        DEBUG_FUNCTION_NAME(TEXT("CopyFSPIJobStatus"));
        
        Assert (sizeof(FSPI_JOB_STATUS) == dwDstSize);
        if (dwDstSize < sizeof(FSPI_JOB_STATUS))
        {
            SetLastError (ERROR_INVALID_PARAMETER);
            return FALSE;
        }
        memcpy(lpDst, lpcSrc, sizeof(FSPI_JOB_STATUS));

        nRes=MultiStringDup(pairs, sizeof(pairs)/sizeof(STRING_PAIR));
        if (nRes!=0) 
        {
            DWORD ec=GetLastError();
            // MultiStringDup takes care of freeing the memory for the pairs for which the copy succeeded
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("MultiStringDup failed to copy string with index %d. (ec: %ld)"),
                nRes-1,
                ec);
            memset(lpDst, 0 , sizeof(FSPI_JOB_STATUS));
            return FALSE;
        }
    return TRUE;
}


DWORD
MapFSPIJobExtendedStatusToJS_EX (DWORD dwFSPIExtendedStatus)
//*********************************************************************************
//* Name: MapFSPIJobExtendedStatusToJS_EX()
//* Author: Oded sacher
//* Date:   Jan 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Maps FSPI extended job status codes to a Fax Client API extended
//*     status (one of the JS_EX_* codes).
//* PARAMETERS:
//*     [IN ]       DWORD dwFSPIExtendedStatus
//*         The FSPI extended Status code.
//*
//* RETURN VALUE:
//*     The corresponding JS_EX_* status code.
//*
//*********************************************************************************
{
    DWORD dwExtendedStatus = 0;

    DEBUG_FUNCTION_NAME(TEXT("MapFSPIJobExtendedStatusToJS_EX"));

    if (FSPI_ES_PROPRIETARY <= dwFSPIExtendedStatus || 
		0 == dwFSPIExtendedStatus)
    {
        return dwFSPIExtendedStatus;
    }

    switch (dwFSPIExtendedStatus)
    {
        case FSPI_ES_DISCONNECTED:
            dwExtendedStatus = JS_EX_DISCONNECTED;
            break;

        case FSPI_ES_INITIALIZING:
            dwExtendedStatus = JS_EX_INITIALIZING;
            break;

        case FSPI_ES_DIALING:
            dwExtendedStatus = JS_EX_DIALING;
            break;

        case FSPI_ES_TRANSMITTING:
            dwExtendedStatus = JS_EX_TRANSMITTING;
            break;

        case FSPI_ES_ANSWERED:
            dwExtendedStatus = JS_EX_ANSWERED;
            break;

        case FSPI_ES_RECEIVING:
            dwExtendedStatus = JS_EX_RECEIVING;
            break;

        case FSPI_ES_LINE_UNAVAILABLE:
            dwExtendedStatus = JS_EX_LINE_UNAVAILABLE;
            break;

        case FSPI_ES_BUSY:
            dwExtendedStatus = JS_EX_BUSY;
            break;

        case FSPI_ES_NO_ANSWER:
            dwExtendedStatus = JS_EX_NO_ANSWER;
            break;

        case FSPI_ES_BAD_ADDRESS:
            dwExtendedStatus = JS_EX_BAD_ADDRESS;
            break;

        case FSPI_ES_NO_DIAL_TONE:
            dwExtendedStatus = JS_EX_NO_DIAL_TONE;
            break;

        case FSPI_ES_FATAL_ERROR:
            dwExtendedStatus = JS_EX_FATAL_ERROR;
            break;

        case FSPI_ES_CALL_DELAYED:
            dwExtendedStatus = JS_EX_CALL_DELAYED;
            break;

        case FSPI_ES_CALL_BLACKLISTED:
            dwExtendedStatus = JS_EX_CALL_BLACKLISTED;
            break;

        case FSPI_ES_NOT_FAX_CALL:
            dwExtendedStatus = JS_EX_NOT_FAX_CALL;
            break;

        case FSPI_ES_PARTIALLY_RECEIVED:
            dwExtendedStatus = JS_EX_PARTIALLY_RECEIVED;
            break;

        case FSPI_ES_HANDLED:
            dwExtendedStatus = JS_EX_HANDLED;
            break;

        case FSPI_ES_CALL_ABORTED:
            dwExtendedStatus = JS_EX_CALL_ABORTED;
            break;

        case FSPI_ES_CALL_COMPLETED:
            dwExtendedStatus = JS_EX_CALL_COMPLETED;
            break;

        default:
            DebugPrintEx(
                DEBUG_WRN,
                TEXT("Invalid extended job status 0x%08X"),
                dwFSPIExtendedStatus);
    }

    return dwExtendedStatus;
}


PDEVICE_PROVIDER
FindFSPByGUID (
    LPCWSTR lpcwstrGUID
)
/*++

Routine name : FindFSPByGUID

Routine description:

    Finds an FSP by its GUID string

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpcwstrGUID         [in ] - GUID string to search with

Return Value:

    Pointer to FSP or NULL if FSP not found.

--*/
{
    PLIST_ENTRY pNext;
    DEBUG_FUNCTION_NAME(TEXT("FindFSPByGUID"));

    pNext = g_DeviceProvidersListHead.Flink;
    Assert (pNext);
    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        PDEVICE_PROVIDER    pDeviceProvider;

        pDeviceProvider = CONTAINING_RECORD( pNext, DEVICE_PROVIDER, ListEntry );
        if (!lstrcmpi (lpcwstrGUID, pDeviceProvider->szGUID))
        {
            //
            // Found match
            //
            return pDeviceProvider;
        }
        pNext = pNext->Flink;
        Assert(pNext);
    }
    //
    // No match
    //
    return NULL;
}   // FindFSPByGUID
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\extensiondata.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    ExtensionData.h

Abstract:

    This file provides declarations of the named 
    extension data functions (get / set / notify)

Author:

    Eran Yariv (EranY)  Dec, 1999

Revision History:

--*/

#ifndef _EXTENSION_DATA_H_
#define _EXTENSION_DATA_H_

#include <map>
#include <list>
#include <string>
using namespace std;

class CExtNotifyCallbackPacket
{
public:
    CExtNotifyCallbackPacket();
    ~CExtNotifyCallbackPacket();
    
    BOOL Init( 
       PFAX_EXT_CONFIG_CHANGE pCallback, 
       DWORD dwDeviceId, 
       LPCWSTR lpcwstrDataGuid, 
       LPBYTE lpbData, 
       DWORD dwDataSize);

    
public:
    DWORD   m_dwDeviceId;
    LPWSTR m_lpwstrGUID;
    LPBYTE  m_lpbData;
    DWORD   m_dwDataSize;
    PFAX_EXT_CONFIG_CHANGE m_pCallback ;


};


/************************************
*                                   *
*         CMapDeviceId              *
*                                   *
************************************/

class CMapDeviceId
{
    public:
    
    CMapDeviceId () {}
    ~CMapDeviceId () {}

    DWORD AddDevice (DWORD dwTAPIid, DWORD dwFaxId);
    DWORD RemoveDevice (DWORD dwTAPIid);

    DWORD LookupUniqueId (DWORD dwOtherId, LPDWORD lpdwFaxId) const;

private:

    typedef map<DWORD, DWORD>  DEVICE_IDS_MAP, *PDEVICE_IDS_MAP;

    DEVICE_IDS_MAP m_Map;
};  // CMapDeviceId

/************************************
*                                   *
*         CDeviceAndGUID            *
*                                   *
************************************/
//
// CDeviceAndGUID class
//
// This class represents the key in the notification map
//
class CDeviceAndGUID
{
public:
    CDeviceAndGUID (DWORD dwDeviceId, LPCWSTR lpcwstrGUID) :
        m_dwDeviceId (dwDeviceId),
        m_strGUID (lpcwstrGUID)
    {}

    virtual ~CDeviceAndGUID ()  {}

    bool operator < ( const CDeviceAndGUID &other ) const;

private:

    wstring m_strGUID;
    DWORD   m_dwDeviceId;
};  // CDeviceAndGUID

/************************************
*                                   *
*         CNotificationSink         *
*                                   *
************************************/

//
// CNotificationSink class
//
// This generic abstract class represents a notification sink.
// The value in the map is a list of pointer to instances derived from this class.
//
class CNotificationSink
{
public:
    CNotificationSink () : m_type (SINK_TYPE_UNKNOWN) {}

    virtual ~CNotificationSink() {}
    
    virtual HRESULT Notify (DWORD   dwDeviceId,
                            LPCWSTR lpcwstrNameGUID,
                            LPCWSTR lpcwstrComputerName,
                            HANDLE  hModule,
                            LPBYTE  lpData, 
                            DWORD   dwDataSize,
                            LPBOOL  lpbRemove) = 0;

    virtual bool operator == (const CNotificationSink &rhs) const = 0;

    virtual bool operator != (const CNotificationSink &rhs) const 
    {
        return !(*this == rhs);
    }

    virtual HRESULT Disconnect () = 0;

    typedef enum {
        SINK_TYPE_UNKNOWN,  // Unspecified sink type
        SINK_TYPE_LOCAL,    // Local sink (callback)
        SINK_TYPE_REMOTE    // Remote sink (RPC)
    } SinkType;

    SinkType Type() const { return m_type; }

protected:

    SinkType m_type;

};  // CNotificationSink

/************************************
*                                   *
*      CLocalNotificationSink       *
*                                   *
************************************/

//
// CLocalNotificationSink class
//
// This is a concrete class derived from CNotificationSink.
// It implementes a notification local sink in a Fax extension (via a callback).
//
class CLocalNotificationSink : public CNotificationSink
{
public:
    CLocalNotificationSink (
        PFAX_EXT_CONFIG_CHANGE lpConfigChangeCallback,
        DWORD                  dwNotifyDeviceId,
        HINSTANCE              hInst);

    virtual ~CLocalNotificationSink() {}

    virtual bool operator == (const CNotificationSink &rhs) const;

    virtual HRESULT Disconnect ()   { return NOERROR; }

    virtual HRESULT Notify (DWORD   dwDeviceId,
                            LPCWSTR lpcwstrNameGUID,
                            LPCWSTR lpcwstrComputerName,
                            HANDLE  hModule,
                            LPBYTE  lpData, 
                            DWORD   dwDataSize,
                            LPBOOL  lpbRemove); 
private:

    PFAX_EXT_CONFIG_CHANGE  m_lpConfigChangeCallback;
    DWORD                   m_dwNotifyDeviceId;
    HINSTANCE               m_hInst;    // Instance of extension that asks for this sink

};  // CLocalNotificationSink

/************************************
*                                   *
*            CSinksList             *
*                                   *
************************************/
typedef list<CNotificationSink *> SINKS_LIST, *PSINKS_LIST;

class CSinksList
{
public:
    
    CSinksList () : m_bNotifying (FALSE) {}
    ~CSinksList ();
    
    BOOL        m_bNotifying;       // Are we now already notifying to this device id + GUID?
    SINKS_LIST  m_List;             // List of notification sinks
};  // CSinksList


#define NUM_EXT_DATA_SET_THREADS                        1   /* The number of extension
                                                               notification completion port 
                                                               dequeueing threads created
                                                            */
#define MAX_CONCURRENT_EXT_DATA_SET_THREADS             1   /* The maximal number of extension 
                                                               notification completion 
                                                               port dequeueing threads allowed
                                                               (by the system) to run concurrently.
                                                            */

/************************************
*                                   *
*         CNotificationMap          *
*                                   *
************************************/

typedef map<CDeviceAndGUID, CSinksList*>  NOTIFY_MAP, *PNOTIFY_MAP;

//
// The CNotificationMap class is the global notification mechanism
//
class CNotificationMap
{
public:
    CNotificationMap () : 
        m_bNotifying (FALSE), 
        m_hCompletionPort(NULL) 
    {}

    virtual ~CNotificationMap ();

    void Notify (DWORD   dwDeviceId,
                 LPCWSTR lpcwstrNameGUID,
                 LPCWSTR lpcwstrComputerName,
                 HANDLE  hModule,
                 LPBYTE  lpData, 
                 DWORD   dwDataSize); 

    CNotificationSink * AddLocalSink (
        HINSTANCE               hInst,
        DWORD                   dwDeviceId,
        DWORD                   dwNotifyDeviceId,
        LPCWSTR                 lpcwstrNameGUID,
        PFAX_EXT_CONFIG_CHANGE  lpConfigChangeCallback);

    DWORD RemoveSink (CNotificationSink *pSinkToRemove);

    DWORD Init ();

    HANDLE m_hCompletionPort;
    CFaxCriticalSection m_CsExtensionData;   // Protects all extension data use

private:
    NOTIFY_MAP       m_Map;
    BOOL             m_bNotifying;      // Are we notifying someone now?

    static DWORD  ExtNotificationThread(LPVOID UnUsed); // Extension Notification Thread function

};  // CNotificationMap

/************************************
*                                   *
*             Externs               *
*                                   *
************************************/

extern CNotificationMap* g_pNotificationMap;   // Map of DeviceId+GUID to list of notification sinks
extern CMapDeviceId*     g_pTAPIDevicesIdsMap; // Map between TAPI permanent line id and fax unique device id.

#endif // _EXTENSION_DATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\faxlog.c ===
/*


Module Name:

    faxlog.c

Abstract:

    This is the main fax service activity logging implementation.

Author:

Revision History:

--*/

#include "faxsvc.h"
#include <string>
using namespace std;


LOG_STRING_TABLE g_OutboxTable[] =
{
    {IDS_JOB_ID,                FIELD_TYPE_TEXT,    18,  NULL },
    {IDS_PARENT_JOB_ID,         FIELD_TYPE_TEXT,    18,  NULL },
    {IDS_SUBMITED,              FIELD_TYPE_DATE,    0,   NULL },
    {IDS_SCHEDULED,             FIELD_TYPE_DATE,    0,   NULL },
    {IDS_STATUS,                FIELD_TYPE_TEXT,    255, NULL },
    {IDS_ERROR_DESC,            FIELD_TYPE_TEXT,    255, NULL },
    {IDS_ERROR_CODE,            FIELD_TYPE_TEXT,    10,  NULL },
    {IDS_START_TIME,            FIELD_TYPE_DATE,    0, NULL   },
    {IDS_END_TIME,              FIELD_TYPE_DATE,    0, NULL   },
    {IDS_DEVICE,                FIELD_TYPE_TEXT,    255, NULL },
    {IDS_DIALED_NUMBER,         FIELD_TYPE_TEXT,    255, NULL },
    {IDS_CSID,                  FIELD_TYPE_TEXT,    255, NULL },
    {IDS_TSID,                  FIELD_TYPE_TEXT,    255, NULL },
    {IDS_PAGES,                 FIELD_TYPE_FLOAT,    0, NULL  },
    {IDS_TOTAL_PAGES,           FIELD_TYPE_FLOAT,    0, NULL  },
    {IDS_FILE_NAME,             FIELD_TYPE_TEXT,    255, NULL },
    {IDS_DOCUMENT,              FIELD_TYPE_TEXT,    255, NULL },
    {IDS_FILE_SIZE,             FIELD_TYPE_FLOAT,    0, NULL  },
    {IDS_RETRIES,               FIELD_TYPE_FLOAT,    0, NULL  },
    {IDS_COVER_PAGE,            FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SUBJECT,               FIELD_TYPE_TEXT,    255, NULL },
    {IDS_NOTE,                  FIELD_TYPE_TEXT,    255, NULL },
    {IDS_USER_NAME,             FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_NAME,           FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_FAX_NUMBER,     FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_COMPANY,        FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_STREET,         FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_CITY,           FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_ZIP,            FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_COUNTRY,        FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_TITLE,          FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_DEPARTMENT,     FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_OFFICE,         FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_H_PHONE,        FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_O_PHONE,        FIELD_TYPE_TEXT,    255, NULL },
    {IDS_SENDER_E_MAIL,         FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_NAME,        FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_FAX_NUMBER,  FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_COMPANY,     FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_STREET,      FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_CITY,        FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_ZIP,         FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_COUNTRY,     FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_TITLE,       FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_DEPARTMENT,  FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_OFFICE,      FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_H_PHONE,     FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_O_PHONE,     FIELD_TYPE_TEXT,    255, NULL },
    {IDS_RECIPIENT_E_MAIL,      FIELD_TYPE_TEXT,    255, NULL },
    {IDS_BILLING_CODE,          FIELD_TYPE_TEXT,    255, NULL }
};

LOG_STRING_TABLE g_InboxTable[] =
{
    {IDS_STATUS,            FIELD_TYPE_TEXT,    255, NULL },
    {IDS_ERROR_DESC,        FIELD_TYPE_TEXT,    255, NULL },
    {IDS_ERROR_CODE,        FIELD_TYPE_TEXT,    10, NULL  },
    {IDS_START_TIME,        FIELD_TYPE_DATE,    0, NULL   },
    {IDS_END_TIME,          FIELD_TYPE_DATE,    0, NULL   },
    {IDS_DEVICE,            FIELD_TYPE_TEXT,    255, NULL },
    {IDS_FILE_NAME,         FIELD_TYPE_TEXT,    255, NULL },
    {IDS_FILE_SIZE,         FIELD_TYPE_FLOAT,    0, NULL  },
    {IDS_CSID,              FIELD_TYPE_TEXT,    255, NULL },
    {IDS_TSID,              FIELD_TYPE_TEXT,    255, NULL },
    {IDS_CALLER_ID,         FIELD_TYPE_TEXT,    255, NULL },
    {IDS_ROUTING_INFO,      FIELD_TYPE_TEXT,    255, NULL },
    {IDS_PAGES,             FIELD_TYPE_FLOAT,    0, NULL }
};

const DWORD gc_dwCountInboxTable =  (sizeof(g_InboxTable)/sizeof(g_InboxTable[0]));
const DWORD gc_dwCountOutboxTable =  (sizeof(g_OutboxTable)/sizeof(g_OutboxTable[0]));

HANDLE g_hInboxActivityLogFile;
HANDLE g_hOutboxActivityLogFile;

static 
wstring 
FilteredLogString (LPCWSTR lpcwstrSrc) throw (exception);

static 
VOID
GetSchemaFileText(wstring &wstrRes) throw (exception);

static 
VOID
GetTableColumnsText(
    LPTSTR  ptszTableName,
    wstring &wstrResult
    ) throw (exception);

static 
BOOL 
GetFaxTimeAsString(
    SYSTEMTIME* pFaxTime,
    wstring &wstrTime
    )  throw (exception);

static 
BOOL
GetInboundCommandText(
    PJOB_QUEUE lpJobQueue,
    LPCFSPI_JOB_STATUS lpcFaxStatus,
    wstring &wstrCommandText
    ) throw (exception);
   
static 
BOOL
GetOutboundCommandText(
    PJOB_QUEUE lpJobQueue,
    wstring &wstrCommandText
    ) throw (exception);
    

//
// Important!! - Always lock g_CsInboundActivityLogging and then g_CsOutboundActivityLogging
//
CFaxCriticalSection    g_CsInboundActivityLogging;
CFaxCriticalSection    g_CsOutboundActivityLogging;

BOOL g_fLogStringTableInit;

static DWORD CreateLogFile(DWORD dwFileType, LPCWSTR lpcwstrDBPath, LPHANDLE phFile);
static BOOL  LogFileLimitReached(DWORD dwFileToCheck);
static DWORD LogFileLimitReachAction(DWORD dwFileType);
static DWORD DeleteLogActivityFile(DWORD dwFileType);
static DWORD ReplaceLogActivityFile(DWORD dwFileType);
static LPTSTR BuildFullFileName( LPCTSTR strPath,LPCTSTR strFileName );
static BOOL SetFileToCurrentTime(HANDLE hFile);


//*********************************************************************************
//* Name:   LogInboundActivity()
//* Author: Oded Sacher
//* Date:   Oct 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Inserts new record into the Inbox Activity logging table.
//*     Must be called inside critical section CsActivityLogging.
//*
//* PARAMETERS:
//*     [IN ]   PJOB_QUEUE lpJobQueue
//*         pointer to the job queue of the inbound job.
//*
//*     [IN ]    LPCFSPI_JOB_STATUS lpcFaxStatus
//*         The status of the recieved job.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*********************************************************************************
BOOL
LogInboundActivity(
    PJOB_QUEUE lpJobQueue,
    LPCFSPI_JOB_STATUS lpcFaxStatus
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("LogInboundActivity"));
    wstring wstrText;
    DWORD dwBytesWritten;

    if (!g_ActivityLoggingConfig.bLogIncoming)
    {
        //
        // Inbound activity logging is disabled
        //
        return TRUE;
    }

    Assert (g_hInboxActivityLogFile != INVALID_HANDLE_VALUE);

    try
    {
        if (!GetInboundCommandText(lpJobQueue, lpcFaxStatus, wstrText))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("GetInboundCommandText failed )"));
            dwRes = ERROR_OUTOFMEMORY;
            goto exit;
        }
    }
    catch (exception &ex)
    {
        dwRes = ERROR_OUTOFMEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetInboundCommandText caused exception (%S)"),
            ex.what());
        goto exit;            
    }

    if (LogFileLimitReached(ACTIVITY_LOG_INBOX))
    {
        //
        //  Time to take action and replace/remove the old log file
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Inbox activity log file has reached it's limit. deleting/renaming the old file")
                    );
        dwRes = LogFileLimitReachAction(ACTIVITY_LOG_INBOX);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("LogFileLimitReachAction for ACTIVITY_LOG_INBOX failed (ec: %ld). Inbound activity logging will halt"),
                         dwRes
                         );

            //
            //  May happen if we couldn't create a new log file
            //  CreateLogFile() disables logging on failure
            //
            if (!g_ActivityLoggingConfig.bLogIncoming ||
                 g_hInboxActivityLogFile == INVALID_HANDLE_VALUE)
            {
                goto exit;
            }

            
            //
            //  try to continue with the old log file
            //
            dwRes = ERROR_SUCCESS;

        }

    }

    if (!WriteFile( g_hInboxActivityLogFile,
                    wstrText.c_str(),
                    wstrText.length() * sizeof(WCHAR),
                    &dwBytesWritten,
                    NULL))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("WriteFile failed (ec: %ld)"),
                     dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }
    return TRUE;
}   // LogInboundActivity



//*********************************************************************************
//* Name:   LogOutboundActivity()
//* Author: Oded Sacher
//* Date:   Oct 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Inserts new record into the Outbox Activity logging table.
//*     Must be called inside critical section CsActivityLogging..
//*
//* PARAMETERS:
//*     [IN ]   PJOB_QUEUE lpJobQueue
//*         pointer to the job queue of the inbound job.
//*
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*********************************************************************************
BOOL
LogOutboundActivity(
    PJOB_QUEUE lpJobQueue
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("LogOutboundActivity"));
    wstring wstrText;
    DWORD dwBytesWritten;

    if (!g_ActivityLoggingConfig.bLogOutgoing)
    {
        //
        // Outbound activity logging is disabled
        //
        return TRUE;
    }

    Assert (g_hOutboxActivityLogFile != INVALID_HANDLE_VALUE);
    try
    {
        if (!GetOutboundCommandText(lpJobQueue, wstrText))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("GetOutboundCommandText failed )"));
            dwRes = ERROR_OUTOFMEMORY;
            goto exit;
        }
    }
    catch (exception &ex)
    {
        dwRes = ERROR_OUTOFMEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetOutboundCommandText caused exception (%S)"),
            ex.what());
        goto exit;            
    }

    if (LogFileLimitReached(ACTIVITY_LOG_OUTBOX))
    {
        //
        //  Time to take action and replace/remove the old log file
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Outbox activity log file has reached it's limit. deleting/renaming the old file")
                    );
        dwRes = LogFileLimitReachAction(ACTIVITY_LOG_OUTBOX);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("LogFileLimitReachAction for ACTIVITY_LOG_OUTBOX failed (ec: %ld)."),
                         dwRes
                        );

            //
            //  May happen if we couldn't create a new log file
            //  CreateLogFile() disables logging on failure
            //
            if (!g_ActivityLoggingConfig.bLogOutgoing ||
                 g_hOutboxActivityLogFile == INVALID_HANDLE_VALUE)
            {
                goto exit;
            }

            
            //
            //  try to continue with the old log file
            //
            dwRes = ERROR_SUCCESS;

        }
    }

    if (!WriteFile( g_hOutboxActivityLogFile,
                    wstrText.c_str(),
                    wstrText.length() * sizeof(WCHAR),
                    &dwBytesWritten,
                    NULL))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("WriteFile failed (ec: %ld)"),
                     dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        SetLastError (dwRes);
        return FALSE;
    }
    return TRUE;
}   // LogOutboundActivity


//*********************************************************************************
//* Name:   GetTableColumnsText()
//* Author: Oded Sacher
//* Date:   Oct 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Retrieves the first row of the log file (column names).
//*
//* PARAMETERS:
//*     [IN]        LPTSTR  TableName
//*         Table name, can be Outbox or Inbox.
//*
//*     [IN]        wstring &wstrResult
//*         Output result string
//*
//* RETURN VALUE:
//*         None
//*
//* NOTE: The function might throw STL string exceptions.
//*
//*********************************************************************************
static
VOID
GetTableColumnsText(
    LPTSTR  ptszTableName,
    wstring &wstrResult
    ) throw (exception)
{
    DEBUG_FUNCTION_NAME(TEXT("GetTableColumnsText"));
    PLOG_STRING_TABLE Table = NULL;
    DWORD Count = 0;

    if (!_tcscmp(ptszTableName, INBOX_TABLE))
    {
        Table = g_InboxTable;
        Count = gc_dwCountInboxTable;
    }
    else
    {
        Table = g_OutboxTable;
        Count = gc_dwCountOutboxTable;
    }
    Assert(Table);

    for (DWORD Index = 0; Index < Count; Index++)
    {
        wstrResult += TEXT("\"");
        wstrResult += Table[Index].String;
        wstrResult += TEXT("\"");
        if (Index < Count - 1)
        {
            wstrResult += TEXT("\t");
        }
    }
    wstrResult += TEXT("\r\n");
    DebugPrintEx(DEBUG_MSG,
                 TEXT("First row (Columns names): %s"),
                 wstrResult.c_str());
}   // GetTableColumnsText


//*********************************************************************************
//* Name:   GetSchemaFileText()
//* Author: Oded Sacher
//* Date:   Jul 25, 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Retrieves the scema.ini text buffer.
//*
//* PARAMETERS:
//*     [IN] wstring &wstrRes
//*          Output result string
//*
//* RETURN VALUE:
//*         None.
//*
//* NOTE: The function might throw STL string exceptions.
//*
//*********************************************************************************
static
VOID
GetSchemaFileText(wstring &wstrRes) throw (exception)
{
    DEBUG_FUNCTION_NAME(TEXT("GetSchemaFileText"));
    DWORD Index;
    //
    // Inbox table
    //
    wstrRes += TEXT("[");
    wstrRes += ACTIVITY_LOG_INBOX_FILE;
    wstrRes += TEXT("]\r\n");

    wstrRes += TEXT("ColNameHeader=True\r\n");
    wstrRes += TEXT("Format=TabDelimited\r\n");
    wstrRes += TEXT("CharacterSet=1200\r\n");

    for (Index = 0; Index < gc_dwCountInboxTable; Index++)
    {
        TCHAR tszTemp[MAX_PATH * 2] = {0};
        if (0 == wcscmp(g_InboxTable[Index].Type, FIELD_TYPE_TEXT))
        {
            _snwprintf(tszTemp,
                       ARR_SIZE(tszTemp)-1,
                       TEXT("Col%ld=%s %s Width %ld\r\n"),
                       Index + 1,
                       g_InboxTable[Index].String,
                       g_InboxTable[Index].Type,
                       g_InboxTable[Index].Size);
        }
        else
        {
            _snwprintf(tszTemp,
                       ARR_SIZE(tszTemp)-1,
                       TEXT("Col%ld=%s %s\r\n"),
                       Index + 1,
                       g_InboxTable[Index].String,
                       g_InboxTable[Index].Type);
        }
        wstrRes += tszTemp;
    }

    //
    // Outbox table
    //
    wstrRes += TEXT("[");
    wstrRes += ACTIVITY_LOG_OUTBOX_FILE;
    wstrRes += TEXT("]\r\n");

    wstrRes += TEXT("ColNameHeader=True\r\n");
    wstrRes += TEXT("Format=TabDelimited\r\n");
    wstrRes += TEXT("CharacterSet=1200\r\n");

    for (Index = 0; Index < gc_dwCountOutboxTable; Index++)
    {
        TCHAR tszTemp[MAX_PATH * 2] = {0};
        if (0 == wcscmp(g_OutboxTable[Index].Type, FIELD_TYPE_TEXT))
        {
            _snwprintf(tszTemp,
                       ARR_SIZE(tszTemp)-1,
                       TEXT("Col%ld=%s %s Width %ld\r\n"),
                       Index + 1,
                       g_OutboxTable[Index].String,
                       g_OutboxTable[Index].Type,
                       g_OutboxTable[Index].Size);
        }
        else
        {
            _snwprintf(tszTemp,
                       ARR_SIZE(tszTemp)-1,
                       TEXT("Col%ld=%s %s\r\n"),
                       Index + 1,
                       g_OutboxTable[Index].String,
                       g_OutboxTable[Index].Type);
        }
        wstrRes += tszTemp;
    }
}   // GetSchemaFileText




//*********************************************************************************
//* Name:   CreateLogDB()
//* Author: Oded Sacher
//* Date:   Oct 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Creates the database files. Creates the Schema.ini file.
//*
//* PARAMETERS:
//*     [IN]   LPCWSTR lpcwstrDBPath
//*         Pointer to a NULL terminated string contains the DB path.
//*     [OUT]  LPHANDLE phInboxFile
//*         Adress of a variable to receive the inbox file handle. 
//*     [OUT]  LPHANDLE phOutboxFile
//*         Adress of a variable to receive the outbox file handle.
//*
//* RETURN VALUE:
//*         Win32 error Code
//*********************************************************************************
DWORD
CreateLogDB (
    LPCWSTR lpcwstrDBPath,
    LPHANDLE phInboxFile,
    LPHANDLE phOutboxFile
    )
{
    DEBUG_FUNCTION_NAME(TEXT("CreateLogDB"));
    DWORD dwRes = ERROR_SUCCESS;
    HANDLE hInboxFile = INVALID_HANDLE_VALUE;
    HANDLE hOutboxFile = INVALID_HANDLE_VALUE;
    HANDLE hSchemaFile = INVALID_HANDLE_VALUE;
    WCHAR wszFileName[MAX_PATH] = {0};
    DWORD dwBytesWritten;
    DWORD ec = ERROR_SUCCESS;  // Used for Schema.ini
    wstring wstrSchema;

    INT iCount = 0;

    Assert (lpcwstrDBPath && phInboxFile && phOutboxFile);

    if (FALSE == g_fLogStringTableInit)
    {
        dwRes = InitializeLoggingStringTables();
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("Close connection failed (hr: 0x%08x)"),
                         dwRes);
            return dwRes;
        }
        g_fLogStringTableInit = TRUE;
    }    

    dwRes = IsValidFaxFolder(lpcwstrDBPath);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("IsValidFaxFolder failed for folder : %s (ec=%lu)."),
                     lpcwstrDBPath,
                     dwRes);
        return dwRes;
    }

    //
    // Create the logging files
    //
    dwRes = CreateLogFile(ACTIVITY_LOG_INBOX,lpcwstrDBPath,&hInboxFile);
    if ( ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("CreateLogFile() Failed, for Inbox file. (ec=%ld)"),
                        dwRes
                    );
        goto exit;
    }

    dwRes = CreateLogFile(ACTIVITY_LOG_OUTBOX,lpcwstrDBPath,&hOutboxFile);
    if ( ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("CreateLogFile() Failed, for Outbox file. (ec=%ld)"),
                        dwRes
                    );
        goto exit;
    }

    *phInboxFile = hInboxFile;
    *phOutboxFile= hOutboxFile;

    
    Assert (ERROR_SUCCESS == dwRes && ERROR_SUCCESS == ec);

    //
    //  Create the Schema.ini file - Function do not fail if not succeeded
    //
    
    iCount = _snwprintf (wszFileName,
                        MAX_PATH - 1,
                        TEXT("%s\\%s"),
                        lpcwstrDBPath,
                        TEXT("schema.ini"));
    if (0 > iCount)
    {
        //
        //  path and file name exceeds MAX_PATH
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));
        ec = ERROR_BUFFER_OVERFLOW;
        goto exit;
    }
    hSchemaFile = SafeCreateFile( 
                              wszFileName,              // file name
                              GENERIC_WRITE,            // access mode
                              0,                        // share mode
                              NULL,                     // SD
                              CREATE_ALWAYS,            // how to create
                              FILE_ATTRIBUTE_NORMAL,    // file attributes
                              NULL);
    if (INVALID_HANDLE_VALUE == hSchemaFile)
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateFile failed (ec: %ld)"),
                     ec);
        goto exit;
    }

    try
    {
        GetSchemaFileText(wstrSchema);
    }
    catch (exception &ex)
    {
        dwRes = ERROR_OUTOFMEMORY;
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetSchemaFileText caused exception (%S)"),
            ex.what());
        goto exit;            
    }

    if (!WriteFile( hSchemaFile,
                    wstrSchema.c_str(),
                    wstrSchema.length() * sizeof(WCHAR),
                    &dwBytesWritten,
                    NULL))
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("WriteFile failed (ec: %ld)"),
                     ec);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes && ERROR_SUCCESS == ec);

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        if (INVALID_HANDLE_VALUE != hOutboxFile)
        {
            if (!CloseHandle (hOutboxFile))
            {
                DebugPrintEx(DEBUG_ERR,
                     TEXT("CloseHandle failed (ec: %ld)"),
                     GetLastError());
            }
        }

        if (INVALID_HANDLE_VALUE != hInboxFile)
        {
            if (!CloseHandle (hInboxFile))
            {
                DebugPrintEx(DEBUG_ERR,
                     TEXT("CloseHandle failed (ec: %ld)"),
                     GetLastError());
            }
        }
    }

    if (INVALID_HANDLE_VALUE != hSchemaFile)
    {
        if (!CloseHandle (hSchemaFile))
        {
            DebugPrintEx(DEBUG_ERR,
                 TEXT("CloseHandle failed (ec: %ld)"),
                 GetLastError());
        }
    }

    if (ERROR_SUCCESS != ec)
    {        
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            FAXLOG_LEVEL_MED,
            2,
            MSG_FAX_ACTIVITY_LOG_FAILED_SCHEMA,
            wszFileName,
            DWORD2DECIMAL(ec)
           );
    }
    return dwRes;
}   // CreateLogDB

//*********************************************************************************
//* Name:   InitializeLogging()
//* Author: Oded Sacher
//* Date:   Jun 26, 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Initializes the Activity Logging. Opens the files.
//*
//*
//* PARAMETERS:  None
//*
//* RETURN VALUE:
//*     Win32 error code.
//*********************************************************************************
DWORD
InitializeLogging(
    VOID
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("InitializeLogging"));


    if (!g_ActivityLoggingConfig.lptstrDBPath)
    {
        //
        // Activity logging is off
        //
        return ERROR_SUCCESS;
    }

    EnterCriticalSection (&g_CsInboundActivityLogging);
    EnterCriticalSection (&g_CsOutboundActivityLogging);

    Assert ( (INVALID_HANDLE_VALUE == g_hInboxActivityLogFile) &&
             (INVALID_HANDLE_VALUE == g_hOutboxActivityLogFile) );

    //
    // Create the logging files
    //
    dwRes = CreateLogDB (g_ActivityLoggingConfig.lptstrDBPath,
                         &g_hInboxActivityLogFile,
                         &g_hOutboxActivityLogFile);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateLogDB failed (hr: 0x%08x)"),
                     dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsOutboundActivityLogging);
    LeaveCriticalSection (&g_CsInboundActivityLogging);
    return dwRes;
}




//*********************************************************************************
//* Name:   GetInboundCommandText()
//* Author: Oded Sacher
//* Date:   Oct 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Retrieves a buffer with the new inbound record.
//*     The function allocates the memory for the string that will contain the record.
//*
//* PARAMETERS:
//*     [IN ]   PJOB_QUEUE lpJobQueue
//*         pointer to the job queue of the inbound job.
//*
//*     [IN ]    LPCFSPI_JOB_STATUS lpcFaxStatus
//*         The status of the recieved job.
//*
//*     [OUT]   wstring &wstrCommandText
//*         String to compose
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*
//* NOTE: The function might throw STL string exceptions.
//*
//*********************************************************************************
static
BOOL
GetInboundCommandText(
    PJOB_QUEUE lpJobQueue,
    LPCFSPI_JOB_STATUS lpcFaxStatus,
    wstring &wstrCommandText
    ) throw (exception)
{
    DEBUG_FUNCTION_NAME(TEXT("GetInboundCommandText"));
    BOOL bStartTime;
    BOOL bEndTime;
    SYSTEMTIME tmStart;
    SYSTEMTIME tmEnd;    
    HINSTANCE hLoadInstance = NULL;

    Assert (lpJobQueue->JobEntry);
    Assert (lpJobQueue->JobEntry->LineInfo);

    bStartTime = GetRealFaxTimeAsSystemTime (lpJobQueue->JobEntry, FAX_TIME_TYPE_START, &tmStart);
    if (bStartTime == FALSE)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("GetRealFaxTimeAsSystemTime (Start time) Failed (ec: %ld)"),
                      GetLastError());
    }

    bEndTime = GetRealFaxTimeAsSystemTime (lpJobQueue->JobEntry, FAX_TIME_TYPE_END, &tmEnd);
    if (bEndTime == FALSE)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("GetRealFaxTimeAsSystemTime (End time) Failed (ec: %ld)"),
                      GetLastError());
    }

    //
    // Status
    //
    wstrCommandText += TEXT("\"");
    switch (lpcFaxStatus->dwJobStatus)
    {
        case FSPI_JS_FAILED:
            wstrCommandText += FilteredLogString(GetString(IDS_FAILED_RECEIVE));
            break;

        case FSPI_JS_COMPLETED:
            wstrCommandText += FilteredLogString(GetString(FPS_COMPLETED));
            break;

        case FSPI_JS_ABORTED:
            wstrCommandText += FilteredLogString(GetString(IDS_CANCELED));
            break;

        default:
            ASSERT_FALSE;
    }
    wstrCommandText += TEXT("\"\t\"");

    //
    // ErrorDesc
    //
    wstring wstrErr;
    if (lstrlen(lpJobQueue->JobEntry->ExStatusString))
    {
        //
        // The FSP provided extended status string
        //
        wstrErr = lpJobQueue->JobEntry->ExStatusString;
    }
    else if (lpcFaxStatus->dwExtendedStatus == 0)
    {
        //
        // No extended status
        //
        wstrErr = TEXT(" ");
    }
    else
    {
        //
        // Well known extended status
        //
        LPTSTR ResStr = MapFSPIJobExtendedStatusToString(lpcFaxStatus->dwExtendedStatus);
        if (NULL == ResStr)
        {
            ASSERT_FALSE;
            wstrErr = TEXT(" ");
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Unexpected extended status. Extended Status: %ld, Provider: %s"),
                lpcFaxStatus->dwExtendedStatus,
                lpJobQueue->JobEntry->LineInfo->Provider->ImageName);
        }
        else
        {                
            if (FSPI_ES_PARTIALLY_RECEIVED == lpcFaxStatus->dwExtendedStatus && // This is a partially received fax
                lstrlen(lpJobQueue->ExStatusString))                            // The original extended status string is not empty)
            {
                //
                // copy both the partially received and original extended status strings
                //
                wstrErr = ResStr;
                wstrErr += TEXT(" - ");
                wstrErr += lpJobQueue->ExStatusString;
            }
            else
            {
                //
                // Copy just the extended status string
                //
                wstrErr = ResStr;
            }
        }                        
    }
    wstrCommandText += FilteredLogString(wstrErr.c_str());
    wstrCommandText += TEXT("\"\t\"");

    //
    // Error Code
    //
    if (lpcFaxStatus->dwExtendedStatus == 0)
    {
        wstrErr = TEXT(" ");
    }
    else
    {
        TCHAR tszHexNum [40];
        swprintf(tszHexNum, TEXT("0x%08x"), lpcFaxStatus->dwExtendedStatus);
        wstrErr = tszHexNum;
    }
    wstrCommandText += wstrErr;
    wstrCommandText += TEXT("\"\t");

    //
    // StartTime
    //
    if (bStartTime)
    {
        wstring wstrTime;
        if (!GetFaxTimeAsString (&tmStart, wstrTime))
        {
            DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("GetFaxTimeAsString Failed (ec: %ld)"),
                        GetLastError());
            return FALSE;
        }
        wstrCommandText += FilteredLogString(wstrTime.c_str());
    }
    wstrCommandText += TEXT("\t");

    //
    // EndTime
    //
    if (bEndTime)
    {
        wstring wstrTime;

        if (!GetFaxTimeAsString (&tmEnd, wstrTime))
        {
            DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("GetFaxTimeAsString Failed (ec: %ld)"),
                        GetLastError());
            return FALSE;
        }
        wstrCommandText += FilteredLogString(wstrTime.c_str());
    }
    wstrCommandText += TEXT("\t\"");

    //
    // Device
    //
    wstrCommandText += FilteredLogString(lpJobQueue->JobEntry->LineInfo->DeviceName);
    wstrCommandText += TEXT("\"\t\"");

    //
    // File name
    //
    wstrCommandText += FilteredLogString(lpJobQueue->FileName);
    wstrCommandText += TEXT("\"\t");

    //
    // File size
    //
    TCHAR tszSize[40];
    swprintf(tszSize,TEXT("%ld"), lpJobQueue->FileSize);
    wstrCommandText += tszSize;
    wstrCommandText += TEXT("\t\"");

    //
    // CSID
    //
    wstrCommandText += FilteredLogString(lpJobQueue->JobEntry->LineInfo->Csid);
    wstrCommandText += TEXT("\"\t\"");

    //
    // TSID
    //
    wstrCommandText += FilteredLogString(lpcFaxStatus->lpwstrRemoteStationId);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Caller ID
    //
    wstrCommandText += FilteredLogString(lpcFaxStatus->lpwstrCallerId);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Routing information
    //
    wstrCommandText += FilteredLogString(lpcFaxStatus->lpwstrRoutingInfo);
    wstrCommandText += TEXT("\"\t");

    //
    // Pages
    //
    TCHAR tszPages[40];
    swprintf(tszPages,TEXT("%ld"),lpcFaxStatus->dwPageCount);
    wstrCommandText += tszPages;
    wstrCommandText += TEXT("\r\n");

    DebugPrintEx(DEBUG_MSG,
                   TEXT("Inbound SQL statement: %s"),
                   wstrCommandText.c_str());
    return TRUE;
}   // GetInboundCommandText



//*********************************************************************************
//* Name:   GetOutboundCommandText()
//* Author: Oded Sacher
//* Date:   Oct 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Retrieves a buffer that contains the new outbound record.
//*     The function allocates the memory for the buffer that will contain the new record.
//*
//* PARAMETERS:
//*     [IN ]   PJOB_QUEUE lpJobQueue
//*         pointer to the job queue of the inbound job.
//*
//*     [OUT]   wstring &wstrCommandText
//*         String to compose
//*
//* RETURN VALUE:
//*     TRUE
//*         If no error occured.
//*     FALSE
//*         If an error occured.
//*
//* NOTE: The function might throw STL string exceptions.
//*
//*********************************************************************************
static
BOOL
GetOutboundCommandText(
    PJOB_QUEUE lpJobQueue,
    wstring &wstrCommandText
    ) throw (exception)
{
    DEBUG_FUNCTION_NAME(TEXT("GetOutboundCommandText"));
    BOOL bStartTime;
    BOOL bEndTime;
    BOOL bOriginalTime;
    BOOL bSubmissionTime;
    SYSTEMTIME tmStart;
    SYSTEMTIME tmEnd;
    SYSTEMTIME tmOriginal;
    SYSTEMTIME tmSubmission;
    HINSTANCE hLoadInstance = NULL;

    Assert (lpJobQueue->lpParentJob->SubmissionTime);
    Assert (lpJobQueue->lpParentJob->OriginalScheduleTime);

    bSubmissionTime = FileTimeToSystemTime ((FILETIME*)&(lpJobQueue->lpParentJob->SubmissionTime), &tmSubmission);
    if (bSubmissionTime == FALSE)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("FileTimeToSystemTime (Submission time) Failed (ec: %ld)"),
                      GetLastError());
    }

    bOriginalTime = FileTimeToSystemTime ((FILETIME*)&(lpJobQueue->lpParentJob->SubmissionTime), &tmOriginal);
    if (bOriginalTime == FALSE)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("FileTimeToSystemTime (Original schduled time) Failed (ec: %ld)"),
                      GetLastError());
    }

    if (NULL != lpJobQueue->JobEntry)
    {
        bStartTime = GetRealFaxTimeAsSystemTime (lpJobQueue->JobEntry, FAX_TIME_TYPE_START, &tmStart);
        if (bStartTime == FALSE)
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("GetRealFaxTimeAsSystemTime (Start time) Failed (ec: %ld)"),
                          GetLastError());
        }

        bEndTime = GetRealFaxTimeAsSystemTime (lpJobQueue->JobEntry, FAX_TIME_TYPE_END, &tmEnd);
        if (bEndTime == FALSE)
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("GetRealFaxTimeAsSystemTime (End time) Failed (ec: %ld)"),
                          GetLastError());
        }
    }

    //
    // JobID
    //
    TCHAR tszTemp[100];
    
    swprintf(tszTemp,TEXT("0x%016I64x"), lpJobQueue->UniqueId);
    wstrCommandText += TEXT("\"");
    wstrCommandText += tszTemp;
    wstrCommandText += TEXT("\"\t\"");

    //
    // Parent JobID
    //
    swprintf(tszTemp,TEXT("0x%016I64x"), lpJobQueue->lpParentJob->UniqueId);
    wstrCommandText += tszTemp;
    wstrCommandText += TEXT("\"\t");

    //
    // Submition time
    //
    if (bSubmissionTime)
    {
        wstring wstrTime;
        if (!GetFaxTimeAsString (&tmSubmission, wstrTime))
        {
            DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("GetFaxTimeAsString Failed (ec: %ld)"),
                        GetLastError());
            return FALSE;
        }
        wstrCommandText += FilteredLogString(wstrTime.c_str());
    }
    wstrCommandText += TEXT("\t");

    //
    // Originaly scheduled time
    //
    if (bOriginalTime)
    {
        wstring wstrTime;
        if (!GetFaxTimeAsString (&tmOriginal, wstrTime))
        {
            DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("GetFaxTimeAsString Failed (ec: %ld)"),
                        GetLastError());
            return FALSE;
        }
        wstrCommandText += FilteredLogString(wstrTime.c_str());
    }
    wstrCommandText += TEXT("\t\"");

    //
    // Status
    //
    if (JS_CANCELED == lpJobQueue->JobStatus)
    {
        wstrCommandText += FilteredLogString(GetString(IDS_CANCELED));
        wstrCommandText += TEXT("\"\t\"");
        //
        // Fill the empty columns with NULL information
        //
        wstrCommandText += TEXT("\"\t\""); // ErrorDesc
        wstrCommandText += TEXT("\"\t");   // Error Code

        wstrCommandText += TEXT("\t");     // StartTime
        wstrCommandText += TEXT("\t\"");   // EndTime

        wstrCommandText += TEXT("\"\t\""); // Device
        wstrCommandText += TEXT("\"\t\""); // DialedNumber
        wstrCommandText += TEXT("\"\t\""); // CSID
        wstrCommandText += TEXT("\"\t");   // TSID
        wstrCommandText += TEXT("\t");     // Pages
    }
    else
    {
        // Completed/Failed/Aborted jobs only
        Assert (lpJobQueue->JobEntry);
        Assert (lpJobQueue->JobEntry->LineInfo);

        switch (lpJobQueue->JobEntry->FSPIJobStatus.dwJobStatus)
        {
            case FSPI_JS_FAILED:
            case FSPI_JS_FAILED_NO_RETRY:
            case FSPI_JS_DELETED:
                wstrCommandText += FilteredLogString(GetString(IDS_FAILED_SEND));
                break;

            case FSPI_JS_COMPLETED :
                wstrCommandText += FilteredLogString(GetString(FPS_COMPLETED));
                break;

            case FSPI_JS_ABORTED :
                wstrCommandText += FilteredLogString(GetString(IDS_CANCELED));
                break;

            default:
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Invalid FSPI_JS status:  0x%08X for JobId: %ld"),
                    lpJobQueue->JobStatus,
                    lpJobQueue->JobId);
                Assert(FSPI_JS_DELETED == lpJobQueue->JobEntry->FSPIJobStatus.dwJobStatus); // ASSERT_FALSE
        }
        wstrCommandText += TEXT("\"\t\"");

        //
        // ErrorDesc
        //
        wstring wstrErr;
        
        if (lstrlen(lpJobQueue->JobEntry->ExStatusString))
        {
            //
            // The FSP provided extended status string
            //
            wstrErr = lpJobQueue->JobEntry->ExStatusString;
        }
        else if (lpJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus == 0)
        {
            //
            // No extended status
            //
            wstrErr = TEXT(" ");
        }
        else
        {
            //
            // Well known extended status
            //
            LPTSTR ResStr = MapFSPIJobExtendedStatusToString(lpJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus);
            if (NULL == ResStr)
            {
                ASSERT_FALSE;
                wstrErr = TEXT(" ");
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Unexpected extended status. Extended Status: %ld, Provider: %s"),
                    lpJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus,
                    lpJobQueue->JobEntry->LineInfo->Provider->ImageName);
            }
            else
            {
                wstrErr = ResStr;
            }                        
        }
        wstrCommandText += FilteredLogString(wstrErr.c_str());
        wstrCommandText += TEXT("\"\t\"");

        //
        // Error Code
        //
        if (lpJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus == 0)
        {
            wstrErr = TEXT(" ");
        }
        else
        {
            swprintf(tszTemp, TEXT("0x%08x"), lpJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus);
            wstrErr = tszTemp;
        }
        wstrCommandText += wstrErr;
        wstrCommandText += TEXT("\"\t");

        //
        // StartTime
        //
        if (bStartTime)
        {
            wstring wstrTime;
            if (!GetFaxTimeAsString (&tmStart, wstrTime))
            {
                DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("GetFaxTimeAsString Failed (ec: %ld)"),
                            GetLastError());
                return FALSE;
            }
            wstrCommandText += FilteredLogString(wstrTime.c_str());
        }
        wstrCommandText += TEXT("\t");

        //
        // EndTime
        //
        if (bEndTime)
        {
            wstring wstrTime;
            if (!GetFaxTimeAsString (&tmEnd, wstrTime))
            {
                DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("GetFaxTimeAsString Failed (ec: %ld)"),
                            GetLastError());
                return FALSE;
            }
            wstrCommandText += FilteredLogString(wstrTime.c_str());
        }
        wstrCommandText += TEXT("\t\"");

        //
        // Device
        //
        wstrCommandText += FilteredLogString(lpJobQueue->JobEntry->LineInfo->DeviceName);
        wstrCommandText += TEXT("\"\t\"");

        //
        // DialedNumber
        //
        if (wcslen (lpJobQueue->JobEntry->DisplayablePhoneNumber))
        {
            // The canonical number was translated to displayable number
            wstrCommandText += FilteredLogString(lpJobQueue->JobEntry->DisplayablePhoneNumber);
        }
        else
        {
            // The canonical number was not translated
            wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrFaxNumber);
        }
        wstrCommandText += TEXT("\"\t\"");

        //
        // CSID
        //
        wstrCommandText += FilteredLogString(lpJobQueue->JobEntry->FSPIJobStatus.lpwstrRemoteStationId);
        wstrCommandText += TEXT("\"\t\"");

        //
        // TSID
        //
        wstrCommandText += FilteredLogString(lpJobQueue->JobEntry->LineInfo->Tsid);
        wstrCommandText += TEXT("\"\t");

        //
        // Pages
        //
        swprintf(tszTemp, TEXT("%ld"),lpJobQueue->JobEntry->FSPIJobStatus.dwPageCount);
        wstrCommandText += tszTemp;
        wstrCommandText += TEXT("\t");
    }
    // Common for Canceled and Failed/Completed/Aborted Jobs

    //
    // Total pages
    //
    swprintf(tszTemp, TEXT("%ld"),lpJobQueue->lpParentJob->PageCount);
    wstrCommandText += tszTemp;
    wstrCommandText += TEXT("\t\"");

    //
    // Queue file name
    //
    wstrCommandText += FilteredLogString(lpJobQueue->QueueFileName);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Document
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->JobParamsEx.lptstrDocumentName);
    wstrCommandText += TEXT("\"\t");

    //
    // File size
    //
    swprintf(tszTemp, TEXT("%ld"), lpJobQueue->lpParentJob->FileSize);
    wstrCommandText += tszTemp;
    wstrCommandText += TEXT("\t");

    //
    // Retries
    //
    swprintf(tszTemp, TEXT("%d"), lpJobQueue->SendRetries);
    wstrCommandText += tszTemp;
    wstrCommandText += TEXT("\t\"");

    //
    // ServerCoverPage
    //
    if (lpJobQueue->lpParentJob->CoverPageEx.bServerBased == TRUE)
    {
        wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->CoverPageEx.lptstrCoverPageFileName);
    }
    else
    {
        wstrCommandText += TEXT(" ");
    }
    wstrCommandText += TEXT("\"\t\"");

    //
    // Cover page subject
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->CoverPageEx.lptstrSubject);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Cover page note
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->CoverPageEx.lptstrNote);
    wstrCommandText += TEXT("\"\t\"");

    //
    // User Name
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->UserName);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender Name
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrName);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender FaxNumber
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrFaxNumber);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender Company
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrCompany);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender Street
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrStreetAddress);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender City
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrCity);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender ZipCode
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrZip);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender Country
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrCountry);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender Title
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrTitle);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender Department
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrDepartment);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender Office
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrOfficeLocation);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender HomePhone
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrHomePhone);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender OfficePhone
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrOfficePhone);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Sender EMail
    //
    wstrCommandText += FilteredLogString(lpJobQueue->lpParentJob->SenderProfile.lptstrEmail);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient Name
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrName);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient FaxNumber
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrFaxNumber);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient Company
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrCompany);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient Street
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrStreetAddress);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient City
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrCity);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient ZipCode
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrZip);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient Country
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrCountry);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient Title
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrTitle);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient Department
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrDepartment);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient Office
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrOfficeLocation);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient HomePhone
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrHomePhone);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient OfficePhone
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrOfficePhone);
    wstrCommandText += TEXT("\"\t\"");

    //
    // Recipient EMail
    //
    wstrCommandText += FilteredLogString(lpJobQueue->RecipientProfile.lptstrEmail);
    wstrCommandText += TEXT("\"\t\"");

    //
    // BillingCode
    //
    wstrCommandText += FilteredLogString(lpJobQueue->SenderProfile.lptstrBillingCode);
    wstrCommandText += TEXT("\"\r\n");

    DebugPrintEx(DEBUG_MSG,
                   TEXT("Outboun SQL statement: %s"),
                   wstrCommandText.c_str());
    return TRUE;
}   // GetOutboundCommandText


//*********************************************************************************
//* Name:   InitializeLoggingStringTables()
//* Author: Oded Sacher
//* Date:   Oct 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Initializes the Activity Logging string tables (Inbox and Outbox)
//*
//*
//* PARAMETERS:  None
//*
//* RETURN VALUE:
//*     Win32 error code.
//*********************************************************************************
DWORD
InitializeLoggingStringTables(
    VOID
    )
{
    DWORD i;
    DWORD err = ERROR_SUCCESS;
    HINSTANCE hInstance;
    TCHAR Buffer[MAX_PATH];
    DEBUG_FUNCTION_NAME(TEXT("InitializeLoggingStringTables"));

    hInstance = GetResInstance(NULL);
    if(!hInstance)
    {
        return GetLastError();
    }

    for (i=0; i<gc_dwCountInboxTable; i++)
    {
        if (LoadString(hInstance,
                       g_InboxTable[i].FieldStringResourceId,
                       Buffer,
                       sizeof(Buffer)/sizeof(TCHAR)))
        {
            g_InboxTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) );
            if (!g_InboxTable[i].String)
            {
                DebugPrintEx(DEBUG_ERR,
                         TEXT("Failed to allocate memory"));
                err = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            else
            {
                _tcscpy( g_InboxTable[i].String, Buffer );
            }
        }
        else
        {
            err = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("LoadString failed, Code:%d"),err);
            goto CleanUp;
        }
    }

    for (i=0; i<gc_dwCountOutboxTable; i++)
    {
        if (LoadString(hInstance,
                       g_OutboxTable[i].FieldStringResourceId,
                       Buffer,
                       sizeof(Buffer)/sizeof(TCHAR)))
        {
            g_OutboxTable[i].String = (LPTSTR) MemAlloc( StringSize( Buffer ) );
            if (!g_OutboxTable[i].String)
            {
                DebugPrintEx(DEBUG_ERR,
                         TEXT("Failed to allocate memory"));
                err = ERROR_OUTOFMEMORY;
                goto CleanUp;
            }
            else
            {
                _tcscpy( g_OutboxTable[i].String, Buffer );
            }

        }
        else
        {
            err = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("LoadString failed, Code:%d"),err);
            goto CleanUp;
        }
    }

    Assert (ERROR_SUCCESS == err);
    return ERROR_SUCCESS;

CleanUp:
    Assert (err != ERROR_SUCCESS);

    for (i=0; i<gc_dwCountInboxTable; i++)
    {
        MemFree (g_InboxTable[i].String);
        g_InboxTable[i].String = NULL;
    }


    for (i=0; i<gc_dwCountOutboxTable; i++)
    {
        MemFree (g_OutboxTable[i].String);
        g_OutboxTable[i].String = NULL;
    }
    return err;
}   // InitializeLoggingStringTables




//*********************************************************************************
//* Name:   FilteredLogString
//* Author: Eran Yariv
//* Date:   Feb 19, 2002
//*********************************************************************************
//* DESCRIPTION:
//*     This function is used to filter strings that go into the log files.
//*
//* PARAMETERS:
//*     [IN]   LPCWSTR lpcwstrSrc
//*         The string to filter
//*
//*
//* RETURN VALUE:
//*         Filtered string
//*
//* NOTE: The function might throw STL string exceptions.
//*
//*********************************************************************************
static
wstring 
FilteredLogString (LPCWSTR lpcwstrSrc) throw (exception)
{

    DEBUG_FUNCTION_NAME(TEXT("FilteredLogString"));

    if (!lpcwstrSrc)
    {
        return EMPTY_LOG_STRING;
    }
    wstring wstrResult = lpcwstrSrc;
    //
    // Replace new lines ('\n') with one space (' ')
    //
    wstring::size_type position;
    while (wstring::npos != (position = wstrResult.find (TEXT('\n'))))
    {
        wstrResult[position] = TEXT(' ');
    }
    //
    // Replace carriage returns ('\r') with one space (' ')
    //
    while (wstring::npos != (position = wstrResult.find (TEXT('\r'))))
    {
        wstrResult[position] = TEXT(' ');
    }
    //
    // Replace double quotes ('"') with single quotes ('\'')
    //
    while (wstring::npos != (position = wstrResult.find (TEXT('"'))))
    {
        wstrResult[position] = TEXT('\'');
    }
    //
    // Replace tabs ('"') with 4 spaces ("    ")
    //
    while (wstring::npos != (position = wstrResult.find (TEXT('\t'))))
    {
        wstrResult.replace (position, 1, 4, TEXT(' '));
    }
    return wstrResult;    
}   // FilteredLogString

//*********************************************************************************
//* Name:   GetFaxTimeAsString
//* Author: Oded Sacher
//* Date:   Oct 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     This function is used to convert a fax time to a string.
//*
//* PARAMETERS:
//*     [IN]   SYSTEMTIME* UniversalTime
//*         Fax time
//*
//*     [OUT]  wstring &wstrTime
//*         The output string.
//*
//*
//* RETURN VALUE:
//*         TRUE for success, FALSE otherwise.
//*
//* NOTE: The function might throw STL string exceptions.
//*
//*********************************************************************************
static
BOOL 
GetFaxTimeAsString(
    SYSTEMTIME* UniversalTime,
    wstring &wstrTime) throw (exception)
{
    DWORD Res;
    SYSTEMTIME LocalTime;
    TIME_ZONE_INFORMATION LocalTimeZone;
    DEBUG_FUNCTION_NAME(TEXT("GetFaxTimeAsString"));

    Res = GetTimeZoneInformation(&LocalTimeZone);
    if (Res == TIME_ZONE_ID_INVALID)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("Failed to get local time zone info (ec: %ld)"),
               GetLastError());
        return FALSE;
    }
    else
    {
        if (!SystemTimeToTzSpecificLocalTime( &LocalTimeZone, UniversalTime, &LocalTime))
        {
            DebugPrintEx(
               DEBUG_ERR,
               TEXT("Failed to convert universal system time to local system time (ec: %ld)"),
               GetLastError());
            return FALSE;
        }
    }
    TCHAR tszTime[100];
    _stprintf(tszTime,
              TEXT("%d/%d/%d %02d:%02d:%02d"),
              LocalTime.wMonth,
              LocalTime.wDay,
              LocalTime.wYear,
              LocalTime.wHour,
              LocalTime.wMinute,
              LocalTime.wSecond);
    wstrTime = tszTime;
    return TRUE;
}   // GetFaxTimeAsString


static
DWORD
CreateLogFile(DWORD dwFileType,LPCWSTR lpcwstrDBPath, LPHANDLE phFile)
/*++

Routine name : CreateLogFile

Routine description:

    According to the selected dwFileType, this function creates an activity log file

Author:

    Caliv Nir (t-nicali), Nov, 2001

Arguments:

    dwFileType      [in]        - the file to create (inbox or outbox)
                                    o ACTIVITY_LOG_INBOX    for inbox
                                    o ACTIVITY_LOG_OUTBOX   for outbox

    lpcwstrDBPath   [in]        - the path to the activity logging folder

    
    phFile          [out]       - handle to the created log file

Return Value:
    
    Win32 Error codes
    

Remarks:
    

--*/
{
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    WCHAR   wszFileName[MAX_PATH] = {0};
    LARGE_INTEGER FileSize= {0};
    DWORD   dwBytesWritten;
    DWORD   dwFilePointer;
    int     Count = 0 ;
    
    DWORD   dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("CreateLogFile"));

    Assert (phFile);
    Assert (lpcwstrDBPath);
    Assert ( (dwFileType==ACTIVITY_LOG_INBOX)  || (dwFileType==ACTIVITY_LOG_OUTBOX) );

    Count = _snwprintf (wszFileName,
                        MAX_PATH -1,
                        TEXT("%s\\%s"),
                        lpcwstrDBPath,
                        ((dwFileType == ACTIVITY_LOG_INBOX) ? ACTIVITY_LOG_INBOX_FILE : ACTIVITY_LOG_OUTBOX_FILE)
                        );
    if (Count < 0)
    {
        //
        // We already checked for max dir path name.
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));
        dwRes = ERROR_BUFFER_OVERFLOW;
        goto exit;

    }

    hFile = SafeCreateFile(  
                         wszFileName,              // file name
                         GENERIC_WRITE,            // access mode
                         FILE_SHARE_READ,          // share mode
                         NULL,                     // SD
                         OPEN_ALWAYS,              // how to create
                         FILE_ATTRIBUTE_NORMAL,    // file attributes
                         NULL);                    
    if (INVALID_HANDLE_VALUE == hFile)
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateFile failed (ec: %ld)"),
                     dwRes);
        goto exit;
    }
    
    
    if (!GetFileSizeEx (hFile, &FileSize))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetFileSizeEx failed (ec: %ld)"),
                     dwRes);
        goto exit;
    }

    if (0 == FileSize.QuadPart)
    {
        //
        // New file was created, add UNICODE header
        //
        USHORT UnicodeHeader = 0xfeff;
        
        if (!WriteFile( hFile,
                        &UnicodeHeader,
                        sizeof(UnicodeHeader),
                        &dwBytesWritten,
                        NULL))
        {
            dwRes = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("WriteFile failed (ec: %ld)"),
                         dwRes);
            goto exit;
        }
        
        
        //
        //  Add the first line (Columns name)
        //
        wstring wstrHeader;
        
        try
        {
            GetTableColumnsText((dwFileType == ACTIVITY_LOG_INBOX) ? INBOX_TABLE : OUTBOX_TABLE, wstrHeader);
        }            
        catch (exception &ex)
        {
            dwRes = ERROR_OUTOFMEMORY;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetTableColumnsText caused exception (%S)"),
                ex.what());
            goto exit;            
        }

        if (!WriteFile( hFile,
                        wstrHeader.c_str(),
                        wstrHeader.length() * sizeof(WCHAR),
                        &dwBytesWritten,
                        NULL))
        {
            dwRes = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("WriteFile failed (ec: %ld)"),
                         dwRes);
            goto exit;
        }
    }
    else
    {
        dwFilePointer = SetFilePointer( hFile,          // handle to file
                                        0,              // bytes to move pointer
                                        NULL,           // bytes to move pointer
                                        FILE_END        // starting point
                                        );
        if (INVALID_SET_FILE_POINTER == dwFilePointer)
        {
            dwRes = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("SetFilePointer failed (ec: %ld)"),
                         dwRes);
            goto exit;
        }
    }

    *phFile = hFile;

    Assert (ERROR_SUCCESS == dwRes);
exit:
    
    if (ERROR_SUCCESS != dwRes)
    {      
        //
        //  The activity logging will halt because we couldn't complete CreateLogFile().
        //
        if (*phFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(*phFile);
            *phFile = INVALID_HANDLE_VALUE;
        }
        
        
        if (dwFileType == ACTIVITY_LOG_INBOX)
        {
            g_ActivityLoggingConfig.bLogIncoming = FALSE;
        }
        else
        {
            g_ActivityLoggingConfig.bLogOutgoing = FALSE;
        }

        
        //
        //  Post an event log entry
        //
        FaxLog(
            FAXLOG_CATEGORY_INIT,
            (dwFileType == ACTIVITY_LOG_INBOX)?FAXLOG_CATEGORY_INBOUND:FAXLOG_CATEGORY_OUTBOUND,
            2,
            MSG_LOGGING_NOT_INITIALIZED,
            g_ActivityLoggingConfig.lptstrDBPath,
            DWORD2DECIMAL(dwRes)
        );

        if (INVALID_HANDLE_VALUE != hFile)
        {
            if (!CloseHandle (hFile))
            {
                DebugPrintEx(DEBUG_ERR,
                     TEXT("CloseHandle failed (ec: %ld)"),
                     GetLastError());
            }
        }
    }
    return dwRes;
}   // CreateLogFile


static
BOOL
LogFileLimitReached(DWORD dwFileToCheck)
/*++

Routine name : LogFileLimitReached

Routine description:

    According to the selected log limit criteria, this function checks to see wheter Activity log file 
    have reached it's limit.

Author:

    Caliv Nir (t-nicali), Nov, 2001

Arguments:

    dwFileToCheck   [in]    - the file to be checked (inbox or outbox)
                                o ACTIVITY_LOG_INBOX    for inbox
                                o ACTIVITY_LOG_OUTBOX   for outbox


Return Value:
    
    TRUE - if the limit have been reached
    

Remarks:
    
    Call this function only if activity logging is enabled for checked the log file !

--*/
{
    BOOL    bActivityLogEnabled = FALSE;
    HANDLE  hLogFile = INVALID_HANDLE_VALUE;

    DEBUG_FUNCTION_NAME(TEXT("LogFileLimitReached"));

    Assert ( (dwFileToCheck==ACTIVITY_LOG_INBOX)  || (dwFileToCheck==ACTIVITY_LOG_OUTBOX) );
    Assert ( g_ActivityLoggingConfig.bLogIncoming || g_ActivityLoggingConfig.bLogOutgoing );


    if ( g_ActivityLoggingConfig.dwLogLimitCriteria == ACTIVITY_LOG_LIMIT_CRITERIA_NONE )
    {
        //
        //  activity logging limiting is disabled so no limit checking is needed
        //
        goto Exit;
    }

    hLogFile = (dwFileToCheck==ACTIVITY_LOG_INBOX)? g_hInboxActivityLogFile : g_hOutboxActivityLogFile;
    
    //
    //  activity logging is enabled so the handle must be valid
    //
    Assert (hLogFile != INVALID_HANDLE_VALUE);

    if ( g_ActivityLoggingConfig.dwLogLimitCriteria == ACTIVITY_LOG_LIMIT_CRITERIA_SIZE )
    {
        //
        //  Checking limit according to file size in Mbytes
        //
        
        
        LARGE_INTEGER FileSize = {0};

        // 
        //  Check the file size
        //
        if( !GetFileSizeEx( hLogFile,&FileSize ) )
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("GetFileSizeEx failed (ec=%ld))"),
                         GetLastError()
                         );
            goto Exit;
        }

        //
        //  Compare it to limit
        //
        if (FileSize.QuadPart >= ( g_ActivityLoggingConfig.dwLogSizeLimit * 1I64 * 1024I64 * 1024I64 )) // dwLogSizeLimit is in Mbytes
        {
            //
            //  File exceeded the given size limit
            //
            return TRUE;
        }
    }
    else
    if ( g_ActivityLoggingConfig.dwLogLimitCriteria == ACTIVITY_LOG_LIMIT_CRITERIA_AGE)
    {
        //
        // Checking limit according to file age in months
        //
        
        FILETIME FileTimeCreationTime;
        
        //
        //  Check file creation time (the creation time is the first time that something was writen into this file)
        //
        if  ( !GetFileTime( hLogFile,               // handle to file
                            &FileTimeCreationTime,  // creation time
                            NULL,                   // last access time
                            NULL                    // last write time
                          )
            )
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("GetFileTime failed (ec=%ld))"),
                         GetLastError()
                         );
            goto Exit;
        }

        SYSTEMTIME SystemTimeCreationTime = {0};
        
        if  ( !FileTimeToSystemTime( &FileTimeCreationTime,     // file time to convert
                                     &SystemTimeCreationTime    // receives system time
                                    )
            )
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("FileTimeToSystemTime failed (ec=%ld))"),
                         GetLastError()
                         );
            goto Exit;
        }

        //
        //  Find out current time
        //
        SYSTEMTIME CurrentTime = {0};
        GetSystemTime(&CurrentTime);
        
        //
        //  Calculate monthe diff between current time and the time of the first write to the log file.
        //
        DWORD dwMonthDiff = (CurrentTime.wYear - SystemTimeCreationTime.wYear) * 12 + CurrentTime.wMonth - SystemTimeCreationTime.wMonth;

        if (dwMonthDiff >= g_ActivityLoggingConfig.dwLogAgeLimit)
        {
            //
            //  the file reached the age limit
            //
            
            return TRUE;
        }

    }
    else
    {
        //
        //  Bad parameter in g_ActivityLoggingConfig.dwLogLimitCriteria
        //
        ASSERT_FALSE;
    }


Exit:
    return FALSE;
}   // LogFileLimitReached


static
DWORD
LogFileLimitReachAction(DWORD dwFileType)
/*++

Routine name : LogFileLimitReachAction

Routine description:

    According to the selected log limit reached action criteria, take the action.

Author:

    Caliv Nir (t-nicali), Nov, 2001

Arguments:

    dwFileType          [in]    - the file to handle (inbox or outbox)
                                    o ACTIVITY_LOG_INBOX    for inbox
                                    o ACTIVITY_LOG_OUTBOX   for outbox

Return Value:
    
      TRUE - if the limit have been reached
    

Remarks:

    Call this function only if activity logging is enabled *and* Limiting the activity files is enabled
    

--*/

{
    HANDLE  hLogFile = INVALID_HANDLE_VALUE;
    DWORD   dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("LogFileLimitReachAction"));

    //
    //  Parameter check (Private function)
    //
    Assert ( (dwFileType==ACTIVITY_LOG_INBOX)  || (dwFileType==ACTIVITY_LOG_OUTBOX) );
    Assert ( (dwFileType==ACTIVITY_LOG_INBOX  && g_ActivityLoggingConfig.bLogIncoming) || 
             (dwFileType==ACTIVITY_LOG_OUTBOX && g_ActivityLoggingConfig.bLogOutgoing)  );

    Assert ( g_ActivityLoggingConfig.dwLogLimitCriteria != ACTIVITY_LOG_LIMIT_CRITERIA_NONE );

    hLogFile = (dwFileType==ACTIVITY_LOG_INBOX)? g_hInboxActivityLogFile : g_hOutboxActivityLogFile;

    if (g_ActivityLoggingConfig.dwLimitReachedAction == ACTIVITY_LOG_LIMIT_REACHED_ACTION_DELETE)
    {
        //
        //  Delete the log file
        //
        dwRes = DeleteLogActivityFile(dwFileType);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("DeleteLogActivityFile failed (ec: %ld)"),
                         dwRes);
            goto exit;
        }

    }
    else
    if (g_ActivityLoggingConfig.dwLimitReachedAction == ACTIVITY_LOG_LIMIT_REACHED_ACTION_COPY)
    {
        //
        //  Replace the log file with a fresh copy
        //
        dwRes = ReplaceLogActivityFile(dwFileType);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("DeleteLogActivityFile failed (ec: %ld)"),
                         dwRes);
            goto exit;
        }

    }
    else
    {
        //
        //  Bad parameter in g_ActivityLoggingConfig.dwLimitReachedAction
        //
        ASSERT_FALSE;
    }

    Assert(ERROR_SUCCESS == dwRes);
exit:
    return dwRes;
}   // LogFileLimitReachAction



static
DWORD
DeleteLogActivityFile(DWORD dwFileType)
/*++

Routine name : DeleteLogActivityFile

Routine description:

    According to dwFileType delete the proper activity log file and create a new one

Author:

    Caliv Nir (t-nicali), Nov, 2001

Arguments:

    dwFileType          [in]    - the file to Delete (inbox or outbox)
                                    o ACTIVITY_LOG_INBOX    for inbox
                                    o ACTIVITY_LOG_OUTBOX   for outbox

Return Value:
    
      TRUE - if the limit have been reached
    

Remarks:

    Call this function only if activity logging is enabled *and* Limiting the activity files is enabled
    

--*/
{
    LPWSTR strFullFileName = NULL;
    LPHANDLE phFile=NULL;

    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("DeleteLogActivityFile"));

    Assert ( (dwFileType==ACTIVITY_LOG_INBOX)  || (dwFileType==ACTIVITY_LOG_OUTBOX) );
    Assert ( g_ActivityLoggingConfig.dwLimitReachedAction == ACTIVITY_LOG_LIMIT_REACHED_ACTION_DELETE );
    Assert ( (dwFileType==ACTIVITY_LOG_INBOX  && g_ActivityLoggingConfig.bLogIncoming) || 
             (dwFileType==ACTIVITY_LOG_OUTBOX && g_ActivityLoggingConfig.bLogOutgoing)  );
    Assert ( g_ActivityLoggingConfig.lptstrDBPath );
    

    strFullFileName = BuildFullFileName(g_ActivityLoggingConfig.lptstrDBPath, ((dwFileType == ACTIVITY_LOG_INBOX)? ACTIVITY_LOG_INBOX_FILE : ACTIVITY_LOG_OUTBOX_FILE) );
    if (NULL == strFullFileName)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("BuildFullFileName() failed.")
                    );
        goto exit;
    }

    phFile = (dwFileType == ACTIVITY_LOG_INBOX) ? &g_hInboxActivityLogFile : &g_hOutboxActivityLogFile ;
    
    Assert(*phFile);
    
    if (!CloseHandle(*phFile))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CloseHandle failed (ec=%ld)."),
                     dwRes
                    );
        goto exit;
    }

    *phFile = INVALID_HANDLE_VALUE;

    if (!DeleteFile(strFullFileName))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("DeleteFile failed (ec=%ld)."),
                     dwRes
                    );
        //
        //  Try to roll back and use the old file
        //
    }

    //
    // Create new logging file
    //
    dwRes = CreateLogFile(dwFileType,g_ActivityLoggingConfig.lptstrDBPath,phFile);
    if ( ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("CreateLogFile() Failed. (ec=%ld)"),
                        dwRes
                    );
        goto exit;
    }

    
    //
    //  Because the creation time of the file is important for log limit 
    //  mechanism, we make sure to update the file creation time that may
    //  not be updated (Due to file system caching mechanism for example) 
    //

    if (!SetFileToCurrentTime(*phFile))
    {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("SetFileToCurrentTime() Failed. (ec=%ld)"),
                        dwRes
                    );
    }

    DebugPrintEx(   DEBUG_MSG,
                    TEXT("Activity log file was deleted and replaced with fresh copy.")
                );

    Assert(ERROR_SUCCESS == dwRes);
exit:


    MemFree(strFullFileName);
    return dwRes;
} // DeleteLogActivityFile



static
DWORD
ReplaceLogActivityFile(DWORD dwFileType)
/*++

Routine name : ReplaceLogActivityFile

Routine description:

    According to dwFileType copy the proper activity log file and create a new one

Author:

    Caliv Nir (t-nicali), Nov, 2001

Arguments:

    dwFileType          [in]    - the file to Replace (inbox or outbox)
                                    o ACTIVITY_LOG_INBOX    for inbox
                                    o ACTIVITY_LOG_OUTBOX   for outbox

Return Value:
       
    Win32 error code

Remarks:

    Call this function only if activity logging is enabled *and* Limiting the activity files is enabled
    

--*/
{
    SYSTEMTIME  LogStartTime = {0};
    SYSTEMTIME  LogEndTime = {0};

    FILETIME    FirstWriteTime = {0};
    FILETIME    LastWriteTime= {0};

    LPWSTR strOldFileName = NULL;
    WCHAR  strNewFileName[MAX_PATH] = {0};
    LPWSTR strNameTemplate = NULL;
    LPWSTR strNewFullFileName = NULL;
    
    LPHANDLE phFile=NULL;

    DWORD dwRes = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("ReplaceLogActivityFile"));

    Assert ( (dwFileType==ACTIVITY_LOG_INBOX)  || (dwFileType==ACTIVITY_LOG_OUTBOX) );
    Assert ( g_ActivityLoggingConfig.dwLimitReachedAction == ACTIVITY_LOG_LIMIT_REACHED_ACTION_COPY );
    Assert ( (dwFileType==ACTIVITY_LOG_INBOX  && g_ActivityLoggingConfig.bLogIncoming) || 
             (dwFileType==ACTIVITY_LOG_OUTBOX && g_ActivityLoggingConfig.bLogOutgoing)  );
    Assert ( g_ActivityLoggingConfig.lptstrDBPath );


    phFile = (dwFileType == ACTIVITY_LOG_INBOX) ? &g_hInboxActivityLogFile : &g_hOutboxActivityLogFile;
    
    Assert (INVALID_HANDLE_VALUE != *phFile);

    //
    //  find out the file's first and last write time 
    //
    if (!GetFileTime(   *phFile,              // handle to file
                        &FirstWriteTime,      // creation time
                        NULL,               // last access time
                        &LastWriteTime      // last write time
                    )
        )
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("GetFileTime() failed. (ec=%ld)"),
                     dwRes
                    );
        goto exit;
    }
    

    if (!FileTimeToSystemTime(  &FirstWriteTime,   // file time to convert
                                &LogStartTime    // receives system time
                             )
        )
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("FileTimeToSystemTime() failed. (ec=%ld)"),
                     dwRes
                    );
        goto exit;
    }

    if (!FileTimeToSystemTime(  &LastWriteTime,  // file time to convert
                                &LogEndTime      // receives system time
                             )
        )
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("FileTimeToSystemTime() failed. (ec=%ld)"),
                     dwRes
                    );
        goto exit;
    }

    
    //
    //  build the current log file name
    //
    strOldFileName = BuildFullFileName(g_ActivityLoggingConfig.lptstrDBPath, ((dwFileType == ACTIVITY_LOG_INBOX)? ACTIVITY_LOG_INBOX_FILE : ACTIVITY_LOG_OUTBOX_FILE) );
    if (NULL == strOldFileName)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("BuildFullFileName() failed.")
                    );
        goto exit;
    }

    //
    //  build the copy file name according to the first and last write times
    //
    strNameTemplate = (dwFileType == ACTIVITY_LOG_INBOX) ? ACTIVITY_LOG_INBOX_FILENAME_TEMPLATE : ACTIVITY_LOG_OUTBOX_FILENAME_TEMPLATE;

    _snwprintf (    strNewFileName,
                    ARR_SIZE(strNewFileName)-1,
                    strNameTemplate,                // TEXT("??boxLOG %04d-%02d-%02d through %04d-%02d-%02d.txt")   ?? - is "In" or "Out"
                    LogStartTime.wYear,
                    LogStartTime.wMonth,
                    LogStartTime.wDay,
                    LogEndTime.wYear,
                    LogEndTime.wMonth,
                    LogEndTime.wDay
               );

    

    strNewFullFileName = BuildFullFileName(g_ActivityLoggingConfig.lptstrDBPath,strNewFileName);
    if (NULL == strNewFullFileName)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR,
                     TEXT("BuildFullFileName() failed.")
                    );
        goto exit;
    }


    if ( !CloseHandle(*phFile) )
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CloseHandle() failed. (ec=%ld)"),
                     dwRes
                    );
        goto exit;
    }

    *phFile = INVALID_HANDLE_VALUE;

    if ( !MoveFile (  strOldFileName,                // file name
                      strNewFullFileName             // new file name
                   )
        )
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("MoveFileEx() failed. (ec=%ld)"),
                     dwRes
                    );
        //
        //  Try to roll back and use the old file
        //
    }



    //
    // Create the logging file that was renamed
    //
    dwRes = CreateLogFile(dwFileType,g_ActivityLoggingConfig.lptstrDBPath,phFile);
    if ( ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("CreateLogFile() Failed. (ec=%ld)"),
                        dwRes
                    );
        goto exit;
    }

    //
    //  Because the creation time of the file is important for log limit 
    //  mechanism, we make sure to update the file creation time that may
    //  not be updated (Due to file system caching mechanism for example) 
    //

    if (!SetFileToCurrentTime(*phFile))
    {
        DebugPrintEx(   DEBUG_ERR,
                        TEXT("SetFileToCurrentTime() Failed. (ec=%ld)"),
                        dwRes
                    );
    }

    DebugPrintEx(   DEBUG_MSG,
                    TEXT("Activity log file was copied and replaced with fresh copy.")
                );

    Assert (ERROR_SUCCESS == dwRes);

exit:

    MemFree(strOldFileName);
    MemFree(strNewFullFileName);
    return dwRes;
}   // ReplaceLogActivityFile


static
LPTSTR
BuildFullFileName( LPCWSTR strPath,
                   LPCWSTR strFileName )
/*++

Routine name : BuildFullFileName

Routine description:

    Utility function to concat path and file name.  -> strPath\strFileName

Author:

    Caliv Nir (t-nicali), Nov, 2001

Arguments:

    strPath         [in]    - file path
    strFileName     [in]    - file name

Return Value:
       
    the full file name string

Remarks:

    Caller must MemFree the return string
    This function works for UNICODE and ANSI (not for MBCS)
    

--*/
{
    LPWSTR  strFullFileName = NULL;
    DWORD   dwNewNameLen = 0;

    DEBUG_FUNCTION_NAME(TEXT("BuildFullFileName"));

    Assert (strPath && strFileName);

    dwNewNameLen = wcslen(strPath) + wcslen(strFileName) + 2; // sizeof path\fileName and null terminator

    strFullFileName = (LPTSTR)MemAlloc(dwNewNameLen * sizeof(TCHAR));
    if (NULL == strFullFileName)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("MemAlloc failed.")
                    );
        goto exit;
    }

    strFullFileName[dwNewNameLen-1] = TEXT('\0');

    //
    //  Build the full file name
    //
    _snwprintf (strFullFileName,
                dwNewNameLen-1,
                TEXT("%s\\%s"),
                strPath,
                strFileName);

exit:
    return strFullFileName;
    
} // BuildFullFileName


static
BOOL 
SetFileToCurrentTime(HANDLE hFile)
/*++

Routine name : SetFileToCurrentTime

Routine description:

    Utility function set the creation time of file into current time

Author:

    Caliv Nir (t-nicali), Nov, 2001

Arguments:

    hFile         [in]    - file handle

Return Value:
       
    TRUE if successful, FALSE otherwise

Remarks:
    
    hFile  - must be a valid file handle

--*/
{
    FILETIME    ft={0};
    SYSTEMTIME  st={0};
    BOOL        bRet = TRUE;
    DWORD       dwRes;
    DEBUG_FUNCTION_NAME(TEXT("SetFileToCurrentTime"));
    
    Assert (INVALID_HANDLE_VALUE != hFile);
    //
    //  Because the creation time of the file is important for log limit 
    //  mechanism, we make sure to update the file creation time that may
    //  not be updated (Due to file system caching mechanism for example) 
    //
        

    GetSystemTime(&st);                     // gets current time


    bRet = SystemTimeToFileTime(&st, &ft);
    if (FALSE == bRet)    // converts to file time format
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("SystemTimeToFileTime failed (ec: %ld)"),
                     dwRes);
        goto exit;
    }

    bRet = SetFileTime( hFile,               // sets creation time for file
                        &ft, 
                        (LPFILETIME) NULL, 
                        (LPFILETIME) NULL);
    if (FALSE == bRet)
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("SetFileTime failed (ec: %ld)"),
                     dwRes);
        goto exit;
    }

    Assert (TRUE == bRet);
exit:
    return bRet;
}   // SetFileToCurrentTime
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\faxsvc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsvc.c

Abstract:

    This module contains the service specific code.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop

#include <ExpDef.h>
#include <ErrorRep.h>

class CComBSTR;


#define SERVICE_DEBUG_LOG_FILE  _T("FXSSVCDebugLogFile.txt")


static SERVICE_STATUS                       gs_FaxServiceStatus;
static SERVICE_STATUS_HANDLE                gs_FaxServiceStatusHandle;

static LPCWSTR                              gs_lpcwstrUnhandledExceptionSourceName; // Points to the friendly name of the last 
                                                                                    // FSP / R.Ext which caused an unhandled 
                                                                                    // exception in a direct function call.
                                                                                    // Used for event logging 
                                                                                    // in FaxUnhandledExceptionFilter().
                                                                                    
static EXCEPTION_SOURCE_TYPE                gs_UnhandledExceptionSource;            // Specifies the source of an unhandled 
                                                                                    // exception.
                                                                                    // Used for event logging 
                                                                                    // in FaxUnhandledExceptionFilter().

static DWORD                                gs_dwUnhandledExceptionCode;            // Holds the exception code of the last
                                                                                    // unhandled exception in a direct function call
                                                                                    // to an FSP / R.Ext
                                                                                    // Used for event logging 
                                                                                    // in FaxUnhandledExceptionFilter().

static BOOL                                 gs_bUseDefaultFaultHandlingPolicy;      // Read from the registry during service
                                                                                    // startup. If non-zero, FaxUnhandledExceptionFilter
                                                                                    // behaves as if it did not exist.

HANDLE                  g_hServiceShutDownEvent;    // This event is set after the service got g_hSCMServiceShutDownEvent from SCM and signals the various threads to terminate!
HANDLE                  g_hSCMServiceShutDownEvent; // This event is set when SCM tells the service to STOP!
HANDLE                  g_hServiceIsDownSemaphore;  // This semaphore is used to synchronize TapiWorkerThread() JobQueueThread() and EndFaxSvc()

SERVICE_TABLE_ENTRY   ServiceDispatchTable[] = {
    { FAX_SERVICE_NAME,   FaxServiceMain    },
    { NULL,               NULL              }
};


static
BOOL
InitializeFaxLibrariesGlobals(
    VOID
    )
/*++

Routine Description:

    Initialize Fax libraries globals.
    Becuase the process is not always terminated when the service is stopped,
    We must not have any staticly initialized global variables.
    Initialize all fax libraries global variables before starting the service

Arguments:

    None.

Return Value:

    BOOL

--*/
{
    BOOL bRet = TRUE;
    DEBUG_FUNCTION_NAME(TEXT("InitializeFaxLibraries"));


    if (!FXSEVENTInitialize())
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("FXSEVENTInitialize failed"));
        bRet = FALSE;
    }

    if (!FXSTIFFInitialize())
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("FXSTIFFInitialize failed"));
        bRet = FALSE;
    }
    return bRet;
}


static
VOID
FreeFaxLibrariesGlobals(
    VOID
    )
/*++

Routine Description:

    Frees Fax libraries globals.

Arguments:

    None.

Return Value:

    BOOL

--*/
{    
    FXSEVENTFree();
	HeapCleanup();
    return;
}



static
BOOL
InitializeServiceGlobals(
    VOID
    )
/*++

Routine Description:

    Initialize service globals.
    Becuase the process is not always terminated when the service is stopped,
    We must not have any staticly initialized global variables.
    Initialize all service global variables before starting the service

Arguments:

    None.

Return Value:

    BOOL

--*/
{
    DWORD Index;
    DWORD ec = ERROR_SUCCESS;

    DEBUG_FUNCTION_NAME(TEXT("InitializeServiceGlobals"));

    //
    // Initialize static allocated globals
    //

    g_pFaxPerfCounters = NULL;
#ifdef DBG
    g_hCritSecLogFile = INVALID_HANDLE_VALUE;
#endif

    gs_lpcwstrUnhandledExceptionSourceName = NULL;
    gs_UnhandledExceptionSource = EXCEPTION_SOURCE_UNKNOWN;
    gs_dwUnhandledExceptionCode = 0;
    gs_bUseDefaultFaultHandlingPolicy = FALSE;

    ZeroMemory (&g_ReceiptsConfig, sizeof(g_ReceiptsConfig)); // Global receipts configuration
    g_ReceiptsConfig.dwSizeOfStruct = sizeof(g_ReceiptsConfig);

    ZeroMemory (g_ArchivesConfig, sizeof(g_ArchivesConfig));  // Global archives configuration
    g_ArchivesConfig[0].dwSizeOfStruct = sizeof(g_ArchivesConfig[0]);
    g_ArchivesConfig[1].dwSizeOfStruct = sizeof(g_ArchivesConfig[1]);

    ZeroMemory (&g_ActivityLoggingConfig, sizeof(g_ActivityLoggingConfig)); // Global activity logging configuration
    g_ActivityLoggingConfig.dwSizeOfStruct = sizeof(g_ActivityLoggingConfig);

    ZeroMemory (&g_ServerActivity, sizeof(g_ServerActivity)); // Global Fax Service Activity
    g_ServerActivity.dwSizeOfStruct = sizeof(FAX_SERVER_ACTIVITY);

    ZeroMemory (g_wszFaxQueueDir, sizeof(g_wszFaxQueueDir));

    g_hDispatchEventsCompPort = NULL;   // Dispatch Events completion port
    g_hSendEventsCompPort = NULL;       // Send Events completion port = NULL;   // Events completion port
    g_dwlClientID = 0;          // Client ID

    ZeroMemory (g_FaxQuotaWarn, sizeof(g_FaxQuotaWarn));
    g_hArchiveQuotaWarningEvent = NULL;

    g_dwConnectionCount = 0;    // Represents the number of active rpc connections.

    g_hInboxActivityLogFile = INVALID_HANDLE_VALUE;
    g_hOutboxActivityLogFile = INVALID_HANDLE_VALUE;
    g_fLogStringTableInit = FALSE; // activity logging string table

    g_dwQueueCount = 0; // Count of jobs (both parent and non-parent) in the queue. Protected by g_CsQueue
    g_hJobQueueEvent = NULL;
    g_dwQueueState = 0;
    g_ScanQueueAfterTimeout = FALSE;    // The JobQueueThread checks this if waked up after JOB_QUEUE_TIMEOUT.
                                        // If it is TRUE - g_hQueueTimer or g_hJobQueueEvent were not set - Scan the queue.
    g_dwReceiveDevicesCount = 0;        // Count of devices that are receive-enabled. Protected by g_CsLine.

    g_bDelaySuicideAttempt = FALSE;     // If TRUE, the service waits 
                                        // before checking if it can commit suicide.
                                        // Initially FALSE, can be set to true if the service is launched
                                        // with SERVICE_DELAY_SUICIDE command line parameter.
    g_bServiceCanSuicide = TRUE;

    g_dwCountRoutingMethods = 0;

    g_pLineCountryList = NULL;

    g_dwLastUniqueId = 0;

    g_bServiceIsDown = FALSE;             // This is set to TRUE by FaxEndSvc()

    g_TapiCompletionPort = NULL;
    g_hLineApp = NULL;
    g_pAdaptiveFileBuffer = NULL;

    gs_FaxServiceStatus.dwServiceType        = SERVICE_WIN32;
    gs_FaxServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
    gs_FaxServiceStatus.dwWin32ExitCode      = 0;
    gs_FaxServiceStatus.dwServiceSpecificExitCode = 0;
    gs_FaxServiceStatus.dwCheckPoint         = 0;
    gs_FaxServiceStatus.dwWaitHint           = 0;

    g_hRPCListeningThread = NULL;

    g_lServiceThreadsCount = 0;
    g_hThreadCountEvent = NULL;

	g_dwAllowRemote = 0; // By default, do not allow remote calls if the printer is not shared.

    for (Index = 0; Index < gc_dwCountInboxTable; Index++)
    {
        g_InboxTable[Index].String = NULL;
    }

    for (Index = 0; Index < gc_dwCountOutboxTable; Index++)
    {
        g_OutboxTable[Index].String = NULL;
    }

    for (Index = 0; Index < gc_dwCountServiceStringTable; Index++)
    {
        g_ServiceStringTable[Index].String = NULL;
    }

    g_StatusCompletionPortHandle = NULL;

    g_pFaxSD = NULL;

    g_dwDeviceCount = 0;
    g_dwDeviceEnabledCount = 0;
    g_dwDeviceEnabledLimit = GetDeviceLimit();

    g_hFaxPerfCountersMap = 0;


    g_hTapiWorkerThread = NULL;
    g_hJobQueueThread = NULL;

	g_dwRecipientsLimit = 0;

	g_hResource = GetResInstance(NULL);
    if(!g_hResource)
    {
        ec = GetLastError();
        goto Error;
    }

    //
    // Create an event to signal service shutdown from service to various threads
    //
    g_hServiceShutDownEvent = CreateEvent(
        NULL,   // SD
        TRUE,   // reset type - Manual
        FALSE,  // initial state - Not signaled. The event is signaled when the service gets g_hSCMServiceShutDownEvent
        NULL    // object name
        );
    if (NULL == g_hServiceShutDownEvent)
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateEvent (g_hServiceShutDownEvent) failed (ec: %ld)"),
                     ec);
        goto Error;
    }

    //
    // Create an event used by SCM to signal service shutdown 
    //
    g_hSCMServiceShutDownEvent = CreateEvent(
        NULL,   // SD
        TRUE,   // reset type - Manual
        FALSE,  // initial state - Not signaled. The event is signaled when the service gets SERVICE_CONTROL_STOP or SERVICE_CONTROL_SHUTDOWN.
        NULL    // object name
        );
    if (NULL == g_hSCMServiceShutDownEvent)
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateEvent (g_hSCMServiceShutDownEvent) failed (ec: %ld)"),
                     ec);
        goto Error;
    }

    //
    // Create a semaphore to syncronize TapiWorkerThread() JobQueueThread() and EndFaxSvc()
    //
    g_hServiceIsDownSemaphore =  CreateSemaphore(
        NULL,                       // SD
        0,                          // initial count - Not signaled
        2,                          // maximum count - JobQueueThread and TapiWorkerThread
        NULL                        // object name
        );
    if (NULL == g_hServiceIsDownSemaphore)
    {
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("CreateSemaphore (g_hServiceIsDownSemaphore) failed (ec: %ld)"),
                     ec);
        goto Error;
    }

    //
    // Try to init some global critical sections
    //
#ifdef DBG
        if (!g_CsCritSecList.Initialize())
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CFaxCriticalSection::Initialize failed: err = %d"),
                ec);
            goto Error;
        }
#endif

    if (!g_CsConfig.Initialize() ||
        !g_CsInboundActivityLogging.Initialize() ||
        !g_CsOutboundActivityLogging.Initialize() ||
        !g_CsJob.Initialize() ||
        !g_CsQueue.Initialize() ||
        !g_CsPerfCounters.Initialize() ||
        !g_CsSecurity.Initialize() ||
        !g_csUniqueQueueFile.Initialize() ||
        !g_CsLine.Initialize() ||
        !g_CsRouting.Initialize() ||
        !g_CsServiceThreads.Initialize() ||
        !g_CsHandleTable.Initialize() ||        
        !g_CsActivity.Initialize() ||
        !g_CsClients.Initialize())
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CFaxCriticalSection::Initialize failed: err = %d"),
            ec);
        goto Error;
    }


    //
    // Initialize service linked lists
    //
    InitializeListHead( &g_DeviceProvidersListHead );
    InitializeListHead( &g_HandleTableListHead );
    InitializeListHead( &g_JobListHead );
    InitializeListHead( &g_QueueListHead );
    InitializeListHead( &g_QueueListHead);
    InitializeListHead( &g_lstRoutingExtensions );
    InitializeListHead( &g_lstRoutingMethods );
#if DBG
    InitializeListHead( &g_CritSecListHead );
#endif
    InitializeListHead( &g_TapiLinesListHead );
    InitializeListHead( &g_RemovedTapiLinesListHead );

    //
    // Initialize dynamic allocated global classes
    //
    g_pClientsMap = NULL;
    g_pNotificationMap = NULL;
    g_pTAPIDevicesIdsMap = NULL;
    g_pGroupsMap = NULL;
    g_pRulesMap = NULL;

    g_pClientsMap = new (std::nothrow) CClientsMap;
    if (NULL == g_pClientsMap)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    g_pNotificationMap = new (std::nothrow) CNotificationMap;
    if (NULL == g_pNotificationMap)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    g_pTAPIDevicesIdsMap = new (std::nothrow) CMapDeviceId;
    if (NULL == g_pTAPIDevicesIdsMap)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;
    }

    g_pGroupsMap = new (std::nothrow) COutboundRoutingGroupsMap;
    if (NULL == g_pGroupsMap)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;

    }

    g_pRulesMap = new (std::nothrow) COutboundRulesMap;
    if (NULL == g_pRulesMap)
    {
        ec = ERROR_NOT_ENOUGH_MEMORY;
        goto Error;

    }


    return TRUE;

Error:

    Assert(ec != ERROR_SUCCESS);

    SetLastError (ec);
    return FALSE;
}

LONG
HandleFaxExtensionFault (
    EXCEPTION_SOURCE_TYPE ExSrc,
    LPCWSTR               lpcswstrExtFriendlyName,
    DWORD                 dwCode
)
/*++

Routine Description:

    This function handles all exceptions thrown as a result from direct calls into fax extensions (FSPs and routing extensions).
    All it does is store the friendly name of the FSP/R.Ext and the exception code and re-throws the exception.
    It should be used as an exception filter in the __except keyword.
    
    The FaxUnhandledExceptionFilter() function uses that store information to log an event message.

Arguments:

    ExSrc                   - [in] The source of the exception (FSP / R.Ext)
    lpcswstrExtFriendlyName - [in] Extension friendly name
    dwCode                  - [in] Exception code

Return Value:

    Exception handling code

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("HandleFaxExtensionFault"));
    Assert (lpcswstrExtFriendlyName);
    Assert (ExSrc > EXCEPTION_SOURCE_UNKNOWN);
    Assert (ExSrc <= EXCEPTION_SOURCE_ROUTING_EXT);
    
    gs_lpcwstrUnhandledExceptionSourceName = lpcswstrExtFriendlyName;
    gs_UnhandledExceptionSource = ExSrc;
    gs_dwUnhandledExceptionCode = dwCode;
    return EXCEPTION_CONTINUE_SEARCH;
} // HandleFaxExtensionFault   

LONG FaxUnhandledExceptionFilter(
  _EXCEPTION_POINTERS *pExceptionInfo 
)
/*++

Routine Description:

    This function serves as the catch-all exception handler for the entire process.
    When an unhandled exception is thrown, this function will be called and:
    1. Increase unhandled exceptions count
    2. For first unhandled exception only
        2.1. Generate a Dr. Watson report
        2.2. Write an event log entry
        2.3. Attempt to shut down all FSPs
        
    3. Terminate the process        


Arguments:

    pExceptionInfo   - Pointer to exception information

Return Value:

    Exception handling code
    
Remarks:
    
    This function gets called by kernel32!UnhandledExceptionFilterEx.
        
    kernel32!UnhandledExceptionFilterEx doesn't call this function if a debugger is attached 
    while a unhandled exception occurs. Instead, it returns EXCEPTION_CONTINUE_SEARCH which let's
    the debugger handle the 2nd chance exception.
    
    If this function returns EXCEPTION_EXECUTE_HANDLER, kernel32!UnhandledExceptionFilterEx does nothing and 
    kernel32!BaseThreadStart calls kernel32!ExitProcess.
    This basically means:
        - No GP fault UI
        - No Dr. Watson report (direct or queued)
        - No support for AeDebug in the registry for attaching a debugger to a crashing process
        
    if this function EXCEPTION_CONTINUE_SEARCH, kernel32!UnhandledExceptionFilterEx acts normally.
    This basically means:
        - GP fault UI (which might be disabled by calling SetErrorMode(), which we never do)
        - A Dr. Watson report is generated
        - AeDebug support is enabled
        - If none of the above is used, kernel32!BaseThreadStart calls kernel32!ExitProcess

--*/
{
    static volatile long lFaultCount = 0;
    DEBUG_FUNCTION_NAME(TEXT("FaxUnhandledExceptionFilter"));
    
    DebugPrintEx (
                DEBUG_MSG,
                TEXT("Unhandled exception from %s (code %d)."),
                gs_lpcwstrUnhandledExceptionSourceName,
                gs_dwUnhandledExceptionCode);    

    if (STATUS_BREAKPOINT == pExceptionInfo->ExceptionRecord->ExceptionCode)
    {
        //
        // Debug break exception caught here.
        // Make sure the user sees the normal system behavior.
        //
        DebugPrintEx (DEBUG_MSG, TEXT("Debug break exception caught."));
        return EXCEPTION_CONTINUE_SEARCH;
    } 
        
    if (1 == InterlockedIncrement (&lFaultCount))
    {
        if (gs_bUseDefaultFaultHandlingPolicy)
        {
            //
            // User chose (in the registry) to disable the SCM revival feature by using the 
            // system's default fault handling policy.
            //
            DebugPrintEx (DEBUG_MSG, TEXT("UseDefaultFaultHandlingPolicy is set. Exception is ignored to be handled by the system."));
            return EXCEPTION_CONTINUE_SEARCH;
        }            
        // First unhandled exception caught here.
        // Try to nicely shutdown the FSPs.
        // Start by generating a Dr. Watson report.
        //
        EFaultRepRetVal ret = ReportFault (pExceptionInfo, 0);
        if (frrvOk         != ret       &&
            frrvOkHeadless != ret       &&
            frrvOkQueued   != ret       &&
            frrvOkManifest != ret)
        {
            //
            // Error generating a Dr. Watson report
            //
            DebugPrintEx (
                DEBUG_MSG,
                TEXT("ReportFault failed with %ld."),
                ret);
        }                        
        //
        // Log a fault event entry
        //
        switch (gs_UnhandledExceptionSource)
        {
            case EXCEPTION_SOURCE_UNKNOWN:
                FaxLog(FAXLOG_CATEGORY_UNKNOWN,
                       FAXLOG_LEVEL_MIN,
                       1,
                       MSG_FAX_GENERAL_FAULT,
                       DWORD2HEX(gs_dwUnhandledExceptionCode)
                      );            
                break;
            case EXCEPTION_SOURCE_FSP:
                FaxLog(FAXLOG_CATEGORY_UNKNOWN,
                       FAXLOG_LEVEL_MIN,
                       2,
                       MSG_FAX_FSP_GENERAL_FAULT,
                       gs_lpcwstrUnhandledExceptionSourceName,
                       DWORD2HEX(gs_dwUnhandledExceptionCode)
                      );   
                      break;         
            case EXCEPTION_SOURCE_ROUTING_EXT:
                FaxLog(FAXLOG_CATEGORY_UNKNOWN,
                       FAXLOG_LEVEL_MIN,
                       2,
                       MSG_FAX_ROUTING_EXT_GENERAL_FAULT,
                       gs_lpcwstrUnhandledExceptionSourceName,
                       DWORD2HEX(gs_dwUnhandledExceptionCode)
                      );   
                      break;         
            default:
                ASSERT_FALSE;
                break;
        }
        //
        // Attempt to gracefully stop the FSPs.
        // This is crucial for releasing the H/W to the correct state before our process gets killed.
        //
        StopAllInProgressJobs();
        StopFaxServiceProviders();
        //
        // Ask kernel32!BaseThreadStart to call kernel32!ExitProcess
        //
        return EXCEPTION_EXECUTE_HANDLER;
    }
    else
    {
        //
        // Fault caught while shutting down.
        // 
        DebugPrintEx (
            DEBUG_MSG,
            TEXT("Unhandled exception number %d from %s (code %d) ignored."),
            lFaultCount,
            gs_lpcwstrUnhandledExceptionSourceName,
            gs_dwUnhandledExceptionCode);
        //
        // Ask kernel32!BaseThreadStart to call kernel32!ExitProcess
        //
        return EXCEPTION_EXECUTE_HANDLER;
    }
}   // FaxUnhandledExceptionFilter


#ifdef __cplusplus
extern "C"
#endif
int
WINAPI
#ifdef UNICODE
wWinMain(
#else
WinMain(
#endif
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR    lpCmdLine,
    int       nShowCmd
    );


int
WINAPI
#ifdef UNICODE
wWinMain(
#else
WinMain(
#endif
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPTSTR    lpCmdLine,
    int       nShowCmd
    )

/*++

Routine Description:

    Main entry point for the TIFF image viewer.


Arguments:

    hInstance       - Instance handle
    hPrevInstance   - Not used
    lpCmdLine       - Command line arguments
    nShowCmd        - How to show the window

Return Value:

    Return code, zero for success.

--*/

{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("WinMain"));

    OPEN_DEBUG_FILE (SERVICE_DEBUG_LOG_FILE);

    if (!StartServiceCtrlDispatcher( ServiceDispatchTable))
    {
        ec = GetLastError();
        DebugPrintEx (
            DEBUG_ERR,
            TEXT("StartServiceCtrlDispatcher error =%d"),
            ec);
    }

    CLOSE_DEBUG_FILE;
    return ec;
}


static
VOID
FreeServiceGlobals (
    VOID
    )
{
    DWORD Index;
    DEBUG_FUNCTION_NAME(TEXT("FreeServiceGlobals"));

    //
    // Delete all global critical sections
    //
    g_CsHandleTable.SafeDelete();    
#ifdef DBG
    g_CsCritSecList.SafeDelete();
#endif
    g_CsConfig.SafeDelete();
    g_CsInboundActivityLogging.SafeDelete();
    g_CsOutboundActivityLogging.SafeDelete();
    g_CsJob.SafeDelete();
    g_CsQueue.SafeDelete();
    g_CsPerfCounters.SafeDelete();
    g_CsSecurity.SafeDelete();
    g_csUniqueQueueFile.SafeDelete();
    g_CsLine.SafeDelete();
    g_CsRouting.SafeDelete();
    g_CsActivity.SafeDelete();
    g_CsClients.SafeDelete();
    g_CsServiceThreads.SafeDelete();

    if (g_pClientsMap)
    {
        delete g_pClientsMap;
        g_pClientsMap = NULL;
    }

    if (g_pNotificationMap)
    {
        delete g_pNotificationMap;
        g_pNotificationMap = NULL;
    }

    if (g_pTAPIDevicesIdsMap)
    {
        delete g_pTAPIDevicesIdsMap;
        g_pTAPIDevicesIdsMap = NULL;
    }

    if (g_pGroupsMap)
    {
        delete g_pGroupsMap;
        g_pGroupsMap = NULL;
    }

    if (g_pRulesMap)
    {
        delete g_pRulesMap;
        g_pRulesMap = NULL;
    }

    //
    // Close global Handles and free globaly allocated memory
    //
    if (NULL != g_pFaxSD)
    {
        if (!DestroyPrivateObjectSecurity (&g_pFaxSD))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DestroyPrivateObjectSecurity() failed. (ec: %ld)"),
                GetLastError());
        }
        g_pFaxSD = NULL;
    }

    if (INVALID_HANDLE_VALUE != g_hOutboxActivityLogFile)
    {
        if (!CloseHandle (g_hOutboxActivityLogFile))
        {
            DebugPrintEx(DEBUG_ERR,
                 TEXT("CloseHandle failed (ec: %ld)"),
                 GetLastError());
        }
        g_hOutboxActivityLogFile = INVALID_HANDLE_VALUE;
    }

    if (INVALID_HANDLE_VALUE != g_hInboxActivityLogFile)
    {
        if (!CloseHandle (g_hInboxActivityLogFile))
        {
            DebugPrintEx(DEBUG_ERR,
                 TEXT("CloseHandle failed (ec: %ld)"),
                 GetLastError());
        }
        g_hInboxActivityLogFile = INVALID_HANDLE_VALUE;
    }


#if DBG
    if (INVALID_HANDLE_VALUE != g_hCritSecLogFile)
    {
        CloseHandle(g_hCritSecLogFile);
        g_hCritSecLogFile = INVALID_HANDLE_VALUE;
    }
#endif

    if (NULL != g_hSendEventsCompPort)
    {
        if (!CloseHandle (g_hSendEventsCompPort))
        {
            DebugPrintEx(DEBUG_ERR,
                 TEXT("CloseHandle failed (ec: %ld)"),
                 GetLastError());
        }
        g_hSendEventsCompPort = NULL;
    }

    if (NULL != g_hDispatchEventsCompPort)
    {
        if (!CloseHandle (g_hDispatchEventsCompPort))
        {
            DebugPrintEx(DEBUG_ERR,
                 TEXT("CloseHandle failed (ec: %ld)"),
                 GetLastError());
        }
        g_hDispatchEventsCompPort = NULL;
    }

    if (NULL != g_hArchiveQuotaWarningEvent)
    {
        if (!CloseHandle(g_hArchiveQuotaWarningEvent))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to close archive config event handle - quota warnings [handle = %p] (ec=0x%08x)."),
                g_hArchiveQuotaWarningEvent,
                GetLastError());
        }
        g_hArchiveQuotaWarningEvent = NULL;
    }

    for (Index = 0; Index < gc_dwCountInboxTable; Index++)
    {
        MemFree(g_InboxTable[Index].String);
        g_InboxTable[Index].String = NULL;
    }

    for (Index = 0; Index < gc_dwCountOutboxTable; Index++)
    {
        MemFree(g_OutboxTable[Index].String);
        g_OutboxTable[Index].String = NULL;
    }

    for (Index = 0; Index < gc_dwCountServiceStringTable; Index++)
    {
        MemFree(g_ServiceStringTable[Index].String);
        g_ServiceStringTable[Index].String = NULL;
    }

    if (NULL != g_StatusCompletionPortHandle)
    {
        if (!CloseHandle(g_StatusCompletionPortHandle))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle Failed (ec: %ld"),
                GetLastError());
        }
        g_StatusCompletionPortHandle = NULL;
    }

    if (NULL != g_pFaxPerfCounters)
    {
        if (!UnmapViewOfFile(g_pFaxPerfCounters))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("UnmapViewOfFile Failed (ec: %ld"),
                GetLastError());
        }
        g_pFaxPerfCounters = NULL;
    }

    if (NULL != g_hFaxPerfCountersMap)
    {
        if (!CloseHandle(g_hFaxPerfCountersMap))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle Failed (ec: %ld"),
                GetLastError());
        }
        g_hFaxPerfCountersMap = NULL;
    }

    if (NULL != g_hLineApp)
    {
        LONG Rslt = lineShutdown(g_hLineApp);
        if (Rslt)
        {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("lineShutdown() failed (ec: %ld)"),
            Rslt);
        }
        g_hLineApp = NULL;
    }

    if (NULL != g_hThreadCountEvent)
    {
        if (!CloseHandle(g_hThreadCountEvent))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle for g_hThreadCountEvent Failed (ec: %ld"),
                GetLastError());
        }
        g_hThreadCountEvent = NULL;
    }

    if (NULL != g_hServiceShutDownEvent)
    {
        if (!CloseHandle(g_hServiceShutDownEvent))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle for g_hServiceShutDownEvent Failed (ec: %ld"),
                GetLastError());
        }
        g_hServiceShutDownEvent = NULL;
    }

    if (NULL != g_hSCMServiceShutDownEvent)
    {
        if (!CloseHandle(g_hSCMServiceShutDownEvent))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle for g_hSCMServiceShutDownEvent Failed (ec: %ld"),
                GetLastError());
        }
        g_hSCMServiceShutDownEvent = NULL;
    }

    if (NULL != g_hServiceIsDownSemaphore)
    {
        if (!CloseHandle(g_hServiceIsDownSemaphore))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle for g_hServiceIsDownSemaphore Failed (ec: %ld"),
                GetLastError());
        }
        g_hServiceIsDownSemaphore = NULL;
    }   

    if (NULL != g_hTapiWorkerThread)
    {
        if (!CloseHandle(g_hTapiWorkerThread))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle for g_hTapiWorkerThread Failed (ec: %ld"),
                GetLastError());
        }
        g_hTapiWorkerThread = NULL;
    }

    if (NULL != g_hJobQueueThread)
    {
        if (!CloseHandle(g_hJobQueueThread))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle for g_hJobQueueThread Failed (ec: %ld"),
                GetLastError());
        }
        g_hJobQueueThread = NULL;
    }

    MemFree(g_pAdaptiveFileBuffer);
    g_pAdaptiveFileBuffer = NULL;

    MemFree(g_pLineCountryList);
    g_pLineCountryList = NULL;

    FreeRecieptsConfiguration( &g_ReceiptsConfig, FALSE);

    //
    // free g_ArchivesConfig strings memory
    //
    MemFree(g_ArchivesConfig[0].lpcstrFolder);
    MemFree(g_ArchivesConfig[1].lpcstrFolder);

    //
    // free g_ActivityLoggingConfig strings memory
    //
    MemFree(g_ActivityLoggingConfig.lptstrDBPath);

    FreeResInstance();

    Assert ((ULONG_PTR)g_HandleTableListHead.Flink == (ULONG_PTR)&g_HandleTableListHead);
    Assert ((ULONG_PTR)g_DeviceProvidersListHead.Flink == (ULONG_PTR)&g_DeviceProvidersListHead);
    Assert ((ULONG_PTR)g_JobListHead.Flink == (ULONG_PTR)&g_JobListHead);
    Assert ((ULONG_PTR)g_QueueListHead.Flink == (ULONG_PTR)&g_QueueListHead);
    Assert ((ULONG_PTR)g_lstRoutingMethods .Flink == (ULONG_PTR)&g_lstRoutingMethods );
    Assert ((ULONG_PTR)g_lstRoutingExtensions .Flink == (ULONG_PTR)&g_lstRoutingExtensions );
#if DBG
    Assert ((ULONG_PTR)g_CritSecListHead .Flink == (ULONG_PTR)&g_CritSecListHead );
#endif
    Assert ((ULONG_PTR)g_TapiLinesListHead .Flink == (ULONG_PTR)&g_TapiLinesListHead );
    Assert ((ULONG_PTR)g_RemovedTapiLinesListHead .Flink == (ULONG_PTR)&g_RemovedTapiLinesListHead );

    return;
}

VOID
EncryptReceiptsPassword(
	VOID
	)
/*++
	Routine Description:

	Checks if the receipts password is stored encrypted. If it is not encrypted, it encrypts the password.
	Unattended fax installation stores this password as clear text in the registry.
    
Arguments:

   None.

Return Value:

    None.

--*/
{
	DEBUG_FUNCTION_NAME(TEXT("EncryptReceiptsPassword"));
	FAX_ENUM_DATA_ENCRYPTION DataEncrypted;
	HKEY hKey;
	LPWSTR lpwstrPassword = NULL;
	BOOL bDeletePassword = FALSE;	

    hKey = OpenRegistryKey(HKEY_LOCAL_MACHINE, REGKEY_FAX_RECEIPTS, FALSE, KEY_READ | KEY_WRITE);
	if (NULL == hKey)
	{
		DebugPrintEx(DEBUG_ERR,
                     TEXT("OpenRegistryKey failed (ec: %ld)"),
                     GetLastError());
		return;
	}

	lpwstrPassword = GetRegistrySecureString(hKey, REGVAL_RECEIPTS_PASSWORD, NULL, TRUE, &DataEncrypted);
	if (FAX_DATA_ENCRYPTED == DataEncrypted)
	{
		//
		// We are done!
		//
		goto exit;
	}
	else if(FAX_NO_DATA == DataEncrypted)
	{
		//
		// We do not know if the data is encrypted or not. 
		// Delete the password
		//
		bDeletePassword = TRUE;
	}
	else
	{
		Assert (FAX_DATA_NOT_ENCRYPTED == DataEncrypted);
		//
		// Data is not encrypted, store it encrypted now.
		//
		if (!SetRegistrySecureString(
			hKey,
			REGVAL_RECEIPTS_PASSWORD,
			lpwstrPassword ? lpwstrPassword : EMPTY_STRING,
			TRUE // Optionally non-encrypted
			))
        {            
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetRegistrySecureString failed : %ld"),
                GetLastError());            
			bDeletePassword = TRUE;
        }
	}

	if (TRUE == bDeletePassword)
	{
		//
		// We do not want to leave clear text password in the registry
		//
		LONG lResult;

		lResult = RegDeleteValue( hKey, REGVAL_RECEIPTS_PASSWORD);
		if (ERROR_SUCCESS != lResult)
		{
			DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegDeleteValue failed : %ld"),
                lResult);
		}
	}

exit:
	RegCloseKey(hKey);
	if (lpwstrPassword)
	{
		SecureZeroMemory(lpwstrPassword, wcslen(lpwstrPassword)*sizeof(WCHAR));
		MemFree(lpwstrPassword);
	}
	return;
}



VOID
FaxServiceMain(
    DWORD argc,
    LPTSTR *argv
    )
/*++

Routine Description:

    This is the service main that is called by the
    service controller.

Arguments:

    argc        - argument count
    argv        - argument array

Return Value:

    None.

--*/
{	
    OPEN_DEBUG_FILE(SERVICE_DEBUG_LOG_FILE);

    DEBUG_FUNCTION_NAME(TEXT("FaxServiceMain"));
    DWORD dwRet;
    HKEY  hStartupKey = NULL;   // Key to signal clients the service is running
    HKEY  hFaxRoot = NULL;      // Key to root of fax prarmeters in the registry

#if DBG
    for (int i = 1; i < argc; i++)
    {
        if (0 == _tcsicmp(argv[i], TEXT("/d")))
        {
            //
            // We are in debug mode. - attach the debugger
            //
            DebugPrintEx(DEBUG_MSG,
                     TEXT("Entring debug mode..."));
            DebugBreak();
        }
    }
#endif //  #if DBG

	//
	// First of all make sure receipts password is stored encrypted
	// Unattended installation stores the password as clear text.
	//
	EncryptReceiptsPassword();

    //
    // Becuase the process is not always terminated when the service is stopped,
    // We must not have any staticly initialized global variables.
    // Initialize all service global variables before starting the service
    //
    if (!InitializeServiceGlobals())
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("InitializeServiceGlobals failed (ec: %ld)"),
                     GetLastError());
        goto Exit;
    }
    if (!InitializeFaxLibrariesGlobals())
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("InitializeFaxLibrariesGlobals failed"));
        goto Exit;
    }
    hFaxRoot = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                                REGKEY_FAXSERVER,
                                TRUE,                    // Create key if needed
                                KEY_READ);
    if (hFaxRoot)
    {
        GetRegistryDwordEx (hFaxRoot, REGVAL_USE_DEFAULT_FAULT_HANDLING_POLICY, (LPDWORD)&gs_bUseDefaultFaultHandlingPolicy);
        RegCloseKey (hFaxRoot);
    }
    //
    // This will prevent the system exception dialog from showing up.
    // This is required so we can support the SCM service-recovery feature
    // to auto-recovery from unhandled exceptions.
    //
    SetUnhandledExceptionFilter (FaxUnhandledExceptionFilter);

    for (int i = 1; i < argc; i++)
    {
        if (0 == _tcsicmp(argv[i], SERVICE_ALWAYS_RUNS))
        {
            //
            // Service must never suicide
            //
            g_bServiceCanSuicide = FALSE;
            DebugPrintEx(DEBUG_MSG,
                         TEXT("Command line detected. Service will not suicide"));

        }
        else if (0 == _tcsicmp(argv[i], SERVICE_DELAY_SUICIDE))
        {
            //
            // Service should delay suicide
            //
            g_bDelaySuicideAttempt = TRUE;
            DebugPrintEx(DEBUG_MSG,
                         TEXT("Command line detected. Service will delay suicide attempts"));

        }
    }

    gs_FaxServiceStatusHandle = RegisterServiceCtrlHandler(
        FAX_SERVICE_NAME,
        FaxServiceCtrlHandler
        );

    if (!gs_FaxServiceStatusHandle)
    {
        DebugPrintEx(DEBUG_ERR,
                     TEXT("RegisterServiceCtrlHandler failed %d"),
                     GetLastError());
        goto Exit;
    }
    //
    // Open the HKLM\Software\Microsoft\Fax\Client\ServiceStartup key
    // to tell clients the service is up.
    //
    hStartupKey = OpenRegistryKey (HKEY_LOCAL_MACHINE,
                                   REGKEY_FAX_SERVICESTARTUP,
                                   TRUE,                    // Create key if needed
                                   KEY_READ | KEY_WRITE);
    if (!hStartupKey)
    {                                          
        DebugPrintEx(DEBUG_ERR,
                        TEXT("Can't open reg key (ec = %ld)"), 
                        GetLastError() );
        goto Exit;
    }
    //
    // Initialize service
    //
    dwRet = ServiceStart();
    if (ERROR_SUCCESS != dwRet)
    {
        //
        // The service failed to start correctly
        //
        DebugPrintEx(DEBUG_ERR,
                     TEXT("The service failed to start correctly (dwRet = %ld)"), dwRet );
    }
    else
    {
        //
        // mark the service in the running state
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Reporting SERVICE_RUNNING to the SCM"));
        ReportServiceStatus( SERVICE_RUNNING, 0, 0 );
        //
        // Notify all clients (on local machine) that the server is up and running.
        // For security reasons, we do that by writing to the registry 
        // (HKLM\Software\Microsoft\Fax\Client\ServiceStartup\RPCReady).
        // The client modules listen to registry changes in that key.
        //
        if (!SetRegistryDword (hStartupKey, 
                               REGVAL_FAX_RPC_READY, 
                               GetRegistryDword (hStartupKey, REGVAL_FAX_RPC_READY) + 1))
        {                             
            DebugPrintEx(DEBUG_ERR,
                            TEXT("Can't open reg key (ec = %ld)"), 
                            GetLastError() );
        }
        //
        // Wait for service shutdown event from SCM
        //
        DebugPrintEx(DEBUG_MSG,
                     TEXT("Waiting for service shutdown event"));
        DWORD dwWaitRes = WaitForSingleObject (g_hSCMServiceShutDownEvent ,INFINITE);
        if (WAIT_OBJECT_0 != dwWaitRes)
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("WaitForSingleObject failed (ec = %ld)"), GetLastError() );
        }
 
    }
    //
    // Close service
    //
    if (ERROR_SUCCESS != dwRet)
    {
        EndFaxSvc(FAXLOG_LEVEL_MIN);
    }
    else
    {
        EndFaxSvc(FAXLOG_LEVEL_MAX);
    }
    
Exit:

    if (hStartupKey)
    {
        RegCloseKey (hStartupKey);
    }
    FreeServiceGlobals();
    FreeFaxLibrariesGlobals();

    ReportServiceStatus( SERVICE_STOPPED, 0 , 0);
    return;
}   // FaxServiceMain



BOOL SetServiceIsDownFlag(VOID)
{
/*++

Routine Description:

    Sets the g_bServiceIsDown to true.
    Done by a separate thread while reporting SERVICE_STOP_PENDING to SCM.

Arguments:

    None.

Return Value:

    TRUE    on success.
    FALSE   on failure - use GetLastError() to get standard win32 error code.

--*/
    HANDLE  hThread = NULL;
    DWORD   ec = ERROR_SUCCESS;    
    DEBUG_FUNCTION_NAME(TEXT("SetServiceIsDownFlag"));

    //
    // Call SetServiceIsDownFlagThread() to set the g_bServiceIsDown flag
    //
    hThread = CreateThread( NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) SetServiceIsDownFlagThread,
                            NULL,
                            0,
                            NULL
                          );
    if (NULL == hThread)
    {
        ec = GetLastError();        
        DebugPrintEx(   DEBUG_ERR,
                        _T("Failed to create SetServiceIsDownFlagThread (ec: %ld)."),
                        ec);
        goto Exit;
    }

    if (!WaitAndReportForThreadToTerminate(hThread,TEXT("Waiting for SetServiceIsDownFlagThread to terminate."))) 
    {
        ec = GetLastError();        
        DebugPrintEx(   DEBUG_ERR,
                        _T("Failed to WaitAndReportForThreadToTerminate (ec: %ld)."),
                        ec);
        goto Exit;
    }

    Assert(ec == ERROR_SUCCESS);
Exit:
    
    if (NULL != hThread) 
    {
        if (!CloseHandle(hThread))
        {
            DebugPrintEx(   DEBUG_ERR,
                            _T("CloseHandle Failed (ec: %ld)."),
                            GetLastError());
        }

    }
    
    if (ERROR_SUCCESS != ec)
    {
        SetLastError(ec);
    }

    return (ERROR_SUCCESS == ec);
}

DWORD SetServiceIsDownFlagThread(
    LPVOID pvUnused
    )
/*++

Routine Description:

    Sets the g_bServiceIsDown to true.
    Done by a separate thread in order for FaxServiceCtrlHandler to return immediately.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success.

--*/
{
    DWORD dwWaitCount = 2; // We wait for TapiWorkerThread() and JobQueueThread()
    DEBUG_FUNCTION_NAME(TEXT("SetServiceIsDownFlagThread"));

    //
    // First set the global flag that the service is going down
    //
    g_bServiceIsDown = TRUE;

    //
    // Update dwWaitCount to the correct value
    //
    if (NULL == g_hTapiWorkerThread)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("TapiWorkerThread was not created. Do not wait for an event from TapiWorkerThread()"));
        dwWaitCount -= 1;
    }

    if (NULL == g_hJobQueueThread)
    {
        DebugPrintEx(
            DEBUG_WRN,
            TEXT("g_hJobQueueThread was not created. Do not wait for an event from g_hJobQueueThread()"));
        dwWaitCount -= 1;
    }

    //
    // Wake up TapiWorkerThread and JobQueueThread, so they can read g_bServiceIsDown
    //
    if (NULL != g_hJobQueueEvent)
    {
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set g_hJobQueueEvent. (ec: %ld)"),
                GetLastError());       
        }
    }

    if (NULL != g_TapiCompletionPort)
    {
        if (!PostQueuedCompletionStatus( g_TapiCompletionPort,
                                         0,
                                         FAXDEV_EVENT_KEY,
                                         (LPOVERLAPPED) NULL))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PostQueuedCompletionStatus failed (FAXDEV_EVENT_KEY - TapiWorkerThread). (ec: %ld)"),
                GetLastError());
        }
    }

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("SetServiceIsDownFlagThread waits for %d Thread(s)"),
            dwWaitCount);
    //
    // Wait for a signal from TapiWorkerThread and JobQueueThread that the global flag g_bServiceIsDown was read by them
    //
    for (DWORD i = 0; i < dwWaitCount; i++)
    {
        DWORD dwWaitRes = WaitForSingleObject (g_hServiceIsDownSemaphore ,INFINITE);
        if (WAIT_OBJECT_0 != dwWaitRes)
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("WaitForSingleObject failed (ec = %ld)"), GetLastError() );
        }
    }

    return (ERROR_SUCCESS);
}



VOID
FaxServiceCtrlHandler(
    DWORD Opcode
    )

/*++

Routine Description:

    This is the FAX service control dispatch function.

Arguments:

    Opcode      - requested control code

Return Value:

    None.

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FaxServiceCtrlHandler"));

    switch(Opcode)
    {
        case SERVICE_CONTROL_STOP:
        case SERVICE_CONTROL_SHUTDOWN:
            
           
            ReportServiceStatus( SERVICE_STOP_PENDING, 0, 2000 );
            if (!SetEvent(g_hSCMServiceShutDownEvent))
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("SetEvent failed (g_hSCMServiceShutDownEvent) (ec = %ld)"),
                     GetLastError());
            }
            return;
            

        default:
            DebugPrintEx(
                 DEBUG_WRN,
                 TEXT("Unrecognized opcode %ld"),
                 Opcode);
            break;
    }

    ReportServiceStatus( 0, 0, 0 );

    return;
}

BOOL
ReportServiceStatus(
    DWORD CurrentState,
    DWORD Win32ExitCode,
    DWORD WaitHint
    )

/*++

Routine Description:

    This function updates the service control manager's status information for the FAX service.

Arguments:

    CurrentState    - Indicates the current state of the service
    Win32ExitCode   - Specifies a Win32 error code that the service uses to
                      report an error that occurs when it is starting or stopping.
    WaitHint        - Specifies an estimate of the amount of time, in milliseconds,
                      that the service expects a pending start, stop, or continue
                      operation to take before the service makes its next call to the
                      SetServiceStatus function with either an incremented dwCheckPoint
                      value or a change in dwCurrentState.

Return Value:

    BOOL

--*/

{
    BOOL rVal;

    if (CurrentState == SERVICE_START_PENDING)
    {
        gs_FaxServiceStatus.dwControlsAccepted = 0;
    }
    else
    {
        gs_FaxServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;
    }

    if (CurrentState)
    {
        gs_FaxServiceStatus.dwCurrentState = CurrentState;
    }
    gs_FaxServiceStatus.dwWin32ExitCode = Win32ExitCode;
    gs_FaxServiceStatus.dwWaitHint = WaitHint;


    ++(gs_FaxServiceStatus.dwCheckPoint);


    //
    // Report the status of the service to the service control manager.
    //
    rVal = SetServiceStatus( gs_FaxServiceStatusHandle, &gs_FaxServiceStatus );
    if (!rVal)
    {
        DebugPrint(( TEXT("SetServiceStatus() failed: ec=%d"), GetLastError() ));
    }

    return rVal;
}



DWORD
RpcBindToFaxClient(
    IN  LPCWSTR               ServerName,
    IN  LPCWSTR               Endpoint,
    OUT RPC_BINDING_HANDLE    *pBindingHandle
    )
/*++

Routine Description:

    Binds to the Fax server to the Client RPC server if possible.

Arguments:

    ServerName - Name of client RPC server to bind with.

    Endpoint - Name of interface to bind with.    

    pBindingHandle - Location where binding handle is to be placed

Return Value:

    STATUS_SUCCESS - The binding has been successfully completed.

    STATUS_INVALID_COMPUTER_NAME - The ServerName syntax is invalid.

    STATUS_NO_MEMORY - There is not sufficient memory available to the
        caller to perform the binding.

--*/

{
    RPC_STATUS        RpcStatus;
    LPWSTR            StringBinding;
    WCHAR             ComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR            NewServerName = LOCAL_HOST_ADDRESS;
    DWORD             bufLen = MAX_COMPUTERNAME_LENGTH + 1;
    DEBUG_FUNCTION_NAME(TEXT("RpcBindToFaxClient"));

    *pBindingHandle = NULL;

    if (ServerName != NULL)
    {
        if (GetComputerNameW(ComputerName,&bufLen))
        {
            if ((_wcsicmp(ComputerName,ServerName) == 0) ||
                ((ServerName[0] == '\\') &&
                 (ServerName[1] == '\\') &&
                 (_wcsicmp(ComputerName,&(ServerName[2]))==0)))
            {
                //
                //  We are binding to local machine - using LOCAL_HOST_ADDRESS (defined as _T("127.0.0.1")).
                //  Using this format we can help the RPC server to detect local calls.
                //
                NewServerName = LOCAL_HOST_ADDRESS;
            }
            else
            {
                NewServerName = (LPWSTR)ServerName;
            }
        }
        else
        {
            DWORD ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetComputerNameW failed  (ec = %lu)"),
                ec);
            return ec;
        }
    }

    RpcStatus = RpcStringBindingComposeW(0,
                                        const_cast<LPTSTR>(RPC_PROT_SEQ_TCP_IP),
                                        NewServerName,
                                        (LPWSTR)Endpoint,
                                        (LPWSTR)L"",
                                        &StringBinding);
    if ( RpcStatus != RPC_S_OK )
    {       
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcStringBindingComposeW failed  (ec = %ld)"),
            RpcStatus);
        return( STATUS_NO_MEMORY );
    }

    RpcStatus = RpcBindingFromStringBindingW(StringBinding, pBindingHandle);
    RpcStringFreeW(&StringBinding);
    if ( RpcStatus != RPC_S_OK )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcBindingFromStringBindingW failed  (ec = %ld)"),
            RpcStatus);

        *pBindingHandle = NULL;
        if (   (RpcStatus == RPC_S_INVALID_ENDPOINT_FORMAT)
            || (RpcStatus == RPC_S_INVALID_NET_ADDR) )
        {
            return( ERROR_INVALID_COMPUTERNAME );
        }
        return(STATUS_NO_MEMORY);
    }

    //
    // Ask for the highest level of privacy (autnetication + encryption)
    //
    RPC_SECURITY_QOS    rpcSecurityQOS = {  RPC_C_SECURITY_QOS_VERSION,
                                            RPC_C_QOS_CAPABILITIES_DEFAULT,
                                            RPC_C_QOS_IDENTITY_STATIC,
                                            RPC_C_IMP_LEVEL_IDENTIFY    // Server can obtain information about 
                                                                        // client security identifiers and privileges, 
                                                                        // but cannot impersonate the client. 
    };


                                            
    RpcStatus = RpcBindingSetAuthInfoEx (
                *pBindingHandle,    			// RPC binding handle
                TEXT(""),  						// Server principal name - ignored for RPC_C_AUTHN_WINNT
                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,  // Authentication level - fullest
                                                // Authenticates, verifies, and privacy-encrypts the arguments passed
                                                // to every remote call.
                RPC_C_AUTHN_WINNT,              // Authentication service (NTLMSSP)
                NULL,                           // Authentication identity - use currently logged on user
                0,                              // Unused when Authentication service == RPC_C_AUTHN_WINNT
                &rpcSecurityQOS);               // Defines the security quality-of-service
    if (RPC_S_OK != RpcStatus)
    {
        //
        // Couldn't set RPC authentication mode
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcBindingSetAuthInfoEx (RPC_C_AUTHN_LEVEL_PKT_PRIVACY) failed. (ec: %ld)"),
            RpcStatus);     
        RpcBindingFree (pBindingHandle);
        *pBindingHandle = NULL;
        return RpcStatus; 
    }

    //
    // Set time out on RPC calls to 30 sec, to avoid denial of service by malicious user.
    //
    RpcStatus = RpcBindingSetOption(
        *pBindingHandle,
        RPC_C_OPT_CALL_TIMEOUT,
        30*1000); 
    if (RPC_S_OK != RpcStatus)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcBindingSetOption failed  (ec = %ld)"),
            RpcStatus);
        RpcBindingFree (pBindingHandle);
        *pBindingHandle = NULL;
        return RpcStatus; 
    }
        
    return(ERROR_SUCCESS);
}

RPC_STATUS RPC_ENTRY FaxServerSecurityCallBack(
    IN RPC_IF_HANDLE idIF, 
    IN void *ctx
    ) 
/*++

Routine Description:

    Security callback function is automatically called when
    any RPC server function is called. (usually, once per client - but in some cases, 
                                        the RPC run time may call the security-callback function more than 
                                        once per client-per interface)

    o The call-back will deny access for clients with authentication level below RPC_C_AUTHN_LEVEL_PRIVACY.

Arguments:

    idIF - UUID and version of the interface.
    ctx  - Pointer to an RPC_IF_ID server binding handle representing the client. 

Return Value:

    The callback function should return RPC_S_OK if the client is allowed to call methods in this interface. 
    Any other return code will cause the client to receive the exception RPC_S_ACCESS_DENIED.

--*/
{
    RPC_AUTHZ_HANDLE hPrivs;
	DWORD dwAuthn;
	BOOL fLocal;	
	BOOL fPrinterShared;
	DWORD dwRes;

    RPC_STATUS status;
    RPC_STATUS rpcStatRet = ERROR_ACCESS_DENIED;

    LPWSTR lpwstrProtSeq = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FaxServerSecurityCallBack"));

	//
    //  Query the client's protseq
    //
    status = GetRpcStringBindingInfo(ctx,
                                     NULL,
                                     &lpwstrProtSeq);
    if (status != RPC_S_OK) 
    {
		DebugPrintEx(DEBUG_ERR,
                     TEXT("RpcBindingServerFromClient failed - (ec: %lu)"), 
                     status);		
        goto error;
	}

    if (_tcsicmp(lpwstrProtSeq, RPC_PROT_SEQ_NP))
    {
		DebugPrintEx(DEBUG_ERR,
                     TEXT("Client not using named pipes protSeq.")
                     );
		goto error;
    }

    //
    //  Query the client's authentication level
    //
    status = RpcBindingInqAuthClient(
			ctx,
			&hPrivs,
			NULL,
			&dwAuthn,
			NULL,
			NULL);										
	if (status != RPC_S_OK) 
    {
		DebugPrintEx(DEBUG_ERR,
                     TEXT("RpcBindingInqAuthClient returned: 0x%x"), 
                     status);
		goto error;
	}

    //
	// Now check the authentication level.
	// We require at least packet-level privacy  (RPC_C_AUTHN_LEVEL_PKT_PRIVACY) authentication.
    //
	if (dwAuthn < RPC_C_AUTHN_LEVEL_PKT_PRIVACY) 
    {
		DebugPrintEx(DEBUG_ERR,
                     TEXT("Attempt by client to use weak authentication. - 0x%x"),
                     dwAuthn);
		goto error;
	}

	if (0 == g_dwAllowRemote)
	{
		//
		// The administrator did not set the registry to always allow remote calls		
		// If the printer is not shared, block remote connections
		//
		dwRes = IsLocalFaxPrinterShared(&fPrinterShared);
		if (ERROR_SUCCESS != dwRes)
		{
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("IsLocalFaxPrinterShared failed. - %ld"),
				dwRes);
			goto error;
		}

		if (FALSE == fPrinterShared)
		{
			status = IsLocalRPCConnectionNP(&fLocal);
			if (RPC_S_OK != status)
			{
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("IsLocalRPCConnectionNP failed. - %ld"),
					status);
				goto error;
			}

			if (FALSE == fLocal)
			{
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("Printer is not shared, and a remote connection is done"));
				goto error;
			}
		}    
	}
	rpcStatRet = RPC_S_OK;

error:

    if(NULL != lpwstrProtSeq)
    {
        MemFree(lpwstrProtSeq);
    }

	return rpcStatRet;
}   // FaxServerSecurityCallBack



RPC_STATUS
AddFaxRpcInterface(
    IN  LPWSTR                  InterfaceName,
    IN  RPC_IF_HANDLE           InterfaceSpecification
    )
/*++

Routine Description:

    Starts an RPC Server, adds the address (or port/pipe), and adds the
    interface (dispatch table).

Arguments:

    InterfaceName - points to the name of the interface.

    InterfaceSpecification - Supplies the interface handle for the
        interface which we wish to add.

Return Value:

    NT_SUCCESS - Indicates the server was successfully started.

    STATUS_NO_MEMORY - An attempt to allocate memory has failed.

    Other - Status values that may be returned by:

                 RpcServerRegisterIfEx()
                 RpcServerUseProtseqEp()

    , or any RPC error codes, or any windows error codes that
    can be returned by LocalAlloc.

--*/
{
    RPC_STATUS          RpcStatus;
    LPWSTR              Endpoint = NULL;
    DEBUG_FUNCTION_NAME(TEXT("AddFaxRpcInterface"));

    // We need to concatenate \pipe\ to the front of the interface name.
    Endpoint = (LPWSTR)LocalAlloc(LMEM_FIXED, sizeof(NT_PIPE_PREFIX) + WCSSIZE(InterfaceName));
    if (Endpoint == 0)
    {
        DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("LocalAlloc failed"));
        return(STATUS_NO_MEMORY);
    }
    wcscpy(Endpoint, NT_PIPE_PREFIX);
    wcscat(Endpoint,InterfaceName);

    RpcStatus = RpcServerUseProtseqEpW(const_cast<LPTSTR>(RPC_PROT_SEQ_NP), RPC_C_PROTSEQ_MAX_REQS_DEFAULT, Endpoint, NULL);
    if (RpcStatus != RPC_S_OK)
    {
        DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("RpcServerUseProtseqEpW failed (ec = %ld)"),
                     RpcStatus);
        goto CleanExit;
    }

    RpcStatus = RpcServerRegisterIfEx(InterfaceSpecification, 
                                      0, 
                                      0, 
                                      RPC_IF_ALLOW_SECURE_ONLY,         // Limits connections to clients that use an authorization level higher than RPC_C_AUTHN_LEVEL_NONE
                                      RPC_C_LISTEN_MAX_CALLS_DEFAULT,   // Relieves the RPC run-time environment from enforcing an unnecessary restriction
                                      FaxServerSecurityCallBack);
    if (RpcStatus != RPC_S_OK)
    {
        DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("RpcServerRegisterIf failed (ec = %ld)"),
                     RpcStatus);
    }

CleanExit:
    if ( Endpoint != NULL )
    {
        LocalFree(Endpoint);
    }
    return RpcStatus;
}


RPC_STATUS
StartFaxRpcServer(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    )
/*++

Routine Description:

    Starts an RPC Server, adds the address (or port/pipe), and adds the
    interface (dispatch table).

Arguments:

    InterfaceName - points to the name of the interface.

    InterfaceSpecification - Supplies the interface handle for the
        interface which we wish to add.

Return Value:

    NT_SUCCESS - Indicates the server was successfully started.

    STATUS_NO_MEMORY - An attempt to allocate memory has failed.

    Other - Status values that may be returned by:

                 RpcServerRegisterIf()
                 RpcServerUseProtseqEp()

    , or any RPC error codes, or any windows error codes that
    can be returned by LocalAlloc.

--*/
{
    RPC_STATUS          RpcStatus = RPC_S_OK;
    DEBUG_FUNCTION_NAME(TEXT("StartFaxRpcServer"));

    RpcStatus = AddFaxRpcInterface( InterfaceName,
                                    InterfaceSpecification );
    if ( RpcStatus != RPC_S_OK )
    {
        DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("AddFaxRpcInterface failed (ec = %ld)"),
                     RpcStatus);
        return RpcStatus;
    }
    
    if (FALSE == IsDesktopSKU())
    {
        //
        // We are not running on DesktopSKU, so remote connection is enabled. RPC data can be passed on the wire
        // We use NTLM authentication for privacy level RPC calls
        //
        RpcStatus = RpcServerRegisterAuthInfo (
                        RPC_SERVER_PRINCIPAL_NAME,  // Igonred by RPC_C_AUTHN_WINNT
                        RPC_C_AUTHN_WINNT,          // NTLM SPP authenticator
                        NULL,                       // Ignored when using RPC_C_AUTHN_WINNT
                        NULL);                      // Ignored when using RPC_C_AUTHN_WINNT
        if (RpcStatus != RPC_S_OK)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcServerRegisterAuthInfo() failed (ec: %ld)"),
                RpcStatus);
            
            RPC_STATUS  RpcStatus2 = RpcServerUnregisterIf(InterfaceSpecification, 0, 1);
            if (RpcStatus2 != RPC_S_OK)
            {
                //
                //  failed to unregister interface. don't propagate error 
                //
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("RpcServerUnregisterIf() failed (ec: %ld)"),
                    RpcStatus2);
            }
            return RpcStatus;
        }
    }

    RpcStatus = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT , TRUE);  // Do not wait
    if ( RpcStatus != RPC_S_OK )
    {
        DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("RpcServerListen failed (ec = %ld)"),
                     RpcStatus);
        
        RPC_STATUS  RpcStatus2 = RpcServerUnregisterIf(InterfaceSpecification, 0, 1);
        if (RpcStatus2 != RPC_S_OK)
        {
            //
            //  failed to unregister interface. don't propagate error 
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RpcServerUnregisterIf() failed (ec: %ld)"),
                RpcStatus2);
        }

        return RpcStatus;
    }

    return RpcStatus;
}


DWORD
StopFaxRpcServer(
    VOID
    )
/*++

Routine Description:

   Stops the service RPC server.

Arguments:

Return Value:


--*/
{
    RPC_STATUS          RpcStatus = RPC_S_OK;
    DEBUG_FUNCTION_NAME(TEXT("StopFaxRpcServer"));
    DWORD dwRet = ERROR_SUCCESS;
    
    RpcStatus = RpcMgmtStopServerListening(NULL);
    if (RPC_S_OK != RpcStatus)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcMgmtStopServerListening failed. (ec: %ld)"),
            RpcStatus);
        dwRet = RpcStatus;
    }

    //
    // Wait for the RPC listening thread to return.
    // The thread returns only when all RPC calls are terminated
    //
    if (NULL != g_hRPCListeningThread)
    {
       if (!WaitAndReportForThreadToTerminate(  g_hRPCListeningThread, 
                                                TEXT("Waiting for RPC listning thread to terminate.")) )
       {
                DebugPrintEx(
                    DEBUG_ERR,
                    _T("WaitAndReportForThreadToTerminate failed (ec: %ld)"),
                    GetLastError());
       }

       if (!CloseHandle(g_hRPCListeningThread))
       {
           DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle for g_hRPCListeningThread Failed (ec: %ld"),
                GetLastError());
       }
       g_hRPCListeningThread = NULL;
    }

    RpcStatus = RpcServerUnregisterIfEx(
        fax_ServerIfHandle,     // Specifies the interface to remove from the registry
        NULL,                   // remove the interface specified in the IfSpec parameter for all previously registered type UUIDs from the registry.
        FALSE);                 // RPC run time will not call the rundown routines. 
    if (RPC_S_OK != RpcStatus)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("RpcServerUnregisterIfEx failed. (ec: %ld)"),
            RpcStatus);     
    }

    return ((ERROR_SUCCESS == dwRet) ? RpcStatus : dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\faxsvc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxsvc.h

Abstract:

    This is the main fax service header file.  All
    source modules should include this file ONLY.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#ifndef _FAXSVC_
#define _FAXSVC_

#include <windows.h>
#include <shellapi.h>
#include <winspool.h>
#include <imagehlp.h>
#include <winsock2.h>
#include <setupapi.h>
#include <ole2.h>
#include <tapi.h>
#include <rpc.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>
#include <shlobj.h>
#include <stddef.h>
#include <fxsapip.h>
#include <faxroute.h>
#include <faxdev.h>
#include <faxdevex.h>
#include <faxext.h>
#include <sddl.h>
#include <objbase.h>
#include <lmcons.h>
#include <Wincrui.h>
#include "fxsapip.h"
#include "faxrpc.h"
#include "faxcli.h"
#include "faxutil.h"
#include "CritSec.h"
#include "faxevent_messages.h"
#include "faxmsg.h"
#include "tifflib.h"
#include "faxreg.h"
#include "faxsvcrg.h"
#include "faxperf.h"
#include "resource.h"
#include "rpcutil.h"
#include "faxmapi.h"
#include "faxevent.h"

#include "tiff.h"
#include "archive.h"
#include "tapiCountry.h"
#include "RouteGroup.h"
#include "RouteRule.h"
#include "Events.h"
#include "prtcovpg.h"
#include "faxres.h"
#include "Dword2Str.h"

#define INBOX_TABLE             TEXT("Inbox")
#define OUTBOX_TABLE            TEXT("Outbox")
#define EMPTY_LOG_STRING             TEXT(" ")
#define TAB_LOG_STRING               TEXT("    ")   // Define '/t' to 4 spaces ,so we can use TAB as a delimeter
#define NEW_LINE_LOG_CHAR            TEXT(' ')      // Define '/n' to 1 space ,so we can log strings with '/n'


#define FIELD_TYPE_TEXT     TEXT("Char")
#define FIELD_TYPE_DATE     TEXT("Date")
#define FIELD_TYPE_FLOAT    TEXT("Float")

typedef struct _LOG_STRING_TABLE {
    DWORD   FieldStringResourceId;
    LPTSTR  Type;
    DWORD   Size;
    LPTSTR  String;
} LOG_STRING_TABLE, *PLOG_STRING_TABLE;

extern HANDLE g_hInboxActivityLogFile;
extern HANDLE g_hOutboxActivityLogFile;

//
// TAPI versions
//
#define MAX_TAPI_API_VER        0x00020000
#define MIN_TAPI_API_VER        MAX_TAPI_API_VER

#define MIN_TAPI_LINE_API_VER    0x00010003
#define MAX_TAPI_LINE_API_VER    MAX_TAPI_API_VER


#define FSPI_JOB_STATUS_INFO_FSP_PRIVATE_STATUS_CODE 0x10000000
//
// JobStatus - Virtual property support
//
#define JS_INVALID      0x00000000

typedef enum {
    FAX_TIME_TYPE_START  = 1,
    FAX_TIME_TYPE_END
} FAX_ENUM_TIME_TYPES;

#define ALL_FAX_USER_ACCESS_RIGHTS		(READ_CONTROL | WRITE_DAC | WRITE_OWNER | FAX_GENERIC_ALL)

#if DBG




BOOL DebugDateTime( IN DWORDLONG DateTime, OUT LPTSTR lptstrDateTime, IN UINT cchstrDateTime);
VOID DebugPrintDateTime(LPTSTR Heading,DWORDLONG DateTime);

void PrintJobQueue(LPCTSTR lptstrStr, const LIST_ENTRY * lpQueueHead);


#else
#define PrintJobQueue( str, Queue )
#define DebugPrintDateTime( Heading, DateTime )
#define DebugDateTime( DateTime, lptstrDateTime, cchstrDateTime)
#define DumpRecipientJob(lpcRecipJob)
#define DumpParentJobJob(lpcParentJob)
#endif


#ifdef DBG
#define EnterCriticalSection(cs)   pEnterCriticalSection(cs,__LINE__,TEXT(__FILE__))
#define LeaveCriticalSection(cs)   pLeaveCriticalSection(cs,__LINE__,TEXT(__FILE__))

VOID pEnterCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    );

VOID pLeaveCriticalSection(
    LPCRITICAL_SECTION cs,
    DWORD line,
    LPTSTR file
    );

BOOL
ThreadOwnsCs(
    VOID
    );

typedef struct {
    LIST_ENTRY  ListEntry;
    ULONG_PTR    CritSecAddr;
    DWORD       ThreadId;
    DWORD       AquiredTime;
    DWORD       ReleasedTime;
} DBGCRITSEC, * PDBGCRITSEC;

#endif

#define FAX_IMAGE_NAME              FAX_SERVICE_IMAGE_NAME
#define RAS_MODULE_NAME             TEXT("rastapi.dll")

#define MAX_CLIENTS                 1
#define MIN_THREADS                 1
#define MAX_STATUS_THREADS          1
#define SIZEOF_PHONENO              256
#define EX_STATUS_STRING_LEN        256
#define MIN_RINGS_ALLOWED           2
#define MAX_MODEM_POPUPS            2
#define MAX_HANDLES                 1024

#define WM_SERVICE_INIT             (WM_USER+101)
#define MilliToNano(_ms)            ((LONGLONG)(_ms) * 1000 * 10)
#define SecToNano(_sec)             (DWORDLONG)((_sec) * 1000 * 1000 * 10)

#define FILLORDER_MSB2LSB           1

#define LINE_SIGNATURE              0x454e494c    // 'LINE'
#define ROUTING_SIGNATURE           'RI01'

#define TAPI_COMPLETION_KEY         0x80000001
#define FAXDEV_EVENT_KEY            0x80000002
#define FSPI_JOB_STATUS_MSG_KEY     0x80000003   // Used internally to post FSPI_JOB_STATUS_MSG messages to the FaxStatusThread
#define EFAXDEV_EVENT_KEY           0x80000004
#define ANSWERNOW_EVENT_KEY         0x80000005
#define SERVICE_SHUT_DOWN_KEY       0xffffffff

#define FixupString(_b, _s)                 (_s) = ((_s) ? (LPTSTR) ((LPBYTE)(_b) + (ULONG_PTR)_s) : 0)

#define FAX_DEVICE_TYPE_NEW                 1
#define FAX_DEVICE_TYPE_CACHED              2
#define FAX_DEVICE_TYPE_OLD                 4
#define FAX_DEVICE_TYPE_MANUAL_ANSWER       8


//
// private fax port state masks
// this bits must not conflict with FPS_?? in winfax.h or FS_??? in faxdev.h
//

#define FPS_SENDRETRY               0x2000f001
#define FPS_SENDFAILED              0x2000f002
#define FPS_BLANKSTR                0x2000f003
#define FPS_ROUTERETRY              0x2000f004

#define FPF_USED                    0x10000000
#define FPF_POWERED_OFF             0x20000000

#define FPF_CLIENT_BITS             (FPF_RECEIVE | FPF_SEND)


typedef struct _DEVICE_PROVIDER {
    LIST_ENTRY                      ListEntry;

    FAX_ENUM_PROVIDER_STATUS        Status;         // Initialization status of the FSP
    DWORD                           dwLastError;    // Last error code during initialization
    FAX_VERSION                     Version;        // FSP's DLL version info.
    
    BOOL                            bShutDownAttempted;         // Used to prevent more than one call FaxDevShutdown
    BOOL                            bInitializationSucceeded;   // Set to TRUE if FaxDevInitialized completed successfully.

    HMODULE                         hModule;
    TCHAR                           FriendlyName[MAX_PATH];
    TCHAR                           ImageName[MAX_PATH];
    TCHAR                           ProviderName[MAX_PATH];
    TCHAR                           szGUID[MAX_PATH]; // GUID for extended EFSPs. Empty string for Legacy FSPs.    
    DWORD                           dwAPIVersion;     // FSPI Version. (Legacy or Extended)    
    HANDLE                          HeapHandle;
    PFAXDEVINITIALIZE               FaxDevInitialize;
    PFAXDEVSTARTJOB                 FaxDevStartJob;
    PFAXDEVENDJOB                   FaxDevEndJob;
    PFAXDEVSEND                     FaxDevSend;
    PFAXDEVRECEIVE                  FaxDevReceive;
    PFAXDEVREPORTSTATUS             FaxDevReportStatus;
    PFAXDEVABORTOPERATION           FaxDevAbortOperation;
    PFAX_LINECALLBACK               FaxDevCallback;
    PFAXDEVVIRTUALDEVICECREATION    FaxDevVirtualDeviceCreation; 
	PFAXDEVSHUTDOWN                 FaxDevShutdown;
	PFAX_EXT_INITIALIZE_CONFIG      pFaxExtInitializeConfig;
    BOOL                            fMicrosoftExtension;
} DEVICE_PROVIDER, *PDEVICE_PROVIDER;

typedef struct _ROUTING_EXTENSION {
    LIST_ENTRY                          ListEntry;
    HMODULE                             hModule;
    FAX_ENUM_PROVIDER_STATUS            Status;         // Initialization status of the routing extension
    DWORD                               dwLastError;    // Last error code during initialization
    FAX_VERSION                         Version;        // routing extension's DLL version info.
    TCHAR                               FriendlyName[MAX_PATH];
    TCHAR                               ImageName[MAX_PATH];
    TCHAR                               InternalName[MAX_PATH];
    HANDLE                              HeapHandle;
    BOOL                                MicrosoftExtension;
    PFAXROUTEINITIALIZE                 FaxRouteInitialize;
    PFAXROUTEGETROUTINGINFO             FaxRouteGetRoutingInfo;
    PFAXROUTESETROUTINGINFO             FaxRouteSetRoutingInfo;
    PFAXROUTEDEVICEENABLE               FaxRouteDeviceEnable;
    PFAXROUTEDEVICECHANGENOTIFICATION   FaxRouteDeviceChangeNotification;
    PFAX_EXT_INITIALIZE_CONFIG          pFaxExtInitializeConfig;
    LIST_ENTRY                          RoutingMethods;
} ROUTING_EXTENSION, *PROUTING_EXTENSION;

typedef struct _ROUTING_METHOD {
    LIST_ENTRY                      ListEntry;
    LIST_ENTRY                      ListEntryMethod;
    GUID                            Guid;
    DWORD                           Priority;
    LPTSTR                          FunctionName;
    LPTSTR                          FriendlyName;
    LPTSTR                          InternalName;
    PFAXROUTEMETHOD                 FaxRouteMethod;
    PROUTING_EXTENSION              RoutingExtension;
} ROUTING_METHOD, *PROUTING_METHOD;

typedef BOOL (CALLBACK *PFAXROUTEMETHODENUM)(PROUTING_METHOD,LPVOID);

typedef struct _FAX_ROUTE_FILE {
    LIST_ENTRY      ListEntry;                      // linked list pointers
    LPWSTR          FileName;                       // file name on disk
    GUID            Guid;                           // routing method that created the file
} FAX_ROUTE_FILE, *PFAX_ROUTE_FILE;

typedef struct _LINE_INFO {
    LIST_ENTRY          ListEntry;                  // linked list pointers
    DWORD               Signature;                  // verification signature
    DWORD               DeviceId;                   // tapi device id
    DWORD               PermanentLineID;            // Fax Service allocation permanent line id.
    DWORD               TapiPermanentLineId;        // TAPI permanent tapi device id for TAPI devices.
    HLINE               hLine;                      // tapi line handle
    PDEVICE_PROVIDER    Provider;                   // fax service device provider
    struct _JOB_ENTRY   *JobEntry;                  // non-null if there is an outstanding job
    LPTSTR              DeviceName;                 // device name
    LPTSTR              lptstrDescription;          // Device description
    DWORD               State;                      // device state
    DWORD               Flags;                      // device use flags
    DWORD               dwReceivingJobsCount;       // Number of receiving jobs using this device
    DWORD               dwSendingJobsCount;         // Number of sending jobs using this device
    LPTSTR              Csid;                       // calling station's identifier
    LPTSTR              Tsid;                       // transmittion station's identifier
    BOOL                UnimodemDevice;             // true if this device is a modem
    DWORD               RingsForAnswer;             //
    DWORD               RingCount;                  //
    LINEMESSAGE         LineMsgOffering;            //
    BOOL                ModemInUse;                 // TRUE if the modem is in use by another TAPI app
    BOOL                OpenInProgress;             //
    DWORD               LineStates;                 //
    HCALL               RasCallHandle;              // used to track call when handed to RAS
    BOOL                NewCall;                    // A new call is coming in    
    DWORDLONG           LastLineClose;              // Time stamp of the last LINE_CLOSE
    DWORD               dwDeviceType;               // One of FAX_DEVICE_TYPE_XXXX defines
} LINE_INFO, *PLINE_INFO;


VOID
UpdateDeviceJobsCounter (
    PLINE_INFO      pLine,
    BOOL            bSend,
    int             iInc,
    BOOL            bNotify
);

typedef struct {
    HANDLE              hComm;
    CHAR                szDeviceName[1];
} DEVICEID, *PDEVICEID;

typedef struct _ROUTING_DATA_OVERRIDE {
    LIST_ENTRY          ListEntry;                  //
    LPBYTE              RoutingData;                //
    DWORD               RoutingDataSize;            //
    PROUTING_METHOD     RoutingMethod;              //
} ROUTING_DATA_OVERRIDE, *PROUTING_DATA_OVERRIDE;

typedef struct _ROUTE_FAILURE_INFO {
    WCHAR   GuidString[MAX_GUID_STRING_LEN];        // GUID of the rounting method that failed
    PVOID   FailureData;                            // pointer to the routing method's data
    DWORD   FailureSize;                            // routing method's data size in bytes
} ROUTE_FAILURE_INFO, *PROUTE_FAILURE_INFO;

typedef struct _JOB_QUEUE * PJOB_QUEUE;
typedef struct _JOB_QUEUE_PTR * PJOB_QUEUE_PTR;

typedef struct _JOB_ENTRY {
    LIST_ENTRY          ListEntry;                  //
    PLINE_INFO          LineInfo;                   //
    HCALL               CallHandle;                 //
    HANDLE              InstanceData;               //
    DWORDLONG           StartTime;                  //
    DWORDLONG           EndTime;                    //
    DWORDLONG           ElapsedTime;                //
    BOOL                Aborting;                   // is the job being aborted?
	BOOL				fSystemAbort;				// The job was aborted by the service becuase it is shutting down.
    INT                 SendIdx;                    //
    TCHAR               DisplayablePhoneNumber[SIZEOF_PHONENO]; // Displayable phone number for current send job
    TCHAR               DialablePhoneNumber[SIZEOF_PHONENO];    // Dialable phone number for current send job
    BOOL                Released;                   // Is the line used by this job already released.    

    PJOB_QUEUE          lpJobQueueEntry;            // link back to the job queue entry for this job
    BOOL                bFSPJobInProgress;  // TRUE if FaxDevStartJob() was called for the job and FaxDevEndJob()
                                                    // was not called yet.
    FSPI_JOB_STATUS     FSPIJobStatus;
    HANDLE              hFSPIParentJobHandle;       // The EFSP provided job handle for the EFSP parent job
                                                        // of this job.
    WCHAR               ExStatusString[EX_STATUS_STRING_LEN];             // Extended status string
    LPWSTR              lpwstrJobTsid;              // The Tsid associated with the job (Server or device or Fax number)
    BOOL                fStopUpdateStatus;          // When it is set to TRUE, the FSPIJobStatus of this structure should not be udated any more

} JOB_ENTRY, *PJOB_ENTRY;


typedef struct _EFSP_JOB_GROUP {
    LIST_ENTRY      ListEntry;
    LPTSTR          lptstrPersistFile;      // The full path to the file where the group information is persisted.
    LINE_INFO *     lpLineInfo;
    FSPI_MESSAGE_ID FSPIParentPermanentId;
    HANDLE          hFSPIParent;
    DWORD           dwRecipientJobs;
    LIST_ENTRY      RecipientJobs;          // List of JOB_QUEUE_PTR pointing to the recipient jobs
                                            // in the group.
} EFSP_JOB_GROUP;

typedef EFSP_JOB_GROUP * LPEFSP_JOB_GROUP;
typedef const EFSP_JOB_GROUP * LPCEFSP_JOB_GROUP;

#define EFSP_JOB_GROUP_SERIALIZATION_SIGNATURE "JOBG"

typedef struct _EFSP_JOB_GROUP_SERIALIZED {
    DWORD  dwSignature;
    DWORD dwPermanentLineId;
    FSPI_MESSAGE_ID FSPIParentPermanentId;
    DWORD dwRecipientJobsCount;
    DWORDLONG dwlRecipientJobs[1];
} EFSP_JOB_GROUP_SERIALIZED;


typedef EFSP_JOB_GROUP_SERIALIZED * LPEFSP_JOB_GROUP_SERIALIZED;
typedef const EFSP_JOB_GROUP_SERIALIZED * LPCEFSP_JOB_GROUP_SERIALIZED;



typedef struct _JOB_QUEUE {
    //=========================== BEGIN COMMON ===========================
    LIST_ENTRY          ListEntry;                  // linked list pointers
    DWORDLONG           UniqueId;                   //
    DWORDLONG           ScheduleTime;               // schedule time in 64bit version after converting from
                                                    // SYSTEMTIME and recacluating to fit the discount time
                                                    // if necessary. For parent jobs this is the schedule of
                                                    // the latest recipient that reached a JS_RETRIES_EXCEEDED state.
                                                    // (we use this value to remove old jobs that were left in the queue).
    DWORD               JobId;                      // fax job id
    DWORD               JobType;                    // job type, see JT defines
    PJOB_ENTRY          JobEntry;                   // Pointer to a JOB_ENTRY structure that holds
                                                    // run time information for a job which is currently in progress.
    DWORD               RefCount;                   // Used to prevent the deletion of a job when it is still in use
                                                    // by the receive or send thread.
    DWORD               PrevRefCount;               // Used to count clients using the job's tif.
    LPTSTR              QueueFileName;              // The name of the file where the job is persisted (full path)

    __declspec(property(get=GetStatus, put=PutStatus)) // JobStatus is a virtual property
    DWORD               JobStatus;                  // job status, see JS defines

    DWORD               PageCount;                  // Th total number of pages in the fax document.
    LPTSTR FileName;    // For a parent job this is the full path to the body file.
                        // for a recipient job that is aimed at EFSP this is NULL.
                        // for a recipient job aimed at legacy FSP this is the full path
                        // to the file to provide to the FSP. This can be the body file
                        // a rendered coverpage file or a merge or the coverpage file and the
                        // body file.
                        // for a receive/route job this is the file into which the FSP
                        // writes the received FAX.
    //=========================== END   COMMON ============================

    //=========================== BEGIN PARENT ============================
    FAX_JOB_PARAM_EXW JobParamsEx;                  // Extended job parameters the job
                                                    // was submitted with.
    FAX_COVERPAGE_INFO_EXW CoverPageEx;
    LIST_ENTRY RecipientJobs;                       // A linked list of JOB_QUEUE_PTR structures
                                                    // pointing to the recipient jobs of the parent.
    DWORD dwRecipientJobsCount;
    FAX_PERSONAL_PROFILE SenderProfile;
    DWORD dwCompletedRecipientJobsCount;
    DWORD dwCanceledRecipientJobsCount;
    DWORD dwFailedRecipientJobsCount;
    DWORD               FileSize;                   // file size in bytes, up to 4Gb
    LPVOID              DeliveryReportProfile;      // Pointer to the MAPI profile object that is
                                                    // is created in order to deliver the reciept.
    LPTSTR              UserName;                   // The OS name of the user sending the fax.
                                                    // For receive jobs this is set to the service name.

    PSID                UserSid;
    DWORDLONG           OriginalScheduleTime;
    DWORDLONG           SubmissionTime;
    BOOL                fReceiptSent;               // TRUE if a receipt was already sent for this broadcast job.
    //=========================== END PARENT   ===========================

    //=========================== BEGIN RECIPIENT ===========================
     FAX_PERSONAL_PROFILE RecipientProfile;         // The recipient profile information.
    _JOB_QUEUE * lpParentJob;                       // A pointer to the parent job queue entry.
    DWORD               SendRetries;                // number of times send attempt has been made    
    LPTSTR              PreviewFileName;            // The full path to the preview tiff file.
    CFaxCriticalSection  CsPreview;                  // Used to synchronize access to preview file

    //  Used when FAX_SendDocumentEx() receives translated recipient's fax number
    TCHAR               tczDialableRecipientFaxNumber[SIZEOF_PHONENO];

    //=========================== END   RECIPIENT ===========================

    //=========================== BEGIN RECEIPT ===========================
    DWORDLONG           StartTime;                  // Start time as will appear on receipt (copied from JobEntry)
                                                    // Used for routing jobs also
    DWORDLONG           EndTime;                    // End time as will appear on receipt (copied from JobEntry)
                                                    // Used for routing jobs also
    //=========================== END   RECEIPT ===========================

    WCHAR               ExStatusString[EX_STATUS_STRING_LEN]; // The last extended status string of this job (when it was active)
    DWORD               dwLastJobExtendedStatus;    // The last extended status of this job (when it was active)

    //=========================== BEGIN ROUTE   ===========================
    LIST_ENTRY          FaxRouteFiles;              // list of files to be routed
    DWORD               CountFaxRouteFiles;         // count of files to be routed
    CFaxCriticalSection  CsFileList;                 // file list lock
    LIST_ENTRY          RoutingDataOverride;        //
    CFaxCriticalSection  CsRoutingDataOverride;      //
    PFAX_ROUTE          FaxRoute;
    DWORD               CountFailureInfo;           // number of ROUTE_FAILURE_INFO structs that follow
    PROUTE_FAILURE_INFO pRouteFailureInfo;          // Pointer to an array of ROUTE_FAILURE_INFO structs
    //=========================== END   ROUTE  ===========================
    
	//=========================== BEGIN RECIEVE   ===========================
	BOOL				fDeleteReceivedTiff;		// FALSE if the received tiff failed to archive succesfully. It will remain in the queue.
	//=========================== END RECIEVE   ===========================

    _JOB_QUEUE() : m_dwJobStatus(JS_INVALID) {}
    ~_JOB_QUEUE();

    DWORD GetStatus()
    {
      return m_dwJobStatus;
    }

    void PutStatus(DWORD dwStatus);

private:
    DWORD m_dwJobStatus;

} JOB_QUEUE, *PJOB_QUEUE;

typedef JOB_QUEUE * PJOB_QUEUE;
typedef const JOB_QUEUE * PCJOB_QUEUE;

typedef struct _JOB_QUEUE_PTR {
    LIST_ENTRY      ListEntry;
    PJOB_QUEUE      lpJob;
} JOB_QUEUE_PTR, * PJOB_QUEUE_PTR;



typedef struct _JOB_QUEUE_FILE {
    DWORD               SizeOfStruct;               // size of this structure
    //=========================== BEGIN COMMON ===========================
    DWORDLONG           UniqueId;                   //
    DWORDLONG           ScheduleTime;               // schedule time in 64bit version after converting from
                                                    // SYSTEMTIME and recacluating to fit the discount time
                                                    // if necessary.
    DWORD               JobType;                    // job type, see JT defines
    LPTSTR              QueueFileName;              //
    DWORD               JobStatus;                  // job status, see JS defines
    DWORD               PageCount;                  // total pages
    //=========================== END   COMMON ============================

    //=========================== BEGIN RECIPIENT/PARENT ==================
    LPTSTR FileName;                                // Body TIFF file name.
                                                    // For each recipient this is set to
                                                    // the parent file name or in the case of
                                                    // a legacy FSP to the cover page or
                                                    // merged cover+body file.

    //=========================== END RECEIVE/PARENT ======================

    //=========================== BEGIN PARENT ============================
    FAX_JOB_PARAM_EXW JobParamsEx;
    FAX_COVERPAGE_INFO_EXW CoverPageEx;

    DWORD dwRecipientJobsCount;
    FAX_PERSONAL_PROFILE SenderProfile;
    DWORD dwCompletedRecipientJobsCount;
    DWORD dwCanceledRecipientJobsCount;
    DWORD               FileSize;                   // file size in bytes, up to 4Gb
    LPTSTR              DeliveryReportAddress;      //
    DWORD               DeliveryReportType;         //
    LPTSTR              UserName;                   // The OS name of the user sending the fax.
                                                    // For receive jobs this is set to the service name.
    PSID                UserSid;                    // Pointer to the user SID
    DWORDLONG           OriginalScheduleTime;
    DWORDLONG           SubmissionTime;
    //=========================== END PARENT   ===========================

    //=========================== BEGIN RECIPIENT ===========================
    FAX_PERSONAL_PROFILE RecipientProfile;          // The recipient profile information.
    DWORDLONG           dwlParentJobUniqueId;       // The unique id of the parent job
    DWORD               SendRetries;                // number of times send attempt has been made
    TCHAR               tczDialableRecipientFaxNumber[SIZEOF_PHONENO];  //  see _JOB_QUEUE for description
    //=========================== END   RECIPIENT ===========================

    //=========================== BEGIN RECIEVE   ===========================
    DWORD               FaxRouteSize;
    PFAX_ROUTE          FaxRoute;
    DWORD               CountFaxRouteFiles;         // count of files to be routed
    DWORD               FaxRouteFileGuid;           // offset array of GUID's
    DWORD               FaxRouteFiles;              // offset to a multi-sz of filenames
    DWORD               CountFailureInfo;           // number of ROUTE_FAILURE_INFO structs that follow
    PROUTE_FAILURE_INFO pRouteFailureInfo;          // Pointer to an array of ROUTE_FAILURE_INFO structs
    //=========================== END   RECIEVE   ===========================
    FSPI_MESSAGE_ID     EFSPPermanentMessageId;
    //=========================== BEGIN RECEIPT ===========================
    DWORDLONG           StartTime;                  // Start time as will appear on receipt (copied from JobEntry)
                                                    // Used for routing jobs also
    DWORDLONG           EndTime;                    // End time as will appear on receipt (copied from JobEntry)
                                                    // Used for routing jobs also
    //=========================== END   RECEIPT ===========================

    WCHAR               ExStatusString[EX_STATUS_STRING_LEN]; // The last extended status string of this job (when it was active)
    DWORD               dwLastJobExtendedStatus;    // The last extended status of this job (when it was active)

} JOB_QUEUE_FILE, *PJOB_QUEUE_FILE;


typedef struct _BOS_JOB_QUEUE_FILE {
    DWORD               SizeOfStruct;               // size of this structure
    //=========================== BEGIN COMMON ===========================
    DWORDLONG           UniqueId;                   //
    DWORDLONG           ScheduleTime;               // schedule time in 64bit version after converting from
                                                    // SYSTEMTIME and recacluating to fit the discount time
                                                    // if necessary.
    DWORD               JobType;                    // job type, see JT defines
    LPTSTR              QueueFileName;              //
    DWORD               JobStatus;                  // job status, see JS defines
    DWORD               PageCount;                  // total pages
    //=========================== END   COMMON ============================

    //=========================== BEGIN RECIPIENT/PARENT ==================
    LPTSTR FileName;                                // Body TIFF file name.
                                                    // For each recipient this is set to
                                                    // the parent file name or in the case of
                                                    // a legacy FSP to the cover page or
                                                    // merged cover+body file.

    //=========================== END RECEIVE/PARENT ======================

    //=========================== BEGIN PARENT ============================
    FAX_JOB_PARAM_EXW JobParamsEx;
    FAX_COVERPAGE_INFO_EXW CoverPageEx;

    DWORD dwRecipientJobsCount;
    FAX_PERSONAL_PROFILE SenderProfile;
    DWORD dwCompletedRecipientJobsCount;
    DWORD dwCanceledRecipientJobsCount;
    DWORD               FileSize;                   // BUGBUG - file size in bytes, up to 4Gb
    LPTSTR              DeliveryReportAddress;      //
    DWORD               DeliveryReportType;         //
    LPTSTR              UserName;                   // The OS name of the user sending the fax.
                                                    // For receive jobs this is set to the service name.
    PSID                UserSid;                    // Pointer to the user SID
    DWORDLONG           OriginalScheduleTime;
    DWORDLONG           SubmissionTime;
    //=========================== END PARENT   ===========================

    //=========================== BEGIN RECIPIENT ===========================
    FAX_PERSONAL_PROFILE RecipientProfile;          // The recipient profile information.
    DWORDLONG           dwlParentJobUniqueId;       // The unique id of the parent job
    DWORD               SendRetries;                // number of times send attempt has been made
    //=========================== END   RECIPIENT ===========================

    //=========================== BEGIN RECIEVE   ===========================
    DWORD               FaxRouteSize;
    PFAX_ROUTE          FaxRoute;
    DWORD               CountFaxRouteFiles;         // count of files to be routed
    DWORD               FaxRouteFileGuid;           // offset array of GUID's
    DWORD               FaxRouteFiles;              // offset to a multi-sz of filenames
    DWORD               CountFailureInfo;           // number of ROUTE_FAILURE_INFO structs that follow
    PROUTE_FAILURE_INFO pRouteFailureInfo;          // Pointer to an array of ROUTE_FAILURE_INFO structs
    //=========================== END   RECIEVE   ===========================    
	FSPI_MESSAGE_ID     EFSPPermanentMessageId;
    //=========================== BEGIN RECEIPT ===========================
    DWORDLONG           StartTime;                  // Start time as will appear on receipt (copied from JobEntry)
                                                    // Used for routing jobs also
    DWORDLONG           EndTime;                    // End time as will appear on receipt (copied from JobEntry)
                                                    // Used for routing jobs also
    //=========================== END   RECEIPT ===========================

    WCHAR               ExStatusString[EX_STATUS_STRING_LEN]; // The last extended status string of this job (when it was active)
    DWORD               dwLastJobExtendedStatus;    // The last extended status of this job (when it was active)

} BOS_JOB_QUEUE_FILE, *BOS_PJOB_QUEUE_FILE;


typedef struct _FAX_SEND_ITEM {
    PJOB_ENTRY          JobEntry;                   //
    LPTSTR              FileName;                   // The following items are copied from the FAX_JOB_PARAM struct
    LPTSTR              PhoneNumber;                // RecipientNumber
    LPTSTR              Tsid;                       // TSID
    LPTSTR              RecipientName;              //
    LPTSTR              SenderName;                 //
    LPTSTR              SenderCompany;              //
    LPTSTR              SenderDept;                 //
    LPTSTR              BillingCode;                //
    LPTSTR              DocumentName;               //
} FAX_SEND_ITEM, *PFAX_SEND_ITEM;

typedef struct _ROUTE_INFO {
    DWORD               Signature;                  // file signature
    DWORD               StringSize;                 // size of strings in bytes
    DWORD               FailureSize;                // size of failure data in bytes
    LPWSTR              TiffFileName;               // original tiff file name
    LPWSTR              ReceiverName;               // receiver's name
    LPWSTR              ReceiverNumber;             // receiver's fax number
    LPWSTR              DeviceName;                 // device name on which the fax was received
    LPWSTR              Csid;                       // calling station's identifier
    LPWSTR              Tsid;                       // transmitter's station identifier
    LPWSTR              CallerId;                   // caller id information
    LPWSTR              RoutingInfo;                // routing info: DID, T.30 subaddress, etc.
    DWORDLONG           ElapsedTime;                // elapsed time for fax receive
//  DWORD               RouteFailureCount;          // number of failure data blocks
//  ROUTE_FAILURE_INFO  RouteFailure[...];          // routing failure data blocks
} ROUTE_INFO, *PROUTE_INFO;

typedef struct _MESSAGEBOX_DATA {
    LPTSTR              Text;                       //
    LPDWORD             Response;                   //
    DWORD               Type;                       //
} MESSAGEBOX_DATA, *PMESSAGEBOX_DATA;

typedef struct _FAX_RECEIVE_ITEM {
    PJOB_ENTRY          JobEntry;                   //
    HCALL               hCall;                      //
    PLINE_INFO          LineInfo;                   //
    LPTSTR              FileName;                   //
} FAX_RECEIVE_ITEM, *PFAX_RECEIVE_ITEM;

typedef struct _FAX_CLIENT_DATA {
    LIST_ENTRY          ListEntry;                  //
    handle_t            hBinding;                   //
    handle_t            FaxHandle;                  //
    WCHAR               wstrMachineName[MAX_COMPUTERNAME_LENGTH + 1];   // Machine name
    WCHAR               wstrEndPoint[MAX_ENDPOINT_LEN];                 // End point used for RPC connection
    ULONG64             Context;                    //
    HANDLE              FaxClientHandle;            //
    BOOL                bEventEx;                   // TRUE if the registration is for FAX_EVENT_EX, FALSE for FAX_EVENT
    DWORD               EventTypes;                 // Bit wise combination of FAX_ENUM_EVENT_TYPE
    PSID                UserSid;                    // Pointer to the user SID
} FAX_CLIENT_DATA, *PFAX_CLIENT_DATA;

typedef struct _MDM_DEVSPEC {
    DWORD Contents;     // Set to 1 (indicates containing key)
    DWORD KeyOffset;    // Offset to key from start of this struct.
                        // (not from start of LINEDEVCAPS ).
                        //  8 in our case.
    CHAR String[1];     // place containing null-terminated registry key.
} MDM_DEVSPEC, *PMDM_DEVSPEC;

//
// fax handle defines & structs
//
typedef enum
{
    FHT_SERVICE,            // Handle to server (FaxConnectFaxServer)
    FHT_PORT,               // Port Handle (FaxOpenPort)
    FHT_MSGENUM,            // Message enumeration handle (FaxStartMessagesEnum)
    FHT_COPY                // RPC copy context handle
} FaxHandleType;


typedef struct _HANDLE_ENTRY
{
    LIST_ENTRY          ListEntry;                  // linked list pointers
    handle_t            hBinding;                   //
    FaxHandleType       Type;                       // handle type, see FHT defines
    PLINE_INFO          LineInfo;                   // pointer to line information
    DWORD               Flags;                      // open flags
    BOOL                bReleased;                  // The connection is not counted in the g_ReferenceCount
    DWORD               dwClientAPIVersion;         // The API version of the connected client
    //
    // The following fields are used to enumerate files in the archive
    //
    HANDLE              hFile;                      // Handle used in enumeration / copy
    WCHAR               wstrFileName[MAX_PATH];     // Name of first file found (enumeration)
                                                    // or file being copied (RPC copy)
    FAX_ENUM_MESSAGE_FOLDER Folder;                 // Enumeration folder
    //
    // The following field is used for RPC copy
    //
    BOOL                bCopyToServer;              // Copy direction
    BOOL                bError;                     // Was there an error during the RPC copy?
    PJOB_QUEUE          pJobQueue;                  // Pointer to the job queue of the preview file (copy from server)
                                                    // NULL if it is an archived file
} HANDLE_ENTRY, *PHANDLE_ENTRY;

typedef struct _DEVICE_SORT {
    DWORD       Priority;
    PLINE_INFO  LineInfo;
} DEVICE_SORT, *PDEVICE_SORT;

typedef struct _METHOD_SORT {
    DWORD               Priority;
    PROUTING_METHOD     RoutingMethod;
} METHOD_SORT, *PMETHOD_SORT;

typedef struct _QUEUE_SORT {
    FAX_ENUM_PRIORITY_TYPE  Priority;
    DWORDLONG               ScheduleTime;
    PJOB_QUEUE              QueueEntry;
} QUEUE_SORT, *PQUEUE_SORT;


typedef struct _FSPI_JOB_STATUS_MSG_tag
{
    PJOB_ENTRY lpJobEntry;
    LPFSPI_JOB_STATUS lpFSPIJobStatus;
} FSPI_JOB_STATUS_MSG;
typedef FSPI_JOB_STATUS_MSG * LPFSPI_JOB_STATUS_MSG;
typedef const FSPI_JOB_STATUS_MSG * LPCFSPI_JOB_STATUS_MSG;



typedef struct _STRING_TABLE {
    DWORD   ResourceId;
    DWORD   InternalId;
    LPTSTR  String;
} STRING_TABLE, *PSTRING_TABLE;



//
// externs
//
extern HLINEAPP            g_hLineApp;              //
extern CFaxCriticalSection    g_CsJob;                 // protects the job list
extern CFaxCriticalSection    g_CsConfig;              // Protects configuration read / write
extern CFaxCriticalSection    g_CsRouting;             //
extern PFAX_PERF_COUNTERS  g_pFaxPerfCounters;      //
extern LIST_ENTRY          g_JobListHead;           //
extern CFaxCriticalSection    g_CsLine;                // critical section for accessing tapi lines
extern CFaxCriticalSection    g_CsPerfCounters;        // critical section for performance monitor counters
extern DWORD               g_dwTotalSeconds;        // use to compute g_pFaxPerfCounters->TotalMinutes
extern DWORD               g_dwInboundSeconds;      //
extern DWORD               g_dwOutboundSeconds;     //
extern LIST_ENTRY          g_TapiLinesListHead;     // linked list of tapi lines
extern CFaxCriticalSection    g_CsClients;               //
extern HANDLE              g_TapiCompletionPort;    //
extern HANDLE              g_hTapiWorkerThread;     // Tapi worker thread handle
extern HANDLE              g_hJobQueueThread;     // JobQueueThread handle
extern HANDLE              g_StatusCompletionPortHandle;
extern DWORD               g_dwCountRoutingMethods; // total number of routing methods for ALL extensions
extern LIST_ENTRY          g_QueueListHead;           //
extern CFaxCriticalSection    g_CsQueue;                 //
extern HANDLE              g_hQueueTimer;             //
extern DWORD               g_dwNextJobId;             //
extern const GUID          gc_FaxSvcGuid;             //
extern DWORD               g_dwFaxSendRetries;        //
extern DWORD               g_dwFaxSendRetryDelay;     //
extern DWORD               g_dwFaxDirtyDays;          //
extern BOOL                g_fFaxUseDeviceTsid;       //
extern BOOL                g_fFaxUseBranding;         //
extern BOOL                g_fServerCp;               //
extern FAX_TIME            g_StartCheapTime;          //
extern FAX_TIME            g_StopCheapTime;           //
extern WCHAR               g_wszFaxQueueDir[MAX_PATH];   //
extern HANDLE              g_hJobQueueEvent;           //
extern DWORD               g_dwLastUniqueLineId;    // The last device id handed out by the Fax Service.
extern DWORD               g_dwQueueState;          // The state of the queue (paused, blocked, etc.)
extern FAX_SERVER_RECEIPTS_CONFIGW    g_ReceiptsConfig;            // Global receipts configuration
extern FAX_ARCHIVE_CONFIG  g_ArchivesConfig[2];     // Global archives configuration
extern FAX_SERVER_ACTIVITY_LOGGING_CONFIG g_ActivityLoggingConfig; // Global activity logging configuration
extern BOOL                g_bServiceIsDown;        // This is set to TRUE by FaxEndSvc()
extern HANDLE              g_hServiceIsDownSemaphore;   // Syncronize TapiWorkerThread() , JobQueueThread() and EndFaxSvc() access to g_bServiceIsDown flag.
extern FAX_SERVER_ACTIVITY g_ServerActivity;        //  Global Fax Service Activity
extern CFaxCriticalSection    g_CsActivity;              // Controls access to g_ServerActivity;
extern CFaxCriticalSection    g_CsInboundActivityLogging;    // Controls access to Inbound Activity logging configuration;
extern CFaxCriticalSection    g_CsOutboundActivityLogging;   // Controls access to Outbound Activity logging configuration;
                                                        //
                                                        // Important!! - Always lock g_CsInboundActivityLogging and then g_CsOutboundActivityLogging
                                                        //
extern DWORD               g_dwReceiveDevicesCount; // Count of devices that are receive-enabled. Protected by g_CsLine.
extern BOOL                g_ScanQueueAfterTimeout;     // The JobQueueThread checks this if waked up after JOB_QUEUE_TIMEOUT. Use g_CsQueue.
                                                        // If it is TRUE - g_hQueueTimer or g_hJobQueueEvent were not set - Scan the queue.
extern DWORD               g_dwMaxLineCloseTime;        // Wait interval in sec before trying to resend on a powered off device
extern CFaxCriticalSection    g_CsServiceThreads;      // Controls service global threads count
extern LONG                g_lServiceThreadsCount;  // Service threads count
extern HANDLE              g_hThreadCountEvent;     // This Event is set when the service threads count is 0.
extern HANDLE              g_hSCMServiceShutDownEvent;  // This event is set when SCM tells the service to STOP!
extern HANDLE              g_hServiceShutDownEvent;     // This event is set after the service got g_hSCMServiceShutDownEvent from SCM and signals the various threads to terminate!
extern DWORD               g_dwConnectionCount;  // Number of active RPC connections
extern DWORD               g_dwQueueCount;      // Count of jobs (both parent and non-parent) in the queue. Protected by g_CsQueue
extern BOOL g_bServiceCanSuicide;       // See description in queue.c
extern BOOL g_bDelaySuicideAttempt;     // See description in queue.c
extern LPLINECOUNTRYLIST g_pLineCountryList;   // The list of countries returned by TAPI
extern DWORD               g_dwManualAnswerDeviceId;    // Id of (one and only) device capable of manual answering (protected by g_CsLine)
extern DWORDLONG           g_dwLastUniqueId;            // Used for generating unique job IDs
extern CFaxCriticalSection  g_CsHandleTable;             // Protects the handles list
extern DWORD               g_dwDeviceCount;              // Total number of devices
extern DWORD               g_dwDeviceEnabledCount;       // Current Send/Receive enabled devices count (protected by g_CsLine)
extern DWORD               g_dwDeviceEnabledLimit;       // Send/Receive enabled devices limit by SKU
extern LPBYTE              g_pAdaptiveFileBuffer;             // list of approved adaptive answer modems
extern LIST_ENTRY          g_DeviceProvidersListHead;
extern BOOL                g_fLogStringTableInit;
extern LOG_STRING_TABLE   g_InboxTable[];                    // Inbox activity logging string table
extern LOG_STRING_TABLE   g_OutboxTable[];                   // Outbox activity logging string table
extern CFaxCriticalSection    g_CsSecurity;
extern PSECURITY_DESCRIPTOR   g_pFaxSD;                    // Fax security descriptor
extern STRING_TABLE          g_ServiceStringTable[];        // Service string table
extern CFaxCriticalSection g_csUniqueQueueFile;
extern const DWORD gc_dwCountInboxTable;
extern const DWORD gc_dwCountOutboxTable;
extern const DWORD gc_dwCountServiceStringTable;
extern HANDLE               g_hFaxPerfCountersMap;  // Handle to the performance counters file mapping;
extern LIST_ENTRY           g_HandleTableListHead;
extern LIST_ENTRY           g_lstRoutingMethods;
extern LIST_ENTRY           g_lstRoutingExtensions;
extern LIST_ENTRY           g_RemovedTapiLinesListHead;
extern HANDLE				g_hRPCListeningThread;  // Thread that waits for all RPC threads to terminate
extern HINSTANCE			g_hResource;	// Handle to fxsres.dll that hold the resources.
extern DWORD				g_dwRecipientsLimit;  // Limits the number of recipients in a single broadcast job. '0' means no limit.
extern DWORD				g_dwAllowRemote;	// If this is non-zero, the service will allow remote calls even if the local printer is not shared.




#if DBG
extern HANDLE g_hCritSecLogFile;
extern LIST_ENTRY g_CritSecListHead;
extern CFaxCriticalSection g_CsCritSecList;
#endif

#define EnterCriticalSectionJobAndQueue \
    EnterCriticalSection(&g_CsJob);       \
    EnterCriticalSection(&g_CsQueue);

#define LeaveCriticalSectionJobAndQueue \
    LeaveCriticalSection(&g_CsQueue);     \
    LeaveCriticalSection(&g_CsJob);



//
// prototypes
//
RPC_STATUS
IsLocalRPCConnectionNP(
	PBOOL pbIsLocal
	);

VOID
FreeMessageBuffer (
    PFAX_MESSAGE pFaxMsg,
    BOOL fDestroy
);

typedef enum
{
    EXCEPTION_SOURCE_UNKNOWN,
    EXCEPTION_SOURCE_FSP,
    EXCEPTION_SOURCE_ROUTING_EXT
} EXCEPTION_SOURCE_TYPE;    

LONG
HandleFaxExtensionFault (
    EXCEPTION_SOURCE_TYPE ExSrc,
    LPCWSTR               lpcswstrExtFriendlyName,
    DWORD                 dwCode
);

BOOL
CommitQueueEntry(
    PJOB_QUEUE JobQueue,
    BOOL       bDeleteFileOnError=TRUE
    );

VOID
FaxServiceMain(
    DWORD argc,
    LPTSTR  *argv
    );

BOOL 
SetServiceIsDownFlag(
    VOID
    );

DWORD 
SetServiceIsDownFlagThread(
    LPVOID pvUnused
    );
    
VOID
FaxServiceCtrlHandler(
    DWORD Opcode
    );

int
DebugService(
    VOID
    );

DWORD
ServiceStart(
    VOID
    );

void EndFaxSvc(
    DWORD Severity
    );
    
BOOL
StopFaxServiceProviders();    

BOOL 
WaitAndReportForThreadToTerminate(
    HANDLE hThread, 
    LPCTSTR strWaitMessage
    );

BOOL 
StopAllInProgressJobs(
    VOID
    );

BOOL
ReportServiceStatus(
    DWORD CurrentState,
    DWORD Win32ExitCode,
    DWORD WaitHint
    );


//
// Fax Server RPC Client
//

DWORD
RpcBindToFaxClient(
    IN  LPCWSTR               servername,
    IN  LPCWSTR               servicename,
    OUT RPC_BINDING_HANDLE    *pBindingHandle
    );


//
// Fax Server RPC Server
//

RPC_STATUS
StartFaxRpcServer(
    IN  LPWSTR              InterfaceName,
    IN  RPC_IF_HANDLE       InterfaceSpecification
    );

DWORD
StopFaxRpcServer(
    VOID
    );



//
// util.c
//

LPTSTR
MapFSPIJobExtendedStatusToString (
	DWORD dwFSPIExtendedStatus);
	

DWORD
LegacyJobStatusToStatus(
    DWORD dwLegacyStatus,
    PDWORD pdwStatus,
    PDWORD pdwExtendedStatus,
    PBOOL  pbPrivateStatusCode);


DWORD MyGetFileSize(
    LPCTSTR FileName
    );


BOOL
DecreaseServiceThreadsCount(
    VOID
    );

HANDLE CreateThreadAndRefCount(
    LPSECURITY_ATTRIBUTES lpThreadAttributes, // SD
    DWORD dwStackSize,                        // initial stack size
    LPTHREAD_START_ROUTINE lpStartAddress,    // thread function
    LPVOID lpParameter,                       // thread argument
    DWORD dwCreationFlags,                    // creation option
    LPDWORD lpThreadId                        // thread identifier
    );

DWORD
IsValidFaxFolder(
    LPCWSTR lpwstrFolder
    );


//
// tapi.c
//

BOOL
IsDeviceEnabled(
    PLINE_INFO pLineInfo
    );

void
FreeTapiLines(
    void
    );

BOOL
CreateTapiThread(void);


DWORD
TapiInitialize(
    PREG_FAX_SERVICE FaxReg
    );

DWORD
UpdateDevicesFlags(
    void
    );

VOID
UpdateManualAnswerDevice(
    void
    );

VOID
FreeTapiLine(
    PLINE_INFO LineInfo
    );

PLINE_INFO
GetTapiLineFromDeviceId(
    DWORD DeviceId,
    BOOL  fLegacyId
    );

PLINE_INFO
GetLineForSendOperation(
    PJOB_QUEUE lpJobQueue
	);

PLINE_INFO
GetTapiLineForFaxOperation(
    DWORD DeviceId,
    DWORD JobType,
    LPWSTR FaxNumber    
    );

LONG
MyLineTranslateAddress(
    LPCTSTR               Address,
    DWORD                 DeviceId,
    LPLINETRANSLATEOUTPUT *TranslateOutput
    );


BOOL
ReleaseTapiLine(
    PLINE_INFO LineInfo,
    HCALL hCall
    );

DWORD
QueueTapiCallback(
    PLINE_INFO  LineInfo,
    DWORD       hDevice,
    DWORD       dwMessage,
    DWORD       dwInstance,
    DWORD       dwParam1,
    DWORD       dwParam2,
    DWORD       dwParam3
    );

VOID
SpoolerSetAllTapiLinesActive(
    VOID
    );


DWORD
GetDeviceListByCountryAndAreaCode(
    DWORD       dwCountryCode,
    DWORD       dwAreaCode,
    LPDWORD*    lppdwDevices,
    LPDWORD     lpdwNumDevices
    );

BOOL
IsAreaCodeMandatory(
    LPLINECOUNTRYLIST   lpCountryList,
    DWORD               dwCountryCode
    );



//
// tapidbg.c
//
#if DBG
VOID
ShowLineEvent(
    HLINE       htLine,
    HCALL       htCall,
    LPTSTR      MsgStr,
    DWORD_PTR   dwCallbackInstance,
    DWORD       dwMsg,
    DWORD_PTR   dwParam1,
    DWORD_PTR   dwParam2,
    DWORD_PTR   dwParam3
    );
#endif // #if DBG

//
// faxdev.c
//
void
UnloadDeviceProviders(
    void
    );

BOOL
LoadDeviceProviders(
    PREG_FAX_SERVICE FaxReg
    );

BOOL
InitializeDeviceProviders(
    VOID
    );

BOOL
InitializeDeviceProvidersConfiguration(
    VOID
    );

PDEVICE_PROVIDER
FindDeviceProvider(
    LPTSTR lptstrProviderName,
    BOOL   bSuccessfullyLoaded = TRUE
    );

DWORD GetSuccessfullyLoadedProvidersCount();

DWORD ShutdownDeviceProviders(LPVOID lpvUnused);

BOOL FreeFSPIJobStatus(LPFSPI_JOB_STATUS lpJobStatus, BOOL bDestroy);
BOOL CopyFSPIJobStatus(LPFSPI_JOB_STATUS lpDst, LPCFSPI_JOB_STATUS lpcSrc, DWORD dwDstSize);
LPFSPI_JOB_STATUS DuplicateFSPIJobStatus(LPCFSPI_JOB_STATUS lpcSrc);
DWORD DeviceStatusToFSPIExtendedStatus(DWORD dwDeviceStatus);
DWORD FSPIExtendedStatusToDeviceStatus(DWORD dwFSPIExtendedStatus);
BOOL FreeFSPIJobStatusMsg(LPFSPI_JOB_STATUS_MSG lpMsg, BOOL bDestroy);

DWORD
MapFSPIJobExtendedStatusToJS_EX (DWORD dwFSPIExtendedStatus);

//
// job.c
//

BOOL
UpdateJobStatus(
    PJOB_ENTRY lpJobEntry,
    LPCFSPI_JOB_STATUS lpcFSPJobStatus
    );

BOOL
CreateCoverpageTiffFileEx(
    IN short                        Resolution,
    IN DWORD                        dwPageCount,
    IN LPCFAX_COVERPAGE_INFO_EXW  lpcCoverpageEx,
    IN LPCFAX_PERSONAL_PROFILEW  lpcRecipient,
    IN LPCFAX_PERSONAL_PROFILEW  lpcSender,
    IN LPCWSTR                   lpcwstrExtension,
    OUT LPWSTR lptstrCovTiffFile,
	IN DWORD dwCovTiffFile);

BOOL
GetBodyTiffResolution(
    IN LPCWSTR lpcwstrBodyFile,
    OUT short*  pResolution
    );

BOOL
CreateStatusThreads(void);

BOOL
CreateJobQueueThread(void);


BOOL
FreePermanentMessageId(
    LPFSPI_MESSAGE_ID lpMessageId,
    BOOL bDestroy
    );


PJOB_ENTRY
FindJobEntryByRecipientNumber(LPCWSTR lpcwstrNumber);


PJOB_ENTRY
StartReceiveJob(
    DWORD DeviceId
    );



BOOL
StartSendJob(
    PJOB_QUEUE lpJobQueueEntry,
    PLINE_INFO lpLineInfo    
    );

BOOL
StartRoutingJob(
    PJOB_QUEUE lpJobQueueEntry
    );


BOOL HanldeFSPIJobStatusChange(PJOB_ENTRY lpJobEntry);
BOOL HandleFailedSendJob(PJOB_ENTRY lpJobEntry);
BOOL HandleCompletedSendJob(PJOB_ENTRY lpJobEntry);

BOOL
ArchiveOutboundJob(
    const JOB_QUEUE * lpcJobQueue
    );

BOOL
InitializeJobManager(
        PREG_FAX_SERVICE FaxReg
    );

BOOL
EndJob(
    IN PJOB_ENTRY JobEntry
    );

BOOL
ReleaseJob(
    IN PJOB_ENTRY JobEntry
    );

DWORD
SendDocument(
    PJOB_ENTRY  JobEntry,
    LPTSTR      FileName);

VOID
SetGlobalsFromRegistry(
    PREG_FAX_SERVICE FaxReg
    );

void
FaxLogSend(
    const JOB_QUEUE * lpcJobQueue, BOOL bRetrying
    );


BOOL
FillMsTagInfo(
    LPTSTR FaxFileName,
     PJOB_QUEUE lpJobQueue
    );

BOOL
GetJobStatusDataEx(
    LPBYTE JobBuffer,
    PFAX_JOB_STATUSW pFaxStatus,
    DWORD dwClientAPIVersion,
    const PJOB_QUEUE lpcJobQueue,
    PULONG_PTR Offset,
	DWORD dwBufferSize
    );

BOOL
CreateTiffFile (
    PJOB_QUEUE lpRecpJob,
    LPCWSTR lpcwstrFileExt,
    LPWSTR lpwstrFullPath,
	DWORD dwFullPathCount
    );

BOOL
CreateTiffFileForJob (
    PJOB_QUEUE lpRecpJob
    );

BOOL
CreateTiffFileForPreview (
    PJOB_QUEUE lpRecpJob
    );

//
// receive.c
//

DWORD
StartFaxReceive(
    PJOB_ENTRY      JobEntry,
    HCALL           hCall,
    PLINE_INFO      LineInfo,
    LPTSTR          FileName,
    DWORD           FileNameSize
    );

//
// route.c
//

void
FreeRoutingExtensions(
    void
    );

BOOL
InitializeRouting(
    PREG_FAX_SERVICE FaxReg
    );


BOOL
FaxRoute(
    PJOB_QUEUE          JobQueue,
    LPTSTR              TiffFileName,
    PFAX_ROUTE          FaxRoute,
    PROUTE_FAILURE_INFO *RouteFailureInfo,
    LPDWORD             RouteFailureCount
    );


BOOL
LoadRouteInfo(
    IN  LPWSTR              RouteFileName,
    OUT PROUTE_INFO         *RouteInfo,
    OUT PROUTE_FAILURE_INFO *RouteFailure,
    OUT LPDWORD             RouteFailureCount
    );

PFAX_ROUTE
SerializeFaxRoute(
    IN PFAX_ROUTE FaxRoute,
    IN LPDWORD Size,
    IN BOOL bSizeOnly
    );

PFAX_ROUTE
DeSerializeFaxRoute(
    IN PFAX_ROUTE FaxRoute
    );

BOOL
FaxRouteRetry(
    PFAX_ROUTE FaxRoute,
    PROUTE_FAILURE_INFO RouteFailureInfo
    );

//
// modem.c
//

DWORD
GetModemClass(
    HANDLE hFile
    );

//
// print.c
//



LPTSTR
GetString(
    DWORD InternalId
    );


BOOL CALLBACK
FaxDeviceProviderCallback(
    IN HANDLE FaxHandle,
    IN DWORD  DeviceId,
    IN DWORD_PTR  Param1,
    IN DWORD_PTR  Param2,
    IN DWORD_PTR  Param3
    );

BOOL
InitializePrinting(
    VOID
    );

PJOB_ENTRY
FindJob(
    IN HANDLE FaxHandle
    );

PJOB_ENTRY
FindJobByPrintJob(
    IN DWORD PrintJobId
    );

BOOL
HandoffCallToRas(
    PLINE_INFO LineInfo,
    HCALL hCall
    );


BOOL
InitializeStringTable(
    VOID
    );

BOOL
InitializeFaxQueue(
    PREG_FAX_SERVICE pFaxReg
    );

BOOL
OpenTapiLine(
    PLINE_INFO LineInfo
    );

PVOID
MyGetJob(
    HANDLE  hPrinter,
    DWORD   level,
    DWORD   jobId
    );

LONG
MyLineGetTransCaps(
    LPLINETRANSLATECAPS *LineTransCaps
    );

BOOL
GenerateUniqueArchiveFileName(
    IN LPTSTR Directory,
    OUT LPTSTR FileName,
    IN UINT cchFileName,
    IN DWORDLONG JobId,
    IN LPTSTR lptstrUserSid
    );

VOID
SetLineState(
    PLINE_INFO LineInfo,
    DWORD State
    );

BOOL
CreateFaxEvent(
    DWORD DeviceId,
    DWORD EventId,
    DWORD JobId
    );

BOOL
GetFaxEvent(
    PLINE_INFO LineInfo,
    PFAX_EVENT Event
    );

DWORD
MapFSPIJobStatusToEventId(
    LPCFSPI_JOB_STATUS lpcFSPIJobStatus
    );

void
FreeServiceContextHandles(
    void
    );


PHANDLE_ENTRY
CreateNewPortHandle(
    handle_t    hBinding,
    PLINE_INFO  LineInfo,
    DWORD       Flags
    );

PHANDLE_ENTRY
CreateNewMsgEnumHandle(
    handle_t                hBinding,
    HANDLE                  hFileFind,
    LPCWSTR                 lpcwstrFirstFileName,
    FAX_ENUM_MESSAGE_FOLDER Folder
);

PHANDLE_ENTRY
CreateNewCopyHandle(
    handle_t                hBinding,
    HANDLE                  hFile,
    BOOL                    bCopyToServer,
    LPCWSTR                 lpcwstrFileName,
    PJOB_QUEUE              pJobQueue
);

PHANDLE_ENTRY
CreateNewConnectionHandle(
    handle_t    hBinding,
    DWORD       dwClientAPIVersion
);

BOOL
IsPortOpenedForModify(
    PLINE_INFO LineInfo
    );

VOID
CloseFaxHandle(
    PHANDLE_ENTRY HandleEntry
    );

LPLINEDEVSTATUS
MyLineGetLineDevStatus(
    HLINE hLine
    );

DWORD
InitializeServerSecurity(
    VOID
    );

DWORD
FaxSvcAccessCheck(
    IN  ACCESS_MASK DesiredAccess,
    OUT BOOL*      lpbAccessStatus,
    OUT LPDWORD    lpdwGrantedAccess
    );

PROUTING_METHOD
FindRoutingMethodByGuid(
    IN LPCWSTR RoutingGuidString
    );

DWORD
EnumerateRoutingMethods(
    IN PFAXROUTEMETHODENUM Enumerator,
    IN LPVOID Context
    );
//
// QUEUE.C
//

void
FreeServiceQueue(
    void
    );

DWORD
RemoveJobStatusModifiers(DWORD dwJobStatus);

VOID
RescheduleJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    );

BOOL
StartJobQueueTimer(
    VOID
    );

BOOL
SetDiscountTime(
    IN OUT LPSYSTEMTIME SystemTime
    );

LPWSTR
GetClientUserName(
    VOID
    );

PSID
GetClientUserSID(
    VOID
    );

BOOL UserOwnsJob(
    IN const PJOB_QUEUE lpcJobQueue,
    IN const PSID lpcUserSId
    );

BOOL
RestoreFaxQueue(
    VOID
    );

PJOB_QUEUE
FindJobQueueEntryByJobQueueEntry(
    IN PJOB_QUEUE JobQueueEntry
    );

PJOB_QUEUE
FindJobQueueEntry(
    IN DWORD JobId
    );

PJOB_QUEUE
FindJobQueueEntryByUniqueId(
    IN DWORDLONG UniqueId
    );

DWORD
JobQueueThread(
    LPVOID UnUsed
    );

BOOL
ResumeJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    );

BOOL
PauseJobQueueEntry(
    IN PJOB_QUEUE JobQueue
    );

BOOL
PauseServerQueue(
    VOID
    );

BOOL
ResumeServerQueue(
    VOID
    );

BOOL
SetFaxServiceAutoStart(
    VOID
    );

DWORD
GetFaxDeviceCount(
    VOID
    );

DWORD
CreateVirtualDevices(
    PREG_FAX_SERVICE FaxReg,
    DWORD dwAPIVersion
    );

BOOL
CommitDeviceChanges(
    PLINE_INFO pLineInfo
    );

BOOL
SortMethodPriorities(
    VOID
    );

BOOL
CommitMethodChanges(
    VOID
    );

VOID
UpdateVirtualDevices(
    VOID
    );

VOID
UpdateVirtualDeviceSendAndReceiveStatus(
    PLINE_INFO  pLineInfo,
    BOOL        bSend,
    BOOL        bReceive
);

BOOL
IsVirtualDevice(
    const LINE_INFO *pLineInfo
    );

DWORD
ValidateTiffFile(
    LPCWSTR TiffFile
    );


BOOL PersonalProfileSerialize(
		LPCFAX_PERSONAL_PROFILEW lpProfileSrc,
		PFAX_PERSONAL_PROFILE lpProfileDst,
		LPBYTE lpbBuffer,
		PULONG_PTR pupOffset,
		DWORD dwBufferSize
		);

void
DecreaseJobRefCount (
    PJOB_QUEUE pJobQueue,
    BOOL       bNotify,
    BOOL bRemoveRecipientJobs = TRUE,
    BOOL bPreview = FALSE
    );

void
IncreaseJobRefCount (
    PJOB_QUEUE pJobQueue,
    BOOL bPreview = FALSE
    );


PJOB_QUEUE_PTR FindRecipientRefByJobId(PJOB_QUEUE lpParentJob,DWORD dwJobId);
BOOL RemoveParentRecipientRef(PJOB_QUEUE lpParentJob,const PJOB_QUEUE lpcRecpJob);
BOOL RemoveParentRecipients(PJOB_QUEUE lpParentJob, BOOL bNotify);

BOOL RemoveRecipientJob(PJOB_QUEUE lpJobToRemove,BOOL bNotify, BOOL bRecalcQueueTimer);
BOOL RemoveParentJob(PJOB_QUEUE lpJobQueue, BOOL bRemoveRecipients, BOOL bNotify);
BOOL RemoveReceiveJob(PJOB_QUEUE lpJobToRemove,BOOL bNotify);


BOOL CopyJobParamEx(PFAX_JOB_PARAM_EXW lpDst,LPCFAX_JOB_PARAM_EXW lpcSrc);
void FreeJobParamEx(PFAX_JOB_PARAM_EXW lpJobParamEx,BOOL bDestroy);
#if DBG
void DumpJobParamsEx( LPCFAX_JOB_PARAM_EX lpParams);
#endif


BOOL CopyCoverPageInfoEx(PFAX_COVERPAGE_INFO_EXW lpDst,LPCFAX_COVERPAGE_INFO_EXW lpcSrc);
void FreeCoverPageInfoEx(PFAX_COVERPAGE_INFO_EXW lpCoverpage, BOOL bDestroy) ;
#if DBG
void DumpCoverPageEx(LPCFAX_COVERPAGE_INFO_EX lpcCover);
#endif


void FreeParentQueueEntry(PJOB_QUEUE lpJobQueueEntry, BOOL bDestroy);
#if DBG
void DumpParentJob(const PJOB_QUEUE lpParentJob);
#endif

void FreeRecipientQueueEntry(PJOB_QUEUE lpJobQueue, BOOL bDestroy);
#if DBG
void DumpRecipientJob(const PJOB_QUEUE lpRecipJob) ;
#endif

void FreeReceiveQueueEntry(PJOB_QUEUE lpJobQueue, BOOL bDestroy);
#if DBG
void DumpReceiveJob(const PJOB_QUEUE lpcJob);
#endif


BOOL IsSendJobReadyForDeleting(PJOB_QUEUE lpParentJob);

BOOL SystemTimeToStr( IN const SYSTEMTIME *  lptmTime, OUT LPTSTR lptstrDateTime, IN UINT cchstrDateTime);

BOOL UpdatePersistentJobStatus(const PJOB_QUEUE lpJobQueue);


DWORDLONG GenerateUniqueQueueFile(
    IN DWORD dwJobType,
    OUT LPTSTR lptstrFileName,
    IN DWORD  dwFileNameSize
    );


PJOB_QUEUE
AddParentJob(IN const PLIST_ENTRY lpcQueueHead,
             IN LPCWSTR lpcwstrBodyFile,
             IN LPCFAX_PERSONAL_PROFILE lpcSenderProfile,
             IN LPCFAX_JOB_PARAM_EXW  lpcJobParams,
             IN LPCFAX_COVERPAGE_INFO_EX  lpcCoverPageInfo,
             IN LPCWSTR lpcwstrUserName,
             IN PSID UserSid,
         IN LPCFAX_PERSONAL_PROFILEW lpcRecipientProfile,
             IN BOOL bCreateQueueFile
             );

PJOB_QUEUE
AddRecipientJob(
             IN const PLIST_ENTRY lpcQueueHead,
             IN PJOB_QUEUE lpParentJob,
             IN LPCFAX_PERSONAL_PROFILE lpcRecipientProfile,
             IN BOOL bCreateQueueFile,
             DWORD dwJobStatus = JS_PENDING
            );
PJOB_QUEUE
AddReceiveJobQueueEntry(
    IN LPCTSTR FileName,
    IN PJOB_ENTRY JobEntry,
    IN DWORD JobType, // can be JT_RECEIVE or JT_RECEIVE_FAIL
    IN DWORDLONG dwlUniqueJobID
    );

BOOL MarkJobAsExpired(PJOB_QUEUE lpJobQueue);

DWORD
GetDevStatus(
    HANDLE hFaxJob,
    PLINE_INFO LineInfo,
    LPFSPI_JOB_STATUS *ppFaxStatus
    );

HRESULT
ReportLineStatusToCrm(
    DWORD dwLineState,
    const LINE_INFO *pLineInfo,
    const JOB_QUEUE *pJobQueue
    );

BOOL
GetRealFaxTimeAsSystemTime (
    const PJOB_ENTRY lpcJobEntry,
    FAX_ENUM_TIME_TYPES TimeType,
    SYSTEMTIME* lpFaxTime
    );

BOOL
GetRealFaxTimeAsFileTime (
    const PJOB_ENTRY lpcJobEntry,
    FAX_ENUM_TIME_TYPES TimeType,
    FILETIME* lpFaxTime
    );

BOOL
ReplaceStringWithCopy (
    LPWSTR *plpwstrDst,
    LPWSTR  lpcwstrSrc
);

//
// Logging
//

BOOL
LogInboundActivity(
    PJOB_QUEUE JobQueue,
    LPCFSPI_JOB_STATUS pFaxStatus
    );

DWORD
InitializeLogging(
    VOID
    );


DWORD
InitializeLoggingStringTables(
    VOID
    );

BOOL
LogOutboundActivity(
    PJOB_QUEUE JobQueue
    );

DWORD CreateLogDB (
    LPCWSTR lpcwstrDBPath,
    LPHANDLE phInboxFile,
    LPHANDLE phOutboxFile
    );

VOID
FaxExtFreeBuffer(
    LPVOID lpvBuffer
);

PDEVICE_PROVIDER
FindFSPByGUID (
    LPCWSTR lpcwstrGUID
);


//
// Events.cpp
//

DWORD
InitializeServerEvents (
    void
    );

DWORD
PostFaxEventEx (
    PFAX_EVENT_EX pFaxEvent,
    DWORD dwEventSize,
    PSID pUserSid
    );

DWORD
CreateQueueEvent (
    FAX_ENUM_JOB_EVENT_TYPE JobEventType,
    const PJOB_QUEUE lpcJobQueue
    );

DWORD
CreateConfigEvent (
    FAX_ENUM_CONFIG_TYPE ConfigType
    );

DWORD
CreateQueueStateEvent (
    DWORD dwQueueState
    );

DWORD
CreateDeviceEvent (
    PLINE_INFO pLine,
    BOOL       bRinging
);

DWORD
CreateArchiveEvent (
    DWORDLONG dwlMessageId,
    FAX_ENUM_EVENT_TYPE EventType,
    FAX_ENUM_JOB_EVENT_TYPE MessageEventType,
    PSID pUserSid
    );

DWORD
CreateActivityEvent (
    void
    );

BOOL
SendReceipt(
    BOOL bPositive,
    BOOL bBroadcast,
    const JOB_QUEUE * lpcJobQueue,
    LPCTSTR           lpctstrTIFF
);

VOID
SafeIncIdleCounter (
    LPDWORD lpdwCounter
);

VOID
SafeDecIdleCounter (
    LPDWORD lpdwCounter
);

VOID UpdateReceiveEnabledDevicesCount();

DWORD
GetServerErrorCode (
    DWORD ec
    );

DWORD
FindClientAPIVersion (handle_t);

//
//	This structure is defined because the legacy FAX_COVERPAGE_INFO doesn't have the e-mail field.
//  It is in use only inside functions participating in the rendering proccess.
//  The only difference between FAX_COVERPAGE_INFOW2 and FAX_COVERPAGE_INFO is the e-mail field.
//
typedef struct _FAX_COVERPAGE_INFOW2
{
    DWORD               SizeOfStruct;               // Size of this structure
    //
    // general
    //
    LPCWSTR             CoverPageName;              // coverpage document name
    BOOL                UseServerCoverPage;         // coverpage exists on the fax server
    //
    // Recipient information
    //
    LPCWSTR             RecName;                    //
    LPCWSTR             RecFaxNumber;               //
    LPCWSTR             RecCompany;                 //
    LPCWSTR             RecStreetAddress;           //
    LPCWSTR             RecCity;                    //
    LPCWSTR             RecState;                   //
    LPCWSTR             RecZip;                     //
    LPCWSTR             RecCountry;                 //
    LPCWSTR             RecTitle;                   //
    LPCWSTR             RecDepartment;              //
    LPCWSTR             RecOfficeLocation;          //
    LPCWSTR             RecHomePhone;               //
    LPCWSTR             RecOfficePhone;             //
    //
    // Sender information
    //
    LPCWSTR             SdrName;                    //
    LPCWSTR             SdrFaxNumber;               //
    LPCWSTR             SdrCompany;                 //
    LPCWSTR             SdrAddress;                 //
    LPCWSTR             SdrTitle;                   //
    LPCWSTR             SdrDepartment;              //
    LPCWSTR             SdrOfficeLocation;          //
    LPCWSTR             SdrHomePhone;               //
    LPCWSTR             SdrOfficePhone;             //
	LPCWSTR				SdrEmail;					//
    //
    // Misc information
    //
    LPCWSTR             Note;                       //
    LPCWSTR             Subject;                    //
    SYSTEMTIME          TimeSent;                   // Time the fax was sent
    DWORD               PageCount;                  // Number of pages
} FAX_COVERPAGE_INFOW2, *PFAX_COVERPAGE_INFOW2;

#include "ExtensionData.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\handle.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This module contains the handle table mgmt routines.

Author:

    Wesley Witt (wesw) 12-Nov-1996


Revision History:

--*/

#include "faxsvc.h"
#pragma hdrstop


LIST_ENTRY   g_HandleTableListHead;
CFaxCriticalSection    g_CsHandleTable;

void
FreeServiceContextHandles(
    void
    )
{
    PLIST_ENTRY Next;
    PHANDLE_ENTRY pHandleEntry; 

    Next = g_HandleTableListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_HandleTableListHead)
    {
        pHandleEntry = CONTAINING_RECORD( Next, HANDLE_ENTRY, ListEntry );
        Next = pHandleEntry->ListEntry.Flink;
        CloseFaxHandle (pHandleEntry);       
    }
    return;
}


static 
PHANDLE_ENTRY
CreateNewHandle(
    handle_t        hBinding,
    FaxHandleType   Type,
    DWORD           dwClientAPIVersion, // Used for connection handles
    PLINE_INFO      LineInfo,           // Used for port handles
    DWORD           Flags               // Used for port handles
    )
{
    PHANDLE_ENTRY pHandleEntry;


    pHandleEntry = (PHANDLE_ENTRY) MemAlloc( sizeof(HANDLE_ENTRY) );
    if (!pHandleEntry) 
    {
        return NULL;
    }
    ZeroMemory (pHandleEntry, sizeof(HANDLE_ENTRY));

    pHandleEntry->hBinding              = hBinding;
    pHandleEntry->Type                  = Type;
    pHandleEntry->dwClientAPIVersion    = dwClientAPIVersion;
    pHandleEntry->LineInfo              = LineInfo;
    pHandleEntry->Flags                 = Flags;
    pHandleEntry->bReleased             = FALSE;
    pHandleEntry->hFile                 = INVALID_HANDLE_VALUE;

    EnterCriticalSection( &g_CsHandleTable );
    InsertTailList( &g_HandleTableListHead, &pHandleEntry->ListEntry );
    LeaveCriticalSection( &g_CsHandleTable );
    return pHandleEntry;
}


PHANDLE_ENTRY
CreateNewConnectionHandle(
    handle_t hBinding,
    DWORD    dwClientAPIVersion
    )
{
    return CreateNewHandle(
        hBinding,
        FHT_SERVICE,
        dwClientAPIVersion,
        NULL,   // Unused
        0       // Unused
        );
}

PHANDLE_ENTRY
CreateNewPortHandle(
    handle_t    hBinding,
    PLINE_INFO  LineInfo,
    DWORD       Flags
    )
{
    return CreateNewHandle(
        hBinding,
        FHT_PORT,
        0,          // Unused
        LineInfo,
        Flags
        );
}

PHANDLE_ENTRY
CreateNewMsgEnumHandle(
    handle_t                hBinding,
    HANDLE                  hFileFind,
    LPCWSTR                 lpcwstrFirstFileName,
    FAX_ENUM_MESSAGE_FOLDER Folder
)
/*++

Routine name : CreateNewMsgEnumHandle

Routine description:

    Creates a new context handle for messages enumeration

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hBinding                [in] - RPC Binding handle
    hFileFind               [in] - Find file handle
    lpcwstrFirstFileName    [in] - Name of first file found
    Folder                  [in] - Archive folder type of find file search

Return Value:

    Returns a pointer to a newly created handle

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateNewMsgEnumHandle"));

    Assert (INVALID_HANDLE_VALUE != hFileFind);
    if (MAX_PATH <= lstrlen (lpcwstrFirstFileName))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("String passed is too long (%s)"),
            lpcwstrFirstFileName);
        ASSERT_FALSE;
        return NULL;
    }

    PHANDLE_ENTRY pHandle = CreateNewHandle (hBinding, 
                                             FHT_MSGENUM, 
                                             FindClientAPIVersion(hBinding), // Client API version
                                             NULL,        // Unused
                                             0);          // Unused
    if (!pHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateNewHandle failed"));
        return NULL;
    }
    //
    // Store find file handle and first file in the new context
    //
    pHandle->hFile = hFileFind;
    wcsncpy (pHandle->wstrFileName, lpcwstrFirstFileName, ARR_SIZE(pHandle->wstrFileName)-1);
    pHandle->Folder = Folder;
    return pHandle;
}   // CreateNewMsgEnumHandle

PHANDLE_ENTRY
CreateNewCopyHandle(
    handle_t                hBinding,
    HANDLE                  hFile,
    BOOL                    bCopyToServer,
    LPCWSTR                 lpcwstrFileName,
    PJOB_QUEUE              pJobQueue
)
/*++

Routine name : CreateNewCopyHandle

Routine description:

    Creates a new context handle for RPC copy

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hBinding           [in] - RPC Binding handle
    hFileFind          [in] - File handle
    bCopyToServer      [in] - Copy direction
    lpcwstrFileName    [in] - Name of file generated on the server
                              (in use for rundown purposes only if bCopyToServer is TRUE)
    pJobQueue          [in] - Pointer to the job queue containing thr preview file
                              (in use for rundown purposes only if bCopyToServer is FALSE)

Return Value:

    Returns a pointer to a newly created handle

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("CreateNewCopyHandle"));

    Assert (INVALID_HANDLE_VALUE != hFile);
    PHANDLE_ENTRY pHandle = CreateNewHandle (hBinding, 
                                             FHT_COPY, 
                                             0,          // Unused
                                             NULL,       // Unused
                                             0);         // Unused
    if (!pHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateNewHandle failed"));
        return NULL;
    }
    //
    // Store file handle and direction in the new context
    //
    pHandle->hFile = hFile;
    pHandle->bCopyToServer = bCopyToServer;
    pHandle->bError = FALSE;
    if (bCopyToServer)
    {
        //
        // If this is a copy operation to the server, we keep the name of the file
        // created in the server's queue so that in the rundown operation we can delete this file.
        //
        Assert (lstrlen (lpcwstrFileName) < MAX_PATH); //wstrFileName is MAX_PATH size
        wcsncpy (pHandle->wstrFileName, lpcwstrFileName, ARR_SIZE(pHandle->wstrFileName)-1); 
    }
    else
    {
        pHandle->pJobQueue = pJobQueue;
    }
    return pHandle;
}   // CreateNewCopyHandle


VOID
CloseFaxHandle(
    PHANDLE_ENTRY pHandleEntry
    )
{
    //
    // note that the HandleEntry may be a context handle,
    // which may be NULL in some cases.  Do nothing if
    // this is the case
    //
    DEBUG_FUNCTION_NAME(TEXT("CloseFaxHandle"));
    Assert (pHandleEntry);

    EnterCriticalSection( &g_CsHandleTable );
    RemoveEntryList( &pHandleEntry->ListEntry );
    if ((pHandleEntry->Type == FHT_SERVICE) && !(pHandleEntry->bReleased))
    {
        SafeDecIdleCounter (&g_dwConnectionCount);
    }
    else if (pHandleEntry->Type == FHT_MSGENUM)
    {
        if (!FindClose (pHandleEntry->hFile))
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("FindClose returned error code %ld"),
                      GetLastError());
        }
    }
    else if (pHandleEntry->Type == FHT_COPY)
    {
        
        if (!CloseHandle (pHandleEntry->hFile))
        {
            DebugPrintEx( DEBUG_ERR,
                      TEXT("CloseHandle returned error code %ld"),
                      GetLastError());
        }
        if (pHandleEntry->bError && pHandleEntry->bCopyToServer)
        {
            //
            // We found an error while copying to the server.
            // Remove temporary file created in the server's queue
            //
            if (!DeleteFile (pHandleEntry->wstrFileName))
            {
                DWORD dwRes = GetLastError ();
                DebugPrintEx( DEBUG_ERR,
                              TEXT("DeleteFile (%s) returned error code %ld"),
                              pHandleEntry->wstrFileName,
                              dwRes);
            }
        }
        if (FALSE == pHandleEntry->bCopyToServer)
        {
            if (pHandleEntry->pJobQueue)
            {
                //
                // Decrease ref count only for queued jobs
                //
                EnterCriticalSection (&g_CsQueue);                
                DecreaseJobRefCount (pHandleEntry->pJobQueue, TRUE, TRUE, TRUE);
                LeaveCriticalSection (&g_CsQueue);              
            }
        }
    }
    MemFree( pHandleEntry );
    LeaveCriticalSection( &g_CsHandleTable );
}


BOOL
IsPortOpenedForModify(
    PLINE_INFO LineInfo
    )
{
    PLIST_ENTRY Next;
    PHANDLE_ENTRY HandleEntry;


    EnterCriticalSection( &g_CsHandleTable );

    Next = g_HandleTableListHead.Flink;
    if (Next == NULL)
    {
        LeaveCriticalSection( &g_CsHandleTable );
        return FALSE;
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_HandleTableListHead) {

        HandleEntry = CONTAINING_RECORD( Next, HANDLE_ENTRY, ListEntry );
        if (HandleEntry->Type == FHT_PORT && (HandleEntry->Flags & PORT_OPEN_MODIFY) && HandleEntry->LineInfo == LineInfo)
        {
            LeaveCriticalSection( &g_CsHandleTable );
            return TRUE;
        }

        Next = HandleEntry->ListEntry.Flink;
    }

    LeaveCriticalSection( &g_CsHandleTable );

    return FALSE;
}

DWORD 
FindClientAPIVersion (
    handle_t hFaxHandle
)
/*++

Routine name : FindClientAPIVersion

Routine description:

    Finds the API version of a connected client by its RPC binding handle

Author:

    Eran Yariv (EranY), Mar, 2001

Arguments:

    hFaxHandle   [in]     - RPC binding handle

Return Value:

    Client API version

--*/
{
    PLIST_ENTRY pNext;
    DEBUG_FUNCTION_NAME(TEXT("FindClientAPIVersion"));

    EnterCriticalSection (&g_CsHandleTable);

    pNext = g_HandleTableListHead.Flink;
    if (pNext == NULL) 
    {
        ASSERT_FALSE;
        DebugPrintEx( DEBUG_ERR,
                      TEXT("g_CsHandleTable is corrupted"));
        LeaveCriticalSection (&g_CsHandleTable);
        return FAX_API_VERSION_0;
    }

    while ((ULONG_PTR)pNext != (ULONG_PTR)&g_HandleTableListHead) 
    {
        PHANDLE_ENTRY pHandleEntry = CONTAINING_RECORD(pNext, HANDLE_ENTRY, ListEntry);
        if ( ((FHT_SERVICE == pHandleEntry->Type) || (FHT_MSGENUM == pHandleEntry->Type) ) && 
             (pHandleEntry->hBinding == hFaxHandle)
           )
        {
            DWORD dwRes = pHandleEntry->dwClientAPIVersion;
            LeaveCriticalSection (&g_CsHandleTable);
            return dwRes;
        }
        pNext = pHandleEntry->ListEntry.Flink;
    }

    LeaveCriticalSection (&g_CsHandleTable);
    DebugPrintEx( DEBUG_ERR,
                  TEXT("No matching client entry for binding handle %08p"), 
                  hFaxHandle);
    
    return FAX_API_VERSION_0;
}   // FindClientAPIVersion
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\receipts.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    Receipts.cpp

Abstract:

    Implementation of the fax DR/NDR mechanism

Author:

    Eran Yariv (EranY)  Feb, 2000

Revision History:

--*/

#include "faxsvc.h"
#include "lmcons.h" // Required by lmmsg.h
#include "lmmsg.h"  // Exports NetMessageBufferSend
#include "htmltags.h"

//
// Static functions:
//
static
BOOL
TimeToString(
    const FILETIME *pft,
    wstring &wstr
) throw (exception);

static
BOOL
PrepareReceiptSubject (
    BOOL             bPositive,
    BOOL             bBroadcast,
    const JOB_QUEUE *lpcJobQueue,
    LPWSTR          * pwstrSubject
);

static
BOOL
GetNumericResourceValue (
    int iResourceId,
    DWORD &dwValue
);

static
BOOL
AddRecipientLine (
    const JOB_QUEUE *lpcJobQueue,
    BOOL             bDisplayError,
    wstring         &wstrLine,
    wstring         &wstrHTMLLine
) throw (exception);

static
BOOL
PrepareReceiptBody(
    BOOL              bPositive,
    BOOL             bBroadcast,
    const JOB_QUEUE * lpcJobQueue,
    LPCWSTR           lpcwstrSubject,
    BOOL              bAttachment,
    LPWSTR          * ppwstrBody,
    LPWSTR          * ppestrHTMLBody
) throw (exception);

static
BOOL
PrepareReceiptErrorString (
    const JOB_QUEUE *lpcJobQueue,
    wstring         &wstrError
) throw (exception);


//
// Implementations
//


BOOL
TimeToString(
    const FILETIME *pft,
    wstring &wstr
) throw (exception)
/*++

Routine name : TimeToString

Routine description:

    Converts a FILETIME to a string, according to system's locale.

    This function may throw STL exceptions in case of string errors.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    pft         [in]     - Pointer to FILETIME
    wstr        [out]    - Reference to output time string.

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("TimeToString"));
    Assert (pft);

    FILETIME    tmLocalTime;
    SYSTEMTIME  tmSystemTime;
    LPWSTR      lpwstrTime  = NULL;
    int         iRequiredBufSize;

    //
    // Convert time from UTC to local time zone
    //
    if (!FileTimeToLocalFileTime( pft, &tmLocalTime ))
    {
        ec=GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToLocalFileTime failed. (ec: %ld)"),
            ec);
        goto exit;
    }
    if (!FileTimeToSystemTime( &tmLocalTime, &tmSystemTime ))
    {
        ec=GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed. (ec: %ld)"),
            ec);
        goto exit;
    }
    //
    // Find required string size (in TCHARs)
    //
    iRequiredBufSize = FaxTimeFormat(
       LOCALE_SYSTEM_DEFAULT,
       LOCALE_NOUSEROVERRIDE,
       &tmSystemTime,
       NULL,
       NULL,
       0
       );

    Assert (iRequiredBufSize);
    if (0 == iRequiredBufSize)
    {
        ec=GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxTimeFormat failed. (ec: %ld)"),
            ec);
        goto exit;
    }    
    //
    // Allocate string buffer
    //
    WCHAR wszTime[256];
    lpwstrTime = wszTime;
    if (iRequiredBufSize > ARR_SIZE (wszTime))
    {
        //
        // The static buffer is not enough, allocate one from the heap
        //
        lpwstrTime = (LPWSTR) MemAlloc (sizeof (TCHAR) * iRequiredBufSize);
        if (!lpwstrTime)
        {
            ec=GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("MemAlloc failed. (ec: %ld)"),
                ec);
            goto exit;
        }
    }
    //
    // Format time into result string
    //
    if (!FaxTimeFormat(
       LOCALE_SYSTEM_DEFAULT,
       LOCALE_NOUSEROVERRIDE,
       &tmSystemTime,
       NULL,
       lpwstrTime,
       iRequiredBufSize
       ))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FaxTimeFormat failed. (ec: %ld)"),
            ec);
        goto exit;
    }

    wstr = lpwstrTime;
    Assert (ERROR_SUCCESS == ec);

exit:
    if ((lpwstrTime != wszTime) && (NULL != lpwstrTime))
    {
        //
        // Memory successfully allocated from the heap
        //
        MemFree ((LPVOID)lpwstrTime);
    }
    if (ERROR_SUCCESS != ec)
    {
        SetLastError (ec);
        return FALSE;
    }
    return TRUE;
}   // TimeToString

BOOL
PrepareReceiptSubject (
    BOOL             bPositive,
    BOOL             bBroadcast,
    const JOB_QUEUE *lpcJobQueue,
    LPWSTR          * pwstrSubject
)
/*++

Routine name : PrepareReceiptSubject

Routine description:

    Prepares the receipts subject line to be sent out via mail or a message box

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    bPositive      [in]  - Did the job(s) complete successfully?
    bBroadcast     [in]  - Is this the a broadcast job?
    lpcJobQueue    [in]  - Pointer to job (or broadcast parent job)
    pwstrSubject   [out] - Pointer to subject line string.
                           The string is allocated by this function.
                           If the function succeeded, the caller must call LocalFree() to
                           deallocate it.

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("PrepareReceiptSubject"));

    Assert (lpcJobQueue && pwstrSubject);

    DWORD dwMsgCount;
    LPDWORD MsgPtr[4] = {0};
    int nMsgStrID;

    try
    {
        wstring wstrSubject = TEXT("");
        wstring wstrError;

        if (lpcJobQueue->CoverPageEx.lptstrSubject)
        {
            //
            // Job has a subject
            //
            wstrSubject = lpcJobQueue->CoverPageEx.lptstrSubject;
            wstrSubject.append (TEXT(" "));
        }
        else if (lpcJobQueue->lpParentJob && lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject)
        {
            //
            // Parent job has a subject
            //
            wstrSubject = lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject;
            wstrSubject.append (TEXT(" "));
        }
        if (!bBroadcast)
        {
            //
            // Compose subject for single recipient job
            //
            MsgPtr[0] = (LPDWORD)(LPCTSTR)wstrSubject.c_str();
            MsgPtr[1] = (LPDWORD)lpcJobQueue->RecipientProfile.lptstrName;
            MsgPtr[2] = (LPDWORD)lpcJobQueue->RecipientProfile.lptstrFaxNumber;

            if (bPositive)
            {
                //
                // Success line
                // "Fax <subject> was successfully sent to <name> at <number>"
                //
                if (!MsgPtr[1])
                {
                    //
                    //  Name is not mandatory parameter
                    //
                    nMsgStrID = MSG_DR_SINGLE_SUBJECT_NONAME;
                }
                else
                {
                    nMsgStrID = MSG_DR_SINGLE_SUBJECT;
                }
            }
            else
            {
                //
                // Failure line
                // "Fax <subject> failed to send to <name> at <number> (<last error>)."
                //
                //
                // Get error string
                //
                if (!PrepareReceiptErrorString (lpcJobQueue, wstrError))
                {
                    ec = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("PrepareReceiptErrorString failed. (ec: %ld)"),
                        ec);
                    return FALSE;
                }
                MsgPtr[3] = (LPDWORD)wstrError.c_str();

                if (!MsgPtr[1])
                {
                    //
                    //  Name is not mandatory parameter
                    //
                    nMsgStrID = MSG_NDR_SINGLE_SUBJECT_NONAME;
                }
                else
                {
                    nMsgStrID = MSG_NDR_SINGLE_SUBJECT;
                }
            }
        }
        else
        {
            //
            // Broadcast case
            //
            Assert (JT_BROADCAST == lpcJobQueue->JobType);
            Assert (lpcJobQueue->RecipientJobs.Flink);
            if (bPositive)
            {
                //
                // Compose subject for a broadcast job - success
                // "Fax <subject> successfully sent to <first name> and all other recipients"
                //
                nMsgStrID = MSG_DR_BROADCAST_SUBJECT;

                MsgPtr[0] = (LPDWORD)(LPCTSTR)wstrSubject.c_str();

                PLIST_ENTRY lpNext = lpcJobQueue->RecipientJobs.Flink;
                Assert (lpNext);
                PJOB_QUEUE_PTR lpRecipientsGroupMember;
                lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
                Assert (lpRecipientsGroupMember);
                PJOB_QUEUE pFirstRecipient = lpRecipientsGroupMember->lpJob;
                Assert (pFirstRecipient);

                MsgPtr[1] = (LPDWORD)pFirstRecipient->RecipientProfile.lptstrName;
                if (!MsgPtr[1])
                {
                    //
                    //  Name is not mandatory parameter
                    //
                    MsgPtr[1] = (LPDWORD)pFirstRecipient->RecipientProfile.lptstrFaxNumber;
                }
            }
            else
            {
                //
                // Compose subject for a broadcast job - failure
                // "Fax <subject> was not successfully sent to <x> recipients. Canceled: <y> recipient(s).  Failed: <z> recipient(s)"
                //
                nMsgStrID = MSG_NDR_BROADCAST_SUBJECT;

                MsgPtr[0] = (LPDWORD)(LPCTSTR)wstrSubject.c_str();
                Assert (lpcJobQueue->dwRecipientJobsCount ==
                        (lpcJobQueue->dwCanceledRecipientJobsCount +
                         lpcJobQueue->dwCompletedRecipientJobsCount +
                         lpcJobQueue->dwFailedRecipientJobsCount));
                MsgPtr[1] = (LPDWORD) ULongToPtr(lpcJobQueue->dwRecipientJobsCount);
                MsgPtr[2] = (LPDWORD) ULongToPtr(lpcJobQueue->dwCanceledRecipientJobsCount);
                MsgPtr[3] = (LPDWORD) ULongToPtr(lpcJobQueue->dwFailedRecipientJobsCount);
            }
        }
        //
        // Format the subject buffer (system allocates it)
        //
        dwMsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE   |
            FORMAT_MESSAGE_ARGUMENT_ARRAY |
            FORMAT_MESSAGE_ALLOCATE_BUFFER,
            g_hResource,
            nMsgStrID,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            (LPTSTR)pwstrSubject,
            0,
            (va_list *) MsgPtr
            );
        if (!dwMsgCount)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FormatMessage failed. (ec: %ld)"),
                ec);
            return FALSE;
        }
    }
    catch (exception &ex)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("wstring caused exception (%S)"),
            ex.what());
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }

    Assert (ERROR_SUCCESS == ec);
    return TRUE;
}   // PrepareReceiptSubject

BOOL
GetNumericResourceValue (
    int iResourceId,
    DWORD &dwValue
)
/*++

Routine name : GetNumericResourceValue

Routine description:

    Reads a string resource and converts to a numeric value

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    iResourceId    [in]     - String resource id
    dwValue        [out]    - Numeric value

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("GetNumericResourceValue"));

    if (1 != swscanf (GetString (iResourceId), TEXT("%ld"), &dwValue))
    {
        SetLastError (ERROR_GEN_FAILURE);
        return FALSE;
    }
    return TRUE;
}   // GetNumericResourceValue

BOOL
AddRecipientLine (
    const JOB_QUEUE *lpcJobQueue,
    BOOL             bDisplayError,
    wstring         &wstrLine,
    wstring         &wstrHTMLLine
) throw (exception)
/*++

Routine name : AddRecipientLine

Routine description:

    Appends a recipient table line to a plain text string and html string

    This function may throw STL exceptions in case of string errors.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lpcJobQueue     [in]  - Recipient job.
                            If NULL, the table header lines (2 lines) are appended to the string.
    bDisplayError   [in]  - TRUE if 'last error' column is to be displayed
    wstrLine        [out] - String to append to
    wstrHTMLLine    [out] - HTML format string to append to

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("AddRecipientLine"));

    DWORD dwRecNameWidth;
    DWORD dwRecNumberWidth;
    DWORD dwStartTimeWidth;
    DWORD dwEndTimeWidth;
    DWORD dwRetriesWidth;
    DWORD dwErrorWidth;

    wstring wstrError;

    if (!GetNumericResourceValue (IDS_RECEIPT_RECIPIENT_NAME_WIDTH, dwRecNameWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_RECIPIENT_NUMBER_WIDTH, dwRecNumberWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_START_TIME_WIDTH, dwStartTimeWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_END_TIME_WIDTH, dwEndTimeWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_RETRIES_WIDTH, dwRetriesWidth) ||
        !GetNumericResourceValue (IDS_RECEIPT_LAST_ERROR_WIDTH, dwErrorWidth))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetNumericResourceValue failed. (ec: %ld)"),
            ec);
        return FALSE;
    }
    Assert (dwRecNameWidth && dwRecNumberWidth && dwStartTimeWidth && dwEndTimeWidth && dwRetriesWidth && dwErrorWidth);
    if (!lpcJobQueue)
    {
        //
        // Special case - prepare header for table
        //
        WCHAR wszLine[1024]={0};
        LPCWSTR lpcwstrFormat;

        if (bDisplayError)
        {
            wstrLine.append (GetString (IDS_FAILED_RECP_LIST_HEADER));
            wstrHTMLLine.append (GetString (IDS_FAILED_RECP_LIST_HEADER));
            lpcwstrFormat = TEXT("\n%-*s %-*s %-*s %-*s %-*s %-*s");
        }
        else
        {
            wstrLine.append (GetString (IDS_COMPLETED_RECP_LIST_HEADER));
            wstrHTMLLine.append (GetString (IDS_COMPLETED_RECP_LIST_HEADER));
            lpcwstrFormat = TEXT("\n%-*s %-*s %-*s %-*s %-*s");
        }
        if (0 > _snwprintf (wszLine,
                            ARR_SIZE (wszLine) - 1,
                            lpcwstrFormat,
                            dwRecNameWidth,
                            wstring(GetString (IDS_RECEIPT_RECIPIENT_NAME)).substr(0, dwRecNameWidth-1).c_str(),
                            dwRecNumberWidth,
                            wstring(GetString (IDS_RECEIPT_RECIPIENT_NUMBER)).substr(0, dwRecNumberWidth-1).c_str(),
                            dwStartTimeWidth,
                            wstring(GetString (IDS_RECEIPT_START_TIME)).substr(0, dwStartTimeWidth-1).c_str(),
                            dwEndTimeWidth,
                            wstring(GetString (IDS_RECEIPT_END_TIME)).substr(0, dwEndTimeWidth-1).c_str(),
                            dwRetriesWidth,
                            wstring(GetString (IDS_RECEIPT_RETRIES)).substr(0, dwRetriesWidth-1).c_str(),
                            dwErrorWidth,
                            wstring(GetString (IDS_RECEIPT_LAST_ERROR)).substr(0, dwErrorWidth-1).c_str()))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            SetLastError (ec);
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf failed. (ec: %ld)"),
                ec);
            return FALSE;
        }
        wstrLine.append (wszLine);

        wstrHTMLLine.append (HTML_NEW_LINE);
        wstrHTMLLine.append (TEXT("\n"));
        wstrHTMLLine.append (HTML_TABLE_RAW_START);
        wstrHTMLLine.append (HTML_TABLE_HEADER_START);
        wstrHTMLLine.append (GetString(IDS_RECEIPT_RECIPIENT_NAME));
        wstrHTMLLine.append (HTML_TABLE_HEADER_END);
        wstrHTMLLine.append (HTML_TABLE_HEADER_START);
        wstrHTMLLine.append (GetString(IDS_RECEIPT_RECIPIENT_NUMBER));
        wstrHTMLLine.append (HTML_TABLE_HEADER_END);
        wstrHTMLLine.append (HTML_TABLE_HEADER_START);
        wstrHTMLLine.append (GetString (IDS_RECEIPT_START_TIME));
        wstrHTMLLine.append (HTML_TABLE_HEADER_END);
        wstrHTMLLine.append (HTML_TABLE_HEADER_START);
        wstrHTMLLine.append (GetString (IDS_RECEIPT_END_TIME));
        wstrHTMLLine.append (HTML_TABLE_HEADER_END);
        wstrHTMLLine.append (HTML_TABLE_HEADER_START);
        wstrHTMLLine.append (GetString (IDS_RECEIPT_RETRIES));
        wstrHTMLLine.append (HTML_TABLE_HEADER_END);
        if (bDisplayError)
        {
            wstrHTMLLine.append (HTML_TABLE_HEADER_START);
            wstrHTMLLine.append (GetString (IDS_RECEIPT_LAST_ERROR));
            wstrHTMLLine.append (HTML_TABLE_HEADER_END );        
        }
        wstrHTMLLine.append (HTML_TABLE_RAW_END);
        wstrHTMLLine.append (TEXT("\n"));
        //
        // Print seperator line
        //
        WCHAR wszSeperator[] =
            TEXT("--------------------------------------------------------------------------------------------------------");
        if (0 > _snwprintf (wszLine,
                            sizeof (wszLine) / sizeof (wszLine[0]),
                            lpcwstrFormat,
                            dwRecNameWidth,
                            wstring(wszSeperator).substr(0, dwRecNameWidth-1).c_str(),
                            dwRecNumberWidth,
                            wstring(wszSeperator).substr(0, dwRecNumberWidth-1).c_str(),
                            dwStartTimeWidth,
                            wstring(wszSeperator).substr(0, dwStartTimeWidth-1).c_str(),
                            dwEndTimeWidth,
                            wstring(wszSeperator).substr(0, dwEndTimeWidth-1).c_str(),
                            dwRetriesWidth,
                            wstring(wszSeperator).substr(0, dwRetriesWidth-1).c_str(),
                            dwErrorWidth,
                            wstring(wszSeperator).substr(0, dwErrorWidth-1).c_str()))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            SetLastError (ec);
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf failed. (ec: %ld)"),
                ec);
            return FALSE;
        }
        wstrLine.append (wszLine);
        wstrLine.append (TEXT("\n"));
    }
    else
    {
        //
        // Prepare recipient line
        //
        WCHAR wszLine[1024]={0};
        WCHAR wszNumber[12]={0};
        LPCWSTR lpcwstrFormat;
        wstring wstrStartTime;
        wstring wstrEndTime;

        if (!TimeToString ((FILETIME*) &lpcJobQueue->StartTime, wstrStartTime) ||
            !TimeToString ((FILETIME*) &lpcJobQueue->EndTime,   wstrEndTime))
        {
            //
            // Some error while converting time to string
            //
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TimeToString failed (ec=%ld)"),
                ec);
            return FALSE;
        }

        if (bDisplayError)
        {
            lpcwstrFormat = TEXT("%-*s %-*s %-*s %-*s %*d %-*s");
            if (!PrepareReceiptErrorString (lpcJobQueue, wstrError))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PrepareReceiptErrorString failed. (ec: %ld)"),
                    ec);
                return FALSE;
            }
        }
        else
        {
            lpcwstrFormat = TEXT("%-*s %-*s %-*s %-*s %*d");
        }
        if (0 > _snwprintf (wszLine,
                            ARR_SIZE (wszLine) - 1,
                            lpcwstrFormat,
                            dwRecNameWidth,
                            wstring(lpcJobQueue->RecipientProfile.lptstrName ?
                                    lpcJobQueue->RecipientProfile.lptstrName : EMPTY_STRING
                                   ).substr(0, dwRecNameWidth-1).c_str(),
                            dwRecNumberWidth,
                            wstring(lpcJobQueue->RecipientProfile.lptstrFaxNumber ?
                                    lpcJobQueue->RecipientProfile.lptstrFaxNumber : EMPTY_STRING
                                   ).substr(0, dwRecNumberWidth-1).c_str(),
                            dwStartTimeWidth,
                            wstrStartTime.substr(0, dwStartTimeWidth-1).c_str(),
                            dwEndTimeWidth,
                            wstrEndTime.substr(0, dwEndTimeWidth-1).c_str(),
                            dwRetriesWidth,
                            lpcJobQueue->SendRetries,
                            dwErrorWidth,
                            wstrError.substr(0, dwErrorWidth-1).c_str()))
        {
            ec = ERROR_BUFFER_OVERFLOW;
            SetLastError (ec);
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf failed. (ec: %ld)"),
                ec);
            return FALSE;
        }
        wstrLine.append (wszLine);
        wstrLine.append (TEXT("\n"));
        
        wstrHTMLLine.append (HTML_TABLE_RAW_START);
        wstrHTMLLine.append (HTML_TABLE_DATA_START);
        wstrHTMLLine.append (lpcJobQueue->RecipientProfile.lptstrName ?
                lpcJobQueue->RecipientProfile.lptstrName : EMPTY_STRING);
        wstrHTMLLine.append (HTML_TABLE_DATA_END);
        wstrHTMLLine.append (HTML_TABLE_DATA_START);
        wstrHTMLLine.append (lpcJobQueue->RecipientProfile.lptstrFaxNumber ?
                lpcJobQueue->RecipientProfile.lptstrFaxNumber : EMPTY_STRING);
        wstrHTMLLine.append (HTML_TABLE_DATA_END);
        wstrHTMLLine.append (HTML_TABLE_DATA_START);
        wstrHTMLLine.append (wstrStartTime);
        wstrHTMLLine.append (HTML_TABLE_DATA_END);
        wstrHTMLLine.append (HTML_TABLE_DATA_START);
        wstrHTMLLine.append (wstrEndTime);
        wstrHTMLLine.append (HTML_TABLE_DATA_END);
        wstrHTMLLine.append (HTML_TABLE_DATA_START);
        _itow(lpcJobQueue->SendRetries,wszNumber,10);
        wstrHTMLLine.append (wszNumber);
        wstrHTMLLine.append (HTML_TABLE_DATA_END);
        if (bDisplayError)
        {
            wstrHTMLLine.append (HTML_TABLE_DATA_START);
            wstrHTMLLine.append (wstrError);
            wstrHTMLLine.append (HTML_TABLE_DATA_END);
        }
        wstrHTMLLine.append (HTML_TABLE_RAW_END);
        wstrHTMLLine.append (TEXT("\n"));
    }
    return TRUE;
}   // AddRecipientLine


BOOL
PrepareReceiptErrorString (
    const JOB_QUEUE *lpcJobQueue,
    wstring         &wstrError
) throw (exception)
/*++

Routine name : PrepareReceiptErrorString

Routine description:

    Creates an error string for a failed job queue entry

    This function may throw STL exceptions in case of string errors.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    lpcJobQueue  [in]     - Pointer to failed job queue entry
    wstrError    [out]    - String output

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    TCHAR szErrorDescription[MAX_PATH] = {0};

    DEBUG_FUNCTION_NAME(TEXT("PrepareReceiptErrorString"));

    Assert (lpcJobQueue);

    //
    // Clear the string
    //
    wstrError = TEXT("");

    Assert( (JS_RETRIES_EXCEEDED == const_cast<PJOB_QUEUE>(lpcJobQueue)->JobStatus) ||
            (JS_CANCELED == const_cast<PJOB_QUEUE>(lpcJobQueue)->JobStatus) );

    if (JS_CANCELED == const_cast<PJOB_QUEUE>(lpcJobQueue)->JobStatus)
    {
        if (!LoadString(
            g_hResource,
            IDS_JOB_CANCELED_BY_USER,
            szErrorDescription,
            sizeof(szErrorDescription)/sizeof(TCHAR)
            ))
        {
            DebugPrintEx(DEBUG_ERR,
                     TEXT("Failed to load string"));
            return FALSE;
        }

        wstrError = szErrorDescription;
        return TRUE;
    }

    if (lpcJobQueue->ExStatusString[0] != L'\0')
    {
        //
        // FSPI provided extended status string
        //
        wstrError = lpcJobQueue->ExStatusString;
    }
    else
    {
        //
        // FSP provided extended status code
        //
        LPTSTR lptstrString = MapFSPIJobExtendedStatusToString(lpcJobQueue->dwLastJobExtendedStatus);        
        if (lptstrString)
        {
            wstrError = lptstrString;
        }
    }
    return TRUE;
}   // PrepareReceiptErrorString

BOOL
PrepareReceiptBody(
    BOOL              bPositive,
    BOOL              bBroadcast,
    const JOB_QUEUE * lpcJobQueue,
    LPCWSTR           lpcwstrSubject,
    BOOL              bAttachment,
    LPWSTR          * ppwstrBody,
    LPWSTR          * ppwstrHTMLBody
) throw (exception)
/*++

Routine name : PrepareReceiptBody

Routine description:

    Prepares the receipts body to be sent out via mail

    This function may throw STL exceptions in case of string errors.

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    bPositive      [in]  - Did the job(s) complete successfully?
    bBroadcast     [in]  - Is this a broadcast job
    lpcJobQueue    [in]  - Pointer to job (or broadcast parent job)
    lpcwstrSubject [in]  - Subject line (as retrieved from call to PrepareReceiptSubject()).
    bAttachment    [in]  - Should the reciept body contain attachment?
    ppwstrBody     [out] - Pointer to receipt body string.
                           The string is allocated by this function.
                           If the function succeeded, the caller must call LocalFree() to
                           deallocate it.
    ppwstrHTMLBody [out] - Pointer to receipt HTML body string.
                           The string is allocated by this function.
                           If the function succeeded, the caller must call LocalFree() to
                           deallocate it. 

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("PrepareReceiptBody"));

    Assert (lpcJobQueue && ppwstrBody && !(bBroadcast && !ppwstrHTMLBody) );

    DWORD dwMsgCount;
    LPDWORD MsgPtr[8];
    int nMsgStrID;
    int nHTMLMsgStrID;
    wstring wstrDateTime[3];    // Submit time, start time, end time.

    //
    // Get name of server
    //
    WCHAR wszServerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwServerNameSize = sizeof (wszServerName) / sizeof (WCHAR);
    if (!GetComputerName (wszServerName, &dwServerNameSize))
    {
        ec = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetComputerName failed. (ec: %ld)"),
            ec);
        goto exit;
    }

    if (!bBroadcast)
    {
        //
        // Compose body for single recipient job
        //
        wstring wstrError;
        if (!TimeToString ((FILETIME*) &lpcJobQueue->lpParentJob->SubmissionTime, wstrDateTime[0]) ||
            !TimeToString ((FILETIME*) &lpcJobQueue->StartTime, wstrDateTime[1]) ||
            !TimeToString ((FILETIME*) &lpcJobQueue->EndTime,   wstrDateTime[2]))
        {
            //
            // Some error while converting time to string
            //
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TimeToString failed (ec=%ld)"),
                ec);
            goto exit;
        }
        if (bPositive)
        {
            //
            // Success case: "
            //      <Subject line again>
            //      Fax submitted: <date and time>
            //      To server: <server name>
            //      Transmission started: <data and time>
            //      Transmission end: <data and time>
            //      Number of retries: <retries>
            //      Number of pages: <pages>"
            //
            nMsgStrID = MSG_DR_SINGLE_BODY;

            MsgPtr[0] = (LPDWORD)lpcwstrSubject;
            MsgPtr[1] = (LPDWORD)(LPCTSTR)(wstrDateTime[0].c_str());
            MsgPtr[2] = (LPDWORD)wszServerName;
            MsgPtr[3] = (LPDWORD)(LPCTSTR)(wstrDateTime[1].c_str());
            MsgPtr[4] = (LPDWORD)(LPCTSTR)(wstrDateTime[2].c_str());
            MsgPtr[5] = (LPDWORD)ULongToPtr(lpcJobQueue->SendRetries);
            MsgPtr[6] = (LPDWORD)ULongToPtr(lpcJobQueue->PageCount);
        }
        else
        {
            //
            // Failure case: "
            //      <Subject line again>
            //      Fax submitted: <date and time>
            //      To server: <server name>
            //      Transmission started: <data and time>
            //      Transmission end: <data and time>
            //      Number of retries: <retries>
            //      Number of pages: <pages>
            //      Last error: <last error description>
            //
            nMsgStrID = MSG_NDR_SINGLE_BODY;
            if (!PrepareReceiptErrorString (lpcJobQueue, wstrError))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("PrepareReceiptErrorString failed. (ec: %ld)"),
                    ec);
                goto exit;
            }
            MsgPtr[0] = (LPDWORD)lpcwstrSubject;
            MsgPtr[1] = (LPDWORD)(LPCTSTR)(wstrDateTime[0].c_str());
            MsgPtr[2] = (LPDWORD)wszServerName;
            MsgPtr[3] = (LPDWORD)(LPCTSTR)(wstrDateTime[1].c_str());
            MsgPtr[4] = (LPDWORD)(LPCTSTR)(wstrDateTime[2].c_str());
            MsgPtr[5] = (LPDWORD)ULongToPtr(lpcJobQueue->SendRetries);
            MsgPtr[6] = (LPDWORD)ULongToPtr(lpcJobQueue->PageCount);
            MsgPtr[7] = (LPDWORD)wstrError.c_str();
        }
        //
        // Single recipient is an easy case
        // Format the body string now (system allocates it)
        //
        dwMsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE   |
            FORMAT_MESSAGE_ARGUMENT_ARRAY |
            FORMAT_MESSAGE_ALLOCATE_BUFFER,
            g_hResource,
            nMsgStrID,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            (LPTSTR)ppwstrBody,
            0,
            (va_list *) MsgPtr
            );
        if (!dwMsgCount)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FormatMessage failed. (ec: %ld)"),
                ec);
            goto exit;
        }
    }
    else
    {
        //
        // Broadcast body case
        //
        wstring wstrBody;
        wstring wstrHTMLBody;
        LPWSTR lpwstrStaticPart = NULL;
        LPWSTR lpwstrHTMLStaticPart = NULL;
        //
        // Start with the body's static part
        //
        if (!TimeToString ((FILETIME*) &lpcJobQueue->SubmissionTime, wstrDateTime[0]))
        {
            //
            // Some error while converting time to string
            //
            ec = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("TimeToString failed (ec=%ld)"),
                ec);
            goto exit;
        }
        if (bPositive)
        {
            //
            // Success case: "
            //      <Subject line again>
            //      Fax submitted: <date and time>
            //      To server: <server name>
            //      Number of pages: <pages>
            //
            //      The fax was successfully sent to the following recipients:
            //      Recipient name Recipient number Started Ended Retries
            //      -------------- ---------------- ------- ----- -------
            //      < ----     data for each recipient goes here    ---->"
            //
            nMsgStrID = MSG_DR_BROADCAST_BODY;
            nHTMLMsgStrID = MSG_DR_BROADCAST_HTML_BODY;
        }
        else
        {
            //
            // Failure case: "
            //      <Subject line again>
            //      Fax submitted: <date and time>
            //      To server: <server name>
            //      Number of pages: <pages>
            //
            //      The fax was successfully sent to the following recipients:
            //      Recipient name Recipient number Started Ended Retries
            //      -------------- ---------------- ------- ----- --------
            //      < ----------  data for each recipient goes here  ---->"

            //      The fax failed to the following recipients:
            //      Recipient name Recipient number Started Ended Retries  Last error
            //      -------------- ---------------- ------- ----- -------- ----------
            //      < ----------     data for each recipient goes here    ---------->"
            //
            nMsgStrID = MSG_NDR_BROADCAST_BODY;
            nHTMLMsgStrID = MSG_NDR_BROADCAST_HTML_BODY;
        }
        //
        // Start by formatting the static header (system allocates it)
        //
        MsgPtr[0] = (LPDWORD)lpcwstrSubject;
        MsgPtr[1] = (LPDWORD)(wstrDateTime[0].c_str());
        MsgPtr[2] = (LPDWORD)wszServerName;
        MsgPtr[3] = (LPDWORD)ULongToPtr(lpcJobQueue->PageCount);
        
        dwMsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE   |
            FORMAT_MESSAGE_ARGUMENT_ARRAY |
            FORMAT_MESSAGE_ALLOCATE_BUFFER,
            g_hResource,
            nMsgStrID,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            (LPTSTR)&lpwstrStaticPart,
            0,
            (va_list *) MsgPtr
            );
        if (!dwMsgCount)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FormatMessage failed. (ec: %ld)"),
                ec);
            goto exit;
        }
        //
        // Continue by formatting the HTML static header (system allocates it)
        //
        dwMsgCount = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE   |
            FORMAT_MESSAGE_ARGUMENT_ARRAY |
            FORMAT_MESSAGE_ALLOCATE_BUFFER,
            g_hResource,
            nHTMLMsgStrID,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_SYS_DEFAULT),
            (LPTSTR)&lpwstrHTMLStaticPart,
            0,
            (va_list *) MsgPtr
            );
        if (!dwMsgCount)
        {
            if (lpwstrStaticPart)
            {
                LocalFree ((HLOCAL)lpwstrStaticPart);
            }
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("FormatMessage failed. (ec: %ld)"),
                ec);
            goto exit;
        }

        //
        // Add static header to result string
        //
        try
        {
            wstrBody = lpwstrStaticPart;
            wstrHTMLBody.append (HTML_START);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_HEAD_START);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_META);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_TITLE_START);
            wstrHTMLBody.append (GetString(IDS_HTML_RECEIPT_HEADER));
            wstrHTMLBody.append (HTML_TITLE_END);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_HEAD_END);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_BODY_START);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_PARAGRAPH_START);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (lpwstrHTMLStaticPart);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_PARAGRAPH_END);
            wstrHTMLBody.append (TEXT("\n"));
        }
        catch (exception &e)
        {
            if (lpwstrStaticPart)
            {
                LocalFree ((HLOCAL)lpwstrStaticPart);
            }
            if (lpwstrHTMLStaticPart)
            {
                LocalFree ((HLOCAL)lpwstrHTMLStaticPart);
            }
            throw e;
        }
        //
        // Free static header
        //
        if (lpwstrStaticPart)
        {
            LocalFree ((HLOCAL)lpwstrStaticPart);
        }
        if (lpwstrHTMLStaticPart)
        {
            LocalFree ((HLOCAL)lpwstrHTMLStaticPart);
        }
        //
        // Start appending table(s) to static body part
        //
        wstrHTMLBody.append (HTML_PARAGRAPH_START);
        wstrHTMLBody.append (TEXT("\n"));
        if (lpcJobQueue->dwCompletedRecipientJobsCount)
        {
            //
            // Do the recipients lists now (successful recipients)
            //
            wstrHTMLBody.append (HTML_TABLE_START);
            wstrHTMLBody.append (TEXT("\n"));
            //
            //Creating the header of the succesors table
            //
            if (!AddRecipientLine (NULL, FALSE, wstrBody, wstrHTMLBody))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("AddRecipientLine (NULL) failed. (ec: %ld)"),
                    ec);
                goto exit;
            }

            PLIST_ENTRY lpNext = lpcJobQueue->RecipientJobs.Flink;
            Assert (lpNext);
            while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpcJobQueue->RecipientJobs)
            {
                PJOB_QUEUE_PTR lpRecipientsGroupMember;
                lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
                Assert (lpRecipientsGroupMember);
                PJOB_QUEUE pRecipient = lpRecipientsGroupMember->lpJob;
                Assert (pRecipient);
                if (JS_COMPLETED == pRecipient->JobStatus)
                {
                    //
                    // Job successfully completed - adding row of data to the table
                    //
                    if (!AddRecipientLine (pRecipient, FALSE, wstrBody, wstrHTMLBody))
                    {
                        ec = GetLastError();
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("AddRecipientLine failed. (ec: %ld)"),
                            ec);
                        goto exit;
                    }
                }
                lpNext = lpRecipientsGroupMember->ListEntry.Flink;
            }
            wstrBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_TABLE_END);
            wstrHTMLBody.append (TEXT("\n"));
        }
        if (lpcJobQueue->dwFailedRecipientJobsCount)
        {
            //
            // Append negative recipient list
            //
            Assert (!bPositive);
            wstrHTMLBody.append (HTML_NEW_LINE);
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_TABLE_START);
            wstrHTMLBody.append (TEXT("\n"));
            //
            //Creating the header of the failures table
            //
            if (!AddRecipientLine (NULL, TRUE, wstrBody, wstrHTMLBody))
            {
                ec = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("AddRecipientLine (NULL) failed. (ec: %ld)"),
                    ec);
                goto exit;
            }

            PLIST_ENTRY lpNext = lpcJobQueue->RecipientJobs.Flink;
            Assert (lpNext);
            while ((ULONG_PTR)lpNext != (ULONG_PTR)&lpcJobQueue->RecipientJobs)
            {
                PJOB_QUEUE_PTR lpRecipientsGroupMember;
                lpRecipientsGroupMember = CONTAINING_RECORD( lpNext, JOB_QUEUE_PTR, ListEntry );
                Assert (lpRecipientsGroupMember);
                PJOB_QUEUE pRecipient = lpRecipientsGroupMember->lpJob;
                Assert (pRecipient);
                if (JS_RETRIES_EXCEEDED == pRecipient->JobStatus)
                {
                    //
                    // Job is in failure (JS_RETRIES_EXCEEDED)- adding row of data to the table
                    //
                    if (!AddRecipientLine (pRecipient, TRUE, wstrBody, wstrHTMLBody))
                    {
                        ec = GetLastError();
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("AddRecipientLine failed. (ec: %ld)"),
                            ec);
                        goto exit;
                    }
                }
                lpNext = lpRecipientsGroupMember->ListEntry.Flink;
            }
            wstrHTMLBody.append (HTML_TABLE_END);
            wstrHTMLBody.append (TEXT("\n"));
        }
        wstrHTMLBody.append (HTML_PARAGRAPH_END);
        wstrHTMLBody.append (TEXT("\n"));

        //
        //  Check if an attachment was requested
        //
        if (bAttachment &&
            lpcJobQueue->CoverPageEx.lptstrCoverPageFileName)
        {
            //
            // Add remark explaining there is no cover page attachments
            //
            wstrBody.append (TEXT("\n\n"));         
            wstrHTMLBody.append (HTML_PARAGRAPH_START);
            wstrHTMLBody.append (TEXT("\n"));
            if (!lpcJobQueue->FileName)
            {
                //
                // No attachment at all
                //
                wstrBody.append (GetString (IDS_RECEIPT_NO_CP_AND_BODY_ATTACH));
                wstrHTMLBody.append (GetString (IDS_RECEIPT_NO_CP_AND_BODY_ATTACH));
            }
            else
            {
                //
                // Attachment contains body file only
                //
                wstrBody.append (GetString (IDS_RECEIPT_NO_CP_ATTACH));
                wstrHTMLBody.append (GetString (IDS_RECEIPT_NO_CP_ATTACH));
            }
            wstrHTMLBody.append (TEXT("\n"));
            wstrHTMLBody.append (HTML_PARAGRAPH_END);
            wstrBody.append (TEXT("\n"));
            wstrHTMLBody.append (TEXT("\n"));
        }

        wstrHTMLBody.append (HTML_BODY_END);
        wstrHTMLBody.append (TEXT("\n"));
        wstrHTMLBody.append (HTML_END);

        //
        // Allocate return buffer
        //
        DWORD dwBufSize = sizeof (WCHAR) * (wstrBody.size() + 1);
        DWORD dwHTMLBufSize = sizeof (WCHAR) * (wstrHTMLBody.size() + 1);

        *ppwstrBody = (LPTSTR)LocalAlloc (LMEM_FIXED, dwBufSize);
        if (NULL == *ppwstrBody)
        {
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LocalAlloc failed. (ec: %ld)"),
                ec);
            goto exit;
        }
        
        *ppwstrHTMLBody = (LPTSTR)LocalAlloc (LMEM_FIXED, dwHTMLBufSize);
        if (NULL == *ppwstrHTMLBody)
        {
            if (*ppwstrBody)
            {
                LocalFree((HLOCAL)ppwstrBody);
            }
            ec = GetLastError();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("LocalAlloc failed. (ec: %ld)"),
                ec);
            goto exit;
        }
        lstrcpy (*ppwstrBody, wstrBody.c_str());
        lstrcpy (*ppwstrHTMLBody, wstrHTMLBody.c_str());
    }   // End of broadcast case

exit:
    if (ERROR_SUCCESS != ec)
    {
        SetLastError (ec);
        return FALSE;
    }
    return TRUE;
}   // PrepareReceiptBody


BOOL
SendReceipt(
    BOOL bPositive,
    BOOL bBroadcast,
    const JOB_QUEUE * lpcJobQueue,
    LPCTSTR           lpctstrTIFF
)
/*++

Routine name : SendReceipt

Routine description:

    Sends a receipt of a fax delivery / non-delivery

Author:

    Eran Yariv (EranY), Feb, 2000

Arguments:

    bPositive      [in]  - Did the job(s) complete successfully?
    bBroadcast     [in]  - Is this a broadcast job
    lpcJobQueue    [in]  - Pointer to job (or broadcast parent job)
    lpctstrTIFF    [in]  - TIFF file to attach to receipt (optional, may be NULL)

Return Value:

    TRUE if successful, FALSE otherwise.
    In case of failure, call GetLastError() to obtain error code.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SendReceipt"));
    DWORD ec = ERROR_SUCCESS;
    PFAX_SERVER_RECEIPTS_CONFIGW pServerRecieptConfig = NULL;

    Assert(lpcJobQueue);

    LPWSTR lpwstrSubject = NULL;
    LPWSTR lpwstrBody = NULL;
    LPWSTR lpwstrHTMLBody = NULL;

    //
    // Remove modifiers - leave only the receipt type
    //
    DWORD dwDeliveryType = lpcJobQueue->JobParamsEx.dwReceiptDeliveryType & ~DRT_MODIFIERS;

    if (DRT_NONE == dwDeliveryType)
    {
        //
        // No receipt requested
        //
        return TRUE;
    }

    //
    // Get server receipts configuration
    //
    ec = GetRecieptsConfiguration (&pServerRecieptConfig, TRUE);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetRecieptsConfiguration failed. (ec: %ld)"),
            ec);
        SetLastError(ec);
        return FALSE;
    }

    if (!(dwDeliveryType & pServerRecieptConfig->dwAllowedReceipts))
    {
        //
        // Receipt type is NOT currently supported by the server.
        // This may happen if the supported receipt types has changed since the job
        // was submitted.
        //
        DebugPrintEx(DEBUG_ERR,
                    TEXT("dwDeliveryType not supported by the server (%ld)"),
                    dwDeliveryType);
        ec = ERROR_UNSUPPORTED_TYPE;
        goto exit;
    }

    if (!PrepareReceiptSubject (bPositive, bBroadcast, lpcJobQueue, &lpwstrSubject))
    {
        ec = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("PrepareReceiptSubject failed. (ec: %ld)"),
            ec);
        goto exit;
    }

    if (DRT_EMAIL & dwDeliveryType)
    {
        //
        // For mail receipts, we create a message body.
        //
        try
        {
            if (!PrepareReceiptBody (bPositive,
                                     bBroadcast,
                                     lpcJobQueue,
                                     lpwstrSubject,
                                     (lpcJobQueue->JobParamsEx.dwReceiptDeliveryType & DRT_ATTACH_FAX),
                                     &lpwstrBody,
                                     &lpwstrHTMLBody) )
            {
                ec = GetLastError ();
            }
        }
        catch (exception &ex)
        {
            ec = ERROR_NOT_ENOUGH_MEMORY;
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PrepareReceiptBody caused exception (%S)"),
                ex.what());
        }
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PrepareReceiptBody failed. (ec: %ld)"),
                ec);
            goto exit;
        }
    }

    switch (dwDeliveryType)
    {
       case DRT_EMAIL:
            {
                HRESULT hr;
                if (!((lpcJobQueue->JobParamsEx.dwReceiptDeliveryType) & DRT_ATTACH_FAX))
                {
                    //
                    // do not attach tiff file
                    //
                    lpctstrTIFF = NULL;
                }
                hr = SendMail (
                    pServerRecieptConfig->lptstrSMTPFrom,                            // From
                    lpcJobQueue->JobParamsEx.lptstrReceiptDeliveryAddress,      // To
                    lpwstrSubject,                                              // Subject
                    lpwstrBody,                                                 // Body
                    lpwstrHTMLBody,                                             // HTML Body
                    lpctstrTIFF,                                                // Attachment
                    GetString ( bPositive ? IDS_DR_FILENAME:IDS_NDR_FILENAME ), // Attachment description
                    pServerRecieptConfig->lptstrSMTPServer,                          // SMTP server
                    pServerRecieptConfig->dwSMTPPort,                                // SMTP port
                    (pServerRecieptConfig->SMTPAuthOption == FAX_SMTP_AUTH_ANONYMOUS) ?
                        CDO_AUTH_ANONYMOUS : (pServerRecieptConfig->SMTPAuthOption == FAX_SMTP_AUTH_BASIC) ?
                        CDO_AUTH_BASIC : CDO_AUTH_NTLM,                         // Authentication type
                    pServerRecieptConfig->lptstrSMTPUserName,                        // User name
                    pServerRecieptConfig->lptstrSMTPPassword,                        // Password
                    pServerRecieptConfig->hLoggedOnUser);                            // Logged on user token
                if (FAILED(hr))
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("SendMail failed. (hr: 0x%08x)"),
                        hr);
                    ec = (DWORD)hr;
                    goto exit;
                }
            }
            break;
        case DRT_MSGBOX:
            {
                //
                // About to send message box receipt
                //
                DWORD dwMessengerStartupType;
                if (ERROR_SUCCESS == GetServiceStartupType (NULL, MESSENGER_SERVICE_NAME, &dwMessengerStartupType))
                {
                    if (SERVICE_DISABLED == dwMessengerStartupType)
                    {
                        //
                        // Ooops. The local Messenger service is disabled. We can't send message boxes.
                        //
                        g_ReceiptsConfig.dwAllowedReceipts &= ~DRT_MSGBOX;
                        DebugPrintEx(
                            DEBUG_ERR,
                            TEXT("The local Messenger service is disabled. We can't send message boxes."));
                        FaxLog( FAXLOG_CATEGORY_OUTBOUND,
                                FAXLOG_LEVEL_MIN,
                                0,
                                MSG_FAX_MESSENGER_SVC_DISABLED_ERR);
                        ec = ERROR_SERVICE_DISABLED;
                        goto exit;                                
                    }                
                }
                ec = NetMessageBufferSend (
                        NULL,                                                   // Send from this machine
                        lpcJobQueue->JobParamsEx.lptstrReceiptDeliveryAddress,  // Computer to send to
                        NULL,                                                   // Sending computer name
                        (LPBYTE)lpwstrSubject,                                  // Buffer
                        (lstrlen (lpwstrSubject) + 1) * sizeof (WCHAR));        // Buffer size
                if (ERROR_SUCCESS != ec)
                {
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("NetMessageBufferSend failed. (ec: %ld)"),
                        ec);
                    goto exit;
                }
            }
            break;
            

        default:
            ASSERT_FALSE;
            break;
    }
    Assert( ERROR_SUCCESS == ec);

exit:
    if (lpwstrSubject)
    {
        LocalFree ((HLOCAL)lpwstrSubject);
    }
    if (lpwstrBody)
    {
        LocalFree ((HLOCAL)lpwstrBody);
    }
    if (lpwstrHTMLBody)
    {
        LocalFree ((HLOCAL)lpwstrHTMLBody);
    }
    if (ERROR_SUCCESS != ec)
    {
        wstring wstrSubmissionTime;
        SetLastError (ec);

        //
        //  Find Submission Time
        //
        LPCWSTR lpcwstrTime = NULL;

        try
        {
            if (!TimeToString ((lpcJobQueue->lpParentJob) ?
                                   ((FILETIME*) &lpcJobQueue->lpParentJob->SubmissionTime) :
                                   ((FILETIME*) &lpcJobQueue->SubmissionTime),
                               wstrSubmissionTime))
            {
                //
                // Some error while converting time to string
                //
                DebugPrintEx(DEBUG_ERR,
                    TEXT("TimeToString failed (ec=%ld)"),
                    GetLastError ());

                lpcwstrTime = L"";
            }
            else
            {
                lpcwstrTime = wstrSubmissionTime.c_str();
            }
        }
        catch (exception &ex)
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("TimeToString caused exception (%S)"),
                ex.what());

            lpcwstrTime = L"";
        }        

        switch (dwDeliveryType)
        {
        case DRT_EMAIL:

            FaxLog(FAXLOG_CATEGORY_OUTBOUND,
                FAXLOG_LEVEL_MIN,
                4,
                ((bPositive) ? MSG_FAX_OK_EMAIL_RECEIPT_FAILED : MSG_FAX_ERR_EMAIL_RECEIPT_FAILED),
                DWORD2HEX(ec),                                          //  error code
                ((lpcJobQueue->lpParentJob) ? lpcJobQueue->lpParentJob->UserName :
                                              lpcJobQueue->UserName),   //  sender user name
                lpcJobQueue->SenderProfile.lptstrName,                  //  sender name
                lpcwstrTime                                             //  submitted on               
                );
            break;

        case DRT_MSGBOX:

            FaxLog(FAXLOG_CATEGORY_OUTBOUND,
                FAXLOG_LEVEL_MIN,
                4,
                ((bPositive) ? MSG_OK_MSGBOX_RECEIPT_FAILED : MSG_ERR_MSGBOX_RECEIPT_FAILED),
                DWORD2HEX(ec),                                          //  error code
                ((lpcJobQueue->lpParentJob) ? lpcJobQueue->lpParentJob->UserName :
                                              lpcJobQueue->UserName),   //  sender user name
                lpcJobQueue->SenderProfile.lptstrName,                  //  sender name
                lpcwstrTime                                             //  submitted on                
                );
            break;

        default:
            ASSERT_FALSE;
            break;
        }
    }

    if (NULL != pServerRecieptConfig)
    {
        FreeRecieptsConfiguration (pServerRecieptConfig, TRUE);
    }
    return (ERROR_SUCCESS == ec);
}   // SendReceipt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\printscan\faxsrv\service\server\faxrpc.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    faxrpc.c

Abstract:

    This module contains the functions that are dispatched
    as a result of an rpc call.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/
#include "faxsvc.h"
#include "faxreg.h"
#include "fxsapip.h"
#pragma hdrstop

#include "tapiCountry.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

static BOOL
IsLegalQueueSetting(
    DWORD    dwQueueStates
    );

DWORD
GetServerErrorCode (DWORD ec)
{
    DWORD dwServerEC;
    switch (ec)
    {
        case ERROR_OUTOFMEMORY:
        case ERROR_NOT_ENOUGH_MEMORY:
            dwServerEC = FAX_ERR_SRV_OUTOFMEMORY;
            break;

        default:
            dwServerEC = ec;
            break;
    }
    return dwServerEC;
}

//
// version defines
//
CFaxCriticalSection  g_CsClients;
DWORD               g_dwConnectionCount;   // Represents the number of active rpc connections.

static DWORD GetJobSize(PJOB_QUEUE JobQueue);
static BOOL GetJobData(
    LPBYTE JobBuffer,
    PFAX_JOB_ENTRYW FaxJobEntry,
    PJOB_QUEUE JobQueue,
    PULONG_PTR Offset,
	DWORD dwJobBufferSize
    );

static BOOL GetJobDataEx(
    LPBYTE              JobBuffer,
    PFAX_JOB_ENTRY_EXW  pFaxJobEntry,
    PFAX_JOB_STATUSW    pFaxStatus,
    DWORD               dwClientAPIVersion,
    const PJOB_QUEUE    lpcJobQueue,
    PULONG_PTR          Offset,
	DWORD               dwJobBufferSize
    );

static DWORD
LineInfoToLegacyDeviceStatus(
    const LINE_INFO *lpcLineInfo
    );

static
LPTSTR
GetClientMachineName (
    IN  handle_t                hFaxHandle
);


static
DWORD
CreatePreviewFile (
    DWORDLONG               dwlMsgId,
    BOOL                    bAllMessages,
    PJOB_QUEUE*             lppJobQueue
);

BOOL
ReplaceStringWithCopy (
    LPWSTR *plpwstrDst,
    LPWSTR  lpcwstrSrc
)
/*++

Routine name : ReplaceStringWithCopy

Routine description:

    Replaces a string with a new copy of another string

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    plpwstrDst          [in/out] - Destination string. If allocated, gets freed.
    lpcwstrSrc          [in]     - Source string to copy.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    MemFree (LPVOID(*plpwstrDst));
    *plpwstrDst = NULL;
    if (NULL == lpcwstrSrc)
    {
        return TRUE;
    }
    *plpwstrDst = StringDup (lpcwstrSrc);
    if (NULL == *plpwstrDst)
    {
        //
        // Failed to duplicate source string
        //
        return FALSE;
    }
    return TRUE;
}   // ReplaceStringWithCopy


void *
MIDL_user_allocate(
    IN size_t NumBytes
    )
{
    return MemAlloc( NumBytes );
}


void
MIDL_user_free(
    IN void *MemPointer
    )
{
    MemFree( MemPointer );
}

error_status_t
FAX_ConnectFaxServer(
    handle_t            hBinding,
    DWORD               dwClientAPIVersion,
    LPDWORD             lpdwServerAPIVersion,
    PRPC_FAX_SVC_HANDLE pHandle
    )
/*++

Routine name : FAX_ConnectFaxServer

Routine description:

    Creates the initial connection context handle to the server

Author:

    Eran Yariv (EranY), Feb, 2001

Arguments:

    hBinding             [in]  - RPC binding handle
    dwClientAPIVersion   [in]  - API version of the client module
    lpdwServerAPIVersion [out] - API version of the server module (us)
    pHandle              [out] - Pointer to context handle

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code. 
    

--*/
{
    PHANDLE_ENTRY pHandleEntry = NULL;
    error_status_t Rval = 0;
    BOOL fAccess;
    DWORD dwRights; 
    DEBUG_FUNCTION_NAME(TEXT("FAX_ConnectFaxServer"));

    Assert (lpdwServerAPIVersion);

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }

    if (dwClientAPIVersion > CURRENT_FAX_API_VERSION)
    {
        //
        //
        // Not knowning any better (for now), we treat all other versions as current (latest) version clients
        //
        dwClientAPIVersion = CURRENT_FAX_API_VERSION;
    }
    //
    // Give away our API version
    //
    *lpdwServerAPIVersion = CURRENT_FAX_API_VERSION;

    pHandleEntry = CreateNewConnectionHandle(hBinding, dwClientAPIVersion);
    if (!pHandleEntry)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR, _T("CreateNewConnectionHandle() failed, Error %ld"), Rval);
        return Rval;
    }
    *pHandle = (HANDLE) pHandleEntry;
    SafeIncIdleCounter (&g_dwConnectionCount);
    return ERROR_SUCCESS;
}   // FAX_ConnectFaxServer

error_status_t
FAX_ConnectionRefCount(
    handle_t FaxHandle,
    LPHANDLE FaxConHandle,
    DWORD dwConnect,
    LPDWORD CanShare
    )
/*++

Routine Description:

    Called on connect.  Maintains an active connection count.  Client unbind rpc and
    the counter is decremented in the rundown routine.  Returns a context handle to the client.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FaxConHandle    - Context handle
    dwConnect       -
                        1 if connecting,
                        0 if disconnecting,
                        2 if releasing ( only decrement the counter )
    CanShare        - non-zero if sharing is allowed, zero otherwise

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/
{
    PHANDLE_ENTRY pHandleEntry = (PHANDLE_ENTRY) *FaxConHandle;
    DEBUG_FUNCTION_NAME(TEXT("FAX_ConnectionRefCount"));

    

    switch (dwConnect)
    {
        case 0: // Disconenct
            if (NULL == pHandleEntry)
            {
                DebugPrintEx(DEBUG_ERR,
                             _T("Empty context handle"));
                return ERROR_INVALID_PARAMETER;
            }            
            CloseFaxHandle (pHandleEntry);
            //
            // Prevent rundown
            //
            *FaxConHandle = NULL;
            return ERROR_SUCCESS;

        case 1: // Connect (from BOS client)
            {                
                DWORD dwDummy;
                //
                // Can always share
                //

                //
                //  Check parameters
                //
                if (!CanShare)          // unique pointer in idl
                {
                    DebugPrintEx(DEBUG_ERR,
                                _T("CanShare is NULL."));
                    return ERROR_INVALID_PARAMETER;
                }
                *CanShare = 1;
                return FAX_ConnectFaxServer (FaxHandle, FAX_API_VERSION_0, &dwDummy, FaxConHandle);
            }

        case 2: // Release

            if (NULL == pHandleEntry)
            {
                //
                // Empty context handle 
                //
                DebugPrintEx(DEBUG_ERR,
                             _T("Empty context handle"));
                return ERROR_INVALID_PARAMETER;
            }

            if (pHandleEntry->bReleased)
            {
                //
                //  The handle is already released
                //
                DebugPrintEx(DEBUG_ERR,
                             _T("Failed to release handle -- it's already released."));
                return ERROR_INVALID_PARAMETER;
            }
            SafeDecIdleCounter (&g_dwConnectionCount);
            pHandleEntry->bReleased = TRUE;
            return ERROR_SUCCESS;

        default:
            DebugPrintEx(DEBUG_ERR,
                         _T("FAX_ConnectionRefCount called with dwConnect=%ld"),
                         dwConnect);
            return ERROR_INVALID_PARAMETER;
    }
    ASSERT_FALSE;
}   // FAX_ConnectionRefCount


VOID
RPC_FAX_SVC_HANDLE_rundown(
    IN HANDLE FaxConnectionHandle
    )
{
    PHANDLE_ENTRY pHandleEntry = (PHANDLE_ENTRY) FaxConnectionHandle;
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_SVC_HANDLE_rundown"));   
    
    DebugPrintEx(
        DEBUG_WRN,
        TEXT("RPC_FAX_SVC_HANDLE_rundown() running for connection handle 0x%08x"),
        FaxConnectionHandle);
    CloseFaxHandle( pHandleEntry );
    return;    
}

error_status_t
FAX_OpenPort(
    handle_t            FaxHandle,
    DWORD               DeviceId,
    DWORD               Flags,
    LPHANDLE            FaxPortHandle
    )

/*++

Routine Description:

    Opens a fax port for subsequent use in other fax APIs.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    DeviceId        - Requested device id
    FaxPortHandle   - The resulting FAX port handle.

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t Rval = 0;
    PLINE_INFO LineInfo;
    PHANDLE_ENTRY HandleEntry;
    BOOL fAccess;
    DWORD dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_OpenPort()"));

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (FAX_ACCESS_QUERY_CONFIG  != (dwRights & FAX_ACCESS_QUERY_CONFIG) &&
        FAX_ACCESS_MANAGE_CONFIG != (dwRights & FAX_ACCESS_MANAGE_CONFIG))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG or FAX_ACCESS_MANAGE_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    if (!FaxPortHandle)
    {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &g_CsLine );   

    LineInfo = GetTapiLineFromDeviceId( DeviceId, FALSE );
    if (LineInfo)
    {
        if (Flags & PORT_OPEN_MODIFY)
        {
            //
            // the client wants to open the port for modify
            // access so we must make sure that no other
            // client already has this port open for modify access
            //
            if (IsPortOpenedForModify( LineInfo ))
            {
                Rval = ERROR_INVALID_HANDLE;
                goto Exit;
            }
        }

        HandleEntry = CreateNewPortHandle( FaxHandle, LineInfo, Flags );
        if (!HandleEntry)
        {
            Rval = GetLastError();
            DebugPrintEx(DEBUG_ERR, _T("CreateNewPortHandle() failed, Error %ld"), Rval);
            goto Exit;
        }
        *FaxPortHandle = (HANDLE) HandleEntry;
    }
    else
    {
        Rval = ERROR_BAD_UNIT;
    } 

Exit:
    LeaveCriticalSection( &g_CsLine );
    return Rval;
}


//----------------------------------------------------------------------------
//  Get Service Printers Info
//----------------------------------------------------------------------------
error_status_t
FAX_GetServicePrinters(
    IN  handle_t    hFaxHandle,
    OUT LPBYTE      *lpBuffer,
    OUT LPDWORD     lpdwBufferSize,
    OUT LPDWORD     lpdwPrintersReturned
)
/*++

Routine Description:

    Returns Buffer filled with FAX_PRINTER_INFO for Printers the Service is aware of.

Arguments:

    FaxHandle           - Fax Handle
    Buffer              - the buffer containing all the data.
    BufferSize          - Size of the buffer in bytes.
    PrintersReturned    - Count of the Printers in the buffer.

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/
{
    DWORD   i = 0;
    BOOL    bAccess;
    DWORD   dwSize = 0;
    DWORD   dwCount = 0;
    DWORD_PTR       dwOffset = 0;
    error_status_t  Rval = 0;
    PPRINTER_INFO_2 pPrintersInfo = NULL;
    PFAX_PRINTER_INFOW  pPrinters = NULL;

    DEBUG_FUNCTION_NAME(_T("FAX_GetServicePrinters()"));

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &bAccess, NULL);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    _T("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        goto Exit;
    }

    if (FALSE == bAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    _T("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        Rval = ERROR_ACCESS_DENIED;
        goto Exit;
    }

    //
    //  Check parameters
    //
    Assert (lpdwBufferSize && lpdwPrintersReturned); // ref pointers in idl
    if (!lpBuffer)                                   // unique pointer in idl
    {
        DebugPrintEx(DEBUG_ERR,
                    _T("lpBuffer is NULL."));
        Rval = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    //  Call MyEnumPrinters() to get Printers known by the Service
    //
    pPrintersInfo = (PPRINTER_INFO_2) MyEnumPrinters(NULL, 2, &dwCount, 0);
    if (!pPrintersInfo)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
            _T("MyEnumPrinters failed, ec = %ld"),
            Rval);
        goto Exit;
    }

    //
    //  Count Size of the Buffer to Allocate for Result
    //
    for ( i = 0 ; i < dwCount ; i++ )
    {
        dwSize += sizeof(FAX_PRINTER_INFOW) +
            StringSize ( pPrintersInfo[i].pPrinterName ) +
            StringSize ( pPrintersInfo[i].pDriverName )  +
            StringSize ( pPrintersInfo[i].pServerName );
    }

    //
    //  Allocate buffer to return
    //
    pPrinters = (PFAX_PRINTER_INFOW)MemAlloc(dwSize);
    if (!pPrinters)
    {
        Rval = ERROR_NOT_ENOUGH_MEMORY;
        DebugPrintEx(DEBUG_ERR,
            _T("pPrinters = MemAlloc(dwSize) failed. dwSize = %ld"),
            dwSize);
        goto Exit;
    }

    //
    //  Fill the Buffer with the Data
    //
    dwOffset = sizeof(FAX_PRINTER_INFOW) * dwCount;

    //
    //  Return Values
    //
    *lpBuffer = (LPBYTE)pPrinters;
    *lpdwBufferSize = dwSize;
    *lpdwPrintersReturned = dwCount;

    //
    //  Store Results in the Buffer
    //
    for ( i = 0 ; i < dwCount ; i++, pPrinters++ )
    {
        StoreString(pPrintersInfo[i].pPrinterName,      //  string to be copied
            (PULONG_PTR)&pPrinters->lptstrPrinterName,  //  where to store the Offset
            *lpBuffer,                                  //  buffer to store the value
            &dwOffset,                                  //  at which offset in the buffer to put the value
			*lpdwBufferSize);                           //  size of the lpBuffer

        StoreString(pPrintersInfo[i].pServerName,
            (PULONG_PTR)&pPrinters->lptstrServerName,
            *lpBuffer,
            &dwOffset,
			*lpdwBufferSize);

        StoreString(pPrintersInfo[i].pDriverName,
            (PULONG_PTR)&pPrinters->lptstrDriverName,
            *lpBuffer,
            &dwOffset,
			*lpdwBufferSize);
    }

Exit:

    if (pPrintersInfo)
    {
        MemFree(pPrintersInfo);
    }

    return Rval;
}


error_status_t
FAX_ClosePort(
    IN OUT LPHANDLE    FaxPortHandle
    )

/*++

Routine Description:

    Closes an open FAX port.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    FaxPortHandle   - FAX port handle obtained from FaxOpenPort.


Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{    
    DEBUG_FUNCTION_NAME(TEXT("FAX_ClosePort()"));   

    if (NULL == *FaxPortHandle)
    {
        return ERROR_INVALID_PARAMETER;
    }

    CloseFaxHandle( (PHANDLE_ENTRY) *FaxPortHandle );
    *FaxPortHandle = NULL;
    return ERROR_SUCCESS;
}



error_status_t
FAX_EnumJobs(
    IN handle_t FaxHandle,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize,
    OUT LPDWORD JobsReturned
    )

/*++

Routine Description:

    Enumerates jobs.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    Buffer      - Buffer to hold the job information
    BufferSize  - Total size of the job info buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    PLIST_ENTRY Next;
    PJOB_QUEUE JobQueue;
    DWORD rVal = 0;
    ULONG_PTR Offset = 0;
    DWORD Size = 0;
    DWORD Count = 0;
    PFAX_JOB_ENTRYW JobEntry;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumJobs"));

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_QUERY_JOBS, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_JOBS"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (BufferSize && JobsReturned); // ref pointers in idl
    if (!Buffer)                         // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSectionJobAndQueue;


    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
	{
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;
        if ((JT_BROADCAST == JobQueue->JobType)   ||    // Broadcast parent jobs not included
            (JS_DELETING  == JobQueue->JobStatus) ||    // zombie jobs not included
            (JS_COMPLETED == JobQueue->JobStatus)       // completed jobs did not show up in W2K Fax
            )
        {
            continue;
        }
        else
        {
            Count += 1;
            Size+=GetJobSize(JobQueue);
        }
    }

    *BufferSize = Size;
    *Buffer = (LPBYTE) MemAlloc( Size );
    if (*Buffer == NULL)
	{
        LeaveCriticalSectionJobAndQueue;
		*BufferSize = 0;
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Offset = sizeof(FAX_JOB_ENTRYW) * Count;
    JobEntry = (PFAX_JOB_ENTRYW) *Buffer;

    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
	{
        JobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = JobQueue->ListEntry.Flink;

        if ((JT_BROADCAST == JobQueue->JobType) ||   // Broadcast parent jobs not included
            (JS_DELETING  == JobQueue->JobStatus) ||    // zombie jobs not included
            (JS_COMPLETED == JobQueue->JobStatus)       // completed jobs did not show up in W2K Fax
            )
        {
            continue;
        }
        else
        {
            if (!GetJobData(*Buffer,JobEntry,JobQueue,&Offset,*BufferSize))
			{
				rVal = GetLastError();
				LeaveCriticalSectionJobAndQueue;
				MemFree(*Buffer);
				*Buffer = NULL;
				*BufferSize = 0;
				return rVal;

			}
            JobEntry += 1;
        }
    }

    LeaveCriticalSectionJobAndQueue;

    *JobsReturned = Count;

    return 0;
}


static
LPCWSTR
GetJobQueueUserName(const JOB_QUEUE *lpJobQueue)
{
    LPCWSTR lpUserName = lpJobQueue->lpParentJob ?
                            lpJobQueue->lpParentJob->UserName :
                            lpJobQueue->UserName;

    return lpUserName;
}

//*****************************************************************************
//* Name:   GetJobSize
//* Author: Ronen Barenboim
//*****************************************************************************
//* DESCRIPTION:
//*     Returns the size of the variable length data of a job
//*     which is reported back via the legacy FAX_JOB_ENTRY structure
//*     (FAX_EnumJobs)
//* PARAMETERS:
//*     [IN] PJOB_QUEUE lpJobQueue:
//*         A pointer to the JOB_QUEUE structure of a RECIPIENT job.
//* RETURN VALUE:
//*         The size in bytes of the variable data for the data reported back
//*         via a legacy FAX_JOB_ENTRY structure.
//* Comments:
//*         If the operation failes the function takes care of deleting any temp files.
//*****************************************************************************
DWORD
GetJobSize(
    PJOB_QUEUE lpJobQueue
    )
{
    DWORD Size;




    Size = sizeof(FAX_JOB_ENTRYW);
    Size += StringSize( GetJobQueueUserName(lpJobQueue));
    Size += StringSize( lpJobQueue->RecipientProfile.lptstrFaxNumber);
    Size += StringSize( lpJobQueue->RecipientProfile.lptstrName);
    Size += StringSize( lpJobQueue->SenderProfile.lptstrTSID);
    Size += StringSize( lpJobQueue->SenderProfile.lptstrName);
    Size += StringSize( lpJobQueue->SenderProfile.lptstrCompany );
    Size += StringSize( lpJobQueue->SenderProfile.lptstrDepartment );
    Size += StringSize( lpJobQueue->SenderProfile.lptstrBillingCode );
    Size += StringSize( lpJobQueue->JobParamsEx.lptstrReceiptDeliveryAddress );
    Size += StringSize( lpJobQueue->JobParamsEx.lptstrDocumentName);
    if (lpJobQueue->JobEntry)
    {
        Size += StringSize( lpJobQueue->JobEntry->ExStatusString);
    }

    return Size;
}

#define JS_TO_W2KJS(js)        ((js)>>1)

DWORD
JT_To_W2KJT (
    DWORD dwJT
)
/*++

Routine name : JT_To_W2KJT

Routine description:

    Converts a JobType (JT_*) to Win2K legacy job type

Author:

    Eran Yariv (EranY), Dec, 2000

Arguments:

    dwJT  [in]   - New job type (bit mask - must have only one bit set)

Return Value:

    Win2K legacy job type (JT_*)

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("JT_To_W2KJT"));
    switch (dwJT)
    {
        case JT_UNKNOWN:
            return 0;
        case JT_SEND:
            return 1;
        case JT_RECEIVE:
            return 2;
        case JT_ROUTING:
            return 3;
        case JT_FAIL_RECEIVE:
            return 4;
        default:
            ASSERT_FALSE;
            return 0;
    }
}   // JT_To_W2KJT

//*********************************************************************************
//* Name:   GetJobData()
//* Author: Ronen Barenboim
//* Date:   April 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Copies the relevant data from a JOB_QUEUE structure to a JOB_FAX_ENTRY
//*     structure while serializing variable data into the provided buffer
//*     and storing offsets to it in the relevant fields of JOB_FAX_ENTRY.
//* PARAMETERS:
//*     [OUT]       LPBYTE JobBuffer
//*         The buffer where serialized data is to be placed.
//*     [IN]        PFAX_JOB_ENTRYW FaxJobEntry
//*         A pointer to teh FAX_JOB_ENTRY to be populated.
//*     [IN]        PJOB_QUEUE JobQueue
//*         A pointer to teh JOB_QUEUE structure from which information is to be
//*         copied.
//*     [IN]        PULONG_PTR Offset
//*         The offset in JobBuffer where the variable data is to be placed.
//*         On return the value of the parameter is increased by the size
//*         of the variable data.
//*     [IN]  dwJobBufferSize   
//*         Size of the buffer JobBuffer, in bytes.
//*         This parameter is used only if JobBuffer is not NULL.
//*
//* RETURN VALUE:
//*     TRUE  - on success.
//*     FALSE - call GetLastError() to obtain the error code
//*
//*********************************************************************************
BOOL
GetJobData(
    LPBYTE JobBuffer,
    PFAX_JOB_ENTRYW FaxJobEntry,
    PJOB_QUEUE JobQueue,
    PULONG_PTR Offset,
	DWORD dwJobBufferSize
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetJobData"));
    memset(FaxJobEntry,0,sizeof(FAX_JOB_ENTRYW));
    FaxJobEntry->SizeOfStruct           = sizeof (FAX_JOB_ENTRYW);
    FaxJobEntry->JobId                  = JobQueue->JobId;
    FaxJobEntry->JobType                = JT_To_W2KJT(JobQueue->JobType);

    DebugPrintEx(
            DEBUG_MSG,
            TEXT("JobQueue::JobStatus: 0x%08X"),
            JobQueue->JobStatus);


    if (JobQueue->JobStatus == JS_INPROGRESS &&
        JobQueue->JobStatus != JT_ROUTING)
    {            
        //
        // In progress Job
        //
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("FSPIJobStatus.dwJobStatus: 0x%08X"),
            JobQueue->JobEntry->FSPIJobStatus.dwJobStatus);

        switch (JobQueue->JobEntry->FSPIJobStatus.dwJobStatus)
        {
            case FSPI_JS_INPROGRESS:
                    FaxJobEntry->QueueStatus = JS_TO_W2KJS(JS_INPROGRESS);
                    break;
            case FSPI_JS_RETRY:
                    FaxJobEntry->QueueStatus = JS_TO_W2KJS(JS_INPROGRESS);
                    break;
            case FSPI_JS_ABORTING:
                FaxJobEntry->QueueStatus  = JS_TO_W2KJS(JS_INPROGRESS);
                break;
            case FSPI_JS_SUSPENDING:
            case FSPI_JS_SUSPENDED:
            case FSPI_JS_RESUMING:
            case FSPI_JS_PENDING:
                //
                // In the legacy model there was no such thing as a job
                // pending, suspending, suspened or resuming while being executed by the
                // FSP.                
                // If the job is internally in progress we allways report JS_INPROGRESS.
                // For FSPI_JS states that map to job states (pending, paused, etc). we just
                // report FPS_HANDLED.
                // This means that an application using the legacy API for jobs
                // does not see the full picture but sees a consistent picture of the job status.
                //

                FaxJobEntry->QueueStatus  = JS_TO_W2KJS(JS_INPROGRESS);
                break;
            case FSPI_JS_ABORTED:
            case FSPI_JS_COMPLETED:
            case FSPI_JS_FAILED:
            case FSPI_JS_FAILED_NO_RETRY:
            case FSPI_JS_DELETED:
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("Final job state 0x%08X found while JobId: %ld is in JS_INPROGRESS state. This can not happen !!!"),
                    JobQueue->JobEntry->FSPIJobStatus.dwJobStatus,
                    JobQueue->JobId);

                Assert(JS_INPROGRESS != JobQueue->JobStatus); // ASSERT_FALSE
                //
                // This should never happen since getting this status update
                // should have moved the internal job state to JS_CANCELED or JS_COMPLETED
                //

                //
                // Return JS_INPROGRESS in FREE builds
                //
                FaxJobEntry->QueueStatus = JS_TO_W2KJS(JS_INPROGRESS);
                break;
            default:
                //
                // This should never happen. The service translates the FS to FSPI_JS                
                //
                DebugPrintEx(
                    DEBUG_WRN,
                    TEXT("Unsupported in progress FSP job status 0x%08X for JobId: %ld"),
                    JobQueue->JobEntry->FSPIJobStatus.dwJobStatus,
                    JobQueue->JobId);
                Assert( FSPI_JS_INPROGRESS == JobQueue->JobEntry->FSPIJobStatus.dwJobStatus); // ASSERT_FALSE        
        }
    }
    else if (JobQueue->JobStatus == JS_ROUTING)
    {
        FaxJobEntry->QueueStatus = JS_TO_W2KJS(JS_INPROGRESS);
    }
    else
    {
        FaxJobEntry->QueueStatus = JS_TO_W2KJS(JobQueue->JobStatus);
    }
    //
    // copy the schedule time that the user orginally requested
    //
    if (!FileTimeToSystemTime((LPFILETIME) &JobQueue->ScheduleTime, &FaxJobEntry->ScheduleTime)) {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FileTimeToSystemTime failed (ec: %ld)"),
            GetLastError());
        return FALSE;
    }

    //
    // get the device status, this job might not be scheduled yet, though.
    //
    EnterCriticalSection(&g_CsJob);

    if (JobQueue->JobEntry )
    {
        //
        // Check if the job is a FSP job. If it is we just need to return LineInfo::State
        //                
        FaxJobEntry->Status = JobQueue->JobEntry->LineInfo->State;                
    }

    DebugPrintEx(
        DEBUG_MSG,
        TEXT("GetJobData() Results [ JobId = 0x%08X, JobType = %ld, QueueStatus: 0x%08X, DeviceStatus: 0x%08X ]"),
        FaxJobEntry->JobId,
        FaxJobEntry->JobType,
        FaxJobEntry->QueueStatus,
        FaxJobEntry->Status);

    LeaveCriticalSection(&g_CsJob);


    StoreString( GetJobQueueUserName(JobQueue),
                 (PULONG_PTR)&FaxJobEntry->UserName,
                 JobBuffer,
                 Offset,
				 dwJobBufferSize);
    StoreString( JobQueue->RecipientProfile.lptstrFaxNumber, 
		         (PULONG_PTR)&FaxJobEntry->RecipientNumber,
				 JobBuffer,  
				 Offset,
				 dwJobBufferSize);
    StoreString( JobQueue->RecipientProfile.lptstrName,  
		         (PULONG_PTR)&FaxJobEntry->RecipientName,         
				 JobBuffer,  
				 Offset,
				 dwJobBufferSize);
    FaxJobEntry->PageCount              = JobQueue->PageCount;
    FaxJobEntry->Size                   = JobQueue->FileSize;
    FaxJobEntry->ScheduleAction         = JobQueue->JobParamsEx.dwScheduleAction;
    FaxJobEntry->DeliveryReportType     = JobQueue->JobParamsEx.dwReceiptDeliveryType;

    StoreString( JobQueue->SenderProfile.lptstrTSID, 
		         (PULONG_PTR)&FaxJobEntry->Tsid,
				 JobBuffer, 
				 Offset,
				 dwJobBufferSize);
    StoreString( JobQueue->SenderProfile.lptstrName,   
		         (PULONG_PTR)&FaxJobEntry->SenderName,
				 JobBuffer,  
				 Offset,
				 dwJobBufferSize);
    StoreString( JobQueue->SenderProfile.lptstrCompany,   
		         (PULONG_PTR)&FaxJobEntry->SenderCompany,    
				 JobBuffer, 
				 Offset,
				 dwJobBufferSize);
    StoreString( JobQueue->SenderProfile.lptstrDepartment, 
		         (PULONG_PTR)&FaxJobEntry->SenderDept,
				 JobBuffer,  
				 Offset,
				 dwJobBufferSize);
    StoreString( JobQueue->SenderProfile.lptstrBillingCode, 
		         (PULONG_PTR)&FaxJobEntry->BillingCode,
				 JobBuffer, 
				 Offset,
				 dwJobBufferSize);
    StoreString( JobQueue->JobParamsEx.lptstrReceiptDeliveryAddress, 
		         (PULONG_PTR)&FaxJobEntry->DeliveryReportAddress, 
				 JobBuffer,  
				 Offset,
				 dwJobBufferSize);
    StoreString( JobQueue->JobParamsEx.lptstrDocumentName,    
		         (PULONG_PTR)&FaxJobEntry->DocumentName, 
				 JobBuffer,  
				 Offset,
				 dwJobBufferSize);
    return TRUE;

}


//*********************************************************************************
//* Name:   GetJobDataEx()
//* Author: Oded Sacher
//* Date:   November 14, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Copies the relevant data from a JOB_QUEUE structure to a FAX_JOB_ENTRY_EX
//*     structure while serializing variable data into the provided buffer
//*     and storing offsets to it in the relevant fields of FAX_JOB_ENTRY_EX.
//*     If JobBuffer is NULL, Offset is the total size needed for the buffer.
//*
//*
//* PARAMETERS:
//*     [OUT]       LPBYTE JobBuffer
//*         The buffer where serialized data is to be placed.
//*     [IN]        PFAX_JOB_ENTRY_EXW FaxJobEntry
//*         A pointer to teh FAX_JOB_ENTRY_EX to be populated.
//*     [IN]        PFAX_JOB_STATUSW pFaxJobStatus
//*         A pointer to the FAX_JOB_STATUS to be populated.
//*     [IN]        DWORD dwClientAPIVersion
//*         The version of the client API
//*     [IN]        PJOB_QUEUE lpcJobQueue
//*         A pointer to teh JOB_QUEUE structure from which information is to be
//*         copied.
//*     [IN]        PULONG_PTR Offset
//*         The offset in JobBuffer where the variable data is to be placed.
//*         On return the value of the parameter is increased by the size
//*         of the variable data.
//*     [IN]  DWORD dwJobBufferSize   
//*         Size of the buffer JobBuffer, in bytes.
//*         This parameter is used only if JobBuffer is not NULL.
//*
//* RETURN VALUE:
//*     True/False ,Call GetLastError() for extended error info.
//*********************************************************************************
BOOL
GetJobDataEx(
    LPBYTE              JobBuffer,
    PFAX_JOB_ENTRY_EXW  pFaxJobEntry,
    PFAX_JOB_STATUSW    pFaxStatus,
    DWORD               dwClientAPIVersion,
    const PJOB_QUEUE    lpcJobQueue,
    PULONG_PTR          Offset,
	DWORD               dwJobBufferSize
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetJobDataEx"));
    Assert (lpcJobQueue->JobType != JT_BROADCAST);

    if (JobBuffer != NULL)
    {
        memset(pFaxJobEntry, 0, (sizeof(FAX_JOB_ENTRY_EXW)));
        pFaxJobEntry->dwSizeOfStruct = sizeof (FAX_JOB_ENTRY_EXW);
        pFaxJobEntry->dwlMessageId = lpcJobQueue->UniqueId;
        pFaxJobEntry->dwValidityMask |= FAX_JOB_FIELD_MESSAGE_ID;
    }
    else
    {
        *Offset += sizeof (FAX_JOB_ENTRY_EXW);
    }

    if (lpcJobQueue->JobType == JT_SEND)
    {
        Assert (lpcJobQueue->lpParentJob);

        StoreString (lpcJobQueue->RecipientProfile.lptstrFaxNumber,
                 (PULONG_PTR)&pFaxJobEntry->lpctstrRecipientNumber,
                 JobBuffer,
                 Offset,
				 dwJobBufferSize);
        StoreString (lpcJobQueue->RecipientProfile.lptstrName,
                 (PULONG_PTR)&pFaxJobEntry->lpctstrRecipientName,
                 JobBuffer,
                 Offset,
				 dwJobBufferSize);
        StoreString( GetJobQueueUserName(lpcJobQueue),
                 (PULONG_PTR)&pFaxJobEntry->lpctstrSenderUserName,
                 JobBuffer,
                 Offset,
				 dwJobBufferSize);
        StoreString( lpcJobQueue->SenderProfile.lptstrBillingCode,
                 (PULONG_PTR)&pFaxJobEntry->lpctstrBillingCode,
                 JobBuffer,
                 Offset,
				 dwJobBufferSize);

        StoreString( lpcJobQueue->lpParentJob->JobParamsEx.lptstrDocumentName,
                     (PULONG_PTR)&pFaxJobEntry->lpctstrDocumentName,
                     JobBuffer,
                     Offset,
					 dwJobBufferSize);
        StoreString( lpcJobQueue->lpParentJob->CoverPageEx.lptstrSubject,
                     (PULONG_PTR)&pFaxJobEntry->lpctstrSubject,
                     JobBuffer,
                     Offset,
					 dwJobBufferSize);

        if (JobBuffer != NULL)
        {
            pFaxJobEntry->dwlBroadcastId = lpcJobQueue->lpParentJob->UniqueId;
            pFaxJobEntry->dwValidityMask |= FAX_JOB_FIELD_BROADCAST_ID;

            pFaxJobEntry->dwDeliveryReportType = lpcJobQueue->JobParamsEx.dwReceiptDeliveryType;
            pFaxJobEntry->dwValidityMask |= FAX_JOB_FIELD_DELIVERY_REPORT_TYPE;

            pFaxJobEntry->Priority = lpcJobQueue->JobParamsEx.Priority;
            pFaxJobEntry->dwValidityMask |= FAX_JOB_FIELD_PRIORITY;

            if (!FileTimeToSystemTime((LPFILETIME) &lpcJobQueue->lpParentJob->OriginalScheduleTime,
                                      &pFaxJobEntry->tmOriginalScheduleTime))
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("FileTimeToSystemTime failed (ec: %ld)"),
                   GetLastError());
            }
            else
            {
                pFaxJobEntry->dwValidityMask |= FAX_JOB_FIELD_ORIGINAL_SCHEDULE_TIME;
            }

            if (!FileTimeToSystemTime((LPFILETIME) &lpcJobQueue->lpParentJob->SubmissionTime,
                                      &pFaxJobEntry->tmSubmissionTime))
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("FileTimeToSystemTime failed (ec: %ld)"),
                   GetLastError());
            }
            else
            {
                pFaxJobEntry->dwValidityMask |= FAX_JOB_FIELD_SUBMISSION_TIME;
            }
        }
    }

    if (!GetJobStatusDataEx (JobBuffer, pFaxStatus, dwClientAPIVersion, lpcJobQueue, Offset, dwJobBufferSize))
    {
        DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("GetJobStatusDataEx failed (ec: %ld)"),
                   GetLastError());
    }
    else
    {
        if (JobBuffer != NULL)
        {
            pFaxJobEntry->dwValidityMask |= FAX_JOB_FIELD_STATUS_SUB_STRUCT;
        }
    }

    return TRUE;
}

//*********************************************************************************
//* Name:   GetAvailableJobOperations()
//* Author: Oded Sacher
//* Date:   Feb 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Returnes a bit wise combination of the available job operations (FAX_ENUM_JOB_OP).
//*
//* PARAMETERS:
//*     [IN]        PJOB_QUEUE lpcJobQueue
//*         A pointer to teh JOB_QUEUE structure from which information is to be
//*         copied.
//*
//* RETURN VALUE:
//*     Bit wise combination of the available job operations (FAX_ENUM_JOB_OP).
//*********************************************************************************
DWORD
GetAvailableJobOperations (
    const PJOB_QUEUE lpcJobQueue
    )
{
    DWORD dwAvailableJobOperations = 0;
    Assert (lpcJobQueue);
    DWORD dwJobStatus = lpcJobQueue->JobStatus;    

    switch (lpcJobQueue->JobType)
    {
        case JT_SEND:
            Assert (lpcJobQueue->lpParentJob);           

            if (lpcJobQueue->lpParentJob->JobStatus == JS_DELETING)
            {
                // The whole broadcast is being deleted
                break; // out of outer switch
            }

            // Check modifiers
            if (lpcJobQueue->JobStatus & JS_PAUSED)
            {
                dwAvailableJobOperations |= (FAX_JOB_OP_RESUME          |
                                             FAX_JOB_OP_DELETE          |
                                             FAX_JOB_OP_VIEW            |
                                             FAX_JOB_OP_RECIPIENT_INFO  |
                                             FAX_JOB_OP_SENDER_INFO);
                break; // out of outer switch
            }

            dwJobStatus = RemoveJobStatusModifiers(dwJobStatus);
            switch (dwJobStatus)
            {
                case JS_PENDING:
                    dwAvailableJobOperations = (FAX_JOB_OP_PAUSE | FAX_JOB_OP_DELETE | FAX_JOB_OP_VIEW | FAX_JOB_OP_RECIPIENT_INFO | FAX_JOB_OP_SENDER_INFO);
                    break;

                case JS_INPROGRESS:
                    dwAvailableJobOperations = (FAX_JOB_OP_DELETE | FAX_JOB_OP_VIEW | FAX_JOB_OP_RECIPIENT_INFO | FAX_JOB_OP_SENDER_INFO);
                    break;

                case JS_RETRYING:
                    dwAvailableJobOperations = (FAX_JOB_OP_DELETE | FAX_JOB_OP_PAUSE | FAX_JOB_OP_VIEW | FAX_JOB_OP_RECIPIENT_INFO | FAX_JOB_OP_SENDER_INFO);
                    break;

                case JS_RETRIES_EXCEEDED:
                    dwAvailableJobOperations = (FAX_JOB_OP_DELETE | FAX_JOB_OP_RESTART | FAX_JOB_OP_VIEW | FAX_JOB_OP_RECIPIENT_INFO | FAX_JOB_OP_SENDER_INFO);
                    break;

                case JS_COMPLETED:
                case JS_CANCELED:
                case JS_CANCELING:
                    dwAvailableJobOperations =  (FAX_JOB_OP_VIEW | FAX_JOB_OP_RECIPIENT_INFO | FAX_JOB_OP_SENDER_INFO);
                    break;
            }
            break; // out of outer switch

        case JT_RECEIVE:
            if (lpcJobQueue->JobStatus == JS_INPROGRESS)
            {
                dwAvailableJobOperations = FAX_JOB_OP_DELETE;                
            }
            break;

        case JT_ROUTING:
            if (lpcJobQueue->JobStatus == JS_RETRYING ||
                lpcJobQueue->JobStatus == JS_RETRIES_EXCEEDED)
            {
                dwAvailableJobOperations = (FAX_JOB_OP_VIEW |FAX_JOB_OP_DELETE);
            }
            else if (lpcJobQueue->JobStatus == JS_INPROGRESS)
            {
                dwAvailableJobOperations = FAX_JOB_OP_VIEW;
            }
            break;


        case JT_BROADCAST:
            // we do not support broadcast operations
            break;
    }
  
    return dwAvailableJobOperations;
}



//*********************************************************************************
//* Name:   GetJobStatusDataEx()
//* Author: Oded Sacher
//* Date:   Jan  2, 2000
//*********************************************************************************
//* DESCRIPTION:
//*     Copies the relevant data from a JOB_QUEUE structure to a FAX_JOB_STATUS
//*     structure while serializing variable data into the provided buffer
//*     and storing offsets to it in the relevant fields of FAX_JOB_STATUS.
//*     If JobBuffer is NULL, Offset is the total size needed for the buffer.
//*
//*
//* PARAMETERS:
//*     [OUT]       LPBYTE JobBuffer
//*         The buffer where serialized data is to be placed.
//*     [IN]        PFAX_JOB_STATUSW pFaxJobStatus
//*         A pointer to the FAX_JOB_STATUS to be populated.
//*     [IN]        DWORD dwClientAPIVersion,
//*         The version of the client API
//*     [IN]        PJOB_QUEUE lpcJobQueue
//*         A pointer to teh JOB_QUEUE structure from which information is to be
//*         copied.
//*     [IN]        PULONG_PTR Offset
//*         The offset in JobBuffer where the variable data is to be placed.
//*         On return the value of the parameter is increased by the size
//*         of the variable data.
//*     [IN]  DWORD dwJobBufferSize   
//*         Size of the buffer JobBuffer, in bytes.
//*         This parameter is used only if JobBuffer is not NULL.
//*
//* RETURN VALUE:
//*     True/False ,Call GetLastError() for extended error info.
//*********************************************************************************
BOOL
GetJobStatusDataEx(
    LPBYTE JobBuffer,
    PFAX_JOB_STATUSW pFaxStatus,
    DWORD dwClientAPIVersion,
    const PJOB_QUEUE lpcJobQueue,
    PULONG_PTR Offset,
	DWORD dwJobBufferSize
    )
{
    DEBUG_FUNCTION_NAME(TEXT("GetJobStatusDataEx"));
    Assert (lpcJobQueue->JobType != JT_BROADCAST);

    if (JobBuffer != NULL)
    {
        memset(pFaxStatus, 0, (sizeof(FAX_JOB_STATUSW)));
        pFaxStatus->dwSizeOfStruct =  sizeof(FAX_JOB_STATUSW);
    }
    else
    {
        *Offset += sizeof(FAX_JOB_STATUSW);
    }

    if (lpcJobQueue->JobType == JT_SEND)
    {
        Assert (lpcJobQueue->lpParentJob);
        if (lpcJobQueue->JobEntry)
        {
            StoreString( lpcJobQueue->JobEntry->FSPIJobStatus.lpwstrRemoteStationId,
                         (PULONG_PTR)&pFaxStatus->lpctstrCsid,
                         JobBuffer,
                         Offset,
						 dwJobBufferSize);
            StoreString( lpcJobQueue->JobEntry->lpwstrJobTsid,
                         (PULONG_PTR)&pFaxStatus->lpctstrTsid,
                         JobBuffer,
                         Offset,
						 dwJobBufferSize);
            //
            // Notice: In outgoing jobs, we store the displayable translated address in the job's
            //         caller ID buffer.
            //         The original address (usually in a TAPI-canonical format) is located in the
            //         lpctstrRecipientNumber field of the FAX_JOB_ENTRY_EX structure.
            //
            //         This is done to support the display of the number actually being dialed out
            //         (without compromising user secrets) in the Fax Status Monitor.
            //
            StoreString( lpcJobQueue->JobEntry->DisplayablePhoneNumber,
                         (PULONG_PTR)&pFaxStatus->lpctstrCallerID,
                         JobBuffer,
                         Offset,
						 dwJobBufferSize);
        }
    }
    else if (lpcJobQueue->JobType == JT_RECEIVE)
    {
        if (lpcJobQueue->JobEntry)
        {
             StoreString( lpcJobQueue->JobEntry->FSPIJobStatus.lpwstrRemoteStationId,
                          (PULONG_PTR)&pFaxStatus->lpctstrTsid,
                          JobBuffer,
                          Offset,
						  dwJobBufferSize);

             StoreString( lpcJobQueue->JobEntry->FSPIJobStatus.lpwstrCallerId,
                          (PULONG_PTR)&pFaxStatus->lpctstrCallerID,
                          JobBuffer,
                          Offset,
						  dwJobBufferSize);

             StoreString( lpcJobQueue->JobEntry->FSPIJobStatus.lpwstrRoutingInfo,
                          (PULONG_PTR)&pFaxStatus->lpctstrRoutingInfo,
                          JobBuffer,
                          Offset,
						  dwJobBufferSize);

             if (lpcJobQueue->JobEntry->LineInfo)
             {
                StoreString( lpcJobQueue->JobEntry->LineInfo->Csid,
                             (PULONG_PTR)&pFaxStatus->lpctstrCsid,
                             JobBuffer,
                             Offset,
							 dwJobBufferSize);
             }
        }
    }
    else if (lpcJobQueue->JobType == JT_ROUTING)
    {
        Assert (lpcJobQueue->FaxRoute);

        StoreString( lpcJobQueue->FaxRoute->Tsid,
                     (PULONG_PTR)&pFaxStatus->lpctstrTsid,
                     JobBuffer,
                     Offset,
					 dwJobBufferSize);

        StoreString( lpcJobQueue->FaxRoute->CallerId,
                      (PULONG_PTR)&pFaxStatus->lpctstrCallerID,
                      JobBuffer,
                      Offset,
					  dwJobBufferSize);

        StoreString( lpcJobQueue->FaxRoute->RoutingInfo,
                      (PULONG_PTR)&pFaxStatus->lpctstrRoutingInfo,
                      JobBuffer,
                      Offset,
					  dwJobBufferSize);

        StoreString( lpcJobQueue->FaxRoute->Csid,
                     (PULONG_PTR)&pFaxStatus->lpctstrCsid,
                     JobBuffer,
                     Offset,
					 dwJobBufferSize);

        StoreString( lpcJobQueue->FaxRoute->DeviceName,
                     (PULONG_PTR)&pFaxStatus->lpctstrDeviceName,
                     JobBuffer,
                     Offset,
					 dwJobBufferSize);

        if (JobBuffer != NULL)
        {
            pFaxStatus->dwDeviceID = lpcJobQueue->FaxRoute->DeviceId;
            pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_DEVICE_ID;

            if (!FileTimeToSystemTime((LPFILETIME) &lpcJobQueue->StartTime, &pFaxStatus->tmTransmissionStartTime))
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("FileTimeToSystemTime failed (ec: %ld)"),
                   GetLastError());
            }
            else
            {
                pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_TRANSMISSION_START_TIME;
            }

            if (!FileTimeToSystemTime((LPFILETIME) &lpcJobQueue->EndTime, &pFaxStatus->tmTransmissionEndTime))
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("FileTimeToSystemTime failed (ec: %ld)"),
                   GetLastError());
            }
            else
            {
                pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_TRANSMISSION_END_TIME;
            }
        }
    }

    if (JobBuffer != NULL)
    {
        if (lpcJobQueue->JobType != JT_ROUTING &&
            lpcJobQueue->JobStatus == JS_INPROGRESS)
        {
                DebugPrintEx(
                    DEBUG_MSG,
                    TEXT("FSPIJobStatus.dwJobStatus: 0x%08X"),
                    lpcJobQueue->JobEntry->FSPIJobStatus.dwJobStatus);

                switch (lpcJobQueue->JobEntry->FSPIJobStatus.dwJobStatus)
                {
                    case FSPI_JS_INPROGRESS:
                         pFaxStatus->dwQueueStatus = JS_INPROGRESS;
                         break;
                    case FSPI_JS_RETRY:
                         pFaxStatus->dwQueueStatus = JS_RETRYING;
                         break;
                    case FSPI_JS_ABORTING:
                        pFaxStatus->dwQueueStatus  = JS_CANCELING;
                        break;
                    case FSPI_JS_SUSPENDING:
                        pFaxStatus->dwQueueStatus  = JS_INPROGRESS; // No support for suspending state in client API
                        break;
                    case FSPI_JS_RESUMING:
                        pFaxStatus->dwQueueStatus  = JS_PAUSED; // No support for resuming state in client API

                    default:
                        DebugPrintEx(
                            DEBUG_WRN,
                            TEXT("Unsupported in progress FSP job status 0x%08X"),
                            lpcJobQueue->JobEntry->FSPIJobStatus.dwJobStatus);
                        pFaxStatus->dwQueueStatus = JS_INPROGRESS;
                }
        }
        else
        {
            pFaxStatus->dwQueueStatus = lpcJobQueue->JobStatus;
        }
        pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_QUEUE_STATUS;
    }

    if (JT_ROUTING != lpcJobQueue->JobType) // Routing jobs with JobEntry are in temporary state.
    {
        if (lpcJobQueue->JobEntry)
        {
            //
            // Job is in progress
            //
            if (lstrlen(lpcJobQueue->JobEntry->ExStatusString))
            {
				//
				// We have an extended status string
				//
                StoreString( lpcJobQueue->JobEntry->ExStatusString,
                             (PULONG_PTR)&pFaxStatus->lpctstrExtendedStatus,
                             JobBuffer,
                             Offset,
							 dwJobBufferSize);				
				if (JobBuffer != NULL)
				{
					pFaxStatus->dwExtendedStatus = lpcJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus; // report the extended status as is.					
					if (0 != pFaxStatus->dwExtendedStatus)
					{
						pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_STATUS_EX;
					}
				}
            }
			else
			{
				//
				// One of the well known extended status codes
				//
				if (JobBuffer != NULL)
				{
					pFaxStatus->dwExtendedStatus = MapFSPIJobExtendedStatusToJS_EX(
															lpcJobQueue->JobEntry->FSPIJobStatus.dwExtendedStatus);											
					if (0 != pFaxStatus->dwExtendedStatus)
					{
						pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_STATUS_EX;
					}
				}
			}

            if (JobBuffer != NULL)
            {
                pFaxStatus->dwCurrentPage = lpcJobQueue->JobEntry->FSPIJobStatus.dwPageCount;
                pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_CURRENT_PAGE;

                if (!GetRealFaxTimeAsSystemTime (lpcJobQueue->JobEntry, FAX_TIME_TYPE_START, &pFaxStatus->tmTransmissionStartTime))
                {
                    DebugPrintEx( DEBUG_ERR,
                                  TEXT("GetRealFaxTimeAsSystemTime (End time) Failed (ec: %ld)"),
                                  GetLastError());
                }
                else
                {
                    pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_TRANSMISSION_START_TIME;
                }
            }

            if (lpcJobQueue->JobEntry->LineInfo)
            {
                if (JobBuffer != NULL)
                {
                    pFaxStatus->dwDeviceID = lpcJobQueue->JobEntry->LineInfo->PermanentLineID;
                    pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_DEVICE_ID;
                }

                StoreString( lpcJobQueue->JobEntry->LineInfo->DeviceName,
                         (PULONG_PTR)&pFaxStatus->lpctstrDeviceName,
                         JobBuffer,
                         Offset,
						 dwJobBufferSize);
            }
        }
        else
        {
            //
            // Job is NOT in progress - retrieve last extended status
            //
            if (lstrlen(lpcJobQueue->ExStatusString))
            {
				//
				// We have an extended status string
				//
                StoreString( lpcJobQueue->ExStatusString,
                             (PULONG_PTR)&pFaxStatus->lpctstrExtendedStatus,
                             JobBuffer,
                             Offset,
							 dwJobBufferSize);
				if (JobBuffer != NULL)
				{
					pFaxStatus->dwExtendedStatus = lpcJobQueue->dwLastJobExtendedStatus; // report the extended status as is.					
					if (0 != pFaxStatus->dwExtendedStatus)
					{
						pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_STATUS_EX;
					}
				}
            }
			else
			{
				//
				// One of the well known extended status codes
				//
				if (JobBuffer != NULL)
				{
					pFaxStatus->dwExtendedStatus = MapFSPIJobExtendedStatusToJS_EX(
														lpcJobQueue->dwLastJobExtendedStatus);											
					if (0 != pFaxStatus->dwExtendedStatus)
					{
						pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_STATUS_EX;
					}
				}
			}           			
        }
    }

    //
    // Common to Send ,receive, routing and partially received
    //
    if (JobBuffer != NULL)
    {
        pFaxStatus->dwJobID = lpcJobQueue->JobId;
        pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_JOB_ID;

        pFaxStatus->dwJobType = lpcJobQueue->JobType;
        pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_TYPE;

        pFaxStatus->dwAvailableJobOperations = GetAvailableJobOperations (lpcJobQueue);


        if (lpcJobQueue->JobType == JT_ROUTING || lpcJobQueue->JobType == JT_SEND)
        {
            pFaxStatus->dwSize = lpcJobQueue->FileSize;
            pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_SIZE;

            pFaxStatus->dwPageCount = lpcJobQueue->PageCount;
            pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_PAGE_COUNT;

            pFaxStatus->dwRetries = lpcJobQueue->SendRetries;
            pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_RETRIES;

            if (!FileTimeToSystemTime((LPFILETIME) &lpcJobQueue->ScheduleTime, &pFaxStatus->tmScheduleTime))
            {
               DebugPrintEx(
                   DEBUG_ERR,
                   TEXT("FileTimeToSystemTime failed (ec: %ld)"),
                   GetLastError());
            }
            else
            {
                pFaxStatus->dwValidityMask |= FAX_JOB_FIELD_SCHEDULE_TIME;
            }
        }
    }

    if (FAX_API_VERSION_1 > dwClientAPIVersion)
    {
        //
        // Clients that use API version 0 can't handle JS_EX_CALL_COMPLETED and JS_EX_CALL_ABORTED
        //
        if (JobBuffer && pFaxStatus)
        {
            if (FAX_API_VER_0_MAX_JS_EX < pFaxStatus->dwExtendedStatus)
            {
                //
                // Turn off the extended status field
                //
                pFaxStatus->dwExtendedStatus = 0;
                pFaxStatus->dwValidityMask &= ~FAX_JOB_FIELD_STATUS_EX;
            }
        }
    }
    return TRUE;
}


error_status_t
FAX_GetJob(
    IN handle_t FaxHandle,
    IN DWORD JobId,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    )
{
    PJOB_QUEUE JobQueue;
    ULONG_PTR Offset = sizeof(FAX_JOB_ENTRYW);
    DWORD Rval = 0;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetJob()"));

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (FAX_ACCESS_QUERY_JOBS, &fAccess, NULL);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_JOBS"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (BufferSize);    // ref pointer in idl
    if (!Buffer)            // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &g_CsJob );
    EnterCriticalSection( &g_CsQueue );

    JobQueue = FindJobQueueEntry( JobId );

    if (!JobQueue ) 
    
    {
        Rval = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if    ((JT_BROADCAST == JobQueue->JobType)   ||   // Broadcast parent jobs not included
           (JS_DELETING  == JobQueue->JobStatus) ||   // zombie jobs not included
           (JS_COMPLETED == JobQueue->JobStatus))     // completed jobs did not show up in W2K Fax
    {
        Rval = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    
    *BufferSize = GetJobSize(JobQueue);
    *Buffer = (LPBYTE)MemAlloc( *BufferSize );
    if (!*Buffer)
    {
		*BufferSize = 0;
        Rval = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    if (!GetJobData(*Buffer,(PFAX_JOB_ENTRYW) *Buffer,JobQueue,&Offset,*BufferSize))
	{
		Rval = GetLastError();
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("GetJobData Failed, Error : %ld"),
			Rval);
		MemFree(*Buffer);
		*Buffer = NULL;
		*BufferSize = 0;
	}

exit:
    LeaveCriticalSection( &g_CsQueue );
    LeaveCriticalSection( &g_CsJob );
    return Rval;
}


error_status_t
FAX_SetJob(
    IN handle_t FaxHandle,
    IN DWORD JobId,
    IN DWORD Command
    )
{
    PJOB_QUEUE JobQueue;
    DWORD Rval = 0;
    BOOL fAccess;
    DWORD dwRights;
    PSID lpUserSid = NULL;
    DWORD dwJobStatus;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetJob"));

    //
    // handle abort case up here because we aquire must aquire additional critical sections to avoid deadlock
    //
    if (Command == JC_DELETE)
    {
        Rval = FAX_Abort(FaxHandle,JobId);
    }
    else
    {
        //
        // Get Access rights
        //
        Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                        Rval);
            return Rval;
        }

        EnterCriticalSection( &g_CsQueue );

        JobQueue = FindJobQueueEntry( JobId );

        if (!JobQueue)
        {
            Rval = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        dwJobStatus = (JT_SEND == JobQueue->JobType) ? JobQueue->lpParentJob->JobStatus : JobQueue->JobStatus;
        if (JS_DELETING == dwJobStatus)
        {
            //
            // Job is being deleted. Do nothing.
            //
            DebugPrintEx(DEBUG_WRN,
                TEXT("[JobId: %ld] is being deleted canceled."),
                JobQueue->JobId);
            Rval = ERROR_INVALID_PARAMETER;
            goto exit;
        }
        //
        // Access check
        //
        if (FAX_ACCESS_MANAGE_JOBS != (dwRights & FAX_ACCESS_MANAGE_JOBS))
        {
            //
            // Check if the user has submit right
            //
            if (FAX_ACCESS_SUBMIT           != (dwRights & FAX_ACCESS_SUBMIT)           &&
                FAX_ACCESS_SUBMIT_NORMAL    != (dwRights & FAX_ACCESS_SUBMIT_NORMAL)    &&
                FAX_ACCESS_SUBMIT_HIGH      != (dwRights & FAX_ACCESS_SUBMIT_HIGH))
            {
                Rval = ERROR_ACCESS_DENIED;
                DebugPrintEx(DEBUG_WRN,
                            TEXT("UserOwnsJob failed - The user does have submit or mange jobs access rights"));
                goto exit;
            }

            //
            // Check if the user owns the job
            //

            //
            //Get the user SID
            //
            lpUserSid = GetClientUserSID();
            if (lpUserSid == NULL)
            {
               Rval = GetLastError();
               DebugPrintEx(DEBUG_ERR,
                            TEXT("GetClientUserSid Failed, Error : %ld"),
                            Rval);
               goto exit;
            }

            if (!UserOwnsJob (JobQueue, lpUserSid))
            {
                Rval = ERROR_ACCESS_DENIED;
                DebugPrintEx(DEBUG_WRN,
                            TEXT("UserOwnsJob failed - The user does not own the job"));
                goto exit;
            }
        }

        switch (Command)
        {
            case JC_UNKNOWN:
                Rval = ERROR_INVALID_PARAMETER;
                break;

/*
 * This case is handled above...
 *           case JC_DELETE:
 *               Rval = FAX_Abort(FaxHandle,JobId);
 *               break;
 */
            case JC_PAUSE:
                if (!PauseJobQueueEntry( JobQueue ))
                {
                    Rval = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("PauseJobQueueEntry failed (ec: %ld)"),
                        Rval);
                }
                break;

            case JC_RESUME:
                if (!ResumeJobQueueEntry( JobQueue ))
                {
                    Rval = GetLastError();
                    DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("ResumeJobQueueEntry failed (ec: %ld)"),
                        Rval);
                }
                break;

            default:
                Rval = ERROR_INVALID_PARAMETER;
                break;
        }

exit:
        LeaveCriticalSection( &g_CsQueue );
        MemFree (lpUserSid);
    }
    return Rval;
}


error_status_t
FAX_GetPageData(
    IN handle_t FaxHandle,
    IN DWORD JobId,
    OUT LPBYTE *ppBuffer,
    OUT LPDWORD lpdwBufferSize,
    OUT LPDWORD lpdwImageWidth,
    OUT LPDWORD lpdwImageHeight
    )
{
    PJOB_QUEUE  pJobQueue;
    LPBYTE      pTiffBuffer;
    DWORD       dwRights;
    BOOL        fAccess;
    DWORD Rval = ERROR_SUCCESS;
    BOOL         bAllMessages = FALSE;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetPageData()"));
    //
    // Parameter check
    //
    Assert (lpdwBufferSize);                                // ref pointer in idl
    if (!ppBuffer || !lpdwImageWidth || !lpdwImageHeight)   // unique pointers in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
    {
        //
        //  user has a FAX_ACCESS_QUERY_JOBS and can preview/query any job
        //
        bAllMessages = TRUE;
    }
    else
    {
        //
        //  user don't have a FAX_ACCESS_QUERY_JOBS allow him to preview/query only her job
        //
        bAllMessages = FALSE;
    }
    
    EnterCriticalSection( &g_CsQueue );

    pJobQueue = FindJobQueueEntry( JobId );
    if (!pJobQueue)
    {
        LeaveCriticalSection( &g_CsQueue );
        return ERROR_INVALID_PARAMETER;
    }

    if (pJobQueue->JobType != JT_SEND)
    {
        LeaveCriticalSection( &g_CsQueue );
        return ERROR_INVALID_DATA;
    }

    //
    //  We create a preview file that will contain the first page body or cover
    //  this function also increase the Job reference count so a call to DecreaseJobRefCount later is neccessary
    //
    PJOB_QUEUE  pRetJobQueue = NULL;

    Rval = CreatePreviewFile (pJobQueue->UniqueId, bAllMessages, &pRetJobQueue);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreatePreviewFile returned %ld"),
            Rval);
        LeaveCriticalSection( &g_CsQueue );
        return GetServerErrorCode(Rval);
    }
    
    Assert(pRetJobQueue == pJobQueue);
    //
    //  Work with the preview file to extract parameters
    //
    if (!TiffExtractFirstPage(
        pJobQueue->PreviewFileName,
        &pTiffBuffer,
        lpdwBufferSize,
        lpdwImageWidth,
        lpdwImageHeight
        ))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("TiffExtractFirstPage Failed, Error : %ld"),
                    GetLastError());
        
        DecreaseJobRefCount (pJobQueue, TRUE, FALSE, TRUE);  // forth parameter - TRUE for Preview ref count.
        LeaveCriticalSection( &g_CsQueue );
        return ERROR_INVALID_DATA;
    }
    
    //
    //  Decrease Job's ref count, the Preview file will not be deleted so 
    //  calling this function again with the same JobId will use the file in the Preview cache
    //
    DecreaseJobRefCount (pJobQueue, TRUE, FALSE, TRUE);  // forth parameter - TRUE for Preview ref count.

    LeaveCriticalSection( &g_CsQueue );

    *ppBuffer = (LPBYTE) MemAlloc( *lpdwBufferSize );
    if (*ppBuffer == NULL)
    {
        VirtualFree( pTiffBuffer, *lpdwBufferSize, MEM_RELEASE);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    CopyMemory( *ppBuffer, pTiffBuffer, *lpdwBufferSize );
    VirtualFree( pTiffBuffer, *lpdwBufferSize, MEM_RELEASE);
    return ERROR_SUCCESS;

}   // FAX_GetPageData


error_status_t
FAX_GetDeviceStatus(
    IN HANDLE FaxPortHandle,
    OUT LPBYTE *StatusBuffer,
    OUT LPDWORD BufferSize
    )

/*++

Routine Description:

    Obtains a status report for the specified FAX job.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    StatusBuffer    - receives FAX_DEVICE_STATUS pointer
    BufferSize      - Pointer to the size of this structure

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    DWORD rVal = 0;
    ULONG_PTR Offset;
    PFAX_DEVICE_STATUS FaxStatus;
    PLINE_INFO LineInfo;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetDeviceStatus()")); 

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (BufferSize);        // ref pointer in idl
    if (!StatusBuffer)          // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == FaxPortHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("NULL context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;

    if (!LineInfo)
    {
        return ERROR_INVALID_DATA;
    }

    EnterCriticalSection( &g_CsJob );
    EnterCriticalSection( &g_CsLine );

    //
    // count the number of bytes required
    //

    *BufferSize  = sizeof(FAX_DEVICE_STATUS);
    *BufferSize += StringSize( LineInfo->DeviceName );
    *BufferSize += StringSize( LineInfo->Csid );

    if (LineInfo->JobEntry)
    {
        *BufferSize += StringSize( LineInfo->JobEntry->DisplayablePhoneNumber );
        *BufferSize += StringSize( LineInfo->JobEntry->FSPIJobStatus.lpwstrCallerId );
        *BufferSize += StringSize( LineInfo->JobEntry->FSPIJobStatus.lpwstrRoutingInfo );
        *BufferSize += StringSize( LineInfo->JobEntry->FSPIJobStatus.lpwstrRemoteStationId );
        *BufferSize += StringSize( LineInfo->JobEntry->lpJobQueueEntry->SenderProfile.lptstrName);
        *BufferSize += StringSize( LineInfo->JobEntry->lpJobQueueEntry->RecipientProfile.lptstrName);
        *BufferSize += StringSize( LineInfo->JobEntry->lpJobQueueEntry->UserName );

    }

    *StatusBuffer = (LPBYTE) MemAlloc( *BufferSize );
    if (*StatusBuffer == NULL)
    {
		*BufferSize = 0;
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    FaxStatus = (PFAX_DEVICE_STATUS) *StatusBuffer;
    Offset = sizeof(FAX_DEVICE_STATUS);
    memset(FaxStatus,0,sizeof(FAX_DEVICE_STATUS));
    FaxStatus->SizeOfStruct = sizeof(FAX_DEVICE_STATUS);

    FaxStatus->Status       = LineInfoToLegacyDeviceStatus(LineInfo);

    FaxStatus->DeviceId     = LineInfo->PermanentLineID;
    FaxStatus->StatusString = NULL;

    StoreString(
        LineInfo->DeviceName,
        (PULONG_PTR)&FaxStatus->DeviceName,
        *StatusBuffer,
        &Offset,
		*BufferSize
        );

    StoreString(
        LineInfo->Csid,
        (PULONG_PTR)&FaxStatus->Csid,
        *StatusBuffer,
        &Offset,
		*BufferSize
        );

    if (LineInfo->JobEntry)
    {
        FaxStatus->JobType        = JT_To_W2KJT(LineInfo->JobEntry->lpJobQueueEntry->JobType);
        FaxStatus->TotalPages     = LineInfo->JobEntry->lpJobQueueEntry->PageCount;
        FaxStatus->Size           = FaxStatus->JobType == JT_SEND ?
                                    LineInfo->JobEntry->lpJobQueueEntry->FileSize :
                                    0; //meaningful for an outbound job only
        FaxStatus->DocumentName   = NULL;

        ZeroMemory( &FaxStatus->SubmittedTime, sizeof(FILETIME) );
        StoreString(
                    LineInfo->JobEntry->lpJobQueueEntry->SenderProfile.lptstrName,
                (PULONG_PTR)&FaxStatus->SenderName,
                *StatusBuffer,
                &Offset,
				*BufferSize
                );

        StoreString(
                LineInfo->JobEntry->lpJobQueueEntry->RecipientProfile.lptstrName,
            (PULONG_PTR)&FaxStatus->RecipientName,
            *StatusBuffer,
            &Offset,
			*BufferSize
            );

        FaxStatus->CurrentPage = LineInfo->JobEntry->FSPIJobStatus.dwPageCount;

        CopyMemory(&FaxStatus->StartTime, &LineInfo->JobEntry->StartTime, sizeof(FILETIME));

        StoreString(
            LineInfo->JobEntry->DisplayablePhoneNumber,
            (PULONG_PTR)&FaxStatus->PhoneNumber,
            *StatusBuffer,
            &Offset,
			*BufferSize
            );

        StoreString(
            LineInfo->JobEntry->FSPIJobStatus.lpwstrCallerId,
            (PULONG_PTR)&FaxStatus->CallerId,
            *StatusBuffer,
            &Offset,
			*BufferSize
            );

        StoreString(
            LineInfo->JobEntry->FSPIJobStatus.lpwstrRoutingInfo,
            (PULONG_PTR)&FaxStatus->RoutingString,
            *StatusBuffer,
            &Offset,
			*BufferSize
            );

        StoreString(
            LineInfo->JobEntry->FSPIJobStatus.lpwstrRemoteStationId,
            (PULONG_PTR)&FaxStatus->Tsid,
            *StatusBuffer,
            &Offset,
			*BufferSize
            );

        StoreString(
            LineInfo->JobEntry->lpJobQueueEntry->UserName,
            (PULONG_PTR)&FaxStatus->UserName,
            *StatusBuffer,
            &Offset,
			*BufferSize
            );

    }
    else
    {
        FaxStatus->PhoneNumber    = NULL;
        FaxStatus->CallerId       = NULL;
        FaxStatus->RoutingString  = NULL;
        FaxStatus->CurrentPage    = 0;
        FaxStatus->JobType        = 0;
        FaxStatus->TotalPages     = 0;
        FaxStatus->Size           = 0;
        FaxStatus->DocumentName   = NULL;
        FaxStatus->SenderName     = NULL;
        FaxStatus->RecipientName  = NULL;
        FaxStatus->Tsid           = NULL;

        ZeroMemory( &FaxStatus->SubmittedTime, sizeof(FILETIME) );
        ZeroMemory( &FaxStatus->StartTime,     sizeof(FILETIME) );

    }  

exit:
    LeaveCriticalSection( &g_CsLine );
    LeaveCriticalSection( &g_CsJob );
    return rVal;
}


error_status_t
FAX_Abort(
   IN handle_t hBinding,
   IN DWORD JobId
   )

/*++

Routine Description:

    Abort the specified FAX job.  All outstanding FAX
    operations are terminated.

Arguments:

    hBinding        - FAX handle obtained from FaxConnectFaxServer.
    JobId           - FAX job Id

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    PJOB_QUEUE JobQueueEntry;
    BOOL fAccess;
    DWORD dwRights;
    DWORD Rval, dwRes;
    PSID lpUserSid = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FAX_Abort"));

    //
    // Get Access rights
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    EnterCriticalSectionJobAndQueue;

    JobQueueEntry = FindJobQueueEntry( JobId );
    if (!JobQueueEntry)
    {
      Rval = ERROR_INVALID_PARAMETER;
      goto exit;
    }

    Assert (JS_DELETING != JobQueueEntry->JobStatus);

    if (!JobQueueEntry)
    {
       Rval = ERROR_INVALID_PARAMETER;
       goto exit;
    }

    if ( (JobQueueEntry->JobType == JT_RECEIVE &&
          JobQueueEntry->JobStatus == JS_ROUTING) ||
         (JobQueueEntry->JobType == JT_ROUTING &&
          JobQueueEntry->JobStatus == JS_INPROGRESS))
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("[JobId: %ld] Can not be deleted at this status [JobStatus: 0x%08X]"),
                      JobQueueEntry->JobId,
                      JobQueueEntry->JobStatus);
        Rval = ERROR_INVALID_OPERATION;
        goto exit;
    }

    if (JobQueueEntry->JobType == JT_BROADCAST)
    {

        // need to add support for aborting a parent job


       DebugPrintEx(DEBUG_WRN,TEXT("No support for aborting parent job."));
       Rval = ERROR_INVALID_PARAMETER;
       goto exit;
    }

    if (JS_CANCELING == JobQueueEntry->JobStatus)
    {
       //
       // Job is in the process of being canceled. Do nothing.
       //
       DebugPrintEx(DEBUG_WRN,
                    TEXT("[JobId: %ld] is already being canceled."),
                    JobQueueEntry->JobId);
       Rval = ERROR_INVALID_PARAMETER;
       goto exit;
    }

    if (JS_CANCELED == JobQueueEntry->JobStatus)
    {
       //
       // Job is already canceled. Do nothing.
       //
       DebugPrintEx(DEBUG_WRN,
                    TEXT("[JobId: %ld] is already canceled."),
                        JobQueueEntry->JobId);
        Rval = ERROR_INVALID_PARAMETER;
       goto exit;
    }

    //
    // Access check
    //
    if (FAX_ACCESS_MANAGE_JOBS != (dwRights & FAX_ACCESS_MANAGE_JOBS))
    {
        //
        // Check if the user has submit right
        //
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH))
        {
            Rval = ERROR_ACCESS_DENIED;
            DebugPrintEx(DEBUG_WRN,
                        TEXT("UserOwnsJob failed - The user does have submit or mange jobs access rights"));
            goto exit;
        }

        //
        // Check if the user owns the job
        //

        //
        //Get the user SID
        //
        lpUserSid = GetClientUserSID();
        if (lpUserSid == NULL)
        {
           Rval = GetLastError();
           DebugPrintEx(DEBUG_ERR,
                        TEXT("GetClientUserSid Failed, Error : %ld"),
                        Rval);
           goto exit;
        }

        if (!UserOwnsJob (JobQueueEntry, lpUserSid))
        {
            Rval = ERROR_ACCESS_DENIED;
            DebugPrintEx(DEBUG_WRN,
                        TEXT("UserOwnsJob failed - The user does not own the job"));
            goto exit;
        }
    }

#if DBG
    if (JobQueueEntry->lpParentJob)
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Parent Job: %ld [Total Rec = %ld] [Canceled Rec = %ld] [Completed Rec = %ld] [Failed Rec = %ld]"),
            JobQueueEntry->lpParentJob->JobId,
            JobQueueEntry->lpParentJob->dwRecipientJobsCount,
            JobQueueEntry->lpParentJob->dwCanceledRecipientJobsCount,
            JobQueueEntry->lpParentJob->dwCompletedRecipientJobsCount,
            JobQueueEntry->lpParentJob->dwFailedRecipientJobsCount);
    }
#endif

	//
	// abort the job if it's in progress
	//
	if (JobQueueEntry->JobStatus & JS_INPROGRESS)
	{
		if ( ( JobQueueEntry->JobType == JT_SEND ) ||
				( JobQueueEntry->JobType == JT_RECEIVE ) )
		{                   
			__try
			{
				BOOL bRes;

				bRes=JobQueueEntry->JobEntry->LineInfo->Provider->FaxDevAbortOperation(
					(HANDLE) JobQueueEntry->JobEntry->InstanceData );
				if (!bRes)
				{
					Rval = GetLastError();
					DebugPrintEx(
						DEBUG_ERR,
						TEXT("[JobId: %ld] FaxDevAbortOperation failed (ec: %ld)"),
						JobQueueEntry->JobId,
						Rval);
					goto exit;
				}
			}
			__except (HandleFaxExtensionFault(EXCEPTION_SOURCE_FSP, JobQueueEntry->JobEntry->LineInfo->Provider->FriendlyName, GetExceptionCode()))
			{
			    ASSERT_FALSE
			}

			JobQueueEntry->JobEntry->Aborting = TRUE;
			JobQueueEntry->JobStatus = JS_CANCELING;

			if (!CreateFaxEvent(JobQueueEntry->JobEntry->LineInfo->PermanentLineID,
							FEI_ABORTING,
							JobId))
			{
					if (TRUE == g_bServiceIsDown)
					{
						DebugPrintEx(
							DEBUG_WRN,
							TEXT("[JobId: %ld] CreateFaxEvent(FEI_ABORTING) failed. Service is going down"),
							JobQueueEntry->JobId
							);
					}
					else
					{
						DebugPrintEx(
							DEBUG_ERR,
							TEXT("[JobId: %ld] CreateFaxEvent(FEI_ABORTING) failed. (ec: %ld)"),
							JobQueueEntry->JobId,
							GetLastError());
						Assert(FALSE);
					}
			}

			//
			// CreteFaxEventEx
			//
			dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
										JobQueueEntry
										);
			if (ERROR_SUCCESS != dwRes)
			{
				DebugPrintEx(
					DEBUG_ERR,
					TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
					JobQueueEntry->UniqueId,
					dwRes);
			}

			DebugPrintEx( DEBUG_MSG,
						TEXT("[Job: %ld] Attempting FaxDevAbort for job in progress"),
						JobQueueEntry->JobId);              
		}                    
	}    
    else
    {
        //
        // The job is NOT in progress.
        //
        if (JobQueueEntry->JobType == JT_SEND &&
           !(JobQueueEntry->JobStatus & JS_COMPLETED) &&
           !(JobQueueEntry->JobStatus & JS_CANCELED))
        {
            // We just need to mark it as CANCELED
            // and as usual check if the parent is ready for archiving.
            //
            DebugPrintEx( DEBUG_MSG,
                          TEXT("[Job: %ld] Aborting RECIPIENT job which is not in progress."),
                          JobQueueEntry->JobId);

            if (JobQueueEntry->JobStatus & JS_RETRIES_EXCEEDED)
            {
                JobQueueEntry->lpParentJob->dwFailedRecipientJobsCount -= 1;
            }
            JobQueueEntry->lpParentJob->dwCanceledRecipientJobsCount+=1;

            JobQueueEntry->JobStatus = JS_CANCELED;
            //
            // CreteFaxEventEx
            //
            dwRes = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_STATUS,
                                       JobQueueEntry
                                     );
            if (ERROR_SUCCESS != dwRes)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_STATUS) failed for job id %ld (ec: %lc)"),
                    JobQueueEntry->UniqueId,
                    dwRes);
            }

            if (!CreateFaxEvent(0, FEI_DELETED, JobQueueEntry->JobId))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateFaxEvent failed. (ec: %ld)"),
                    GetLastError());
            }


            if (!UpdatePersistentJobStatus(JobQueueEntry))
            {
                DebugPrintEx(
                     DEBUG_ERR,
                     TEXT("Failed to update persistent job status to 0x%08x"),
                     JobQueueEntry->JobStatus);
                Assert(FALSE);
            }

            EnterCriticalSection (&g_CsOutboundActivityLogging);
            if (INVALID_HANDLE_VALUE == g_hOutboxActivityLogFile)
            {
                DebugPrintEx(DEBUG_ERR,
                        TEXT("Logging not initialized"));
            }
            else
            {
                if (!LogOutboundActivity(JobQueueEntry))
                {
                    DebugPrintEx(DEBUG_ERR, TEXT("Logging outbound activity failed"));
                }
            }
            LeaveCriticalSection (&g_CsOutboundActivityLogging);


            DecreaseJobRefCount(JobQueueEntry, TRUE); // This will mark it as JS_DELETING if needed
        }
        else if (JobQueueEntry->JobType == JT_ROUTING)
        {
            //
            // Remove the routing job
            //
            DebugPrintEx( DEBUG_MSG,
                          TEXT("[Job: %ld] Aborting ROUTING job (never in progress)."),
                          JobQueueEntry->JobId);
            JobQueueEntry->JobStatus = JS_DELETING;

            DecreaseJobRefCount (JobQueueEntry, TRUE);
        }
    }
    Rval = 0;

exit:
    LeaveCriticalSectionJobAndQueue;
    MemFree (lpUserSid);
    return Rval;
}


error_status_t
FAX_GetConfiguration(
    IN  handle_t FaxHandle,
    OUT LPBYTE *Buffer,
    IN  LPDWORD BufferSize
    )

/*++

Routine Description:

    Retrieves the FAX configuration from the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value == sizeof(FAX_CONFIGURATION).  If the BufferSize
    is not big enough, return an error and set BytesNeeded to the
    required size.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    Buffer      - Pointer to a FAX_CONFIGURATION structure.
    BufferSize  - Size of Buffer
    BytesNeeded - Number of bytes needed

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t rVal = ERROR_SUCCESS;
    PFAX_CONFIGURATION FaxConfig;
    ULONG_PTR Offset;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetConfiguration()"));
    BOOL fAccess;

    Assert (BufferSize);    // ref pointer in idl
    if (!Buffer)            // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // count up the number of bytes needed
    //

    *BufferSize = sizeof(FAX_CONFIGURATION);
    Offset = sizeof(FAX_CONFIGURATION);

    EnterCriticalSection (&g_CsConfig);

    if (g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder)
    {
        *BufferSize += StringSize( g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder );
    }

    *Buffer = (LPBYTE)MemAlloc( *BufferSize );
    if (*Buffer == NULL)
    {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    FaxConfig = (PFAX_CONFIGURATION)*Buffer;

    FaxConfig->SizeOfStruct          = sizeof(FAX_CONFIGURATION);
    FaxConfig->Retries               = g_dwFaxSendRetries;
    FaxConfig->RetryDelay            = g_dwFaxSendRetryDelay;
    FaxConfig->DirtyDays             = g_dwFaxDirtyDays;
    FaxConfig->Branding              = g_fFaxUseBranding;
    FaxConfig->UseDeviceTsid         = g_fFaxUseDeviceTsid;
    FaxConfig->ServerCp              = g_fServerCp;
    FaxConfig->StartCheapTime.Hour   = g_StartCheapTime.Hour;
    FaxConfig->StartCheapTime.Minute = g_StartCheapTime.Minute;
    FaxConfig->StopCheapTime.Hour    = g_StopCheapTime.Hour;
    FaxConfig->StopCheapTime.Minute  = g_StopCheapTime.Minute;
    FaxConfig->ArchiveOutgoingFaxes  = g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].bUseArchive;
    FaxConfig->PauseServerQueue      = (g_dwQueueState & FAX_OUTBOX_PAUSED) ? TRUE : FALSE;
    FaxConfig->Reserved              = NULL;

    StoreString(
        g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder,
        (PULONG_PTR)&FaxConfig->ArchiveDirectory,
        *Buffer,
        &Offset,
		*BufferSize
        );

exit:
    LeaveCriticalSection (&g_CsConfig);
    return rVal;
}



error_status_t
FAX_SetConfiguration(
    IN handle_t FaxHandle,
    IN const FAX_CONFIGURATION *FaxConfig
    )

/*++

Routine Description:

    Changes the FAX configuration on the FAX server.
    The SizeOfStruct in the FaxConfig argument MUST be
    set to a value == sizeof(FAX_CONFIGURATION).

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    Buffer      - Pointer to a FAX_CONFIGURATION structure.
    BufferSize  - Size of Buffer

Return Value:

    TRUE    - Success
    FALSE   - Failure, call GetLastError() for more error information.

--*/

{
    error_status_t rVal = ERROR_SUCCESS;
    LPTSTR s;
    BOOL b;
    BOOL bSendOutboxEvent = FALSE;
    BOOL bSendQueueStateEvent = FALSE;
    BOOL bSendArchiveEvent = FALSE;
    DWORD dwRes;
    DWORD dw;
    BOOL fAccess;
    DWORD dwNewQueueState;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetConfiguration"));

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_MANAGE_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }


    if (!FaxConfig || FaxConfig->SizeOfStruct != sizeof(FAX_CONFIGURATION))
    {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection (&g_CsQueue);
    EnterCriticalSection (&g_CsConfig);

    if (FaxConfig->ArchiveOutgoingFaxes)
    {
        //
        // make sure they give us something valid for a path if they want us to archive
        //
        if (!FaxConfig->ArchiveDirectory)
        {
            rVal = ERROR_INVALID_PARAMETER;
            goto exit;
        }
        rVal = IsValidArchiveFolder (LPWSTR(FaxConfig->ArchiveDirectory),
                                        FAX_MESSAGE_FOLDER_SENTITEMS);
        if (ERROR_SUCCESS != rVal)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid archive folder specified (%s), ec = %lu"),
                (LPTSTR)(FaxConfig->ArchiveDirectory),
                rVal);

            if(ERROR_ACCESS_DENIED == rVal && 
               FAX_API_VERSION_1 <= FindClientAPIVersion (FaxHandle))
            {
                rVal = FAX_ERR_FILE_ACCESS_DENIED;
            }

            goto exit;
        }
    }
    
    dwNewQueueState = g_dwQueueState;       
    (TRUE == FaxConfig->PauseServerQueue) ? (dwNewQueueState |= FAX_OUTBOX_PAUSED) : (dwNewQueueState &= ~FAX_OUTBOX_PAUSED);

    if ( g_dwQueueState != dwNewQueueState)
    {
        bSendQueueStateEvent = TRUE;
    }

    //
    // change the values in the registry
    //
    if (!IsLegalQueueSetting(dwNewQueueState))
    {		
        if (FAX_API_VERSION_1 > FindClientAPIVersion (FaxHandle))
        {
            dwRes = ERROR_ACCESS_DENIED;
        }
        else
        {
			dwRes = GetLastError();
            dwRes = (FAX_ERR_DIRECTORY_IN_USE == dwRes) ?  FAX_ERR_DIRECTORY_IN_USE : FAX_ERR_FILE_ACCESS_DENIED;
        }
        goto exit;
    }

    if (!SetFaxGlobalsRegistry((PFAX_CONFIGURATION) FaxConfig, dwNewQueueState))
    {
        //
        // Failed to set stuff
        //
        rVal = RPC_E_SYS_CALL_FAILED;
        goto exit;
    }
    //
    // change the values that the server is currently using
    //
    if (FaxConfig->PauseServerQueue)
    {
        if (!PauseServerQueue())
        {
            rVal = RPC_E_SYS_CALL_FAILED;
            goto exit;
        }
    }
    else
    {
        if (!ResumeServerQueue())
        {
            rVal = RPC_E_SYS_CALL_FAILED;
            goto exit;
        }
    }

    b = (BOOL)InterlockedExchange( (PLONG)&g_fFaxUseDeviceTsid,      FaxConfig->UseDeviceTsid );
    if ( b != FaxConfig->UseDeviceTsid)
    {
        bSendOutboxEvent = TRUE;
    }

    b = (BOOL)InterlockedExchange( (PLONG)&g_fFaxUseBranding,        FaxConfig->Branding );
    if ( !bSendOutboxEvent && b != FaxConfig->Branding)
    {
        bSendOutboxEvent = TRUE;
    }

    b = (BOOL)InterlockedExchange( (PLONG)&g_fServerCp,              FaxConfig->ServerCp );
    if ( !bSendOutboxEvent && b != FaxConfig->ServerCp)
    {
        bSendOutboxEvent = TRUE;
    }

    b = (BOOL)InterlockedExchange( (PLONG)&g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].bUseArchive,
                                    FaxConfig->ArchiveOutgoingFaxes );

    if ( b != FaxConfig->ArchiveOutgoingFaxes)
    {
        bSendArchiveEvent = TRUE;
    }


    dw = (DWORD)InterlockedExchange( (PLONG)&g_dwFaxSendRetries,        FaxConfig->Retries );
    if ( !bSendOutboxEvent && dw != FaxConfig->Retries)
    {
        bSendOutboxEvent = TRUE;
    }

    dw = (DWORD)InterlockedExchange( (PLONG)&g_dwFaxDirtyDays,          FaxConfig->DirtyDays );
    if ( !bSendOutboxEvent && dw != FaxConfig->DirtyDays)
    {
        bSendOutboxEvent = TRUE;
    }

    dw = (DWORD)InterlockedExchange( (PLONG)&g_dwFaxSendRetryDelay,     FaxConfig->RetryDelay );
    if ( !bSendOutboxEvent && dw != FaxConfig->RetryDelay)
    {
        bSendOutboxEvent = TRUE;
    }

    if ( (MAKELONG(g_StartCheapTime.Hour,g_StartCheapTime.Minute) != MAKELONG(FaxConfig->StartCheapTime.Hour,FaxConfig->StartCheapTime.Minute)) ||
            (MAKELONG(g_StopCheapTime.Hour,g_StopCheapTime.Minute)  != MAKELONG(FaxConfig->StopCheapTime.Hour, FaxConfig->StopCheapTime.Minute )) )
    {
        InterlockedExchange( (LPLONG)&g_StartCheapTime, MAKELONG(FaxConfig->StartCheapTime.Hour,FaxConfig->StartCheapTime.Minute) );
        InterlockedExchange( (LPLONG)&g_StopCheapTime, MAKELONG(FaxConfig->StopCheapTime.Hour,FaxConfig->StopCheapTime.Minute) );
        bSendOutboxEvent = TRUE;
    }

    s = (LPTSTR) InterlockedExchangePointer(
        (LPVOID *)&(g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder),
        FaxConfig->ArchiveDirectory ? (PVOID)StringDup( FaxConfig->ArchiveDirectory ) : NULL
        );
    if (s)
    {
        if (!bSendArchiveEvent)
        {
            if ( !FaxConfig->ArchiveDirectory ||
                    wcscmp(FaxConfig->ArchiveDirectory, s) != 0)

            {
                bSendArchiveEvent = TRUE;
            }
        }

        MemFree( s );
    }
    else
    {
        // s was NULL
        if (!bSendOutboxEvent && FaxConfig->ArchiveDirectory)
        {
            // value has changed
            bSendArchiveEvent = TRUE;
        }
    }    

    //
    // Send events
    //
    if (TRUE == bSendArchiveEvent)
    {
        dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_SENTITEMS);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_SENTITEMS) (ec: %lc)"),
                dwRes);
        }

        //
        // We want to refresh the archive size  and send quota warnings
        //
        g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].dwlArchiveSize = FAX_ARCHIVE_FOLDER_INVALID_SIZE;
        g_FaxQuotaWarn[FAX_MESSAGE_FOLDER_SENTITEMS].bConfigChanged = TRUE;
        g_FaxQuotaWarn[FAX_MESSAGE_FOLDER_SENTITEMS].bLoggedQuotaEvent = FALSE;

        if (!SetEvent (g_hArchiveQuotaWarningEvent))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to set quota warning event, SetEvent failed (ec: %lc)"),
                GetLastError());
        }
    }

    if (TRUE == bSendOutboxEvent)
    {
        dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_OUTBOX);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUTBOX) (ec: %lc)"),
                dwRes);
        }
    }


    if (TRUE == bSendQueueStateEvent)
    {
        dwRes = CreateQueueStateEvent (g_dwQueueState);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateQueueStateEvent() (ec: %lc)"),
                dwRes);
        }
    }


exit:
    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsQueue);
    return rVal;
}


DWORD
GetPortSize(
    PLINE_INFO LineInfo
    )
{
    DWORD Size;


    Size = sizeof(FAX_PORT_INFOW);
    Size += StringSize( LineInfo->DeviceName );
    Size += StringSize( LineInfo->Tsid );
    Size += StringSize( LineInfo->Csid );

    return Size;
}


BOOL
GetPortData(
    LPBYTE PortBuffer,
    PFAX_PORT_INFOW PortInfo,
    PLINE_INFO LineInfo,
    PULONG_PTR Offset,
	DWORD dwPortBufferSize
    )
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("GetPortData"));
    LPDWORD lpdwDevices = NULL;
    DWORD dwNumDevices = 0;
    DWORD i;
    PCGROUP pCGroup;

    pCGroup = g_pGroupsMap->FindGroup (ROUTING_GROUP_ALL_DEVICESW);
    if (NULL == pCGroup)
    {
        dwRes = GetLastError();
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingGroupsMap::FindGroup failed , ec %ld"), dwRes);
        return FALSE;
    }

    dwRes = pCGroup->SerializeDevices (&lpdwDevices, &dwNumDevices);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("COutboundRoutingGroup::EnumDevices failed , ec %ld"), dwRes);
        SetLastError (dwRes);
        return FALSE;
    }

    PortInfo->Priority = 0;
    for (i = 0; i < dwNumDevices; i++)
    {
        if (LineInfo->PermanentLineID == lpdwDevices[i])
        {
            PortInfo->Priority = i+1; // 1 based index
        }
    }
    if (0 == PortInfo->Priority)
    {
        DebugPrintEx(
               DEBUG_ERR,
               TEXT("%ld is not a valid device ID"), LineInfo->PermanentLineID);
        MemFree (lpdwDevices);
        SetLastError (ERROR_INVALID_PARAMETER);
        return FALSE;
    }
    MemFree (lpdwDevices);


    PortInfo->SizeOfStruct = sizeof(FAX_PORT_INFOW);
    PortInfo->DeviceId   = LineInfo->PermanentLineID;

    PortInfo->State = LineInfoToLegacyDeviceStatus(LineInfo);

    PortInfo->Flags      = LineInfo->Flags & 0x0fffffff;
    PortInfo->Rings      = LineInfo->RingsForAnswer;


    StoreString( LineInfo->DeviceName, 
		        (PULONG_PTR)&PortInfo->DeviceName,
				 PortBuffer, 
				 Offset,
				 dwPortBufferSize);
    StoreString( LineInfo->Tsid, 
		        (PULONG_PTR)&PortInfo->Tsid,
				 PortBuffer,
				 Offset,
				 dwPortBufferSize);
    StoreString( LineInfo->Csid,
				(PULONG_PTR)&PortInfo->Csid,
				PortBuffer,
				Offset,
				dwPortBufferSize);

    return (dwRes == ERROR_SUCCESS);
}

error_status_t
FAX_EnumPorts(
    handle_t    FaxHandle,
    LPBYTE      *PortBuffer,
    LPDWORD     BufferSize,
    LPDWORD     PortsReturned
    )

/*++

Routine Description:

    Enumerates all of the FAX devices attached to the
    FAX server.  The port state information is returned
    for each device.

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer
    PortBuffer      - Buffer to hold the port information
    BufferSize      - Total size of the port info buffer
    PortsReturned   - The number of ports in the buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    DWORD rVal = 0;
    PLIST_ENTRY Next;
    PLINE_INFO LineInfo;
    DWORD i;
    ULONG_PTR Offset;
    DWORD FaxDevices;
    PFAX_PORT_INFOW PortInfo;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumPorts()"));

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (BufferSize && PortsReturned);   // ref pointers in idl
    if (!PortBuffer)                        // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    EnterCriticalSection( &g_CsLine );

    if (!PortsReturned)
    {
        rVal = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if (!g_TapiLinesListHead.Flink)
    {
        rVal = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    Next = g_TapiLinesListHead.Flink;

    *PortsReturned = 0;
    *BufferSize = 0;
    FaxDevices = 0;

    //
    // count the number of bytes required
    //

    *BufferSize = 0;

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;

        if (LineInfo->PermanentLineID && LineInfo->DeviceName)
        {
            *BufferSize += sizeof(PFAX_PORT_INFOW);
            *BufferSize += GetPortSize( LineInfo );
            FaxDevices += 1;
        }
    }

    *PortBuffer = (LPBYTE) MemAlloc( *BufferSize );
    if (*PortBuffer == NULL)
    {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    PortInfo = (PFAX_PORT_INFOW) *PortBuffer;
    Offset = FaxDevices * sizeof(FAX_PORT_INFOW);

    Next = g_TapiLinesListHead.Flink;
    i = 0;

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        LineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        Next = LineInfo->ListEntry.Flink;

        if (LineInfo->PermanentLineID && LineInfo->DeviceName)
        {
            if (!GetPortData( *PortBuffer,
                                &PortInfo[i],
                                LineInfo,
                                &Offset,
								*BufferSize))
            {
                MemFree (*PortBuffer);
                *PortBuffer = NULL;
                *BufferSize = 0;
                rVal = GetLastError();
                goto exit;
            }
        }
        i++;
    }

    //
    // set the device count
    //
    *PortsReturned = FaxDevices;

exit:
    LeaveCriticalSection( &g_CsLine );
    return rVal;
}


error_status_t
FAX_GetPort(
    HANDLE FaxPortHandle,
    LPBYTE *PortBuffer,
    LPDWORD BufferSize
    )

/*++

Routine Description:

    Returns port status information for a requested port.
    The device id passed in should be optained from FAXEnumPorts.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    DeviceId    - TAPI device id
    PortBuffer  - Buffer to hold the port information
    BufferSize  - Total size of the port info buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    PLINE_INFO LineInfo;
    DWORD rVal = 0;
    ULONG_PTR Offset;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetPort()"));

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (BufferSize);   // ref pointer in idl
    if (!PortBuffer)       // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == FaxPortHandle)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("NULL context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    if (!LineInfo)
    {
        return ERROR_INVALID_DATA;
    }

    EnterCriticalSection (&g_CsLine);
    EnterCriticalSection (&g_CsConfig);   

    //
    // calculate the required buffer size
    //

    *BufferSize = GetPortSize( LineInfo );
    *PortBuffer = (LPBYTE) MemAlloc( *BufferSize );
    if (*PortBuffer == NULL)
    {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    Offset = sizeof(FAX_PORT_INFOW);
    if (!GetPortData( *PortBuffer,
                        (PFAX_PORT_INFO)*PortBuffer,
                        LineInfo,
                        &Offset,
						*BufferSize))
    {
        MemFree (*PortBuffer);
        *PortBuffer = NULL;
        *BufferSize = 0;
        rVal = GetLastError();
        goto Exit;
    }

Exit:
    LeaveCriticalSection( &g_CsConfig );
    LeaveCriticalSection( &g_CsLine );
    return rVal;
}

DWORD
SetDeviceOrder(
    DWORD dwDeviceId,
    DWORD dwNewOrder
    )
/*++

Routine name : SetDeviceOrder

Routine description:

    Sets the device order in <All Devices> group.

Author:

    Oded Sacher (OdedS), May, 2000

Arguments:

    dwDeviceId            [in] - Device ID.
    dwNewOrder            [in] - New order.

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("SetDeviceOrder"));
    DWORD rVal = ERROR_SUCCESS;
    HKEY hGroupKey = NULL;
    PCGROUP pCGroup = NULL;
    COutboundRoutingGroup OldGroup;

    // Open the <All Devices> group registry key
    hGroupKey = OpenOutboundGroupKey( ROUTING_GROUP_ALL_DEVICESW, FALSE, KEY_READ | KEY_WRITE );
    if (NULL == hGroupKey)
    {
        rVal = GetLastError ();
        DebugPrintEx(
          DEBUG_ERR,
          TEXT("Can't open group key, OpenOutboundGroupKey failed  : %ld"),
          rVal);
        goto exit;
    }

    // Find the group in memory
    pCGroup = g_pGroupsMap->FindGroup (ROUTING_GROUP_ALL_DEVICESW);
    if (!pCGroup)
    {
        rVal = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::FindGroup failed, Group name - %s,  error %ld"),
            ROUTING_GROUP_ALL_DEVICESW,
            rVal);
        goto exit;
    }
    // Save a copy of the old group
    OldGroup = *pCGroup;

    // Cahnge the device order in the group
    rVal = pCGroup->SetDeviceOrder(dwDeviceId, dwNewOrder);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroupsMap::SetDeviceOrder failed, Group name - %s,\
                  Device Id %ld, new order %ld,   error %ld"),
            ROUTING_GROUP_ALL_DEVICESW,
            dwDeviceId,
            dwNewOrder,
            rVal);
        goto exit;
    }

    // save changes to the registry
    rVal = pCGroup->Save (hGroupKey);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("COutboundRoutingGroup::Save failed, Group name - %s,  failed with %ld"),
            ROUTING_GROUP_ALL_DEVICESW,
            rVal);
        // Rollback memory
        *pCGroup = OldGroup;
    }

exit:
    if (NULL != hGroupKey)
    {
        RegCloseKey (hGroupKey);
    }
    return rVal;
}



error_status_t
FAX_SetPort(
    HANDLE FaxPortHandle,
    const FAX_PORT_INFOW *PortInfo
    )

/*++

Routine Description:

    Changes the port capability mask.  This allows the caller to
    enable or disable sending & receiving on a port basis.

Arguments:

    FaxHandle   - FAX handle obtained from FaxConnectFaxServer.
    PortBuffer  - Buffer to hold the port information
    BufferSize  - Total size of the port info buffer

Return Value:

    ERROR_SUCCESS for success, otherwise a WIN32 error code.

--*/

{
    DWORD rVal = 0;
    DWORD flags = 0;
    PLINE_INFO LineInfo;
    DWORD totalDevices;
    BOOL SendEnabled = FALSE;
    DWORD dwRes;
    BOOL fAccess;
    BOOL bDeviceWasReceiveEnabled;
    BOOL fDeviceWasEnabled;
    BOOL bCancelManualAnswerDevice = FALSE; // Should we cancel (zero) the manual answer device?
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetPort"));

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_MANAGE_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    if (!PortInfo)       // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == FaxPortHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Empty context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    if (!LineInfo)
    {
        return ERROR_INVALID_DATA;
    }

    EnterCriticalSection( &g_CsJob );
    EnterCriticalSection( &g_CsLine );
    EnterCriticalSection (&g_CsConfig);

    bDeviceWasReceiveEnabled = (LineInfo->Flags & FPF_RECEIVE) ? TRUE : FALSE;
    fDeviceWasEnabled = IsDeviceEnabled(LineInfo);
    
    if (PortInfo->SizeOfStruct != sizeof(FAX_PORT_INFOW))
    {
        rVal = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //
    // Check if we exceed device limit
    //
    if (g_dwDeviceEnabledCount >= g_dwDeviceEnabledLimit &&                             // We are at the device limit
        !fDeviceWasEnabled                               &&                             // It was not send/receive/manual receive enabled
        ((PortInfo->Flags & FPF_SEND) || (PortInfo->Flags & FPF_RECEIVE)))              // It is now set to send/receive enabled
    {
        if (FAX_API_VERSION_1 > FindClientAPIVersion (FaxPortHandle))
        {
            //
            // API version 0 clients don't know about FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED
            //
            rVal = ERROR_INVALID_PARAMETER;
        }
        else
        {
            rVal = FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED;
        }
        goto Exit;
    }

    if (LineInfo->PermanentLineID == g_dwManualAnswerDeviceId &&
        ((PortInfo->Flags) & FPF_RECEIVE))
    {
        //
        // Can't set device to auto-answer when it's in manual-answer mode.
        // So, we mark a flag that will cause (towards the end of the function, if everything is ok)
        // the disabling of the manual-answer device.
        //
        bCancelManualAnswerDevice = TRUE;
    }

    //
    // make sure the user sets a reasonable priority
    //
    totalDevices = GetFaxDeviceCount();
    if (0 == PortInfo->Priority ||
        PortInfo->Priority > totalDevices)
    {
        rVal = ERROR_INVALID_PARAMETER;
        goto Exit;
    }       

    rVal = SetDeviceOrder(LineInfo->PermanentLineID, PortInfo->Priority);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                        TEXT("SetDeviceOrder Failed, Error : %ld"),
                        rVal);
        goto Exit;
    }
    //
    // HACK: we allow the ring count to be set even if the line is in use so that systray will work.  we don't allow
    //  the user to change things like CSID/TSID or tapi related information since that cannot change until the call
    //  transaction is complete.
    //
    LineInfo->RingsForAnswer = PortInfo->Rings;        

    flags = PortInfo->Flags & (FPF_CLIENT_BITS);

    //
    // first change the real time data that the server is using
    //
    if ((!(LineInfo->Flags & FPF_RECEIVE)) && (flags & FPF_RECEIVE))
    {
        //
        // Device was NOT receive-enabled and now turned into receive-enabled
        //
        if (!(LineInfo->Flags & FPF_VIRTUAL) && (!LineInfo->hLine))
        {
            if (!OpenTapiLine( LineInfo ))
            {
                DWORD rc = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("OpenTapiLine failed. (ec: %ld)"),
                    rc);
            }
        }
    }
    else if ((LineInfo->Flags & FPF_RECEIVE) && (!(flags & FPF_RECEIVE)))
    {
        //
        // Device was receive-enabled and now turned into not receive-enabled
        //
        if (LineInfo->State == FPS_AVAILABLE                        &&  // Line available and
            LineInfo->hLine                                             // device is open
            )
        {
            lineClose( LineInfo->hLine );
            LineInfo->hLine = 0;
        }
    }

    if (!(LineInfo->Flags & FPF_SEND) && (flags & FPF_SEND))
    {
        LineInfo->LastLineClose = 0; // Try to use it on the first try
        SendEnabled = TRUE;
    }

    if ((LineInfo->Flags & FPF_CLIENT_BITS) != (flags & FPF_CLIENT_BITS))
    {
        UpdateVirtualDeviceSendAndReceiveStatus (LineInfo,
                                                    LineInfo->Flags & FPF_SEND,
                                                    LineInfo->Flags & FPF_RECEIVE
                                            );
    }

    LineInfo->Flags = (LineInfo->Flags & ~FPF_CLIENT_BITS) | flags;
    LineInfo->RingsForAnswer = PortInfo->Rings;

    if (PortInfo->Tsid)
    {
        MemFree( LineInfo->Tsid );
        LineInfo->Tsid = StringDup( PortInfo->Tsid );
    }
    if (PortInfo->Csid)
    {
        MemFree( LineInfo->Csid );
        LineInfo->Csid = StringDup( PortInfo->Csid );
    }

    //
    // now change the registry so it sticks
    // (need to change all devices, since the priority may have changed)
    //
    CommitDeviceChanges(LineInfo);    

    if ((ERROR_SUCCESS == rVal) && bCancelManualAnswerDevice)
    {
        //
        // This is the time to cancel (in memory and the registry) the manual answer device
        //
        g_dwManualAnswerDeviceId = 0;
        dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
    }
    dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_DEVICES);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_DEVICES) (ec: %lc)"),
            dwRes);
    }

    if (bDeviceWasReceiveEnabled && !(LineInfo->Flags & FPF_RECEIVE))
    {
        //
        // This device stopped receiving
        //
        SafeDecIdleCounter (&g_dwReceiveDevicesCount);
    }
    else if (!bDeviceWasReceiveEnabled && (LineInfo->Flags & FPF_RECEIVE))
    {
        //
        // This device started receiving
        //
        SafeIncIdleCounter (&g_dwReceiveDevicesCount);
    }

    //
    // Update enabled device count
    //
    if (fDeviceWasEnabled == TRUE)
    {
        if (FALSE == IsDeviceEnabled(LineInfo))
        {
            Assert (g_dwDeviceEnabledCount);
            g_dwDeviceEnabledCount -= 1;
        }
    }
    else
    {
        //
        // The device was not enabled
        //
        if (TRUE == IsDeviceEnabled(LineInfo))
        {
            g_dwDeviceEnabledCount += 1;
            Assert (g_dwDeviceEnabledCount <= g_dwDeviceEnabledLimit);
        }
    }

Exit:
    LeaveCriticalSection( &g_CsConfig );
    LeaveCriticalSection( &g_CsLine );
    LeaveCriticalSection( &g_CsJob );

    if (SendEnabled)
    {
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetEvent failed (ec: %lc)"),
                GetLastError);
            EnterCriticalSection (&g_CsQueue);
            g_ScanQueueAfterTimeout = TRUE;
            LeaveCriticalSection (&g_CsQueue);
        }
    }

    return rVal;
}


typedef struct _ENUM_CONTEXT {
    DWORD               Function;
    DWORD               Size;
    ULONG_PTR            Offset;
    PLINE_INFO          LineInfo;
    PFAX_ROUTING_METHOD RoutingInfoMethod;
	DWORD               dwRoutingInfoMethodSize;
} ENUM_CONTEXT, *PENUM_CONTEXT;


BOOL CALLBACK
RoutingMethodEnumerator(
    PROUTING_METHOD RoutingMethod,
    LPVOID lpEnumCtxt
    )
{
    PENUM_CONTEXT EnumContext=(PENUM_CONTEXT)lpEnumCtxt;
    LPWSTR GuidString;

    //
    // we only access read-only static data in the LINE_INFO structure.
    // make sure that this access is protected if you access dynamic
    // data in the future.
    //

    if (EnumContext->Function == 1)
    {
        //
        // Enumerate (read)
        //
        EnumContext->Size += sizeof(FAX_ROUTING_METHOD);

        StringFromIID( RoutingMethod->Guid, &GuidString );

        EnumContext->Size += StringSize( GuidString );
        EnumContext->Size += StringSize( EnumContext->LineInfo->DeviceName );
        EnumContext->Size += StringSize( RoutingMethod->FunctionName );
        EnumContext->Size += StringSize( RoutingMethod->FriendlyName );
        EnumContext->Size += StringSize( RoutingMethod->RoutingExtension->ImageName );
        EnumContext->Size += StringSize( RoutingMethod->RoutingExtension->FriendlyName );

        CoTaskMemFree( GuidString );

        return TRUE;
    }

    if (EnumContext->Function == 2)
    {
        //
        // Set data
        //
        StringFromIID( RoutingMethod->Guid, &GuidString );

        EnumContext->RoutingInfoMethod[EnumContext->Size].SizeOfStruct = sizeof(FAX_ROUTING_METHOD);
        EnumContext->RoutingInfoMethod[EnumContext->Size].DeviceId = EnumContext->LineInfo->PermanentLineID;

        __try
        {
            EnumContext->RoutingInfoMethod[EnumContext->Size].Enabled =
                RoutingMethod->RoutingExtension->FaxRouteDeviceEnable(
                    GuidString,
                    EnumContext->LineInfo->PermanentLineID,
                    QUERY_STATUS
                );
        }
        __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, RoutingMethod->RoutingExtension->FriendlyName, GetExceptionCode()))
        {
            ASSERT_FALSE;
        }

        StoreString(
            EnumContext->LineInfo->DeviceName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].DeviceName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        StoreString(
            GuidString,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].Guid,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
            EnumContext->dwRoutingInfoMethodSize
			);

        StoreString(
            RoutingMethod->FriendlyName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].FriendlyName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        StoreString(
            RoutingMethod->FunctionName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].FunctionName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        StoreString(
            RoutingMethod->RoutingExtension->ImageName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].ExtensionImageName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        StoreString(
            RoutingMethod->RoutingExtension->FriendlyName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].ExtensionFriendlyName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        EnumContext->Size += 1;
        CoTaskMemFree( GuidString );

        return TRUE;
    }

    return FALSE;
}


error_status_t
FAX_EnumRoutingMethods(
    IN HANDLE FaxPortHandle,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize,
    OUT LPDWORD MethodsReturned
    )
{
    PLINE_INFO      LineInfo;
    ENUM_CONTEXT    EnumContext;
    DWORD           CountMethods;
    BOOL fAccess;
    DWORD rVal = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumRoutingMethods()"));

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (RoutingInfoBufferSize && MethodsReturned);  // ref pointers in idl
    if (!RoutingInfoBuffer)                             // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }   

    if (NULL == FaxPortHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Empty context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    if (!LineInfo)
    {
        return ERROR_INVALID_DATA;
    }

    //
    // note that the called routines are protected so we don't have any protection here
    //

    //
    // compute the required size of the buffer
    //

    EnumContext.Function = 1;
    EnumContext.Size = 0;
    EnumContext.Offset = 0;
    EnumContext.LineInfo = LineInfo;
    EnumContext.RoutingInfoMethod = NULL;
	EnumContext.dwRoutingInfoMethodSize = 0;

    CountMethods = EnumerateRoutingMethods( RoutingMethodEnumerator, &EnumContext );

    rVal = GetLastError();
    if (ERROR_SUCCESS != rVal)
    {
        //
        //  Function failed in enumeration
        //
        return rVal;
    }

    if (CountMethods == 0)
    {
        //
        //  No Methods registered
        //
        *RoutingInfoBuffer = NULL;
        *RoutingInfoBufferSize = 0;
        *MethodsReturned = 0;

        return ERROR_SUCCESS;
    }

    //
    // allocate the buffer
    //

    *RoutingInfoBufferSize = EnumContext.Size;
    *RoutingInfoBuffer = (LPBYTE) MemAlloc( *RoutingInfoBufferSize );
    if (*RoutingInfoBuffer == NULL)
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // fill the buffer with the data
    //

    EnumContext.Function = 2;
    EnumContext.Size = 0;
    EnumContext.Offset = sizeof(FAX_ROUTING_METHODW) * CountMethods;
    EnumContext.LineInfo = LineInfo;
    EnumContext.RoutingInfoMethod = (PFAX_ROUTING_METHOD) *RoutingInfoBuffer;
	EnumContext.dwRoutingInfoMethodSize = *RoutingInfoBufferSize;

    if (!EnumerateRoutingMethods( RoutingMethodEnumerator, &EnumContext))
    {
        MemFree( *RoutingInfoBuffer );
        *RoutingInfoBuffer = NULL;
        *RoutingInfoBufferSize = 0;
        return ERROR_INVALID_FUNCTION;
    }

    *MethodsReturned = CountMethods;


    return 0;
}


error_status_t
FAX_EnableRoutingMethod(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuidString,
    IN BOOL Enabled
    )
{
    error_status_t  ec = 0;
    BOOL            bRes;
    PLINE_INFO      LineInfo;
    PROUTING_METHOD RoutingMethod;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnableRoutingMethod"));

    //
    // Access check
    //
    ec = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ec);
        return ec;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_MANAGE_CONFIG "));
        return ERROR_ACCESS_DENIED;
    }

    if (NULL == FaxPortHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Empty context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    if (!LineInfo)
    {
        return ERROR_INVALID_DATA;
    }

    if (!RoutingGuidString)
    {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &g_CsRouting );

    //
    // get the routing method
    //

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuidString );
    if (!RoutingMethod)
    {
        LeaveCriticalSection( &g_CsRouting );
        DebugPrintEx(DEBUG_ERR,
                     TEXT("Couldn't find routing method with GUID %s"),
                     RoutingGuidString);
        return ERROR_INVALID_DATA;
    }

    //
    // enable/disable the routing method for this device
    //

    __try
    {
        bRes = RoutingMethod->RoutingExtension->FaxRouteDeviceEnable(
                     (LPWSTR)RoutingGuidString,
                     LineInfo->PermanentLineID,
                     Enabled ? STATUS_ENABLE : STATUS_DISABLE);
    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, RoutingMethod->RoutingExtension->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }
    if (!bRes)
    {
        //
        // FaxRouteDeviceEnable failed
        //
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                     TEXT("FaxRouteDeviceEnable failed with %ld"),
                     ec);
    }

    LeaveCriticalSection( &g_CsRouting );

    return ec;
}


typedef struct _ENUM_GLOBALCONTEXT {
    DWORD               Function;
    DWORD               Size;
    ULONG_PTR            Offset;
    PFAX_GLOBAL_ROUTING_INFO RoutingInfoMethod;
	DWORD  dwRoutingInfoMethodSize;
} ENUM_GLOBALCONTEXT, *PENUM_GLOBALCONTEXT;


BOOL CALLBACK
GlobalRoutingInfoMethodEnumerator(
    PROUTING_METHOD RoutingMethod,
    LPVOID lpEnumCtxt
    )
{
    PENUM_GLOBALCONTEXT EnumContext=(PENUM_GLOBALCONTEXT)lpEnumCtxt;
    LPWSTR GuidString;


    if (EnumContext->Function == 1) {

        EnumContext->Size += sizeof(FAX_GLOBAL_ROUTING_INFO);

        StringFromIID( RoutingMethod->Guid, &GuidString );

        EnumContext->Size += StringSize( GuidString );
        EnumContext->Size += StringSize( RoutingMethod->FunctionName );
        EnumContext->Size += StringSize( RoutingMethod->FriendlyName );
        EnumContext->Size += StringSize( RoutingMethod->RoutingExtension->ImageName );
        EnumContext->Size += StringSize( RoutingMethod->RoutingExtension->FriendlyName );

        CoTaskMemFree( GuidString );

        return TRUE;
    }

    if (EnumContext->Function == 2) {

        StringFromIID( RoutingMethod->Guid, &GuidString );

        EnumContext->RoutingInfoMethod[EnumContext->Size].SizeOfStruct = sizeof(FAX_GLOBAL_ROUTING_INFO);

        EnumContext->RoutingInfoMethod[EnumContext->Size].Priority = RoutingMethod->Priority;


        StoreString(
            GuidString,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].Guid,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        StoreString(
            RoutingMethod->FriendlyName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].FriendlyName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        StoreString(
            RoutingMethod->FunctionName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].FunctionName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        StoreString(
            RoutingMethod->RoutingExtension->ImageName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].ExtensionImageName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        StoreString(
            RoutingMethod->RoutingExtension->FriendlyName,
            (PULONG_PTR)&EnumContext->RoutingInfoMethod[EnumContext->Size].ExtensionFriendlyName,
            (LPBYTE)EnumContext->RoutingInfoMethod,
            &EnumContext->Offset,
			EnumContext->dwRoutingInfoMethodSize
            );

        EnumContext->Size += 1;
        CoTaskMemFree( GuidString );

        return TRUE;
    }

    return FALSE;
}



error_status_t
FAX_EnumGlobalRoutingInfo(
    IN handle_t FaxHandle ,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize,
    OUT LPDWORD MethodsReturned
    )
{

    DWORD           CountMethods;
    ENUM_GLOBALCONTEXT EnumContext;
    BOOL fAccess;
    DWORD ec = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumGlobalRoutingInfo"));

    //
    // Access check
    //
    ec = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ec);
        return ec;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (RoutingInfoBufferSize && MethodsReturned);  // ref pointer in idl
    if (!RoutingInfoBuffer)                             // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // compute the required size of the buffer
    //

    EnumContext.Function = 1;
    EnumContext.Size = 0;
    EnumContext.Offset = 0;
    EnumContext.RoutingInfoMethod = NULL;
	EnumContext.dwRoutingInfoMethodSize = 0;

    CountMethods = EnumerateRoutingMethods( GlobalRoutingInfoMethodEnumerator, &EnumContext );

    ec = GetLastError();
    if (ERROR_SUCCESS != ec)
    {
        //
        //  Function failed in enumeration
        //
        return ec;
    }

    if (CountMethods == 0)
    {
        //
        //  No Methods registered
        //
        *RoutingInfoBuffer = NULL;
        *RoutingInfoBufferSize = 0;
        *MethodsReturned = 0;

        return ERROR_SUCCESS;
    }

    //
    // allocate the buffer
    //

    *RoutingInfoBufferSize = EnumContext.Size;
    *RoutingInfoBuffer = (LPBYTE) MemAlloc( *RoutingInfoBufferSize );
    if (*RoutingInfoBuffer == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // fill the buffer with the data
    //

    EnumContext.Function = 2;
    EnumContext.Size = 0;
    EnumContext.Offset = sizeof(FAX_GLOBAL_ROUTING_INFOW) * CountMethods;
    EnumContext.RoutingInfoMethod = (PFAX_GLOBAL_ROUTING_INFO) *RoutingInfoBuffer;
	EnumContext.dwRoutingInfoMethodSize = *RoutingInfoBufferSize;

    if (!EnumerateRoutingMethods( GlobalRoutingInfoMethodEnumerator, &EnumContext )) {
        MemFree( *RoutingInfoBuffer );
        *RoutingInfoBuffer = NULL;
        *RoutingInfoBufferSize = 0;
        return ERROR_INVALID_FUNCTION;
    }

    *MethodsReturned = CountMethods;

    return 0;
}



error_status_t
FAX_SetGlobalRoutingInfo(
    IN HANDLE FaxHandle,
    IN const FAX_GLOBAL_ROUTING_INFOW *RoutingInfo
    )
{
    error_status_t  ec = 0;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetGlobalRoutingInfo"));

    //
    // Access check
    //
    ec = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != ec)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ec);
        return ec;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_MANAGE_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    PROUTING_METHOD RoutingMethod;

    //
    // verify that the client as access rights
    //

    if (!RoutingInfo)
    {
        return ERROR_INVALID_PARAMETER;
    }
    
    if (RoutingInfo->SizeOfStruct != sizeof(FAX_GLOBAL_ROUTING_INFOW))
    {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &g_CsRouting );

    //
    // get the routing method
    //

    RoutingMethod = FindRoutingMethodByGuid( RoutingInfo->Guid );
    if (!RoutingMethod)
    {
        LeaveCriticalSection( &g_CsRouting );
        return ERROR_INVALID_DATA;
    }

    //
    // change the priority
    //

    RoutingMethod->Priority = RoutingInfo->Priority;
    SortMethodPriorities();
    CommitMethodChanges();

    LeaveCriticalSection( &g_CsRouting );
    return ec;
}


error_status_t
FAX_GetRoutingInfo(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuidString,
    OUT LPBYTE *RoutingInfoBuffer,
    OUT LPDWORD RoutingInfoBufferSize
    )
{
    error_status_t      ec=0;
    PLINE_INFO          LineInfo;
    PROUTING_METHOD     RoutingMethod;
    LPBYTE              RoutingInfo = NULL;
    DWORD               RoutingInfoSize = 0;
    BOOL                fAccess;
    BOOL                bRes;
    DWORD Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetRoutingInfo()"));

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (RoutingInfoBufferSize);                     // ref pointer in idl
    if (!RoutingGuidString || !RoutingInfoBuffer)      // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == FaxPortHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Empty context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    if (!LineInfo)
    {
        return ERROR_INVALID_DATA;
    }

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuidString );
    if (!RoutingMethod)
    {
        return ERROR_INVALID_DATA;
    }

    __try
    {
        //
        // first check to see how big the buffer needs to be
        //
        bRes = RoutingMethod->RoutingExtension->FaxRouteGetRoutingInfo(
                (LPWSTR) RoutingGuidString,
                LineInfo->PermanentLineID,
                NULL,
                &RoutingInfoSize );
    }                
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, RoutingMethod->RoutingExtension->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }
                
    if (bRes)
    {
        //
        // allocate a client buffer
        //
        RoutingInfo = (LPBYTE) MemAlloc( RoutingInfoSize );
        if (RoutingInfo == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        //
        // get the routing data
        //
        __try
        {
            bRes = RoutingMethod->RoutingExtension->FaxRouteGetRoutingInfo(
                    RoutingGuidString,
                    LineInfo->PermanentLineID,
                    RoutingInfo,
                    &RoutingInfoSize );
        }                
        __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, RoutingMethod->RoutingExtension->FriendlyName, GetExceptionCode()))
        {
            ASSERT_FALSE;
        }
        if (bRes)
        {
            //
            // move the data to the return buffer
            //
            *RoutingInfoBuffer = RoutingInfo;
            *RoutingInfoBufferSize = RoutingInfoSize;
            return ERROR_SUCCESS;
        }
        else
        {
            //
            // FaxRouteGetRoutingInfo failed so return last error
            //
            ec = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                TEXT("FaxRouteGetRoutingInfo failed with %ld in trying to find out buffer size"),
                ec);
			MemFree(RoutingInfo);
			return ec;
        }
    }
    else
    {
        //
        // FaxRouteGetRoutingInfo failed so return last error
        //
        ec = GetLastError();
        DebugPrintEx(DEBUG_ERR,
            TEXT("FaxRouteGetRoutingInfo failed with %ld in trying get the routing data"),
            ec);			
        return ec;
    }
    return ERROR_INVALID_FUNCTION;
}   // FAX_GetRoutingInfo


error_status_t
FAX_SetRoutingInfo(
    IN HANDLE FaxPortHandle,
    IN LPCWSTR RoutingGuidString,
    IN const BYTE *RoutingInfoBuffer,
    IN DWORD RoutingInfoBufferSize
    )
{
    error_status_t      ec=0;
    PLINE_INFO          LineInfo;
    PROUTING_METHOD     RoutingMethod;
    BOOL fAccess;
    DWORD rVal = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetRoutingInfo"));

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_MANAGE_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }


    if (!RoutingGuidString || !RoutingInfoBuffer || !RoutingInfoBufferSize)
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (NULL == FaxPortHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            _T("Empty context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    LineInfo = ((PHANDLE_ENTRY)FaxPortHandle)->LineInfo;
    if (!LineInfo)
    {
        return ERROR_INVALID_DATA;
    }

    RoutingMethod = FindRoutingMethodByGuid( RoutingGuidString );
    if (!RoutingMethod)
    {
        return ERROR_INVALID_DATA;
    }

    __try
    {
        if (RoutingMethod->RoutingExtension->FaxRouteSetRoutingInfo(
                RoutingGuidString,
                LineInfo->PermanentLineID,
                RoutingInfoBuffer,
                RoutingInfoBufferSize ))
        {
            return ERROR_SUCCESS;
        }
        else
        {
            //
            // FaxRouteSetRoutingInfo failed so return last error
            //
            ec = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                TEXT("FaxRouteSetRoutingInfo failed with %ld"),
                ec);
            return ec;
        }
    }
    __except (HandleFaxExtensionFault(EXCEPTION_SOURCE_ROUTING_EXT, RoutingMethod->RoutingExtension->FriendlyName, GetExceptionCode()))
    {
        ASSERT_FALSE;
    }

    return ERROR_INVALID_FUNCTION;
}



error_status_t
FAX_GetCountryList(
    IN  HANDLE      FaxHandle,
    OUT LPBYTE*     Buffer,
    OUT LPDWORD     BufferSize
   )
/*++

Routine Description:

    Return a list of countries from TAPI

Arguments:

    FaxHandle       - FAX handle obtained from FaxConnectFaxServer.
    Buffer          - A pointer to the buffer into which the output should be copied.
    BufferSize      - Buffer Size

Return Value:

    TRUE if successful, FALSE if there is an error

--*/

{
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetCountryList"));

    LPLINECOUNTRYLIST           lpCountryList = NULL;
    LPLINECOUNTRYENTRY          lpEntry = NULL;
    PFAX_TAPI_LINECOUNTRY_LIST  pLineCountryList = NULL;
    ULONG_PTR                   Offset = NULL;
    LONG                        rVal = ERROR_SUCCESS;
    DWORD                       dwIndex;
    BOOL                        fAccess;
    DWORD                       dwRights;

    Assert (BufferSize);    // ref pointer in idl   
    if (!Buffer)            // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    *Buffer = NULL;
    *BufferSize = 0;

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }
   
    if (!(lpCountryList = GetCountryList()))
    {
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    *BufferSize = lpCountryList->dwTotalSize;
    *Buffer = (LPBYTE)MemAlloc(lpCountryList->dwTotalSize);
    if (*Buffer == NULL)
    {
		*BufferSize = 0;
        rVal = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    pLineCountryList = (PFAX_TAPI_LINECOUNTRY_LIST) *Buffer;
    pLineCountryList->dwNumCountries = lpCountryList->dwNumCountries;

    Offset = sizeof(FAX_TAPI_LINECOUNTRY_LIST);

    pLineCountryList->LineCountryEntries = (PFAX_TAPI_LINECOUNTRY_ENTRY) ((LPBYTE) pLineCountryList + Offset);

    // offset points to the end of the structure- beginning of the "string field"
    Offset += (lpCountryList->dwNumCountries * sizeof(FAX_TAPI_LINECOUNTRY_ENTRY));

    lpEntry = (LPLINECOUNTRYENTRY)  // init array of entries
        ((PBYTE) lpCountryList + lpCountryList->dwCountryListOffset);

    for (dwIndex=0; dwIndex < pLineCountryList->dwNumCountries; dwIndex++)
    {
        pLineCountryList->LineCountryEntries[dwIndex].dwCountryCode =
            lpEntry[dwIndex].dwCountryCode;
        pLineCountryList->LineCountryEntries[dwIndex].dwCountryID =
            lpEntry[dwIndex].dwCountryID;
        // copy Country names
        if (lpEntry[dwIndex].dwCountryNameSize && lpEntry[dwIndex].dwCountryNameOffset)
        {
            pLineCountryList->LineCountryEntries[dwIndex].lpctstrCountryName =
                (LPWSTR) ((LPBYTE) pLineCountryList + Offset);
            Offset += lpEntry[dwIndex].dwCountryNameSize;
            _tcscpy(
                (LPWSTR)pLineCountryList->LineCountryEntries[dwIndex].lpctstrCountryName,
                (LPWSTR) ((LPBYTE)lpCountryList + lpEntry[dwIndex].dwCountryNameOffset)
                );
        }
        else
        {
            pLineCountryList->LineCountryEntries[dwIndex].lpctstrCountryName = NULL;
        }
        // copy LongDistanceRule
        if (lpEntry[dwIndex].dwLongDistanceRuleSize && lpEntry[dwIndex].dwLongDistanceRuleOffset)
        {
            pLineCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule =
                (LPWSTR) ((LPBYTE) pLineCountryList + Offset);
            Offset += lpEntry[dwIndex].dwLongDistanceRuleSize;
            _tcscpy(
                (LPWSTR)pLineCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule,
                (LPWSTR) ((LPBYTE)lpCountryList + lpEntry[dwIndex].dwLongDistanceRuleOffset)
                );
        }
        else
        {
            pLineCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule = NULL;
        }
    }
    for (dwIndex=0; dwIndex < pLineCountryList->dwNumCountries; dwIndex++)
    {
        if (pLineCountryList->LineCountryEntries[dwIndex].lpctstrCountryName)
        {
            pLineCountryList->LineCountryEntries[dwIndex].lpctstrCountryName =
                (LPWSTR) ((ULONG_PTR)pLineCountryList->LineCountryEntries[dwIndex].lpctstrCountryName - (ULONG_PTR)pLineCountryList);
        }
        if (pLineCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule)
        {
            pLineCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule =
                (LPWSTR) ((ULONG_PTR)pLineCountryList->LineCountryEntries[dwIndex].lpctstrLongDistanceRule - (ULONG_PTR)pLineCountryList);
        }
    }

    pLineCountryList->LineCountryEntries =
        (PFAX_TAPI_LINECOUNTRY_ENTRY) ((LPBYTE)pLineCountryList->LineCountryEntries -
                                        (ULONG_PTR)pLineCountryList);    

exit:
    return rVal;
}

error_status_t
FAX_GetLoggingCategories(
    IN handle_t hBinding,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize,
    OUT LPDWORD NumberCategories
    )
{
    BOOL fAccess;
    DWORD Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetLoggingCategories()"));

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_QUERY_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }


    Assert (BufferSize && NumberCategories);    // ref pointer in idl
    if (!Buffer)                                // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    EnterCriticalSection( &g_CsConfig );
    Rval = GetLoggingCategories(
                                (PFAX_LOG_CATEGORY*)Buffer,
                                BufferSize,
                                NumberCategories);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetLoggingCategories failed (ec: %ld)"),
            Rval);
    }
    LeaveCriticalSection( &g_CsConfig );
    return Rval;
}


error_status_t
FAX_SetLoggingCategories(
    IN handle_t hBinding,
    IN const LPBYTE Buffer,
    IN DWORD BufferSize,
    IN DWORD NumberCategories
    )
{
    REG_FAX_LOGGING FaxRegLogging;
    DWORD i;
    DWORD dwRes;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetLoggingCategories"));

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_MANAGE_CONFIG"));
        return ERROR_ACCESS_DENIED;
    }

    if (!Buffer || !BufferSize)
    {
        return ERROR_INVALID_PARAMETER;
    }

    FaxRegLogging.LoggingCount = NumberCategories;
    FaxRegLogging.Logging = (PREG_CATEGORY) Buffer;

    for (i = 0; i < FaxRegLogging.LoggingCount; i++)
    {
        LPWSTR lpwstrCategoryName;
        LPWSTR lpcwstrString;

        lpwstrCategoryName = (LPWSTR) FixupString(Buffer,FaxRegLogging.Logging[i].CategoryName);       

        //
        //  Verify that pointer+offset is in the buffer range
        //
        if ((BYTE*)lpwstrCategoryName >= ((BYTE*)Buffer + BufferSize) ||
            (BYTE*)lpwstrCategoryName < (BYTE*)Buffer)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Input buffer is currupted on FAX_SetLoggingCategories.")
                );         
            return ERROR_INVALID_PARAMETER;
        }

        //
        // Make sure string ends within the buffer bounds
        //
        lpcwstrString = lpwstrCategoryName;
        while (*lpcwstrString != TEXT('\0'))
        {
            lpcwstrString++;
            if (lpcwstrString >= (LPCWSTR)((BYTE*)Buffer + BufferSize))
            {
                //
                // Going to exceed structure - corrupted offset
                //
                return ERROR_INVALID_PARAMETER;
            }
        }
        FaxRegLogging.Logging[i].CategoryName = lpwstrCategoryName;
    }

    //
    // setup the data
    //
    EnterCriticalSection (&g_CsConfig);

    //
    //  first change the registry so it sticks
    //
    if (!SetLoggingCategoriesRegistry( &FaxRegLogging ))
    {
        dwRes = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                    TEXT("SetLoggingCategoriesRegistry"),
                     dwRes);
        LeaveCriticalSection (&g_CsConfig);
        Assert (ERROR_SUCCESS != dwRes);
        return dwRes;
    }

    //
    // Now change the real time data that the server is using
    //
    dwRes = RefreshEventLog(&FaxRegLogging);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("RefreshEventLog"),
                     dwRes);
        LeaveCriticalSection (&g_CsConfig);
        Assert (ERROR_SUCCESS != dwRes);
        return dwRes;
    }

    LeaveCriticalSection (&g_CsConfig);

    // Create FAX_EVENT_EX
    DWORD ec = CreateConfigEvent (FAX_CONFIG_TYPE_EVENTLOGS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_EVENTLOGS) (ec: %lc)"),
            ec);
    }    
    return dwRes;
}

VOID
RPC_FAX_PORT_HANDLE_rundown(
    IN HANDLE FaxPortHandle
    )
{
    PHANDLE_ENTRY pPortHandleEntry = (PHANDLE_ENTRY) FaxPortHandle;
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_PORT_HANDLE_rundown"));

    EnterCriticalSection( &g_CsLine );    
    DebugPrintEx(
        DEBUG_WRN,
        TEXT("RPC_FAX_PORT_HANDLE_rundown() running for port handle 0x%08x"),
        FaxPortHandle);
    CloseFaxHandle( pPortHandleEntry );    
    LeaveCriticalSection( &g_CsLine );
}

//*************************************
//* Extended FAX API
//*************************************

//*************************************
//* Extended FAX API
//*************************************

//*********************************************************************************
//* Name:   ValidateCopiedQueueFileName()
//* Author: OdedS
//* Date:   Jan 23, 2002
//*********************************************************************************
//* DESCRIPTION:
//*     Validates that the caller of FAX_SendDocumentEx provided personal cover page or body file name
//*		that match the format of the file name generated by FAX_StartCopyToServer()
//*		Prevents attackers from providing bogus file names
//* PARAMETERS:
//*     [IN]        lpcwstrFileName - Pointer to the file name
//*
//*     [IN]        fCovFile - TRUE if personal cover page, FALSE if body tif file
//* RETURN VALUE:
//*     If the name is valid it returns TRUE.
//*     If the name is not valid it returns FALSE.
//*********************************************************************************
BOOL
ValidateCopiedQueueFileName(
	LPCWSTR	lpcwstrFileName,
	BOOL	fCovFile
	)
{	
	WCHAR wszFileName[21] = {0};	// The copied filename contains 16 hex digits '.' and 'tif' or 'cov' total of 20 chars.	
	WCHAR* pwchr;

	Assert (lpcwstrFileName);	

	//
	// Validate file name is in the right format
	//
	if (wcslen(lpcwstrFileName) > 20 || wcslen(lpcwstrFileName) < 5)
	{
		return FALSE;
	}

	wcsncpy (wszFileName, lpcwstrFileName, ARR_SIZE(wszFileName)-1);
	pwchr = wcsrchr(wszFileName, L'.');
	if (NULL == pwchr)
	{
		return FALSE;
	}
	*pwchr = L'\0';
	pwchr++;

	//
	// compare file name extension
	//
	if (TRUE == fCovFile)
	{
		if (_wcsicmp(pwchr, FAX_COVER_PAGE_EXT_LETTERS))
		{
			//
			//  extension is other then "COV"
			//
			return FALSE;
		}
	}
	else
	{
		if (_wcsicmp(pwchr, FAX_TIF_FILE_EXT))
		{
			//
			//  extension is other then "TIF"
			//
			return FALSE;
		}
	}

	//
	// Make sure the file name contains hex digits only
	//
#define HEX_DIGITS	TEXT("0123456789abcdefABCDEF")
	if (NULL == _wcsspnp (wszFileName, HEX_DIGITS))
	{
		// only hex digits		
		return TRUE;
	}	
	return FALSE;
}


//*********************************************************************************
//* Name:   FAX_SendDocumentEx()
//* Author: Ronen Barenboim
//* Date:   April 19, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Server side implementation of FaxSendDocumentEx()
//* PARAMETERS:
//*     [IN]        handle_t hBinding
//*             The RPC binding handle
//*
//*     [IN]        LPCWSTR lpcwstrBodyFileName
//*             Short name to the fax bofy TIFF file in the SERVER machine queue
//*             directory.
//*
//*     [IN]        LPCFAX_COVERPAGE_INFO_EXW lpcCoverPageInfo
//*             Cover page information. This is never NULL.
//*             if no cover page information is available then
//*             lpcCoverPageInfo->lptstrCoverPageFileName is NULL.
//*             If coverpage information is specified it must point to the coverpage
//*             template file on the server.
//*
//*     [IN]        LPCFAX_PERSONAL_PROFILEW lpcSenderProfile
//*             Pointer to Sender personal
//*
//*     [IN]        DWORD dwNumRecipients
//*             The number of recipients.
//*
//*     [IN]        LPCFAX_PERSONAL_PROFILEW lpcRecipientList
//*             Pointer to Recipient Profiles array
//*
//*     [IN]        LPCFAX_JOB_PARAM_EXW lpcJobParams
//*             Pointer to job parameters.
//*
//*     [OUT]       LPDWORD lpdwJobId
//*             Pointer to a DWORD where the function will return the
//*             recipient job session ID (only one recipient) -
//*             Used for backwords competability with FaxSendDocument.
//*             If this parameter is NULL it is ignored.
//*
//*
//*     [OUT]       PDWORDLONG lpdwlParentJobId
//*             Pointer to a DWORDLONG where the function will return the parent
//*             job id.
//*     [OUT]       PDWORDLONG lpdwlRecipientIds
//*             Pointer to a DWORDLONG array (dwNumRecipients elemetns)
//*             where the function will return the recipient jobs' unique ids.
//*
//* RETURN VALUE:
//*     If the function is successful it returns ERROR_SUCCESS.
//*     If the function is not successful it returns the LastError code
//*     that caused the error.
//*********************************************************************************
error_status_t FAX_SendDocumentEx(
    handle_t hBinding,
    LPCWSTR lpcwstrBodyFileName,
    LPCFAX_COVERPAGE_INFO_EXW lpcCoverPageInfo,
    LPCFAX_PERSONAL_PROFILEW lpcSenderProfile,
    DWORD dwNumRecipients,
    LPCFAX_PERSONAL_PROFILEW lpcRecipientList,
    LPCFAX_JOB_PARAM_EXW lpcJobParams,
    LPDWORD lpdwJobId,
    PDWORDLONG lpdwlParentJobId,
    PDWORDLONG lpdwlRecipientIds
    )
{
    DWORD i;
    LPWSTR lpwstrUserName = NULL;
	LPWSTR lpwstrUserSid = NULL;
    error_status_t ulRet=0;
    PJOB_QUEUE lpParentJob = NULL;
    PJOB_QUEUE lpRecipientJob;

    error_status_t rc;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SendDocumentEx"));
    WCHAR szBodyPath[MAX_PATH] = {0};
    LPTSTR lptstrFixedBodyPath=NULL;    // The full path to the location of the body TIFF.
                                        // NULL if no body specified.
    FAX_COVERPAGE_INFO_EXW newCoverInfo;
    WCHAR szCoverPagePath[MAX_PATH] = {0};
    LPCFAX_COVERPAGE_INFO_EXW lpcFinalCoverInfo;
    DWORD dwQueueState;
    PSID lpUserSid = NULL;
    ACCESS_MASK AccessMask = 0;
    BOOL fAccess;    
    LPTSTR lptstrClientName = NULL;
    int Count;

    if (!dwNumRecipients	||
		!lpcSenderProfile   ||
        !lpcRecipientList   ||
        !lpcJobParams       ||
        !lpdwlParentJobId   ||
        !lpdwlRecipientIds  ||
        !lpcCoverPageInfo)  // unique pointers in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

	//
	// Verify the body filename is in the expected format I64x.tif
	//
	if (lpcwstrBodyFileName)
	{
		if (!ValidateCopiedQueueFileName(lpcwstrBodyFileName, FALSE)) // FALSE - TIF file
		{
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("ValidateCopiedQueueFileName Failed, body file name in the wrong format"));
			return ERROR_INVALID_PARAMETER; // Must not go to Error, where the file is deleted. can lead to a deletion of a wrong file			
		}
	}

	//
	// Verify the personal cover page filename is in the expected format I64x.cov
	//
	if (lpcCoverPageInfo->lptstrCoverPageFileName && !lpcCoverPageInfo->bServerBased)
	{
		if (!ValidateCopiedQueueFileName(lpcCoverPageInfo->lptstrCoverPageFileName, TRUE)) // TRUE - COV file
		{
			DebugPrintEx(
				DEBUG_ERR,
				TEXT("ValidateCopiedQueueFileName Failed, personal cover page in the wrong name format"));
			return ERROR_INVALID_PARAMETER;			
		}
	}

	//
    //Get the user SID
    //
    lpUserSid = GetClientUserSID();
    if (lpUserSid == NULL)
    {
       rc = GetLastError();
       DebugPrintEx(DEBUG_ERR,
                    TEXT("GetClientUserSid Failed, Error : %ld"),
                    rc);
       return rc;
    }

	if (!ConvertSidToStringSid (lpUserSid, &lpwstrUserSid))
    {
		rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ConvertSidToStringSid Failed, error : %ld"),
            rc);
        MemFree(lpUserSid);
		return rc;
    }
	//
	// Only After file name validation, and getting the user string SID,
	// we can safely goto Error, and delete the files that were copied to the queue in FAX_StartCopyToServer()
	// 

	//
	// Check the recipients limit of a single broadcast job
	//
	if (0 != g_dwRecipientsLimit &&           // The Administrator set a limit
		dwNumRecipients > g_dwRecipientsLimit)
	{
		DebugPrintEx(
			DEBUG_ERR,
			TEXT("Recipient limit reached. Recipient count:%ld. Recipient limit:%ld."),
			dwNumRecipients,
			g_dwRecipientsLimit
			);
		if (FAX_API_VERSION_2 > FindClientAPIVersion (hBinding))
        {
            //
            // API versions 0,1 clients don't know about FAX_ERR_RECIPIENTS_LIMIT
            //
            rc = ERROR_ACCESS_DENIED;
			goto Error;
        }
        else
        {
            rc = FAX_ERR_RECIPIENTS_LIMIT;
			goto Error;
        } 
	}

    //
    // Save the original receipt delivery address.
    // If the receipt delivry type is DRT_MSGBOX we change lpcJobParams->lptstrReceiptDeliveryAddress
    // but must restore it to its previous value before the function returns so that RPC allocations
    // keep working.
    //
    LPTSTR lptrstOriginalReceiptDeliveryAddress = lpcJobParams->lptstrReceiptDeliveryAddress;

    if (lpcJobParams->hCall != 0 ||
        0xFFFF1234 == lpcJobParams->dwReserved[0])
    {

        //
        // Handoff is not supported
        //
        DebugPrintEx(DEBUG_ERR,TEXT("We do not support handoff."));
        rc = ERROR_NOT_SUPPORTED;
        goto Error;            
    }

    //
    // Access check
    //
    switch (lpcJobParams->Priority)
    {
        case FAX_PRIORITY_TYPE_LOW:
            AccessMask = FAX_ACCESS_SUBMIT;
            break;

        case FAX_PRIORITY_TYPE_NORMAL:
            AccessMask = FAX_ACCESS_SUBMIT_NORMAL;
            break;

        case FAX_PRIORITY_TYPE_HIGH:
            AccessMask = FAX_ACCESS_SUBMIT_HIGH;
            break;

        default:
            ASSERT_FALSE;
    }

    if (0 == AccessMask)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("Not a valid priority, (priority = %ld"),
                    lpcJobParams->Priority);
        rc = ERROR_INVALID_PARAMETER;
        goto Error;
    }

    rc = FaxSvcAccessCheck (AccessMask, &fAccess, NULL);
    if (ERROR_SUCCESS != rc)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ulRet);
        goto Error;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the needed rights to submit the fax"));
        rc = ERROR_ACCESS_DENIED;
        goto Error;
    }

    //
    // Check if the requrested receipts options are supported by the server
    //
    if ((lpcJobParams->dwReceiptDeliveryType) & ~(DRT_ALL | DRT_MODIFIERS))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("ReceiptDeliveryType invalid (%ld)"),
                    lpcJobParams->dwReceiptDeliveryType);
        rc = ERROR_INVALID_PARAMETER;
        goto Error;
    }
    DWORD dwReceiptDeliveryType = (lpcJobParams->dwReceiptDeliveryType) & ~DRT_MODIFIERS;
    if ((DRT_EMAIL  != dwReceiptDeliveryType) &&
        (DRT_MSGBOX != dwReceiptDeliveryType) &&
        (DRT_NONE   != dwReceiptDeliveryType)
       )
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("ReceiptDeliveryType invalid (%ld)"),
                    lpcJobParams->dwReceiptDeliveryType);
        rc = ERROR_INVALID_PARAMETER;
        goto Error;
    }
    if ((DRT_NONE != dwReceiptDeliveryType) &&
        !(dwReceiptDeliveryType & g_ReceiptsConfig.dwAllowedReceipts))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("ReceiptDeliveryType not supported by the server (%ld)"),
                    lpcJobParams->dwReceiptDeliveryType);
        rc = ERROR_UNSUPPORTED_TYPE;
        goto Error;
    }

    if (!IsFaxShared())
    {
       //
       // Only local connections are allowed on non-shared SKUs
       //
       BOOL  bLocalFlag;

        rc = IsLocalRPCConnectionNP(&bLocalFlag);
        if ( rc != RPC_S_OK )
        {
            DebugPrintEx(DEBUG_ERR,
                    TEXT("IsLocalRPCConnectionNP failed. (ec: %ld)"),
                    rc);
            goto Error;
        }

        if( !bLocalFlag )
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Desktop SKUs do not share fax printers. FAX_SendDocumentEX is available for local clients only"));

            if (FAX_API_VERSION_1 > FindClientAPIVersion (hBinding))
            {
                //
                // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
                //
                rc = ERROR_INVALID_PARAMETER;
            }
            else
            {
                rc = FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
            }
            goto Error;
        }
    }
    
    if (DRT_MSGBOX == dwReceiptDeliveryType)
    {
        //
        // For message boxes, we always use the user name of the client.
        // Otherwise, any client with fax capabilities can ask us to pop a message on
        // any other machine (or even the entire domain) - unacceptable.
        //
        lptstrClientName = GetClientUserName();
        if (!lptstrClientName)
        {
            rc = GetLastError ();
            goto Error;
        }
        LPWSTR lpwstrUserStart = wcsrchr (lptstrClientName, TEXT('\\'));
        if (lpwstrUserStart)
        {
            //
            // User name is indeed composed of domain\user
            // Need to take only the user part.
            //

            //
            // Skip the '/' character
            //
            lpwstrUserStart++;
            LPWSTR lpwstrUserOnly = StringDup(lpwstrUserStart);
            if (!lpwstrUserOnly)
            {
                DebugPrintEx(
                DEBUG_ERR,
                TEXT("StringDup failed"));
                rc = ERROR_NOT_ENOUGH_MEMORY;
                goto Error;
            }
            
            //
            // Replace the allocated "domain\user" string with its "user" portion only.
            //
            lstrcpy (lptstrClientName, lpwstrUserOnly);
            MemFree(lpwstrUserOnly);
        }
        //
        // Replace the receipt delivery address with the client machine name.
        // NOTICE: We replace an RPC allocated buffer (lptstrReceiptDeliveryAddress) with 
        // a stack buffer (wszClientName). This will only work because RPC does a single allocation
        // for the entire parameter block (lpcJobParams) with all of its sub-strings.
        //
        (LPTSTR)lpcJobParams->lptstrReceiptDeliveryAddress = lptstrClientName;
    }
            

    EnterCriticalSection (&g_CsConfig);
    dwQueueState = g_dwQueueState;
    LeaveCriticalSection (&g_CsConfig);
    if (dwQueueState & FAX_OUTBOX_BLOCKED)
    {
        //
        // The outbox is blocked - nobody can submit new faxes
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Attempt to submit a new job while outbox is blocked - access denied"));
        rc = ERROR_WRITE_PROTECT;
        goto Error;
    }

    //
    // Get the user name of the submitting user
    //
    lpwstrUserName = GetClientUserName();
    if (!lpwstrUserName) {
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetClientUserName() failed. (ec: %ld)"),
            rc);
        goto Error;
    }   

    if (lpcwstrBodyFileName)
    {
        HANDLE hLocalFile = INVALID_HANDLE_VALUE;	

        //
        // We have a body file (not just a cover page).
        // create a full path to the body file (The lptstrBodyFileName is just the short file name - the location
        // is allways the job queue).
        Count = _snwprintf (szBodyPath,
                            MAX_PATH -1,
                            L"%s\\%s%s%s",
                            g_wszFaxQueueDir,
							lpwstrUserSid,
							TEXT("$"),
                            lpcwstrBodyFileName);
        if (Count < 0)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));  
			rc = ERROR_BUFFER_OVERFLOW;
			goto Error;
        }

        DebugPrintEx(DEBUG_MSG,TEXT("Body file is: %ws"),szBodyPath);

        lptstrFixedBodyPath=szBodyPath; 
        
        //
        // Check file size is non-zero and make sure it is not a device
        // Try to open file
        //
        hLocalFile = SafeCreateFile (
            szBodyPath,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL);
        if ( INVALID_HANDLE_VALUE == hLocalFile )
        {
            rc = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Opening %s for read failed (ec: %ld)"),
                szBodyPath,
                rc);
            goto Error;
        }

        DWORD dwFileSize = GetFileSize (hLocalFile, NULL);
        if (INVALID_FILE_SIZE == dwFileSize)
        {
            rc = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetFileSize failed (ec: %ld)"),
                rc);
            CloseHandle (hLocalFile);
            goto Error;
        }
        if (!CloseHandle (hLocalFile))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle failed (ec: %ld)"),
                GetLastError());
        }

        if (!dwFileSize)
        {
            //
            // Zero-sized file passed to us
            //
            rc = ERROR_INVALID_DATA;
            goto Error;
        }

        //
        // validate the body tiff file
        //
        rc =  ValidateTiffFile(szBodyPath);
        if (rc != ERROR_SUCCESS)
        {
            DebugPrintEx(DEBUG_ERR,TEXT("ValidateTiffFile of body file %ws failed (ec: %ld)."), szBodyPath,rc);
            goto Error;
        }
    }
    else
    {
        lptstrFixedBodyPath=NULL; // No body
    }


    //
    // NOTE: we do not merge the cover page with body at this point since we do not know yet if
    // the job will be handed of to legacy FSP. Just before handing the job to a legacy FSP we will
    // render the cover page and merge it with the body that the Legacy FSP gets.
    //

    //
    // Fix the cover page path to point to the queue directory
    //
    lpcFinalCoverInfo=lpcCoverPageInfo;
    if (lpcCoverPageInfo->lptstrCoverPageFileName)
	{
        if (!lpcCoverPageInfo->bServerBased)
		{
            Count = _snwprintf (szCoverPagePath,
                                MAX_PATH -1,
                                L"%s\\%s%s%s",
                                g_wszFaxQueueDir,								
								lpwstrUserSid,
								TEXT("$"),
                                lpcCoverPageInfo->lptstrCoverPageFileName);
            if (Count < 0)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("_snwprintf Failed, File name bigger than MAX_PATH"));
                rc = ERROR_BUFFER_OVERFLOW;
				goto Error;
            }

			memcpy((LPVOID)&newCoverInfo,(LPVOID)lpcCoverPageInfo,sizeof(FAX_COVERPAGE_INFO_EXW));
            newCoverInfo.lptstrCoverPageFileName=szCoverPagePath;
            lpcFinalCoverInfo=&newCoverInfo;
            DebugPrintEx(DEBUG_MSG,TEXT("Using personal cover file page at : %ws"),newCoverInfo.lptstrCoverPageFileName);
        }
    }

    //
    // Create a parent job for the broadcast
    //
    EnterCriticalSection(&g_CsQueue);

    lpParentJob=AddParentJob( &g_QueueListHead,
                              lptstrFixedBodyPath,
                              lpcSenderProfile,
                              lpcJobParams,
                              lpcFinalCoverInfo,
                              lpwstrUserName,
                              lpUserSid,
							  &lpcRecipientList[0],
                              TRUE //commit to file
                              );

    if (!lpParentJob)
	{
        rc = GetLastError();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Failed to create parent job (ec: %ld)."),
            rc);
        LeaveCriticalSection(&g_CsQueue);
        goto Error;
    }
    for (i=0;i<dwNumRecipients;i++)
	{
        lpRecipientJob=AddRecipientJob(
                            &g_QueueListHead,
                            lpParentJob,
                            &lpcRecipientList[i],
                            TRUE // commit to file
                            );
        if (!lpRecipientJob)
        {
            rc = GetLastError();

            // Remove the job and its recipients jobs

            PLIST_ENTRY Next;
            PJOB_QUEUE_PTR pJobQueuePtr;

            Next = lpParentJob->RecipientJobs.Flink;
            while ((ULONG_PTR)Next != (ULONG_PTR)&lpParentJob->RecipientJobs)
			{
                pJobQueuePtr = CONTAINING_RECORD( Next, JOB_QUEUE_PTR, ListEntry );
                Assert(pJobQueuePtr->lpJob);
                Next = pJobQueuePtr->ListEntry.Flink;

                pJobQueuePtr->lpJob->RefCount = 0; // This will cause the job to be deleted
				Assert(lpParentJob->RefCount);
				lpParentJob->RefCount--;		   // Update the parent job ref count, so it will be deleted as well.
            }
            RemoveParentJob ( lpParentJob,
                              TRUE, //  bRemoveRecipientJobs
                              FALSE // do not notify
                            );
            LeaveCriticalSection(&g_CsQueue);
            goto Error;
        }
        lpdwlRecipientIds[i]=lpRecipientJob->UniqueId;
    }
    //
    // Report back the parent job id.
    //
    *lpdwlParentJobId=lpParentJob->UniqueId;

    //
    // Create event, and Report back the first recipient job session id if needed.
    //
    PLIST_ENTRY Next;
    PJOB_QUEUE_PTR pJobQueuePtr;
    Next = lpParentJob->RecipientJobs.Flink;
    for (i = 0; i < dwNumRecipients; i++)
    {
        pJobQueuePtr = CONTAINING_RECORD( Next, JOB_QUEUE_PTR, ListEntry );
        PJOB_QUEUE pJobQueueRecipient = pJobQueuePtr->lpJob;

        if (i == 0 && NULL != lpdwJobId)
        {
            // Report back the first recipient job session id if needed.
            Assert (1 == dwNumRecipients);
            *lpdwJobId = pJobQueueRecipient->JobId;
        }

        rc = CreateQueueEvent ( FAX_JOB_EVENT_TYPE_ADDED,
                                pJobQueueRecipient
                               );
        if (ERROR_SUCCESS != rc)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateQueueEvent(FAX_JOB_EVENT_TYPE_ADDED) failed for job id %ld (ec: %lc)"),
                pJobQueueRecipient->UniqueId,
                rc);
        }

        if (!CreateFaxEvent(0, FEI_JOB_QUEUED, pJobQueueRecipient->JobId ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Failed to generate FEI_JOB_QUEUED for JobId: %ld"),
                pJobQueueRecipient->JobId);
        }


        Next = pJobQueuePtr->ListEntry.Flink;
        // Check the consistency of the linked list.
        Assert ((Next != lpParentJob->RecipientJobs.Flink) || (i == dwNumRecipients));
    }


    //
    // Notify legacy clients on parent job addition.
    //
    if (dwNumRecipients > 1)
    {
        //
        // Legacy client API generated a parent FEI_JOB_QUEUED notification only for broadcast
        // jobs
        if (!CreateFaxEvent(0,FEI_JOB_QUEUED,lpParentJob->JobId)) {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CreateFaxEvent(FEI_JOB_QUEUED) failed for job id %ld (ec: %lc)"),
                lpParentJob->JobId,
                GetLastError());
        }
    }
   
    PrintJobQueue(_T(""),&g_QueueListHead);
    LeaveCriticalSection(&g_CsQueue);

    if (!StartJobQueueTimer())
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StartJobQueueTimer() failed. (ec: %ld)"),
            GetLastError());
    }

    rc=ERROR_SUCCESS;

    goto Exit;
Error:
    //
    // If we failed before AddParentJob() was called and the cover page is personal then
    // we need to delete the cover page template file here. This is because RemoveParentJob() will
    // not be called and will not have a chance to remove it as is the case when the parent job
    // is added to the queue.
	Assert (lpwstrUserSid);

	if (lpcCoverPageInfo &&
        !lpParentJob &&
        !lpcCoverPageInfo->bServerBased &&
        lpcCoverPageInfo->lptstrCoverPageFileName
        )
    {
        DebugPrintEx(
            DEBUG_MSG,
            TEXT("Deleting cover page template %s"),
            lpcCoverPageInfo->lptstrCoverPageFileName);

        if (0 == wcslen(szCoverPagePath))
        {
            Count = _snwprintf (szCoverPagePath,
                                MAX_PATH -1,
                                L"%s\\%s%s%s",
                                g_wszFaxQueueDir,								
								lpwstrUserSid,
								TEXT("$"),
                                lpcCoverPageInfo->lptstrCoverPageFileName);
            if (Count < 0)
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("_snwprintf Failed, File name bigger than MAX_PATH"));
            }
        }

        if (!DeleteFile(szCoverPagePath))
        {
            DebugPrintEx(DEBUG_ERR,
                _T("Failed to delete cover page template %s (ec: %ld)"),
                lpcCoverPageInfo->lptstrCoverPageFileName,
                GetLastError());
        }
    }

    //
    // The same regarding the body Tiff file.
    //
    if (lpcwstrBodyFileName && !lpParentJob)
    {
        if (!lptstrFixedBodyPath)
        {
            //
            //  We haven't yet created full body file path
            //
            Count = _snwprintf (szBodyPath,
                                MAX_PATH -1,
                                L"%s\\%s%s%s",
                                g_wszFaxQueueDir,								
								lpwstrUserSid,
								TEXT("$"),
                                lpcwstrBodyFileName);
            if (Count < 0)
            {
                DebugPrintEx(DEBUG_ERR,
                    _T("_snwprintf Failed, File name bigger than MAX_PATH"));
            }

            DebugPrintEx(DEBUG_MSG,TEXT("Body file is: %ws"),szBodyPath);
            lptstrFixedBodyPath = szBodyPath;
        }

        DebugPrintEx(DEBUG_MSG,
            _T("Deleting body tiff file %s"),
            lptstrFixedBodyPath);

        if (!DeleteFile(lptstrFixedBodyPath))
        {
            DebugPrintEx(DEBUG_ERR,
                TEXT("Failed to delete body tiff file %s (ec: %ld)"),
                lptstrFixedBodyPath,
                GetLastError());
        }
    }

Exit:

    if (lptrstOriginalReceiptDeliveryAddress != lpcJobParams->lptstrReceiptDeliveryAddress)
    {
        //
        // Restore the original receipt delivery address.
        // If the receipt delivry type is DRT_MSGBOX we changed lpcJobParams->lptstrReceiptDeliveryAddress
        // but must restore it to its previous value before the function returns so that RPC allocations
        // keep working.
        //
        (LPTSTR)lpcJobParams->lptstrReceiptDeliveryAddress = lptrstOriginalReceiptDeliveryAddress;
    }
    
    MemFree(lpwstrUserName);
    MemFree(lpUserSid);
    MemFree(lptstrClientName);
	if (NULL != lpwstrUserSid)
	{
		LocalFree(lpwstrUserSid);
	}
    return rc;
}   // FAX_SendDocumentEx


#ifdef DBG

void DumpJobParamsEx(LPCFAX_JOB_PARAM_EX lpcParams)
{
    TCHAR szSchedule[1024];

    SystemTimeToStr(&lpcParams->tmSchedule, szSchedule, ARR_SIZE(szSchedule));
    DebugPrint((TEXT("\tdwSizeOfStruct: %ld"),lpcParams->dwSizeOfStruct));
    DebugPrint((TEXT("\tdwScheduleAction: %ld"),lpcParams->dwScheduleAction));
    DebugPrint((TEXT("\ttmSchedule: %s "),szSchedule));
    DebugPrint((TEXT("\tdwReceiptDeliveryType: %ld "),lpcParams->dwReceiptDeliveryType));
    DebugPrint((TEXT("\tlptstrReceiptDeliveryAddress: %s "),lpcParams->lptstrReceiptDeliveryAddress));
    DebugPrint((TEXT("\tPriority %ld "),lpcParams->Priority));
    DebugPrint((TEXT("\thCall: 0x%08X"),lpcParams->hCall));
    DebugPrint((TEXT("\tlptstrDocumentName: %s"),lpcParams->lptstrDocumentName));
    DebugPrint((TEXT("\tdwPageCount: %ld"),lpcParams->dwPageCount));
    DebugPrint((TEXT("\tdwReserved[0]: 0x%08X"),lpcParams->dwReserved[0]));
    DebugPrint((TEXT("\tdwReserved[1]: 0x%08X"),lpcParams->dwReserved[1]));
    DebugPrint((TEXT("\tdwReserved[2]: 0x%08X"),lpcParams->dwReserved[2]));
    DebugPrint((TEXT("\tdwReserved[3]: 0x%08X"),lpcParams->dwReserved[3]));
}

void DumpCoverPageEx(LPCFAX_COVERPAGE_INFO_EX lpcCover)
{
    DebugPrint((TEXT("\tdwSizeOfStruct: %ld"),lpcCover->dwSizeOfStruct));
    DebugPrint((TEXT("\tdwCoverPageFormat: %ld"),lpcCover->dwCoverPageFormat));
    DebugPrint((TEXT("\tlptstrCoverPageFileName: %s "),lpcCover->lptstrCoverPageFileName));
    DebugPrint((TEXT("\tbServerBased: %s "), lpcCover->bServerBased ? TEXT("TRUE") : TEXT("FALSE")));
    DebugPrint((TEXT("\tlptstrNote: %s "),lpcCover->lptstrNote));
    DebugPrint((TEXT("\tlptstrSubject: %s"),lpcCover->lptstrSubject));
}

#endif


//*********************************************************************************
//* Name:   FAX_GetPersonalProfileInfo()
//* Author: Oded Sacher
//* Date:   May 18, 1999
//*********************************************************************************
//* DESCRIPTION:
//*     Server side implementation of FaxGetSenderInfo() and FaxGetRecipientInfo
//* PARAMETERS:
//*     [IN]        handle_t hFaxHandle
//*             The RPC binding handle
//*
//*     [IN]        DWORDLONF dwlMessageId
//*             The message Id whose sender FAX_PERSONAL_PROFILE
//*             structure is retrieved.
//*
//*     [IN]        DWORD dwFolder
//*             The folder in which to search the message by dwlMessageId
//*
//*     [IN]        PERSONAL_PROF_TYPE  ProfType
//*             Can be Sender or recipient info.
//*
//*     [OUT]       LPDWORD* Buffer
//*             pointer to the adress of a buffer to recieve the sender
//*             FAX_RECIPIENT_JOB_INFO structure.
//*
//*     [OUT]       LPDWORD BufferSize
//*             Pointer to a DWORD variable to recieve the buffer size.
//*
//* RETURN VALUE:
//*    ERROR_SUCCESS for success, otherwise a WIN32 error code.
//*
//*********************************************************************************
error_status_t
FAX_GetPersonalProfileInfo
(
    IN  handle_t hFaxHandle,
    IN  DWORDLONG dwlMessageId,
    IN  FAX_ENUM_MESSAGE_FOLDER   dwFolder,
    IN  FAX_ENUM_PERSONAL_PROF_TYPES  ProfType,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
)
{
    PFAX_PERSONAL_PROFILEW lpPersonalProf;
    FAX_PERSONAL_PROFILEW   PersonalProf;
    PJOB_QUEUE pJobQueue;
    ULONG_PTR Size = 0;
    ULONG_PTR Offset;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetPersonalProfileInfo"));
    error_status_t ulRet = ERROR_SUCCESS;
    BOOL bAllMessages = FALSE;
    LPWSTR lpwstrFileName = NULL;
    BOOL bFreeSenderInfo = FALSE;
    PSID pUserSid = NULL;
    BOOL fAccess;
    DWORD dwRights;

    Assert (BufferSize);    // ref pointer in idl
    if (!Buffer)            // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if (dwFolder != FAX_MESSAGE_FOLDER_QUEUE &&
        dwFolder != FAX_MESSAGE_FOLDER_SENTITEMS)
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    ulRet = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != ulRet)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ulRet);
        return GetServerErrorCode(ulRet);
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_MESSAGE_FOLDER_QUEUE == dwFolder)
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_JOBS    != (dwRights & FAX_ACCESS_QUERY_JOBS))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to get personal profile of queued jobs"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
        {
            bAllMessages = TRUE;
        }
    }
    else
    {
        Assert (FAX_MESSAGE_FOLDER_SENTITEMS  == dwFolder);

        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to get personal profile of archived (sent items) messages"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            bAllMessages = TRUE;
        }
    }

    if (FALSE == bAllMessages)
    {
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            ulRet = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), ulRet);
            return GetServerErrorCode(ulRet);
        }
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Before Enter g_CsJob & Queue"));
    EnterCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Enter g_CsJob & Queue"));

    if (FAX_MESSAGE_FOLDER_QUEUE  == dwFolder)
    {
        pJobQueue = FindJobQueueEntryByUniqueId (dwlMessageId);
        if (pJobQueue == NULL || pJobQueue->JobType != JT_SEND)
        {
            //
            // dwlMessageId is not a valid queued recipient job Id.
            //
            DebugPrintEx(DEBUG_ERR,TEXT("Invalid Parameter - not a recipient job Id"));
            ulRet = FAX_ERR_MESSAGE_NOT_FOUND;
            goto Exit;
        }
        Assert (pJobQueue->lpParentJob);
        if (pJobQueue->lpParentJob->JobStatus == JS_DELETING)
        {
            //
            // Job is being deleted.
            //
            DebugPrintEx(DEBUG_ERR,
                         TEXT("Invalid Parameter - job Id (%I64ld) is being deleted"),
                         dwlMessageId);
            ulRet = FAX_ERR_MESSAGE_NOT_FOUND;
            goto Exit;
        }

        if (FALSE == bAllMessages)
        {
            if (!UserOwnsJob (pJobQueue, pUserSid))
            {
                DebugPrintEx(DEBUG_WRN,TEXT("UserOwnsJob failed ,Access denied"));
                ulRet = ERROR_ACCESS_DENIED;
                goto Exit;
            }
        }

        if (SENDER_PERSONAL_PROF == ProfType)
        {
            lpPersonalProf = &(pJobQueue->lpParentJob->SenderProfile);
        }
        else
        {
           Assert (RECIPIENT_PERSONAL_PROF == ProfType);
           lpPersonalProf = &(pJobQueue->RecipientProfile);
        }
    }
    else
    {   // Sent items Folder
        if (TRUE == bAllMessages)
        {
            // Administrator
            lpwstrFileName = GetSentMessageFileName (dwlMessageId, NULL);
        }
        else
        {
            // User
            lpwstrFileName = GetSentMessageFileName (dwlMessageId, pUserSid);
        }

        if (NULL == lpwstrFileName)
        {
            //
            // dwlMessageId is not a valid archived message Id.
            //
            ulRet = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                         TEXT("GetMessageFileByUniqueId* failed, Error %ld"), ulRet);
            goto Exit;
        }

        if (!GetPersonalProfNTFSStorageProperties (lpwstrFileName,
                                                   ProfType,
                                                   &PersonalProf))
        {
            BOOL success;
            // failed to retrieve information from NTFS, try from TIFF tags

            if(SENDER_PERSONAL_PROF == ProfType)
                success = GetFaxSenderMsTags(lpwstrFileName, &PersonalProf);
            else
                success = GetFaxRecipientMsTags(lpwstrFileName, &PersonalProf);

            if(!success) {

                ulRet = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                         TEXT("failed to get PersonalProf from TIFF, error %ld"),
                         ulRet);
                goto Exit;
            }
        }

        lpPersonalProf = &PersonalProf;
        bFreeSenderInfo = TRUE;
    }

    //
    //calculating buffer size.
    //
    PersonalProfileSerialize (lpPersonalProf, NULL, NULL, &Size, 0); // Calc variable size.
    Size += sizeof (FAX_PERSONAL_PROFILEW);

    //
    // Allocate buffer memory.
    //
    *BufferSize = Size;
    *Buffer = (LPBYTE) MemAlloc( Size );
    if (*Buffer == NULL)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("ERROR_NOT_ENOUGH_MEMORY (Server)"));
        ulRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    Offset = sizeof (FAX_PERSONAL_PROFILEW);
    if( FALSE == PersonalProfileSerialize (	lpPersonalProf,
											(PFAX_PERSONAL_PROFILEW)*Buffer,
											*Buffer,
											&Offset,
											Size))
	{
		Assert(FALSE);
		DebugPrintEx(DEBUG_ERR,
			         TEXT("PersonalProfileSerialize failed, insufficient buffer size"));
	}

    Assert (ERROR_SUCCESS == ulRet);
Exit:

    LeaveCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Release g_CsJob & g_CsQueue"));

    if (NULL != lpwstrFileName)
    {
        MemFree (lpwstrFileName);
    }

    if (NULL != pUserSid)
    {
        MemFree (pUserSid);
    }

    if (TRUE == bFreeSenderInfo)
    {
        FreePersonalProfile (&PersonalProf, FALSE);
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(ulRet);
}


error_status_t
FAX_CheckServerProtSeq(
    IN handle_t hFaxServer,
    IN OUT LPDWORD lpdwProtSeq
    )
{
	//
	// This function is obsolete. The Fax server sends notifications with ncacn_ip_tcp. 
	//
    DEBUG_FUNCTION_NAME(TEXT("FAX_CheckServerProtSeq"));    
    DWORD dwRights;
    BOOL fAccess;
    DWORD Rval = ERROR_SUCCESS;   

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }    

	//
	// This function is obsolete. The Fax server sends notifications with ncacn_ip_tcp. 
	//
    return ERROR_NOT_SUPPORTED;
}


//************************************
//* Getting / Settings the queue state
//************************************

error_status_t
FAX_GetQueueStates (
    IN  handle_t    hFaxHandle,
    OUT LPDWORD     pdwQueueStates
)
/*++

Routine name : FAX_GetQueueStates

Routine description:

    Get the state of the queue

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pdwQueueStates      [out] - State bits (see FAX_QUEUE_STATE)

Return Value:

    Standard RPC error codes

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    BOOL fAccess;
    DWORD dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetQueueStates"));


    if (NULL == pdwQueueStates)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_GetQueueStates() received an invalid pointer"));
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig);
    *pdwQueueStates = g_dwQueueState;
    LeaveCriticalSection (&g_CsConfig);
    return dwRes;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetQueueStates

static BOOL
IsLegalQueueSetting(
    DWORD    dwQueueStates
    )
    /*++

Routine name : IsLegalQueueSetting

Routine description:

    Checks to see if requested queue setting is valid according to the
    validity of fax folders (Queue, inbox and sentItems).

    This function must be called within g_CsQueue  & g_CsConfig critical sections

Author:

    Caliv Nir, (t-nicali), Apr 2002

Arguments:
    
    dwQueueStates       [in ] - State bits (see FAX_ENUM_QUEUE_STATE)

Return Value:

    TRUE - if the setting is valid, FALSE otherwise

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("IsLegalQueueSetting"));

    if ( (dwQueueStates & FAX_INCOMING_BLOCKED)  &&
         (dwQueueStates & FAX_OUTBOX_BLOCKED)    &&
         (dwQueueStates & FAX_OUTBOX_PAUSED)          )
    {
        //
        //  User wants to disable all fax transmission
        //
        return TRUE;
    }

    //
    // first check to see if queue folder is valid
    //
    dwRes = IsValidFaxFolder(g_wszFaxQueueDir);
    if(ERROR_SUCCESS != dwRes)
    {
        //
        //  Queue folder is invalid - User can't resume queue, unblock incoming or outgoing faxs
        //
        DebugPrintEx(DEBUG_ERR,
                        TEXT("IsValidFaxFolder failed for folder : %s (ec=%lu)."),
                        g_wszFaxQueueDir,
                        dwRes);
		SetLastError(dwRes);        
        return FALSE;
    }

    //
    //  if inbox folder is in use
    //
    if (g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].bUseArchive)
    {
        //
        // Check to see if the user requested to unblock it
        //
        if (!(dwQueueStates & FAX_INCOMING_BLOCKED))
        {
            //
            //  Is it valid folder ?
            //
            dwRes = IsValidArchiveFolder(g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder, FAX_MESSAGE_FOLDER_INBOX);
            if(ERROR_SUCCESS != dwRes)
            {
                //
                //  Inbox folder is invalid - User can't resume queue, unblock incoming or outgoing faxs
                //
                DebugPrintEx(DEBUG_ERR,
                                TEXT("IsValidArchiveFolder failed for folder : %s (ec=%lu)."),
                                g_ArchivesConfig[FAX_MESSAGE_FOLDER_INBOX].lpcstrFolder,
                                dwRes);
				SetLastError(dwRes);                
                return FALSE;
            }
        }
    }

    //
    //  if sentItems folder is in use
    //
    if (g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].bUseArchive)
    {
        //
        // Check to see if the user requested to unblock it
        //
        if (!(dwQueueStates & FAX_OUTBOX_BLOCKED))
        {
            //
            //  Is it valid folder ?
            //
            dwRes = IsValidArchiveFolder(g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder, FAX_MESSAGE_FOLDER_SENTITEMS);
            if(ERROR_SUCCESS != dwRes)
            {
                //
                //  Sent items folder is invalid - User can't resume queue, unblock incoming or outgoing faxs
                //
                DebugPrintEx(DEBUG_ERR,
                                TEXT("IsValidFaxFolder failed for folder : %s (ec=%lu)."),
                                g_ArchivesConfig[FAX_MESSAGE_FOLDER_SENTITEMS].lpcstrFolder,
                                dwRes);
				SetLastError(dwRes);                
                return FALSE;
            }
        }
    }
    return TRUE;
} // IsLegalQueueSetting


error_status_t
FAX_SetQueue (
    IN handle_t       hFaxHandle,
    IN const DWORD    dwQueueStates
)
/*++

Routine name : FAX_SetQueue

Routine description:

    Set the state of the queue

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    dwQueueStates       [in ] - State bits (see FAX_ENUM_QUEUE_STATE)

Return Value:

    Standard RPC error codes

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetQueue"));
    DWORD rVal;
    BOOL  fAccess;

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return GetServerErrorCode(rVal);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (dwQueueStates & ~(FAX_INCOMING_BLOCKED | FAX_OUTBOX_BLOCKED | FAX_OUTBOX_PAUSED))
    {
        //
        // Some invalid queue state specified
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_SetQueue() received a bad value. dwQueueStates = %ld"),
            dwQueueStates);
        return ERROR_INVALID_PARAMETER;
    }
    //
    // Try to save new value
    //
    EnterCriticalSection (&g_CsQueue);
    EnterCriticalSection (&g_CsConfig);

    if ( (dwQueueStates  & (FAX_INCOMING_BLOCKED | FAX_OUTBOX_BLOCKED | FAX_OUTBOX_PAUSED)) == 
         (g_dwQueueState & (FAX_INCOMING_BLOCKED | FAX_OUTBOX_BLOCKED | FAX_OUTBOX_PAUSED))      )
    {
        //
        // no change to queue state is needed.
        //
        dwRes = ERROR_SUCCESS;
        goto exit;
    }

    if (!IsLegalQueueSetting(dwQueueStates))
    {
        if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
        {
            dwRes = ERROR_ACCESS_DENIED;
        }
        else
        {
			dwRes = GetLastError();
			dwRes = (FAX_ERR_DIRECTORY_IN_USE == dwRes) ?  FAX_ERR_DIRECTORY_IN_USE : FAX_ERR_FILE_ACCESS_DENIED;
        }
        goto exit;
    }

    dwRes = SaveQueueState (dwQueueStates);
    if (ERROR_SUCCESS != dwRes)
    {
        //
        // Failed saving new value, return error code
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FAX_SetQueue() failed to save the new state. dwRes = %ld"),
            dwRes);
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }
    //
    // Apply new value
    //
    if (dwQueueStates & FAX_OUTBOX_PAUSED)
    {
        //
        // User wished to pause the queue - do it
        //
        if (!PauseServerQueue())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("PauseServerQueue failed."));
            dwRes = RPC_E_SYS_CALL_FAILED;
            
            //
            // Restore old values
            //
            rVal = SaveQueueState (g_dwQueueState);
            if (ERROR_SUCCESS != rVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SaveQueueState failed to save the new state. rVal = %ld"),
                    rVal);
            }

            goto exit;
        }

    }
    else
    {
        //
        // User wished to resume the queue - do it
        //
        if (!ResumeServerQueue())
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("ResumeServerQueue failed."));
            dwRes = RPC_E_SYS_CALL_FAILED;

            //
            // Restore old values
            //
            rVal = SaveQueueState (g_dwQueueState);
            if (ERROR_SUCCESS != rVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("SaveQueueState failed to save the new state. rVal = %ld"),
                    rVal);
            }

            goto exit;
        }
    }
    g_dwQueueState = dwQueueStates;

    rVal = CreateQueueStateEvent (dwQueueStates);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateQueueStateEvent() failed (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:

    LeaveCriticalSection (&g_CsConfig);
    LeaveCriticalSection (&g_CsQueue);
    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetQueue

//****************************************************
//* Getting / Settings the receipts configuration
//****************************************************

error_status_t
FAX_GetReceiptsConfiguration (
    IN  handle_t    hFaxHandle,
    OUT LPBYTE     *pBuffer,
    OUT LPDWORD     pdwBufferSize
)
/*++

Routine name : FAX_GetReceiptsConfiguration

Routine description:

    Gets the current receipts configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pBuffer             [out] - Pointer to buffer to hold configuration information
    pdwBufferSize       [out] - Pointer to buffer size

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetReceiptsConfiguration"));
    DWORD dwRes = ERROR_SUCCESS;
    BOOL fAccess;

    Assert (pdwBufferSize);     // ref pointer in idl
    if (!pBuffer)               // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }


    //
    // count up the number of bytes needed
    //

    *pdwBufferSize = sizeof(FAX_RECEIPTS_CONFIG);
    ULONG_PTR Offset = sizeof(FAX_RECEIPTS_CONFIG);
    PFAX_RECEIPTS_CONFIG pReceiptsConfig;

    EnterCriticalSection (&g_CsConfig);

    if (NULL != g_ReceiptsConfig.lptstrSMTPServer)
    {
        *pdwBufferSize += StringSize( g_ReceiptsConfig.lptstrSMTPServer );
    }

    if (NULL != g_ReceiptsConfig.lptstrSMTPFrom)
    {
        *pdwBufferSize += StringSize( g_ReceiptsConfig.lptstrSMTPFrom );
    }

    if (NULL != g_ReceiptsConfig.lptstrSMTPUserName)
    {
        *pdwBufferSize += StringSize( g_ReceiptsConfig.lptstrSMTPUserName );
    }

    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    pReceiptsConfig = (PFAX_RECEIPTS_CONFIG)*pBuffer;

    pReceiptsConfig->dwSizeOfStruct = sizeof (FAX_RECEIPTS_CONFIG);
    pReceiptsConfig->bIsToUseForMSRouteThroughEmailMethod = g_ReceiptsConfig.bIsToUseForMSRouteThroughEmailMethod;

    pReceiptsConfig->dwSMTPPort = g_ReceiptsConfig.dwSMTPPort;
    pReceiptsConfig->dwAllowedReceipts = g_ReceiptsConfig.dwAllowedReceipts;
    pReceiptsConfig->SMTPAuthOption = g_ReceiptsConfig.SMTPAuthOption;
    pReceiptsConfig->lptstrReserved = NULL;

    StoreString(
        g_ReceiptsConfig.lptstrSMTPServer,
        (PULONG_PTR)&pReceiptsConfig->lptstrSMTPServer,
        *pBuffer,
        &Offset,
		*pdwBufferSize
        );

    StoreString(
        g_ReceiptsConfig.lptstrSMTPFrom,
        (PULONG_PTR)&pReceiptsConfig->lptstrSMTPFrom,
        *pBuffer,
        &Offset,
		*pdwBufferSize
        );

    StoreString(
        g_ReceiptsConfig.lptstrSMTPUserName,
        (PULONG_PTR)&pReceiptsConfig->lptstrSMTPUserName,
        *pBuffer,
        &Offset,
		*pdwBufferSize
        );

    StoreString(
        NULL,   // We always return a NULL password string. Never transmit a password over the wire if
                // you don't have to.
        (PULONG_PTR)&pReceiptsConfig->lptstrSMTPPassword,
        *pBuffer,
        &Offset,
		*pdwBufferSize
        );

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);
    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetReceiptsConfiguration

error_status_t
FAX_SetReceiptsConfiguration (
    IN handle_t                    hFaxHandle,
    IN const PFAX_RECEIPTS_CONFIG  pReciptsCfg
)
/*++

Routine name : FAX_SetReceiptsConfiguration

Routine description:

    Sets the current receipts configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pReciptsCfg         [in ] - Pointer to new data to set

Return Value:

    Standard RPC error codes

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DWORD dwRes;
    BOOL fAccess;
    BOOL fIsAllowedEmailReceipts = FALSE;
    BOOL fCloseToken = FALSE;
    HKEY hReceiptsKey = NULL;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetReceiptsConfiguration"));

    Assert (pReciptsCfg);

    if (sizeof (FAX_RECEIPTS_CONFIG) != pReciptsCfg->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
       return ERROR_INVALID_PARAMETER;
    }
    if ((pReciptsCfg->dwAllowedReceipts) & ~DRT_ALL)
    {
        //
        // Receipts type is invalid
        //
        return ERROR_INVALID_PARAMETER;
    }

    if (pReciptsCfg->dwAllowedReceipts & DRT_EMAIL ||
        pReciptsCfg->bIsToUseForMSRouteThroughEmailMethod)
    {
        if (TRUE == IsDesktopSKU())
        {
            //
            // We do not support mail (routing or receipts) on desktop SKUs.
            //
            if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
            {
                //
                // API version 0 clients don't know about FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU
                //
                return ERROR_INVALID_PARAMETER;
            }
            else
            {
                return FAX_ERR_NOT_SUPPORTED_ON_THIS_SKU;
            }
        }
        if (pReciptsCfg->dwAllowedReceipts & DRT_EMAIL)
        {
            fIsAllowedEmailReceipts = TRUE;
        }
    }

    if (!(pReciptsCfg->dwAllowedReceipts & DRT_EMAIL) &&
        !pReciptsCfg->bIsToUseForMSRouteThroughEmailMethod &&
        NULL != pReciptsCfg->lptstrSMTPPassword)
    {
        //
        // Password is not NULL, but no mail receipt/routing was set
        //
        return ERROR_INVALID_PARAMETER;
    }

    if (fIsAllowedEmailReceipts ||                          // DRT_EMAIL is allowed or
        pReciptsCfg->bIsToUseForMSRouteThroughEmailMethod   // Route to email will use SMTP settings
       )
    {
        //
        // Validate authentication option range
        //
        if ((pReciptsCfg->SMTPAuthOption < FAX_SMTP_AUTH_ANONYMOUS) ||
            (pReciptsCfg->SMTPAuthOption > FAX_SMTP_AUTH_NTLM))
        {
            //
            // SMTP auth type type is invalid
            //
            return ERROR_INVALID_PARAMETER;
        }
    }
    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return GetServerErrorCode(rVal);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig);

    //
    // Check if NTLM authentication was turned off
    //
    if (pReciptsCfg->dwSMTPPort != FAX_SMTP_AUTH_NTLM ||
        !( fIsAllowedEmailReceipts || pReciptsCfg->bIsToUseForMSRouteThroughEmailMethod))
    {
        //
        // NTLM authentication is off
        //
        fCloseToken = TRUE;
    }

    //
    //  Read stored password before overwriting it
    //
    hReceiptsKey = OpenRegistryKey(
        HKEY_LOCAL_MACHINE,
        REGKEY_SOFTWARE TEXT("\\") REGKEY_RECEIPTS_CONFIG,
        FALSE,
        KEY_READ | KEY_WRITE);
    if (NULL == hReceiptsKey)
    {
        rVal = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("OpenRegistryKey failed. (ec=%lu)"),
            rVal);
        goto exit;
    }
    g_ReceiptsConfig.lptstrSMTPPassword = GetRegistrySecureString(hReceiptsKey, REGVAL_RECEIPTS_PASSWORD, EMPTY_STRING, TRUE, NULL);

    //
    // Change the values in the registry
    //
    rVal = StoreReceiptsSettings (pReciptsCfg);
    if (ERROR_SUCCESS != rVal)
    {
        //
        // Failed to set stuff
        //
        rVal = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }
    //
    // change the values that the server is currently using
    //
    g_ReceiptsConfig.dwAllowedReceipts = pReciptsCfg->dwAllowedReceipts;
    g_ReceiptsConfig.bIsToUseForMSRouteThroughEmailMethod = pReciptsCfg->bIsToUseForMSRouteThroughEmailMethod;

    if (
         fIsAllowedEmailReceipts
        ||
         pReciptsCfg->bIsToUseForMSRouteThroughEmailMethod
        )
    {
        g_ReceiptsConfig.dwSMTPPort = pReciptsCfg->dwSMTPPort;
        g_ReceiptsConfig.SMTPAuthOption = pReciptsCfg->SMTPAuthOption;
        if (!ReplaceStringWithCopy (&g_ReceiptsConfig.lptstrSMTPServer, pReciptsCfg->lptstrSMTPServer))
        {
            rVal = GetLastError ();
            goto exit;
        }
        if (!ReplaceStringWithCopy (&g_ReceiptsConfig.lptstrSMTPFrom, pReciptsCfg->lptstrSMTPFrom))
        {
            rVal = GetLastError ();
            goto exit;
        }

        if (g_ReceiptsConfig.lptstrSMTPUserName &&
            pReciptsCfg->lptstrSMTPUserName     &&
            g_ReceiptsConfig.lptstrSMTPPassword &&
            pReciptsCfg->lptstrSMTPPassword)
        {
            if (0 != wcscmp (g_ReceiptsConfig.lptstrSMTPUserName, pReciptsCfg->lptstrSMTPUserName) ||
                0 != wcscmp (g_ReceiptsConfig.lptstrSMTPPassword, pReciptsCfg->lptstrSMTPPassword))
            {
                //
                // Logged on user token was changed
                //
                fCloseToken = TRUE;
            }
        }
        else
        {
            //
            // We can not decide if user information was changed - close old token
            //
            fCloseToken = TRUE;
        }

        if (!ReplaceStringWithCopy (&g_ReceiptsConfig.lptstrSMTPUserName, pReciptsCfg->lptstrSMTPUserName))
        {
            rVal = GetLastError ();
            goto exit;
        }
    }

    if (NULL != g_ReceiptsConfig.hLoggedOnUser &&
        TRUE == fCloseToken)
    {
        //
        // Logged on user token is not needed or changed. Close the old token
        //
        if (!CloseHandle(g_ReceiptsConfig.hLoggedOnUser))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("CloseHandle failed. (ec: %ld)"),
                GetLastError());
        }
        g_ReceiptsConfig.hLoggedOnUser = NULL;
    }

    dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_RECEIPTS);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_RECEIPTS) (ec: %lc)"),
            dwRes);
    }

    Assert (ERROR_SUCCESS == rVal);

exit:
    if (NULL != hReceiptsKey)
    {
        DWORD ec = RegCloseKey(hReceiptsKey);
        if (ERROR_SUCCESS != ec)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("RegCloseKey failed (ec: %lu)"),
                ec);
        }
    }

    if (g_ReceiptsConfig.lptstrSMTPPassword)
    {
        SecureZeroMemory(g_ReceiptsConfig.lptstrSMTPPassword,_tcslen(g_ReceiptsConfig.lptstrSMTPPassword)*sizeof(TCHAR));
        MemFree(g_ReceiptsConfig.lptstrSMTPPassword);
        g_ReceiptsConfig.lptstrSMTPPassword = NULL;
    }

    LeaveCriticalSection (&g_CsConfig);
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetReceiptsConfiguration


error_status_t
FAX_GetReceiptsOptions (
    IN  handle_t    hFaxHandle,
    OUT LPDWORD     lpdwReceiptsOptions
)
/*++

Routine name : FAX_GetReceiptsOptions

Routine description:

    Gets the currently supported options.

    Requires no access rights.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    lpdwReceiptsOptions [out] - Pointer to buffer to hold supported options.

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetReceiptsOptions"));
    DWORD Rval = ERROR_SUCCESS;
    DWORD dwRights;
    BOOL fAccess;

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (lpdwReceiptsOptions);

    *lpdwReceiptsOptions = g_ReceiptsConfig.dwAllowedReceipts;
    return ERROR_SUCCESS;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetReceiptsOptions


//********************************************
//*             Server version
//********************************************

error_status_t
FAX_GetVersion (
    IN  handle_t      hFaxHandle,
    OUT PFAX_VERSION  pVersion
)
/*++

Routine name : FAX_GetVersion

Routine description:

    Retrieves the version of the fax server

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in    ] - Unused
    pVersion            [in/out] - Returned version structure

Return Value:

    Standard RPC error codes

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    WCHAR wszSvcFileName[MAX_PATH * 2]={0};
    BOOL fAccess;
    DWORD dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetVersion"));

    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return rVal;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }

    if (!GetModuleFileName( NULL,
                            wszSvcFileName,
                            ARR_SIZE(wszSvcFileName)-1)
       )
    {
        rVal = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("GetModuleFileName() failed . rVal = %ld"),
            rVal);
        return GetServerErrorCode(rVal);
    }
    rVal = GetFileVersion (wszSvcFileName, pVersion);
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetVersion

//*********************************************
//* Getting / Settings the Outbox configuration
//*********************************************

error_status_t
FAX_GetOutboxConfiguration (
    IN     handle_t    hFaxHandle,
    IN OUT LPBYTE     *pBuffer,
    IN OUT LPDWORD     pdwBufferSize
)
/*++

Routine name : FAX_GetOutboxConfiguration

Routine description:

    Retrieves the Outbox configuration of the fax server

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pBuffer             [out] - Pointer to buffer to hold configuration information
    pdwBufferSize       [out] - Pointer to buffer size

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetOutboxConfiguration"));
    DWORD dwRes = ERROR_SUCCESS;
    BOOL fAccess;

    Assert (pdwBufferSize);     // ref pointer in idl
    if (!pBuffer)               // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // count up the number of bytes needed
    //
    *pdwBufferSize = sizeof(FAX_OUTBOX_CONFIG);
    PFAX_OUTBOX_CONFIG pOutboxConfig;

    EnterCriticalSection (&g_CsConfig);

    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    pOutboxConfig = (PFAX_OUTBOX_CONFIG)*pBuffer;

    pOutboxConfig->dwSizeOfStruct = sizeof (FAX_OUTBOX_CONFIG);
    pOutboxConfig->bAllowPersonalCP = g_fServerCp ? FALSE : TRUE;
    pOutboxConfig->bUseDeviceTSID = g_fFaxUseDeviceTsid;
    pOutboxConfig->dwRetries = g_dwFaxSendRetries;
    pOutboxConfig->dwRetryDelay = g_dwFaxSendRetryDelay;
    pOutboxConfig->dtDiscountStart.Hour   = g_StartCheapTime.Hour;
    pOutboxConfig->dtDiscountStart.Minute = g_StartCheapTime.Minute;
    pOutboxConfig->dtDiscountEnd.Hour    = g_StopCheapTime.Hour;
    pOutboxConfig->dtDiscountEnd.Minute  = g_StopCheapTime.Minute;
    pOutboxConfig->dwAgeLimit = g_dwFaxDirtyDays;
    pOutboxConfig->bBranding = g_fFaxUseBranding;

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);
    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetOutboxConfiguration

error_status_t
FAX_SetOutboxConfiguration (
    IN handle_t                 hFaxHandle,
    IN const PFAX_OUTBOX_CONFIG pOutboxCfg
)
/*++

Routine name : FAX_SetOutboxConfiguration

Routine description:

    Sets the current Outbox configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in] - Unused
    pOutboxCfg          [in] - Pointer to new data to set

Return Value:

    Standard RPC error codes

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DWORD dwRes;
    BOOL fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetOutboxConfiguration"));

    Assert (pOutboxCfg);

    if (sizeof (FAX_OUTBOX_CONFIG) != pOutboxCfg->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
       return ERROR_INVALID_PARAMETER;
    }
    if ((pOutboxCfg->dtDiscountStart.Hour   > 23) ||
        (pOutboxCfg->dtDiscountStart.Minute > 59) ||
        (pOutboxCfg->dtDiscountEnd.Hour     > 23) ||
        (pOutboxCfg->dtDiscountEnd.Minute   > 59)
       )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSection (&g_CsConfig);

    //
    // Change the values in the registry
    //
    rVal = StoreOutboxSettings (pOutboxCfg);
    if (ERROR_SUCCESS != rVal)
    {
        //
        // Failed to set stuff
        //
        rVal = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }
    //
    // Change the values that the server is currently using
    //
    g_fServerCp =              pOutboxCfg->bAllowPersonalCP ? FALSE : TRUE;
    g_fFaxUseDeviceTsid =      pOutboxCfg->bUseDeviceTSID;
    g_dwFaxSendRetries =        pOutboxCfg->dwRetries;
    g_dwFaxSendRetryDelay =     pOutboxCfg->dwRetryDelay;
    g_dwFaxDirtyDays =          pOutboxCfg->dwAgeLimit;
    g_fFaxUseBranding =        pOutboxCfg->bBranding;

    //
    // Check if CheapTime has changed
    //
    if ( (MAKELONG(g_StartCheapTime.Hour,g_StartCheapTime.Minute) != MAKELONG(pOutboxCfg->dtDiscountStart.Hour,pOutboxCfg->dtDiscountStart.Minute)) ||
         (MAKELONG(g_StopCheapTime.Hour,g_StopCheapTime.Minute)   != MAKELONG(pOutboxCfg->dtDiscountEnd.Hour  ,pOutboxCfg->dtDiscountEnd.Minute  )) )
    {
        //
        // CheapTime has changed. and sort the JobQ
        //
        g_StartCheapTime.Hour =   pOutboxCfg->dtDiscountStart.Hour;
        g_StartCheapTime.Minute = pOutboxCfg->dtDiscountStart.Minute;
        g_StopCheapTime.Hour =    pOutboxCfg->dtDiscountEnd.Hour;
        g_StopCheapTime.Minute =  pOutboxCfg->dtDiscountEnd.Minute;        
    }

    dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_OUTBOX);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_OUTBOX) (ec: %lc)"),
            dwRes);
    }

    Assert (ERROR_SUCCESS == rVal);

exit:
    LeaveCriticalSection (&g_CsConfig);
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetOutboxConfiguration

error_status_t
FAX_GetPersonalCoverPagesOption (
    IN  handle_t hFaxHandle,
    OUT LPBOOL   lpbPersonalCPAllowed
)
/*++

Routine name : FAX_GetPersonalCoverPagesOption

Routine description:

    Gets the currently supported options.

    Requires no access rights.

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle           [in ] - Unused
    lpbPersonalCPAllowed [out] - Pointer to buffer to hold support for personal CP flag.

Return Value:

    Standard RPC error codes

--*/
{
    BOOL fAccess;
    DWORD dwRights;
    DWORD Rval = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetPersonalCoverPagesOption"));

    Assert (lpbPersonalCPAllowed);

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return Rval;
    }

    if (0 == (ALL_FAX_USER_ACCESS_RIGHTS & dwRights))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have any Fax rights"));
        return ERROR_ACCESS_DENIED;
    }

    *lpbPersonalCPAllowed = g_fServerCp ? FALSE : TRUE;
    return ERROR_SUCCESS;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetPersonalCoverPagesOption


//*******************************************
//*         Archive configuration
//*******************************************

error_status_t
FAX_GetArchiveConfiguration (
    IN  handle_t                     hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER      Folder,
    OUT LPBYTE                      *pBuffer,
    OUT LPDWORD                      pdwBufferSize
)
/*++

Routine name : FAX_GetArchiveConfiguration

Routine description:

    Gets the current archive configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    Folder              [in ] - Type of archive
    pBuffer             [out] - Pointer to buffer to hold configuration information
    pdwBufferSize       [out] - Pointer to buffer size

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetArchiveConfiguration"));
    DWORD dwRes = ERROR_SUCCESS;
    BOOL fAccess;

    Assert (pdwBufferSize);     // ref pointer in idl
    if (!pBuffer)               // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    if ((Folder != FAX_MESSAGE_FOLDER_SENTITEMS) &&
        (Folder != FAX_MESSAGE_FOLDER_INBOX)
       )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid folder id (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // count up the number of bytes needed
    //

    *pdwBufferSize = sizeof(FAX_ARCHIVE_CONFIG);
    ULONG_PTR Offset = sizeof(FAX_ARCHIVE_CONFIG);
    PFAX_ARCHIVE_CONFIG pConfig;

    EnterCriticalSection (&g_CsConfig);

    if (NULL != g_ArchivesConfig[Folder].lpcstrFolder)
    {
        *pdwBufferSize += StringSize( g_ArchivesConfig[Folder].lpcstrFolder );
    }

    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    pConfig = (PFAX_ARCHIVE_CONFIG)*pBuffer;

    pConfig->dwSizeOfStruct             = sizeof (FAX_ARCHIVE_CONFIG);
    pConfig->bSizeQuotaWarning          = g_ArchivesConfig[Folder].bSizeQuotaWarning;
    pConfig->bUseArchive                = g_ArchivesConfig[Folder].bUseArchive;
    pConfig->dwAgeLimit                 = g_ArchivesConfig[Folder].dwAgeLimit;
    pConfig->dwSizeQuotaHighWatermark   = g_ArchivesConfig[Folder].dwSizeQuotaHighWatermark;
    pConfig->dwSizeQuotaLowWatermark    = g_ArchivesConfig[Folder].dwSizeQuotaLowWatermark;
    pConfig->dwlArchiveSize             = g_ArchivesConfig[Folder].dwlArchiveSize;

    StoreString(
        g_ArchivesConfig[Folder].lpcstrFolder,
        (PULONG_PTR)&pConfig->lpcstrFolder,
        *pBuffer,
        &Offset,
		*pdwBufferSize
        );

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);
    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetArchiveConfiguration

error_status_t
FAX_SetArchiveConfiguration (
    IN handle_t                     hFaxHandle,
    IN FAX_ENUM_MESSAGE_FOLDER      Folder,
    IN const PFAX_ARCHIVE_CONFIGW   pConfig
)
/*++

Routine name : FAX_SetArchiveConfiguration

Routine description:

    Sets the current archive configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    Folder              [in ] - Type of archive
    pConfig             [in ] - Pointer to new data to set

Return Value:

    Standard RPC error codes

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DWORD dwRes;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetArchiveConfiguration"));
    FAX_ENUM_CONFIG_TYPE ConfigType;
    BOOL bQuotaWarningConfigChanged = TRUE;
    BOOL fAccess;

    Assert (pConfig);

    if (sizeof (FAX_ARCHIVE_CONFIG) != pConfig->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }


    if ((Folder != FAX_MESSAGE_FOLDER_SENTITEMS) &&
        (Folder != FAX_MESSAGE_FOLDER_INBOX)
       )
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid folder id (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }
    if (pConfig->bUseArchive)
    {
        if (pConfig->dwSizeQuotaHighWatermark < pConfig->dwSizeQuotaLowWatermark)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Watermarks mismatch (high=%ld, low=%ld)"),
                pConfig->dwSizeQuotaHighWatermark,
                pConfig->dwSizeQuotaLowWatermark);
            return ERROR_INVALID_PARAMETER;
        }
        if ((NULL == pConfig->lpcstrFolder) || (!lstrlen (pConfig->lpcstrFolder)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Empty folder specified"));
            return ERROR_INVALID_PARAMETER;
        }
    }

    EnterCriticalSection (&g_CsConfig);
    if (pConfig->bUseArchive)
    {
        //
        // Make sure the folder is valid - (Exists, NTFS, Diffrent from the other archive folder
        //
        rVal = IsValidArchiveFolder (pConfig->lpcstrFolder, Folder);
        if (ERROR_SUCCESS != rVal)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Invalid archive folder specified (%s), ec = %ld"),
                pConfig->lpcstrFolder,
                rVal);

            if (ERROR_ACCESS_DENIED == rVal ||
                ERROR_SHARING_VIOLATION == rVal)
            {
                rVal = FAX_ERR_FILE_ACCESS_DENIED;
            }
            goto exit;
        }
    }
    //
    // Change the values in the registry
    //
    rVal = StoreArchiveSettings (Folder, pConfig);
    if (ERROR_SUCCESS != rVal)
    {
        //
        // Failed to set stuff
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StoreArchiveSettings failed, ec = %ld"),
            rVal);
        rVal = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    //
    // Check if we are about to change quota warning configuration
    //
    if (g_ArchivesConfig[Folder].bUseArchive == pConfig->bUseArchive)
    {
        if (pConfig->bUseArchive == TRUE)
        {
                Assert (pConfig->lpcstrFolder && g_ArchivesConfig[Folder].lpcstrFolder);

                if (0 == wcscmp (pConfig->lpcstrFolder, g_ArchivesConfig[Folder].lpcstrFolder) &&
                    pConfig->bSizeQuotaWarning == g_ArchivesConfig[Folder].bSizeQuotaWarning   &&
                    pConfig->dwSizeQuotaHighWatermark == g_ArchivesConfig[Folder].dwSizeQuotaHighWatermark &&
                    pConfig->dwSizeQuotaLowWatermark == g_ArchivesConfig[Folder].dwSizeQuotaLowWatermark)
                {
                        // Quota warning configuration did not change
                        bQuotaWarningConfigChanged = FALSE;
                }
        }
        else
        {
            bQuotaWarningConfigChanged = FALSE;
        }
    }

    //
    // change the values that the server is currently using
    //
    if (!ReplaceStringWithCopy (&g_ArchivesConfig[Folder].lpcstrFolder, pConfig->lpcstrFolder))
    {
        rVal = GetLastError ();
        goto exit;
    }
    g_ArchivesConfig[Folder].bSizeQuotaWarning        = pConfig->bSizeQuotaWarning;
    g_ArchivesConfig[Folder].bUseArchive              = pConfig->bUseArchive;
    g_ArchivesConfig[Folder].dwAgeLimit               = pConfig->dwAgeLimit;
    g_ArchivesConfig[Folder].dwSizeQuotaHighWatermark = pConfig->dwSizeQuotaHighWatermark;
    g_ArchivesConfig[Folder].dwSizeQuotaLowWatermark  = pConfig->dwSizeQuotaLowWatermark;

    ConfigType = (Folder == FAX_MESSAGE_FOLDER_SENTITEMS) ? FAX_CONFIG_TYPE_SENTITEMS : FAX_CONFIG_TYPE_INBOX;
    dwRes = CreateConfigEvent (ConfigType);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_*) (ec: %lc)"),
            dwRes);
    }

    //
    // We want to refresh the archive size
    //
    if (TRUE == bQuotaWarningConfigChanged)
    {
        g_ArchivesConfig[Folder].dwlArchiveSize = FAX_ARCHIVE_FOLDER_INVALID_SIZE;
        g_FaxQuotaWarn[Folder].bConfigChanged = TRUE;
        g_FaxQuotaWarn[Folder].bLoggedQuotaEvent = FALSE;

        if (TRUE == g_ArchivesConfig[Folder].bUseArchive )
        {
            if (!SetEvent (g_hArchiveQuotaWarningEvent))
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("Failed to set quota warning event, SetEvent failed (ec: %lc)"),
                    GetLastError());
            }
        }
    }

    Assert (ERROR_SUCCESS == rVal);

exit:
    LeaveCriticalSection (&g_CsConfig);
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetArchiveConfiguration

//********************************************
//*            Activity logging
//********************************************

error_status_t
FAX_GetActivityLoggingConfiguration (
    IN  handle_t                     hFaxHandle,
    OUT LPBYTE                      *pBuffer,
    OUT LPDWORD                      pdwBufferSize
)
/*++

Routine name : FAX_GetActivityLoggingConfiguration

Routine description:

    Gets the current activity logging configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pBuffer             [out] - Pointer to buffer to hold configuration information
    pdwBufferSize       [out] - Pointer to buffer size

Return Value:

    Standard RPC error codes

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetActivityLoggingConfiguration"));
    DWORD dwRes = ERROR_SUCCESS;
    BOOL fAccess;

    Assert (pdwBufferSize);     // ref pointer in idl
    if (!pBuffer)               // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // count up the number of bytes needed
    //
    *pdwBufferSize = sizeof(FAX_ACTIVITY_LOGGING_CONFIG);
    ULONG_PTR Offset = sizeof(FAX_ACTIVITY_LOGGING_CONFIG);
    PFAX_ACTIVITY_LOGGING_CONFIG pConfig;

    EnterCriticalSection (&g_CsConfig);

    if (NULL != g_ActivityLoggingConfig.lptstrDBPath)
    {
        *pdwBufferSize += StringSize( g_ActivityLoggingConfig.lptstrDBPath );
    }

    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    pConfig = (PFAX_ACTIVITY_LOGGING_CONFIG)*pBuffer;

    pConfig->dwSizeOfStruct             = sizeof (FAX_ACTIVITY_LOGGING_CONFIG);
    pConfig->bLogIncoming               = g_ActivityLoggingConfig.bLogIncoming;
    pConfig->bLogOutgoing               = g_ActivityLoggingConfig.bLogOutgoing;

    StoreString(
        g_ActivityLoggingConfig.lptstrDBPath,
        (PULONG_PTR)&pConfig->lptstrDBPath,
        *pBuffer,
        &Offset,
		*pdwBufferSize
        );

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection (&g_CsConfig);
    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetActivityLoggingConfiguration

error_status_t
FAX_SetActivityLoggingConfiguration (
    IN handle_t                             hFaxHandle,
    IN const PFAX_ACTIVITY_LOGGING_CONFIGW  pConfig
)
/*++

Routine name : FAX_SetActivityLoggingConfiguration

Routine description:

    Sets the current activity logging configuration

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pConfig             [in ] - Pointer to new data to set

Return Value:

    Standard RPC error codes

--*/
{
    error_status_t rVal = ERROR_SUCCESS;
    DWORD dwRes;
    BOOL fAccess;
    HANDLE hNewInboxFile = INVALID_HANDLE_VALUE;
    HANDLE hNewOutboxFile = INVALID_HANDLE_VALUE;
    BOOL IsSameDir = FALSE;
    FAX_ACTIVITY_LOGGING_CONFIGW ActualConfig;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetActivityLoggingConfiguration"));

    Assert (pConfig);

    if (sizeof (FAX_ACTIVITY_LOGGING_CONFIG) != pConfig->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
        return ERROR_INVALID_PARAMETER;
    }

    ActualConfig = *pConfig;

    if (ActualConfig.bLogIncoming || ActualConfig.bLogOutgoing)
    {
        DWORD dwLen;

        if ((NULL == ActualConfig.lptstrDBPath) || (!lstrlen (ActualConfig.lptstrDBPath)))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Empty DB file name specified"));
            return ERROR_INVALID_PARAMETER;
        }

        if ((dwLen = lstrlen (ActualConfig.lptstrDBPath)) > MAX_DIR_PATH)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("DB file name exceeds MAX_PATH"));
            return ERROR_BUFFER_OVERFLOW;
        }

        if (L'\\' == ActualConfig.lptstrDBPath[dwLen - 1])
        {
            //
            // Activity logging DB name should not end with a backslash.
            //
            ActualConfig.lptstrDBPath[dwLen - 1] = (WCHAR)'\0';
        }
    }
    else
    {
        //
        // If logging is off, the DB path is always NULL
        //
        ActualConfig.lptstrDBPath = NULL;
    }
    //
    // Access check
    //
    rVal = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    rVal);
        return GetServerErrorCode(rVal);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Always lock  g_CsInboundActivityLogging and then g_CsOutboundActivityLogging
    //
    EnterCriticalSection (&g_CsInboundActivityLogging);
    EnterCriticalSection (&g_CsOutboundActivityLogging);

    if (ActualConfig.lptstrDBPath)
    {
        //
        // Activity logging is on.
        // Validate the new activity logging directory
        //
        rVal = IsValidFaxFolder(ActualConfig.lptstrDBPath);
        if(ERROR_SUCCESS != rVal)
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("IsValidFaxFolder failed for folder : %s (ec=%lu)."),
                         ActualConfig.lptstrDBPath,
                         rVal);

            if(ERROR_ACCESS_DENIED == rVal &&
               FAX_API_VERSION_1 <= FindClientAPIVersion (hFaxHandle) )
            {
                rVal = FAX_ERR_FILE_ACCESS_DENIED;
            }
            goto exit;
        }

        //
        // Check if the DB path has changed
        //
        if (NULL == g_ActivityLoggingConfig.lptstrDBPath)
        {
            //
            // DB was off
            //
            IsSameDir = FALSE;
        }
        else
        {
            rVal = CheckToSeeIfSameDir( ActualConfig.lptstrDBPath,
                                        g_ActivityLoggingConfig.lptstrDBPath,
                                        &IsSameDir);
            if (ERROR_SUCCESS != rVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CheckToSeeIfSameDir with %ld"), rVal);
            }
        }

        if (ERROR_SUCCESS == rVal && FALSE == IsSameDir)
        {
            //
            // Switch DB path
            //
            rVal = CreateLogDB (ActualConfig.lptstrDBPath, &hNewInboxFile, &hNewOutboxFile);
            if (ERROR_SUCCESS != rVal)
            {
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CreateLogDB with %ld"), rVal);
            }
        }

        if (ERROR_SUCCESS != rVal)
        {
            if (ERROR_ACCESS_DENIED == rVal ||
                ERROR_SHARING_VIOLATION == rVal)
            {
                rVal = FAX_ERR_FILE_ACCESS_DENIED;
            }
            goto exit;
        }
    }

    //
    // Change the values in the registry.
    // Notice: if the logging is off, the DB path gets written as "".
    //
    rVal = StoreActivityLoggingSettings (&ActualConfig);
    if (ERROR_SUCCESS != rVal)
    {
        //
        // Failed to set stuff
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("StoreActivityLoggingSettings failed (ec: %ld)"),
            rVal);
        rVal = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }

    if (!ReplaceStringWithCopy (&g_ActivityLoggingConfig.lptstrDBPath, ActualConfig.lptstrDBPath))
    {
        rVal = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("ReplaceStringWithCopy (ec: %ld)"),
            rVal);

        //
        // Try to rollback
        //
        FAX_ACTIVITY_LOGGING_CONFIGW previousActivityLoggingConfig = {0};
        
        previousActivityLoggingConfig.dwSizeOfStruct = sizeof(previousActivityLoggingConfig);
        previousActivityLoggingConfig.bLogIncoming  = g_ActivityLoggingConfig.bLogIncoming;
        previousActivityLoggingConfig.bLogOutgoing  = g_ActivityLoggingConfig.bLogOutgoing;
        previousActivityLoggingConfig.lptstrDBPath  = g_ActivityLoggingConfig.lptstrDBPath;


        dwRes = StoreActivityLoggingSettings (&previousActivityLoggingConfig);
        if (ERROR_SUCCESS != dwRes)
        {
            //
            // Failed to set stuff
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("StoreActivityLoggingSettings failed  - rollback failed (ec: %ld)"),
                dwRes);
        }
        goto exit;
    }

    if (FALSE == IsSameDir)
    {
        //
        // change the values that the server is currently using
        //
        if (g_hInboxActivityLogFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle (g_hInboxActivityLogFile))
            {
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CloseHandle failed  - (ec: %ld)"),
                        GetLastError());
            }
        }

        if (g_hOutboxActivityLogFile != INVALID_HANDLE_VALUE)
        {
            if (!CloseHandle (g_hOutboxActivityLogFile))
            {
                DebugPrintEx(
                        DEBUG_ERR,
                        TEXT("CloseHandle failed  - (ec: %ld)"),
                        GetLastError());
            }
        }

        g_hInboxActivityLogFile = hNewInboxFile;
        hNewInboxFile = INVALID_HANDLE_VALUE; // Do not close the file handle

        g_hOutboxActivityLogFile = hNewOutboxFile;
        hNewOutboxFile = INVALID_HANDLE_VALUE; // Do not close the file handle
    }

    g_ActivityLoggingConfig.bLogIncoming = ActualConfig.bLogIncoming;
    g_ActivityLoggingConfig.bLogOutgoing = ActualConfig.bLogOutgoing;

    dwRes = CreateConfigEvent (FAX_CONFIG_TYPE_ACTIVITY_LOGGING);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_ACTIVITY_LOGGING) (ec: %ld)"),
            dwRes);
    }

    Assert (ERROR_SUCCESS == rVal);

exit:
    LeaveCriticalSection (&g_CsOutboundActivityLogging);
    LeaveCriticalSection (&g_CsInboundActivityLogging);

    if (INVALID_HANDLE_VALUE != hNewInboxFile ||
        INVALID_HANDLE_VALUE != hNewOutboxFile)
    {
        WCHAR wszFileName[MAX_PATH*2] = {0};
        Assert (INVALID_HANDLE_VALUE != hNewInboxFile &&
                INVALID_HANDLE_VALUE != hNewOutboxFile);

        //
        // Clean Inbox file
        //
        swprintf (wszFileName,
                  TEXT("%s\\%s"),
                  ActualConfig.lptstrDBPath,
                  ACTIVITY_LOG_INBOX_FILE);

        if (!CloseHandle (hNewInboxFile))
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CloseHandle failed  - (ec: %ld)"),
                    GetLastError());
        }
        if (!DeleteFile(wszFileName))
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteFile failed  - (ec: %ld)"),
                GetLastError());
        }

        //
        // Clean Outbox file
        //
        swprintf (wszFileName,
                  TEXT("%s\\%s"),
                  ActualConfig.lptstrDBPath,
                  ACTIVITY_LOG_OUTBOX_FILE);

        if (!CloseHandle (hNewOutboxFile))
        {
            DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("CloseHandle failed  - (ec: %ld)"),
                    GetLastError());
        }
        if (!DeleteFile(wszFileName))
        {
             DebugPrintEx(
                DEBUG_ERR,
                TEXT("DeleteFile failed  - (ec: %ld)"),
                GetLastError());
        }
    }
    return GetServerErrorCode(rVal);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetActivityLoggingConfiguration


//********************************************
//*                   FSP
//********************************************

error_status_t
FAX_EnumerateProviders (
    IN  handle_t   hFaxHandle,
    OUT LPBYTE    *pBuffer,
    OUT LPDWORD    pdwBufferSize,
    OUT LPDWORD    lpdwNumProviders
)
/*++

Routine name : FAX_EnumerateProviders

Routine description:

    Enumerates the FSPs

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    pBuffer             [out] - Pointer to buffer to hold FSPs array
    pdwBufferSize       [out] - Pointer to buffer size
    lpdwNumProviders    [out] - Size of FSPs array

Return Value:

    Standard RPC error codes

--*/
{
    PLIST_ENTRY                 Next;
    DWORD_PTR                   dwOffset;
    PFAX_DEVICE_PROVIDER_INFO   pFSPs;
    DWORD                       dwIndex;
    DWORD                       dwRes = ERROR_SUCCESS;
    BOOL                        fAccess;

    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumerateProviders"));

    Assert (pdwBufferSize && lpdwNumProviders);     // ref pointer in idl
    if (!pBuffer)                                   // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // First run - traverse list and count size required + list size
    //
    *lpdwNumProviders = 0;
    *pdwBufferSize = 0;
    Next = g_DeviceProvidersListHead.Flink;
    if (NULL == Next)
    {
        //
        // The list is corrupted
        //
        ASSERT_FALSE;
        //
        // We'll crash and we deserve it....
        //
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        PDEVICE_PROVIDER    pProvider;

        (*lpdwNumProviders)++;
        (*pdwBufferSize) += sizeof (FAX_DEVICE_PROVIDER_INFO);
        //
        // Get current provider
        //
        pProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        //
        // Advance pointer
        //
        Next = pProvider->ListEntry.Flink;
        (*pdwBufferSize) += StringSize (pProvider->FriendlyName);
        (*pdwBufferSize) += StringSize (pProvider->ImageName);
        (*pdwBufferSize) += StringSize (pProvider->ProviderName);
        (*pdwBufferSize) += StringSize (pProvider->szGUID);
    }
    //
    // Allocate required size
    //
    *pBuffer = (LPBYTE)MemAlloc( *pdwBufferSize );
    if (NULL == *pBuffer)
    {
        return FAX_ERR_SRV_OUTOFMEMORY;
    }
    //
    // Second pass, fill in the array
    //
    pFSPs = (PFAX_DEVICE_PROVIDER_INFO)(*pBuffer);
    dwOffset = (*lpdwNumProviders) * sizeof (FAX_DEVICE_PROVIDER_INFO);
    Next = g_DeviceProvidersListHead.Flink;
    dwIndex = 0;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_DeviceProvidersListHead)
    {
        PDEVICE_PROVIDER    pProvider;

        //
        // Get current provider
        //
        pProvider = CONTAINING_RECORD( Next, DEVICE_PROVIDER, ListEntry );
        //
        // Advance pointer
        //
        Next = pProvider->ListEntry.Flink;
        pFSPs[dwIndex].dwSizeOfStruct = sizeof (FAX_DEVICE_PROVIDER_INFO);
        StoreString(
            pProvider->FriendlyName,
            (PULONG_PTR)&(pFSPs[dwIndex].lpctstrFriendlyName),
            *pBuffer,
            &dwOffset,
			*pdwBufferSize
            );
        StoreString(
            pProvider->ImageName,
            (PULONG_PTR)&(pFSPs[dwIndex].lpctstrImageName),
            *pBuffer,
            &dwOffset,
			*pdwBufferSize
            );
        StoreString(
            pProvider->ProviderName,
            (PULONG_PTR)&(pFSPs[dwIndex].lpctstrProviderName),
            *pBuffer,
            &dwOffset,
			*pdwBufferSize
            );
        StoreString(
            pProvider->szGUID,
            (PULONG_PTR)&(pFSPs[dwIndex].lpctstrGUID),
            *pBuffer,
            &dwOffset,
			*pdwBufferSize
            );
        pFSPs[dwIndex].dwCapabilities = 0;
        pFSPs[dwIndex].Version = pProvider->Version;
        pFSPs[dwIndex].Status = pProvider->Status;
        pFSPs[dwIndex].dwLastError = pProvider->dwLastError;
        dwIndex++;
    }
    Assert (dwIndex == *lpdwNumProviders);
    return ERROR_SUCCESS;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_EnumerateProviders

//********************************************
//*              Extended ports
//********************************************

DWORD
GetExtendedPortSize (
    PLINE_INFO pLineInfo
)
/*++

Routine name : GetExtendedPortSize

Routine description:

    Returns the size occupied by the extended info of a port

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pLineInfo           [in] - Port pointer

Remarks:

    This function should be called with g_CsLine held.

Return Value:

    Size required

--*/
{
    DWORD dwSize = sizeof (FAX_PORT_INFO_EX);
    DEBUG_FUNCTION_NAME(TEXT("GetExtendedPortSize"));

    Assert (pLineInfo);
    dwSize+= StringSize (pLineInfo->DeviceName);
    dwSize+= StringSize (pLineInfo->lptstrDescription);
    Assert (pLineInfo->Provider);
    dwSize+= StringSize (pLineInfo->Provider->FriendlyName);
    dwSize+= StringSize (pLineInfo->Provider->szGUID);
    dwSize+= StringSize (pLineInfo->Csid);
    dwSize+= StringSize (pLineInfo->Tsid);
    return dwSize;
}   // GetExtendedPortSize

VOID
StorePortInfoEx (
    PFAX_PORT_INFO_EX pPortInfoEx,
    PLINE_INFO        pLineInfo,
    LPBYTE            lpBufferStart,
    PULONG_PTR        pupOffset,
	DWORD             dwBufferStartSize
)
/*++

Routine name : StorePortInfoEx

Routine description:

    Stores a port extended info into a buffer

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    pPortInfoEx         [in ] - Buffer to store
    pLineInfo           [in ] - Port pointer
    lpBufferStart       [in ] - Start address of buffer (for offset calculations)
    pupOffset           [in ] - Current offset
	dwBufferStartSize   [in ] - Size of the lpBufferStart, in bytes.
                                This parameter is used only if lpBufferStart is not NULL.   

Remarks:

    This function should be called with g_CsLine held.

Return Value:
	None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("StorePortInfoEx"));

    //
    // Store the data
    //
    pPortInfoEx->dwSizeOfStruct             = sizeof (FAX_PORT_INFO_EX);
    if (g_dwManualAnswerDeviceId == pLineInfo->PermanentLineID)
    {
        //
        // Device is in manual-answer mode
        //
        Assert (!(pLineInfo->Flags & FPF_RECEIVE));
        pPortInfoEx->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_MANUAL;
    }
    else if (pLineInfo->Flags & FPF_RECEIVE)
    {
        //
        // Device is in auto-answer mode
        //
        Assert (g_dwManualAnswerDeviceId != pLineInfo->PermanentLineID);
        pPortInfoEx->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_AUTO;
    }
    else
    {
        //
        // Device is not set to receive
        //
        Assert (g_dwManualAnswerDeviceId != pLineInfo->PermanentLineID);
        pPortInfoEx->ReceiveMode = FAX_DEVICE_RECEIVE_MODE_OFF;
    }
    pPortInfoEx->bSend                      = (pLineInfo->Flags & FPF_SEND) ? TRUE : FALSE;
    pPortInfoEx->dwStatus                   = (pLineInfo->dwReceivingJobsCount ? FAX_DEVICE_STATUS_RECEIVING : 0) |
                                              (pLineInfo->dwSendingJobsCount ? FAX_DEVICE_STATUS_SENDING : 0);
    pPortInfoEx->dwDeviceID                 = pLineInfo->PermanentLineID;
    pPortInfoEx->dwRings                    = pLineInfo->RingsForAnswer;

    StoreString(
        pLineInfo->DeviceName,
        (PULONG_PTR)&pPortInfoEx->lpctstrDeviceName,
        lpBufferStart,
        pupOffset,
		dwBufferStartSize
        );

    StoreString(
        pLineInfo->lptstrDescription,
        (PULONG_PTR)&pPortInfoEx->lptstrDescription,
        lpBufferStart,
        pupOffset,
		dwBufferStartSize
        );

    StoreString(
        pLineInfo->Provider->FriendlyName,
        (PULONG_PTR)&pPortInfoEx->lpctstrProviderName,
        lpBufferStart,
        pupOffset,
		dwBufferStartSize
        );

    StoreString(
        pLineInfo->Provider->szGUID,
        (PULONG_PTR)&pPortInfoEx->lpctstrProviderGUID,
        lpBufferStart,
        pupOffset,
		dwBufferStartSize
        );

    StoreString(
        pLineInfo->Csid,
        (PULONG_PTR)&pPortInfoEx->lptstrCsid,
        lpBufferStart,
        pupOffset,
		dwBufferStartSize
        );

    StoreString(
        pLineInfo->Tsid,
        (PULONG_PTR)&pPortInfoEx->lptstrTsid,
        lpBufferStart,
        pupOffset,
		dwBufferStartSize
        );

}   // StorePortInfoEx

error_status_t
FAX_EnumPortsEx(
    IN handle_t       hFaxHandle,
    IN OUT LPBYTE    *lpBuffer,
    IN OUT LPDWORD    lpdwBufferSize,
    OUT LPDWORD       lpdwNumPorts
)
/*++

Routine name : FAX_EnumPortsEx

Routine description:

    Enumerates the ports

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    lpBuffer            [out] - Pointer to buffer to hold ports array
    lpdwBufferSize      [out] - Pointer to buffer size
    lpdwNumPorts        [out] - Size of ports array

Return Value:

    Standard RPC error codes

--*/
{
    PLIST_ENTRY                 Next;
    DWORD_PTR                   dwOffset;
    DWORD                       dwIndex;
    DWORD                       dwRes = ERROR_SUCCESS;
    PFAX_PORT_INFO_EX           pPorts;
    BOOL                        fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumPortsEx"));

    Assert (lpdwBufferSize && lpdwNumPorts);    // ref pointer in idl
    if (!lpBuffer)                              // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // First run - traverse list and count size required + list size
    //
    *lpdwNumPorts = 0;
    *lpdwBufferSize = 0;

    EnterCriticalSection( &g_CsLine );
    Next = g_TapiLinesListHead.Flink;
    if (NULL == Next)
    {
        //
        // The list is corrupted
        //
        ASSERT_FALSE;
        //
        // We'll crash and we deserve it....
        //
    }

    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        PLINE_INFO pLineInfo;

        (*lpdwNumPorts)++;
        //
        // Get current port
        //
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        //
        // Advance pointer
        //
        Next = pLineInfo->ListEntry.Flink;
        //
        // Sum up size
        //
        (*lpdwBufferSize) += GetExtendedPortSize (pLineInfo);
    }
    //
    // Allocate required size
    //
    *lpBuffer = (LPBYTE)MemAlloc( *lpdwBufferSize );
    if (NULL == *lpBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    //
    // Second pass, fill in the array
    //
    pPorts = (PFAX_PORT_INFO_EX)(*lpBuffer);
    dwOffset = (*lpdwNumPorts) * sizeof (FAX_PORT_INFO_EX);
    Next = g_TapiLinesListHead.Flink;
    dwIndex = 0;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_TapiLinesListHead)
    {
        PLINE_INFO pLineInfo;

        //
        // Get current port
        //
        pLineInfo = CONTAINING_RECORD( Next, LINE_INFO, ListEntry );
        //
        // Advance pointer
        //
        Next = pLineInfo->ListEntry.Flink;
        //
        // Store port data
        //
        StorePortInfoEx (&pPorts[dwIndex++],
                         pLineInfo,
                         *lpBuffer,
                         &dwOffset,
						 *lpdwBufferSize
                        );
    }
    Assert (dwIndex == *lpdwNumPorts);
    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection( &g_CsLine );
    return GetServerErrorCode(dwRes);

    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_EnumPortsEx

error_status_t
FAX_GetPortEx(
    IN handle_t    hFaxHandle,
    IN DWORD       dwDeviceId,
    IN OUT LPBYTE *lpBuffer,
    IN OUT LPDWORD lpdwBufferSize
)
/*++

Routine name : FAX_GetPortEx

Routine description:

    Gets extended port info

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    dwDeviceId          [in ] - Unique device id
    lpBuffer            [out] - Pointer to buffer to hold extended port information
    lpdwBufferSize      [out] - Pointer to buffer size

Return Value:

    Standard RPC error codes

--*/
{
    DWORD_PTR           dwOffset;
    PLINE_INFO          pLineInfo;
    DWORD               dwRes = ERROR_SUCCESS;
    BOOL                fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_GetPortEx"));

    Assert (lpdwBufferSize);     // ref pointer in idl
    if (!lpBuffer)               // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_QUERY_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_QUERY_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Locate the port (device)
    //
    EnterCriticalSection( &g_CsLine );
    pLineInfo = GetTapiLineFromDeviceId( dwDeviceId, FALSE );
    if (!pLineInfo)
    {
        //
        // Port not found
        //
        dwRes = ERROR_BAD_UNIT; // The system cannot find the device specified.
        goto exit;
    }
    //
    // count up the number of bytes needed
    //
    *lpdwBufferSize = GetExtendedPortSize(pLineInfo);
    dwOffset = sizeof (FAX_PORT_INFO_EX);
    //
    // Allocate buffer
    //
    *lpBuffer = (LPBYTE)MemAlloc( *lpdwBufferSize );
    if (NULL == *lpBuffer)
    {
        dwRes = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    StorePortInfoEx ((PFAX_PORT_INFO_EX)*lpBuffer,
                     pLineInfo,
                     *lpBuffer,
                     &dwOffset,
					 *lpdwBufferSize
                    );

    Assert (ERROR_SUCCESS == dwRes);

exit:
    LeaveCriticalSection( &g_CsLine );
    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_GetPortEx


error_status_t
FAX_SetPortEx (
    IN handle_t                 hFaxHandle,
    IN DWORD                    dwDeviceId,
    IN const PFAX_PORT_INFO_EX  pNewPortInfo
)
/*++

Routine name : FAX_SetPortEx

Routine description:

    Sets extended port info

Author:

    Eran Yariv (EranY), Nov, 1999

Arguments:

    hFaxHandle          [in ] - Unused
    dwDeviceId          [in ] - Unique device id
    pNewPortInfo        [out] - Pointer to new extended port information

Return Value:

    Standard RPC error codes

--*/
{
    DWORD       dwRes = ERROR_SUCCESS;
    DWORD       rVal;
    PLINE_INFO  pLineInfo;
    BOOL        bVirtualDeviceNeedsUpdate = FALSE;
    BOOL        fAccess;
    BOOL        bDeviceWasSetToReceive;    // Was the device configured to receive faxes?
    BOOL        bDeviceWasEnabled;         // Was the device send/receive/manual receive enabled
	BOOL        bDeviceWasAutoReceive;     // Was the device  auto receive enabled
    DWORD       dwLastManualAnswerDeviceId = 0;
    DEBUG_FUNCTION_NAME(TEXT("FAX_SetPortEx"));

    Assert (pNewPortInfo);

    if (!dwDeviceId)
    {
        return ERROR_INVALID_PARAMETER;
    }
    if (sizeof (FAX_PORT_INFO_EX) != pNewPortInfo->dwSizeOfStruct)
    {
        //
        // Size mismatch
        //
        return ERROR_INVALID_PARAMETER;
    }
    if (MAX_FAX_STRING_LEN <= lstrlen (pNewPortInfo->lptstrDescription))
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    if ((FAX_DEVICE_RECEIVE_MODE_MANUAL < pNewPortInfo->ReceiveMode) ||
        (FAX_DEVICE_RECEIVE_MODE_OFF    > pNewPortInfo->ReceiveMode))

    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("ReceiveMode = %d and > FAX_DEVICE_RECEIVE_MODE_MANUAL"),
                    pNewPortInfo->ReceiveMode);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return GetServerErrorCode(dwRes);
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    EnterCriticalSectionJobAndQueue;
    EnterCriticalSection( &g_CsLine );

    //
    // Remember the original device set to manual-answer
    //
    dwLastManualAnswerDeviceId = g_dwManualAnswerDeviceId;
    //
    // Locate the port (device)
    //
    pLineInfo = GetTapiLineFromDeviceId (dwDeviceId, FALSE);
    if (!pLineInfo)
    {
        //
        // Port not found
        //
        dwRes = ERROR_BAD_UNIT; // The system cannot find the device specified.
        goto exit;
    }
    bDeviceWasEnabled = IsDeviceEnabled(pLineInfo);
    bDeviceWasSetToReceive = (pLineInfo->Flags & FPF_RECEIVE) ||            // Either device was set to auto-receive or
                             (dwDeviceId == g_dwManualAnswerDeviceId);      // it's the manual answer device id
	bDeviceWasAutoReceive = (pLineInfo->Flags & FPF_RECEIVE);				// Device was set to auto receive


    if ((pLineInfo->Flags & FPF_VIRTUAL) &&                                 // The device is virtual and
        (FAX_DEVICE_RECEIVE_MODE_MANUAL == pNewPortInfo->ReceiveMode))      // we were asked to set it to manual-answer
    {
        //
        // We don't support manual-answer on non-physical devices
        //
        DebugPrintEx(DEBUG_ERR,
                    TEXT("Device id (%ld) is virtual"),
                    dwDeviceId);
        dwRes = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Check device limit
    //
    if (g_dwDeviceEnabledCount >= g_dwDeviceEnabledLimit &&             // We are at the device limit
        !bDeviceWasEnabled                               &&             // It was not send/receive/manual receive enabled
        (pNewPortInfo->bSend        ||                                  // It is now send  enabled
        pNewPortInfo->ReceiveMode  != FAX_DEVICE_RECEIVE_MODE_OFF))     // It is now receive enabled
    {
        BOOL fLimitExceeded = TRUE;

        //
        // We should now verify if manual answer device changed. If so there is another device to take into device enabled account.
        //
        if (dwLastManualAnswerDeviceId != 0                                 && // There was a device set to manual answer
            FAX_DEVICE_RECEIVE_MODE_MANUAL == pNewPortInfo->ReceiveMode     && // The new device is set to manual
            dwLastManualAnswerDeviceId != dwDeviceId)                          // It is not the same device
        {
            //
            // See if the old device is send enabled
            //
            PLINE_INFO pOldLine;
            pOldLine = GetTapiLineFromDeviceId (dwLastManualAnswerDeviceId, FALSE);
            if (pOldLine)
            {
                if (!(pOldLine->Flags & FPF_SEND))
                {
                    //
                    // The old manual receive device is not send enabled. When the manual receive device will be changed, the old device
                    // will not be enabled anymore, and the enabled device count will be decremented.
                    //
                    fLimitExceeded = FALSE;
                }
            }
        }

        if (TRUE == fLimitExceeded)
        {
            if (FAX_API_VERSION_1 > FindClientAPIVersion (hFaxHandle))
            {
                //
                // API version 0 clients don't know about FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED
                //
                dwRes = ERROR_INVALID_PARAMETER;
            }
            else
            {
                dwRes = FAX_ERR_DEVICE_NUM_LIMIT_EXCEEDED;
            }
            goto exit;
        }
    }

    //
    // Store device configuration in the registry
    //
    dwRes = StoreDeviceConfig (dwDeviceId, pNewPortInfo, pLineInfo->Flags & FPF_VIRTUAL ? TRUE : FALSE);
    if (ERROR_SUCCESS != dwRes)
    {
        dwRes = ERROR_REGISTRY_CORRUPT;
        goto exit;
    }
    //
    // Update data in server's memory
    //
    if (!ReplaceStringWithCopy (&(pLineInfo->lptstrDescription), pNewPortInfo->lptstrDescription))
    {
        dwRes = GetLastError ();
        goto exit;
    }
    if (!ReplaceStringWithCopy (&(pLineInfo->Csid), pNewPortInfo->lptstrCsid))
    {
        dwRes = GetLastError ();
        goto exit;
    }
    if (!ReplaceStringWithCopy (&(pLineInfo->Tsid), pNewPortInfo->lptstrTsid))
    {
        dwRes = GetLastError ();
        goto exit;
    }
    pLineInfo->RingsForAnswer = pNewPortInfo->dwRings;
    //
    // More advanced settings - require additional work
    //

    //
    // Check for changes in the device receive modes
    //
    // We have 9 options here as described in the table below:
    //
    //     New receive mode | Off | Auto | Manual
    // Old receive mode     |     |      |
    // ---------------------+-----+------+--------
    // Off                  |  1  |   2  |   3
    // ---------------------+-----+------+--------
    // Auto                 |  4  |   5  |   6
    // ---------------------+-----+------+--------
    // Manual               |  7  |   8  |   9
    //
    //
    // Options 1, 5, and 9 mean no change and there's no code to handle them explicitly.
    //

    if ((FAX_DEVICE_RECEIVE_MODE_AUTO == pNewPortInfo->ReceiveMode) &&
        (g_dwManualAnswerDeviceId == dwDeviceId))
    {
        //
        // Change #8 - see table above
        //
        // Device was in manual-answer mode and we now switch to auto-answer mode
        // Keep the line open
        //
        pLineInfo->Flags |= FPF_RECEIVE;
        bVirtualDeviceNeedsUpdate = TRUE;
        //
        // Mark no device as manual answer device
        //
        g_dwManualAnswerDeviceId = 0;
        goto UpdateManualDevice;
    }
    else if ((FAX_DEVICE_RECEIVE_MODE_MANUAL == pNewPortInfo->ReceiveMode) &&
             (pLineInfo->Flags & FPF_RECEIVE))
    {
        //
        // Change #6 - see table above
        //
        // Device was in auto-answer mode and we now switch to manual-answer mode
        // Keep the line open
        //
        pLineInfo->Flags &= ~FPF_RECEIVE;
        bVirtualDeviceNeedsUpdate = TRUE;
        //
        // Mark our device as manual answer device
        //
        g_dwManualAnswerDeviceId = dwDeviceId;
        goto UpdateManualDevice;
    }

    if (!bDeviceWasSetToReceive && (pNewPortInfo->ReceiveMode != FAX_DEVICE_RECEIVE_MODE_OFF))
    {
        //
        // The device should start receiving now (manual or auto).
        // Update line info.
        //
        if (FAX_DEVICE_RECEIVE_MODE_AUTO == pNewPortInfo->ReceiveMode)
        {
            //
            // Change #2 - see table above
            //
            // If set to auto-receive, mark that in the device info
            //
            pLineInfo->Flags |= FPF_RECEIVE;
            bVirtualDeviceNeedsUpdate = TRUE;
        }
        else
        {
            //
            // Change #3 - see table above
            //
            // If manual-receive, update the global manual-receive device id
            //
            g_dwManualAnswerDeviceId = dwDeviceId;
        }

        if (!(pLineInfo->Flags & FPF_VIRTUAL) && (!pLineInfo->hLine))
        {
            if (!OpenTapiLine( pLineInfo ))
            {
                DWORD rc = GetLastError();
                DebugPrintEx(
                    DEBUG_ERR,
                    TEXT("OpenTapiLine failed. (ec: %ld)"),
                    rc);
            }
        }
    }
    else if (bDeviceWasSetToReceive && (FAX_DEVICE_RECEIVE_MODE_OFF == pNewPortInfo->ReceiveMode))
    {
        //
        // The device should stop receiving now
        //
        if (dwDeviceId == g_dwManualAnswerDeviceId)
        {
            //
            // Change #7 - see table above
            //
            // The device was in manual-answer mode
            //
            Assert (!(pLineInfo->Flags & FPF_RECEIVE));
            //
            // Set manual-answer device id to 'no device'
            //
            g_dwManualAnswerDeviceId = 0;
        }
        else
        {
            //
            // Change #4 - see table above
            //
            // The device was in auto-answer mode
            //
            Assert (pLineInfo->Flags & FPF_RECEIVE);
            //
            // Update line info
            //
            pLineInfo->Flags &= ~FPF_RECEIVE;
            bVirtualDeviceNeedsUpdate = TRUE;
        }
        if (pLineInfo->State == FPS_AVAILABLE                        &&  // Line is available and
            pLineInfo->hLine                                             // device is open
           )
        {
            //
            // We can not close the line if it is busy.
            // We simply remove the FPF_RECEIVE and ReleaseTapiLine will call lineClose when the job terminates.
            //
            lineClose( pLineInfo->hLine );
            pLineInfo->hLine = 0;
        }
    }
UpdateManualDevice:
    if (dwLastManualAnswerDeviceId != g_dwManualAnswerDeviceId)
    {
        //
        // Manual answer device has changed.
        // Update the registry
        //
        dwRes = WriteManualAnswerDeviceId (g_dwManualAnswerDeviceId);
        if (ERROR_SUCCESS != dwRes)
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("WriteManualAnswerDeviceId(0) (ec: %lc)"),
                dwRes);
        }
        if (0 != dwLastManualAnswerDeviceId &&
            dwDeviceId != dwLastManualAnswerDeviceId)
        {
            //
            // Another device just stopped being the device in manual-anser mode
            //
            PLINE_INFO pOldLine;
            pOldLine = GetTapiLineFromDeviceId (dwLastManualAnswerDeviceId, FALSE);
            if (pOldLine)
            {
                //
                // The former device still exists, remove receive enabled flag.
                //
                pOldLine->Flags &= ~FPF_RECEIVE;

                if (pOldLine->State == FPS_AVAILABLE        &&  // Line is available and
                    pOldLine->hLine)                            // Device is open
                {
                    //
                    // This is a good time to close the device
                    // which just stopped being the manual-answer device
                    //
                    lineClose(pOldLine->hLine);
                    pOldLine->hLine = 0;
                }

                //
                // Check if this device is still enabled
                //
                if (FALSE == IsDeviceEnabled(pOldLine))
                {
                    Assert (g_dwDeviceEnabledCount);
                    g_dwDeviceEnabledCount -= 1;
                }
            }
        }
    }
    //
    // Check for changes in the device send mode
    //
    if (!(pLineInfo->Flags & FPF_SEND) && pNewPortInfo->bSend)
    {
        //
        // The device should start being available for sending now
        //
        bVirtualDeviceNeedsUpdate = TRUE;
        //
        // We just added a new device to the send
        // capable device collection - signal the queue
        //
        if (!SetEvent( g_hJobQueueEvent ))
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("SetEvent failed (ec: %lc)"),
                GetLastError);
            g_ScanQueueAfterTimeout = TRUE;
        }
        //
        // Update line info
        //
        pLineInfo->Flags |= FPF_SEND;
        pLineInfo->LastLineClose = 0; // Try to use it on the first try
    }
    else if ((pLineInfo->Flags & FPF_SEND) && !pNewPortInfo->bSend)
    {
        //
        // The device should stop being available for sending now
        // Update line info
        //
        bVirtualDeviceNeedsUpdate = TRUE;
        pLineInfo->Flags &= ~FPF_SEND;
    }
    if (bVirtualDeviceNeedsUpdate)
    {
        //
        // The Send / Receive status has changed - update the virtual device
        //
        UpdateVirtualDeviceSendAndReceiveStatus (pLineInfo,
                                                 pNewPortInfo->bSend,
                                                 (FAX_DEVICE_RECEIVE_MODE_AUTO == pNewPortInfo->ReceiveMode)
                                                );
    }

    rVal = CreateConfigEvent (FAX_CONFIG_TYPE_DEVICES);
    if (ERROR_SUCCESS != rVal)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("CreateConfigEvent(FAX_CONFIG_TYPE_DEVICES) (ec: %lc)"),
            rVal);
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (pLineInfo)
    {
        if (bDeviceWasAutoReceive && !(pLineInfo->Flags & FPF_RECEIVE))
        {
            //
            // This device stopped auto receiving
            //
            SafeDecIdleCounter (&g_dwReceiveDevicesCount);
        }
        else if (!bDeviceWasAutoReceive && (pLineInfo->Flags & FPF_RECEIVE))
        {
            //
            // This device started auto receiving
            //
            SafeIncIdleCounter (&g_dwReceiveDevicesCount);
        }

        //
        // Update enabled device count
        //
        if (bDeviceWasEnabled == TRUE)
        {
            if (FALSE == IsDeviceEnabled(pLineInfo))
            {
                Assert (g_dwDeviceEnabledCount);
                g_dwDeviceEnabledCount -= 1;
            }
        }
        else
        {
            //
            // The device was not enabled
            //
            if (TRUE == IsDeviceEnabled(pLineInfo))
            {
                g_dwDeviceEnabledCount += 1;
                Assert (g_dwDeviceEnabledCount <= g_dwDeviceEnabledLimit);
            }
        }
    }
    LeaveCriticalSection( &g_CsLine );
    LeaveCriticalSectionJobAndQueue;

    return GetServerErrorCode(dwRes);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_SetPortEx



error_status_t
FAX_GetJobEx(
    IN handle_t hFaxHandle,
    IN DWORDLONG dwlMessageId,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize
    )
/*++

Routine name : FAX_GetJobEx

Routine description:

    Fills FAX_JOB_ENTRY_EX of a message specified by its unique ID

Author:

    Oded Sacher (OdedS),    Nov, 1999

Arguments:

    hFaxHandle          [in] - Binding handle
    dwlMessageId        [in] - Unique message ID
    Buffer              [Out] - Buffer to receive FAX_JOB_ENTRY_EX
    BufferSize          [out] - The size of Buffer

Return Value:

    Standard RPC error codes

--*/
{
    PJOB_QUEUE pJobQueue;
    ULONG_PTR Offset = 0;
    DWORD ulRet = ERROR_SUCCESS;
    BOOL bAllMessages = FALSE;
    PSID pUserSid = NULL;
    BOOL fAccess;
    DWORD dwRights;
    DWORD dwClientAPIVersion = FindClientAPIVersion(hFaxHandle);

    DEBUG_FUNCTION_NAME(TEXT("FAX_GetJobEx"));

    Assert (BufferSize);    // ref pointer in idl
    if (!Buffer)            // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    ulRet = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != ulRet)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ulRet);
        return GetServerErrorCode(ulRet);
    }

    if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT) &&
        FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
        FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH) &&
        FAX_ACCESS_QUERY_JOBS != (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the needed rights to view jobs in queue"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        bAllMessages = TRUE;
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Before Enter g_CsJob & Queue"));
    EnterCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Enter g_CsJob & Queue"));

    pJobQueue = FindJobQueueEntryByUniqueId (dwlMessageId);
    if (pJobQueue == NULL || pJobQueue->JobType == JT_BROADCAST)
    {
        //
        // dwlMessageId is not a valid queued job Id.
        //
        DebugPrintEx(DEBUG_ERR,TEXT("Invalid Parameter - not a valid job Id"));
        ulRet = FAX_ERR_MESSAGE_NOT_FOUND;
        goto Exit;
    }

    if (pJobQueue->JobType == JT_SEND)
    {
        Assert (pJobQueue->lpParentJob);
        if (pJobQueue->lpParentJob->JobStatus == JS_DELETING)
        {
            //
            // dwlMessageId is being deleted
            //
            DebugPrintEx(DEBUG_ERR,TEXT("Job is deleted - not a valid job Id"));
            ulRet = FAX_ERR_MESSAGE_NOT_FOUND;
            goto Exit;
        }
    }

    if (FALSE == bAllMessages)
    {
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            ulRet = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), ulRet);
            goto Exit;
        }

        if (!UserOwnsJob (pJobQueue, pUserSid))
        {
            DebugPrintEx(DEBUG_WRN,TEXT("UserOwnsJob failed ,Access denied"));
            ulRet = ERROR_ACCESS_DENIED;
            goto Exit;
        }
    }

    //
    // Allocate buffer memory.
    //
    if (!GetJobDataEx(NULL,
                      NULL,
                      NULL,
                      dwClientAPIVersion,
                      pJobQueue,
                      &Offset,
					  0))
    {
       ulRet = GetLastError();
       DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
       goto Exit;
    }

    *BufferSize = Offset;
    *Buffer = (LPBYTE) MemAlloc( *BufferSize );
    if (*Buffer == NULL)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("ERROR_NOT_ENOUGH_MEMORY (Server)"));
        ulRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    Offset = sizeof(FAX_JOB_STATUSW) + sizeof(FAX_JOB_ENTRY_EXW);
    if (!GetJobDataEx(*Buffer,
                      (PFAX_JOB_ENTRY_EXW)*Buffer,
                      (PFAX_JOB_STATUSW)(*Buffer + sizeof(FAX_JOB_ENTRY_EXW)),
                      dwClientAPIVersion,
                      pJobQueue,
                      &Offset,
					  *BufferSize))
    {
        ulRet = GetLastError();
        DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
        MemFree(*Buffer);
        *BufferSize =0;
    }

Exit:
    LeaveCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Release g_CsJob & g_CsQueue"));

    if (NULL != pUserSid)
    {
        MemFree (pUserSid);
    }
    return GetServerErrorCode(ulRet);

}


error_status_t
FAX_EnumJobsEx(
    IN handle_t hFaxHandle,
    IN DWORD dwJobTypes,
    OUT LPBYTE *Buffer,
    OUT LPDWORD BufferSize,
    OUT LPDWORD lpdwJobs
    )
/*++

Routine name : FAX_EnumJobsEx

Routine description:

    Fills an array of FAX_JOB_ENTR_EX of all messages with type specified in  dwJobTypes

Author:

    Oded Sacher (OdedS),    Nov, 1999

Arguments:

    hFaxHandle          [in] - Binding handle
    dwJobTypes          [in] - Specifies the job type filter
    Buffer              [out] - Buffer to receive FAX_JOB_ENTRY_EX
    BufferSize          [out] - The size of the buffer
    lpdwJobs            [out] - Number of FAX_JOB_ENTRY_EX retrieved

Return Value:

    None.

--*/
{
    PJOB_QUEUE pJobQueue;
    DWORD ulRet = ERROR_SUCCESS;
    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumJobsEx"));
    PLIST_ENTRY Next;
    DWORD rVal = 0;
    ULONG_PTR Offset = 0;
    DWORD Count = 0;
    PFAX_JOB_ENTRY_EXW pJobEntry;
    PFAX_JOB_STATUSW pFaxStatus;
    BOOL bAllMessages = FALSE;
    PSID pUserSid = NULL;
    BOOL fAccess;
    DWORD dwRights;
    DWORD dwClientAPIVersion = FindClientAPIVersion(hFaxHandle);

    Assert (BufferSize && lpdwJobs);    // ref pointer in idl
    if (!Buffer)                        // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    ulRet = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != ulRet)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    ulRet);
        return GetServerErrorCode(ulRet);
    }

    if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT) &&
        FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
        FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH) &&
        FAX_ACCESS_QUERY_JOBS != (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the needed rights to Enumerate jobs in queue"));
        return ERROR_ACCESS_DENIED;
    }

    //
    // Set bAllMessages to the right value
    //
    if (FAX_ACCESS_QUERY_JOBS == (dwRights & FAX_ACCESS_QUERY_JOBS))
    {
        bAllMessages = TRUE;
    }

    if (FALSE == bAllMessages)
    {
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            ulRet = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), ulRet);
            return GetServerErrorCode(ulRet);
        }
    }

    DebugPrintEx(DEBUG_MSG,TEXT("Before Enter g_CsJob & Queue"));
    EnterCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Enter g_CsJob & Queue"));

    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        pJobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = pJobQueue->ListEntry.Flink;

        if (pJobQueue->JobType == JT_SEND)
        {
            Assert (pJobQueue->lpParentJob);
            if (pJobQueue->lpParentJob->JobStatus == JS_DELETING)
            {
                // do not show this job
                continue;
            }
        }

        if (JT_BROADCAST != pJobQueue->JobType &&
            (pJobQueue->JobType & dwJobTypes))
        {
            if (TRUE == bAllMessages)
            {

                if (!GetJobDataEx(
                      NULL,
                      NULL,
                      NULL,
                      dwClientAPIVersion,
                      pJobQueue,
                      &Offset,
					  0))
                {
                   ulRet = GetLastError();
                   DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
                   goto Exit;
                }
                Count += 1;
            }
            else
            {
                if (UserOwnsJob (pJobQueue, pUserSid))
                {
                    if (!GetJobDataEx(
                      NULL,
                      NULL,
                      NULL,
                      dwClientAPIVersion,
                      pJobQueue,
                      &Offset,
					  0))
                    {
                       ulRet = GetLastError();
                       DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
                       goto Exit;
                    }
                    Count += 1;
                }
            }
        }
    }

    //
    // Allocate buffer memory.
    //

    *BufferSize = Offset;
    *Buffer = (LPBYTE) MemAlloc( Offset );
    if (*Buffer == NULL)
    {
        DebugPrintEx(DEBUG_ERR,TEXT("ERROR_NOT_ENOUGH_MEMORY (Server)"));
        ulRet = ERROR_NOT_ENOUGH_MEMORY;
        goto Exit;
    }

    Offset = (sizeof(FAX_JOB_ENTRY_EXW) + sizeof(FAX_JOB_STATUSW)) * Count;
    pJobEntry = (PFAX_JOB_ENTRY_EXW) *Buffer;
    pFaxStatus = (PFAX_JOB_STATUSW) (*Buffer + (sizeof(FAX_JOB_ENTRY_EXW) * Count));

    Next = g_QueueListHead.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&g_QueueListHead)
    {
        pJobQueue = CONTAINING_RECORD( Next, JOB_QUEUE, ListEntry );
        Next = pJobQueue->ListEntry.Flink;

        if (pJobQueue->JobType == JT_SEND)
        {
            Assert (pJobQueue->lpParentJob);
            if (pJobQueue->lpParentJob->JobStatus == JS_DELETING)
            {
                // do not show this job
                continue;
            }
        }

        if (JT_BROADCAST != pJobQueue->JobType &&
            (pJobQueue->JobType & dwJobTypes))
        {
            if (TRUE == bAllMessages)
            {
                if (!GetJobDataEx (*Buffer, pJobEntry, pFaxStatus, dwClientAPIVersion, pJobQueue, &Offset, *BufferSize))
                {
                    ulRet = GetLastError();
                    DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
                    goto Exit;
                }
                pJobEntry ++;
                pFaxStatus ++;
            }
            else
            {
                if (UserOwnsJob (pJobQueue, pUserSid))
                {
                    if (!GetJobDataEx (*Buffer, pJobEntry, pFaxStatus, dwClientAPIVersion, pJobQueue, &Offset, *BufferSize))
                    {
                        ulRet = GetLastError();
                        DebugPrintEx(DEBUG_ERR,TEXT("GetJobDataEx failed ,Error %ld"), ulRet);
                        goto Exit;
                    }
                    pJobEntry ++;
                    pFaxStatus ++;
                }
            }
        }
    }

    *lpdwJobs = Count;
    Assert (ERROR_SUCCESS == ulRet);

Exit:
    LeaveCriticalSectionJobAndQueue;
    DebugPrintEx(DEBUG_MSG,TEXT("After Release g_CsJob & g_CsQueue"));

    if (ERROR_SUCCESS != ulRet)
    {
        MemFree (*Buffer);
        *BufferSize = 0;
    }

    if (NULL != pUserSid)
    {
        MemFree (pUserSid);
    }

    UNREFERENCED_PARAMETER (hFaxHandle);
    return GetServerErrorCode(ulRet);
}

//********************************************
//*            FSP registration
//********************************************


error_status_t
FAX_RegisterServiceProviderEx (
    IN handle_t     hFaxHandle,
    IN LPCWSTR      lpctstrGUID,
    IN LPCWSTR      lpctstrFriendlyName,
    IN LPCWSTR      lpctstrImageName,
    IN LPCWSTR      lpctstrTspName,
    IN DWORD        dwFSPIVersion,
    IN DWORD        dwCapabilities
)
/*++

Routine name : FAX_RegisterServiceProviderEx

Routine description:

    Registers an FSP

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server - unused
    lpctstrGUID         [in] - GUID of FSP
    lpctstrFriendlyName [in] - Friendly name of FSP
    lpctstrImageName    [in] - Image name of FSP. May contain environment variables
    lpctstrTspName      [in] - TSP name of FSP.
    dwFSPIVersion       [in] - FSP's API version.
    dwCapabilities      [in] - FSP's extended capabilities.

Return Value:

    Standard RPC error code

--*/
{
    DWORD       dwRes = ERROR_SUCCESS;
    HANDLE      hFile = INVALID_HANDLE_VALUE;
    LPCWSTR     lpcwstrExpandedImage = NULL;
    BOOL        fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_RegisterServiceProviderEx"));

    Assert (lpctstrGUID && lpctstrFriendlyName && lpctstrImageName && lpctstrTspName);

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    if (MAX_FAX_STRING_LEN < lstrlen (lpctstrFriendlyName) ||
        MAX_FAX_STRING_LEN < lstrlen (lpctstrImageName) ||
        MAX_FAX_STRING_LEN < lstrlen (lpctstrTspName))
    {
        return ERROR_BUFFER_OVERFLOW;
    }

    //
    // Verify GUID format
    //
    dwRes = IsValidGUID (lpctstrGUID);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Invalid GUID (dwRes: %ld)"),
            dwRes);
        return dwRes;
    }

    //
    // Verify version field range
    //
    if (FSPI_API_VERSION_1 != dwFSPIVersion ||
        dwCapabilities)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("dwFSPIVersion invalid (0x%08x), or not valid capability (0x%08x)"),
            dwFSPIVersion,
            dwCapabilities);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Make sure the FSP isn't already registered (by it's GUID)
    //
    if (FindFSPByGUID (lpctstrGUID))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FSP with same GUID already exists (%s)"),
            lpctstrGUID);
        return ERROR_ALREADY_EXISTS;
    }
    //
    // Make sure the FSP isn't already registered (by it's TSP name)
    //
    if (FindDeviceProvider ((LPWSTR)lpctstrTspName, FALSE))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("FSP with same TSP name already exists (%s)"),
            lpctstrGUID);
        return ERROR_ALREADY_EXISTS;
    }
    //
    // Make sure the image name parameter points to a file
    //
    lpcwstrExpandedImage = ExpandEnvironmentString (lpctstrImageName);
    if (NULL == lpcwstrExpandedImage)
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error expanding image name (%s) (ec = %ld)"),
            lpctstrImageName,
            dwRes);
        return dwRes;
    }
    hFile = SafeCreateFile ( 
                         lpcwstrExpandedImage,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
    if (INVALID_HANDLE_VALUE == hFile)
    {
        //
        // Couldn't open the file
        //
        dwRes = GetLastError ();
        if (ERROR_FILE_NOT_FOUND == dwRes)
        {
            //
            // Image name (after environment expansion) doesn't exist
            //
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Image file (%s) doesn't exist"),
                lpctstrImageName);
            dwRes = ERROR_INVALID_PARAMETER;
        }
        else
        {
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("Error opening image file (%s) (ec = %ld)"),
                lpctstrImageName,
                dwRes);
        }
        goto exit;
    }
    //
    // Everything's OK - Add the new FSP to the registry
    //
    dwRes =  AddNewProviderToRegistry (lpctstrGUID,
                                       lpctstrFriendlyName,
                                       lpctstrImageName,
                                       lpctstrTspName,
                                       dwFSPIVersion);

    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("AddNewProviderToRegistry returned %ld"),
            dwRes);
        goto exit;
    }

    Assert (ERROR_SUCCESS == dwRes);

exit:
    if (INVALID_HANDLE_VALUE != hFile)
    {
        CloseHandle (hFile);
    }
    MemFree ((LPVOID)lpcwstrExpandedImage);
    return dwRes;

    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_RegisterServiceProviderEx

error_status_t
FAX_UnregisterServiceProviderEx (
    IN handle_t  hFaxHandle,
    IN LPCWSTR   lpctstrGUID
)
/*++

Routine name : FAX_UnregisterServiceProviderEx

Routine description:

    Unregisters an FSP

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle          [in] - Handle to fax server - unused
    lpctstrGUID         [in] - GUID of FSP
                                (or provider name for legacy FSPs registered
                                 through FaxRegisterServiceProvider)

Return Value:

    Standard RPC error code

--*/
{
    DWORD            dwRes = ERROR_SUCCESS;
    BOOL             fAccess;
    DEBUG_FUNCTION_NAME(TEXT("FAX_UnregisterServiceProviderEx"));

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (lpctstrGUID);
    //
    // Remove the FSP from registry
    //
    return RemoveProviderFromRegistry (lpctstrGUID);

    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_UnregisterServiceProviderEx

//********************************************
//*     Routing Extension unregistration
//********************************************

//
// Registration of routing extensions is local (non-RPC)
//
error_status_t
FAX_UnregisterRoutingExtension (
    IN handle_t  hFaxHandle,
    IN LPCWSTR   lpctstrExtensionName
)
/*++

Routine name : FAX_UnregisterRoutingExtension

Routine description:

    Unregisters a routing extension

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle              [in] - Handle to fax server - unused
    lpctstrExtensionName    [in] - Unique name of routing extension.
                                   This is the actual registry key.

Return Value:

    Standard RPC error code

--*/
{
    DWORD            dwRes = ERROR_SUCCESS;
    BOOL             fAccess;
    HKEY             hKey = NULL;
    DWORD            dw;
    DEBUG_FUNCTION_NAME(TEXT("FAX_UnregisterRoutingExtension"));

    //
    // Access check
    //
    dwRes = FaxSvcAccessCheck (FAX_ACCESS_MANAGE_CONFIG, &fAccess, NULL);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    dwRes);
        return dwRes;
    }

    if (FALSE == fAccess)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("The user does not have the FAX_ACCESS_MANAGE_CONFIG right"));
        return ERROR_ACCESS_DENIED;
    }

    Assert (lpctstrExtensionName);
    //
    // Remove the routing extension from registry
    //
    dwRes = RegOpenKeyEx (HKEY_LOCAL_MACHINE, REGKEY_ROUTING_EXTENSION_KEY, 0, KEY_READ | KEY_WRITE, &hKey);
    if (ERROR_SUCCESS != dwRes)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error opening extensions key (ec = %ld)"),
            dwRes);
        return dwRes;
    }
    //
    // Delete (recursively) the extension's key and subkeys.
    //
    if (!DeleteRegistryKey (hKey, lpctstrExtensionName))
    {
        dwRes = GetLastError ();
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error deleting extension key ( %s ) (ec = %ld)"),
            lpctstrExtensionName,
            dwRes);
    }
    dw = RegCloseKey (hKey);
    if (ERROR_SUCCESS != dw)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Error closing extensions key (ec = %ld)"),
            dw);
    }
    return dwRes;
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_UnregisterRoutingExtension


//********************************************
//*               Archive jobs
//********************************************

error_status_t
FAX_StartMessagesEnum (
    IN  handle_t                   hFaxHandle,
    IN  FAX_ENUM_MESSAGE_FOLDER    Folder,
    OUT PRPC_FAX_MSG_ENUM_HANDLE   lpHandle
)
/*++

Routine name : FAX_StartMessagesEnum

Routine description:

    A fax client application calls the FAX_StartMessagesEnum
    function to start enumerating messages in one of the archives

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hFaxHandle      [in ] - Specifies a fax server handle returned by a call
                            to the FaxConnectFaxServer function.

    Folder          [in ] - The type of the archive where the message resides.
                            FAX_MESSAGE_FOLDER_QUEUE is an invalid
                            value for this parameter.

    lpHandle        [out] - Points to an enumeration handle return value.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t   Rval = ERROR_SUCCESS;
    WIN32_FIND_DATA  FileFindData;
    HANDLE           hFileFind = INVALID_HANDLE_VALUE;
    BOOL             bAllMessages = FALSE;
    PSID             pUserSid = NULL;
    LPWSTR           lpwstrCallerSID = NULL;
	WCHAR            wszSearchPattern[MAX_PATH] = {0};
    WCHAR            wszArchiveFolder [MAX_PATH];
    PHANDLE_ENTRY    pHandleEntry;
    BOOL             fAccess;
    DWORD            dwRights;
    DEBUG_FUNCTION_NAME(TEXT("FAX_StartMessagesEnum"));

    Assert (lpHandle);
    if ((FAX_MESSAGE_FOLDER_INBOX != Folder) &&
        (FAX_MESSAGE_FOLDER_SENTITEMS != Folder))
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad folder specified (%ld)"),
            Folder);
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Access check
    //
    Rval = FaxSvcAccessCheck (MAXIMUM_ALLOWED, &fAccess, &dwRights);
    if (ERROR_SUCCESS != Rval)
    {
        DebugPrintEx(DEBUG_ERR,
                    TEXT("FaxSvcAccessCheck Failed, Error : %ld"),
                    Rval);
        return GetServerErrorCode(Rval);
    }

    if (FAX_MESSAGE_FOLDER_INBOX  == Folder)
    {
        if (FAX_ACCESS_QUERY_IN_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_IN_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to enumerate Inbox messages"));
            return ERROR_ACCESS_DENIED;
        }

        bAllMessages = TRUE;
    }
    else
    {
        if (FAX_ACCESS_SUBMIT        != (dwRights & FAX_ACCESS_SUBMIT)        &&
            FAX_ACCESS_SUBMIT_NORMAL != (dwRights & FAX_ACCESS_SUBMIT_NORMAL) &&
            FAX_ACCESS_SUBMIT_HIGH   != (dwRights & FAX_ACCESS_SUBMIT_HIGH)   &&
            FAX_ACCESS_QUERY_OUT_ARCHIVE != (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
            DebugPrintEx(DEBUG_ERR,
                        TEXT("The user does not have the needed rights to enumerate Outbox messages"));
            return ERROR_ACCESS_DENIED;
        }

        if (FAX_ACCESS_QUERY_OUT_ARCHIVE == (dwRights & FAX_ACCESS_QUERY_OUT_ARCHIVE))
        {
           bAllMessages = TRUE;
        }
    }


    EnterCriticalSection (&g_CsConfig);
    lstrcpyn (wszArchiveFolder, g_ArchivesConfig[Folder].lpcstrFolder, MAX_PATH);
    LeaveCriticalSection (&g_CsConfig);
    if (!bAllMessages)
    {
        //
        // We want only the messages of the calling user - get its SID.
        //
        pUserSid = GetClientUserSID();
        if (NULL == pUserSid)
        {
            Rval = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("GetClientUserSid failed, Error %ld"), Rval);
            return GetServerErrorCode(Rval);
        }
        if (!ConvertSidToStringSid (pUserSid, &lpwstrCallerSID))
        {
            Rval = GetLastError();
            DebugPrintEx(DEBUG_ERR,
                     TEXT("ConvertSidToStringSid failed, Error %ld"), Rval);
            goto exit;
        }
        if (0 > _snwprintf (wszSearchPattern,
                            ARR_SIZE(wszSearchPattern) -1,
                            L"%s\\%s$*.tif",
                            wszArchiveFolder,
                            lpwstrCallerSID))
        {
            //
            // We exceeded MAX_PATH characters
            //
            Rval = ERROR_BUFFER_OVERFLOW;
            DebugPrintEx(DEBUG_ERR,
                     TEXT("Search pattern exceeds MAX_PATH characters"));
            LocalFree (lpwstrCallerSID);
            goto exit;
        }

        LocalFree (lpwstrCallerSID);
    }
    else
    {
        //
        // Get all archive files
        //
        if (0 > _snwprintf (wszSearchPattern,
                            ARR_SIZE(wszSearchPattern) -1,
                            L"%s\\*.tif",
                            wszArchiveFolder))
        {
            //
            // We exceeded MAX_PATH characters
            //
            Rval = ERROR_BUFFER_OVERFLOW;
            DebugPrintEx(DEBUG_ERR,
                     TEXT("Search pattern exceeds MAX_PATH characters"));
            goto exit;
        }
    }
    //
    // Start searching the archive folder.
    // Search pattern is wszSearchPattern
    //
    hFileFind = FindFirstFile (wszSearchPattern, &FileFindData);
    if (INVALID_HANDLE_VALUE == hFileFind)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                 TEXT("FindFirstFile failed, Error %ld"), Rval);

        if (ERROR_FILE_NOT_FOUND == Rval)
        {
            Rval = ERROR_NO_MORE_ITEMS;
        }
        goto exit;
    }
    //
    // Now, create a context handle from the result
    //
    pHandleEntry = CreateNewMsgEnumHandle( hFaxHandle,
                                           hFileFind,
                                           FileFindData.cFileName,
                                           Folder
                                         );
    if (!pHandleEntry)
    {
        Rval = GetLastError();
        DebugPrintEx(DEBUG_ERR,
                 TEXT("CreateNewMsgEnumHandle failed, Error %ld"), Rval);
        goto exit;
    }

    *lpHandle = (HANDLE) pHandleEntry;

    Assert (ERROR_SUCCESS == Rval);

exit:
    if ((ERROR_SUCCESS != Rval) && (INVALID_HANDLE_VALUE != hFileFind))
    {
        //
        // Error and the search handle is still open
        //
        if (!FindClose (hFileFind))
        {
            DWORD dw = GetLastError ();
            DebugPrintEx(DEBUG_ERR,
                 TEXT("FindClose failed, Error %ld"), dw);
        }
    }
    MemFree ((LPVOID)pUserSid);
    return GetServerErrorCode(Rval);
    UNREFERENCED_PARAMETER (hFaxHandle);
}   // FAX_StartMessagesEnum

error_status_t
FAX_EndMessagesEnum (
    IN OUT LPHANDLE  lpHandle
)
/*++

Routine name : FAX_EndMessagesEnum

Routine description:

    A fax client application calls the FAX_EndMessagesEnum function to stop
    enumerating messages in one of the archives.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpHandle    [in] - The enumeration handle value.
                       This value is obtained by calling FAX_StartMessagesEnum.

Return Value:

    Standard RPC error code

--*/
{    
    DEBUG_FUNCTION_NAME(TEXT("FAX_EndMessagesEnum"));

    if (NULL == *lpHandle)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("NULL Context handle"));
        return ERROR_INVALID_PARAMETER;
    }

    CloseFaxHandle( (PHANDLE_ENTRY) *lpHandle );    
    *lpHandle = NULL;    
    return ERROR_SUCCESS;
}   // FAX_EndMessagesEnum

VOID
RPC_FAX_MSG_ENUM_HANDLE_rundown(
    IN HANDLE FaxMsgEnumHandle
    )
/*++

Routine name : RPC_FAX_MSG_ENUM_HANDLE_rundown

Routine description:

    The RPC rundown function of the message enumeration handle.
    This function is called if the client abruptly disconnected on us.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    FaxMsgEnumHandle            [in] - Message enumeration handle.

Return Value:

    None.

--*/
{
    PHANDLE_ENTRY pHandleEntry = (PHANDLE_ENTRY) FaxMsgEnumHandle;
    DEBUG_FUNCTION_NAME(TEXT("RPC_FAX_MSG_ENUM_HANDLE_rundown"));

    DebugPrintEx(
        DEBUG_WRN,
         TEXT("RPC_FAX_MSG_ENUM_HANDLE_rundown: handle = 0x%08x"),
         FaxMsgEnumHandle);   
    CloseFaxHandle( pHandleEntry );
    return;
}   // RPC_FAX_MSG_ENUM_HANDLE_rundown

static
DWORD
RetrieveMessage (
    LPCWSTR                 lpcwstrFileName,
    FAX_ENUM_MESSAGE_FOLDER Folder,
    PFAX_MESSAGE           *ppFaxMsg
)
/*++

Routine name : RetrieveMessage

Routine description:

    Allocates and reads a message from the archive.
    To free the message call FreeMessageBuffer () on the returned message.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpcwstrFileName     [in ] - Name (not full path) of the file
                                containing the message to retrieve.

    Folder              [in ] - Archive folder where the message resides.


    ppFaxMsg            [out] - Pointer to a message buffer to allocate.

Return Value:

    Standard Win32 error code.

--*/
{
    DWORD dwRes = ERROR_SUCCESS;
	WCHAR wszMsgFile [MAX_PATH] = {0};
    DEBUG_FUNCTION_NAME(TEXT("RetrieveMessage"));

    EnterCriticalSection (&g_CsConfig);
    int iRes = _snwprintf (wszMsgFile,
                           ARR_SIZE(wszMsgFile) -1,
                           L"%s\\%s",
                           g_ArchivesConfig[Folder].lpcstrFolder,
                           lpcwstrFileName
                          );
    LeaveCriticalSection (&g_CsConfig);
    if (0 > iRes)
    {
        //
        // We exceeded MAX_PATH characters
        //
        DebugPrintEx(DEBUG_ERR,
                 TEXT("Search pattern exceeds MAX_PATH characters"));
        return ERROR_BUFFER_OVERFLOW;
    }
    *ppFaxMsg = (PFAX_MESSAGE) MemAlloc (sizeof (FAX_MESSAGE));
    if (NULL == *ppFaxMsg)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Cannot allocate memory for a FAX_MESSAGE structure"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!GetMessageNTFSStorageProperties (wszMsgFile, *ppFaxMsg))
    {
        if(!GetMessageMsTags (wszMsgFile, *ppFaxMsg))
        {
            dwRes = GetLastError ();
            DebugPrintEx( DEBUG_ERR,
                          TEXT("GetMessageNTFSStorageProperties returned error %ld"),
                          dwRes);
            goto exit;
        }
    }

exit:
    if (ERROR_SUCCESS != dwRes)
    {
        MemFree (*ppFaxMsg);
        *ppFaxMsg = NULL;
    }
    return dwRes;
}   // RetrieveMessage


VOID
FreeMessageBuffer (
    PFAX_MESSAGE pFaxMsg,
    BOOL fDestroy
)
/*++

Routine name : FreeMessageBuffer

Routine description:

    Frees a previously allocated message buffer.
    The allocated message was created by calling RetrieveMessage().

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    pFaxMsg         [in] - Message to free
    fDestroy        [in] - Free structure

Return Value:

    None.

--*/
{
    DEBUG_FUNCTION_NAME(TEXT("FreeMessageBuffer"));
    MemFree ((LPVOID)pFaxMsg->lpctstrRecipientNumber);
    MemFree ((LPVOID)pFaxMsg->lpctstrRecipientName);
    MemFree ((LPVOID)pFaxMsg->lpctstrSenderNumber);
    MemFree ((LPVOID)pFaxMsg->lpctstrSenderName);
    MemFree ((LPVOID)pFaxMsg->lpctstrTsid);
    MemFree ((LPVOID)pFaxMsg->lpctstrCsid);
    MemFree ((LPVOID)pFaxMsg->lpctstrSenderUserName);
    MemFree ((LPVOID)pFaxMsg->lpctstrBillingCode);
    MemFree ((LPVOID)pFaxMsg->lpctstrDeviceName);
    MemFree ((LPVOID)pFaxMsg->lpctstrDocumentName);
    MemFree ((LPVOID)pFaxMsg->lpctstrSubject);
    MemFree ((LPVOID)pFaxMsg->lpctstrCallerID);
    MemFree ((LPVOID)pFaxMsg->lpctstrRoutingInfo);
    MemFree ((LPVOID)pFaxMsg->lpctstrExtendedStatus);

    if (fDestroy)
    {
        MemFree ((LPVOID)pFaxMsg);
    }

}   // FreeMessageBuffer

static
VOID
SerializeMessage (
    LPBYTE          lpBuffer,
    PULONG_PTR      Offset,
    DWORD           dwClientAPIVersion,
    DWORD           dwMsgIndex,
    PFAX_MESSAGE    pMsg,
	DWORD           dwBufferSize)
/*++

Routine name : SerializeMessage

Routine description:

    Stores a FAX_MESSAGE in an RPC serialized manner into a buffer.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    lpBuffer        [in    ] - Pointer to buffer head.
                               If this value is NULL, no serialization is done.
                               Only the pupOffset value gets advanced by the total
                               size required to store the strings in the message
                               (but not the FAX_MESSAGE structure itself).

    Offset          [in/out] - Pointer to a ULONG_PTR specifying the next variable
                               length part of the buffer.

    dwClientAPIVersion  [in] - API version of the client

    dwMsgIndex      [in    ] - The 0-based index of the message to store
                               within the buffer

    pMsg            [in    ] - Source message to store

	dwBufferSize    [in    ] - Size of the buffer lpBuffer, in bytes.
                               This parameter is used only if Buffer is not NULL.

Return Value:
   None.

--*/
{
    Assert (pMsg);
    DEBUG_FUNCTION_NAME(TEXT("SerializeMessage"));
    PFAX_MESSAGE pDstMsg = (PFAX_MESSAGE)&(lpBuffer[sizeof (FAX_MESSAGE) * dwMsgIndex]);

    if (lpBuffer)
    {
        if (FAX_API_VERSION_1 > dwClientAPIVersion)
        {
            //
            // Clients that use API version 0 can't handle JS_EX_CALL_COMPLETED and JS_EX_CALL_ABORTED
            //
            if (FAX_API_VER_0_MAX_JS_EX < pMsg->dwExtendedStatus)
            {
                //
                // Turn off the extended status field
                //
                pMsg->dwExtendedStatus = 0;
                pMsg->dwValidityMask &= ~FAX_JOB_FIELD_STATUS_EX;
            }
        }
        //
        // Copy message structure first
        //
        memcpy (pDstMsg,
                pMsg,
                sizeof (FAX_MESSAGE));
    }
    //
    // Serialize strings
    //
    StoreString (pMsg->lpctstrRecipientNumber,
                 (PULONG_PTR)&pDstMsg->lpctstrRecipientNumber,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrRecipientName,
                 (PULONG_PTR)&pDstMsg->lpctstrRecipientName,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrSenderNumber,
                 (PULONG_PTR)&pDstMsg->lpctstrSenderNumber,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrSenderName,
                 (PULONG_PTR)&pDstMsg->lpctstrSenderName,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrTsid,
                 (PULONG_PTR)&pDstMsg->lpctstrTsid,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrCsid,
                 (PULONG_PTR)&pDstMsg->lpctstrCsid,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrSenderUserName,
                 (PULONG_PTR)&pDstMsg->lpctstrSenderUserName,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrBillingCode,
                 (PULONG_PTR)&pDstMsg->lpctstrBillingCode,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrDeviceName,
                 (PULONG_PTR)&pDstMsg->lpctstrDeviceName,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrDocumentName,
                 (PULONG_PTR)&pDstMsg->lpctstrDocumentName,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrSubject,
                 (PULONG_PTR)&pDstMsg->lpctstrSubject,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrCallerID,
                 (PULONG_PTR)&pDstMsg->lpctstrCallerID,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrRoutingInfo,
                 (PULONG_PTR)&pDstMsg->lpctstrRoutingInfo,
                 lpBuffer,
                 Offset,
				 dwBufferSize);
    StoreString (pMsg->lpctstrExtendedStatus,
                 (PULONG_PTR)&pDstMsg->lpctstrExtendedStatus,
                 lpBuffer,
                 Offset,
				 dwBufferSize);

}   // SerializeMessage


error_status_t
FAX_EnumMessages(
   IN     RPC_FAX_MSG_ENUM_HANDLE hEnum,
   IN     DWORD                   dwNumMessages,
   IN OUT LPBYTE                 *lppBuffer,
   IN OUT LPDWORD                 lpdwBufferSize,
   OUT    LPDWORD                 lpdwNumMessagesRetrieved
)
/*++

Routine name : FAX_EnumMessages

Routine description:

    A fax client application calls the FAX_EnumMessages function to enumerate
    messages in one of the archives.

    This function is incremental. That is, it uses an internal context cursor to
    point to the next set of messages to retrieve for each call.

    The cursor is set to point to the begging of the messages in the archive after a
    successful call to FAX_StartMessagesEnum.

    Each successful call to FAX_EnumMessages advances the cursor by the number of
    messages retrieved.

    Once the cursor reaches the end of the enumeration,
    the function fails with ERROR_NO_MORE_ITEMS error code.
    The FAX_EndMessagesEnum function should be called then.

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    hEnum                       [in ] - The enumeration handle value.
                                        This value is obtained by calling
                                        FAX_StartMessagesEnum.

    dwNumMessages               [in ] - A DWORD value indicating the maximal number
                                        of messages the caller requires to enumerate.
                                        This value cannot be zero.

    lppBuffer                   [out] - A pointer to a buffer of FAX_MESSAGE structures.
                                        This buffer will contain lpdwReturnedMsgs entries.
                                        The buffer will be allocated by the function
                                        and the caller must free it.

    lpdwBufferSize              [out] - The size (in bytes) of the lppBuffer buffer.

    lpdwNumMessagesRetrieved    [out] - Pointer to a DWORD value indicating the actual
                                        number of messages retrieved.
                                        This value cannot exceed dwNumMessages.

Return Value:

    Standard RPC error code

--*/
{
    error_status_t  Rval = ERROR_SUCCESS;
    DWORD           dw;
    DWORD_PTR       dwOffset;
    PFAX_MESSAGE   *pMsgs = NULL;
    DWORD           dwClientAPIVersion;
    PHANDLE_ENTRY   pHandle = (PHANDLE_ENTRY)hEnum;

    DEBUG_FUNCTION_NAME(TEXT("FAX_EnumMessages"));

    dwClientAPIVersion = pHandle->dwClientAPIVersion;

    Assert (lpdwBufferSize && lpdwNumMessagesRetrieved);    // ref pointer in idl
    if (!lppBuffer)                                         // unique pointer in idl
    {
        return ERROR_INVALID_PARAMETER;
    }
    if (NULL == hEnum)
    {
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("NULL context handle"));
        return ERROR_INVALID_PARAMETER;
    }
    Assert ((INVALID_HANDLE_VALUE != pHandle->hFile));
    if (!dwNumMessages)
    {
        return ERROR_INVALID_PARAMETER;
    }
    //
    // Create array of dwNumMessages pointers to FAX_MESSAGE structures and NULLify it.
    //
    pMsgs = (PFAX_MESSAGE *) MemAlloc (sizeof (PFAX_MESSAGE) * dwNumMessages);
    if (!pMsgs)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Cannot allocate memory for a PFAX_MESSAGE array [%ld]"),
                      dwNumMessages);
        return FAX_ERR_SRV_OUTOFMEMORY;
    }
    memset (pMsgs, 0, sizeof (PFAX_MESSAGE) * dwNumMessages);
    //
    // Next, start collecting messages into the array.
    // Stop when dwNumMessages is reached or no more messages are available.
    //
    *lpdwBufferSize = 0;
    *lpdwNumMessagesRetrieved = 0;
    while ((*lpdwNumMessagesRetrieved) < dwNumMessages)
    {
        DWORD_PTR       dwMsgSize = sizeof (FAX_MESSAGE);
        LPWSTR          lpwstrFileToRetrieve;
        WIN32_FIND_DATA FindData;

        if (lstrlen (pHandle->wstrFileName))
        {
            //
            // This is the first file in an enumeration session
            //
            lpwstrFileToRetrieve = pHandle->wstrFileName;
        }
        else
        {
            //
            // Find next file using the find file handle
            //
            if (!FindNextFile (pHandle->hFile, &FindData))
            {
                Rval = GetLastError ();
                if (ERROR_NO_MORE_FILES == Rval)
                {
                    //
                    // This is not a real error - just the end of files.
                    // Break the loop.
                    //
                    Rval = ERROR_SUCCESS;
                    break;
                }
                DebugPrintEx( DEBUG_ERR,
                              TEXT("FindNextFile returned error %ld"),
                              Rval);
                goto exit;
            }
            lpwstrFileToRetrieve = FindData.cFileName;
        }
        //
        // Get the message now from lpwstrFileToRetrieve
        //
        Rval = RetrieveMessage (lpwstrFileToRetrieve,
                                pHandle->Folder,
                                &(pMsgs[*lpdwNumMessagesRetrieved]));
        if (ERROR_SUCCESS != Rval)
        {
            DebugPrintEx( DEBUG_ERR,
                          TEXT("RetrieveMessage returned error %ld"),
                          Rval);

            if (ERROR_NOT_ENOUGH_MEMORY != Rval && ERROR_OUTOFMEMORY != Rval)
            {
                //
                //  The error is related to the Message itself.
                //  This will not stop us from searching the rest of the messages.
                //

                //
                // Mark (in the enumeration handle) the fact that the first file was read.
                //
                lstrcpy (pHandle->wstrFileName, L"");
                continue;
            }
            goto exit;
        }
        //
        // Mark (in the enumeration handle) the fact that the first file was read.
        //
        lstrcpy (pHandle->wstrFileName, L"");
        //
        // Get the size of the retrieved message
        //
        SerializeMessage (NULL, &dwMsgSize, dwClientAPIVersion, 0, pMsgs[*lpdwNumMessagesRetrieved],0);

        *lpdwBufferSize += (DWORD)dwMsgSize;
        (*lpdwNumMessagesRetrieved)++;
    }   // End of enumeration loop

    if (0 == *lpdwNumMessagesRetrieved)
    {
        //
        // No file(s) retrieved
        //
        *lppBuffer = NULL;
        Assert (0 == *lpdwBufferSize);
        Rval = ERROR_NO_MORE_ITEMS;
        goto exit;
    }
    //
    // Allocate return buffer
    //
    *lppBuffer = (LPBYTE) MemAlloc (*lpdwBufferSize);
    if (!*lppBuffer)
    {
        DebugPrintEx( DEBUG_ERR,
                      TEXT("Cannot allocate memory for return buffer (%ld bytes)"),
                      *lpdwBufferSize);
        Rval = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }
    //
    // Place all messages in the return buffer
    //
    dwOffset = sizeof(FAX_MESSAGE) * (*lpdwNumMessagesRetrieved);
    for (dw = 0; dw < *lpdwNumMessagesRetrieved; dw++)
    {
        //
        // Store retrieved message in return buffer
        //
        SerializeMessage (*lppBuffer, &dwOffset, dwClientAPIVersion, dw, pMsgs[dw], *lpdwBufferSize);
    }
    Assert (dwOffset == *lpdwBufferSize);
    Assert (ERROR_SUCCESS == Rval);

exit:

    //
    // Free local array of messages
    //
    for (dw = 0; dw < dwNumMessages; dw++)
    {
        if (NULL != pMsgs[dw])
        {
            FreeMessageBuffer (pMsgs[dw], TRUE);
        }
    }
    //
    // Free array of message pointers
    //
    MemFree (pMsgs);
    return GetServerErrorCode(Rval);
}   // FAX_EnumMessages

static
DWORD
FindArchivedMessage (
    FAX_ENUM_MESSAGE_FOLDER IN  Folder,
    DWORDLONG               IN  dwlMsgId,
    BOOL                    IN  bAllMessages,
    LPWSTR                  OUT lpwstrFileName,
    DWORD                   IN  cchFileName,
    LPWSTR                  OUT lpwstrFilePath,
    DWORD                   IN  cchFilePath
)
/*++

Routine name : FindArchivedMessage

Routine description:

    Finds the file containing the message in an archive

Author:

    Eran Yariv (EranY), Dec, 1999

Arguments:

    Folder          [in ] - Archive / queue folder
    dwlMessageId    [in ] - Unique message id
    bAllMessages    [in ] - TRUE if the caller is allowed to view all messages
    lpwstrFileName  [out] - Optional. If not NULL, will contain the file name
                            and extension of the archive message file.
    cchFileName     [in]  - Length, in TCHARs, of lpwstrFileName
    lpwstrFilePath  [out] - Optional. If not NULL, will contain the full path
                            of the archive message file.
    cchFilePath     [in]  - Length, in TCHARs, of lpwstrFilePath

Return Value:

    Standard RPC error code

--*/
{
    WCHAR           wszArchiveFolder[MAX_PATH * 2] = {0};
    DWORD           dwRes = ERROR_SUCCESS;
    LPWSTR          lpwstrResultFullPath;
    HRESULT         hr;
    DEBUG_FUNCTION_NAME(TEXT("FindArchivedMessage"));

    EnterCriticalSection (&g_CsConfig);
    hr = StringCchCopy (wszArchiveFolder, ARR_SIZE(wszArchiveFolder), g_ArchivesConfig[Folder].lpcstrFolder);
    if (FAILED(hr))
    {
        ASSERT_FALSE;
        DebugPrintEx(DEBUG_ERR,
                        TEXT("StringCchCopy failed with 0x%08x"),
                        hr);
        LeaveCriticalSection (&g_CsConfig);                        
        return HRESULT_CODE(hr);
    }
    LeaveCriticalSection (&g_CsConfig);

    if (FAX_MESSAGE_FOLDER_INBOX == Folder)
    {
        Assert (TRUE == bAllMessages);
        //
        // Get full name of Inbox archive file
        //
        lpwstrResultFullPath = GetRecievedMessageFileName (dwlMsgId);
        if (!lpwstrResultFullPath)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetRecievedMessageFileName Failed, Error %ld"), dwRes);
            return dwRes;
        }
    }
    else if (FAX_MESSAGE_FOLDER_SENTITEMS == Folder)
    {
        //
        // Get full name of sent items archive file
        //
        PSID             pUserSid = NULL;

        if (!bAllMessages)
        {
            //
            // If the user doesn't have the right to view all messages
            //
            // Get SID of caller
            //
            pUserSid = GetClientUserSID();
            if (NULL == pUserSid)
            {
                dwRes = GetLastError();
                DebugPrintEx(DEBUG_ERR,
                         TEXT("GetClientUserSid failed, Error %ld"), dwRes);
                return dwRes;
            }
        }
        //
        // Get full name of sent items archive file
        //
        lpwstrResultFullPath = GetSentMessageFileName (dwlMsgId, pUserSid);
        if (!lpwstrResultFullPath)
        {
            dwRes = GetLastError ();
            DebugPrintEx(
                DEBUG_ERR,
                TEXT("GetSentMessageFileName Failed, Error %ld"), dwRes);
            MemFree ((LPVOID)pUserSid);
            return dwRes;
        }
        MemFree ((LPVOID)pUserSid);
    }
    else
    {
        //
        // We don't support any other archive type
        //
        DebugPrintEx(
            DEBUG_ERR,
            TEXT("Bad archive folder type %ld"), Folder);
        ASSERT_FALSE;
    }
    if (lpwstrFilePath)
    {
        //
        // Copy full path back to caller
        //
        hr = StringCchCopy (lpwstrFilePath, cchFilePath, lpwstrResultFullPath);
        if (FAILED(hr))
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("StringCchCopy failed with 0x%08x"),
                         hr);
            dwRes = HRESULT_CODE(hr);
            goto exit;
        }
    }
    if (lpwstrFileName)
    {
        WCHAR wszExt[MAX_PATH];
        WCHAR wszFileName[MAX_PATH * 2];
        //
        // Split just the file name back to the caller (optional)
        //
        _wsplitpath (lpwstrResultFullPath, NULL, NULL, wszFileName, wszExt);
        hr = StringCchPrintf (lpwstrFileName, cchFileName, TEXT("%s%s"), wszFileName, wszExt);
        if (FAILED(hr))
        {
            DebugPrintEx(DEBUG_ERR,
                         TEXT("StringCchCopy failed with 0x%08x"),
                         hr);
            dwRes = HRESULT_CODE