   Sets the auto cursor to its ON state

    HISTORY:
        rustanl     12-Mar-1991     created

********************************************************************/

VOID AUTO_CURSOR::TurnOn()
{
    if ( ! _fState )
    {
        Set( _hOnCursor );
        if ( _cCurs >= 0 )
        {
            Show( TRUE );
        }
        _fState = TRUE;
    }
}


/*******************************************************************

    NAME:       AUTO_CURSOR::TurnOff

    SYNOPSIS:   Sets the auto cursor to its OFF state

    HISTORY:
        rustanl     12-Mar-1991     created

********************************************************************/

VOID AUTO_CURSOR::TurnOff()
{
    if ( _fState )
    {
        Set( _hOffCursor );
        if ( _cCurs >= 0 )
        {
            Show( FALSE );
        }
        _fState = FALSE;
    }
}


/*******************************************************************

    NAME:       ACCELTABLE::ACCELTABLE

    SYNOPSIS:   From resource, construct an accelerator table

    ENTRY:      pszResourceName - pointer to resource name

    EXIT:       Table loaded from file

    HISTORY:
        beng        09-Jul-1991 Created
        rustanl     29-Aug-1991 Ct now takes const TCHAR *
        beng        03-Aug-1992 Uses IDRESOURCE; dllization

********************************************************************/

ACCELTABLE::ACCELTABLE( const IDRESOURCE & idrsrc )
    : _hAccTable(0)
{
    HMODULE hmod = BLT::CalcHmodRsrc(idrsrc);

    HACCEL h = (HACCEL)::LoadAccelerators( hmod, idrsrc.QueryPsz() );
    if (h == NULL)
    {
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    _hAccTable = h;
}


/*******************************************************************

    NAME:       ACCELTABLE::~ACCELTABLE

    SYNOPSIS:   Destroy an accelerator table

    ENTRY:      Instance of table object

    EXIT:       Table unloaded

    HISTORY:
        beng        09-Jul-1991     Created

********************************************************************/

ACCELTABLE::~ACCELTABLE()
{
    if (_hAccTable)
        ::FreeResource( (HGLOBAL)_hAccTable );
}


/*******************************************************************

    NAME:       ACCELTABLE::QueryHandle

    SYNOPSIS:   Return Win handle to table, for Win APIs

    RETURNS:    HANDLE

    HISTORY:
        beng        09-Jul-1991     Created

********************************************************************/

HACCEL ACCELTABLE::QueryHandle() const
{
    return _hAccTable;
}


/*******************************************************************

    NAME:       ACCELTABLE::Translate

    SYNOPSIS:   Translate a window's accelerators

    ENTRY:      pwnd - pointer to window in question
                pmsg - message, hot off of the Windows queue

    EXIT:       If accelerator, xlated appropriately

    RETURNS:    TRUE if it ate the message

    HISTORY:
        beng        09-Jul-1991     Created

********************************************************************/

BOOL ACCELTABLE::Translate( const WINDOW* pwnd, MSG* pmsg ) const
{
    return ::TranslateAccelerator(pwnd->QueryHwnd(),
                                  _hAccTable,
                                  (LPMSG)pmsg );
}


/*******************************************************************

    NAME:       SOLID_BRUSH::SOLID_BRUSH

    SYNOPSIS:   SOLID_BRUSH constructor

    ENTRY:      iSolidBrush -   Specifies the Windows-defined
                                index of the solid brush

    HISTORY:
        rustanl     22-Jul-1991 Created
        beng        06-Nov-1991 uses MapLastError

********************************************************************/

SOLID_BRUSH::SOLID_BRUSH( INT iSolidBrush )
    :   _hbrush( ::CreateSolidBrush( ::GetSysColor( iSolidBrush )))
{
    if ( QueryError() != NERR_Success )
        return;

    if ( _hbrush == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }
}


/*******************************************************************

    NAME:       SOLID_BRUSH::~SOLID_BRUSH

    SYNOPSIS:   SOLID_BRUSH destructor

    HISTORY:
        rustanl     22-Jul-1991     Created

********************************************************************/

SOLID_BRUSH::~SOLID_BRUSH()
{
    if ( _hbrush != NULL )
        ::DeleteObject( (HGDIOBJ)_hbrush );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltorder.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltorder.cxx
        Use the up and down button to move the listbox's items up and down

    FILE HISTORY:
        terryk  28-Jan-1992     Created
*/
#include "pchblt.hxx"   // Precompiled header

/*******************************************************************

    NAME:       ORDER_GROUP::ORDER_GROUP

    SYNOPSIS:   constructor - associate all the controls to this group

    ENTRY:      STRING_LISTBOX *plcList - listbox control
                BUTTON_CONTROL *pbcUp - Up button
                BUTTON_CONTROL *pbcDown - down button
                CONTROL_GROUP *pgroupOwner - owner group

    HISTORY:
                terryk  29-Mar-1992     Created

********************************************************************/

ORDER_GROUP::ORDER_GROUP(
        STRING_LISTBOX * plcList,
        BUTTON_CONTROL * pbcUp,
        BUTTON_CONTROL * pbcDown,
        CONTROL_GROUP *pgroupOwner )
    : CONTROL_GROUP( pgroupOwner ),
    _plcList( plcList ),
    _pbcUp( pbcUp ),
    _pbcDown( pbcDown )
{
    _plcList->SetGroup( this );
    _pbcUp->SetGroup( this );
    _pbcDown->SetGroup( this );
}

/*******************************************************************

    NAME:       ORDER_GROUP::OnUserAction

    SYNOPSIS:   move the listbox item up and down

    ENTRY:      CONTROL_WINDOW * pcw - control window which received the action
                const CONTROL_EVENT & e - action

    RETURNS:    APIERR - NERR_Success if okay

    HISTORY:
                terryk  29-Mar-1992     Created

********************************************************************/

APIERR ORDER_GROUP::OnUserAction( CONTROL_WINDOW * pcw, const CONTROL_EVENT & e )
{
    INT nCurrentSel;
    NLS_STR nlsSelect;

    CID cid = pcw->QueryCid();

    if ( cid == _pbcUp->QueryCid() )
    {
        if (( e.QueryCode() == BN_CLICKED ) ||
            ( e.QueryCode() == BN_DOUBLECLICKED ))
        {
            // Move an item up

            UIASSERT( _plcList->QuerySelCount() == 1 );

            nCurrentSel = _plcList->QueryCurrentItem();
            _plcList->QueryItemText( &nlsSelect, nCurrentSel );
            _plcList->DeleteItem( nCurrentSel );
            _plcList->InsertItem( nCurrentSel - 1, nlsSelect );
            _plcList->SelectItem( nCurrentSel - 1 );
            SetButton();
        }
    }
    else if ( cid == _pbcDown->QueryCid() )
    {
        if (( e.QueryCode() == BN_CLICKED ) ||
            ( e.QueryCode() == BN_DOUBLECLICKED ))
        {
            // move an item down

            UIASSERT( _plcList->QuerySelCount() == 1 );

            nCurrentSel = _plcList->QueryCurrentItem();
            _plcList->QueryItemText( &nlsSelect, nCurrentSel );
            _plcList->DeleteItem( nCurrentSel );
            _plcList->InsertItem( nCurrentSel + 1, nlsSelect );
            _plcList->SelectItem( nCurrentSel + 1 );
            SetButton();
        }
    }
    else if ( cid == _plcList->QueryCid() )
    {
        // reset button status
        if ( e.QueryCode() == LBN_SELCHANGE )
            SetButton();
    }
    return NERR_Success;
}


/*******************************************************************

    NAME:       ORDER_GROUP::SetButton

    SYNOPSIS:   Reset the button status

    HISTORY:
                terryk  29-Mar-1992     Created

********************************************************************/

VOID ORDER_GROUP::SetButton()
{
    BOOL fpbcUpHasFocus   = _pbcUp->HasFocus();
    BOOL fpbcDownHasFocus = _pbcDown->HasFocus();
    if ( _plcList->QuerySelCount() != 1 )
    {
        _pbcUp->Enable( FALSE );
        _pbcDown->Enable( FALSE );
    }
    else
    {
        _pbcUp->Enable( _plcList->QueryCurrentItem() != 0 );
        _pbcDown->Enable( _plcList->QueryCurrentItem() < ( _plcList->QueryCount() - 1 ));
    }

    // set the focus to the buttons or the listbox.

    BOOL fpbcUpEnabled = _pbcUp->IsEnabled();
    BOOL fpbcDownEnabled = _pbcDown->IsEnabled();

    if ( fpbcUpHasFocus && !fpbcUpEnabled)
    {
        if ( fpbcDownEnabled )
        {
            _pbcDown->ClaimFocus();
        }
        else
        {
            _plcList->ClaimFocus();
        }
    } else if ( fpbcDownHasFocus && !fpbcDownEnabled )
    {
        if ( fpbcUpEnabled )
        {
            _pbcUp->ClaimFocus();
        }
        else
        {
            _plcList->ClaimFocus();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltmitem.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltmitem.cxx
    MENUITEM implementation


    FILE HISTORY:
	rustanl     11-Jul-1991     Created
	rustanl     12-Jul-1991     Added to BLT
	rustanl     15-Jul-1991     Code review changes (change
				    CLIENT_WINDOW * to APP_WINDOW *)
				    CR attended by BenG, ChuckC,
				    Hui-LiCh, TerryK, RustanL.
	terryk	    27-Nov-1991	    Added SetText for MENUITEM

*/
#include "pchblt.hxx"   // Precompiled header


/*******************************************************************

    NAME:	MENUITEM::MENUITEM

    SYNOPSIS:	MENUITEM constructor

    ENTRY:	pawin - 	Pointer to APP_WINDOW which owns
				the menu
		mid -		Menu item ID

    HISTORY:
	rustanl     11-Jul-1991 Created
	beng	    31-Oct-1991 Added protected ctor taking raw hmenu,
				for derived classes

********************************************************************/

MENUITEM::MENUITEM( APP_WINDOW * pawin, MID mid )
    : _hmenu( ::GetMenu( pawin->QueryHwnd() )),
      _mid( mid )
{
    if ( QueryError() != NERR_Success )
	return;

    if ( _hmenu == NULL )
    {
	DBGEOL( SZ("MENUITEM ct: Cannot find menu") );
	ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
	return;
    }
}


MENUITEM::MENUITEM( HMENU hmenu, MID mid )
    : _hmenu(hmenu),
      _mid(mid)
{
    if ( QueryError() != NERR_Success )
	return;

    if ( _hmenu == NULL )
    {
	DBGEOL( SZ("MENUITEM ct: given null _hmenu") );
	ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
	return;
    }
}


/*******************************************************************

    NAME:	MENUITEM::Enable

    SYNOPSIS:	Enables or disables a menu item

    ENTRY:	f -	TRUE to enable menu item
			FALSE to disable menu item

    EXIT:	Menu item is enabled or disabled, as requested

    HISTORY:
	rustanl     11-Jul-1991     Created
	rustanl     05-Sep-1991     Added MF_GRAYED

********************************************************************/

VOID MENUITEM::Enable( BOOL f )
{
    REQUIRE( ::EnableMenuItem( _hmenu, _mid,
			       MF_BYCOMMAND |
			       ( f ?
				    MF_ENABLED :
				    ( MF_DISABLED | MF_GRAYED ))) != -1 );
}


/*******************************************************************

    NAME:	MENUITEM::IsEnabled

    SYNOPSIS:	Returns whether or not the menu item is enabled

    RETURNS:	TRUE if menu item is enabled; FALSE otherwise

    NOTES:	It is assumed that a menu item is MF_DISABLED'd exactly
		when it is also MF_GRAYED'd.

    HISTORY:
	rustanl     11-Sep-1991 Created
	beng	    04-Oct-1991 Win32 conversion

********************************************************************/

BOOL MENUITEM::IsEnabled() const
{
    UINT nState = ::GetMenuState( _hmenu, _mid, MF_BYCOMMAND );

    //	assert that the menu item is disabled exactly when it is grayed
    UIASSERT( !( nState & MF_ENABLED ) == !( nState & MF_GRAYED ));

    return !( nState & MF_DISABLED );
}


/*******************************************************************

    NAME:	MENUITEM::SetCheck

    SYNOPSIS:	Sets or removes the check mark next to a menu item

    ENTRY:	f -	Specifies whether to set or remove the check mark
			TRUE sets it, whereas FALSE removes it

    EXIT:	The menu item check mark has the requested state

    HISTORY:
	rustanl     11-Jul-1991     Created

********************************************************************/

VOID MENUITEM::SetCheck( BOOL f )
{
    REQUIRE( ::CheckMenuItem( _hmenu, _mid,
			      ( f ? MF_CHECKED : MF_UNCHECKED ) |
			      MF_BYCOMMAND ) != -1 );
}


/*******************************************************************

    NAME:	MENUITEM::IsChecked

    SYNOPSIS:	Returns whether or not the menu item is checked

    RETURNS:	TRUE if menu item is checked; FALSE otherwise

    HISTORY:
	rustanl     11-Sep-1991 Created
	beng	    04-Oct-1991 Made BOOL-safe

********************************************************************/

BOOL MENUITEM::IsChecked() const
{
    return !!( ::GetMenuState( _hmenu, _mid, MF_BYCOMMAND ) & MF_CHECKED );
}

/*******************************************************************

    NAME:	MENUITEM::SetText

    SYNOPSIS:	set the menu item to the given string

    ENTRY:	const TCHAR * pszString - string to be set

    RETURNS:	TRUE if succeed

    HISTORY:
	terryk	    27-Nov-1991	Created

********************************************************************/

BOOL MENUITEM::SetText( const TCHAR * pszString )
{
    return ::ModifyMenu( _hmenu, _mid, MF_BYCOMMAND | MF_STRING, _mid,
	(TCHAR *)pszString );
}

#ifdef WIN32

/*******************************************************************

    NAME:	MENUITEM::ItemExists

    SYNOPSIS:	This static method checks whether the specified menu
                item exists.

    RETURNS:	TRUE if the menu item exists, FALSE otherwise

    HISTORY:
        jonn        19-Mar-1993 Created

********************************************************************/

BOOL MENUITEM::ItemExists( HMENU hmenu, MID mid )
{
    return ( ::GetMenuState( hmenu, mid, MF_BYCOMMAND ) != 0xFFFFFFFF );
}

BOOL MENUITEM::ItemExists( APP_WINDOW * pawin, MID mid )
{
    ASSERT( pawin != NULL );
    HMENU hmenu = ::GetMenu( pawin->QueryHwnd() );
    ASSERT( hmenu != NULL );
    return MENUITEM::ItemExists( hmenu, mid );
}

#endif


/*******************************************************************

    NAME:	SYSMENUITEM::SYSMENUITEM

    SYNOPSIS:	Ctor for system menu item

    ENTRY:	pwnd - pointer to either app or dialog window
		mid  - menu item ID in question

    HISTORY:
	beng	    31-Oct-1991 Created

********************************************************************/

SYSMENUITEM::SYSMENUITEM( OWNER_WINDOW * pwnd, MID mid )
    : MENUITEM ( ::GetSystemMenu( pwnd->QueryHwnd(), FALSE ), mid )
{
    if ( QueryError() != NERR_Success )
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltnslt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltnslt.cxx
    This file contains the class definition for the DEC_SLT class.

    The DEC_SLT class is a display object derived from the SLT class.
    DEC_SLT adds a new method SetValue() for setting a numerical value
    into the SLT.


    FILE HISTORY:
        KeithMo     28-Jul-1991 Created.
        KeithMo     26-Aug-1991 Changes from code review attended by
                                RustanL and EricCh.
        KeithMo     23-Mar-1992 Changed formatting from ultoa to DEC_STR.

*/
#include "pchblt.hxx"  // Precompiled header

//
//  DEC_SLT methods.
//

/*******************************************************************

    NAME:       DEC_SLT :: DEC_SLT

    SYNOPSIS:   DEC_SLT class constructor.

    ENTRY:      powner                  - Owning window.

                cid                     - Cid for this control

                cchDigitPad             - Number of pad digits to display.

    HISTORY:
        KeithMo     28-Jul-1991 Created.

********************************************************************/
DEC_SLT :: DEC_SLT( OWNER_WINDOW * powner,
                    CID            cid,
                    UINT           cchDigitPad )
  : SLT( powner, cid ),
    _cchDigitPad( cchDigitPad )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // DEC_SLT :: DEC_SLT


/*******************************************************************

    NAME:       DEC_SLT :: DEC_SLT

    SYNOPSIS:   DEC_SLT class constructor.

    ENTRY:      powner                  - Owning window.

                cid                     - Cid for this control

                xy                      - This control's position.

                dxy                     - This control's size.

                flStyle                 - Window style bits.

                pszClassName            - This control's window class
                                          name.

                cchDigitPad             - Number of pad digits to display.

    HISTORY:
        KeithMo     26-Aug-1991 Created.

********************************************************************/
DEC_SLT :: DEC_SLT( OWNER_WINDOW * powner,
                    CID            cid,
                    XYPOINT        xy,
                    XYDIMENSION    dxy,
                    ULONG          flStyle,
                    const TCHAR  * pszClassName,
                    UINT           cchDigitPad )
  : SLT( powner, cid, xy, dxy, flStyle, pszClassName ),
    _cchDigitPad( cchDigitPad )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // DEC_SLT :: DEC_SLT


/*******************************************************************

    NAME:       DEC_SLT :: ~DEC_SLT

    SYNOPSIS:   DEC_SLT class destructor.

    HISTORY:
        KeithMo     20-Aug-1991 Created.

********************************************************************/
DEC_SLT :: ~DEC_SLT()
{
    //
    //  This space intentionally left blank.
    //

}   // DEC_SLT :: ~DEC_SLT


/*******************************************************************

    NAME:       DEC_SLT :: SetValue

    SYNOPSIS:   Sets the displayed value (unsigned version).

    ENTRY:      ulValue                 - The value to display.

    EXIT:       The value is displayed.

    HISTORY:
        KeithMo     28-Jul-1991 Created.
        KeithMo     23-Mar-1992 Now uses DEC_STR instead of ultoa().

********************************************************************/
VOID DEC_SLT :: SetValue( ULONG ulValue )
{
    DEC_STR nls( ulValue, _cchDigitPad );

    if( nls.QueryError() == NERR_Success )
    {
        SetText( nls.QueryPch() );
    }
    else
    {
        SetText( SZ("") );
    }

}   // DEC_SLT :: SetValue


/*******************************************************************

    NAME:       DEC_SLT :: SetValue

    SYNOPSIS:   Sets the displayed value (signed version).

    ENTRY:      lValue                  - The value to display.

    EXIT:       The value is displayed.

    HISTORY:
        KeithMo     28-Jul-1991 Created.

********************************************************************/
VOID DEC_SLT :: SetValue( LONG lValue )
{
    SetValue( (ULONG)lValue );          // signed values NYI

}   // DEC_SLT :: SetValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltmsgp.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltmsgp.cxx
    BLT Message popup functions

    This file defines the BLT MsgPopup functions


    FILE HISTORY:
        Rustanl      7-Dec-1990 Created
        Johnl       14-Feb-1991 Made functional
        Rustanl      4-Mar-1991 Removed comment about QueryRobustHwnd,
                                which is now being used in the header
                                file
        JohnL       19-Apr-1991 Removed vhInst reference, grays Close sys
                                menu item
        beng        14-May-1991 Exploded blt.hxx into components
        beng        23-Oct-1991 Replace min, max
        Yi-HsinS     6-Dec-1991 change behavior of DisplayGenericError
                                when err not in NERR range
        beng        17-Jun-1992 Restructuring, extensive rewrite
        KeithMo     07-Aug-1992 STRICTified.
        Yi-HsinS    10-Aug-1992 Added MPSEV_QUESTION
        JonN        25-Aug-1992 Merged in PERFORMER::DisplayError()
        Yi-HsinS    09-Oct-1992 Added SetHelpContextBase()
*/

#include "pchblt.hxx"   // Precompiled header

#ifdef min
#undef min
#endif
#ifdef max
#undef max
#endif

inline INT min(INT a, INT b)
{
    return (a < b) ? a : b;
}

inline INT max(INT a, INT b)
{
    return (a > b) ? a : b;
}

// Maximum number of buttons that can be displayed at one time
#define MAX_DISPLAY_BUTTONS     4

// Maximum number of characters of the lanman message box captions
#define MAX_CAPTION_LEN 80

// Number of dialog units between controls in the dialog box
#define DU_DIST_BETWEEN_BUTTONS    3

// Number of dialog units between controls in the dialog box and the edge of
// the dialog box
#define DU_DIST_TO_DLG_EDGE        6

// The following two macros convert horizontal and vertical (respectively)
// dialog unit measurements to pixel measurements
// lBaseUnits == the value returned from GetDialogBaseUnits
// w?DlgUnits == Vert.or Horiz. dialog units
#define HDUTOPIXELS( lBaseUnits, wXDlgUnits ) \
                    ( (wXDlgUnits*LOWORD( lBaseUnits ))/4 )

#define VDUTOPIXELS( lBaseUnits, wYDlgUnits ) \
                    ( (wYDlgUnits*HIWORD( lBaseUnits ))/8 )


/*************************************************************************

    NAME:       MSGPOPUP_DIALOG

    SYNOPSIS:   Class that handles all of the dialog aspects of the message
                popup dialog

    INTERFACE:

    PARENT:     DIALOG_WINDOW

    USES:       PUSH_BUTTON, ICON_CONTROL, SLT

    CAVEATS:

    NOTES:
        Private to message-popup module.

    HISTORY:
        Johnl       7-Feb-1991  Added meat to Rustan's original outline
        beng        30-Sep-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

**************************************************************************/

class MSGPOPUP_DIALOG : public DIALOG_WINDOW
{
private:
    PUSH_BUTTON   _pbOK, _pbCancel, _pbYes, _pbNo, _pbHelp;
    PUSH_BUTTON * _appbDisplay[MAX_DISPLAY_BUTTONS + 1];
    ICON_CONTROL  _iconSev;
    SLT           _sltMsgText;      // Message gets displayed in this
    ULONG         _ulHC;            // Save the help context
    UINT          _usMessageNum;    // Save the message number
    MSGID         _msgidCaption;    // Caption, if set

    VOID FillButtonArray( UINT usButtons, INT *piWidthReq, INT *piHeightReq );
    VOID PlaceButtons();
    PUSH_BUTTON * QueryButton( UINT usMsgPopupButton );
    const TCHAR * QueryIcon( MSG_SEVERITY msgsev );

    static BOOL Msg2HC( MSGID msgid, ULONG * hc );

protected:
    virtual BOOL OnOK();
    virtual BOOL OnCancel();
    virtual BOOL OnCommand( const CONTROL_EVENT & e );
    virtual ULONG QueryHelpContext();

public:
    MSGPOPUP_DIALOG( HWND           hwndParent,
                     const NLS_STR& nlsMessage,
                     MSGID          msgid,
                     MSG_SEVERITY   msgsev,
                     ULONG          ulHelpContext,
                     UINT           nButtons,
                     UINT           nDefButton,
                     MSGID          msgidCaption = 0,
                     ULONG          ulHelpContextBase = 0 );

    ~MSGPOPUP_DIALOG();
};


//
// Local variables
//

NLS_STR * POPUP::_vpnlsEmergencyText = NULL;
NLS_STR * POPUP::_vpnlsEmergencyCapt = NULL;
MSGID     POPUP::_vmsgidCaption = 0;
ULONG     POPUP::_ulHelpContextBase = 0;
MSGMAPENTRY * POPUP::_vpmmeTable = NULL;

BOOL      POPUP::_fInit = FALSE;

POPUP::POPUP( HWND hwndOwner, MSGID msgid, MSG_SEVERITY msgsev,
              UINT nButtons, UINT nDefButton, BOOL fTrySystem )
    : _hwndParent(hwndOwner),
      _msgid( msgid ),
      _msgsev(msgsev),
      _ulHelpContext(HC_DEFAULT_HELP),
      _nButtons(nButtons),
      _nDefButton(CalcDefButton(nButtons, nDefButton)),
      _pnlsText(NULL)
{

    _pnlsText = LoadMessage(msgid, fTrySystem);
    if (_pnlsText == NULL)
        return; // already reported error
}


POPUP::POPUP( HWND hwndOwner, MSGID msgid, MSG_SEVERITY msgsev,
              ULONG ulHelpTopic, UINT nButtons,
              const NLS_STR ** apnlsParams, UINT nDefButton )
    : _hwndParent(hwndOwner),
      _msgid( msgid ),
      _msgsev(msgsev),
      _ulHelpContext(ulHelpTopic),
      _nButtons(nButtons),
      _nDefButton(CalcDefButton(nButtons, nDefButton)),
      _pnlsText(NULL)
{

    _pnlsText = LoadMessage(msgid);
    if (_pnlsText == NULL)
        return; // already reported error

    if (apnlsParams != NULL)
    {
        if (_pnlsText->InsertParams( apnlsParams ) != NERR_Success)
        {
            Emergency();
            ReportError(1); // A simple true/false will suffice
            return;
        }
    }
}


#if 0 // strlist form never used
POPUP::POPUP( HWND hwndOwner, MSGID msgid, MSG_SEVERITY msgsev,
              ULONG ulHelpContext, UINT nButtons,
              STRLIST & strlst, UINT nDefButton )
    : _hwndParent(hwndOwner),
      _msgid( msgid ),
      _msgsev(msgsev),
      _ulHelpContext(ulHelpContext),
      _nButtons(nButtons),
      _nDefButton(CalcDefButton(nButtons, nDefButton)),
      _pnlsText(NULL)
{

    _pnlsText = LoadMessage(msgid);
    if (_pnlsText == NULL)
        return; // Already reported the error

    // Get a vector which will accommodate the strlist

    ITER_STRLIST iter(strlst);
    UINT cnls = 0;
    while (iter.Next() != NULL)
        ++cnls;

    NLS_STR ** apnlsParams = (NLS_STR**) new NLS_STR* [cnls+1];
    if (apnlsParams == NULL)
    {
        Emergency();
        ReportError(ERROR_NOT_ENOUGH_MEMORY);
        return;
    }

    // Copy the strlist into the vector

    iter.Reset();
    cnls = 0; // This time, it's an index instead of a count
    while ((apnlsParams[cnls] = iter.Next()) != NULL)
        ++cnls;

    APIERR err;
    if ((err = _pnlsText->InsertParams( apnlsParams )) != NERR_Success)
    {
        Emergency();
        ReportError(err);
        delete[] apnlsParams;
        return;
    }

    delete[] apnlsParams;
}
#endif // never used


POPUP::~POPUP()
{
    delete _pnlsText;
}



/*******************************************************************

    NAME:       POPUP::SetMsgMapTable

    SYNOPSIS:  Sets the message mapping table.

    INPUT:     pmmeTable - mapping table allocated by the application

    RETURNS:   none

    HISTORY:
        thomaspa    13-Apr-1993 Created

********************************************************************/
VOID POPUP::SetMsgMapTable( MSGMAPENTRY * pmmeTable )
{
    _vpmmeTable = pmmeTable;
}

/*******************************************************************

    NAME:       POPUP::MapMessage

    SYNOPSIS:  Uses the Application supplied message map table to map
               the input message.

    INPUT:      Message to be mapped.

    RETURNS:    The mapped message.

    HISTORY:
        thomaspa    13-Apr-1993 Created

********************************************************************/
MSGID POPUP::MapMessage( MSGID msgidIn )
{
    MSGID msgidRet = msgidIn;
    if ( _vpmmeTable != NULL )
    {
        for ( INT i = 0; _vpmmeTable[i].msgidIn != 0; i++ )
        {
            if ( msgidIn == _vpmmeTable[i].msgidIn )
            {
                msgidRet = _vpmmeTable[i].msgidOut;
                break;
            }
        }
    }
    return msgidRet;
}

/*******************************************************************

    NAME:       POPUP::Emergency

    SYNOPSIS:   This popup gets called when MsgPopup gets stuck due to
                Low memory or resource failures.  It is guaranteed to come
                up and will display either "Low memory" or "Can't load
                resource"

    RETURNS:    Identifier of the default button.

    NOTES:
        InitMsgPopup must be called before calling this function.

    HISTORY:
        Johnl       5-Feb-1991  Created
        beng        17-Jun-1992 Restructured, rewritten

********************************************************************/

INT POPUP::Emergency() const
{
    ASSERT( _fInit );
    ASSERT( _vpnlsEmergencyText != NULL && _vpnlsEmergencyCapt != NULL );

    ::MessageBox( _hwndParent,
                  (TCHAR*)_vpnlsEmergencyText->QueryPch(),
                  (TCHAR*)_vpnlsEmergencyCapt->QueryPch(),
                  (UINT)  ( MB_ICONHAND | MB_SYSTEMMODAL) );

    return MapButton(_nDefButton);
}


/*******************************************************************

    NAME:     POPUP::Init

    SYNOPSIS: Initializes resource strings at start, returns NERR_Success
              if successful, ERROR_NOT_ENOUGH_MEMORY if a memory
              failur. occurred or ERROR_GEN_FAILURE if a resource could
              not be loaded.

              The application should not continue if InitMsgPopup
              returns an error.

    ENTRY:

    EXIT:
        Loads the resources required for emergency situations

    NOTES:
        Should fold into the rest of BLTInit

    HISTORY:
        Johnl       12-Feb-1991 Created
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructured
        beng        23-Jul-1992 Tune error reporting a bit

********************************************************************/

APIERR POPUP::Init()
{
# if !defined(WIN32)
    DWORD wWinFlags = ::GetWinFlags();
    ASSERT( wWinFlags & WF_PMODE );
# endif

    ASSERT(!_fInit);
    _fInit = TRUE;

    _vpnlsEmergencyText = new NLS_STR;
    _vpnlsEmergencyCapt = new NLS_STR;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   _vpnlsEmergencyText == NULL
        || _vpnlsEmergencyCapt == NULL
        || (err = _vpnlsEmergencyText->Load( (MSGID) IDS_BLT_TEXT_MSGP )) != NERR_Success
        || (err = _vpnlsEmergencyCapt->Load( (MSGID) IDS_BLT_CAPT_MSGP )) != NERR_Success )
    {
        DBGEOL("POPUP::Init: failed, error " << err);
        POPUP::Term();
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:     POPUP::Term

    SYNOPSIS: Uninitializes the message popup stuff.  Free the emergency
              strings allocated by InitMsgPopup

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl       12-Feb-1991 Created
        beng        17-Jun-1992 Restructured

********************************************************************/

VOID POPUP::Term()
{
    ASSERT( _fInit );
    _fInit = FALSE;

    delete _vpnlsEmergencyText;
    delete _vpnlsEmergencyCapt;

    _vpnlsEmergencyText = _vpnlsEmergencyCapt = NULL;
}


/*******************************************************************

    NAME:       POPUP::LoadMessage

    SYNOPSIS:   Loads the initial message string from the resource file
                and puts up an appropriate popup if any error occurred.

    ENTRY:      msgid - Message/string resource ID to retrieve
                fTrySystem - set if system error text is interesting

    RETURNS:    Pointer to a newly allocated NLS_STR that contains the message
                text, or NULL if an error occurred (in which case it reports
                the error).

    CAVEATS:
        * THE CLIENT IS RESPONSIBLE FOR DELETING THE RETURNED NLS_STR*! *

    NOTES:
        A popup will be displayed if an error occurs.  The text is
        dependent on the range of msgid.  The text will be:

        "DOS error %1 occurred" if  0 < msgid < NERR_BASE
        "Network error %1 occurred" if NERR_BASE <= msgid <= MAX_NERR
        "LAN Manager network driver error %1 occurred" anything else.

    HISTORY:
        Johnl       19-Mar-1991 Created
        beng        04-Oct-1991 Win32 conversion
        beng        21-Nov-1991 Remove STR_OWNERALLOC
        beng        27-Feb-1992 Add InsertParams call
        beng        05-Mar-1992 Remove ltoa usage
        beng        17-Jun-1992 Restructured, rewritten
        beng        05-Aug-1992 Use NLS_STR::LoadSystem
        KeithMo     06-Jan-1993 Map ERROR_MR_MID_NOT_FOUND to
                                IDS_BLT_UNKNOWN_ERROR.

********************************************************************/

NLS_STR * POPUP::LoadMessage( MSGID msgid, BOOL fTrySystem )
{
    NLS_STR * pnlsMessage = new NLS_STR( MAX_RES_STR_LEN + 1 );

    msgid = POPUP::MapMessage( msgid );

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if (   pnlsMessage == NULL
        || (err = pnlsMessage->QueryError()) != NERR_Success )
    {
        delete pnlsMessage;
        Emergency();
        ReportError(err);
        return NULL;
    }

    if( msgid == ERROR_MR_MID_NOT_FOUND )
    {
        //
        //  ERROR_MR_MID_NOT_FOUND is returned by RtlNtStatusToDosError
        //  if there was no ERROR_* code corresponding to a particular
        //  STATUS_* code.  We'll map this to IDS_BLT_UNKNOWN_ERROR,
        //  which is slightly less cryptic than the text associated
        //  with ERROR_MR_MID_NOT_FOUND.
        //

        msgid = IDS_BLT_UNKNOWN_ERROR;
    }

    // Attempt to load the string; if successful, return it.

    if ((err = pnlsMessage->Load( msgid )) == NERR_Success)
        return pnlsMessage;

    // If appropriate, next try the system for the text.

#if defined(WIN32)
    if (fTrySystem)
    {
        if ((err = pnlsMessage->LoadSystem(msgid)) == NERR_Success)
            return pnlsMessage;
    }
#endif

    // Didn't find the string.

    if (   msgid == IDS_BLT_DOSERROR_MSGP
        || msgid == IDS_BLT_NETERROR_MSGP
        || msgid == IDS_BLT_WINNET_ERROR_MSGP )
    {
        // Prevent recursion

        Emergency();
    }
    else
    {
        // Convert the message number to an NLS_STR so we can insert it into
        // the message string.
        //
        const DEC_STR nlsDecMsgNum(msgid);
        const HEX_STR nlsHexMsgNum(msgid);
        const NLS_STR * apnls[2]; // Do this by hand here
        apnls[0] = &nlsDecMsgNum;
        apnls[1] = NULL;

        MSGID idMessage;

        if ( msgid >= 0 && msgid < NERR_BASE )
            idMessage = IDS_BLT_DOSERROR_MSGP;
        else if ( msgid >= NERR_BASE && msgid <= MAX_NERR )
            idMessage = IDS_BLT_NETERROR_MSGP;
        else if ( msgid > MAX_NERR && msgid < 0x10000000 )
            idMessage = IDS_BLT_WINNET_ERROR_MSGP;
        else
        {
            DBGEOL( "NETUI: MsgPopup: NTSTATUS error code " << msgid );
            ASSERT( FALSE );
            idMessage = IDS_BLT_NTSTATUS_ERROR_MSGP;
            apnls[0] = &nlsHexMsgNum;
        }

        // Post the stand-in popup.  If this fails, the next time
        // through it will hit the Emergency case above.

        POPUP popup(_hwndParent, idMessage, MPSEV_ERROR, (ULONG)HC_NO_HELP,
                    MP_OK, apnls, MP_UNKNOWN);
        popup.Show();
    }

    // This was an error path; return NULL, which will prematurely
    // terminate the caller.  (All the above popups took place in the
    // caller's ctor.)

    delete pnlsMessage;
    ReportError(err);
    return NULL;
}


/*******************************************************************

    NAME:      POPUP::CalcDefButton

    SYNOPSIS:  Returns usDefButton (input value) if usDefButton != 0
               else it selects the appropriate default from the presented
               selection in usButtons (will either be OK, or Yes).

    ENTRY:

    EXIT:

    CAVEATS:
        nButtons must contain either MP_OK or MP_YES

    NOTES:
        This is a static, private member function.

    HISTORY:
        Johnl       15-Feb-1991 Created
        beng        17-Jun-1992 Restructured

********************************************************************/

INT POPUP::CalcDefButton( UINT nButtons, UINT nDefButton )
{
    if ( nDefButton == MP_UNKNOWN )
    {
        if ( nButtons & MP_OK )
            nDefButton = MP_OK;
        else if ( nButtons & MP_YES )
            nDefButton = MP_YES;
        else
        {
            DBGEOL("BLT: MSGPOPUP::CalcDefButton - Bad button combination");
            ASSERT(FALSE);
        }
    }

    return nDefButton;
}


/*******************************************************************

    NAME:       POPUP::MapButton

    SYNOPSIS:   Converts a MP button code to the CID

    ENTRY:      MP button code (MP_OK, etc.)

    RETURNS:    CID

    NOTES:
        This is a static, private member function.

    HISTORY:
        beng        17-Jun-1992 Created

********************************************************************/

INT POPUP::MapButton( UINT nButton )
{
    switch (nButton)
    {
    case MP_OK:
        return IDOK;

    case MP_YES:
        return IDYES;

    case MP_NO:
        return IDNO;

    case MP_CANCEL:
        return IDCANCEL;

    default:
        DBGEOL("BLT: Unknown MP button code passed to MsgPopup");
        ASSERT(FALSE);
        return IDCANCEL;
    }
}


/*******************************************************************

    NAME:      POPUP::Show

    SYNOPSIS:  Worker routine for the message popup stuff, this is the
               routine that actually puts up the dialog box

    ENTRY:     hwndParent - Parent window handle
               nlsMessage - Expanded message to display
               msgid      - Message number (used to obtain help context)
               msgsev     - Message severity, determines icon
               ulHelpContext - Help file context, 0 if we should use #
                               associated with msgid from the resource file.
               usButtons  - Buttons to display
               usDefButton- Default button, 0 to use windows default

    EXIT:      Returns button pressed or the default button

    NOTES:     If no buttons were passed in usButtons, then the OK button
               is displayed by default.

    HISTORY:
        JohnL       1/31/91     Created
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructured, rewritten

********************************************************************/

INT POPUP::Show()
{
    ASSERT( _fInit );

    /* Must have at least OK button...
     */
    ASSERT( _nButtons );
    if ( _nButtons == 0 )
        _nButtons |= MP_OK;

    if (QueryError())
        return MapButton(_nDefButton);

    MSGPOPUP_DIALOG dlgMsgPopup( _hwndParent, *_pnlsText, _msgid, _msgsev,
                                 _ulHelpContext, _nButtons, _nDefButton,
                                 _vmsgidCaption, _ulHelpContextBase );
    if (!dlgMsgPopup)
        return Emergency();

    // Process the dialog.

    UINT nButtonUserPressed;
    if ( dlgMsgPopup.Process( &nButtonUserPressed ) != NERR_Success )
    {
        return Emergency();
    }

    return (INT) nButtonUserPressed;
}


/*******************************************************************

    NAME:      POPUP::SetCaption

    SYNOPSIS:  Set the default caption

    ENTRY:     msgid      - ID of title

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Outlined as part of dllization delta

********************************************************************/

VOID POPUP::SetCaption( MSGID msgid )
{
    _vmsgidCaption = msgid;
}


/*******************************************************************

    NAME:      POPUP::ResetCaption

    SYNOPSIS:  Reset the default caption to its original setting

    NOTES:
        This is a static member function.

    HISTORY:
        beng        29-Jun-1992 Outlined as part of dllization delta

********************************************************************/

VOID POPUP::ResetCaption()
{
    _vmsgidCaption = 0;
}

/*******************************************************************

    NAME:      POPUP::SetHelpContextBase

    SYNOPSIS:  Set the help context base for the help contexts
               contained in the msg2help.tbl

    ENTRY:     ulHelpContextBase - the base of the help contexts

    RETURNS:   Returns the old help context base

    NOTES:
        This is a static member function.

    HISTORY:
        Yi-HsinS     09-Oct-1992 Created

********************************************************************/

ULONG POPUP::SetHelpContextBase( ULONG ulHelpContextBase )
{
    ULONG ulOldHelpContextBase = _ulHelpContextBase;
    _ulHelpContextBase = ulHelpContextBase;
    return ulOldHelpContextBase;
}

/*******************************************************************

    NAME:      MSGPOPUP_DIALOG::MSGPOPUP_DIALOG

    SYNOPSIS:  Constructor for Message popup dialog

    ENTRY:

    EXIT:

    NOTES:     Initializes the controls and places everything where it
               is supposed to go.

               Note: You cannot make the help button the default button.
               If no default is specified, then either the OK or Yes button
               gets the default (specified in the resource file).

         The dialog box looks roughly like:

              +---------------------------------------------------------+
              | - |                     Lan Manager                     |
              +---+-----------------------------------------------------+
              |             : } Six DUs
              |     +-----+
              |     |     |
              |     |     |     This is some message text
              |     |     |
              |^^^^^+-----+^^^^^
              |{six DUs) : {six DUs}
              |          :
              |   6 DUs {:     3DUs between buttons, 6DUs on each side
              |         |   OK   |    |  Cancel  |    |   Help   |
              |     6 DUs to frame {:
              +-----------------------------------------------

    HISTORY:
        Johnl       5-Feb-1991  Created
        beng        04-Oct-1991 Win32 conversion
        beng        20-Feb-1992 Uses numeric resource ID for dialog

********************************************************************/

MSGPOPUP_DIALOG::MSGPOPUP_DIALOG( HWND           hwndParent,
                                  const NLS_STR& nlsMessage,
                                  MSGID          msgid,
                                  MSG_SEVERITY   msgsev,
                                  ULONG          ulHelpContext,
                                  UINT           usButtons,
                                  UINT           usDefButton,
                                  MSGID          msgidCaption,
                                  ULONG          ulHelpContextBase )
  : DIALOG_WINDOW( IDD_BLT_HELPMSG, hwndParent ),
    _pbOK( this, IDOK ),
    _pbCancel( this, IDCANCEL ),
    _pbYes( this, IDYES ),
    _pbNo( this, IDNO ),
    _pbHelp( this, IDHELPBLT ),
    _sltMsgText( this, IDC_MSGPOPUPTEXT ),
    _iconSev( this, IDC_MSGPOPUPICON )
{
    UNREFERENCED( hwndParent );

    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _iconSev.SetPredefinedIcon( QueryIcon( msgsev ) );
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    /* Is there a help context available?  If no, then we won't display
     * the help button.
     */
    if ( ulHelpContext == HC_DEFAULT_HELP )
    {
        if ( !Msg2HC( msgid, &ulHelpContext ) )
            ulHelpContext = (ULONG) HC_NO_HELP;
        else
            ulHelpContext += ulHelpContextBase;
    }

#if defined(DEBUG)
    switch (ulHelpContext)
    {
    case HC_NO_HELP:
        DBGEOL( "Msgpopup help = HC_NO_HELP" );
        break;
    case HC_DEFAULT_HELP:
        DBGEOL( "Msgpopup help = HC_DEFAULT_HELP" );
        break;
    default:
        DBGEOL( "Msgpopup help = " << ulHelpContext );
        break;
    }
#endif

    _ulHC = ulHelpContext;
    _usMessageNum = (UINT) msgid;
    _sltMsgText.SetText( nlsMessage.QueryPch() );

    // If the client has requested an alternate caption, set it here.

    if (msgidCaption != 0)
    {
        RESOURCE_STR nlsCaption(msgidCaption);
        if (!nlsCaption)
        {
            DBGEOL("BLT: Couldn't load alternate popup caption "
                   << msgidCaption);
        }
        else
        {
            SetText(nlsCaption);
        }
        // If this failed, carry on.
    }

    /* Now we need to figure how large to make the dialog box, we will get
     * the minimum of each group then set the size accordingly.  There are
     * two groups, the button group and the icon + text group.
     */
    INT  cxButtons, cyButtons,
         cxIcon,    cyIcon,
         cxCaption,
         cxMaxCapBtn;            // Maximum between cxButtons & cxCaption
    LONG lBaseDlgUnits = GetDialogBaseUnits();

    /* Margins for controls (6 DUs)
     */
    INT  cxBigContMargin = HDUTOPIXELS( lBaseDlgUnits, DU_DIST_TO_DLG_EDGE );
    INT  cyBigContMargin = VDUTOPIXELS( lBaseDlgUnits, DU_DIST_TO_DLG_EDGE );

    DISPLAY_CONTEXT dcDlg( QueryHwnd() );
    SCREEN_DC dcScreen;
    RECT rcText;            // Message text bounding rectangle

    if ( dcDlg.QueryHdc() == NULL || dcScreen.QueryHdc() == NULL )
    {
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }

    HFONT hfontDlg = dcDlg.SelectFont( _sltMsgText.QueryFont() );

    /* Get the width of the caption + width of system menu and the width of
     * the button group, then compute the maximum between the two
     */
    STACK_NLS_STR( nlsCaption, MAX_CAPTION_LEN );
    QueryText(&nlsCaption);

    XYDIMENSION dxy = dcScreen.QueryTextExtent( nlsCaption );

    cxCaption = dxy.QueryWidth() + GetSystemMetrics( SM_CXSIZE );

    FillButtonArray( usButtons, &cxButtons, &cyButtons );

    cxMaxCapBtn = max( cxButtons, cxCaption );

    /* Compute the maximum width we will allow the dialog to be.
     * This is 5/8 of the screen width (this was taken directly from the
     * windows code).
     */
    INT cxMBMax = ( GetSystemMetrics( SM_CXSCREEN ) >> 3 ) * 5;

    /* This is the max width we will allow the text to be
     *  Max text width = Max dialog width - left & right borders - icon width - icon border
     */
    _iconSev.QuerySize( &cxIcon, &cyIcon );
    INT cxTextMax = cxMBMax - 3*cxBigContMargin - cxIcon;

    /* Use DrawText to calculate how high the resultant text will be.
     * (with DT_CALCRECT the text is not drawn, but rcText will be adjusted
     * to bound the text).
     *
     * The DT_* parameters are the same used by the windows message box
     * function (see winmsg.c).
     */
    SetRect( &rcText, 0, 0, cxTextMax, cxTextMax );
    INT cyText = dcDlg.DrawText(nlsMessage, &rcText,
                                DT_CALCRECT   |
                                DT_WORDBREAK  |
                                DT_EXPANDTABS | DT_NOPREFIX );
    INT cxText = (INT) ( rcText.right - rcText.left );
    _sltMsgText.SetSize( (INT) rcText.right, (INT) rcText.bottom );

    /* Find the window size -
     *    x = max( Cap/But, text width ) + 3 wide borders + dlgframe width
     *    y = Button group height + max( text, icon ) + 1 larger border +
     *          caption height + dlgframe height
     */
    INT cxBox = max( cxMaxCapBtn, cxText) + cxIcon + 3 * cxBigContMargin + GetSystemMetrics( SM_CXDLGFRAME );
    INT cyBox = cyButtons + max( cyText, cyIcon ) + cyBigContMargin +
                GetSystemMetrics( SM_CYCAPTION ) + GetSystemMetrics( SM_CYDLGFRAME );
    SetSize( cxBox, cyBox );

    /* Place the dialog centered over the app, checking to make sure we
     * don't go off the screen.
     */
    INT xScreen = GetSystemMetrics( SM_CXSCREEN );
    INT yScreen = GetSystemMetrics( SM_CYSCREEN );
    INT xParent, yParent, cxParent, cyParent;

    if ( QueryOwnerHwnd() != NULL )
    {
        RECT rect;
        ::GetWindowRect( QueryOwnerHwnd(), &rect );
        xParent = (INT) rect.left;
        yParent = (INT) rect.top;
        cxParent= (INT) (rect.right - rect.left);
        cyParent= (INT) (rect.bottom - rect.top);
    }
    else
    {
        xParent = yParent = 0;
        cxParent = xScreen;
        cyParent = yScreen;
    }

    POINT ptDlgBox;
    ptDlgBox.x = xParent + cxParent/2 - cxBox/2;
    ptDlgBox.y = yParent + cyParent/2 - cyBox/2;

    ptDlgBox.x = max( 0, (INT) ptDlgBox.x );
    ptDlgBox.y = max( 0, (INT) ptDlgBox.y );
    ptDlgBox.x = min( (INT) (xScreen - cxBox), (INT) ptDlgBox.x );
    ptDlgBox.y = min( (INT) (yScreen - cyBox), (INT) ptDlgBox.y );

    SetPos( ptDlgBox );

    /* Determine where to place the icon and the text on the dialog box.
     * They get placed half way between the button group and the top of the
     * client area in the y direction.  In the x direction, the icon gets
     * placed one large margin width from the left of the control, then the
     * text gets placed one large margin width to the right of the icon
     */
    INT cyCapIconMidpt = (2*cyBigContMargin + max( cyIcon, cyText ))/2;
    {
        XYPOINT xyIconPos(cxBigContMargin,
                          cyCapIconMidpt - cyIcon/2);
        XYPOINT xyTextPos(xyIconPos.QueryX() + cxIcon + cxBigContMargin,
                          cyCapIconMidpt - cyText/2);

        _iconSev.SetPos( xyIconPos );
        _sltMsgText.SetPos( xyTextPos );
    }

    PlaceButtons();

    /* Set the default button if it's specified and give it the focus
     * First we assert that if a default button is specified, that it had
     * better be one of the requested buttons to display.
     */
    ASSERT( (usButtons & usDefButton) );
    PUSH_BUTTON * pbDefault;
    if ( (pbDefault = QueryButton( usDefButton )) != NULL )
    {
        pbDefault->MakeDefault();
        pbDefault->ClaimFocus();
    }

    dcDlg.SelectFont( hfontDlg );
}


/**********************************************************************

   NAME:       MSGPOPUP_DIALOG::~MSGPOPUP_DIALOG

   HISTORY:
        Johnl   5-Feb-1991  Created

**********************************************************************/

MSGPOPUP_DIALOG::~MSGPOPUP_DIALOG()
{
    // Nothing to do...
}


/**********************************************************************

   NAME:       MSGPOPUP_DIALOG::OnOK

   HISTORY:
        Johnl   5-Feb-1991  Created

**********************************************************************/

BOOL MSGPOPUP_DIALOG::OnOK()
{
    Dismiss( IDOK );
    return TRUE;
}


/**********************************************************************

   NAME:       MSGPOPUP_DIALOG::OnCancel

   HISTORY:
        Johnl   5-Feb-1991  Created

**********************************************************************/

BOOL MSGPOPUP_DIALOG::OnCancel()
{
    /* OnCancel won't be called if there is no cancel button displayed
     * (since the Close system menu option was disabled).
     */
    Dismiss( IDCANCEL );
    return TRUE;
}


/**********************************************************************

   NAME:       MSGPOPUP_DIALOG::OnCommand

   HISTORY:
        Johnl       5-Feb-1991  Created
        beng        30-Sep-1991 Win32 conversion

**********************************************************************/

BOOL MSGPOPUP_DIALOG::OnCommand( const CONTROL_EVENT & e )
{
    switch ( e.QueryCid() )
    {
    case IDYES:
        Dismiss( IDYES );
        return TRUE;

    case IDNO:
        Dismiss( IDNO );
        return TRUE;

    default:
        break;
    }

    return DIALOG_WINDOW::OnCommand( e );
}


/**********************************************************************

    NAME:       MSGPOPUP_DIALOG::QueryHelpContext

    SYNOPSIS:   Return help context for popup (callback)

    HISTORY:
        Johnl       5-Feb-1991      Created

**********************************************************************/

ULONG MSGPOPUP_DIALOG::QueryHelpContext()
{
    return _ulHC;
}


/*******************************************************************

    NAME:     MSGPOPUP_DIALOG::FillButtonArray

    SYNOPSIS: Looks at the usButton parameter and fills the class member
              _appbDisplay (array of buttons to display on the message box).
              The ordering of the buttons is determined in this function.

    ENTRY:

    EXIT:      Returns minimum width and height (in pixels) the dialog box
               needs to be to accomodate the buttons requested in piWidthReq and
               piHeightReq respectively.

    NOTES:

    HISTORY:
        Johnl   11-Feb-1991     Created

********************************************************************/

VOID MSGPOPUP_DIALOG::FillButtonArray(
    UINT usButtons,
    INT  * piWidthReq,
    INT  * piHeightReq )
{
    INT iButtonIndex = 0;

    // Watch for invalid button combinations
    ASSERT( !( (usButtons & MP_OK) && (usButtons & MP_YES) ) );

    if ( usButtons & MP_OK )
        _appbDisplay[iButtonIndex++] = &_pbOK;
    else
    {
        _pbOK.Show(FALSE);
        _pbOK.Enable(FALSE);
    }

    if ( usButtons & MP_YES )
        _appbDisplay[iButtonIndex++] = &_pbYes;
    else
    {
        _pbYes.Show(FALSE);
        _pbYes.Enable(FALSE);
    }

    if ( usButtons & MP_NO )
        _appbDisplay[iButtonIndex++] = &_pbNo;
    else
    {
        _pbNo.Show(FALSE);
        _pbNo.Enable(FALSE);
    }

    if ( usButtons & MP_CANCEL )
        _appbDisplay[iButtonIndex++] = &_pbCancel;
    else
    {
        /* Delete the "Close" system menu item if there isn't a Cancel
         * button
         */
        HMENU hSysMenu = ::GetSystemMenu( QueryHwnd(), FALSE );
        ASSERT( hSysMenu != NULL );
        if ( !::DeleteMenu( hSysMenu, SC_CLOSE, (UINT) MF_BYCOMMAND ) )
        {
            DWORD dwErr = ::GetLastError();
            DBGEOL( "NETUI2.DLL: MSGPOPUP_DIALOG::FillButtonArray; DeleteMenu error "
                    << dwErr );
            ASSERT(FALSE); // JonN 8/7/95 see bug report 16768
        }

        _pbCancel.Show(FALSE);
        _pbCancel.Enable(FALSE);
    }

    if ( _ulHC != HC_NO_HELP )
        _appbDisplay[iButtonIndex++] = &_pbHelp;
    else
    {
        _pbHelp.Show(FALSE);
        _pbHelp.Enable(FALSE);
    }

    ASSERT( iButtonIndex > 0 && iButtonIndex <= MAX_DISPLAY_BUTTONS );

    /* Terminate the array
     */
    _appbDisplay[iButtonIndex] = NULL;

    /* The minimum width of the dialog box to display the requested buttons
     * plus the borders is:
     *  Width Req.= 2 * the distance between the end button and the dialog edge +
     *              (# of buttons -1) * distance between buttons +
     *              The width of each button
     */
    LONG lBaseUnits = GetDialogBaseUnits();
    *piWidthReq = 2*HDUTOPIXELS( lBaseUnits, DU_DIST_TO_DLG_EDGE ) +
                    (iButtonIndex-1) * HDUTOPIXELS( lBaseUnits, DU_DIST_BETWEEN_BUTTONS);

    for ( INT i = 0 ; _appbDisplay[i] != NULL ; i++ )
    {
        INT iWidth, iHeight;
        _appbDisplay[i]->QuerySize( &iWidth, &iHeight );

        *piWidthReq += iWidth;
    }

    /* The height of the button group plus border is:
     *   Height Req. = 2* white space border + height of 1st button
     */
    INT iWidth;
    _appbDisplay[0]->QuerySize( &iWidth, piHeightReq );
    *piHeightReq += 2*VDUTOPIXELS( lBaseUnits, DU_DIST_TO_DLG_EDGE );
}


/*******************************************************************

    NAME:     MSGPOPUP_DIALOG::PlaceButtons

    SYNOPSIS: Uses the class member array _appbDisplay filled by
              FillButtonArray and places/sizes the buttons according
              to the MS UI Style guide (Chapter 7).  Also sets the
              default button.  There must be at least one button in
              the button array.

    ENTRY:

    EXIT:

    NOTES:
        The current draft of the style guide states that:

        ...center the group of buttons and space them evenly
        within the group, leaving at least 3 DUs between the
        right edge of one button and the left edge of the next.
        Leave at least 6 DUs between the edge of the dialog
        and the edges of the buttons.  Normally the buttons should
        all be the same width, but individual buttons may be
        made wider to accommodate exceptionally long text...

        It is assumed that the current size of the dialog box is the
        size that will be displayed and that it is at least as wide
        as the value returned by FillButtonArray

        The height of the buttons is determined from the
        first button.  It is assumed that all buttons are of the
        same height (width doesn't matter).

    HISTORY:
        Johnl   11-Feb-1991     Created

********************************************************************/

VOID MSGPOPUP_DIALOG::PlaceButtons()
{
    LONG lDlgBaseUnits = ::GetDialogBaseUnits();
    INT iButtonWidth, iButtonHeight, iDlgWidth, iDlgHeight;

    /* Get the height of the first button (assumed all buttons are of the
     * same height).
     */
    _appbDisplay[0]->QuerySize( &iButtonWidth, &iButtonHeight );

    /* Get the width and height of the dialog for button placement calc.
     */
    QuerySize( &iDlgWidth, &iDlgHeight );

    /* The y-position of the buttons is the height of the dialog minus
     * 6 dialog units minus the height of the button minus the caption
     * bar minus 2 * the horizonatal frame (top & bottom)
     */
    POINT ptButtonPos;
    ptButtonPos.y = iDlgHeight - iButtonHeight -
                    VDUTOPIXELS( lDlgBaseUnits, DU_DIST_TO_DLG_EDGE ) -
                    2 * GetSystemMetrics( SM_CYDLGFRAME ) -
                    GetSystemMetrics( SM_CYCAPTION );

    /* The x-position of the first button is the width of the dialog/2
     * minus the width of the button group/2.
     * First we loop through the buttons to get the total width (excluding
     * white space on end) of the button group.
     */
    ptButtonPos.x = 0;
    INT iButtonGrpWidth = 0, ipbIndex = 0;
    for ( ; _appbDisplay[ipbIndex] != NULL ; ipbIndex++ )
    {
        INT iWidth, iHeight;
        _appbDisplay[ipbIndex]->QuerySize( &iWidth, &iHeight );
        iButtonGrpWidth += iWidth;
    }
    ipbIndex--;      // Adjust for number of buttons

    iButtonGrpWidth += (ipbIndex-1) * HDUTOPIXELS( lDlgBaseUnits, DU_DIST_BETWEEN_BUTTONS );

    ptButtonPos.x = iDlgWidth/2 - iButtonGrpWidth/2;

    /* Loop through each button and place it where it is supposed to go
     */
    for ( ipbIndex = 0 ; _appbDisplay[ipbIndex] != NULL  ; ipbIndex++ )
    {
        INT iWidth, iHeight;

        _appbDisplay[ipbIndex]->SetPos( ptButtonPos );

        _appbDisplay[ipbIndex]->QuerySize( &iWidth, &iHeight );
        ptButtonPos.x += iWidth + HDUTOPIXELS( lDlgBaseUnits, DU_DIST_BETWEEN_BUTTONS );
    }
}


/*******************************************************************

    NAME:       MSGPOPUP_DIALOG::QueryButton

    SYNOPSIS:   Given an MP_*, this function returns a pointer to the
                corresponding button

    ENTRY:      Windows pusbutton identifier (MP_xxx)

    RETURNS:    Pointer to pushbutton object

    NOTES:
        In the debug version, QueryButton Asserts out if you pass
        it an unkown button (usMsgPopupButton cannot be a mask, must
        be a single button).  In the retail version, it returns NULL.

    HISTORY:
        Johnl   14-Feb-1991     Created

********************************************************************/

PUSH_BUTTON * MSGPOPUP_DIALOG::QueryButton( UINT usMsgPopupButton )
{
    switch (usMsgPopupButton)
    {
    case MP_OK:
        return &_pbOK;

    case MP_YES:
        return &_pbYes;

    case MP_NO:
        return &_pbNo;

    case MP_CANCEL:
        return &_pbCancel;

    default:
        DBGEOL("BLT: Unknown button passed to MsgPopup");
        ASSERT(FALSE);
        return NULL;
    }
}


/**********************************************************************

   NAME:        MSGPOPUP_DIALOG::QueryIcon

   SYNOPSIS:    Converts a MsgPopup severity level
                into an equivalent MessageBox icon flag.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        Johnl       14-Feb-1991 Created
        beng        30-Sep-1991 Changed return type

**********************************************************************/

const TCHAR * MSGPOPUP_DIALOG::QueryIcon( MSG_SEVERITY msgsev )
{
    switch ( msgsev )
    {
    case MPSEV_ERROR:
        return IDI_HAND;

    case MPSEV_WARNING:
        return IDI_EXCLAMATION;

    case MPSEV_INFO:
        return IDI_ASTERISK;

    case MPSEV_QUESTION:
        return IDI_QUESTION;

    default:
        DBGEOL("BLT: Unknown severity (icon) passed to MsgPopup");
        ASSERT(FALSE);
        return 0;
    }
}


/* The following typedef is the format of the Message/Help number
 * associtation table.
 */
extern "C"
{
    typedef struct
    {
//        MSGID msgid;
//        UINT usHC;
        WORD msgid;
        WORD usHC;

    } MSGHCPAIR, * LPMSGHCTABLE;
}


/*******************************************************************

    NAME:       Msg2HC

    SYNOPSIS:   Attempts to lookup the help context associated with msgid
                from the resource file.

    ENTRY:      msgid - Message we want to find the help context for
                pusHC - Pointer that will receive the associated help context

    EXIT:       Returns TRUE if the help context was successfuly found
                A return of FALSE means the resource could not be found
                or the resource could not be loaded.

    NOTES:
        This is a static, private member function.

        This function attempts to load the custom resource from the
        resource file.  The resource file needs to have the form
        of:

            IDHC_MSG_TO_HELP RCDATA
            BEGIN
                 ERROR_NOT_ENOUGH_MEMORY, HC_NOT_ENOUGH_MEMORY
                 ERROR_ACCESS_DENIED,     HC_ACCESS_DENIED
                 0, 0        // Must be terminated with a pair of zeros
            END

        Note that BLT seeks the custom resource from whichever module
        contains the string.

    HISTORY:
        Johnl       7-Feb-1991  Created
        beng        04-Oct-1991 Win32 conversion
        beng        29-Mar-1992 Loads resource by numeric ID
        beng        03-Aug-1992 Seeks resource in same hmod as string

********************************************************************/

BOOL MSGPOPUP_DIALOG::Msg2HC( MSGID msgid, ULONG * pulHC )
{
    /* Get help from message to help context resource table
     */
    HMODULE hmod = BLT::CalcHmodString(msgid);

    HRSRC hMsgToHCTable = ::FindResource( hmod,
                                          MAKEINTRESOURCE(IDHC_MSG_TO_HELP),
                                          RT_RCDATA );
    if ( hMsgToHCTable == NULL )
        return FALSE;

    HGLOBAL hMemMsgToHCTable = ::LoadResource( hmod, hMsgToHCTable );
    if ( hMemMsgToHCTable == NULL )
        return FALSE;

    LPMSGHCTABLE lpMsgToHCTable =
        (LPMSGHCTABLE) ::LockResource( hMemMsgToHCTable );
    if ( lpMsgToHCTable == NULL )
    {
#if !defined(WIN32)
        ::FreeResource( hMemMsgToHCTable );
#endif
        return FALSE;
    }

    /* Search for the message number in the table.  We have to do a linear
     * search since we can't assume ordering.
     */
    BOOL fRet = FALSE;          // Assume we will fail
    for ( INT i = 0 ; lpMsgToHCTable[i].usHC != 0 ; i++ )
    {
        if ( (MSGID)lpMsgToHCTable[i].msgid == msgid )
        {
            *pulHC = (ULONG) (lpMsgToHCTable[i].usHC);
            fRet = TRUE;
            break;
        }
    }

#if !defined(WIN32)
    ::UnlockResource( hMemMsgToHCTable );
    ::FreeResource( hMemMsgToHCTable );
#endif

    return fRet;
}


/*******************************************************************

    NAME:       DisplayGenericError

    SYNOPSIS:   Displays a generic error.

    ENTRY:      wnd                     - The "owning" window.

                idMessage               - String ID of the message.
                                          Probably contains insert params.

                errAPI                  - An APIERR.  There should be an
                                          error message in the string table
                                          with this number.  If this value
                                          is > MAX_NERR, we don't even try
                                          to display it.

                pszObject1              - An object for insert params.

                pszObject2              - Another object for insert params.

                msgsev                  - A MsgPopup severity value
                                          (one of the MPSEV_* values).

    NOTES:      The insert parameters are as follows:

                    %1  = pszObject1
                    %2  = pszObject2
                    %3  = errAPI (in decimal)
                    %4  = errAPI (an informative textual description)

                If either (or both) objects are not specified, then the
                remaining parameter numbers are shifted down.  For example,
                if neither object1 nor object2 are specified (passed as
                NULL), then the insert parameters become:

                    %1  = errAPI (in decimal)
                    %2  = errAPI (an informative textual description)

    HISTORY:
        ChuckC      11-Sep-1991 Stole from USER tool.
        beng        04-Oct-1991 Win32 conversion
        Yi-HsinS    06-Dec-1991 Don't print error number if errAPI
                                falls outside the NERR range
        Yi-HsinS    21-Jan-1992 Takes MSG_SEVERITY
        beng        05-Mar-1992 Use new string formatting available
        beng        17-Jun-1992 Look in system for error message text
        beng        05-Aug-1992 Use NLS_STR::LoadSystem
        KeithMo     21-Aug-1992 Added second object, change object
                                handling a bit.

********************************************************************/
DLL_BASED
UINT DisplayGenericError( const OWNINGWND & wnd,
                          MSGID             idMessage,
                          APIERR            errAPI,
                          const TCHAR     * pszObject1,
                          const TCHAR     * pszObject2,
                          MSG_SEVERITY      msgsev )
{
    const TCHAR * pszEmpty = SZ("");

    ALIAS_STR nlsObject1( pszEmpty );
    ALIAS_STR nlsObject2( pszEmpty );
    DEC_STR nlsErrorCode( errAPI, 4 );        // error code given
    NLS_STR nlsEmpty;                         // empty string

    ASSERT(!!nlsEmpty);      // necessary to handle boundary cases
    ASSERT(!!nlsObject1);    // shouldn't fail. really.
    ASSERT(!!nlsObject2);    //

    // Get text describing the error.

    RESOURCE_STR nlsErrorString( errAPI );    // error string
#if defined(WIN32)
    if (!nlsErrorString)
    {
        // If couldn't find it in app resources, check system

        nlsErrorString.LoadSystem(errAPI);
    }
#endif

    if( errAPI > MAX_NERR )
    {
        DBGEOL("Warning - displaying non-error val " << errAPI);
    }

    if( pszObject1 != NULL )
        nlsObject1 = pszObject1;

    if( pszObject2 != NULL )
        nlsObject2 = pszObject2;

    /*
     * Create the insert strings table
     */
    NLS_STR  * apnlsParamStrings[5];
    NLS_STR ** ppnls = apnlsParamStrings;

    if( pszObject1 != NULL )
        *ppnls++ = &nlsObject1;         // apnlsParamStrings[0]

    if( pszObject2 != NULL )
        *ppnls++ = &nlsObject2;         // apnlsParamStrings[1]

    *ppnls++ = &nlsErrorCode;           // apnlsParamStrings[2]
    *ppnls++ = !nlsErrorString          // apnlsParamStrings[3]
                   ? &nlsEmpty
                   : &nlsErrorString;
    *ppnls   = NULL;                    // apnlsParamStrings[4]

    /*
     * pop it up.
     */
    return ( MsgPopup(wnd.QueryHwnd(), idMessage, msgsev, (ULONG)HC_NO_HELP,
                      MP_OK, apnlsParamStrings) );
}


DLL_BASED
UINT DisplayGenericError( const OWNINGWND & wnd,
                          MSGID             idMessage,
                          APIERR            errAPI,
                          const TCHAR     * pszObjectName,
                          MSG_SEVERITY      msgsev )
{
    return ::DisplayGenericError( wnd,
                                  idMessage,
                                  errAPI,
                                  pszObjectName,
                                  (const TCHAR *)NULL,
                                  msgsev );
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: Takes message # and severity, uses OK button, help context
              taken from message number
    ENTRY:

    EXIT:

    NOTES:
        This form will look for the text in the system as well.

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev )
{
    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, MP_OK, MP_UNKNOWN, TRUE );
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: Takes message #, severity, button set and the default button.
              Help context taken from table in resource file.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              UINT nButtons, UINT nDefButton )
{
    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, nButtons, nDefButton );
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: This variety allows either one or two insert strings (which will
              cover 95% of the cases) in addition to specifying the set
              of buttons, the severity and the default buttons.

    ENTRY:

    EXIT:

    NOTES:    If pchString2 is NULL, then we ignore it.

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        21-Nov-1991 Remove STR_OWNERALLOC
        beng        17-Jun-1992 Restructuring

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              UINT          nButtons,
              const TCHAR * psz,
              UINT          nDefButton )
{
    if (psz == NULL)
        return MsgPopup(wnd, msgid, msgsev, nButtons, nDefButton);

    const ALIAS_STR nls(psz);
    const NLS_STR * apnls[2];
    apnls[0] = &nls;
    apnls[1] = NULL;

    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, HC_DEFAULT_HELP, nButtons,
                 apnls, nDefButton);
    return popup.Show();
}


DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              UINT          nButtons,
              const TCHAR * pszOne,
              const TCHAR * pszTwo,
              UINT          nDefButton )
{
    if (pszTwo == NULL && pszOne != NULL)
        return MsgPopup(wnd, msgid, msgsev, nButtons, pszOne, nDefButton);
    if (pszOne == NULL)
        return MsgPopup(wnd, msgid, msgsev, nButtons, nDefButton);

    const ALIAS_STR nls1(pszOne);
    const ALIAS_STR nls2(pszTwo);
    const NLS_STR * apnls[3];
    apnls[0] = &nls1;
    apnls[1] = &nls2;
    apnls[2] = NULL;

    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, HC_DEFAULT_HELP, nButtons,
                 apnls, nDefButton);
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: This one allows multiple insert strings stuffed into an apnls
              (Generally preferable to next version which uses the STR_LIST)

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              ULONG     ulHelpTopic,
              UINT      nButtons,
              NLS_STR * apnlsParams[],
              UINT      nDefButton )
{
    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, ulHelpTopic, nButtons,
                 (const NLS_STR * * const) apnlsParams, nDefButton );
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: One further refinement:  This form allows the user to
              specify both a MSGID and an APIERR.  The string for this
              APIERR will be inserted into the MSGID string as %1,
              while the apnlsInserted strings will be shifted to %2
              and higher.  If the APIERR string cannot be found,
              a string containing the error number and class will be
              inserted instead.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        JonN        25-Aug-1992 Merged in PERFORMER::DisplayError()
        JonN        01-Feb-1993 Map ERROR_MR_MID_NOT_FOUND to
                                IDS_BLT_UNKNOWN_ERROR.

********************************************************************/

DLL_BASED
INT MsgPopup( const OWNINGWND & wnd,
              MSGID msgid,
              APIERR       errAPI,
              MSG_SEVERITY msgsev,
              ULONG     ulHelpTopic,
              UINT      nButtons,
              NLS_STR * apnlsParams[],
              UINT      nDefButton )
{
    APIERR err = NERR_Success;

    if( errAPI == ERROR_MR_MID_NOT_FOUND )
    {
        //
        //  ERROR_MR_MID_NOT_FOUND is returned by RtlNtStatusToDosError
        //  if there was no ERROR_* code corresponding to a particular
        //  STATUS_* code.  We'll map this to IDS_BLT_UNKNOWN_ERROR,
        //  which is slightly less cryptic than the text associated
        //  with ERROR_MR_MID_NOT_FOUND.
        //

        errAPI = IDS_BLT_UNKNOWN_ERROR;
    }

    NLS_STR nlsErrorString;
    if (   (err = nlsErrorString.QueryError()) != NERR_Success
        || (err = nlsErrorString.Load(errAPI)) != NERR_Success
       )
    {
        DBGEOL(   SZ("NETUI: MsgPopup(): Could not load error ")
               << errAPI
               << SZ(", failure code ")
               << err );

        DEC_STR nlsErrorCodeDec( errAPI, 4 );
        HEX_STR nlsErrorCodeHex( errAPI, 8 );

        // workaround for NLS_STR *apnlsParamStrings[2]
        // CODEWORK what is the correct syntax?
        PVOID apvoid[2];
        NLS_STR **apnlsParamStrings = (NLS_STR **)apvoid;

        MSGID msgFormat;

        if ( ((ULONG)errAPI) < ((ULONG)NERR_BASE) )
        {
            msgFormat = IDS_BLT_FMT_SYS_error;
            apnlsParamStrings[0] = &nlsErrorCodeDec;
        }
        else if ( ((ULONG)errAPI) <= ((ULONG)MAX_NERR) )
        {
            msgFormat = IDS_BLT_FMT_NET_error;
            apnlsParamStrings[0] = &nlsErrorCodeDec;
        }
        else
        {
            /* We display probable NTSTATUS error codes in hex */
            msgFormat = IDS_BLT_FMT_other_error;
            apnlsParamStrings[0] = &nlsErrorCodeHex;
        }

        apnlsParamStrings[1] = NULL;

        // We ignore error returns, just skip displaying string
        // CODEWORK - should resource_str take params in ctor?
        err = nlsErrorString.Load(msgFormat);
        if (err != NERR_Success)
        {
            DBGEOL(   SZ("NETUI: MsgPopup(): Could not load message ")
                   << msgFormat
                   << SZ(", failure code ")
                   << err );
            MsgPopup( wnd, err );
        }
        else
        {
            nlsErrorString.InsertParams( (const NLS_STR * * const) apnlsParamStrings );
            if ( !nlsErrorString )
            {
                DBGEOL( SZ("NETUI: MsgPopup(): first param insertion failed") );
            }
        }
    }

    if ( !nlsErrorString )
    {
        DBGEOL( SZ("NETUI: MspPopup(): Load of errAPI " << errAPI << " failed.") );
        nlsErrorString.Reset();
        ASSERT( nlsErrorString.QueryError() == NERR_Success );
    }

    INT cParams = 0;
    if (apnlsParams != NULL)
    {
        for (cParams = 0; apnlsParams[cParams] != NULL; cParams++) {};
    }

    NLS_STR ** apnlsNewParams = (NLS_STR **) new PVOID[cParams+2];
    if (apnlsNewParams == NULL)
    {
        return MsgPopup( wnd, ERROR_NOT_ENOUGH_MEMORY );
    }

    // do not return until apnlsNewParams freed

    apnlsNewParams[0] = &nlsErrorString;
    for (INT i = 1; i <= cParams; i++)
    {
        apnlsNewParams[i] = apnlsParams[i-1];
    }

    apnlsNewParams[cParams+1] = NULL;

    POPUP popup( wnd.QueryHwnd(), msgid, msgsev, ulHelpTopic, nButtons,
                 (const NLS_STR * * const) apnlsNewParams, nDefButton );

    delete apnlsNewParams;

    return popup.Show();
}


#if 0 // strlist forms never used
/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: The >2 insert string MsgPopup function, just like the 1 & 2
              MsgPopup, only it stores the insert strings in a strlst

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              UINT nButtons,
              STRLIST & strlst, UINT nDefButton )
{
    POPUP popup(wnd.QueryHwnd(), msgid, msgsev,
                HC_DEFAULT_HELP, nButtons, strlst, nDefButton);
    return popup.Show();
}


/*******************************************************************

    NAME:     MsgPopup

    SYNOPSIS: The "Works" MsgPopup, 1/2 lb. patty with everything

    ENTRY:

    EXIT:

    NOTES:    Takes insert strings in a STRLIST (which may be empty).

    HISTORY:
        beng        04-Oct-1991 Win32 conversion
        beng        17-Jun-1992 Restructuring

********************************************************************/

INT MsgPopup( const OWNINGWND & wnd, MSGID msgid, MSG_SEVERITY msgsev,
              ULONG     ulHelpContext,
              UINT      nButtons,
              STRLIST & strlst,
              UINT      nDefButton )
{
    POPUP popup(wnd.QueryHwnd(), msgid, msgsev,
                ulHelpContext, nButtons, strlst, nDefButton);
    return popup.Show();
}
#endif // never used
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\blttcurs.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltcurs.cxx
    Misc BLT cursor extensions

    FILE HISTORY:
        DavidHov    13-Mar-1991     Created
        beng        14-May-1991     Exploded blt.hxx into components
        beng        05-Mar-1992     Removed load-by-name resource stuff
        KeithMo     07-Aug-1992     STRICTified.
*/

#include "pchblt.hxx"   // Precompiled header

/**********************************************************************

    NAME:       TIME_CURSOR::TIME_CURSOR

    SYNOPSIS:   Construct a timed cursor

    ENTRY:      cMsInterval - interval in milliseconds
                idResourceBase - ID of first cursor in sequence

    EXIT:       Cursors loaded; first cursor shown

    NOTES:

    HISTORY:
        DavidHov    13-Mar-1991 Created
        beng        05-Oct-1991 Win32 conversion
        beng        05-Mar-1992 Loads resources by number
        beng        03-Aug-1992 Dllization

**********************************************************************/

TIME_CURSOR::TIME_CURSOR( UINT cMsInterval, UINT idResourceBase )
    : _cMsInterval(cMsInterval),
      _fState(FALSE) // not on... yet
{
    HMODULE hmod = BLT::CalcHmodRsrc(idResourceBase);
    UINT ihCursors = 0;

    // From the base, load cursors sequentially until we find no more,
    // or else until we read end-of-range

    for (UINT idResourceLoad = idResourceBase;
         ihCursors < TIME_CURSOR_MAX-1 ;
         ihCursors++, idResourceLoad++ )
    {
        HCURSOR h = ::LoadCursor( hmod, MAKEINTRESOURCE(idResourceLoad) );
        if ( h == NULL )
            break;
        _ahCursors[ihCursors] = h;
    }

    // If no cursors were found, set the first entry in the table
    // to the standard wait cursor.

    if ( ihCursors == 0 )
    {
        _ahCursors[ihCursors++] = ::LoadCursor(NULL, IDC_WAIT);
    }

    // Delimit the table with NULL.

    _ahCursors[ ihCursors ] = NULL;

    // Show the first cursor. Don't use operator++, because we
    // must remember the user's current cursor.

    _ihCursor = 0;
    _hCursPrev = Set( _ahCursors[0] );
    _fState = TRUE;
    _cMsLast = ::GetCurrentTime();
}


/**********************************************************************

    NAME:       TIME_CURSOR::~TIME_CURSOR

    SYNOPSIS:   Dtor for timed cursor

    HISTORY:
        DavidHov    13-Mar-1991     Created

**********************************************************************/

TIME_CURSOR::~TIME_CURSOR()
{
    TurnOff();
    Show( TRUE );
}


/*******************************************************************

    NAME:       TIME_CURSOR::operator++

    SYNOPSIS:   Increments the cursor if define interval has elapsed.

    NOTES:      This operator allows the caller to increment the cursor
                as often (or as infrequently) as convenient, knowing
                that the cursor will only be changed according to the
                interval defined during construction; the default is
                every 2 seconds.

    HISTORY:
        davidhov     18-Mar-1991     created

********************************************************************/

INT TIME_CURSOR::operator++()
{
    DWORD cMsCurrent = ::GetCurrentTime();

    if ( cMsCurrent - _cMsLast > (DWORD)_cMsInterval )
    {
       _cMsLast = cMsCurrent;
       if ( _ahCursors[ ++_ihCursor ] == NULL )
         _ihCursor = 0;
       Set( _ahCursors[ _ihCursor ] );
    }
    return _ihCursor;
}


/*******************************************************************

    NAME:       TIME_CURSOR::TurnOn

    SYNOPSIS:   Sets the time cursor to its ON state; that is,
                is sets the cursor to the current cursor in the cycle.

    HISTORY:
        davidhov  18-Mar-1991     created

********************************************************************/

VOID TIME_CURSOR::TurnOn()
{
    if ( _fState )
    {
        //  Already turned on.  Do nothing.
    }
    else
    {
        Set( _ahCursors[ _ihCursor ] );
        Show( TRUE );

        _fState = TRUE;
    }
}


/*******************************************************************

    NAME:       TIME_CURSOR::TurnOff

    SYNOPSIS:   Sets the time cursor to its OFF state; that is, it
                restores the cursor to the state it was in when the
                TIME_CURSOR was constructed.

    HISTORY:
        davidhov   18-Mar-1991     created

********************************************************************/

VOID TIME_CURSOR::TurnOff()
{
    if ( ! _fState )
    {
        //  Already turned off.  Do nothing.
    }
    else
    {
        Show( FALSE );
        Set( _hCursPrev );

        _fState = FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltrect.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltrect.hxx
    Rectangle functions

    FILE HISTORY:
        terryk      29-Jul-1991 Created
        terryk      16-Aug-1991 Code review changed.
                                Attend: rustanl davidhov davidbul terryk
        beng        09-Oct-1991 Added XYPOINT members (once all inline)
*/

#include "pchblt.hxx"   // Precompiled header

/******************************************************************

    NAME:       XYRECT

    SYNOPSIS:   Constructor

    HISTORY:
        terryk      29-Jul-1991 Created
        beng        09-Oct-1991 Added window-rect calculation;
                                simplified
        beng        12-May-1992 Fixed bug in xy, dxy ctor
        beng        28-May-1992 Make pwnd arg const

*******************************************************************/

XYRECT::XYRECT()
{
    _rect.left = 0;
    _rect.top  = 0;
    _rect.right  = 0;
    _rect.bottom = 0;
}

XYRECT::XYRECT( XYPOINT xyUl, XYPOINT xyLr )
{
    _rect.left = xyUl.QueryX();
    _rect.top  = xyUl.QueryY();
    _rect.right  = xyLr.QueryX();
    _rect.bottom = xyLr.QueryY();
}

XYRECT::XYRECT( XYPOINT xy, XYDIMENSION dxy )
{
    _rect.left = xy.QueryX();
    _rect.top  = xy.QueryY();
    _rect.right  = dxy.QueryWidth() + xy.QueryX();
    _rect.bottom = dxy.QueryHeight() + xy.QueryY();
}

XYRECT::XYRECT( INT xUl, INT yUl, INT xLr, INT yLr )
{
    _rect.left = xUl;
    _rect.top  = yUl;
    _rect.right  = xLr;
    _rect.bottom = yLr;
}

XYRECT::XYRECT( const RECT & rect )
{
    _rect = rect;
}

XYRECT::XYRECT( HWND hwnd, BOOL fClientOnly )
{
    UIASSERT( hwnd != NULL );

    if (fClientOnly)
        ::GetClientRect( hwnd, &_rect );
    else
        ::GetWindowRect( hwnd, &_rect );
}

XYRECT::XYRECT( const WINDOW *pwnd, BOOL fClientOnly )
{
    UIASSERT( pwnd != NULL );

    if (fClientOnly)
        ::GetClientRect( pwnd->QueryHwnd(), &_rect );
    else
        ::GetWindowRect( pwnd->QueryHwnd(), &_rect );
}

XYRECT::XYRECT( const XYRECT & rect )
{
    _rect = rect._rect;
}


/*********************************************************************

    NAME:       XYRECT::operator=

    SYNOPSIS:   assign operation

    ENTRY:      XYRECT rect - the source xyrect

    RETURN:     XYRECT &rect - the result xyrect

    HISTORY:
        terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::operator=( const XYRECT & rect )
{
    _rect = rect._rect;
    return *this;
}


/*********************************************************************

    NAME:       XYREC::Offset

    SYNOPSIS:   Move the given rectangle by the specified offsets

    ENTRY:      INT x - x position
                INT y - y position
                OR
                XYDIMENSION xy - xy dimension which specify width and height

    RETURN:     XYRECT & - the resultant xyrect

    HISTORY:
                terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::Offset( INT dx, INT dy )
{
    ::OffsetRect( &_rect, dx, dy );
    return *this;
}

XYRECT& XYRECT::Offset( XYDIMENSION dxy )
{
    ::OffsetRect( &_rect, dxy.QueryWidth(), dxy.QueryHeight() );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::Inflate

    SYNOPSIS:   Increase ot decrease the width and height of the rectangle

    ENTRY:      INT x - x value
                INT y - y value
                OR
                XYDIMENSION dxy - the width and height

    RETURN:     XYRECT &rect - the resultant xyrect

    HISTORY:
        terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::Inflate( INT dx, INT dy )
{
    ::InflateRect( &_rect, dx, dy );
    return *this;
}

XYRECT& XYRECT::Inflate( XYDIMENSION dxy )
{
    ::InflateRect( &_rect, dxy.QueryWidth(), dxy.QueryHeight() );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::CalcIntersect

    SYNOPSIS:   Create the intersection of 2 existing rectangle

    ENTRY:      XYRECT xysrc1 - the first rectangle
                XYRECT xysrc2 - the second rectangle

    RETURN:     XYRECT & - the resultant rectangle - the intersection of
                    the two source rectangles

    HISTORY:
        terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::CalcIntersect( const XYRECT &xySrc1, const XYRECT & xySrc2 )
{
    ::IntersectRect( &_rect, (RECT *)&xySrc1._rect, (RECT *)&xySrc2._rect );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::CalcUnion

    SYNOPSIS:   Create the union of two rectangles

    ENTRY:      XYRECT xysrc1 - the first rectangle
                XYRECT xysrc2 - the second rectangle

    RETURN:     XYRECT & - the resultant rectangle - the union of the two

    HISTORY:
        terryk  29-Jul-1991 Created

*********************************************************************/

XYRECT& XYRECT::CalcUnion( const XYRECT &xySrc1, const XYRECT &xySrc2 )
{
    ::UnionRect( &_rect, (RECT *)&xySrc1._rect, (RECT *)&xySrc2._rect );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::operator+=

    SYNOPSIS:   adjust the current rectangle by adding the dimension of
                the passing parameter.

    ENTRY:      const XYRECT& xySrc - the dimension to be adjust

    RETURN:     the resultant rectangle

    HISTORY:
        terryk  16-Aug-1991     Created

*********************************************************************/

XYRECT& XYRECT::operator+=( const XYRECT& xySrc )
{
    AdjustLeft( xySrc._rect.left );
    AdjustRight( xySrc._rect.right );
    AdjustTop( xySrc._rect.top );
    AdjustBottom( xySrc._rect.bottom );
    return *this;
}


/*********************************************************************

    NAME:       XYRECT::ContainsXY

    SYNOPSIS:   check whether the point is located within the rectangle or
                not

    ENTRY:      XYPOINT xy - the xy point to be checked

    RETURN:     TRUE is the point is located within the rectangle.
                FALSE otherwise

    HISTORY:
        terryk      29-Jul-1991 Created
        beng        09-Oct-1991 Win32 conversion

*********************************************************************/

BOOL XYRECT::ContainsXY( XYPOINT xy ) const
{
    return ::PtInRect( (RECT *)&_rect, xy.QueryPoint() );
}


/*********************************************************************

    NAME:       XYRECT::IsEmpty

    SYNOPSIS:   check whether the rectangle is empty or not

    RETURN:     TRUE if the rectangle is empty.
                FALSE otherwise

    HISTORY:
        terryk  29-JUl-1991 Created

*********************************************************************/

BOOL XYRECT::IsEmpty() const
{
    return ::IsRectEmpty( (RECT *) &_rect );
}


/*********************************************************************

    NAME:       XYRECT::operator==

    SYNOPSIS:   given a rectangle. Check whether it is equal to the
                original rectangle

    ENTRY:      XYRECT &xyrect - rectangle to be compared

    RETURN:     TRUE if the rectangle are the same
                FALSE otherwise

    HISTORY:
                terryk  29-Jul-1991 Created

*********************************************************************/

BOOL XYRECT::operator==( const XYRECT& xyrect ) const
{
    return ::EqualRect( (RECT *)&_rect, (RECT *)&xyrect._rect );
}


/*********************************************************************

    NAME:       XYRECT::ConvertClientToScreen

    SYNOPSIS:   convert the rectangle to Screen coordinate

    ENTRY:      HWND hwnd - the associated window handle

    HISTORY:
        terryk      15-Aug-1991 Created
        beng        09-Oct-1991 Win32 conversion

*********************************************************************/

VOID XYRECT::ConvertClientToScreen( HWND hwnd )
{
    UIASSERT( hwnd != NULL );

    POINT pt;

    pt.x = _rect.left;
    pt.y = _rect.top;
    ::ClientToScreen( hwnd, &pt );
    _rect.left = pt.x;
    _rect.top  = pt.y;

    pt.x = _rect.right;
    pt.y = _rect.bottom;
    ::ClientToScreen( hwnd, &pt );
    _rect.right  = pt.x;
    _rect.bottom = pt.y;
}


/*********************************************************************

    NAME:       XYRECT::ConvertScreenToClient

    SYNOPSIS:   convert the current rectangle coordinate to client
                coordinate

    ENTRY:      HWND hwnd - the associated window handle

    HISTORY:
        terryk      15-Aug-1991 Created
        beng        09-Oct-1991 Win32 conversion

*********************************************************************/

VOID XYRECT::ConvertScreenToClient( HWND hwnd )
{
    UIASSERT( hwnd != NULL );

    POINT pt;

    pt.x = _rect.left;
    pt.y = _rect.top;
    ::ScreenToClient( hwnd, &pt );
    _rect.left = pt.x;
    _rect.top  = pt.y;

    pt.x = _rect.right;
    pt.y = _rect.bottom;
    ::ScreenToClient( hwnd, &pt );
    _rect.right  = pt.x;
    _rect.bottom = pt.y;
}


/*******************************************************************

    NAME:       XYPOINT::ScreenToClient

    SYNOPSIS:   Convert a point from screen to client coordinates

    ENTRY:      HWND - handle of target window

    EXIT:       Coordinate system changed

    NOTES:

    HISTORY:
        beng        09-Oct-1991 Created

********************************************************************/

VOID XYPOINT::ScreenToClient( HWND hwnd )
{
    POINT pt;
    pt.x = _x;
    pt.y = _y;
    ::ScreenToClient( hwnd, &pt );
    _x = pt.x;
    _y = pt.y;
}


/*******************************************************************

    NAME:       XYPOINT::ClientToScreen

    SYNOPSIS:   Convert a point from client to screen coordinates

    ENTRY:      HWND - handle of current client window

    EXIT:       Coordinate system changed

    NOTES:

    HISTORY:
        beng        09-Oct-1991 Created

********************************************************************/

VOID XYPOINT::ClientToScreen( HWND hwnd )
{
    POINT pt;
    pt.x = _x;
    pt.y = _y;
    ::ClientToScreen( hwnd, &pt );
    _x = pt.x;
    _y = pt.y;
}


/*******************************************************************

    NAME:       XYPOINT::InRect

    SYNOPSIS:   Return whether the point is within a rectangle

    ENTRY:      xyr - rectangle under consideration

    RETURNS:    TRUE if point fits within rectagle

    NOTES:

    HISTORY:
        beng        09-Oct-1991 Created

********************************************************************/

BOOL XYPOINT::InRect( const XYRECT & xyr ) const
{
    POINT pt;
    pt.x = _x;
    pt.y = _y;

    return !!(::PtInRect( (RECT*)(const RECT *)xyr, pt ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltwin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltwin.cxx
    BLT base window class definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        beng        14-May-1991 Exploded blt.hxx into components
        terryk      10-Jul-1991 Added IsEnable to Window class
        beng        31-Jul-1991 Reloc'd fClientGen'dMsg to class
        terryk      12-Aug-1991 Change QueryWindowRect to QueryClient
                                window rect
        terryk      20-Aug-1991 Change QueryClientRect back to
                                QueryWindowRect
        beng        30-Sep-1991 Added ASSOCHWNDTHIS class
        beng        18-Oct-1991 Threw in some tracing
        Yi-Hsins     8-Jan-1991 Added HasFocus method
        terryk      02-Apr-1992 Added Z position in SetPos
        terryk      28-Apr-1992 fixed Z position problem in SetPos
        KeithMo     11-Nov-1992 Added new ctor form and Center method.
        Yi-HsinS    10-Dec-1992 Added CalcFixedHeight
        DavidHov    17-Sep-1993 Changes for C8 and re-dllization
*/


#include "pchblt.hxx"   // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

#define WIN32_REMOVEPROP_BUG 1

// Indicates that the message was generated internally and not
// by the user manipulating controls.
//
BOOL WINDOW::_fClientGeneratedMessage = FALSE;

const TCHAR * ASSOCHWNDTHIS::_pszPropThisLo = SZ("BltPropThisL");
const TCHAR * ASSOCHWNDTHIS::_pszPropThisHi = SZ("BltPropThisH");


#if defined(DEBUG) && defined(TRACE) && 0
DBGSTREAM& operator<<(DBGSTREAM &out, const WINDOW * pwnd)
{
    TCHAR szBuf[12];
    FMT(szBuf, SZ("%lx"), (ULONG)pwnd);
    out << SZ("WINDOW ") << szBuf;

    return out;
}

DBGSTREAM& operator<<(DBGSTREAM &out, HWND hwnd)
{
    out << (ULONG)hwnd;

    return out;
}
#endif

#ifndef max
inline INT max(INT a, INT b)
{
    return (a > b) ? a : b;
}
#endif

/**********************************************************************

    NAME:       WINDOW::WINDOW

    SYNOPSIS:   Constructor for the WINDOW object.

    ENTRY:      Without parameters, leaves an empty object which can
                later adopt an existing window (via SetHwnd).

        - or -

                pszClassName - class name of window class
                flStyle      - dword of style bits
                pwndOwner    - pointer to owner window
                cid          - control ID.  Default is 0, which
                               means no ID (and no menu if not
                               a WS_CHILD).


    NOTES:
        The parmless WINDOW object does no real construction;
        rather, it is a repository for a large body of common
        methods and information, much of which can only be
        calculated well into the construction process by one
        of its derived classes.  Hence this version of the ctor
        does nearly nothing.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        25-Apr-1991 Removed unused hwndOwner parm
        beng        07-May-1991 Added CreateWindow versions
        beng        15-May-1991 Added CID child-window support
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

WINDOW::WINDOW(
    const TCHAR * pszClassName,
    ULONG         flStyle,
    const WINDOW *pwndOwner,
    CID           cid )
    : _hwnd(NULL),
      _fCreator(FALSE)
{
    // CODEWORK: make these const with C7

    UIASSERT( ((cid == 0) || (flStyle & WS_CHILD)) );

    HWND hwndOwner = (pwndOwner == 0) ? 0 : pwndOwner->_hwnd;

    HWND hwnd = ::CreateWindow(pszClassName,
                               SZ(""), flStyle,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               hwndOwner, (HMENU)LongToHandle(cid), hmodBlt, 0);
    if (hwnd == 0)
    {
        ReportError(hwnd == 0);
        return;
    }

    _hwnd = hwnd;
    _fCreator = TRUE;
}


WINDOW::WINDOW()
    : _hwnd( NULL ),
    _fCreator( FALSE )
{
    ; // nothing else to do
}


WINDOW::WINDOW( HWND hwnd )
    : _hwnd( hwnd ),
    _fCreator( FALSE )
{
    ; // nothing else to do
}


/**********************************************************************

    NAME:       WINDOW::~WINDOW

    SYNOPSIS:   Destructor of WINDOW

    ENTRY:      Valid WINDOW base.  If _fCreator set, has a window
                object (id'd by _hwnd) which it needs to destroy.

    EXIT:       Window destroyed

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        07-May-1991     Added DestroyWindow function

**********************************************************************/

WINDOW::~WINDOW()
{
    if (_fCreator)
    {
        if (!::DestroyWindow(_hwnd))
        {
            DWORD err = ::GetLastError();
            DBGEOL( "NETUI: WINDOW::dtor: DestroyWindow( " << ((DWORD)(DWORD_PTR)_hwnd)
                    << " ) failed with error " << err );
            // ASSERT( FALSE ); removing again
        }
    }
}


/*******************************************************************

    NAME:       WINDOW::ResetCreator

    SYNOPSIS:   Resets the fCreator flag

    ENTRY:      fCreator is set; presumably, we just noticed that
                some cad called DestroyWindow(this->QueryHwnd()).

    EXIT:       fCreator is clear

    NOTES:
        This is for when ClientWindow notices that some outside
        agency called DestroyWindow on its window.  Under normal
        circumstances it should never run.

    HISTORY:
        beng        10-May-1991     Created

********************************************************************/

VOID WINDOW::ResetCreator()
{
    UIASSERT(_fCreator);
    _fCreator = FALSE;
}


/*******************************************************************

    NAME:       WINDOW::SetHwnd

    SYNOPSIS:   Sets the window-handle member of WINDOW.
                This is integral to complete object construction
                (i.e. including derived classes).

    ENTRY:      hwnd - new value of window handle

    EXIT:       _hwnd has been set

    NOTES:
        This method should be called only once in the lifetime of
        a window.

    HISTORY:
        beng        25-Apr-1991     Relocated to here from class def'n
        beng        07-May-1991     Updated to honor _fCreator

********************************************************************/

VOID WINDOW::SetHwnd( HWND hwnd )
{
    UIASSERT(!_fCreator);   // better not have created any window
    UIASSERT(_hwnd == 0);   // or for that matter have already called this

    _hwnd = hwnd;
}


/*******************************************************************

    NAME:       WINDOW::QueryHwnd

    SYNOPSIS:   Return the Windows HWND associated with the WINDOW

    RETURNS:    the value of _hwnd

    NOTES:

    HISTORY:
        beng        25-Apr-1991     Relocated to here from class def'n

********************************************************************/

HWND WINDOW::QueryHwnd() const
{
    return _hwnd;
}


/**********************************************************************

    NAME:       WINDOW::QueryOwnerHwnd

    SYNOPSIS:   Return the hwnd of the window's owner

    RETURNS:    HWND of window's owner

    NOTES:

    HISTORY:
       beng     25-Apr-1991 Moved out of the class def'n
       beng     09-Oct-1991 Win32 conversion

***********************************************************************/

HWND WINDOW::QueryOwnerHwnd() const
{
#if defined(WIN32)
    return (HWND) ::GetWindowLongPtr( _hwnd, GWLP_HWNDPARENT );
#else
    return (HWND) ::GetWindowWord( _hwnd, GWW_HWNDPARENT );
#endif
}


/**********************************************************************

    NAME:       WINDOW::Command

    SYNOPSIS:   This method sends a message to the window.

    ENTRY:
        usMsg               Message
        wParam, lParam      Message parameters

    RETURNS:    The return code of the message.

    CAVEATS:
        This method is obviously not host environment independent.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

ULONG_PTR WINDOW::Command( UINT nMsg, WPARAM wParam, LPARAM lParam ) const
{
    return ::SendMessage( _hwnd, nMsg, wParam, lParam );
}


/**********************************************************************

    NAME:       WINDOW::QueryStyle

    SYNOPSIS:   Return the style bits for the window

    RETURNS:    Style bits (dword)

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

ULONG WINDOW::QueryStyle() const
{
    return (ULONG) ::GetWindowLong( _hwnd, GWL_STYLE );
}


/**********************************************************************

    NAME:       WINDOW::SetStyle

    SYNOPSIS:   Set the style bits for the window

    NOTES:
        This is a protected member function, intended to allow controls
        to change their style.

    HISTORY:
        beng        13-Feb-1992 Created

**********************************************************************/

VOID WINDOW::SetStyle( ULONG nValue )
{
    ::SetWindowLong( _hwnd, GWL_STYLE, (LONG)nValue );
}


/**********************************************************************

    NAME:       WINDOW::QueryClientRect

    SYNOPSIS:   get the client coordinates of a window's client area

    ENTRY:      RECT * pRect - the returned coordinates

    EXIT:       RECT * pRect - fill the data structure with the window's
                               coordinates.

    NOTES:
        Consider instead constructing an XYRECT with this window
        as a parameter.

    HISTORY:
        terryk      20-Jul-1991 Created
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Added XYRECT version

**********************************************************************/

VOID WINDOW::QueryClientRect( RECT * pRect ) const
{
    ::GetClientRect( _hwnd, pRect );
}

VOID WINDOW::QueryClientRect( XYRECT * pxyxy ) const
{
    XYRECT xyxy( _hwnd, TRUE );
    *pxyxy = xyxy;
}


/*********************************************************************

    NAME:       WINDOW::QueryWindowRect

    SYNOPSIS:   get the window's screen coordinate

    ENTRY:      RECT *pRect - rectangle data structure to store the
                information.

    NOTES:
        Consider instead constructing an XYRECT with this window
        as a parameter.

    HISTORY:
        terryk      2-Aug-1991  Created
        beng        09-Oct-1991 Added XYRECT version

**********************************************************************/

VOID WINDOW::QueryWindowRect( RECT * pRect ) const
{
    ::GetWindowRect( _hwnd, pRect );
}

VOID WINDOW::QueryWindowRect( XYRECT * pxyxy ) const
{
    XYRECT xyxy( _hwnd, FALSE );
    *pxyxy = xyxy;
}


/**********************************************************************

    NAME:       WINDOW::SetText

    SYNOPSIS:
        This method sets the text of a window.  The text of an application
        window or dialog is the caption, whereas it is the text contents of
        a controls for many controls.

    ENTRY:
         psz             A pointer to the text
     or
         nls             NLS text string

    EXIT:

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        rustanl     27-Apr-1991 Changed PSZ to const TCHAR *
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

VOID WINDOW::SetText( const TCHAR * psz )
{
    SetClientGeneratedMsgFlag( TRUE ) ;
    ::SetWindowText( _hwnd, psz );
    SetClientGeneratedMsgFlag( FALSE ) ;
}


VOID WINDOW::SetText( const NLS_STR & nls )
{
    SetClientGeneratedMsgFlag( TRUE ) ;
    ::SetWindowText( _hwnd, nls.QueryPch() );
    SetClientGeneratedMsgFlag( FALSE ) ;
}


/**********************************************************************

    NAME:       WINDOW::QueryText

    SYNOPSIS:   Returns the text of a window.

    ENTRY:
        pszBuffer   A pointer to a buffer, where the window text
                    will be copied.
        cbBufSize   The size of this buffer.  The window text
                    copied to the buffer will be truncated if
                    the buffer is not big enough.

            - or -

        pnls        Pointer to a NLS_STR

    RETURNS:
        0 if successful; NERR_BufTooSmall if given buffer too small.

    NOTES:
        The length of the window text can be retrieved by calling
        WINDOW::QueryTextLength, while the storage needed to copy
        that text is available via WINDOW::QueryTextSize.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        23-May-1991 Changed return type; made const
        beng        10-Jun-1991 Tinkered for Unicode
        beng        04-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

**********************************************************************/

APIERR WINDOW::QueryText( TCHAR * pszBuffer, UINT cbBufSize ) const
{
    UINT cbActual = QueryTextSize();

    if (cbBufSize < cbActual)
        return NERR_BufTooSmall;

    if (cbBufSize > 0 && pszBuffer == NULL)
        return ERROR_INVALID_PARAMETER;

    // This Win API works in total TCHARs, including terminator.
    //
    ::GetWindowText(_hwnd, (TCHAR *)pszBuffer, cbBufSize/sizeof(TCHAR) );

    return 0;
}

APIERR WINDOW::QueryText( NLS_STR * pnls ) const
{
    if (pnls == NULL)
        return ERROR_INVALID_PARAMETER;

    UINT cbActual = QueryTextSize();

    BLT_SCRATCH scratch( cbActual );
    if (!scratch)
        return scratch.QueryError();

    ::GetWindowText( _hwnd,
                     (TCHAR*)scratch.QueryPtr(),
                     scratch.QuerySize()/sizeof(TCHAR) );

    return pnls->CopyFrom((TCHAR*)scratch.QueryPtr());
}


/**********************************************************************

    NAME:       WINDOW::QueryTextLength

    SYNOPSIS:   Returns the length of the window text.
                See WINDOW::SetText for a description of "window text".

    RETURNS:    The length, in actual characters (as opposed to the
                byte-characters of strlen), of the window text.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        23-May-1991 Made const
        beng        10-Jun-1991 Changed return type
        beng        09-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

***********************************************************************/

INT WINDOW::QueryTextLength() const
{
    return ::GetWindowTextLength( _hwnd );
}


/*******************************************************************

    NAME:       WINDOW::QueryTextSize

    SYNOPSIS:   Returns the byte count of the window text,
                including the terminating character

    RETURNS:    Count of bytes

    NOTES:

    HISTORY:
        beng        10-Jun-1991 Created
        beng        09-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

********************************************************************/

INT WINDOW::QueryTextSize() const
{
    INT cchRet = ::GetWindowTextLength( _hwnd );

    return (cchRet + 1) * sizeof(TCHAR);
}


/**********************************************************************

    NAME:       WINDOW::ClearText

    SYNOPSIS:   Clears the window text of the window.

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID WINDOW::ClearText()
{
    SetText( SZ("") );
}


/**********************************************************************

    NAME:       WINDOW::Show

    SYNOPSIS:   This method shows or hides a window.

    ENTRY:
       f        Indicates whether to show or hide the window:
                TRUE to show the window, and FALSE to hide it.

    RETURNS:    The previous state of the windows:
                  FALSE if the window was previously hidden
                  TRUE if the window was previously visible

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

BOOL WINDOW::Show( BOOL f )
{
    return ::ShowWindow( _hwnd, ( f ? SW_SHOW : SW_HIDE ));
}


/**********************************************************************

    NAME:       WINDOW::Enable

    SYNOPSIS:   Enables or disables a window.

    ENTRY:
        f       Indicates whether to enable or disable the
                window:  TRUE to enable, and FALSE to disable.

    EXIT:
        Window is enabled or disabled (duh) as requested.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion
        beng        26-Dec-1991 With full understanding, removed some tracery

**********************************************************************/

VOID WINDOW::Enable( BOOL f )
{
    if ( f != IsEnabled() )
    {
        ::EnableWindow( _hwnd, f );
    }
}


/*********************************************************************

    NAME:       WINDOW::IsEnabled

    SYNOPSIS:   return the current status of the window

    RETURN:     return TRUE if the window is enable, FALSE if the window
                is disable.

    HISTORY:
        terryk      8-Jul-91    Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

BOOL WINDOW::IsEnabled() const
{
    return !! ::IsWindowEnabled( _hwnd );
}


/**********************************************************************

    NAME:       WINDOW::SetRedraw

    SYNOPSIS:   Sets or clears the redraw flag of the window.

    ENTRY:
       f        Indicates whether to set or clear the redraw flag.
                TRUE sets it, whereas FALSE clears it.
                TRUE is the default value for this parameter.

    EXIT:

    NOTES:
        Setting the redraw flag on does not refresh listboxes.

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID WINDOW::SetRedraw( BOOL f )
{
    Command( WM_SETREDRAW, f );
}


/**********************************************************************

    NAME:       WINDOW::Invalidate

    SYNOPSIS:   Invalidates some or all of the client area of the window.

    ENTRY:
       fErase   Indicates whether the window's background is to
                be erased (default FALSE).  This version invalidates
                the entire client region.

       rect     Rectangle to invalidate within client area.  This version
                doesn't erase.

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion
        beng        13-Feb-1992 Rolled in CLIENT_WINDOW::Repaint

**********************************************************************/

VOID WINDOW::Invalidate( BOOL fErase )
{
    ::InvalidateRect( _hwnd, NULL, fErase );
}

VOID WINDOW::Invalidate( const XYRECT & rect )
{
    ::InvalidateRect( _hwnd, (RECT*)(const RECT *)rect, FALSE );
}


/*******************************************************************

    NAME:       WINDOW::RepaintNow

    SYNOPSIS:   Force an immediate repaint of the window

    EXIT:       Window is completely valid, and has been repainted
                irregardless of outstanding PAINT messages

    HISTORY:
        beng        10-May-1991 Implemented
        beng        13-Feb-1992 Relocated to WINDOW from CLIENT_WINDOW

********************************************************************/

VOID WINDOW::RepaintNow()
{
    ::UpdateWindow( _hwnd );
}


/*******************************************************************

    NAME:       WINDOW::ShowFirst

    SYNOPSIS:   The first "Show" call for a client or owned window

    ENTRY:      Window has never been shown - just created

    EXIT:       Window is visible on screen

    NOTES:
        A window's creator should make this call when it is ready
        for the window to appear.

    HISTORY:
        beng        31-Jul-1991     Created

********************************************************************/

VOID WINDOW::ShowFirst()
{
    Show(TRUE);
    Invalidate(FALSE);
}


/*******************************************************************

    NAME:      WINDOW::SetPos

    SYNOPSIS:  Moves a windows to the new cooridinates

    ENTRY:     xy - New position of window,
               fRepaint = TRUE if repaint after move
               WINDOW *pwin - the Z value for the control.
                      The TAB order of the control is placed after pwin.
                      If pwin is NULL, the tab order of the control
                      will be the same as its position in the resource
                      file or according to its creation time.

    NOTES:     Cooridinates are relative to:
                Screen if pop-up window
                Client if child window

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Uses XYPOINT
        beng        09-Oct-1991 Win32 conversion
        terryk      02-Apr-1992 Added Z position

********************************************************************/

VOID WINDOW::SetPos( XYPOINT xy, BOOL fRepaint, WINDOW *pwin )
{
#if 0 // this is the old way - required a Query before could Set
    INT nWidth, nHeight;

    QuerySize( &nWidth, &nHeight );

    ::MoveWindow( _hwnd, xy.QueryX(), xy.QueryY(),
                  nWidth, nHeight, fRepaint );
#else
    ::SetWindowPos(_hwnd, ( pwin == NULL ) ? 0 : pwin->QueryHwnd(),
                   xy.QueryX(), xy.QueryY(), 0, 0,
                   ((( pwin == NULL ) ?  SWP_NOZORDER : 0 ) | SWP_NOSIZE |
                   (fRepaint?0:SWP_NOREDRAW)));
#endif
}


/*******************************************************************

    NAME:       WINDOW::QueryPos

    SYNOPSIS:   Get the current position (top left corner) of *this

    RETURNS:    Current position of window

    NOTES:
        Cooridinates are relative to:
        Screen if pop-up window
        Client area of parent if child window

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Added XYPOINT version
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Withdrew vanilla POINT version

********************************************************************/

XYPOINT WINDOW::QueryPos() const
{
    RECT rc;
    ::GetWindowRect(_hwnd, &rc);

    XYPOINT xy(rc.left, rc.top);

    /* If the window is a child window, then we need to get the coordinates
     * relative to the parent's client area
     */
    if (IsChild())
        xy.ScreenToClient(QueryOwnerHwnd());

    return xy;
}


/*******************************************************************

    NAME:       WINDOW::SetSize

    SYNOPSIS:   Sets the width and height of a window

    ENTRY:      nWidth, nHeight - width and height for window
                -or-
                dxy - desired dimensions of window

    EXIT:

    NOTES:
        Size is not the client area, but full size including borders,
        menus and captions.

        This command causes the window to receive OnMove and OnSize
        events.

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Added XYDIM version
        beng        09-Oct-1991 Win32 conversion

********************************************************************/

VOID WINDOW::SetSize( INT cxWidth, INT cyHeight, BOOL fRepaint )
{
#if 0 // this is the old way - required a Query before could Set
    XYPOINT xy = QueryPos();

    ::MoveWindow( _hwnd, xy.QueryX(), xy.QueryY(),
                  cxWidth, cyHeight, fRepaint );

#else

    ::SetWindowPos(_hwnd, 0, 0, 0, cxWidth, cyHeight,
                   (SWP_NOZORDER|SWP_NOMOVE|(fRepaint?0:SWP_NOREDRAW)));
#endif
}

VOID WINDOW::SetSize( XYDIMENSION dxy, BOOL fRepaint )
{
    SetSize(dxy.QueryWidth(), dxy.QueryHeight(), fRepaint);
}


/*******************************************************************

    NAME:      WINDOW::QuerySize

    SYNOPSIS:  Get the current size of this window

    ENTRY:     pnWidth, pnHeight - pointers to receive
                                   current size of window

    EXIT:
        If px, py supplied, they've been loaded with X and Y.

        Otherwise, returns XYDIM.

    NOTES:

    HISTORY:
        Johnl       7-Feb-91    Created
        beng        15-May-1991 Added XYDIM version
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Win32 conversion

********************************************************************/

VOID WINDOW::QuerySize( INT *pnWidth, INT *pnHeight ) const
{
    RECT rcRect;
    ::GetWindowRect(_hwnd, &rcRect);

    *pnWidth  = rcRect.right - rcRect.left;
    *pnHeight = rcRect.bottom - rcRect.top;
}

XYDIMENSION WINDOW::QuerySize() const
{
    INT dx, dy;

    QuerySize(&dx, &dy);

    return XYDIMENSION(dx, dy);
}


/*******************************************************************

    NAME:       WINDOW::IsChild

    SYNOPSIS:   Determine whether window has CHILD style

    RETURNS:    TRUE if the WS_CHILD window style bits are set for window

    NOTES:

    HISTORY:
        Johnl       14-Feb-1991     Created
        beng        31-Jul-1991     Made 'const'

********************************************************************/

BOOL WINDOW::IsChild() const
{
    return ( WS_CHILD & QueryStyle() ) != 0 ;
}


/*******************************************************************

    NAME:     WINDOW::SetClientGeneratedMsgFlag

    SYNOPSIS: Sets the global flag _fClientGeneratedMessage.

    NOTES:
      Set to TRUE if this is a message we generated ourselves (and you don't
      want the shell dialog proc. to "process" it (i.e., send out notices
      to children etc.).  Be careful you only use this on messages that are
      sent immediately.

    HISTORY:
        Johnl       26-Apr-1991     Created

********************************************************************/

VOID WINDOW::SetClientGeneratedMsgFlag( BOOL fInClientGeneratedMessage )
{
    _fClientGeneratedMessage = fInClientGeneratedMessage;
}


/*******************************************************************

    NAME:     WINDOW::IsClientGeneratedMsg

    SYNOPSIS: Returns TRUE if the _fClientGeneratedMessage flag is set.
              This means the current message is a message we should
              ignore.

    HISTORY:
        Johnl       26-Apr-1991     Created

********************************************************************/

BOOL WINDOW::IsClientGeneratedMessage()
{
    return _fClientGeneratedMessage;
}


/*******************************************************************

    NAME:     WINDOW::HasFocus

    SYNOPSIS: Returns TRUE if the current window has the focus.

    HISTORY:
        Yi-HsinS    8-Jan-1992     Created

********************************************************************/

BOOL WINDOW::HasFocus( VOID ) const
{
    return ( QueryHwnd() == ::GetFocus() );
}


/*******************************************************************

    NAME:     WINDOW::Center

    SYNOPSIS: Centers the window above another window.

    ENTRY:    hwnd      - The window to center *this over.  If this
                          value is NULL, then the window is centered
                          over its parent.

    CODEWORK: It may be more aesthetically appealing to center
              child windows their parent's client area, rather
              than over the parent's window proper.

    HISTORY:
        KeithMo    11-Nov-1992     Created.

********************************************************************/

VOID WINDOW::Center( HWND hwnd )
{
    //
    //  If no window was specified, use the parent.
    //  If there is no parent, use the screen size.
    //

    INT xThis;
    INT yThis;

    XYRECT xycdThis;
    UIASSERT( !!xycdThis );

    QueryWindowRect( &xycdThis );

    if( hwnd == NULL )
    {
        hwnd = QueryOwnerHwnd();
    }

    if( hwnd == NULL )
    {
        HDC hdc;

        hdc = GetDC(_hwnd);
        if (!hdc) // JonN 01/23/00: PREFIX bug 444891
            return;

        xThis =  ( GetDeviceCaps(hdc, HORZRES) - xycdThis.CalcWidth()  ) / 2;

        yThis =  ( GetDeviceCaps(hdc, VERTRES) - xycdThis.CalcHeight() ) / 3;

        (void) ReleaseDC( _hwnd, hdc ); // JonN 01/23/00: PREFIX bug 444892
    }
    else
    {
        WINDOW windowParent( hwnd );
        UIASSERT( !!windowParent );

        //
        //  Get the bounding rectangles of this window & the
        //  parent window.  Note that QueryWindowRect returns
        //  *screen* coordinates!
        //

        XYRECT xycdParent;
        UIASSERT( !!xycdParent );

        windowParent.QueryWindowRect( &xycdParent );

        //
        //  Calculate the new window position relative
        //  to the parent.
        //

        xThis = xycdParent.QueryLeft() +
                ( xycdParent.CalcWidth()  - xycdThis.CalcWidth()  ) / 2;
        yThis = xycdParent.QueryTop() +
                ( xycdParent.CalcHeight() - xycdThis.CalcHeight() ) / 3;

    }

    XYPOINT xyThis( xThis, yThis );

    //
    //  Move the window into position.  The SetWindowPos API
    //  is documented as taking client coordinates when
    //  dealing with child windows, but it seems to actually
    //  want screen coordinates.
    //

    SetPos( xyThis );
}

/* Maximum height we expect bitmaps to be in the owner drawn list boxes
 */
const USHORT yMaxCDBitmap = 16;

/*******************************************************************

    NAME:       WINDOW::CalcFixedHeight

    SYNOPSIS:   Calculate height of fixed-size (single line) owner-draw object

    ENTRY:      hwnd   - handle to the window
                pmis   - as passed by WM_MEASUREITEM in lParam

    EXIT:

    RETURNS:    FALSE if the calculation fails for some reason

    NOTES:
        This is a static member of the class.

        This WM_MEASUREITEM message is sent before the
        WM_INITDIALOG message (except for variable size owner-draw
        list controls).  Since the window properties are not yet set
        up, the owner dialog cannot be called.

        The chosen solution for list controls is to assume that every
        owner-draw control will always have the same height as the font
        of that list control.  This is a very reasonable guess for most
        owner-draw list controls.  Since owner-draw list controls with
        variable size items call the owner for every item, the window
        properties will have been properly initialized by that time.  Hence,
        a client may respond to these messages through OnOther.

        Currently, owner-draw buttons are not supported.

    HISTORY:
        beng        21-May-1991 Created, from old BltDlgProc
        Yi-HsinS    10-Dec-1992 Moved from bltowin.cxx

********************************************************************/

BOOL WINDOW::CalcFixedHeight( HWND hwnd, UINT *pnHeight )
{
    DISPLAY_CONTEXT dc( hwnd );

    HFONT hFont = (HFONT)::SendMessage( hwnd, WM_GETFONT, 0, 0L );
    if ( hFont != NULL )
    {
        // Font isn't the system font
        dc.SelectFont( hFont );
    }

    TEXTMETRIC tm;
    if ( ! dc.QueryTextMetrics( &tm ))
        return FALSE;

    *pnHeight = max((USHORT)tm.tmHeight, yMaxCDBitmap);

    return TRUE;
}

/*******************************************************************

    NAME:       ASSOCHWNDTHIS::ASSOCHWNDTHIS

    SYNOPSIS:   Associates a hwnd with a pwnd

    ENTRY:      hwnd - handle of window
                pwnd - pointer to WINDOW

    EXIT:       Window has two properties added

    NOTES:
        This class inherits from BASE.  If the association fails,
        it will report an error.

    HISTORY:
        beng        30-Sep-1991 Created
        beng        07-Nov-1991 Error mapping

********************************************************************/

ASSOCHWNDTHIS::ASSOCHWNDTHIS( HWND hwnd, const VOID * pv )
    : _hwnd(hwnd)
{
    if (hwnd == 0 || pv == 0)
    {
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

#ifdef _WIN64
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)pv ))
    {
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
#else
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)LOWORD( (ULONG_PTR)pv )))
    {
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisHi, (HANDLE)HIWORD( (ULONG_PTR)pv )))
    {
        ::RemoveProp( hwnd, (TCHAR*)_pszPropThisLo );
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
#endif
}


/*******************************************************************

    NAME:       ASSOCHWNDTHIS::~ASSOCHWNDTHIS

    SYNOPSIS:   Disassociate a hwnd from the WINDOW object.

    ENTRY:      There are two properties on the hwnd which
                contain the seg:off of the WINDOW object.

    EXIT:       Those two props are dust

    NOTES:
        This might seem unnecessary - after all, won't the
        DestroyWindow delete these properties?

    HISTORY:
        beng        10-May-1991 Created as CLIENT_WINDOW::DisassocHwndPwnd
        beng        30-Sep-1991 Made own class
        beng        04-Jun-1992 A little error checking needed here

********************************************************************/

ASSOCHWNDTHIS::~ASSOCHWNDTHIS()
{
    if (QueryError() == NERR_Success)
    {
#if defined(WIN32) && defined(WIN32_REMOVEPROP_BUG)
        ::SetProp( _hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)0 );
        ::SetProp( _hwnd, (TCHAR*)_pszPropThisHi, (HANDLE)0 );
#else
        ::RemoveProp( _hwnd, (TCHAR*)_pszPropThisLo );
        ::RemoveProp( _hwnd, (TCHAR*)_pszPropThisHi );
#endif
    }
}


/*******************************************************************

    NAME:       ASSOCHWNDTHIS::HwndToThis

    SYNOPSIS:   Given a hwnd, locate the corresponding object

    ENTRY:      hwnd - window handle returned by Windows

    RETURNS:    Pointer to some anonymous object, or NULL
                if nothing found

    NOTES:
        This is a static member function.

    HISTORY:
        beng        10-May-1991 Created as CLIENT_WINDOW::HwndToPwnd
        beng        30-Sep-1991 Made own class

********************************************************************/

VOID * ASSOCHWNDTHIS::HwndToThis( HWND hwnd )
{
    // GetProp returns 0 if it fails; hence these two will build
    // one 0L if they fail.
    //
#ifdef _WIN64
    return ::GetProp( hwnd, (TCHAR*)_pszPropThisLo );
#else
    return (VOID *)MAKELONG( ::GetProp( hwnd, (TCHAR*)_pszPropThisLo ),
                             ::GetProp( hwnd, (TCHAR*)_pszPropThisHi ));
#endif
}


/*********************************************************************

    NAME:       PROC_INSTANCE::PROC_INSTANCE

    SYNOPSIS:   constructor - create a Proc Instance

    ENTRY:      FARPROC fp

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-Oct-1991 Win32 conversion

**********************************************************************/

PROC_INSTANCE::PROC_INSTANCE( MFARPROC fp )
#if defined(WIN32)
    : _fpInstance(fp)
#else
    : _fpInstance( ::MakeProcInstance( fp, BLT::QueryInstance() ))
#endif
{
    if ( _fpInstance == NULL )
    {
        //  Assume memory failure
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
    }
}


/*********************************************************************

    NAME:       PROC_INSTANCE::~PROC_INSTANCE

    SYNOPSIS:   destructor - free the procedure instance

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-Oct-1991 Win32 conversion

**********************************************************************/

PROC_INSTANCE::~PROC_INSTANCE()
{
#if !defined(WIN32)
    if ( _fpInstance != NULL )
    {
        ::FreeProcInstance( _fpInstance );
# if defined(DEBUG)
        _fpInstance = NULL;
# endif
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltowin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltowin.cxx
    BLT owner window class definitions

    FILE HISTORY:
        rustanl     27-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        beng        14-May-1991 Exploded blt.hxx into components
        beng        26-Sep-1991 C7 delta
        terryk      27-Nov-1991 Bump the control pair number from 40 to 60
        KeithMo     07-Aug-1992 STRICTified.
        Yi-HsinS    10-Dec-1992 Use WINDOW::CalcFixedHeight
*/

#include "pchblt.hxx"   // Precompiled header

class CONTROL_TABLE;    // fwd refs for local classes
class CONTROL_ENTRY;

/**********************************************************************

    NAME:       CONTROL_TABLE (ctrltable)

    SYNOPSIS:   The CONTROL_TABLE class is used with the OWNER_WINDOW to
                keep track of the controls in the owner window.

    INTERFACE:  CONTROL_TABLE()     - ctor.  No args.
                ~CONTROL_TABLE()    - dtor.
                AddControl()        - Adds a control to the table.
                RemoveControl()     - Locates and removes a control.
                CidToCtrlPtr()      -
                QueryCount()        -
                QueryItem()         -

    PARENT:     BASE

    USES:       CONTROL_ENTRY

    CAVEATS:
        Table has a fixed size.

    NOTES:
        The table is considered to be in an error state if any
        addition to it failed.  This is so that OWNER_WINDOW can
        easily verify that all of the table's contents are accurate.

        CODEWORK:  This class should use an SLIST or DICT or some other
        storage class.  For now, a simple fixed size array is used.

    HISTORY:
        rustanl     27-Nov-1990 Created
        keithmo     24-Apr-1991 Bumped MAX_CONTROL_TABLE_SIZE from 20 to 40
        beng        25-Apr-1991 Added const methods, BASE; changed
                                short QuerySize to INT QueryCount
        beng        30-Oct-1991 Added QueryItem member (for ITER_CTRL);
                                inlined Queries; unsigned integer counts
        terryk      27-Nov-1991 Bumped MAX_CONTROL_TABLE_SIZE from 40 to 60

**********************************************************************/

// CODEWORK - we should used slist instead of array

#define MAX_CONTROL_TABLE_SIZE (60)

class CONTROL_TABLE: public BASE
{
private:
    UINT _cce; // count of entries

    // CODEWORK.  Wasteful storage mechanism - this implementation should
    // probably change later.
    //
    CONTROL_ENTRY * _apce[ MAX_CONTROL_TABLE_SIZE ];

protected:
    // Simple, true-or-false error state
    //
    VOID ReportError()
        { BASE::ReportError(1); }

public:
    CONTROL_TABLE();
    ~CONTROL_TABLE();

    // AddControl adds a control to the table.  Returns TRUE on
    // success, and FALSE otherwise.
    //
    BOOL AddControl( CONTROL_WINDOW * pwinctrl );

    // RemoveControl removes a control from the table.  Returns
    // TRUE if control was found and successfully removed, and
    // FALSE otherwise.
    //
    BOOL RemoveControl( CONTROL_WINDOW * pwinctrl );

    // CidToCtrlPtr return the CONTROL_WINDOW pointer corresponding
    // to the given CID, or NULL on failure.
    //
    CONTROL_WINDOW * CidToCtrlPtr( CID cid ) const;

    // QueryCount returns the number of elements in the CONTROL_TABLE;
    // QueryItem returns one entry.  These export the table for ITER_CTRL.
    //
    UINT QueryCount() const
        { return _cce; }
    CONTROL_ENTRY * QueryItem( UINT i ) const
        { return _apce[i]; }
};


/**********************************************************************

    NAME:       CONTROL_ENTRY (ce)

    SYNOPSIS:   Pair ( pctrlwin, cid ) used in the CONTROL_TABLE.

    INTERFACE:  CONTROL_ENTRY() - constructor
                QueryCid()      - return the cid of the control entry
                QueryCtrlPtr()  - return pointer to control-window

    USES:       CONTROL_WINDOW, CID

    NOTES:
        This class is private to the OWNER_WINDOW and
        to CONTROL_TABLE.

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Private constructor, friends;
                                    made Queries inline and const

**********************************************************************/

class CONTROL_ENTRY // ce
{
friend BOOL CONTROL_TABLE::AddControl(CONTROL_WINDOW *);

private:
    CONTROL_WINDOW * _pctrlwin;
    CID              _cid;

    // Constructor is private, so that only named friends of the class
    // can create instances.
    //
    CONTROL_ENTRY( CONTROL_WINDOW * pctrlwin );

public:
    CID QueryCid() const
        { return _cid; }
    CONTROL_WINDOW * QueryCtrlPtr() const
        { return _pctrlwin; }
};


/**********************************************************************

    NAME:       CONTROL_ENTRY::CONTROL_ENTRY

    SYNOPSIS:   Construct a new entry in a CONTROL_TABLE

    ENTRY:      pctrlwin - pointer to control to include

    NOTES:
        Only CONTROL_TABLE::AddControl may call
        this function - it contains all error checking.

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Folded error checking into called

**********************************************************************/

CONTROL_ENTRY::CONTROL_ENTRY( CONTROL_WINDOW * pctrlwin )
    : _pctrlwin(pctrlwin),
      _cid(pctrlwin->QueryCid())
{
    // No error checking, since only AddControl can create
    // an instance, and it validates pctrlwin before creation.
}


/**********************************************************************

    NAME:       CONTROL_TABLE::CONTROL_TABLE

    SYNOPSIS:   Create a new, empty control table

    NOTES:
        The new control table contains no controls.

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

CONTROL_TABLE::CONTROL_TABLE() :
    _cce(0)
{
    for ( INT i = 0; i < MAX_CONTROL_TABLE_SIZE; i++ )
        _apce[ i ] = NULL;
}


/**********************************************************************

    NAME:       CONTROL_TABLE::~CONTROL_TABLE

    SYNOPSIS:   Destroy a control table

    NOTES:
        Deletes every added entry

    HISTORY:
        rustanl     27-Nov-1990 Created
        beng        30-Oct-1991 Uses dynamic table size
                                instead of static maximum size

**********************************************************************/

CONTROL_TABLE::~CONTROL_TABLE()
{
    for ( UINT i = 0; i < _cce; i++ )
    {
        delete _apce[ i ];
    }
}


/**********************************************************************

    NAME:       CONTROL_TABLE::AddControl

    SYNOPSIS:   Add a record to the table

    ENTRY:

    EXIT:

    RETURNS:    TRUE if the control was successfully added, or
                FALSE if not.

    NOTES:

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Uses Query/ReportError

**********************************************************************/

BOOL CONTROL_TABLE::AddControl( CONTROL_WINDOW * pwinctrl )
{
    // Return a failure if the table is in an error state
    //
    if ( QueryError() )
        return FALSE;

    // Likewise on illegal input
    //
    if (pwinctrl == NULL)
    {
        DBGEOL(SZ("Tried to add a NULL control"));
        return FALSE;
    }

    // If the table is full, mark the table as being in an
    // error state, and return failure.
    //
    if ( _cce == MAX_CONTROL_TABLE_SIZE )
    {
        ReportError();
        return FALSE;
    }

    // Create a table entry for the new control.  If the allocation
    // fails, marks the table as being in an error state, and return
    // a failure.
    //
    CONTROL_ENTRY * pce = new CONTROL_ENTRY( pwinctrl );
    if ( pce == NULL )
    {
        ReportError();
        return FALSE;
    }

    // Add the new entry into the table
    //
    _apce[ _cce++ ] = pce;

    return TRUE;    // success
}


/**********************************************************************

    NAME:       CONTROL_TABLE::RemoveControl

    SYNOPSIS:   Locate and remove a record from the table

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

BOOL CONTROL_TABLE::RemoveControl( CONTROL_WINDOW * pwinctrl )
{
    // Return a failure if the table is in an error state.
    //
    if ( QueryError() )
        return FALSE;

    // Likewise on illegal input
    //
    if (pwinctrl == NULL)
    {
        DBGEOL(SZ("Tried to remove a NULL control"));
        return FALSE;
    }

    // Attempt to find the given control in the table
    //
    UINT i;
    for ( i = 0; i < _cce; i++ )
    {
        if ( _apce[ i ]->QueryCtrlPtr() == pwinctrl )
            break;
    }

    // Verify success of search
    //
    if ( i == _cce )
        return FALSE;

    // Remove the control from the table, and fill its spot
    // with the last entry, so that all current entries are
    // consecutive.
    //
    delete _apce[ i ];
    _apce[ i ] = _apce[ --_cce ];
    _apce[ _cce ] = NULL;

    return TRUE;    // success
}


/**********************************************************************

    NAME:       CONTROL_TABLE::CidToCtrlPtr

    SYNOPSIS:   Locate a record by its CID, and return appropriate window

    ENTRY:      cid - BLT control-id

    EXIT:

    RETURNS:    Pointer to appropriate CONTROL_WINDOW, or NULL
                if the CID couldn't be found

    NOTES:

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Uses Query/ReportError

**********************************************************************/

CONTROL_WINDOW * CONTROL_TABLE::CidToCtrlPtr( CID cid ) const
{
    // Return a failure if the table is in an error state.
    //
    if ( QueryError() )
        return NULL;

    // Attempt to find the given control in the table
    //
    UINT i;
    for ( i = 0; i < _cce; i++ )
    {
        if ( _apce[ i ]->QueryCid() == cid )
            break;
    }

    // Verify success of search
    //
    if ( i == _cce )
        return NULL;

    return _apce[ i ]->QueryCtrlPtr();
}


/**********************************************************************

    NAME:       OWNER_WINDOW::OWNER_WINDOW

    SYNOPSIS:   Constructor for owner window object

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        rustanl     27-Nov-1990     Created
        beng        25-Apr-1991     Removed hwndOwner parm; fixed
                                    error reporting
        beng        08-May-1991     Relocated BASE to WINDOW ancestor

**********************************************************************/

OWNER_WINDOW::OWNER_WINDOW()
    : WINDOW(),
      _pctrltable( new CONTROL_TABLE() ),
      _dwAttributes( 0 )
{
    if ( !_pctrltable || !*_pctrltable )
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
}


OWNER_WINDOW::OWNER_WINDOW(
    const TCHAR *  pszClassName,
    ULONG         flStyle,
    const WINDOW *pwndOwner )
    : WINDOW(pszClassName, flStyle, pwndOwner),
      _pctrltable( new CONTROL_TABLE() )
{
    if ( !_pctrltable || !*_pctrltable )
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
}


/**********************************************************************

    NAME:       OWNER_WINDOW::~OWNER_WINDOW

    SYNOPSIS:   Destructor for OWNER_WINDOW

    ENTRY:

    EXIT:       control table is dust

    NOTES:

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

OWNER_WINDOW::~OWNER_WINDOW()
{
    delete _pctrltable;
    _pctrltable = NULL;
}


/**********************************************************************

    NAME:       OWNER_WINDOW::AddControl

    SYNOPSIS:   Adds a control to a window

    ENTRY:      pctrlwin - pointer to the CONTROL_WINDOW to add

    EXIT:       See CONTROL_TABLE::AddControl()

    NOTES:      This works by forwarding the call to the
                embedded CONTROL_TABLE object.

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

BOOL OWNER_WINDOW::AddControl( CONTROL_WINDOW * pctrlwin )
{
    return _pctrltable->AddControl( pctrlwin );
}


/**********************************************************************

    NAME:       OWNER_WINDOW::SetFocus

    SYNOPSIS:   Sets the focus to a control, ID'd by CID

    ENTRY:      cid - ID of control to receive focus

    EXIT:       That control has focus

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

VOID OWNER_WINDOW::SetFocus( CID cid )
{
    ::SetFocus(::GetDlgItem(QueryHwnd(), cid));
}


/**********************************************************************

    NAME:       OWNER_WINDOW::SetDialogFocus

    SYNOPSIS:   Sets the focus to a control in a dialog

    ENTRY:      ctrlwin - control to receive focus

    EXIT:       That control has focus

    HISTORY:
        jonn      21-May-1993

**********************************************************************/

VOID OWNER_WINDOW::SetDialogFocus( CONTROL_WINDOW & ctrlwin )
{
    Command( WM_NEXTDLGCTL,
             (WPARAM)(ctrlwin.QueryHwnd()),
             (LPARAM)TRUE );
}


/**********************************************************************

    NAME:       OWNER_WINDOW::CidToCtrlPtr

    SYNOPSIS:   Returns the control-window pointer corresponding
                to the named control

    ENTRY:      cid - Control ID (child-window-identifier)

    RETURNS:    A pointer to a control window, or NULL if not found.

    HISTORY:
        rustanl   27-Nov-1990     Created

**********************************************************************/

CONTROL_WINDOW * OWNER_WINDOW::CidToCtrlPtr( CID cid ) const
{
    return _pctrltable->CidToCtrlPtr( cid );
}


/*******************************************************************

    NAME:       OWNER_WINDOW::OnCDMessages

    SYNOPSIS:   Responds to the messages handling custom-draw controls

    ENTRY:      usMsg, wParam, lParam - as per wndproc

    EXIT:

    RETURNS:

    NOTES:
        This *non-virtual* dispatch function is called by both
        dialog and client windows.

        Possible optimization: note that the offset of the CtlID field
        is the same for all of the [...]ITEMSTRUCTs below.

        GUILTT is the UI CT team's testing tool.  It uses a private
        message to extract information from owner-drawn listboxen.
        Talk to DavidBul, or else see the file
        \\testy\lm30ct\src\ui\guiltt\src\bltlist.cxx
        for annoying details.

    HISTORY:
        beng        21-May-1991 Created, from old BltDlgProc
        beng        27-Jun-1991 Corrected a GUILTT handling bug;
                                added some doc for GUILTT
        beng        15-Oct-1991 Win32 conversion
        beng        14-Feb-1992 Win32 enabling of GUILTT
        beng        30-Apr-1992 API changes
        beng        01-Jun-1992 GUILTT changes

********************************************************************/

INT OWNER_WINDOW::OnCDMessages( UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    switch (nMsg)
    {
    case WM_GUILTT:
        {
            CID cid = (CID)wParam;
            UINT ilb = (UINT)lParam;

            // Find the control

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if (pctrl == NULL)
                return ERROR_CONTROL_ID_NOT_FOUND;

            // Get the data from the control

            NLS_STR nlsData;
            APIERR err = pctrl->CD_Guiltt( ilb, &nlsData );
            if (err != NERR_Success)
                return err;

            // Get the data onto the clipboard
            //
            // This is a one-way trip; we alloc the mem, but never
            // free it, since it becomes the property of the clipboard.

            HANDLE h = ::GlobalAlloc(GMEM_MOVEABLE, nlsData.QueryTextSize());
            if (h == NULL)
                return BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY);

            {
                VOID * pvData = ::GlobalLock(h);
                ASSERT(pvData != NULL);
                ::memcpy(pvData, nlsData.QueryPch(), nlsData.QueryTextSize());
                ::GlobalUnlock(h);
            }

            if (   ! ::OpenClipboard(QueryHwnd())
                || ! ::EmptyClipboard()
#if defined(UNICODE)
                || ! ::SetClipboardData( CF_UNICODETEXT, h )
#else
                || ! ::SetClipboardData( CF_TEXT, h )
#endif
                || ! ::CloseClipboard())
            {
                return BLT::MapLastError(ERROR_BUSY);
            }

            // Over and out - return to GUILTT

            return 0;
        }

    case WM_DRAWITEM:
        {
            CID cid = ((DRAWITEMSTRUCT *)lParam)->CtlID;

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if ( pctrl != NULL )
                return pctrl->CD_Draw( (DRAWITEMSTRUCT *)lParam );
        }
        break;

    case WM_MEASUREITEM:
        {
            //  Note, this will only be done for variable-size items.
            //  Fixed size items are handled in WM_MEASUREITEM message
            //  above.

            CID cid = ((MEASUREITEMSTRUCT *)lParam)->CtlID;

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if ( pctrl != NULL )
                return pctrl->CD_Measure( (MEASUREITEMSTRUCT *)lParam );
        }
        break;

    case WM_CHARTOITEM:
        {
#if defined(WIN32)
            WCHAR wch = (WCHAR)LOWORD(wParam);
            CID cid = ::GetDlgCtrlID( (HWND)lParam );
            USHORT nCaretPos = HIWORD(wParam);
#else
            WCHAR wch = (WCHAR)wParam;
            CID cid = ::GetDlgCtrlID( LOWORD( lParam ) );
            USHORT nCaretPos = HIWORD(lParam);
#endif

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if ( pctrl != NULL )
                return pctrl->CD_Char( wch, nCaretPos );
        }
        break;

    case WM_VKEYTOITEM:
        {
#if defined(WIN32)
            USHORT nVKey = LOWORD(wParam);
            CID cid = ::GetDlgCtrlID( (HWND)lParam );
            USHORT nCaretPos = HIWORD(wParam);
#else
            USHORT nVKey = wParam;
            CID cid = ::GetDlgCtrlID( LOWORD( lParam ) );
            USHORT nCaretPos = HIWORD(lParam);
#endif

            CONTROL_WINDOW * pctrl = CidToCtrlPtr( cid );
            if ( pctrl != NULL )
                return pctrl->CD_VKey( nVKey, nCaretPos );
        }
        break;

    default:
        break;
    }

    return 0;
}


/* Maximum height we expect bitmaps to be in the owner drawn list boxes
 */
const USHORT yMaxCDBitmap = 16;


/*******************************************************************

    NAME:       OWNER_WINDOW::CalcFixedCDMeasure

    SYNOPSIS:   Calculate size of fixed-size owner-draw object

    ENTRY:      hwnd   - handle to window owning the control
                pmis   - as passed by WM_MEASUREITEM in lParam

    EXIT:

    RETURNS:    FALSE if the calculation fails for some reason

    NOTES:
        This is a static member of the class.

        This WM_MEASUREITEM message is sent before the
        WM_INITDIALOG message (except for variable size owner-draw
        list controls).  Since the window properties are not yet set
        up, the owner dialog cannot be called.

        The chosen solution for list controls is to assume that every
        owner-draw control will always have the same height as the font
        of that list control.  This is a very reasonable guess for most
        owner-draw list controls.  Since owner-draw list controls with
        variable size items call the owner for every item, the window
        properties will have been properly initialized by that time.  Hence,
        a client may respond to these messages through OnOther.

        Currently, owner-draw buttons are not supported.

    HISTORY:
        beng        21-May-1991 Created, from old BltDlgProc
        beng        15-Oct-1991 Win32 conversion
        Yi-Hsin     10-Dec-1992 Call WINDOW?::CalcFixedHeight instead

********************************************************************/

BOOL OWNER_WINDOW::CalcFixedCDMeasure( HWND hwnd, MEASUREITEMSTRUCT * pmis )
{
    // Get the handle of the control
    //
    return ( WINDOW::CalcFixedHeight( ::GetDlgItem( hwnd, pmis->CtlID ),
                                      &( pmis->itemHeight ) ));

}


/*******************************************************************

    NAME:       OWNER_WINDOW::OnLBIMessages

    SYNOPSIS:   Handle LBI messages which need no pwnd

    ENTRY:

    EXIT:

    RETURNS:    Value for wndproc to return

    NOTES:
        This is a static member of the class.

    HISTORY:
        beng        21-May-1991 Created
        beng        15-Oct-1991 Win32 conversion

********************************************************************/

INT OWNER_WINDOW::OnLBIMessages(
    UINT   nMsg,
    WPARAM wParam,
    LPARAM lParam )
{
    switch (nMsg)
    {
    case WM_COMPAREITEM:
        return LBI::OnCompareItem(wParam, lParam);

    case WM_DELETEITEM:
        LBI::OnDeleteItem(wParam, lParam);
        return TRUE;

    default:
        break;
    }

    return 0;
}


/*******************************************************************

    NAME:       OWNER_WINDOW::OnUserMessage

    SYNOPSIS:   Handles all user-defined messages

    ENTRY:      event - an untyped EVENT

    RETURNS:    TRUE if event handled, FALSE otherwise

    NOTES:
        Clients handling user-defined messages should supply
        OnOther instead of redefining DispatchMessage.

    HISTORY:
        beng        14-May-1991     Created (in CLIENT_WINDOW).
        KeithMo     14-Oct-1992     Moved to OWNER_WINDOW.

********************************************************************/

BOOL OWNER_WINDOW::OnUserMessage( const EVENT &event )
{
    UNREFERENCED(event);
    return FALSE;
}


/*******************************************************************

    NAME:       ITER_CTRL::ITER_CTRL

    SYNOPSIS:   Construct a control iterator

    ENTRY:      pwndOwning - owner-window owning controls

    EXIT:       Iterator constructed.  If the window is in some
                error state, the resulting enumeration will have
                length 0.

    HISTORY:
        beng        30-Oct-1991 Created

********************************************************************/

ITER_CTRL::ITER_CTRL( const OWNER_WINDOW * pwndOwning )
    : _pwndOwning(pwndOwning),
      _pctrltable(NULL),
      _ictrl(0),
      _cctrl(0)
{
    if (pwndOwning == NULL || !*pwndOwning)
    {
        // Yields a zero-length sequence.
        return;
    }

    // The iterator is a friend of owner window, and so has access
    // to this private member.
    //
    _pctrltable = pwndOwning->_pctrltable;
    _cctrl = _pctrltable->QueryCount();
}


/*******************************************************************

    NAME:       ITER_CTRL::Reset

    SYNOPSIS:   Resets the control iterator to its initial state

    EXIT:       Iterator is fresh and new

    NOTES:
        If the owner window acquires or loses any controls, this
        method will synchronize the iterator anew.

    HISTORY:
        beng        30-Oct-1991 Created

********************************************************************/

VOID ITER_CTRL::Reset()
{
    ASSERT(!!*_pwndOwning);

    _ictrl = 0;
    _cctrl = _pctrltable->QueryCount();
}


/*******************************************************************

    NAME:       ITER_CTRL::Next

    SYNOPSIS:   Fetch the next control in the sequence

    RETURNS:    A pointer to a control-window

    NOTES:
        The sequence is that in which the controls were constructed.

    HISTORY:
        beng        30-Oct-1991 Created

********************************************************************/

CONTROL_WINDOW * ITER_CTRL::Next()
{
    if (_ictrl >= _cctrl)
        return NULL;

    // I should just make this class
    // a friend of CONTROL_TABLE.  This is absurd, particularly
    // within a private class.

    return _pctrltable->QueryItem(_ictrl++)->QueryCtrlPtr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltsload.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltsload.cxx
    NLS/DBCS-aware string class:  Load

*/

#include "pchblt.hxx"  // Precompiled header


/*******************************************************************

    NAME:       NLS_STR::Load

    SYNOPSIS:   Loads a string from a resource file.

    ENTRY:      msgid   - ID of the string resource to load

    EXIT:       Zaps the current contents of the string.

    RETURNS:    Error value, which is NERR_Success on success.

    CAVEATS:
        Please use RESOURCE_STR instead of this function, if possible.

    NOTES:
        This function may fragment the heap somewhat if its realloc
        requires in new memory for the string.  Alternatives include
        always bloating the string up to MAX_RES_STR_LEN, so that we
        can load the resource directly into its buffer without the
        temp buffer; creating the temp buffer on the stack; or creating
        the temp buffer in a new BUFFER object.  Should profile heap
        usage in our apps and revisit.  REVIEW PROFILE

    HISTORY:
        rustanl     31-Jan-1991 Created
        beng        23-Jul-1991 Allow on erroneous string
        beng        07-Oct-1991 Use MSGID and APIERR
        beng        18-Oct-1991 Renamed from "LoadString"
        beng        20-Nov-1991 Unicode fixes
        beng        31-Dec-1991 No longer bloats strings unnecessarily
        beng        03-Aug-1992 Loads strings itself; dllization;
                                remove size limit

********************************************************************/

APIERR NLS_STR::Load( MSGID msgid )
{
    if (QueryError())
        return QueryError();

    if ( msgid < IDS_UI_BASE )
    {
#if defined(WIN32)
        return LoadSystem( msgid );
#endif
    }

    return Load( msgid, BLT::CalcHmodString(msgid) ) ;
}


#if defined(WIN32)
/*******************************************************************

    NAME:       NLS_STR::LoadSystem

    SYNOPSIS:   Loads a string from the system's resource files.

    ENTRY:      msgid   - ID of the string resource to load

    EXIT:       Zaps the current contents of the string.

    RETURNS:    Error value, which is NERR_Success on success.

    HISTORY:
        beng        05-Aug-1992 Created
        YiHsinS     01-Jan-1993 Use W version of FormatMessage

********************************************************************/

APIERR NLS_STR::LoadSystem( MSGID msgid )
{
    if (QueryError())
        return QueryError();

    HANDLE hmod = NULL;
    DWORD dwFlags =  FORMAT_MESSAGE_ALLOCATE_BUFFER |
                     FORMAT_MESSAGE_IGNORE_INSERTS  |
                     FORMAT_MESSAGE_MAX_WIDTH_MASK;

    if ((msgid <= MAX_LANMAN_MESSAGE_ID) && (msgid >= MIN_LANMAN_MESSAGE_ID))
    {
        // Net Errors
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
        hmod = BLT::CalcHmodString(msgid);
    }
    else   // other system errors
    {
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }


    TCHAR* pchBuffer = NULL;
    UINT cch = (UINT) ::FormatMessage( dwFlags,
                                       hmod,
                                       msgid,
                                       0,
                                       (LPTSTR)&pchBuffer,
                                       1024,
                                       NULL );
    if (cch > 0)
    {
        APIERR err = CopyFrom(pchBuffer);
        ::LocalFree((VOID*)pchBuffer);
        return err;
    }
    else
    {
        return ::GetLastError();
    }
}
#endif // WIN32


/*******************************************************************

    NAME:       RESOURCE_STR::RESOURCE_STR

    SYNOPSIS:   Constructs a nls-string from a resource ID.

    ENTRY:      idResource

    EXIT:       Successful construct, or else ReportError

    NOTES:      This string may not be owner-alloc!  For owner-alloc,
                cons up a new one and copy this into it.

    HISTORY:
        beng        23-Jul-1991 Created
        beng        07-Oct-1991 Use MSGID

********************************************************************/

RESOURCE_STR::RESOURCE_STR( MSGID msgid )
    : NLS_STR()
{
    UIASSERT(!IsOwnerAlloc());

    APIERR err = Load(msgid);
    if (err)
        ReportError(err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\bltpump.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltpump.cxx
    The BLT message pump

    FILE HISTORY:
	beng	    07-Oct-1991 Created

*/

#include "pchblt.hxx"   // Precompiled header


/*******************************************************************

    NAME:	HAS_MESSAGE_PUMP::RunMessagePump

    SYNOPSIS:	Run message loop.

	Acquires and dispatches messages until a WM_QUIT message
	is received, or else until some client-specified termination
	condition is satisfied.

    ENTRY:	New application.  App object has been "constructed"
		and app has been properly initialized.

    EXIT:	App has received WM_QUIT

    RETURNS:	Value from PostQuitMessage, or 0 if at client request.

    HISTORY:
	beng	    01-Apr-1991 Created (as APPSTART::MessageLoop)
	rustanl     17-Jun-1991 Copied from APPSTART::MessageLoop
				into APPLICATION::RunMessageLoop
	beng	    09-Jul-1991 Added new FilterMessage scheme
	beng	    07-Oct-1991 Incorporated into new HAS_MESSAGE_PUMP

********************************************************************/

WPARAM HAS_MESSAGE_PUMP::RunMessagePump()
{
    MSG msg;

    while ( ::GetMessage( &msg,     // message structure
			  NULL,     // handle of window receiving the message
			  0,	    // lowest message to examine
			  0 ) )     // highest message to examine
    {
	// Call the app's filter, giving it an opportunity to
	// translate menu accelerators, etc.  If the filter handles
	// the message, continue to the next message.
	//
	if (!FilterMessage( &msg ))
	{
	    ::TranslateMessage( &msg ); // Translates virtual key codes
	    ::DispatchMessage( &msg );	// Dispatches message to window
	}

	// Not all message loops run to app termination -
	// e.g., any dialog.  This predicate is supplied by the client.
	//
	if (IsPumpFinished())
	    return 0;
    }

    return msg.wParam;		    // Returns the value from PostQuitMessage
}


/*******************************************************************

    NAME:	HAS_MESSAGE_PUMP::FilterMessage

    SYNOPSIS:	Client-installable hook into the messageloop.

	This default implementation does nothing.

    ENTRY:	pmsg	- pointer to message fresh off the queue

    EXIT:	pmsg	- could possibly be changed

    RETURNS:
	FALSE to proceed with translating and dispatching
	the message.

	TRUE indicates that the message has already been
	handled by the filter.	In this case, the message
	loop will continue on to the next message in the
	queue.

    CAVEATS:
	When parsing the contents of *pmsg, clients should take care
	to retain portability between different Win environments.
	While "message" is usually safe, wParam and lParam may change.

    NOTES:
	This is a virtual member function.

	A client which needs menu-accelerator support should supply
	an implementation which calls TranslateAccelerator as appropriate.
	(See the ACCELTABLE class.)

    HISTORY:
	beng	    09-Jul-1991 Created (within APPLICATION)
	beng	    07-Oct-1991 Moved into HAS_MESSAGE_PUMP

********************************************************************/

BOOL HAS_MESSAGE_PUMP::FilterMessage( MSG* pmsg )
{
    UNREFERENCED(pmsg);

    return FALSE;
}


/*******************************************************************

    NAME:	HAS_MESSAGE_PUMP::IsPumpFinished

    SYNOPSIS:	Client-installable pump termination condition

	This default implementation does nothing but return "FALSE;"
	hence a client which does not replace this will run until
	the pump receives WM_QUIT.

    ENTRY:	Message pump has dispatched a message

    RETURNS:	TRUE to end the pump; FALSE to continue

    CAVEATS:
	A class derived from APPLICATION proably shouldn't replace
	this function.

    NOTES:
	This is a virtual member function.

    HISTORY:
	beng	    07-Oct-1991 Created

********************************************************************/

BOOL HAS_MESSAGE_PUMP::IsPumpFinished()
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\blttimer.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    blttimer.cxx
    BLT's timer object.

    Currently, window only have 16 timers at one
    time. However, in order to provide more timer for the blt
    application, a timer class is created. This is a timer multiplexer.
    It will first get a timer from the system and then set up a global
    call back function. Depending on each element in the request list,
    the global call back function will call the requested element's
    call back function when time is up.

    FILE HISTORY:
        terryk      29-May-1991 Created
        terryk      14-Jun-1991 Add a serve request counter
        terryk      18-Jul-1991 code review changed. Attend: terryk jonn ericch
        rustanl     10-Sep-1991 Large changes, introducing new timer hierarchy
*/

#include "pchblt.hxx"   // Precompiled header

#define TICKCOUNT_50_PERCENT  ( 1L << ( sizeof( ULONG ) * 8 - 1 ))

DEFINE_SLIST_OF( TIMER_BASE );


/*********************************************************************

    NAME:       TIMER_WINDOW

    SYNOPSIS:   An invisible window which contains the timer object and
                handle all the WM_TIMER message.

    PARENT:     CLIENT_WINDOW

    USES:       BLT_MASTER_TIMER, TIMER_BASE

    CAVEATS:    User does not have to directly access this class because
                BLT_MASTER_TIMER will create this object during
                initialization.

    HISTORY:
                terryk  1-Jun-91    Created
                rustanl 06-Sep-91   Moved class decl. into .cxx file
                rustanl 9-Sep-91    Removed _dwOldTime data member

**********************************************************************/

class TIMER_WINDOW: public CLIENT_WINDOW
{
private:
    BLT_MASTER_TIMER * _pmastertimer;

protected:
    BOOL OnTimer( const TIMER_EVENT & tEvent );

public:
    TIMER_WINDOW( BLT_MASTER_TIMER * pmastertimer );
};


/*********************************************************************

    NAME:       TIMER_WINDOW::TIMER_WINDOW

    SYNOPSIS:   An invisible app to trap the WM_TIMER message.

    HISTORY:
                terryk  1-Jun-91    Created
                rustanl 9-Sep-91    Removed _dwOldTime data member; added
                                    pmastertimer parameter and corresponding
                                    data member

**********************************************************************/

TIMER_WINDOW::TIMER_WINDOW( BLT_MASTER_TIMER * pmastertimer )
    :   CLIENT_WINDOW( WS_OVERLAPPEDWINDOW, NULL ),
        _pmastertimer( pmastertimer )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _pmastertimer != NULL );
}


/*********************************************************************

    NAME:       TIMER_WINDOW::OnTimer

    SYNOPSIS:   Trap the WM_TIMER message.

    ENTRY:      const TIMER_EVENT &tEvent - Timer event

    HISTORY:
                terryk  01-Jun-91   Created
                terryk  14-Jun-91   Add a serve request count
                rustanl 06-Sep-91   Use DispatchTimer
                rustanl 10-Sep-91   Removed unneeded serve request count

**********************************************************************/

BOOL TIMER_WINDOW::OnTimer( const TIMER_EVENT &tEvent )
{
    UNREFERENCED( tEvent );

    TIMER_BASE * pTimer;

    _pmastertimer->ResetIterator();
    while (( pTimer = _pmastertimer->NextTimer()) != NULL )
    {
        if ( ( ! pTimer->IsEnabled()) || pTimer->_fBeingServed )
            continue;

        ULONG ulCurrentTickCount = ::GetTickCount();
        ULONG ulNextDue = pTimer->_ulNextTimerDue;

        //  Note, since the tick count may wrap, we need to take special
        //  action.  This gets a bit hairy.  Simplified, this is the
        //  algorithm used:
        //
        //      fTimeIsDue =
        //          ( ulNextDue <= ulCurrentTickCount &&
        //            ulCurrentTickCount < ulNextDue + TICKCOUNT_50_PERCENT );
        //
        //  The tricky part is that ulNextDue + TICKCOUNT_50_PERCENT
        //  may overflow what can be stored in a ULONG.  This occurs when
        //  ulNextDue is at least TICKCOUNT_50_PERCENT.
        //

        BOOL fTimerIsDue;
        if ( ulNextDue < TICKCOUNT_50_PERCENT )
        {
            //  ulNextDue + TICKCOUNT_50_PERCENT won't overflow
            fTimerIsDue =
                    ( ulNextDue <= ulCurrentTickCount &&
                      ulCurrentTickCount < ulNextDue + TICKCOUNT_50_PERCENT );
        }
        else
        {
            //  ulNextDue + TICKCOUNT_50_PERCENT will overflow
            fTimerIsDue =
                    ( ulNextDue <= ulCurrentTickCount ||
                      ulCurrentTickCount < ulNextDue - TICKCOUNT_50_PERCENT );
        }

        if ( fTimerIsDue )
        {
            /*  Timer is due.  Make the callout.
             */

            pTimer->_fBeingServed = TRUE;
            pTimer->DispatchTimer();
            pTimer->_fBeingServed = FALSE;

            pTimer->SetNewTimeDue();
        }
    }
    return TRUE;
}


#define MASTER_TIMER_INTERVAL       (500)
#define IDT_MASTER_TIMER            (1)

BLT_MASTER_TIMER * BLT_MASTER_TIMER::_pBltMasterTimer = NULL;

static UINT _cInit = 0; // CODEWORK - make a static class member
                        // (I'm saving myself a rebuild here, that's all)


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::Init

    SYNOPSIS:   Initialize the global object - Master Timer

    NOTES:      This method must be called before any timer can be used
                successfully

    HISTORY:
        terryk      30-May-1991 Created
        rustanl     09-Sep-1991 Allocate global objects dynamically
        beng        05-Aug-1992 Dllization

**********************************************************************/

APIERR BLT_MASTER_TIMER::Init()
{
    TRACEEOL( "BLT_MASTER_TIMER::Init()" );

    if (_cInit++ != 0) // Allow multiple registrands.  (Only first has effect.)
        return NERR_Success;

    TRACEEOL( "BLT_MASTER_TIMER::Init(); creating master timer" );

    // Make sure Init has not been called before
    ASSERT( _pBltMasterTimer == NULL );

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    _pBltMasterTimer = new BLT_MASTER_TIMER;
    if (   (_pBltMasterTimer == NULL)
        || ((err = _pBltMasterTimer->QueryError()) != NERR_Success) )
    {
        DBGEOL("NETUI2.DLL: BLT_MASTER_TIMER::Init failed, err " << (UINT)err);
    }

    return err;
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::Term

    SYNOPSIS:   Terminate the global object - Master Timer

    HISTORY:
        terryk      30-May-1991 Created
        rustanl     09-Sep-1991 Allocate global objects dynamically
        beng        05-Aug-1992 Dllization

**********************************************************************/

VOID BLT_MASTER_TIMER::Term()
{
    TRACEEOL( "BLT_MASTER_TIMER::Term()" );

    ASSERT(_cInit > 0); // Ensure that Terms match Inits

    if (--_cInit != 0)
        return;

    TRACEEOL( "BLT_MASTER_TIMER::Term(); deleting master timer" );

    delete _pBltMasterTimer;
    _pBltMasterTimer = NULL;
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::BLT_MASTER_TIMER

    SYNOPSIS:   constructor - request a timer from the system

    HISTORY:
        terryk      30-May-1991 Created
        rustanl     09-Sep-1991 Allocate TIMER_WINDOW from here
        beng        05-Aug-1992 Twiddled error reporting

**********************************************************************/

BLT_MASTER_TIMER::BLT_MASTER_TIMER()
    : BASE(),
    _slTimer( FALSE ),
    _iterTimer( _slTimer ),
    _wTimerId( 0 ),
    _pclwinTimerApp( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    _pclwinTimerApp = new TIMER_WINDOW( this );
    if (   (_pclwinTimerApp == NULL)
        || ((err = _pclwinTimerApp->QueryError()) != NERR_Success) )
    {
        ReportError(err);
        return;
    }

    //  Note, the destructor assumes that _wTimerId is assigned to after
    //  *_pclwinTimerApp is successfully constructed.

    TRACEEOL("BLT_MASTER_TIMER::ctor; setting timer for HWND "
                << (DWORD)(_pclwinTimerApp->QueryHwnd()) );
    _wTimerId = ::SetTimer( _pclwinTimerApp->QueryHwnd(),
                            IDT_MASTER_TIMER,
                            MASTER_TIMER_INTERVAL,
                            NULL );
    DWORD dwErr = ::GetLastError();
    TRACEEOL("BLT_MASTER_TIMER::ctor; SetTimer returned timer ID " << (DWORD)_wTimerId);
    if ( _wTimerId == 0 )
    {
        DBGEOL( "NETUI2.DLL: BLT_MASTER_TIMER::SetTimer failed with error "
                << dwErr);
        ReportError( BLT::MapLastError(ERROR_GEN_FAILURE) );
        return;
    }
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::~BLT_MASTER_TIMER

    SYNOPSIS:   destructor - kill the timer from the window system

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Use _wTimerId and handle _pclwinTimerApp

**********************************************************************/

BLT_MASTER_TIMER::~BLT_MASTER_TIMER()
{
    TRACEEOL("BLT_MASTER_TIMER::dtor; HWND is "
                << (DWORD)(_pclwinTimerApp->QueryHwnd()) );
    TRACEEOL("BLT_MASTER_TIMER::dtor; timer ID is " << (DWORD)_wTimerId);
    if ( _wTimerId != 0 )
    {
        UIASSERT( _pclwinTimerApp != NULL );   // assume ct constructed this
                                               // before assigning to _wTimerId
        BOOL fTimerErr = ::KillTimer(_pclwinTimerApp->QueryHwnd(), IDT_MASTER_TIMER);
        DWORD dwErr = ::GetLastError();
        TRACEEOL("BLT_MASTER_TIMER::dtor; KillTimer returned " << fTimerErr);
        if (!fTimerErr)
        {
            DBGEOL("NETUI2.DLL: BLT_MASTER_TIMER::dtor; KillTimer failed with error " << dwErr);
        }
        else
        {
            _wTimerId = 0;
        }
        // REQUIRE( fTimerErr );
    }

    delete _pclwinTimerApp;
    _pclwinTimerApp = NULL;
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::ResetIterator

    SYNOPSIS:   Reset the master timer list to the beginning

    HISTORY:
                terryk  30-May-91   Created

**********************************************************************/

VOID BLT_MASTER_TIMER::ResetIterator()
{
    _iterTimer.Reset();
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::NextTimer

    SYNOPSIS:   return the next timer to the caller

    HISTORY:
                terryk  30-May-91   Created

**********************************************************************/

TIMER_BASE *BLT_MASTER_TIMER::NextTimer()
{
    return (TIMER_BASE *)_iterTimer.Next();
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::RemoveTimer

    SYNOPSIS:   remove the timer from the master timer list

    ENTRY:      TIMER_BASE *Timer - Timer to be removed

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Changed parameter name

**********************************************************************/

VOID BLT_MASTER_TIMER::RemoveTimer( TIMER_BASE * pTimer )
{
    ITER_SL_OF( TIMER_BASE ) iterTimer( _slTimer );
    TIMER_BASE * ptimerTmp;

    while ( ( ptimerTmp = iterTimer.Next()) != NULL )
    {
        if ( ptimerTmp == pTimer )
        {
            _slTimer.Remove( iterTimer );
            return ;
        }
    }
}


/*********************************************************************

    NAME:       BLT_MASTER_TIMER::InsertTimer

    SYNOPSIS:   Add an element to the master timer list

    ENTRY:      TIMER_BASE *p - Timer to be added

    RETURN:     return the apierr if the insertion is failed.

    NOTES:      This function assumes that there will never be more
                than 2^16 different timers instantiated.  No check
                is being made to handle overflows; in the unlikely
                event that 'tidNext' below wraps around from 0 reusing
                an ID, *and* that ID is currently in use by another timer,
                *and* that timer happens to be dispatched to the same
                timer recipient, all that would happen is that some
                timer would seem to occur before or after when it was
                set up to occur.

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Added timer ID assignment

**********************************************************************/

APIERR BLT_MASTER_TIMER::InsertTimer( TIMER_BASE * pTimer )
{
    static TIMER_ID tidNext = 0;
    pTimer->_tid = tidNext;
    tidNext++;
    UIASSERT( tidNext != 0 );       // assume no overflow will ever occur

    return _slTimer.Add( pTimer );
}


/*******************************************************************

    NAME:       BLT_MASTER_TIMER::QueryMasterTimer

    SYNOPSIS:   Returns a pointer to the master timer

    ENTRY:      ppmastertimer -     Pointer to location which will receive
                                    pointer to master timer

    EXIT:       On success, *ppmastertimer will contain a pointer to the
                master timer

    RETURNS:    An API return value, which is NERR_Success on success

    NOTES:      BLT_MASTER_TIMER::Init is called from the APPLICATION
                constructor.  Since a derived application may contain
                a timer, which will be constructed regardless of whether
                or not the application constructed, this method must
                be able to gracefully handle cases where _pBltMasterTimer
                does not point to a successfully constructed master
                timer.

    HISTORY:
        rustanl     09-Sep-1991 Created
        beng        05-Aug-1992 Twiddle error reporting

********************************************************************/

APIERR BLT_MASTER_TIMER::QueryMasterTimer( BLT_MASTER_TIMER * * ppmastertimer )
{
    UIASSERT( ppmastertimer != NULL );

    if ( _pBltMasterTimer == NULL )
        return ERROR_NOT_ENOUGH_MEMORY; // hey, just a guess

    APIERR err = _pBltMasterTimer->QueryError();
    if ( err != NERR_Success )
        return err;

    *ppmastertimer = _pBltMasterTimer;

    return NERR_Success;
}


/*******************************************************************

    NAME:       BLT_MASTER_TIMER::ClearMasterTimerHotkey

    SYNOPSIS:   Clears the hotkey (if any) associated with the master timer,
                and returns its vkey code.

    RETURNS:    vkey code, or NULL if no vkey or on error

    NOTES:      BLT_MASTER_TIMER::Init creates the master timer window,
                which for many apps is the first window they will create.
                Program Manager will assign the default hotkey to this
                window.  This method clears that hotkey and returns its
                vkey code so that the hotkey can be applied to the
                correct window.

    HISTORY:
        jonn        05-Jul-1995 Created

********************************************************************/

ULONG BLT_MASTER_TIMER::ClearMasterTimerHotkey()
{
    BLT_MASTER_TIMER * pbltmastertimer = NULL;
    APIERR err = QueryMasterTimer( &pbltmastertimer );
    if (err != NERR_Success)
    {
        DBGEOL( "NETUI2.DLL: BLT_MASTER_TIMER::ClearMasterTimerHotKey error "
                << err );
        return NULL;
    }
    UIASSERT(   pbltmastertimer != NULL
             && pbltmastertimer->QueryError() == NERR_Success
             && pbltmastertimer->_pclwinTimerApp != NULL );
    TIMER_WINDOW * ptimerMasterTimer = pbltmastertimer->_pclwinTimerApp;
    ULONG vkeyHotkey = (ULONG)ptimerMasterTimer->Command( WM_GETHOTKEY );
    if (vkeyHotkey != NULL)
    {
        ULONG retval = (ULONG)ptimerMasterTimer->Command( WM_SETHOTKEY, NULL );
        switch (retval)
        {
        case 1:
            break;
        case 2:
            TRACEEOL( "NETUI2.DLL: BLT_MASTER_TIMER::ClearMasterTimerHotkey: "
                      << "another window already has hotkey NULL" );
            break;
        default:
            DBGEOL( "NETUI2.DLL: BLT_MASTER_TIMER::ClearMasterTimerHotkey retval "
                    << retval );
        }
    }

    return vkeyHotkey;
}


/*********************************************************************

    NAME:       TIMER_BASE::TIMER_BASE

    SYNOPSIS:   Constructor - create the timer object and add it to the
                master timer list

    ENTRY:      msInterval - Interval, measured in milliseconds, at which
                             the timer should go off.  This interval may
                             not exceed TICKCOUNT_50_PERCENT, which is defined
                             to be exactly half of the number of unique tick
                             counts.  (Today, a tick count is stored in
                             a ULONG, so TICKCOUNT_50_PERCENT amounts to
                             about 25 days.)

                fEnabled -   Specifies whether the timer should be enabled
                             initially.  TRUE (default) means the timer will
                             be created as enabled; FALSE means it will be
                             created as disabled.

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Use QueryMasterTimer method

**********************************************************************/

TIMER_BASE::TIMER_BASE( ULONG msInterval,
                        BOOL fEnabled )
    :   BASE(),
        _msInterval( msInterval ),
        _fEnabled( fEnabled ),
        _ulNextTimerDue( 0 ),   // for now; initialized later in SetNewTimeDue
        _fBeingServed( FALSE ),
        _tid( 0 )               // for now; initialized later in BMT::InsertTimer
{
    if ( QueryError() != NERR_Success )
        return;

    if ( TICKCOUNT_50_PERCENT <= _msInterval )
    {
        ASSERT( FALSE ); // Interval too long. Can only support intervals less than TICKCOUNT_50_PERCENT
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

    if ( fEnabled )
        SetNewTimeDue();

    BLT_MASTER_TIMER * pmastertimer;
    APIERR err;
    if (   (err = BLT_MASTER_TIMER::QueryMasterTimer( &pmastertimer ))
                                                     != NERR_Success
        || (err = pmastertimer->InsertTimer( this )) != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*********************************************************************

    NAME:       TIMER_BASE::~TIMER_BASE

    SYNOPSIS:   destructor - delete the blt timer object from the
                master timer list

    HISTORY:
                terryk  30-May-91   Created
                rustanl 09-Sep-91   Use QueryMasterTimer method

**********************************************************************/

TIMER_BASE::~TIMER_BASE()
{
    BLT_MASTER_TIMER * pmastertimer;
    if ( BLT_MASTER_TIMER::QueryMasterTimer( &pmastertimer ) == NERR_Success )
    {
        pmastertimer->RemoveTimer( this );
    }
}


/*******************************************************************

    NAME:       TIMER_BASE::SetNewTimeDue

    SYNOPSIS:   Sets up the next time at which the timer is due

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID TIMER_BASE::SetNewTimeDue()
{
    _ulNextTimerDue = ::GetTickCount() + _msInterval;
}


/*********************************************************************

    NAME:       TIMER_BASE::Enable

    SYNOPSIS:   Enables or disables the timer

    ENTRY:      fEnable -       TRUE to enable the timer; FALSE to disable
                                the timer

    HISTORY:
        rustanl     10-Sep-1991     Created

**********************************************************************/

VOID TIMER_BASE::Enable( BOOL fEnable )
{
    if ( fEnable && !_fEnabled )
    {
        SetNewTimeDue();
    }

    _fEnabled = fEnable;
}


/*******************************************************************

    NAME:       TIMER_BASE::DispatchTimer

    SYNOPSIS:   Dispatches the timer

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID TIMER_BASE::DispatchTimer()
{
    //  do nothing
}


/*******************************************************************

    NAME:       TIMER_BASE::TriggerNow

    SYNOPSIS:   Forces the timer to be triggered.  Does not affect
                the next interval at which it will ripen anyway.

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID TIMER_BASE::TriggerNow()
{
    DispatchTimer();
}


/*******************************************************************

    NAME:       WINDOW_TIMER::WINDOW_TIMER

    SYNOPSIS:   WINDOW_TIMER constructor

    ENTRY:      hwnd -      Window handle of window that will receive the
                            timers
                            CODEWORK.  Could create version of constructor
                            that takes a WINDOW *.  However, the TIMER
                            class seems like a better choice anyway since
                            we have control over it, rather than that
                            Windows imposes its queue priorities.

                msInterval - Interval, measured in milliseconds, at which
                             the timer should go off.

                fEnabled -   Specifies whether the timer should be enabled
                             initially.  TRUE (default) means the timer will
                             be created as enabled; FALSE means it will be
                             created as disabled.

                fPostMsg -  Specifies whether timer messages should be
                            posted or sent.  TRUE indicates they will
                            be posted; FALSE (default) indicates they will
                            be sent.

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

WINDOW_TIMER::WINDOW_TIMER( HWND hwnd,
                            ULONG msInterval,
                            BOOL fEnabled,
                            BOOL fPostMsg     )
    :   TIMER_BASE( msInterval, fEnabled ),
        _hwnd( hwnd ),
        _fPostMsg( fPostMsg )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( _hwnd != NULL );
}


/*******************************************************************

    NAME:       WINDOW_TIMER::DispatchTimer

    SYNOPSIS:   Dispatches the timer

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID WINDOW_TIMER::DispatchTimer()
{
    if ( _fPostMsg )
    {
        // post a message to the window
        ::PostMessage( _hwnd, WM_TIMER, QueryID(), NULL );
    }
    else
    {
        // send a message to the window
        ::SendMessage( _hwnd, WM_TIMER, QueryID(), NULL );
    }
}


/*******************************************************************

    NAME:       PROC_TIMER::PROC_TIMER

    SYNOPSIS:   PROC_TIMER constructor

    ENTRY:      hwnd -          Handle to window to be used

                lpTimerFunc -   Pointer to timer function which will
                                get timer notifications

                msInterval -    Interval, measured in milliseconds, at which
                                the timer should go off.

                fEnabled -   Specifies whether the timer should be enabled
                             initially.  TRUE (default) means the timer will
                             be created as enabled; FALSE means it will be
                             created as disabled.

    HISTORY:
        rustanl     06-Sep-1991 Created
        beng        17-Oct-1991 Win32 conversion

********************************************************************/

PROC_TIMER::PROC_TIMER( HWND hwnd,
                        MFARPROC lpTimerFunc,
                        ULONG msInterval,
                        BOOL fEnabled          )
    :   TIMER_BASE( msInterval, fEnabled ),
        _hwnd( hwnd ),
        _lpTimerFunc( lpTimerFunc )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( lpTimerFunc != NULL );
}


/*******************************************************************

    NAME:       PROC_TIMER::DispatchTimer

    SYNOPSIS:   Dispatches the timer

    HISTORY:
        rustanl     06-Sep-1991 Created
        beng        17-Oct-1991 Win32 conversion

********************************************************************/

VOID PROC_TIMER::DispatchTimer()
{
    // directly call the WndProc
    ::CallWindowProc( (WNDPROC)_lpTimerFunc, _hwnd, WM_TIMER,
                      QueryID(), NULL );
}


/*******************************************************************

    NAME:       TIMER_CALLOUT::OnTimerNotification

    SYNOPSIS:   Called when a TIMER object matures

    ENTRY:      tid -       Specifies the timer ID of the timer that
                            matured

    HISTORY:
        rustanl     09-Sep-1991     Created

********************************************************************/

VOID TIMER_CALLOUT::OnTimerNotification( TIMER_ID tid )
{
    UNREFERENCED( tid );

    DBGEOL( "TIMER_CALLOUT::OnTimerNotification called with tid="
           << (UINT)tid );
}


/*******************************************************************

    NAME:       TIMER::TIMER

    SYNOPSIS:   TIMER constructor

    ENTRY:      ptimercallout - Pointer to TIMER_CALLOUT object which will
                                receive timer notifications

                msInterval -    Interval, measured in milliseconds, at which
                                the timer should go off.

                fEnabled -   Specifies whether the timer should be enabled
                             initially.  TRUE (default) means the timer will
                             be created as enabled; FALSE means it will be
                             created as disabled.

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

TIMER::TIMER( TIMER_CALLOUT * ptimercallout,
              ULONG msInterval,
              BOOL fEnabled                    )
    :   TIMER_BASE( msInterval, fEnabled ),
        _ptimercallout( ptimercallout )
{
    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( ptimercallout != NULL );
}


/*******************************************************************

    NAME:       TIMER::DispatchTimer

    SYNOPSIS:   Dispatches the timer

    HISTORY:
        rustanl     06-Sep-1991     Created

********************************************************************/

VOID TIMER::DispatchTimer()
{
    _ptimercallout->OnTimerNotification( QueryID());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\maskmap.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    Maskmap.cxx

    This file contains the implementation for the MASK_MAP class.

    FILE HISTORY:
	Johnl	02-Aug-1991	Created

*/

#include "pchblt.hxx"  //  Precompiled header inclusion

#include "maskmap.hxx"


DEFINE_SLIST_OF( STRING_BITSET_PAIR ) ;

/*******************************************************************

    NAME:	MASK_MAP::MASK_MAP

    SYNOPSIS:	Constructor, does nothing except initialize slist and
		iterators.

    NOTES:

    HISTORY:
	Johnl	02-Aug-1991	Created

********************************************************************/

MASK_MAP::MASK_MAP()
  : _slbitnlsPairs( TRUE ),
    _sliterStrings( _slbitnlsPairs ),
    _sliterBits( _slbitnlsPairs )
{
    /* Nothing to do */

}

MASK_MAP::~MASK_MAP()
{ }
/*******************************************************************

    NAME:	MASK_MAP::Add

    SYNOPSIS:	Adds an association to the MASK_MAP

    ENTRY:	bitfieldMask - Bitfield to associate the string with
		nlsString    - String to associate the bitfield with
		nID	     - User defined ID to categorize the association

    RETURNS:	NERR_Success if the addition was successful, an
		appropriate error code otherwise

    NOTES:

    HISTORY:
	Johnl	02-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::Add( const BITFIELD & bitfieldMask,
		      const NLS_STR  & nlsString,
		      INT   nID )
{
    UIASSERT( bitfieldMask.QueryError() == NERR_Success ) ;
    UIASSERT( nlsString.QueryError() == NERR_Success ) ;

    STRING_BITSET_PAIR * pnewpair = new STRING_BITSET_PAIR( nlsString,
							    bitfieldMask, nID ) ;
    if ( pnewpair == NULL )
	return ERROR_NOT_ENOUGH_MEMORY ;

    APIERR err = pnewpair->QueryError()  ;
    if ( err != NERR_Success )
    {
	delete pnewpair ;
	return err ;
    }

    err = _slbitnlsPairs.Append( pnewpair ) ;

    return err ;
}

/*******************************************************************

    NAME:	MASK_MAP::Add

    SYNOPSIS:	Adds multiple entities based on the passed array.  Good
		for static initializers.  Automatically loads the string
		IDS using nls.LoadString.

    ENTRY:	usidspairs - Array of struct US_IDS_PAIRS
		cCount - Number of items in the array

    EXIT:	The MASK_MAP will be initialized with the data in the
		array if no error occurs.

    RETURNS:	NERR_Success if no error occurred.

    NOTES:

    HISTORY:
	Johnl	9-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::Add( US_IDS_PAIRS usidspairs[], USHORT cCount )
{
    APIERR err ;
    NLS_STR  nls ;

    for ( unsigned i = 0 ; i < cCount ; i++ )
    {
	BITFIELD bitsMask( (USHORT)usidspairs[i].usBitMask ) ;

	if ( err = nls.Load( usidspairs[i].idsStringID ) != NERR_Success )
	    return err ;

	if ( (err = Add( bitsMask, nls, usidspairs[i].nID )) != NERR_Success )
	    return err ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:	MASK_MAP::BitsToString

    SYNOPSIS:	Finds the first bitfield in the list that matches the
		passed bitfield, and returns its associated string.

    ENTRY:	bitfieldKey - Search key
		pnlsString - Pointer to NLS_STR that will receive this
		    associated string

    EXIT:	pnlsString will contain the associated string

    RETURNS:	NERR_Success if successful
		ERROR_NO_ITEMS if the matching bitfield is not found
		Some Other standard error

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::BitsToString( const BITFIELD & bitfieldKey,
			       NLS_STR	* pnlsString,
			       INT	  nID,
			       UINT	* puiFoundIndex )
{
    ITER_SL_OF(STRING_BITSET_PAIR) sliter( _slbitnlsPairs ) ;
    STRING_BITSET_PAIR * pbitnlsPair ;
    UINT uiFoundIndex = 0 ;

    while ( (pbitnlsPair = sliter.Next()) != NULL )
    {
	if ( (BITFIELD &) bitfieldKey == *(pbitnlsPair->QueryBitfield()) &&
	     nID == pbitnlsPair->QueryID() )
	{
	    *pnlsString = *(pbitnlsPair->QueryString()) ;
	    if ( puiFoundIndex != NULL )
		*puiFoundIndex = uiFoundIndex ;

	    return pnlsString->QueryError() ;
	}

	uiFoundIndex++ ;
    }

    // Couldn't find a match, return a "couldn't find" error message
    return ERROR_NO_ITEMS ;
}

/*******************************************************************

    NAME:	MASK_MAP::StringToBits

    SYNOPSIS:	Finds the first string in the list that matches the
		passed key string, and returns its associated bitfield.

    ENTRY:	nlsStringKey - Search key
		pbitfield - Pointer to BITFIELD that will receive this
		    associated bitfield

    EXIT:	pbitfield will contain the associated bitfield

    RETURNS:	NERR_Success if successful
		ERROR_NO_ITEMS if the matching bitfield is not found
		Some Other standard error

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::StringToBits( const NLS_STR  & nlsStringKey,
			       BITFIELD * pbitfield,
			       INT	  nID,
			       UINT	* puiFoundIndex )
{
    ITER_SL_OF(STRING_BITSET_PAIR) sliter( _slbitnlsPairs ) ;
    STRING_BITSET_PAIR * pbitnlsPair ;
    UINT uiFoundIndex = 0 ;

    while ( (pbitnlsPair = sliter.Next()) != NULL )
    {
	if ( *(pbitnlsPair->QueryString()) == nlsStringKey &&
	     nID == pbitnlsPair->QueryID()  )
	{
	    APIERR err = pbitfield->Resize( (pbitnlsPair->QueryBitfield())->QueryCount() ) ;
	    if ( err != NERR_Success )
		return err ;

	    *pbitfield = *(pbitnlsPair->QueryBitfield()) ;
	    if ( puiFoundIndex != NULL )
		*puiFoundIndex = uiFoundIndex ;
	    return pbitfield->QueryError() ;
	}

	uiFoundIndex++ ;
    }

    // Couldn't find a match, return a "couldn't find" error message
    return ERROR_NO_ITEMS ;

}

/*******************************************************************

    NAME:	MASK_MAP::EnumStrings

    SYNOPSIS:	Lists all of the strings in the table with a particular
		ID.

    ENTRY:	pnlsString - Pointer to receive enumerated string
		pfMoreData - Set to FALSE when no more data
		fFromBeginning - Start listing from beginning (should be
		    set to FALSE on subsequent calls)
		nID - Enumerate all values with this ID

    EXIT:	pnlsString will contain the enumerated string
		pfMoreData will be set to FALSE if there isn't any(more)
		    data to enumerate

    RETURNS:	NERR_Success if all went well, else some standard error code.

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::EnumStrings( NLS_STR * pnlsString,
			      BOOL *	pfMoreData,
			      BOOL *	pfFromBeginning,
			      INT	nID )
{
    if ( *pfFromBeginning )
    {
	_sliterStrings.Reset() ;
	*pfFromBeginning = FALSE ;
    }

    STRING_BITSET_PAIR * pbitnlsPair ;

    while ( (pbitnlsPair = _sliterStrings.Next()) != NULL )
    {
	if ( pbitnlsPair->QueryID() == nID )
	{
	    *pnlsString = *(pbitnlsPair->QueryString()) ;
	    *pfMoreData = TRUE ;
	    return pnlsString->QueryError() ;
	}
    }

    *pfMoreData = FALSE ;
    return NERR_Success ;
}


/*******************************************************************

    NAME:	MASK_MAP::EnumBits

    SYNOPSIS:	Lists all of the bitfields in the table with a particular
		ID.

    ENTRY:	pbitfield - Pointer to receive enumerated bitield
		pfMoreData - Set to FALSE when no more data
		fFromBeginning - Start listing from beginning (should be
		    set to FALSE on subsequent calls)
		nID - Enumerate all values with this ID

    EXIT:	pbitfield will contain the enumerated bitfield
		pfMoreData will be set to FALSE if there isn't any(more)
		    data to enumerate

    RETURNS:	NERR_Success if all went well, else some standard error code.

    NOTES:

    HISTORY:
	Johnl	05-Aug-1991	Created

********************************************************************/

APIERR MASK_MAP::EnumBits( BITFIELD* pbitfield,
			   BOOL *    pfMoreData,
			   BOOL *    pfFromBeginning,
			   INT	     nID )

{
    if ( *pfFromBeginning )
    {
	_sliterStrings.Reset() ;
	*pfFromBeginning = FALSE ;
    }

    STRING_BITSET_PAIR * pbitnlsPair ;

    while ( (pbitnlsPair = _sliterStrings.Next()) != NULL )
    {
	if ( pbitnlsPair->QueryID() == nID )
	{
	    *pbitfield = *(pbitnlsPair->QueryBitfield()) ;
	    *pfMoreData = TRUE ;
	    return pbitfield->QueryError() ;
	}
    }

    *pfMoreData = FALSE ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:	MASK_MAP::QueryBits

    SYNOPSIS:	Retrieves the nth item of this mask map

    ENTRY:	uiIndex - index of string/bitfield pair to retrieve
		pbitfield - pointer to bitfield to receive the bitfield
		pnlsString - Pointer to NLS_STR to receive the string
		pnID	   - Pointer to the ID for this entry.	If it is
		    NULL, then this parameter is ignored.

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	10-Feb-1992	Created

********************************************************************/

APIERR MASK_MAP::QueryBits(   UINT	       uiIndex,
			      BITFIELD	     * pbitfield,
			      NLS_STR	     * pnlsString,
			      int	     * pnID	  )
{
    ITER_SL_OF(STRING_BITSET_PAIR) sliter( _slbitnlsPairs ) ;
    STRING_BITSET_PAIR * pbitnlsPair ;

    if ( uiIndex > QueryCount() )
	return ERROR_INVALID_PARAMETER ;

    while ( (pbitnlsPair = sliter.Next()) != NULL )
    {
	if ( uiIndex-- == 0 )
	{
	    break ;
	}
    }

    UIASSERT( pbitnlsPair != NULL ) ;

    APIERR err = pbitfield->Resize( (pbitnlsPair->QueryBitfield())->QueryCount() ) ;
    if ( err != NERR_Success )
	return err ;

    *pbitfield = *(pbitnlsPair->QueryBitfield()) ;
    *pnlsString = *(pbitnlsPair->QueryString()) ;

    if ( pnID != NULL )
	*pnID = pbitnlsPair->QueryID() ;

    return (pbitfield->QueryError() ? pbitfield->QueryError() :
					      pnlsString->QueryError()) ;
}

/*******************************************************************

    NAME:       MASK_MAP::IsPresent

    SYNOPSIS:   Makes sure all of the bits contained in the past bitfield
                have corresponding bits in this mask map.

    ENTRY:      pbitfield - Bitfield to look for

    RETURNS:    TRUE if found, FALSE otherwise

    NOTES:

    HISTORY:
        Johnl   02-Feb-1993     Created

********************************************************************/

BOOL MASK_MAP::IsPresent( BITFIELD * pbitfield )
{
    UIASSERT( pbitfield != NULL ) ;
    BITFIELD bitfield( *pbitfield ) ;

    if ( bitfield.QueryError() )
        return FALSE ;

    ITER_SL_OF(STRING_BITSET_PAIR) sliter( _slbitnlsPairs ) ;
    STRING_BITSET_PAIR * pbitnlsPair ;
    BOOL fFound = FALSE ;

    while ( (pbitnlsPair = sliter.Next()) != NULL )
    {
        bitfield |= *pbitnlsPair->QueryBitfield() ;

        //
        //  Get out early if we found an exact match
        //
        if ( *pbitnlsPair->QueryBitfield() == *pbitfield )
        {
            fFound = TRUE ;
	    break ;
	}
    }

    if ( !fFound )
    {
        bitfield.Not() ;
        fFound = !(bitfield & *pbitfield) ;
    }

    return fFound ;
}

/*******************************************************************

    NAME:	STRING_BITSET_PAIR::STRING_BITSET_PAIR

    SYNOPSIS:	Constructor for the STRING_BITSET_PAIR class

    ENTRY:	nlsString - string to associate with this bitfield
		bitfieldMask - Bitfield to associate with this string
		nID is a user defined tag that can be used to group
		    the bitset/string pairs.

    NOTES:

    HISTORY:
	Johnl	02-Aug-1991	Created

********************************************************************/

STRING_BITSET_PAIR::STRING_BITSET_PAIR( const NLS_STR &  nlsString,
					const BITFIELD & bitfieldMask,
					      INT	 nID	       )
    : _nlsString( nlsString ),
      _bitfieldMask( bitfieldMask ),
      _nID( nID )
{
    APIERR err ;
    if ( ( err = _nlsString.QueryError() ) ||
	 ( err = _bitfieldMask.QueryError() ) )
    {
	ReportError( err ) ;
	return ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltcolh.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltcolh.cxx
    Column header control implementation

    The column header control typically goes above a listbox where
    it tells the contents of each listbox column.


    FILE HISTORY:
	rustanl     22-Jul-1991     Created
	rustanl     07-Aug-1991     Added to BLT

*/


#include "pchblt.hxx"  // Precompiled header


/*******************************************************************

    NAME:	LB_COLUMN_HEADER::LB_COLUMN_HEADER

    SYNOPSIS:	LB_COLUMN_HEADER constructor

    ENTRY:	powin - 	Pointer to owner window
		cid -		Control ID
		xy -		Window position
		dxy -		Window size

    HISTORY:
	rustanl     22-Jul-1991     Created
	beng	    31-Jul-1991     Control error handling changed
        congpay     07-Jan-1993     add QueryHeight()

********************************************************************/

LB_COLUMN_HEADER::LB_COLUMN_HEADER( OWNER_WINDOW * powin, CID cid,
				    XYPOINT xy, XYDIMENSION dxy )
    :	SLT( powin, cid, xy, dxy,
	     SS_LEFT | WS_CHILD ),
	CUSTOM_CONTROL( this )
{
    if ( QueryError() != NERR_Success )
	return;
}

INT LB_COLUMN_HEADER::QueryHeight()
{
    DISPLAY_CONTEXT dc (this);

    return ((dc.QueryFontHeight()) + (METALLIC_STR_DTE::QueryVerticalMargins()));
}


/*********************************************************************

    NAME:       LB_COLUMN_HEADER::Dispatch

    SYNOPSIS:   Main routine to dispatch the event appropriately

    ENTRY:      EVENT event - general event

    HISTORY:
        jonn        26-May-1993 Created

*********************************************************************/

BOOL LB_COLUMN_HEADER::Dispatch( const EVENT &event, ULONG * pnRes )
{
    if ( event.QueryMessage() == WM_ERASEBKGND )
    {
        DWORD dwColor = ::GetSysColor( COLOR_WINDOW );

        HBRUSH hBrush = ::CreateSolidBrush( dwColor );
        ASSERT( hBrush != NULL );

        RECT r;
        QueryClientRect( &r );
        REQUIRE( ::FillRect( (HDC)event.QueryWParam(), &r, hBrush ) != FALSE );

        REQUIRE( ::DeleteObject( hBrush ) != FALSE );

        return TRUE;
    }

    return CUSTOM_CONTROL::Dispatch( event, pnRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltarrow.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltarrow.cxx
        Source file for SPIN_GROUP 's arrow control

    FILE HISTORY:
        terryk  15-May-91   Created
        terryk  12-Aug-91   create its own timer instead of using the
                            BLT_TIMER class
        terryk  19-Aug-91   Add OnLMouseDblClk to handle double click
                            problem
        terryk  26-Aug-91   Change the button behavious such that it
                            will be released if the mouse moves outside
                            the button area.
*/

#include "pchblt.hxx"  // Precompiled header



#define TIME_DELAY (75)


/**********************************************************************

    NAME:       ARROW_BUTTON::ARROW_BUTTON

    SYNOPSIS:   constructor for the arrow button within the
                SPIN_GROUP .

    ENTRY:      OWNER_WINDOW *powin - owner window of the control
                CID cid - cid of the control
                TCHAR * pszEnable - enable bitmap name
                TCHAR * pszEnableInvert - enable invert bitmap name
                CHA R* pszDisable - disable bitmap name

    HISTORY:
        terryk      15-May-91   Created
        beng        31-Jul-1991 Control error handling changed
        beng        17-Sep-1991 Elided winclass name (now uses that of
                                button control)
        beng        05-Oct-1991 Win32 conversion
        beng        04-Aug-1992 Load bitmaps by ordinal

**********************************************************************/

ARROW_BUTTON::ARROW_BUTTON( OWNER_WINDOW *powin, CID cid,
                            BMID nIdEnable, BMID nIdEnableInvert,
                            BMID nIdDisable )
    : GRAPHICAL_BUTTON_WITH_DISABLE( powin, cid, nIdEnable, nIdEnableInvert,
                                     nIdDisable ),
      CUSTOM_CONTROL( this ),
      _cTimerClick ( 0 ),
      _fPress( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

ARROW_BUTTON::ARROW_BUTTON( OWNER_WINDOW *powin, CID cid,
                            BMID nIdEnable, BMID nIdEnableInvert,
                            BMID nIdDisable,
                            XYPOINT pXY, XYDIMENSION dXY, ULONG flStyle )
    : GRAPHICAL_BUTTON_WITH_DISABLE( powin, cid, nIdEnable, nIdEnableInvert,
                                     nIdDisable, pXY, dXY, flStyle ),
      CUSTOM_CONTROL( this ),
      _cTimerClick ( 0 ),
      _fPress( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}


/*********************************************************************

    NAME:       ARROW_BUTTON::OnLMouseButtonDown

    SYNOPSIS:   Start the timer when the mouse button is down

    ENTRY:      MOUSE_EVENT &event

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

BOOL ARROW_BUTTON::OnLMouseButtonDown( const MOUSE_EVENT &event )
{
    UNREFERENCED( event );

    CaptureMouse();
    SetSelected( TRUE );
    Invalidate();
    RepaintNow();
    _fPress = TRUE;
    _cTimerClick = 0;
    REQUIRE( ::SetTimer( WINDOW::QueryHwnd(), 1, TIME_DELAY, NULL ) != 0 );
    return TRUE;
}


/*********************************************************************

    NAME:       ARROW_BUTTON::OnLMouseButtonUp

    SYNOPSIS:   stop the timer when the Mouse button up

    ENTRY:      MOUSE_EVENT &event

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

#define CLICK_COUNTER   20

BOOL ARROW_BUTTON::OnLMouseButtonUp( const MOUSE_EVENT & event )
{
    if ( !_fPress )
        return TRUE;

    _fPress = FALSE;
    ReleaseMouse();
    SetSelected( FALSE );
    REQUIRE( ::KillTimer( WINDOW::QueryHwnd(), 1 ));
    Invalidate();
    RepaintNow();

    XYRECT xyrect( WINDOW::QueryHwnd() );
    if ( xyrect.ContainsXY( event.QueryPos() ))
    {
        SPIN_GROUP  *pSB = (SPIN_GROUP *)QueryGroup();

        if ( _cTimerClick > CLICK_COUNTER )
        {
            pSB->DoArrowCommand( QueryCid(), SPN_ARROW_BIGINC );
        }
        else
        {
            pSB->DoArrowCommand( QueryCid(), SPN_ARROW_SMALLINC );
            _cTimerClick ++;
        }
    }
    _cTimerClick = 0;
    return TRUE;
}


/*********************************************************************

    NAME:       ARROW_BUTTON::OnTimer

    SYNOPSIS:   For each timer message, send a increase message to
                the spin button

    ENTRY:      TIMER_EVENT &tEvent

    HISTORY:
        terryk      29-May-91   Created
        beng        16-Oct-1991 Win32 conversion

*********************************************************************/

BOOL ARROW_BUTTON::OnTimer( const TIMER_EVENT & tEvent )
{
    UNREFERENCED( tEvent );

    BOOL fOldSelected = QuerySelected();

    XYPOINT xy = CURSOR::QueryPos();
    xy.ScreenToClient( WINDOW::QueryHwnd() );

    XYRECT xyrect( WINDOW::QueryHwnd() );
    if ( xyrect.ContainsXY( xy ))
    {
        SetSelected( TRUE );
        SPIN_GROUP  *pSB = (SPIN_GROUP *)QueryGroup();

        if ( _cTimerClick > 10 )
        {
            pSB->DoArrowCommand( QueryCid(), SPN_ARROW_BIGINC );
        }
        else
        {
            if ( _cTimerClick % 2 == 1 )
            pSB->DoArrowCommand( QueryCid(), SPN_ARROW_SMALLINC );
            _cTimerClick ++;
        }
    }
    else
    {
        SetSelected( FALSE );
    }
    if ( fOldSelected != QuerySelected() )
    {
        Invalidate();
        RepaintNow();
    }
    return TRUE;
}


/*********************************************************************

    NAME:       ARROW_BUTTON::QueryEventEffects

    SYNOPSIS:   request for the button status after this WM_COMMAND

    ENTRY:      Args of the WM_COMMAND

    RETURN:     CVMI_VALUE_CHANGE of the command is a clicked.
                CVMI_NO_VALUE_CHANGE otherwise.

    HISTORY:
        terryk      10-Jul-1991 Created
        beng        31-Jul-1991 Renamed, from QMessageInfo
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

UINT ARROW_BUTTON::QueryEventEffects( const CONTROL_EVENT & e )
{
    switch( e.QueryCode() )
    {
    case BN_CLICKED:
        return CVMI_VALUE_CHANGE;

    default:
        break;
    }
    return CVMI_NO_VALUE_CHANGE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltbmctl.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltbmctl.cxx
    BIT_MAP_CONTROL declaration

    FILE HISTORY:
        JonN        13-Aug-1992 Created
*/

#include "pchblt.hxx"  // Precompiled header


/*******************************************************************

    NAME:     BIT_MAP_CONTROL::BIT_MAP_CONTROL

    SYNOPSIS: Static bitmap control class

    ENTRY:    powin - Owner window of this control
              cidBitmap - Control ID of the bitmap

    EXIT:

    HISTORY:
        JonN        11-Aug-1992     Created (templated from LOGON_HOURS_CONTROL)

********************************************************************/

BIT_MAP_CONTROL::BIT_MAP_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidBitmap,
    BMID           bmid )
    : CONTROL_WINDOW( powin, cidBitmap ),
      CUSTOM_CONTROL( this ),
      _dmap( bmid )
{
    if (QueryError())
        return;

    APIERR err = _dmap.QueryError();
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

BIT_MAP_CONTROL::BIT_MAP_CONTROL(
    OWNER_WINDOW * powin,
    CID            cidBitmap,
    XYPOINT        xy,
    XYDIMENSION    dxy,
    BMID           bmid,
    ULONG          flStyle,
    const TCHAR *   pszClassName )
    : CONTROL_WINDOW( powin, cidBitmap, xy, dxy, flStyle, pszClassName ),
      CUSTOM_CONTROL( this ),
      _dmap( bmid )
{
    if (QueryError())
        return;

    APIERR err = _dmap.QueryError();
    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*********************************************************************

    NAME:       BIT_MAP_CONTROL::OnPaintReq

    SYNOPSIS:   Handles paint messages for the control

    HISTORY:
        jonn        13-Aug-1992 Templated from LOGON_HOURS_CONTROL

**********************************************************************/

BOOL BIT_MAP_CONTROL::OnPaintReq()
{
    if (QueryError() != NERR_Success)
        return FALSE; // bail out!

    PAINT_DISPLAY_CONTEXT dc(this);

    return _dmap.Paint( dc.QueryHdc(), 0, 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\blt\progress.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    progress.cx
    This file contains the class definition for the PROGRESS_CONTROL
    class.

    The PROGRESS_CONTROL class is a display object derived from the
    ICON_CONTROL class.  PROGRESS_CONTROL adds a new method Advance()
    for cycling through a set of icons.


    FILE HISTORY:
        KeithMo     03-Oct-1991 Created.
        KeithMo     06-Oct-1991 Win32 Conversion.

*/
#include "pchblt.hxx"  // Precompiled header

//
//  PROGRESS_INDICATOR methods.
//

/*******************************************************************

    NAME:       PROGRESS_CONTROL :: PROGRESS_CONTROL

    SYNOPSIS:   PROGRESS_CONTROL class constructor.

    ENTRY:      powner                  - Owning window.

                cid                     - Cid for this control

                idFirstIcon             - Resource ID for the first
                                          icon in the icon list.

                cIcons                  - The number of icons to cycle.

    HISTORY:
        KeithMo     03-Oct-1991 Created.

********************************************************************/
PROGRESS_CONTROL :: PROGRESS_CONTROL( OWNER_WINDOW * powner,
                                      CID            cid,
                                      UINT           idFirstIcon,
                                      UINT           cIcons )
  : ICON_CONTROL( powner, cid ),
    _cIcons( cIcons ),
    _idFirstIcon( idFirstIcon ),
    _usCurrent( 0 )
{
    CtAux();

}   // PROGRESS_CONTROL :: PROGRESS_CONTROL


/*******************************************************************

    NAME:       PROGRESS_CONTROL :: ~PROGRESS_CONTROL

    SYNOPSIS:   PROGRESS_CONTROL class destructor.

    HISTORY:
        KeithMo     03-Oct-1991 Created.

********************************************************************/
PROGRESS_CONTROL :: ~PROGRESS_CONTROL()
{
    //
    //  This space intentionally left blank.
    //

}   // PROGRESS_CONTROL :: ~PROGRESS_CONTROL


/*******************************************************************

    NAME:       PROGRESS_CONTROL :: CtAux

    SYNOPSIS:   Auxilliary constructor.

    HISTORY:
        KeithMo     03-Oct-1991 Created.

********************************************************************/
VOID PROGRESS_CONTROL :: CtAux( VOID )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Display the initial icon.
    //

    Advance();

}   // PROGRESS_CONTROL :: CtAux


/*******************************************************************

    NAME:       PROGRESS_CONTROL :: Advance

    SYNOPSIS:   Advance the progress indicator to the next icon.

    ENTRY:      nStep                   - The number of "steps" to
                                          increment the icon by.
                                          Default = 1.

    HISTORY:
        KeithMo     03-Oct-1991 Created.

********************************************************************/
VOID PROGRESS_CONTROL :: Advance( INT nStep )
{
    //
    //  Display the current icon.
    //

    SetIcon( MAKEINTRESOURCE( _idFirstIcon + _usCurrent ) );

#ifdef WIN32
    //
    //  We need this Invalidate() call here to get around a bug
    //  in Win/NT which causes icon controls to not be repainted
    //  after a STM_SETICON message.  Remove this bulls**t when
    //  NT has been fixed!
    //

    Invalidate( TRUE );
#endif

    //
    //  Advance to the next icon in the cycle.
    //

    _usCurrent = ( _usCurrent + nStep ) % _cIcons;

}   // PROGRESS_CONTROL :: Advance
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltlhour.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    bltlhour.cxx
    Source file for the Logon Hours custom control

    FILE HISTORY:
        beng        07-May-1992 Created
        KeithMo     07-Aug-1992 STRICTified.
        KeithMo     03-Nov-1992 Added hash marks, fixed some paint bugs.
*/

#include "pchblt.hxx"  // Precompiled header


// All lines ("wires") in the grid are 1x1

#define DXGRIDWIRES 1
#define DYGRIDWIRES 1

//
//  Drawing area offset from top of control.
//

#define Y_OFFSET (_dyRow + DYGRIDWIRES)


const TCHAR * LOGON_HOURS_CONTROL::_pszClassName = SZ("static");


inline VOID LOGON_HOURS_CONTROL::Beep() const
{
    ::MessageBeep(0);
}

inline BOOL LOGON_HOURS_CONTROL::IsButtonACell( INT iButton ) const
{
    return (iButton > 32);
}


/*********************************************************************

    NAME:       LOGON_HOURS_CONTROL::LOGON_HOURS_CONTROL

    SYNOPSIS:   Ctor for logon-hours custom control.

    ENTRY:      powin - owner window of the control
                cid   - cid of the control

    HISTORY:
        beng        07-May-1992 Created

**********************************************************************/

LOGON_HOURS_CONTROL::LOGON_HOURS_CONTROL( OWNER_WINDOW *powin, CID cid )
    : CONTROL_WINDOW( powin, cid ),
      CUSTOM_CONTROL( this ),
      _hcurCross( CURSOR::LoadSystem(IDC_CROSS) ),
      _fSpaceIsDown(FALSE),
      _fMouseTrap(FALSE),
      _fFocusVisible(FALSE),
      _fCellsSelected(FALSE),
      _iCellSelUpper(0),
      _iCellSelLower(0),
      _iButtonDown(0), // Start with no buttons down
      _iWithFocus(33),
      _iFocusSave(33)  // Upper lefthand cell gets initial focus
{
    APIERR err = QueryError();
    if (err != NERR_Success)
        return;

    ::memset(_abSetting, 0, sizeof(_abSetting));

    HFONT hfont = (HFONT) ::SendMessage(QueryOwnerHwnd(), WM_GETFONT, 0, 0);
    if (hfont != NULL)
        SetFont(hfont);

    err = LoadLabels( IDS_SUNDAY );
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    err = CalcSizes(QuerySize());
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    Invalidate();
}

LOGON_HOURS_CONTROL::LOGON_HOURS_CONTROL( OWNER_WINDOW *powin, CID cid,
                                          XYPOINT xy, XYDIMENSION dxy )
    : CONTROL_WINDOW( powin, cid, xy, dxy, WS_CHILD, _pszClassName ),
      CUSTOM_CONTROL( this ),
      _hcurCross( CURSOR::LoadSystem(IDC_CROSS) ),
      _fSpaceIsDown(FALSE),
      _fMouseTrap(FALSE),
      _fFocusVisible(FALSE),
      _fCellsSelected(FALSE),
      _iCellSelUpper(0),
      _iCellSelLower(0),
      _iButtonDown(0), // Start with no buttons down
      _iWithFocus(33),
      _iFocusSave(33)  // Upper lefthand cell gets initial focus
{
    APIERR err = QueryError();
    if (err != NERR_Success)
        return;

    ::memset(_abSetting, 0, sizeof(_abSetting));

    HFONT hfont = (HFONT) ::SendMessage(QueryOwnerHwnd(), WM_GETFONT, 0, 0);
    if (hfont != NULL)
        SetFont(hfont);

    err = LoadLabels( IDS_SUNDAY );
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    err = CalcSizes(dxy);
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    Invalidate();
}


/*********************************************************************

    NAME:       LOGON_HOURS_CONTROL::~LOGON_HOURS_CONTROL

    SYNOPSIS:   Dtor for logon-hours custom control.

    HISTORY:
        beng        07-May-1992 Created

**********************************************************************/

LOGON_HOURS_CONTROL::~LOGON_HOURS_CONTROL()
{
    UnloadLabels();
}



/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::QueryHours

    SYNOPSIS:   Queries the control as to the currently permitted hours.

    ENTRY:      plhrs - points to a "setting" collection, into which
                        the control will report its selected hours.

    EXIT:       Setting has been set

    RETURNS:    Error code, NERR_Success if OK

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

APIERR LOGON_HOURS_CONTROL::QueryHours( LOGON_HOURS_SETTING * plhrs ) const
{
    if (plhrs == NULL)
        return ERROR_INVALID_PARAMETER;
    if (!*plhrs)
        return plhrs->QueryError();

    // At present the control and logon hours both count from
    // midnight Sunday, making this a simple loop.

    APIERR err = NERR_Success;
    for (INT iHour = 0; iHour < 24*7 && err == NERR_Success; iHour++)
    {
        err = plhrs->SetHourInWeek( _abSetting[iHour], iHour );
    }

    return err;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::SetHours

    SYNOPSIS:   Paints the "wires" in the grid, along with the borders
                of the control and its buttons.

    ENTRY:      plhrs - points to a "setting" collection containing
                        the desired hours

    EXIT:       _abSetting has changed; grid is inval'd

    RETURNS:    Error code, NERR_Success if OK

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

APIERR LOGON_HOURS_CONTROL::SetHours( const LOGON_HOURS_SETTING * plhrs )
{
    if (plhrs == NULL)
        return ERROR_INVALID_PARAMETER;
    if (!*plhrs)
        return plhrs->QueryError();

    for (INT iHour = 0; iHour < 24*7; iHour++)
    {
        _abSetting[iHour] = (BYTE)plhrs->QueryHourInWeek(iHour);
    }

    // Grid contents now need a complete repaint.  Inval entire grid.

    XYRECT rGrid;
    CalcGridRect(&rGrid);
    Invalidate(rGrid);

    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DoPermitButton

    SYNOPSIS:   Dialog hook, called when user hits Permit

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DoPermitButton()
{
    if (!_fCellsSelected)
        Beep();
    else
    {
        SetSelectedCells(TRUE);
    }
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DoBanButton

    SYNOPSIS:   Dialog hook, called when user hits Ban

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DoBanButton()
{
    if (!_fCellsSelected)
        Beep();
    else
    {
        SetSelectedCells(FALSE);
    }
}


/*********************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnPaintReq

    SYNOPSIS:   Handles paint messages for the control

    NOTES:
        Concerning the layout of the control -

        The control itself subsumes the grid, bars within the grid, quasi
        buttons bounding the grid, and the labels on the Days Of Week buttons.
        It does not include the labels of the Hours Of Day buttons, since those
        at present carry no labels, nor does it include the captions and bitmaps
        above the Hours Of Day buttons, the Permit/Ban push buttons, or any
        other controls which the dialog may need.

        The control takes whatever size its creator specifies and adjusts the
        dimensions of its components accordingly.  It divides itself into 8
        rows, each with equal height, and 25 columns, of which the first column
        contains a labeled quasibutton and so is wider than the remaining
        columns.  The first column sizes itself dynamically to accommodate the
        longest label in its set; the remaining columns divide the remaining
        horizontal space equally between them.

    HISTORY:
        beng        12-May-1992 Created

**********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnPaintReq()
{
    if (QueryError() != NERR_Success)
        return FALSE; // bail out!

    PAINT_DISPLAY_CONTEXT dc(this);

    if (   !DrawBackground(dc)
        || !DrawGridWires(dc)
        || !DrawAllButtons(dc)
        || !DrawGridSetting(dc) )
        return FALSE;

    if (_fFocusVisible)
        DrawFocusSomewhere(dc, _iWithFocus);

    DrawCurrentSelection(dc);

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnFocus

    SYNOPSIS:   Callback when the control receives focus

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnFocus( const FOCUS_EVENT & e )
{
    // Restore the control's subfocus

    _iWithFocus = _iFocusSave;

    // Draw the has-focus rectangle at the correct location

    DISPLAY_CONTEXT dc(this);
    DrawFocusSomewhere(dc, _iWithFocus);
    _fFocusVisible = TRUE;

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnDefocus

    SYNOPSIS:   Callback when the control loses focus

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnDefocus( const FOCUS_EVENT & e )
{
    // Erase the has-focus rectangle if it's present

    if (_fFocusVisible)
    {
        DISPLAY_CONTEXT dc(this);
        DrawFocusSomewhere(dc, _iWithFocus); // will XOR it out of existence
        _fFocusVisible = FALSE;
    }

    // Save away the subfocus, then mark the control as not having any

    _iFocusSave = _iWithFocus;
    _iWithFocus = 0;

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnKeyDown

    SYNOPSIS:   Callback when the control sees a key go down

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnKeyDown( const VKEY_EVENT & e )
{
    switch (e.QueryVKey())
    {
    case VK_LEFT:
        MoveFocusLeft();
        break;

    case VK_RIGHT:
        MoveFocusRight();
        break;

    case VK_UP:
        MoveFocusUp();
        break;

    case VK_DOWN:
        MoveFocusDown();
        break;

    case VK_SPACE:
        if (!_fSpaceIsDown)
        {
            _fSpaceIsDown = TRUE;
            DoButtonDownVisuals();
        }
        break;

    default:
        // Default case throws back to our distant ancestors
        return CUSTOM_CONTROL::OnKeyDown(e);
    }

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnKeyUp

    SYNOPSIS:   Callback when the control sees a key pop back up

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnKeyUp( const VKEY_EVENT & e )
{
    if (_fSpaceIsDown && e.QueryVKey() == VK_SPACE)
    {
        _fSpaceIsDown = FALSE;
        DoButtonUpVisuals();
        return TRUE;
    }

    return CUSTOM_CONTROL::OnKeyUp(e);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnQDlgCode

    SYNOPSIS:   Callback defining the input a control expects from a dlg

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

ULONG LOGON_HOURS_CONTROL::OnQDlgCode()
{
    return (DLGC_WANTARROWS);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnQHitTest

    SYNOPSIS:   Callback determining the subloc within a window

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

ULONG LOGON_HOURS_CONTROL::OnQHitTest( const XYPOINT & xy )
{
    XYPOINT xyTmp = xy;
    xyTmp.ScreenToClient( WINDOW::QueryHwnd() );

    return ( (UINT)xyTmp.QueryY() < Y_OFFSET ) ? HTNOWHERE : HTCLIENT;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnQMouseActivate

    SYNOPSIS:   Callback determining whether a mouse awakens a control

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

ULONG LOGON_HOURS_CONTROL::OnQMouseActivate( const QMOUSEACT_EVENT & e )
{
    UNREFERENCED(e);

    ClaimFocus();
    return MA_ACTIVATE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnQMouseCursor

    SYNOPSIS:   Callback determining whether mouse movement should
                change the cursor

    HISTORY:
        beng        28-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnQMouseCursor( const QMOUSEACT_EVENT & e )
{
    UNREFERENCED(e);

    CURSOR::Set(_hcurCross);
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnLMouseButtonDown

    SYNOPSIS:   Callback on a mouse-down event

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnLMouseButtonDown( const MOUSE_EVENT & e )
{
    XYPOINT xy = e.QueryPos();

    if( (UINT)xy.QueryY() < Y_OFFSET )
        return CUSTOM_CONTROL::OnLMouseButtonDown(e); // punt

    CaptureMouse();
    _fMouseTrap = TRUE;

    INT iLoc = CalcButtonFromPoint(e.QueryPos());
    MoveFocusTo(iLoc);
    DoButtonDownVisuals();

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnLMouseButtonUp

    SYNOPSIS:   Callback on a mouse-up event

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnLMouseButtonUp( const MOUSE_EVENT & e )
{
    if (!_fMouseTrap)
        return CUSTOM_CONTROL::OnLMouseButtonUp(e); // punt

    _fMouseTrap = FALSE;
    ReleaseMouse();

    INT iLoc = CalcButtonFromPoint(e.QueryPos());
    DoButtonUpVisuals(iLoc == (INT)_iButtonDown);

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::OnMouseMove

    SYNOPSIS:   Callback on a mouse-move event

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::OnMouseMove( const MOUSE_EVENT & e )
{
    if (!_fMouseTrap || _iWithFocus == 0)
        return CUSTOM_CONTROL::OnMouseMove(e);

    INT iLoc = CalcButtonFromPoint(e.QueryPos());

    if (!IsButtonACell(_iWithFocus)) // button has focus
    {
        if (_iButtonDown != 0 && iLoc != (INT)_iButtonDown)
            DoButtonUpVisuals(FALSE);
        else if (_iButtonDown == 0 && iLoc == (INT)_iWithFocus)
            DoButtonDownVisuals();
    }
    else                             // cell has focus
    {
        if (IsButtonACell(iLoc))     // drag into another cell?
        {
            SetSelection(_iWithFocus-33, iLoc-33);
        }
    }

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::CalcButtonFromPoint

    SYNOPSIS:   Given a mouse loc, returns the assoc'd button

    ENTRY:      xy - mouse coords (client)

    RETURNS:    "cell index" (which may indicate either a button or
                a cell)

    NOTES:
        Called by OnLButton{Up,Down}, OnMouseMove

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

INT LOGON_HOURS_CONTROL::CalcButtonFromPoint( XYPOINT xy ) const
{
    // Range check.  0 = "nothing" for button indices.

    XYDIMENSION dxy = QuerySize();
    const INT x = xy.QueryX();
    const INT y = xy.QueryY();

    if (x < 0 || x >= (INT)dxy.QueryWidth())
        return 0;
    if (y < 0 || y >= (INT)dxy.QueryHeight())
        return 0;


    // From point, compute [i, j] of the absolute cell or button.
    // The upper lefthand edge belongs to the leftmost/uppermost
    // cell; each cell includes its lower/rightmost edge.

    INT j = (y < (INT)(DYGRIDWIRES + Y_OFFSET))
            ? 0
            : ((y - DYGRIDWIRES - Y_OFFSET) / (_dyRow + DYGRIDWIRES));

    INT i = (x < (INT)(_dxFirstColumn + 2*DXGRIDWIRES))
            ? 0
            : 1 + (x - 2*DXGRIDWIRES - _dxFirstColumn)
                   / (_dxColumn + DXGRIDWIRES);

    ASSERT(i >= 0 && i < 25);
    ASSERT(j >= 0 && j < 8);

    // Convert to button index.

    if (i == 0)      // either day or corner
    {
        if (j == 0)
            return 32;
        else
            return j;
    }
    else if (j == 0) // must be hour
    {
        return i+7;
    }
    else             // must be cell
    {
        return 8 + (j*24) + i;
    }
}


VOID LOGON_HOURS_CONTROL::DoButtonDownVisuals()
{
    if (_iWithFocus > 0 && _iWithFocus < 33)
    {
#if 0
        DISPLAY_CONTEXT dc(this);
        DrawFocusSomewhere(dc, _iWithFocus); // will XOR it out of existence
#endif

        _iButtonDown = _iWithFocus;
        InvalidateButton(_iButtonDown);
    }
    else if (_iWithFocus != 0)
    {
        ASSERT(_iWithFocus < 201);

        // Space-down in a cell:
        // Sets selection to the cell with focus, unless that cell
        // is the only one selected, in which case it deselects it.
        //

        const INT iCellFocus = _iWithFocus-33; // convert c/b index to c index

        if (   _fCellsSelected
            && (_iCellSelUpper == _iCellSelLower)
            && (iCellFocus == (INT)_iCellSelUpper))
        {
            DISPLAY_CONTEXT dc(this);
            EraseSelection(dc);
        }
        else
        {
            SetSelection(iCellFocus);
        }
    }
}


VOID LOGON_HOURS_CONTROL::DoButtonUpVisuals( BOOL fTrigger )
{
    if (_iButtonDown > 0 && _iButtonDown < 33)
    {
#if 0
        DISPLAY_CONTEXT dc(this);
        DrawFocusSomewhere(dc, _iWithFocus); // will XOR it out of existence
#endif

        UINT iButtonWasDown = _iButtonDown;
        _iButtonDown = 0;
        InvalidateButton(iButtonWasDown);
        if (fTrigger)
            DoButtonClick(iButtonWasDown);
    }
}


VOID LOGON_HOURS_CONTROL::DoButtonClick( INT iButton )
{
    ASSERT(iButton > 0 && iButton < 33);

    if (iButton < 8) // Day button
    {
        const INT iCellLower =  (iButton-1)*24; // note index conversion
        SetSelection( iCellLower, iCellLower+23 );
    }
    else if (iButton < 32) // Hour button
    {
        const INT iCellLower = iButton-8;       // again, different indices
        SetSelection( iCellLower, iCellLower + (6*24) );
    }
    else
    {
        SetSelection( 0, (7*24) - 1 );
    }
}


VOID LOGON_HOURS_CONTROL::InvalidateButton( INT iButtonOrCell )
{
    ASSERT( iButtonOrCell > 0 && iButtonOrCell < 201 );

    if (iButtonOrCell > 32)
    {
        XYRECT r;
        CalcRectForCell(&r, iButtonOrCell-33);
        Invalidate(r);
    }
    else if (iButtonOrCell < 8)
    {
        XYRECT r;
        CalcRectForDay(&r, iButtonOrCell-1);
        Invalidate(r);
    }
    else if (iButtonOrCell < 32)
    {
        XYRECT r;
        CalcRectForHour(&r, iButtonOrCell-8);
        Invalidate(r);
    }
    else
    {
        XYRECT r;
        CalcRectForCorner(&r);
        Invalidate(r);
    }
}


VOID LOGON_HOURS_CONTROL::SetSelectedCells( BOOL fPermit )
{
    ASSERT(_fCellsSelected);

    const INT cj = (_iCellSelUpper / 24) - (_iCellSelLower / 24) + 1;
    const INT ci = (_iCellSelUpper % 24) - (_iCellSelLower % 24) + 1;

    const INT iBase = _iCellSelLower;

    for (INT j = 0; j < cj; j++)
    {
        for (INT i = 0; i < ci; i++)
        {
            _abSetting[iBase+i+(24*j)] = (BYTE)fPermit;
        }
    }

    // Grid contents now need repainting.

    XYRECT r1, r2;

    CalcRectForCell(&r1, _iCellSelLower);
    CalcRectForCell(&r2, _iCellSelUpper);

    XYRECT rChanged;
    rChanged.CalcUnion(r1, r2);
    rChanged.AdjustLeft(-1);    // Move left over one so that the line
                                // between cells gets repainted
    Invalidate(rChanged);
}


VOID LOGON_HOURS_CONTROL::MoveFocusLeft()
{
    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);

    UINT iCurrentFocus = _iWithFocus;

    if (iCurrentFocus < 8 || iCurrentFocus == 32) // left margin
        Beep();
    else if (iCurrentFocus == 8) // leftmost hour button
        MoveFocusTo(32);         // go to corner button
    else if (iCurrentFocus > 32 && ((iCurrentFocus-32)%24) == 1) // leftmost
        MoveFocusTo( (iCurrentFocus-9)/24 ); // move into day buttons
    else
        MoveFocusTo(iCurrentFocus-1);

    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);
}


VOID LOGON_HOURS_CONTROL::MoveFocusRight()
{
    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);

    UINT iCurrentFocus = _iWithFocus;


    if ((iCurrentFocus == 31) ||                // right margin
        (iCurrentFocus > 32 && ((iCurrentFocus-32)%24) == 0))
        Beep();
    else if (iCurrentFocus == 32)               // corner button
        MoveFocusTo(8);                         // go to first hour button
    else if (iCurrentFocus < 8)                 // left margin, day buttons
        MoveFocusTo(32 + (iCurrentFocus-1)*24 + 1); // go to first grid cell
    else                                        // top row button OR grid cell
        MoveFocusTo(iCurrentFocus+1);

    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);
}


VOID LOGON_HOURS_CONTROL::MoveFocusUp()
{
    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);

    UINT iCurrentFocus = _iWithFocus;

    if (iCurrentFocus > 7 && iCurrentFocus < 33) // topmost, including corner
        Beep();
    else if (iCurrentFocus == 1) // topmost day button
        MoveFocusTo(32);         // go to corner button
    else if (iCurrentFocus < 8)  // other day buttons
        MoveFocusTo(iCurrentFocus-1);
    else if (iCurrentFocus < 57)       // topmost row of grid
        MoveFocusTo(iCurrentFocus-25); // go to hour button
    else
        MoveFocusTo(iCurrentFocus-24);

    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);
}


VOID LOGON_HOURS_CONTROL::MoveFocusDown()
{
    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);

    UINT iCurrentFocus = _iWithFocus;

    if (iCurrentFocus > 176 || iCurrentFocus == 7) // lowest row of cells
        Beep();
    else if (iCurrentFocus == 32) // corner button
        MoveFocusTo(1);           // goto first day button
    else if (iCurrentFocus < 7)
        MoveFocusTo(iCurrentFocus+1);
    else if (iCurrentFocus < 32)       // hour buttons
        MoveFocusTo(iCurrentFocus+25); // goto topmost grid row
    else
        MoveFocusTo(iCurrentFocus+24);

    ASSERT(_iWithFocus > 0 && _iWithFocus < 201);
}


BOOL LOGON_HOURS_CONTROL::DrawBackground( PAINT_DISPLAY_CONTEXT &dc ) const
{
    HBRUSH hbrZap = ::CreateSolidBrush(::GetSysColor(COLOR_WINDOW));
    if (hbrZap == NULL)
        return FALSE;

    XYRECT rGrid;
    CalcGridRect(&rGrid);

    XYRECT rPaint;
    rPaint.CalcIntersect(rGrid, dc.QueryInvalidRect());

    ::FillRect(dc.QueryHdc(), (const RECT *)rPaint, hbrZap);

    ::DeleteObject( (HGDIOBJ)hbrZap);
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawGridWires

    SYNOPSIS:   Paints the "wires" in the grid, along with the borders
                of the control and its buttons.

    ENTRY:      dc         - the OnPaint display context

    EXIT:       Button is drawn

    RETURNS:    FALSE if something in GDI went boom

    NOTES:
        This is a private member function.

    HISTORY:
        beng        14-May-1992 Created
        KeithMo     03-Nov-1992 Also draws hash marks.

********************************************************************/

BOOL LOGON_HOURS_CONTROL::DrawGridWires( PAINT_DISPLAY_CONTEXT &dc ) const
{
    ASSERT(DXGRIDWIRES == DYGRIDWIRES); // Laziness - lets me use same
                                        // pen vertically and horizontally

    HPEN hpenMain = ::CreatePen(PS_SOLID, DXGRIDWIRES,
                                ::GetSysColor(COLOR_BTNTEXT));
    if (hpenMain == NULL)
        return FALSE;
    HPEN hpenGrid = ::CreatePen(PS_SOLID, DXGRIDWIRES,
                                ::GetSysColor(COLOR_GRAYTEXT));
    if (hpenGrid == NULL)
    {
        ::DeleteObject((HGDIOBJ)hpenMain);
        return FALSE;
    }
    HPEN hpenBar = ::CreatePen(PS_SOLID, DXGRIDWIRES,
                                ::GetSysColor(COLOR_BTNSHADOW));
    if (hpenBar == NULL)
    {
        ::DeleteObject((HGDIOBJ)hpenGrid);
        ::DeleteObject((HGDIOBJ)hpenMain);
        return FALSE;
    }

    HPEN hpenOld = dc.SelectPen(hpenMain);

    // Draw outermost lines, plus button/grid edges
    // (Following sequence optimizes out some adds where I know
    // that one addend is zero.)

    XYDIMENSION dxyTotal = QuerySize();

    INT x = 0;
    INT y = Y_OFFSET;
    dc.MoveTo(x, y);
    x = (INT) dxyTotal.QueryWidth()-1;
    dc.LineTo(x, y);
    y = (INT) dxyTotal.QueryHeight()-1;
    dc.LineTo(x, y);
    x = 0;
    dc.LineTo(x, y);
    y = Y_OFFSET;
    dc.LineTo(x, y);
    y = (INT) _dyRow + DYGRIDWIRES + Y_OFFSET;
    dc.MoveTo(x, y);
    x = (INT) dxyTotal.QueryWidth()-1;
    dc.LineTo(x, y);
    x = (INT) _dxFirstColumn+DXGRIDWIRES;
    y = Y_OFFSET;
    dc.MoveTo(x, y);
    y = (INT) dxyTotal.QueryHeight()-1;
    dc.LineTo(x, y);

    // Draw rest of button separators, along with the grid separators.
    // REVIEW: by doubling loop could save overhead of switching pens
    // back and forth.  Worth the bloat?

    const INT xMainOrigin = 0;
    const INT xMainEndPt = (INT) _dxFirstColumn + DXGRIDWIRES;
    const INT xGreyOrigin = (INT) _dxFirstColumn + 2*DXGRIDWIRES;
    const INT xGreyEndPt = (INT) dxyTotal.QueryWidth() - DXGRIDWIRES;

    INT i;
    for (i = 2, y = 2*_dyRow + 2*DYGRIDWIRES + Y_OFFSET; i < 8;
         i++, y += _dyRow + DYGRIDWIRES)
    {
        dc.SelectPen(hpenMain);
        dc.MoveTo(xMainOrigin, y);
        dc.LineTo(xMainEndPt, y);

        dc.SelectPen(hpenGrid);
        dc.MoveTo(xGreyOrigin, y);
        dc.LineTo(xGreyEndPt, y);
    }

    const INT yMainOrigin = Y_OFFSET;
    const INT yMainEndPt = (INT) _dyRow + DYGRIDWIRES + Y_OFFSET;
    const INT yGreyOrigin = (INT) _dyRow + 2*DYGRIDWIRES + Y_OFFSET;
    const INT yGreyEndPt = (INT) dxyTotal.QueryHeight() - DYGRIDWIRES;

    for (i = 2, x = _dxFirstColumn + _dxColumn + 2*DXGRIDWIRES; i < 25;
         i++, x += _dxColumn + DXGRIDWIRES)
    {
        dc.SelectPen(hpenMain);
        dc.MoveTo(x, yMainOrigin);
        dc.LineTo(x, yMainEndPt);

        if( ( i == 7 ) || ( i == 13 ) || ( i == 19 ) )
            dc.SelectPen(hpenBar);
        else
            dc.SelectPen(hpenGrid);

        dc.MoveTo(x, yGreyOrigin);
        dc.LineTo(x, yGreyEndPt);
    }

    //
    //  Draw the hash marks.  The marks at noon & both midnights
    //  are _dyRow units high.  The marks at 6am & 6pm are 2*_dyRow/3
    //  units high.  The marks at other two-hour intervals are
    //  _dyRow/3 units high.  There is a one pixel whitespace border
    //  between the bottom of the hash marks and the top of the
    //  actual grid.
    //

    const INT yLargeOrigin  = 0;
    const INT yMediumOrigin = _dyRow/3;
    const INT ySmallOrigin  = 2*_dyRow/3;
    const INT yHashEndPt    = _dyRow + DYGRIDWIRES - 1;

    dc.SelectPen(hpenMain);

    for( i = 1, x = _dxFirstColumn + DXGRIDWIRES ;
         i <= 25 ;
         i += 2, x += 2*_dxColumn + 2*DXGRIDWIRES )
    {
        INT yHashOrigin;

        if( ( i == 1 ) || ( i == 13 ) || ( i == 25 ) )
            yHashOrigin = yLargeOrigin;
        else
        if( ( i == 7 ) || ( i == 19 ) )
            yHashOrigin = yMediumOrigin;
        else
            yHashOrigin = ySmallOrigin;

        dc.MoveTo( x, yHashOrigin );
        dc.LineTo( x, yHashEndPt );
    }

    dc.SelectPen(hpenOld);
    ::DeleteObject( (HGDIOBJ)hpenBar );
    ::DeleteObject( (HGDIOBJ)hpenGrid );
    ::DeleteObject( (HGDIOBJ)hpenMain );
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::QueryXForRow

    SYNOPSIS:   Returns the X-position in pixels for a row separator

    ENTRY:      1 <= iRow <= 25, 1 for left midnight, 13 for noon,
                25 for right mignight

    RETURNS:    X-location relative to control position, in pixels

    NOTES:      This is a public member function.

    HISTORY:
        jonn        29-Jan-1993 Created

********************************************************************/

UINT LOGON_HOURS_CONTROL::QueryXForRow( INT nRow )
{
    ASSERT( 1 <= nRow && nRow <= 25 );

    return (_dxFirstColumn - _dxColumn) + (nRow * (_dxColumn + DXGRIDWIRES));
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawAllButtons

    SYNOPSIS:   Paints the rows of buttons along the top and left edges.
                (Excel style)

    ENTRY:      dc         - the OnPaint display context

    EXIT:       Button is drawn

    RETURNS:    FALSE if something in GDI went boom

    NOTES:
        This is a private member function.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::DrawAllButtons( PAINT_DISPLAY_CONTEXT &dc ) const
{
    // For the face - get these once for every button

    HBRUSH hbrFace = ::CreateSolidBrush(::GetSysColor(COLOR_BTNFACE));
    if (hbrFace == NULL)
        return FALSE;
    HPEN hpenShadow= ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNSHADOW));
    if (hpenShadow == NULL)
    {
        ::DeleteObject((HGDIOBJ)hbrFace);
        return FALSE;
    }
    HPEN hpenHlight= ::CreatePen(PS_SOLID, 1, ::GetSysColor(COLOR_BTNHIGHLIGHT));
    if (hpenHlight == NULL)
    {
        ::DeleteObject((HGDIOBJ)hpenShadow);
        ::DeleteObject((HGDIOBJ)hbrFace);
        return FALSE;
    }

    // Draw the buttons in the left-hand column (All and Days).

    {
        XYRECT r(XYPOINT(DXGRIDWIRES, DYGRIDWIRES + Y_OFFSET),
                 XYDIMENSION(_dxFirstColumn-1, _dyRow-1));

        DrawOneCornerButton(dc, r, (_iButtonDown == 32),
                            hbrFace, hpenShadow, hpenHlight);


        // I would think this was already selected - but apparently not.
        // N.b. no need for save/restore here....
        dc.SelectFont(QueryFont());

        XYRECT rScratch;
        for (INT i = 1; i < 8; i++)
        {
            BOOL fDown = ((INT)_iButtonDown == i);
            r.Offset(0, _dyRow+DYGRIDWIRES);
            rScratch.CalcIntersect(r, dc.QueryInvalidRect());
            if (rScratch.IsEmpty())
                continue;

            DrawOneFlatButton(dc, r, fDown, hbrFace, hpenShadow, hpenHlight);
            COLORREF crOldBack = dc.SetBkColor(::GetSysColor(COLOR_BTNFACE));
            COLORREF crOldText = dc.SetTextColor(::GetSysColor(COLOR_BTNTEXT));
            r.AdjustLeft(_dxLabelFudge);
            if (fDown)
                r.Offset(1, 1);
            dc.DrawText(*_apnlsDayOfWeek[i-1], (RECT*)(const RECT *)r,
                        DT_LEFT|DT_VCENTER|DT_NOPREFIX|DT_SINGLELINE);
            if (fDown)
                r.Offset(-1, -1);
            r.AdjustLeft(-_dxLabelFudge);
            dc.SetBkColor(crOldBack);
            dc.SetTextColor(crOldText);
        }
    }

    // Draw the buttons in the topmost row (Hours).

    {
        XYRECT r2(XYPOINT(2*DXGRIDWIRES+_dxFirstColumn, DYGRIDWIRES + Y_OFFSET),
                  XYDIMENSION(_dxColumn-1, _dyRow-1));

        XYRECT rScratch;
        for (INT i = 8; i < 32;
             i++, r2.Offset(_dxColumn+DXGRIDWIRES, 0))
        {
            rScratch.CalcIntersect(r2, dc.QueryInvalidRect());
            if (rScratch.IsEmpty())
                continue;
            DrawOneFlatButton(dc, r2, ((INT)_iButtonDown == i),
                              hbrFace, hpenShadow, hpenHlight);
        }
    }

    ::DeleteObject((HGDIOBJ)hpenHlight);
    ::DeleteObject((HGDIOBJ)hpenShadow);
    ::DeleteObject((HGDIOBJ)hbrFace);
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawOneCornerButton

    SYNOPSIS:   Paints a single high corner "select all" point
                (Excel style)

    ENTRY:      dc         - the OnPaint display context
                r          - rectangle of button position
                fDown      - TRUE if button is in mid-click
                hbrFace    - brush with which to paint button face
                hpenShadow - pen with which to draw button shadows
                hpenHlight - pen with which to draw button highlights

    EXIT:       Button is drawn

    NOTES:
        This is a private member function.

        The function doesn't draw any focus rect on the button.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawOneCornerButton(
    PAINT_DISPLAY_CONTEXT &dc,
    const XYRECT &r, BOOL fDown,
    HBRUSH hbrFace, HPEN hpenShadow, HPEN hpenHlight) const
{
    // Draw the face of the button.  (Caller will draw any text.)

    ::FillRect(dc.QueryHdc(), (const RECT *)r, hbrFace);

    // Draw the 3D FX (shadowing).

    HPEN hpenSave = dc.SelectPen(hpenShadow);
    if (fDown)
    {
        dc.MoveTo(r.QueryLeft(),  r.QueryBottom()-1);
        dc.LineTo(r.QueryLeft(),  r.QueryTop());
        dc.LineTo(r.QueryRight(), r.QueryTop());
    }
    else
    {
        dc.MoveTo(r.QueryRight(),   r.QueryTop());
        dc.LineTo(r.QueryRight(),   r.QueryBottom());
        dc.LineTo(r.QueryLeft(),    r.QueryBottom());
        dc.MoveTo(r.QueryRight()-1, r.QueryTop()+1);
        dc.LineTo(r.QueryRight()-1, r.QueryBottom()-1);
        dc.LineTo(r.QueryLeft()+1,  r.QueryBottom()-1);

        dc.SelectPen(hpenHlight); // Highlight above

        dc.MoveTo(r.QueryLeft(),    r.QueryBottom());
        dc.LineTo(r.QueryLeft(),    r.QueryTop());
        dc.LineTo(r.QueryRight(),   r.QueryTop());
        dc.MoveTo(r.QueryLeft()+1,  r.QueryBottom()-1);
        dc.LineTo(r.QueryLeft()+1,  r.QueryTop()+1);
        dc.LineTo(r.QueryRight()-1, r.QueryTop()+1);
    }

    dc.SelectPen(hpenSave);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawOneFlatButton

    SYNOPSIS:   Paints a single flat row/column header

    ENTRY:      dc         - the OnPaint display context
                r          - rectangle of button position
                fDown      - TRUE if button is in mid-click
                hbrFace    - brush with which to paint button face
                hpenShadow - pen with which to draw button shadows
                hpenHlight - pen with which to draw button highlights

    EXIT:       Button is drawn

    NOTES:
        This is a private member function.

        The function doesn't draw any text or focus rect on the button.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawOneFlatButton(
    PAINT_DISPLAY_CONTEXT &dc,
    const XYRECT &r, BOOL fDown,
    HBRUSH hbrFace, HPEN hpenShadow, HPEN hpenHlight) const
{
    // Draw the face of the button.  (Caller will draw any text.)
    // We have to stretch a copy of the rect to get the last bit colored;
    // this is still faster than getting another pen and drawing more lines.

    {
        XYRECT rPrime = r;
        rPrime.AdjustRight(1);
        rPrime.AdjustBottom(1);
        ::FillRect(dc.QueryHdc(), (const RECT *)rPrime, hbrFace);
    }

    // Draw the minimal 3D FX for these Excel-style flat buttons.

    HPEN hpenSave = dc.SelectPen( fDown ? hpenShadow : hpenHlight );

    dc.MoveTo(r.QueryLeft(),  r.QueryBottom());
    dc.LineTo(r.QueryLeft(),  r.QueryTop());
    dc.LineTo(r.QueryRight(), r.QueryTop());

    dc.SelectPen(hpenSave);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawGridSetting

    SYNOPSIS:   Paints all the bars in the grid of permitted hours

    ENTRY:      dc       - the OnPaint display context

    EXIT:       Bars are painted

    NOTES:
        THis is a private member function.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::DrawGridSetting( PAINT_DISPLAY_CONTEXT &dc ) const
{
    XYRECT rGrid;
    CalcGridRect(&rGrid);

    XYRECT rIntersect;
    rIntersect.CalcIntersect(rGrid, dc.QueryInvalidRect());

    if (rIntersect.IsEmpty()) // None of the grid needs painting
        return TRUE;

    // Otherwise, paint the whole ding dang thing.
    // CODEWORK: paint only what is necessary.  Will require integrating
    // some of the grid-wire-paint code here.  Worth it?  Prolly not.

    // CODEWORK - what if background is blue?  need to check

    HBRUSH hbrBar = ::CreateSolidBrush( RGB(0, 0, 255) );
    if (hbrBar == NULL)
        return FALSE;

    // ibSetting optimizes away the array indexing math
    INT ibSetting = 0;

    for (INT i = 0; i < 7; i++)
    {
        BOOL fCarrying = FALSE;
        INT  jStart = 0;

        for (INT j = 0; j < 24; j++)
        {
            ASSERT(24*i+j == ibSetting);

            if (fCarrying != _abSetting[ibSetting++])
            {
                fCarrying = !fCarrying;

                if (!fCarrying)
                {
                    // Time to draw the line we'd been carrying
                    if (!DrawOneDayBar(dc, i, jStart, j-1, hbrBar))
                    {
                        ::DeleteObject((HGDIOBJ)hbrBar);
                        return FALSE;
                    }
                }
                else
                {
                    // Mark this point as the beginning of a line
                    jStart = j;
                }
            }
        }

        if (fCarrying) // Still carrying? Paint the bar to the end
        {
            if (!DrawOneDayBar(dc, i, jStart, 23, hbrBar))
            {
                ::DeleteObject((HGDIOBJ)hbrBar);
                return FALSE;
            }
        }
    }

    ::DeleteObject((HGDIOBJ)hbrBar);
    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawOneDayBar

    SYNOPSIS:   Paints a bar representing a range of permitted times

    ENTRY:      dc       - the OnPaint display context
                iRow     - index of row
                iColHead - index of first column of bar
                iColTail - index of last column of bar
                hbrBar   - brush with which to paint bar

    EXIT:       Bar is painted

    NOTES:
        This is a private member function.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

BOOL LOGON_HOURS_CONTROL::DrawOneDayBar( PAINT_DISPLAY_CONTEXT & dc,
                                         INT iRow, INT iColHead,
                                         INT iColTail, HBRUSH hbrBar ) const
{
    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (iColHead * (DXGRIDWIRES + _dxColumn));
    const INT xEnd = xStart-1 + (1+iColTail-iColHead) * (DXGRIDWIRES+_dxColumn);

    // Buttons at the top are the same size as grid cells -
    // hence the 1+iRow below.

    const INT yStart = (1+iRow) * (DYGRIDWIRES+_dyRow)
                       + DYGRIDWIRES + _dyRow/4 + 1 + Y_OFFSET;
    const INT yEnd = yStart + _dyRow/2 - 1;

    XYRECT r(xStart, yStart, xEnd, yEnd);

    if (!::FillRect(dc.QueryHdc(), (const RECT *)r, hbrBar))
        return FALSE;

    return TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusOnCell

    SYNOPSIS:   Draws or undraws the focus rectangle on a grid cell

    ENTRY:      dc    - the OnPaint display contect
                iCell - 0-base cell index in the sequence

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function, called only by DrawFocusSomewhere.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusOnCell( const DISPLAY_CONTEXT &dc,
                                           INT iCell ) const
{
    // Convert cell index to [i, j] row/col indices

    const INT i = iCell%24;
    const INT j = iCell/24;

    // Convert [i, j] row indices to (x, y, x', y') coordinates

    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (i * (DXGRIDWIRES+_dxColumn));
    const INT xEnd = xStart + _dxColumn;

    // Buttons at the top are the same size as grid cells -
    // hence the 1+j below.

    const INT yStart = (1+j) * (DYGRIDWIRES+_dyRow) + DYGRIDWIRES + Y_OFFSET;
    const INT yEnd = yStart + _dyRow;

    // Build a slightly diminished rectangle from the coords

    XYRECT r(xStart+2, yStart+2, xEnd-2, yEnd-2);

    dc.DrawFocusRect(r);
}


VOID LOGON_HOURS_CONTROL::SetSelection( INT iCell )
{
    SetSelection(iCell, iCell);
}


VOID LOGON_HOURS_CONTROL::SetSelection( INT iFrom, INT iTo )
{
    // Normalize implicit rectangle so that, for (x, y) and (x', y'),
    // x' > x and y' > y

    INT iLower = iFrom % 24;
    INT jLower = iFrom / 24;
    INT iUpper = iTo % 24;
    INT jUpper = iTo / 24;

    if (iLower > iUpper)
    {
        INT iTmp = iLower;
        iLower = iUpper;
        iUpper = iTmp;
    }

    if (jLower > jUpper)
    {
        INT jTmp = jLower;
        jLower = jUpper;
        jUpper = jTmp;
    }

    const INT iCellSelLower = iLower + (24*jLower);
    const INT iCellSelUpper = iUpper + (24*jUpper);

    // Avoid the flickering effect: skip erase-redraw cycles
    // that won't change the rectangle.
    //
    // JonN 7/31/95:  Added _fCellsSelected term, otherwise cell 0 is not
    // updated properly

    if (   _fCellsSelected
        && iCellSelLower == (INT)_iCellSelLower
        && iCellSelUpper == (INT)_iCellSelUpper )
    {
        return;
    }

    DISPLAY_CONTEXT dc(this);

    EraseSelection(dc);

    _fCellsSelected = TRUE;

    _iCellSelLower = iCellSelLower;
    _iCellSelUpper = iCellSelUpper;

    DrawCurrentSelection(dc);
}


VOID LOGON_HOURS_CONTROL::DrawCurrentSelection( const DISPLAY_CONTEXT &dc ) const
{
    if (_fCellsSelected)
    {
        if (_iCellSelUpper == _iCellSelLower)
            DrawSelectionOnCell(dc, _iCellSelUpper);
        else
            DrawSelectionOnCells(dc, _iCellSelLower, _iCellSelUpper);
    }
}


VOID LOGON_HOURS_CONTROL::EraseSelection( const DISPLAY_CONTEXT &dc )
{
    if (_fCellsSelected)
        DrawCurrentSelection(dc); // XOR it away
    _fCellsSelected = FALSE;
    _iCellSelUpper = _iCellSelLower = 0;
}


VOID LOGON_HOURS_CONTROL::DrawSelectionOnCell( const DISPLAY_CONTEXT &dc,
                                               INT iCell ) const
{
    XYRECT r;
    CalcRectForCell(&r, iCell);

    dc.InvertRect(r);
}


VOID LOGON_HOURS_CONTROL::DrawSelectionOnCells( const DISPLAY_CONTEXT &dc,
                                                INT iFrom, INT iTo ) const
{
    ASSERT(iFrom <= iTo);

    XYRECT r1, r2;

    CalcRectForCell(&r1, iFrom);
    CalcRectForCell(&r2, iTo);

    XYRECT r;
    r.CalcUnion(r1, r2);

    dc.InvertRect(r);
}


VOID LOGON_HOURS_CONTROL::CalcRectForCell( XYRECT * pr, INT iCell ) const
{
    // Convert cell index to [i, j] row/col indices

    const INT i = iCell%24;
    const INT j = iCell/24;

    // Convert [i, j] row indices to (x, y, x', y') coordinates

    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (i * (DXGRIDWIRES+_dxColumn));
    const INT xEnd = xStart + _dxColumn;

    // Buttons at the top are the same size as grid cells -
    // hence the 1+j below.

    const INT yStart = (1+j) * (DYGRIDWIRES+_dyRow) + DYGRIDWIRES + Y_OFFSET;
    const INT yEnd = yStart + _dyRow;

    XYRECT r(xStart, yStart, xEnd, yEnd);
    *pr = r;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusOnDayButton

    SYNOPSIS:   Draws or undraws the focus rectangle on a day button
                (up the left-hand-side of the control)

    ENTRY:      dc    - the OnPaint display contect
                iCell - 0-base button index in the sequence, counting
                        from the top down

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function, called only by DrawFocusSomewhere.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusOnDayButton( const DISPLAY_CONTEXT &dc,
                                                INT iDay ) const
{
    const INT xStart = DXGRIDWIRES;
    const INT xEnd   = xStart + _dxFirstColumn;

    // 1+iDay takes the Corner button (same size as day button) into account

    const INT yStart = (1+iDay) * (DYGRIDWIRES+_dyRow) + DYGRIDWIRES + Y_OFFSET;
    const INT yEnd   = yStart + _dyRow;

    // Build a slightly diminished rectangle from the coords

    XYRECT r(xStart+2, yStart+2, xEnd-2, yEnd-2);

    dc.DrawFocusRect(r);
}


VOID LOGON_HOURS_CONTROL::CalcRectForDay( XYRECT *pr, INT iDay ) const
{
    const INT xStart = DXGRIDWIRES;
    const INT xEnd   = xStart + _dxFirstColumn;

    // 1+iDay takes the Corner button (same size as day button) into account

    const INT yStart = (1+iDay) * (DYGRIDWIRES+_dyRow) + DYGRIDWIRES + Y_OFFSET;
    const INT yEnd   = yStart + _dyRow;

    XYRECT r(xStart, yStart, xEnd, yEnd);
    *pr = r;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusOnHourButton

    SYNOPSIS:   Draws or undraws the focus rectangle on an hour button
                (across the top of the control)

    ENTRY:      dc    - the OnPaint display contect
                iHour - 0-base button index in the sequence, counting
                        from left to right

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function, called only by DrawFocusSomewhere.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusOnHourButton( const DISPLAY_CONTEXT &dc,
                                                 INT iHour ) const
{
    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (iHour * (DXGRIDWIRES+_dxColumn));
    const INT xEnd   = xStart + _dxColumn;
    const INT yStart = DYGRIDWIRES + Y_OFFSET;
    const INT yEnd   = yStart + _dyRow;

    // Build a slightly diminished rectangle from the coords

    XYRECT r(xStart+2, yStart+2, xEnd-2, yEnd-2);

    dc.DrawFocusRect(r);
}


VOID LOGON_HOURS_CONTROL::CalcRectForHour( XYRECT *pr, INT iHour ) const
{
    const INT xStart = DXGRIDWIRES + _dxFirstColumn + DXGRIDWIRES
                       + (iHour * (DXGRIDWIRES+_dxColumn));
    const INT xEnd   = xStart + _dxColumn;
    const INT yStart = DYGRIDWIRES + Y_OFFSET;
    const INT yEnd   = yStart + _dyRow;

    XYRECT r(xStart, yStart, xEnd, yEnd);
    *pr = r;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusOnCornerButton

    SYNOPSIS:   Draws or undraws the focus rectangle on the corner button
                (upper left corner, denoting Select All)

    ENTRY:      dc    - the OnPaint display contect

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function, called only by DrawFocusSomewhere.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusOnCornerButton(
    const DISPLAY_CONTEXT &dc ) const
{
    const INT xStart = DXGRIDWIRES;
    const INT yStart = DYGRIDWIRES + Y_OFFSET;
    const INT xEnd   = xStart + _dxFirstColumn;
    const INT yEnd   = yStart + _dyRow;

    XYRECT r(xStart+2, yStart+2, xEnd-2, yEnd-2);

    dc.DrawFocusRect(r);
}


VOID LOGON_HOURS_CONTROL::CalcRectForCorner( XYRECT * pr ) const
{
    const INT xStart = DXGRIDWIRES;
    const INT yStart = DYGRIDWIRES + Y_OFFSET;
    const INT xEnd   = xStart + _dxFirstColumn;
    const INT yEnd   = yStart + _dyRow;

    XYRECT r(xStart, yStart, xEnd, yEnd);
    *pr = r;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::DrawFocusSomewhere

    SYNOPSIS:   Determines where to draw focus, then dispatches

    ENTRY:      dc    - the OnPaint display contect
                iFocus- the focus index (uses same scheme as _iWithFocus)

    EXIT:       Focus rect has been drawn or undrawn

    NOTES:
        This is a private member function.

    HISTORY:
        beng        15-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::DrawFocusSomewhere( const DISPLAY_CONTEXT &dc,
                                              INT iFocus ) const
{
    if (iFocus == 0 || iFocus > 200)
        return;
    else if (iFocus > 32)
        DrawFocusOnCell(dc, iFocus-33);
    else if (iFocus < 8)
        DrawFocusOnDayButton(dc, iFocus-1);
    else if (iFocus < 32)
        DrawFocusOnHourButton(dc, iFocus-8);
    else
        DrawFocusOnCornerButton(dc);
}


VOID LOGON_HOURS_CONTROL::MoveFocusTo( INT iGetsFocus )
{
    DISPLAY_CONTEXT dc(this);

    if (_fFocusVisible)
        DrawFocusSomewhere(dc, _iWithFocus); // OUT with the old focus...

    _iWithFocus = iGetsFocus;
    DrawFocusSomewhere(dc, _iWithFocus); // IN with the new focus!
    _fFocusVisible = TRUE;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::CalcGridRect

    SYNOPSIS:   Calcs the rectangle occupied by the grid

    ENTRY:      prDest - points to destination XYRECT

    EXIT:       *prDest is set

    NOTES:
        THis is a private member function.

    HISTORY:
        beng        14-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::CalcGridRect( XYRECT * prDest ) const
{
    XYDIMENSION dxyTotal = QuerySize();

    const INT xOrigin = (INT) _dxFirstColumn + 2*DXGRIDWIRES;
    const INT yOrigin = (INT) _dyRow + 2*DYGRIDWIRES + Y_OFFSET;
    const INT xEndPt = (INT) dxyTotal.QueryWidth() - DXGRIDWIRES;
    const INT yEndPt = (INT) dxyTotal.QueryHeight() - DYGRIDWIRES;

    *prDest = XYRECT(xOrigin, yOrigin, xEndPt, yEndPt);
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::CalcSizes

    SYNOPSIS:   Calculates relative sizes within control

    ENTRY:      dxy - the total dimensions of the control

    EXIT:       Sets some members of the class: _dyRow, _dxFirstColumn,
                _dxColumn,  Resizes control so that an integral number
                of cells fit within it.

    RETURNS:    NERR_Success if control has enough real estate to work.
                Some other error code if not.

    NOTES:
        This is a private member function.
        Assumes that labels have already been loaded.

    HISTORY:
        beng        12-May-1992 Created

********************************************************************/

APIERR LOGON_HOURS_CONTROL::CalcSizes( XYDIMENSION dxy )
{
    // All the sanity checks below just keep the math legal.  A control
    // can pass them and still be unusable, depending on the font sel'd
    // etc.

    // Row height is easy: take the total height, subtract the space used
    // by the grid wires, and divide the remainder evenly between each row.

    if (dxy.QueryHeight() < (10*DYGRIDWIRES + (3*9)))
    {
        ASSERT(FALSE); // Each row needs height >= 3
        return ERROR_INVALID_PARAMETER; // The dxy parameter, that is
    }

    _dyRow = (dxy.QueryHeight() - 10*(DYGRIDWIRES)) / 9;


    // Column 1 width: enough to accommodate the longest label (day of
    // week), plus padding.

    {
        DISPLAY_CONTEXT dc(this);

        // I would think this was already selected - but apparently not.
        // N.b. no need for save/restore here....
        dc.SelectFont(QueryFont());

        _dxLabelFudge = dc.QueryAveCharWidth();

        UINT dxInsane = dxy.QueryWidth()/4 - 2*_dxLabelFudge;
        UINT dxMax = 0;
        INT i = 0;
        while (i < 7)
        {
            ASSERT(_apnlsDayOfWeek[i] != NULL);
            UINT dx = dc.QueryTextWidth(*_apnlsDayOfWeek[i++]);
            if (dx < dxInsane && dx > dxMax)
                dxMax = dx;
        }

        if (dxMax == 0)
        {
            // REVIEW: Perhaps should try the abbrev day strings instead?
            // Or perhaps should sub them in as needed for the too-long
            // days, one at a time.

            ASSERT(FALSE); // Every label was longer than 25% of the control
            return ERROR_INVALID_PARAMETER;
        }

        _dxFirstColumn = dxMax + 2*_dxLabelFudge;
    }


    // Each remaining column gets an equal part of the leftovers
    // after gridwire overhead.

    {
        UINT dxRemaining = dxy.QueryWidth() - _dxFirstColumn;

        if (dxRemaining < (26*DXGRIDWIRES + 3*24))
        {
            ASSERT(FALSE); // Each lesser col needs width >= 3
            return ERROR_INVALID_PARAMETER;
        }

        _dxColumn = (dxRemaining - 26*DXGRIDWIRES) / 24;
    }

    // Now that the control knows the dimensions of its components,
    // let it resize itself to remove "dead space."

    SetSize(_dxFirstColumn + 24*_dxColumn + 26*DXGRIDWIRES,
            9*_dyRow + 10*DYGRIDWIRES,
            FALSE);

    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::LoadLabels

    SYNOPSIS:   Load the strings for the button labels

    ENTRY:      Object is incompletely constructed

    EXIT:

    RETURNS:
        Error code if couldn't load strings.  NERR_Success otherwise.

    NOTES:
        This is a private member function.

        This function assumes that no previous strings have been loaded;
        do not call it more than once per object.

        Assumes that all strings are contiguous, following Sunday.
        Assumes seven days per week (gasp!).

    HISTORY:
        beng        12-May-1992 Created

********************************************************************/

APIERR LOGON_HOURS_CONTROL::LoadLabels( MSGID idDay0 )
{
    INT i = 0;

    while (i < 7)
        _apnlsDayOfWeek[i++] = NULL;

    APIERR err = NERR_Success;
    for (i = 0; i < 7 && err == NERR_Success; i++)
    {
        if ((_apnlsDayOfWeek[i] = new RESOURCE_STR(idDay0 + i)) == NULL)
            err = ERROR_NOT_ENOUGH_MEMORY;
        else
            err = _apnlsDayOfWeek[i]->QueryError();
    }

    return err;
}


/*******************************************************************

    NAME:       LOGON_HOURS_CONTROL::UnloadLabels

    SYNOPSIS:   Unrolls LoadLabels

    ENTRY:      Object has some (perhaps all) labels loaded

    EXIT:       They're been freed

    NOTES:
        This is a private member function.

    HISTORY:
        beng        12-May-1992 Created

********************************************************************/

VOID LOGON_HOURS_CONTROL::UnloadLabels()
{
    INT i = 0;

    while (i < 7)
    {
        delete _apnlsDayOfWeek[i];
        _apnlsDayOfWeek[i++] = NULL; // play it safe
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltsb.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltsb.cxx
    Source file for the BLT spin button object

    FILE HISTORY:
        terryk      15-Apr-1991 created
        terryk      20-Jun-1991 code review changed. Attend: beng
        terryk      05-Jul-1991 second code review changed. Attend:
                                beng chuckc rustanl annmc terryk
        terryk      19-Jul-1991 Change the bitmap parameter from ULONG
                                to TCHAR *
        terryk      27-Sep-1991 solve spin group restore bug
        terryk      07-Oct-1991 Add update
        terryk      17-APr-1992 Created the up and down arrow during
                                construction time

*/

#include "pchblt.hxx"  // Precompiled header


// BUGBUG:
// DEFINE_DLIST_OF(SPIN_ITEM);


/*********************************************************************

    NAME:       DownArrowLocation

    SYNOPSIS:   Given the current XY position and the dimension of
                the control, this function will return the xy
                location of the down arrow within the SPIN_GROUP .

    ENTRY:      XYPOINT xy - the xy position of the SPIN_GROUP
                XYDIMENSION dxy - the total dimension of the SPIN_GROUP

    RETURN_VALUE:   The starting position of the down arrow in the SPIN_GROUP

    HISTORY:
        terryk      22-May-91   Created
        beng        04-Aug-1992 Made local and inline

*********************************************************************/

static inline XYPOINT DownArrowLocation( XYPOINT xy, XYDIMENSION dxy )
{
    return XYPOINT( xy.QueryX(), xy.QueryY() + dxy.QueryHeight() / 2 );
}


/*********************************************************************

    NAME:       HalfSpinDimension

    SYNOPSIS:   Given the total dimension of the SPIN_GROUP , it will
                return the dimension of the arrow button within the
                SPIN_GROUP .

    ENTRY:      XYDIMENSION dxy - the SPIN_GROUP  dimension.

    RETURN_VALUE:   the dimension of a arrow button within the SPIN_GROUP

    HISTORY:
        terryk      22-May-91   Created
        beng        04-Aug-1992 Made local and inline

*********************************************************************/

static inline XYDIMENSION HalfSpinDimension( XYDIMENSION dxy )
{
    return XYDIMENSION( dxy.QueryWidth(), dxy.QueryHeight() / 2 );
}


/**********************************************************************

    NAME:       SPIN_GROUP::SPIN_GROUP

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - owner window handler
                CID cidSpinButton    - cid for the SPIN BUTTON control
                CID cidUpArrow       - cid for the up arrow control
                CID cidDownArrow     - cid for the down arrow control
                BOOL fActive         - Initial state of the SPIN_GROUP.
                                       Assume that it is inactive

                Parameter for the apps window
                XYPOINT xy      - xy position of the custom control
                XYDIMENSION dxy - xy dimension of the custom control
                ULONG flStyle   - style of the custom control
                TCHAR * pszClassName - if it is undefined, it will be
                                      "button".

    HISTORY:
        terryk      22-May-91   Created
        beng        05-Oct-1991 Win32 conversion
        terryk      17-Apr-1992 use the resource file's up and down arrows
        beng        04-Aug-1992 Bitmap ids now ordinals, and fixed

**********************************************************************/

SPIN_GROUP::SPIN_GROUP( OWNER_WINDOW *powin, CID cidSpinButton,
                        CID cidUpArrow, CID cidDownArrow, BOOL fActive )
    : CONTROL_GROUP(),
    _SpinButton( powin, cidSpinButton ),
    _dlsiControl( FALSE ),
    _arrowUp( powin, cidUpArrow, BMID_UP, BMID_UP_INV, BMID_UP_DIS ),
    _arrowDown( powin, cidDownArrow, BMID_DOWN, BMID_DOWN_INV, BMID_DOWN_DIS ),
    _fModified ( FALSE ),
    _psiCurrentField( NULL ),
    _psiFirstField( NULL ),
    _psiLastField( NULL ),
    _fActive( fActive )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    _arrowUp.SetPos(_SpinButton.QueryPos());
    _arrowUp.SetSize( HalfSpinDimension( _SpinButton.QuerySize() ));
    _arrowDown.SetPos( DownArrowLocation( _SpinButton.QueryPos(), _SpinButton.QuerySize()));
    _arrowDown.SetSize( HalfSpinDimension( _SpinButton.QuerySize() ));

    _arrowUp.SetGroup( (CONTROL_GROUP *)this );
    _arrowDown.SetGroup( (CONTROL_GROUP * )this );

    _arrowUp.Show();
    _arrowDown.Show();
}

SPIN_GROUP::SPIN_GROUP( OWNER_WINDOW *powin, CID cidSpinButton,
                        CID cidUpArrow, CID cidDownArrow,
                        XYPOINT xy, XYDIMENSION dxy, ULONG flStyle,
                        BOOL fActive )
    : CONTROL_GROUP(),
    _SpinButton( powin, cidSpinButton, xy, dxy, flStyle ),
    _dlsiControl( FALSE ),
    _arrowUp( powin, cidUpArrow,
              BMID_UP, BMID_UP_INV, BMID_UP_DIS,
              xy, HalfSpinDimension( dxy ),
              BS_OWNERDRAW|WS_BORDER|WS_CHILD|WS_GROUP ),
    _arrowDown( powin, cidDownArrow,
                BMID_DOWN, BMID_DOWN_INV, BMID_DOWN_DIS,
                DownArrowLocation( xy, dxy ), HalfSpinDimension( dxy ),
                BS_OWNERDRAW|WS_BORDER|WS_CHILD ),
    _fModified( FALSE ),
    _psiCurrentField( NULL ),
    _psiFirstField( NULL ),
    _psiLastField( NULL ),
    _fActive( fActive )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    _arrowUp.SetGroup( (CONTROL_GROUP *)this );
    _arrowDown.SetGroup( (CONTROL_GROUP * )this );

    _arrowUp.Show();
    _arrowDown.Show();

}


/*********************************************************************

    NAME:       SPIN_GROUP::~SPIN_GROUP

    SYNOPSIS:   destructor - clear up all the internal variables

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

SPIN_GROUP::~SPIN_GROUP()
{
    // let the private variable's destructors do the job
}


/*********************************************************************

    NAME:       SPIN_GROUP::DoChar

    SYNOPSIS:   Character handler

    ENTRY:      CHAR_EVENT & event - the TCHAR message

    BOOL:       return TRUE if one of the control item use the character
                FALSE otherwise

    NOTES:      When it receives the WM_CHAR message, it will
                ask each of the control in the list. If one
                of the control wants to handle the character,
                let it has the character. Otherwise, Beeps the user.

    HISTORY:
                terryk  22-May-91   Created
                terryk  20-Jun-91   Changed sendmessage to OnXXX.

*********************************************************************/

BOOL SPIN_GROUP::DoChar( const CHAR_EVENT & event )
{
    // if the valid is invalid then skip it and don't do anything
    if ( !QueryCurrentField()->IsStatic() && !IsValidField() )
    {
        SetArrowButtonStatus();
        return TRUE;
    }

    SPIN_ITEM *psiOldItem = QueryCurrentField();
    SPIN_ITEM *psiCurrent;
    ITER_DL_OF( SPIN_ITEM ) itersi( _dlsiControl );

    while (( psiCurrent = itersi.Next() )!= NULL )
    {
        // find the current item
        if ( psiCurrent == QueryCurrentField() )
            break;
    }

    UIASSERT( psiCurrent != NULL );

    do
    {
        psiCurrent = itersi.Next();
        if ( psiCurrent == NULL )
        {
            itersi.Reset();
            psiCurrent = itersi.Next();
        }

        if ( psiCurrent->QueryAccCharPos( event.QueryChar() ) >= 0 )
        {
            SetCurrentField( psiCurrent );
            // the inputed character is one of the accelerator key
            if ( psiCurrent->IsStatic() )
            {
                // it must be a separator
                // so we must jump to the next field
               JumpNextField( );
            }
            else
            {
                // let the item handles the character
                psiCurrent->DoChar( event );
                CHANGEABLE_SPIN_ITEM *pcsi = (CHANGEABLE_SPIN_ITEM *)psiCurrent;
                pcsi->SaveCurrentData();
            }
            return TRUE;
        }
    } while ( psiCurrent != psiOldItem );

    if ( (event.QueryChar() != VK_TAB)
         && (event.QueryChar() != VK_ESCAPE)
         && (event.QueryChar() != VK_RETURN) )
    {
        TRACEEOL(   SZ("SPIN_GROUP::DoChar(): invalid character ")
                 << ((INT)event.QueryChar()) );
        ::MessageBeep(0);
    }

    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::IsValidField

    SYNOPSIS:   check the current field is valid or not

    RETURN:     BOOL - TRUE if the current field item is valid
                       FALSE otherwise

    HISTORY:
                terryk  10-Jul-91   Created

*********************************************************************/

BOOL SPIN_GROUP::IsValidField()
{
    UIASSERT( QueryCurrentField() != NULL );
    UIASSERT( !QueryCurrentField()->IsStatic() );

    CHANGEABLE_SPIN_ITEM *pcsiCurrentFocus =
        (CHANGEABLE_SPIN_ITEM *) QueryCurrentField();

    BOOL fValid;

    if (!( fValid = pcsiCurrentFocus->CheckValid() ))
    {
        // reset the up and down arrow
        _arrowUp.SetSelected( FALSE );
        _arrowDown.SetSelected( FALSE );
        _arrowUp.Invalidate();
        _arrowDown.Invalidate();
    }

    return fValid;
}


/*********************************************************************

    NAME:       SPIN_GROUP::JumpNextField

    SYNOPSIS:   Set the current field to the next changeable field

    RETURN:     always TRUE

    HISTORY:
                terryk  20-Jun-91   Created
                terryk  10-Jul-91   Use ITER_DL inside the routine

*********************************************************************/

BOOL SPIN_GROUP::JumpNextField( )
{
    if ( _fActive )
    {
        if ( !QueryCurrentField()->IsStatic() && !IsValidField() )
        {
            return TRUE;
        }
    }
     ITER_DL_OF( SPIN_ITEM ) itersi( _dlsiControl );
    SPIN_ITEM * psi;
    while (( psi = itersi.Next() )!= NULL )
    {
        if ( psi == QueryCurrentField() )
            break;
    }

    UIASSERT( psi != NULL );

    while (( psi = itersi.Next() )!= NULL )
    {
        if (! psi->IsStatic() )
        {
            SetCurrentField( psi );
            SetArrowButtonStatus();
            return TRUE;
        }
    }
    ::MessageBeep( 0 );
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::JumpPrevField

    SYNOPSIS:   Jump to the previous field

    RETURN:     always true

    HISTORY:
                terryk  20-Jun-91   Created
                terryk  10-Jul-91   use ITER_DL inside the routine

*********************************************************************/

BOOL SPIN_GROUP::JumpPrevField( )
{
    if ( _fActive )
    {
        if ( !QueryCurrentField()->IsStatic() && !IsValidField() )
        {
            return TRUE;
        }
    }

    RITER_DL_OF( SPIN_ITEM ) ritersi( _dlsiControl );
    SPIN_ITEM * psi;
    while (( psi = ritersi.Next() )!= NULL )
    {
        if ( psi == QueryCurrentField() )
            break;
    }

    UIASSERT( psi != NULL );

    while (( psi = ritersi.Next() )!= NULL )
    {
        if (! psi->IsStatic() )
        {
            SetCurrentField( psi );
            SetArrowButtonStatus();
            return TRUE;
        }
    }
    ::MessageBeep( 0 );
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::DoNewFocus

    SYNOPSIS:   Set the current field to the new focus

    ENTRY:      SPIN_ITEM * pSpinItem - Spin item to be focused

    RETURN:     always TRUE

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

BOOL    SPIN_GROUP::DoNewFocus( SPIN_ITEM * pSpinItem )
{
    if ( !_fActive )
    {
        if ( QueryCurrentField() != pSpinItem )
        {
            SetCurrentField( pSpinItem );
        }
        return TRUE;
    }

    if ( !QueryCurrentField()->IsStatic() && IsValidField() )
    {
        // set the field to current focus
        if ( QueryCurrentField() != pSpinItem )
        {
            SetCurrentField( pSpinItem );
        }
    }
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::DoArrowCommand

    SYNOPSIS:   Whenever the up/down arrow is hit, it will send a message
                to here. Then the OnArrowCommand will increase or
                decrease the control item value.

    ENTRY:      CID cidArrow - the cid of the active arrow
                WORD Msg  = SPN_ARROW_SMALLINC or
                            SPN_ARROW_BIGINC

    EXIT:       increase or decrease the control item value.

    RETURN:     always TRUE

    NOTE:       depend on the cid value, we can find out the button is
                up arrow or down arrow and do the incease/decrease.

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

BOOL    SPIN_GROUP::DoArrowCommand( CID cidArrow, WORD wMsg )
{
    if ( !QueryCurrentField()->IsStatic() && IsValidField() )
    {
        CHANGEABLE_SPIN_ITEM *pcsiCurrentFocus =
            (CHANGEABLE_SPIN_ITEM *) QueryCurrentField();

        pcsiCurrentFocus->SaveCurrentData();

        // inc or dec the number depended on the arrow key
        if ( cidArrow == _arrowUp.QueryCid() )
        {

            (*pcsiCurrentFocus) += ( wMsg == SPN_ARROW_SMALLINC ) ?
                                    pcsiCurrentFocus->QuerySmallIncValue() :
                                    pcsiCurrentFocus->QueryBigIncValue();

        }
        else
        {
            (*pcsiCurrentFocus) -= ( wMsg == SPN_ARROW_SMALLINC ) ?
                                    pcsiCurrentFocus->QuerySmallDecValue() :
                                    pcsiCurrentFocus->QueryBigDecValue();
        }
        _fModified = TRUE;
    }
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::ChangeFieldValue

    SYNOPSIS:   handle all the VKey command

    ENTRY:      WORD Msg: SPN_INCREASE - increase by a small value
                          SPN_DECREASE - decrease by a small value
                          SPN_BIGINCREASE - big increase
                          SPN_BIGDECREASE - big decrease
                INT nRepeatCount - the repeat number

    EXIT:       Change the current control item's value

    RETURN:     TRUE

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

BOOL SPIN_GROUP::ChangeFieldValue( WORD wMsg, INT nRepeatCount )
{
    if ( !QueryCurrentField()->IsStatic() && IsValidField() )
    {
        CHANGEABLE_SPIN_ITEM * pcsiCurrentFocus =
            (CHANGEABLE_SPIN_ITEM *) QueryCurrentField();

        // check for the repeat count
        for ( INT i =0; i < nRepeatCount; i++ )
        {
            pcsiCurrentFocus->SaveCurrentData();

            switch ( wMsg )
            {
            case SPN_INCREASE:
                (*pcsiCurrentFocus)+= pcsiCurrentFocus->QuerySmallIncValue();
                break;

            case SPN_DECREASE:
                (*pcsiCurrentFocus)-= pcsiCurrentFocus->QuerySmallDecValue();
                break;

            case SPN_BIGINCREASE:
                (*pcsiCurrentFocus)+= pcsiCurrentFocus->QueryBigIncValue();
                break;

            case SPN_BIGDECREASE:
                (*pcsiCurrentFocus)-= pcsiCurrentFocus->QueryBigDecValue();
                break;
            }
        }
        _fModified = TRUE;
    }
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::SetFieldMinMax

    SYNOPSIS:   Set the value to either MAX or MIN

    ENTRY:      WORD Msg: either SPN_MAX or SPN_MIN

    EXIT:       set the current control item to either MAX or MIN

    RETURN:     TRUE

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

BOOL SPIN_GROUP::SetFieldMinMax( WORD wMsg )
{
    if ( !QueryCurrentField()->IsStatic() && IsValidField() )
    {
        CHANGEABLE_SPIN_ITEM * pcsiCurrentFocus =
            (CHANGEABLE_SPIN_ITEM *) QueryCurrentField();

        pcsiCurrentFocus->SetValue( ( wMsg == SPN_MAX ) ?
            pcsiCurrentFocus->QueryMax() : pcsiCurrentFocus->QueryMin() );

        _fModified = TRUE;
    }
    SetArrowButtonStatus();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_GROUP::SetArrowButtonStatus

    SYNOPSIS:   disable the button(s) if the current control reach the upper
                or lower limit

    NOTES:      disable the button if necessary

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

VOID SPIN_GROUP::SetArrowButtonStatus()
{
    UIASSERT( QueryCurrentField() != NULL );
    UIASSERT( !QueryCurrentField()->IsStatic() );

    // set the arrow button. Disable the button if we reach the upper or
    // lower limit.

    CHANGEABLE_SPIN_ITEM *pcsiCurrentFocus = (CHANGEABLE_SPIN_ITEM *)
        QueryCurrentField();

    // do all the checking in order to avoid the blinking

    if (( ! pcsiCurrentFocus->QueryWrap() ) &&
        ( pcsiCurrentFocus->QueryValue() == pcsiCurrentFocus->QueryMax() ))
    {
        _arrowUp.Enable( FALSE );
        ::SendMessage( ((WINDOW)_arrowUp).QueryHwnd(), WM_LBUTTONUP, 0, 0);
    }
    else
    {
        _arrowUp.Enable( TRUE );
    }
    if (( ! pcsiCurrentFocus->QueryWrap() ) &&
        ( pcsiCurrentFocus->QueryValue() == pcsiCurrentFocus->QueryMin() ))
    {
        _arrowDown.Enable( FALSE );
        ::SendMessage( ((WINDOW)_arrowUp).QueryHwnd(), WM_LBUTTONUP, 0, 0);
    }
    else
    {
        _arrowDown.Enable( TRUE );
    }

    pcsiCurrentFocus->Update();
    SetControlValueFocus();
}


/*********************************************************************

    NAME:       SPIN_GROUP::AddAssociation

    SYNOPSIS:   associated a control with the spin button

    ENTRY:      SPIN_ITEM * psiControl - control to be associated with

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

APIERR SPIN_GROUP::AddAssociation( SPIN_ITEM * psiControl )
{
    APIERR err = _dlsiControl.Append( psiControl );

    if ( err != NERR_Success )
    {
        return err;
    }

    if ( _psiFirstField == NULL )
    {
        _psiFirstField = psiControl;
    }
    _psiLastField = psiControl;
    CONTROL_WINDOW *pcw = psiControl->QueryControlWin();
    pcw->SetGroup( this );

    if (( ! psiControl->IsStatic() ) && ( _psiCurrentField == NULL ))
    {
        _psiCurrentField = psiControl;
    }
    return err;

}


/*********************************************************************

    NAME:       SPIN_GROUP::SetCurrentField

    SYNOPSIS:   set the current focus to the given control

    ENTRY:      SPIN_ITEM * psiControl - control to be focused
                if psiControl is NULL, it will set the spin button to
                the first changeable item.

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

VOID SPIN_GROUP::SetCurrentField( SPIN_ITEM * psiControl )
{
    if ( psiControl == NULL )
    {
        // if no parameter is given, then set the first list item
        SPIN_ITEM * psi;
        ITER_DL_OF(SPIN_ITEM) itersi( _dlsiControl );
        for ( psi = itersi.Next(); (( psi != NULL ) && ( psi->IsStatic()));
              psi = itersi.Next())
        {
        }
        _psiCurrentField = psi;

    }
    else
    {
        _psiCurrentField = psiControl;
    }
}


/*********************************************************************

    NAME:       SPIN_GROUP::SetControlValueFocus

    SYNOPSIS:   set the current focus to the first field

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

VOID SPIN_GROUP::SetControlValueFocus()
{
    UIASSERT( QueryCurrentField() != NULL );

    CONTROL_WINDOW * pWin = QueryCurrentField()->QueryControlWin();
    pWin->SetControlValueFocus();
}


/*********************************************************************

    NAME:       SPIN_GROUP::SaveValue

    SYNOPSIS:   save all the value within the spin_button's control(s)

    NOTES:      save the control value one by one

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

VOID SPIN_GROUP::SaveValue( BOOL fInvisible )
{
    _fActive = FALSE;

    SPIN_ITEM * psiCurrentField;
    ITER_DL_OF( SPIN_ITEM ) itersi( _dlsiControl );

    while (( psiCurrentField = itersi.Next()) != NULL )
    {
        CONTROL_WINDOW * pYuck = psiCurrentField->QueryControlWin();

        if ( ! psiCurrentField->IsStatic())
        {
            CVSaveValue( pYuck, fInvisible );
        }
    }
//    SetControlValueFocus();
}


/*********************************************************************

    NAME:       SPIN_GROUP::RestoreValue

    SYNOPSIS:   restore all the value within the spin button's control(s)

    NOTES:      call each control one by one and restore the value

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

VOID SPIN_GROUP::RestoreValue( BOOL fInvisible )
{
    if ( _fActive )
        return;

    _fActive = TRUE;

    SPIN_ITEM * psiCurrentField;
    ITER_DL_OF( SPIN_ITEM ) itersi( _dlsiControl );

    while (( psiCurrentField = itersi.Next()) != NULL )
    {
        CONTROL_WINDOW * pYuck = psiCurrentField->QueryControlWin();

        if ( ! psiCurrentField->IsStatic() )
           // && ( psiCurrentField->QueryHwnd() != ::GetFocus()))
        {
            CVRestoreValue( pYuck, fInvisible );
        }
    }
//    SetControlValueFocus();
}


/*********************************************************************

    NAME:       SPIN_GROUP::IsModified

    SYNOPSIS:   return the status of the spin button

    EXIT:       return TRUE if the spin button's controls have been modified.
                FALSE otherwise

    HISTORY:
                terryk  16-Jun-91   Created

*********************************************************************/

BOOL SPIN_GROUP::IsModified( VOID ) const
{
    return _fModified;
}


/*********************************************************************

    NAME:       SPIN_GROUP::SetModified

    SYNOPSIS:   Set the internal Modified flag to the given parameter

    ENTRY:      BOOl fModified - modified state

    HISTORY:
                terryk  10-Jul-91   Created

*********************************************************************/

VOID SPIN_GROUP::SetModified( BOOL fModified )
{
    _fModified = fModified;
}


/*********************************************************************

    NAME:       SPIN_GROUP::OnUserAction

    SYNOPSIS:   Restore the value if necessary

    ENTRY:      CONTROL_WINDOW * pcw - one of the control item
                ULPARAM lParam - the message type.

    RETURN:     Always NERR_Success

    HISTORY:
        terryk      10-Jul-91   Created
        beng        31-Jul-1991 Renamed QMessageInfo to QEventEffects
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

APIERR SPIN_GROUP::OnUserAction( CONTROL_WINDOW *      pcw,
                                 const CONTROL_EVENT & e )
{
    UINT nChangeFlags = pcw->QueryEventEffects( e );

    if ( nChangeFlags == CVMI_NO_VALUE_CHANGE )
        return GROUP_NO_CHANGE;

    RestoreValue();

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltmeter.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    bltmeter.cxx
        Source file for Activity Meter custom control

    FILE HISTORY:
        terryk  10-Jun-91   Created
        o-SimoP 31-Jan-92   Added Frame
*/

#include "pchblt.hxx"  // Precompiled header


const TCHAR * METER::_pszClassName = SZ("static");


/*********************************************************************

    NAME:       METER::METER

    SYNOPSIS:   Meter is an activity indicator object. It displays the
                number of percentage complete and mark the specified
                percentage of the rectangle with the specified color.

    ENTRY:      OWNER_WINDOW *powin - owner window of the control
                CID cid - cid of the control
                COLORREF color - color to paint the rectangle. Optional.
                                 If the color is missing, use BLUE.

    HISTORY:
        terryk      15-May-91       Created
        beng        31-Jul-1991     Control error reporting changed

**********************************************************************/

METER::METER( OWNER_WINDOW *powin, CID cid, COLORREF color )
    : CONTROL_WINDOW( powin, cid ),
      CUSTOM_CONTROL( this ),
      _nComplete( 0 ),
      _color( color )
{
    APIERR  apierr = QueryError();
    if ( apierr != NERR_Success )
    {
        DBGOUT(SZ("BLTMETER error: constructor failed."));
        return;
    }

}

METER::METER( OWNER_WINDOW *powin, CID cid,
              XYPOINT xy, XYDIMENSION dxy, ULONG flStyle, COLORREF color )
    : CONTROL_WINDOW ( powin, cid, xy, dxy, flStyle, _pszClassName ),
      CUSTOM_CONTROL( this ),
      _nComplete( 0 ),
      _color( color )
{
    APIERR  apierr = QueryError();
    if ( apierr != NERR_Success )
    {
        DBGOUT(SZ("BLTMETER error: constructor failed."));
        return ;
    }
}


/*********************************************************************

    NAME:       METER::SetComplete

    SYNOPSIS:   Reset the number of percentage completed

    ENTRY:      INT nComplete - completed percentage

    NOTES:      It will repaint the object every reset the percentage.

    HISTORY:
                terryk  15-May-91   Created

**********************************************************************/

VOID METER::SetComplete( INT nComplete )
{
    _nComplete = ( nComplete < 0 ) ? 0 :
                 (( nComplete > 100 ) ? 100 : nComplete );
    Invalidate( TRUE );
}


/*********************************************************************

    NAME:       METER::OnPaintReq

    SYNOPSIS:   Redraw the whole object

    HISTORY:
        terryk  15-May-91   Created
        o-SimoP 31-Jan-92   Added Frame
        beng    05-Mar-1992 Remove wsprintf; add BUG-BUG; use PAINT_dc
        beng    29-Mar-1992 Fix for Unicode (ExtTextOut usage)
        beng    05-May-1992 API changes

**********************************************************************/

BOOL METER::OnPaintReq()
{
    RECT rectClient, rectPercent;

    NLS_STR nlsPercent(SZ("%1%"));
    DEC_STR nlsNumber(_nComplete);
    ASSERT(!!nlsPercent && !!nlsNumber);

    if (!nlsPercent || !nlsNumber)
        return FALSE;

    APIERR err = nlsPercent.InsertParams(nlsNumber);
    ASSERT(err == NERR_Success);
    if (err != NERR_Success)
        return FALSE;

    PAINT_DISPLAY_CONTEXT dc(this);

    COLORREF rgbBkColor   = dc.SetBkColor( ::GetSysColor( COLOR_WINDOW ) );
    COLORREF rgbTextColor = dc.SetTextColor( _color );

    dc.SetTextAlign( TA_CENTER | TA_TOP );

    COLORREF rgbColor = dc.GetBkColor();

    // fill up the rectangle first

    dc.SetBkColor( dc.SetTextColor( rgbColor ));
    ::GetClientRect( WINDOW::QueryHwnd(), &rectClient );

    RECT rectOrg;       // Original rect
    ::SetRect( &rectOrg, (INT)rectClient.left, (INT)rectClient.top,
             (INT)rectClient.right, (INT)rectClient.bottom );

    ::InflateRect( &rectClient, -2, -2 );
    ::SetRect( &rectPercent, (INT)rectClient.left, (INT)rectClient.top,
             (( INT )((( LONG )rectClient.right * ( LONG )_nComplete )/ 100 )),
             (INT)rectClient.bottom );

    TEXTMETRIC  textmetric;

    dc.QueryTextMetrics( &textmetric );

    // draw half of the text
    dc.ExtTextOut( (INT)rectClient.right/2,
                   (INT)( rectClient.bottom - textmetric.tmHeight )/ 2,
                   ETO_OPAQUE | ETO_CLIPPED,
                   &rectPercent,
                   nlsPercent );

    rectPercent.left = rectPercent.right;
    rectPercent.right = rectClient.right;

    // draw the other half of the text
    rgbColor = dc.GetBkColor( );
    dc.SetBkColor( dc.SetTextColor( rgbColor ));
    dc.ExtTextOut( (INT)rectClient.right /2,
                   (INT)( rectClient.bottom - textmetric.tmHeight ) / 2,
                   ETO_OPAQUE | ETO_CLIPPED,
                   &rectPercent,
                   nlsPercent );

    dc.SetBkColor( rgbBkColor );
    dc.SetTextColor( rgbTextColor );

    dc.FrameRect( &rectOrg, ::CreateSolidBrush( 0x00000000 ) ); // Black

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltcc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltcc.cxx
    BLT custom control class implementation

    FILE HISTORY:
        terryk      16-Apr-1991 Creation
        terryk      05-Jul-1991 Second code review.
                                Attend: beng chuckc rustanl annmc terryk
        beng        18-May-1992 Added mouse handling
        beng        28-May-1992 The great bltcc/bltdisph scramble
*/

#include "pchblt.hxx"  // Precompiled header


extern "C"
{
    /* C7 CODEWORK - nuke this stub */
    /* main call back function */
    extern LPARAM _EXPORT APIENTRY BltCCWndProc( HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
    {
        return CUSTOM_CONTROL::WndProc(hwnd, nMsg, wParam, lParam);
    }
}



/*********************************************************************

    NAME:       CUSTOM_CONTROL::CUSTOM_CONTROL

    SYNOPSIS:   constructor. The constructor will set the internal
                call back function to DisphWndProc.

    ENTRY:      CONTROL_WINDOW * pWin - window's handler of the object

    HISTORY:
        terryk      22-May-1991 created
        beng        17-Oct-1991 Win32 conversion

*********************************************************************/

CUSTOM_CONTROL::CUSTOM_CONTROL( CONTROL_WINDOW * pctrl )
    : DISPATCHER( pctrl ),
    _pctrl( pctrl ),
    _instance( (MFARPROC)BltCCWndProc ),
    _lpfnOldWndProc(
        (MFARPROC)::SetWindowLongPtr( QueryHwnd(),
                                      GWLP_WNDPROC,
                                      (LONG_PTR) _instance.QueryProc()) )
{
    if ( _instance.QueryError() != NERR_Success )
    {
        DBGEOL( "BLTCC: ctor failed." );
    }
}


/*********************************************************************

    NAME:       CUSTOM_CONTROL::~CUSTOM_CONTROL

    SYNOPSIS:   destructor

    NOTE:       reset the call back function to the orginial one.

    HISTORY:
                terryk      22-May-1991 Created

*********************************************************************/

CUSTOM_CONTROL::~CUSTOM_CONTROL( )
{
    ::SetWindowLongPtr( QueryHwnd(), GWLP_WNDPROC, (LONG_PTR) _lpfnOldWndProc );
}


/*********************************************************************

    NAME:       CUSTOM_CONTROL::SubClassWndProc

    SYNOPSIS:   Depending on the original class call back function.
                If it is defined, it will pass the parameters to the
                original function. Otherwise, it will pass the
                parameters to Default Window Procedure.

    ENTRY:      EVENT event - the current event

    HISTORY:
        terryk      22-May-1991 created
        beng        17-Oct-1991 Win32 conversion

*********************************************************************/

LPARAM CUSTOM_CONTROL::SubClassWndProc( const EVENT & event )
{
    if ( _lpfnOldWndProc != NULL )
    {
        return ::CallWindowProc( (WNDPROC)_lpfnOldWndProc,
                                 QueryHwnd(),
                                 event.QueryMessage(),
                                 event.QueryWParam(),
                                 event.QueryLParam() );
    }
    else
    {
        return ::DefWindowProc( QueryHwnd(),
                                event.QueryMessage(),
                                event.QueryWParam(),
                                event.QueryLParam() );
    }
}


/*********************************************************************

    NAME:       CUSTOM_CONTROL::CVSaveValue

    SYNOPSIS:   Call the SaveValue method in the control window

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID CUSTOM_CONTROL::CVSaveValue( BOOL fInvisible )
{
    _pctrl->SaveValue( fInvisible );
}


/*********************************************************************

    NAME:       CUSTOM_CONTROL::CVRestoreValue

    SYNOPSIS:   Call the RestoreValue method in the control window

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID CUSTOM_CONTROL::CVRestoreValue( BOOL fInvisible )
{
    _pctrl->RestoreValue( fInvisible );
}


/*******************************************************************

    NAME:       CUSTOM_CONTROL::WndProc

    SYNOPSIS:   Window-proc for BLT custom control windows

    ENTRY:      As per wndproc

    EXIT:       As per wndproc

    RETURNS:    The usual code returned by a wndproc

    NOTES:
        This is a static member function.

        This is the wndproc proper for BLT custom control windows.  In
        the "extern C" clause above I declare a tiny exported stub
        which calls this.

    HISTORY:
        beng        10-May-1991 Implemented
        beng        20-May-1991 Add custom-draw control support
        beng        15-Oct-1991 Win32 conversion
        beng        28-May-1992 Great custom control dispatcher shuffle

********************************************************************/

LPARAM CUSTOM_CONTROL::WndProc( HWND hwnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    // First, handle messages which are not concerned about whether or
    // not hwnd can be converted into pwnd.

#if 0 // These make no sense in a subclassed control - they're owner messages
    switch (nMsg)
    {
    case WM_COMPAREITEM:
    case WM_DELETEITEM:
        return OWNER_WINDOW::OnLBIMessages(nMsg, wParam, lParam);
    }
#endif

    CUSTOM_CONTROL * pwnd = (CUSTOM_CONTROL *)DISPATCHER::HwndToPwnd( hwnd );

    if (pwnd == NULL)
    {
        // If HwndToPwnd returns NULL, then either CreateWindow call
        // has not yet returned, or else this class's destructor has
        // already been called - important, since this proc will continue
        // to receive messages such as WM_DESTROY.  Since Blt Windows perform
        // their WM_CREATE style code in their constructor, it's okay to
        // let most of the traditional early messages pass us by.
        //
        // The exception is WM_GETMINMAXINFO, I suppose...
        //
        return ::DefWindowProc(hwnd, nMsg, wParam, lParam);
    }

#if 0 // These make no sense in a subclassed control - they're owner msgs
    switch (nMsg)
    {
    case WM_GUILTT:
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_CHARTOITEM:
    case WM_VKEYTOITEM:
        // Responses to owner-draw-control messages are defined
        // in the owner-window class.
        //
        // It makes no sense to redefine one of these without
        // redefining the others.  Proper redefinition of control
        // behavior is done in the CONTROL_WINDOW::CD_* functions.
        //
        return pwnd->OnCDMessages(nMsg, wParam, lParam);
    }
#endif

    // Assemble an EVENT object, and dispatch appropriately.

    // CODEWORK: this is a bit pokey, especially when subclassing
    // controls which extensively use messages internally (e.g., the
    // listbox).  Might want to build some sort of sparse map at ctor
    // time which would allow us to skip the dispatch for messages
    // we don't catch.

    EVENT event( nMsg, wParam, lParam );
    ULONG lRes32 = 0;
    LPARAM lRes;
    BOOL fRes = pwnd->Dispatch(event, &lRes32);
    if (fRes) {
        lRes = lRes32;
    } else {
        lRes = pwnd->SubClassWndProc(event);
    }

#if 0
    if (nMsg == WM_NCDESTROY)
    {
        // This is the last message that any window receives before its
        // hwnd becomes invalid.  This case will only be run if a BLT
        // client-window is destroyed by DestroyWindow instead of by
        // its destructor: a pathological case, since BLT custom controls
        // die by destructor even in a BLT dialog.
        //
        // Normally, a client window will receive DESTROY only after
        // its destructor has already disassociated the hwnd and pwnd.
        //
        // pwnd->DisassocHwndPwnd(); !!REVIEW!!
    }
#endif

    return lRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltsetbx.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltsetbx.cxx
    Set control object.

    It consists of 2 listboxes and 2 push buttons.
    Inside the listboxes are LBI items. Each item consists of
    a bitmap and a string. The user can drag on the string to select
    the string and drag on the icon to move the string from 1 listbox
    to the other. These are 2 push buttons associated with the control.
    The first one is Add button to add the items from the original
    listbox to the new listbox. Then, we also have a Delete button to
    delete all the selected items from the new listbox to the
    original listbox.

    FILE HISTORY:
        terryk      01-Jul-91   Created
        terryk      12-Aug-91   Add bitmap parameter to the constructor
        terryk      31-Oct-91   Fix enable move problem
        beng        20-May-1992 Add direct manipulation
        jonn      09-Sep-93    Modified to allow SET_CONTROL listboxes
                               to be lazy
*/

#include "pchblt.hxx"  // Precompiled header


static inline UINT absval( INT x )
{
    return (x < 0) ? -x : x;
}


/*********************************************************************

    NAME:       SET_CONTROL::SET_CONTROL

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *powin - owner window
                CID cidAdd - cid of the Add push button
                CID cidDelete - cid of the Delete button
                SET_CONTROL_LISTBOX *plbOrigBox - pointer to the orginial
                        listbox
                SET_CONTROL_LISTBOX *plbNewBox - pointer to the new listbox

    NOTES:      Construct the listboxes first.  Then construct the
                SET_CONTROL.  Finally, redirect the listboxes'
                OnLMouse and OnMouseMove messages to the SET_CONTROL.
                Reverse order on destruction.

    HISTORY:
        terryk      02-Jul-91   Created
        terryk      12-Aug-91   Add bitmap name parameter to the
                                constructor
        beng        03-Oct-1991 Checks listboxes
        beng        27-May-1992 Direct-manipulation delta
        jonn      09-Sep-93    Modified to allow SET_CONTROL listboxes
                               to be lazy

*********************************************************************/

SET_CONTROL::SET_CONTROL( OWNER_WINDOW *powin, CID cidAdd, CID cidDelete,
                          HCURSOR hcurSingle, HCURSOR hcurMultiple,
                          LISTBOX * plbOrigBox,
                          LISTBOX * plbNewBox,
                          UINT dxIconColumn )
    : _plbOrigBox( plbOrigBox ),
      _plbNewBox( plbNewBox ),
      _butAdd( powin, cidAdd ), // CODEWORK - why do these create a new obj?
      _butDelete( powin, cidDelete ), // shouldn't the dialog do that instead??
      _hcurNoDrop( CURSOR::LoadSystem(IDC_NO) ),
      _hcurSingle(hcurSingle),
      _hcurMultiple(hcurMultiple),
      _hcurSave( NULL ),
      _hcurUse( NULL ),
      _fEnableMove( TRUE ),
      _fInDrag(FALSE),
      _fInFakeClick(FALSE),
      _dxIconColumn(dxIconColumn),
      _eMouseDownSave(0,0,0)
{
    if (QueryError() != NERR_Success)
    {
        // error in parent ctor - abort
        return;
    }
    if (!*plbOrigBox)
    {
        // error in component listbox
        ReportError(plbOrigBox->QueryError());
        return;
    }
    if (!*plbNewBox)
    {
        // error in component listbox
        ReportError(plbNewBox->QueryError());
        return;
    }

    if (   _hcurNoDrop   == (HCURSOR)NULL
        || _hcurSingle   == (HCURSOR)NULL
        || _hcurMultiple == (HCURSOR)NULL
       )
    {
        DBGEOL( "SET_CONTROL::ctor; hcur error" );
        ReportError(BLT::MapLastError(ERROR_INVALID_PARAMETER));
        return;
    }

    // Associate the group objects

    _butAdd.SetGroup( this );
    _butDelete.SetGroup( this );

    plbOrigBox->SetGroup( this );
    plbNewBox->SetGroup( this );

    // if necessary, disable both buttons first
    INT clbiOrigCount = plbOrigBox->QuerySelCount();
    if ( clbiOrigCount == 0 )
    {
        _butAdd.Enable( FALSE );
    }

    INT clbiNewCount = plbNewBox->QuerySelCount();
    if ( clbiNewCount == 0 )
    {
        _butDelete.Enable( FALSE );
    }
    else if ( clbiOrigCount != 0 )
    {
        plbNewBox->RemoveSelection();
    }
}


/*********************************************************************

    NAME:       SET_CONTROL::~SET_CONTROL

    SYNOPSIS:   destructor

    HISTORY:
                terryk  02-Jul-91   Created

*********************************************************************/

SET_CONTROL::~SET_CONTROL()
{
    // do nothing
}


/*********************************************************************

    NAME:       SET_CONTROL::CalcAppropriateCursor

    SYNOPSIS:   Determine the cursor to use during a drag

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

HCURSOR SET_CONTROL::CalcAppropriateCursor( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    // n.b. do this with POINT instead of XYPOINT because w-from-pt
    // needs such anyway.  maybe someday heavy up XYPOINT to track
    // coordinate types.  (class CLIENT_XYPOINT: public XYPOINT?)

    POINT pt = xy.QueryPoint();
    REQUIRE( ::ClientToScreen(plbThis->WINDOW::QueryHwnd(), &pt) );

    HWND hwnd = ::WindowFromPoint(pt);

    if (hwnd == plbThis->WINDOW::QueryHwnd() || hwnd == plbOther->WINDOW::QueryHwnd())
        return _hcurUse;
    else
        return _hcurNoDrop;
}


/*********************************************************************

    NAME:       SET_CONTROL::IsWithinHitZone

    SYNOPSIS:   Determine whether a mousedown may init a drag

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::IsWithinHitZone( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    // The "hit zone" is the column consisting of all the visible
    // icons in the listbox.

    // CODEWORK: cache most of this stuff.

    XYRECT xyrClient(plbThis, TRUE);
    XYRECT xyrIcons( 0, 0,
                     _dxIconColumn,
                     (plbThis->QueryCount()-plbThis->QueryTopIndex())*plbThis->QueryItemHeight() );
    XYRECT xyrFinal;
    xyrFinal.CalcIntersect(xyrClient, xyrIcons);

    return xyrFinal.ContainsXY(xy);
}


/*********************************************************************

    NAME:       SET_CONTROL::IsOnSelectedItem

    SYNOPSIS:   Determine whether a mousedown landed on an item
                in the listbox which was already selected

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    NOTES:
        Assumes that xy already passed IsWithinHitZone

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::IsOnSelectedItem( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    //ASSERT(IsWithinHitZone(xy)); -- presupposed

    // Assumes fixed-height listbox, too.

    const UINT iFirst = plbThis->QueryTopIndex();
    const UINT iHit = iFirst + (xy.QueryY() / plbThis->QueryItemHeight());

    return plbThis->IsItemSelected(iHit);
}


/*********************************************************************

    NAME:       SET_CONTROL::IsOverTarget

    SYNOPSIS:   Determine whether a mouseup may successfully end a drag

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::IsOverTarget( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    POINT pt = xy.QueryPoint();
    REQUIRE( ::ClientToScreen(plbThis->WINDOW::QueryHwnd(), &pt) );

    return (::WindowFromPoint(pt) == plbOther->WINDOW::QueryHwnd());
}


/*********************************************************************

    NAME:       SET_CONTROL::IsOnDragStart

    SYNOPSIS:   Determine whether a mouseup didn't move from the down

    ENTRY:      xy - current cursor loc in client coords
                     relative to this

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::IsOnDragStart( LISTBOX * plbThis, LISTBOX * plbOther, const XYPOINT & xy ) const
{
    // Size of fudge for a drag which goes nowhere to be considered a click.
    // CODEWORK: cache the metrics calls

    const UINT cxFudge = ::GetSystemMetrics(SM_CXDOUBLECLK);
    const UINT cyFudge = ::GetSystemMetrics(SM_CYDOUBLECLK);

    XYPOINT xyDown = _eMouseDownSave.QueryPos();

    INT cx = xy.QueryX() - xyDown.QueryX();
    INT cy = xy.QueryY() - xyDown.QueryY();

    return ((absval(cx) <= cxFudge) && (absval(cy) <= cyFudge));
}


/*********************************************************************

    NAME:       SET_CONTROL::OnUserAction

    SYNOPSIS:   Depend on the push button, it will call the proper
                function.

    ENTRY:      CONTROL_WINDOW *pcw - control object which receive
                                      the message
                ULPARAM lParam - the lParam of the window message

    RETURN:     NERR_Success if success.

    HISTORY:
        terryk      02-Jul-91   Created
        beng        08-Oct-1991 Win32 conversion

**********************************************************************/

APIERR SET_CONTROL::OnUserAction( CONTROL_WINDOW *      pcw,
                                  const CONTROL_EVENT & e )
{
    UIASSERT( pcw != NULL );

    APIERR err = NERR_Success;

    CID cid = pcw->QueryCid();

    if ( cid == _plbOrigBox->QueryCid() )
    {
        // the user selected the items within the original listbox
        switch ( e.QueryCode() )
        {
        case LBN_SELCHANGE:
            _plbNewBox->RemoveSelection();
            if ( _fEnableMove )
            {
                EnableButtons();
            }
            break;
        case LBN_DBLCLK:
            if ( _fEnableMove )
            {
                err = DoAdd();
            }
            break;
        default:
            break;
        }
    }
    else if ( cid == _plbNewBox->QueryCid() )
    {
        // the user selected the items within the new listbox
        switch ( e.QueryCode() )
        {
        case LBN_SELCHANGE:
            _plbOrigBox->RemoveSelection();
            if ( _fEnableMove )
            {
                EnableButtons();
            }
            break;
        case LBN_DBLCLK:
            if ( _fEnableMove )
            {
                err = DoRemove();
            }
            break;
        default:
            break;
        }
    }
    else if ( _fEnableMove )
    {
        if ( cid == _butAdd.QueryCid() )
        {
            // add button is hit by the user
            err = DoAdd();
            if ( err == NERR_Success )
                _butDelete.ClaimFocus();
        }
        else if ( cid == _butDelete.QueryCid() )
        {
            // delete button is hit by the user
            err = DoRemove();
            if ( err == NERR_Success )
                _butAdd.ClaimFocus();
        }
        else
        {
            DBGEOL("BLT: Set control - unknown cid");
            ASSERT( FALSE );
            return ERROR_GEN_FAILURE;
        }
    }

    return err;
}


/*********************************************************************

    NAME:       SET_CONTROL::DoAdd

    SYNOPSIS:   move all the selected strings from original box
                to the new listbox

    HISTORY:
        terryk      02-Jul-91   Created
        beng        27-May-1992 Direct manipulation delta

*********************************************************************/

APIERR SET_CONTROL::DoAdd()
{
    return MoveItems(_plbOrigBox, _plbNewBox);
}


/*********************************************************************

    NAME:       SET_CONTROL::DoRemove

    SYNOPSIS:   move all the selected strings from the new listbox
                to the original listbox

    HISTORY:
        terryk      02-Jul-91   Created
        beng        27-May-1992 Direct manipulation delta

*********************************************************************/

APIERR SET_CONTROL::DoRemove()
{
    return MoveItems(_plbNewBox, _plbOrigBox);
}


/*********************************************************************

    NAME:       SET_CONTROL::DoAddOrRemove

    SYNOPSIS:   move all the selected strings from the new listbox
                to the original listbox

    HISTORY:
        thomaspa    17-Mar-93   Created

*********************************************************************/

APIERR SET_CONTROL::DoAddOrRemove( LISTBOX *plbFrom,
                                   LISTBOX *plbTo )
{
    if ( plbFrom == _plbOrigBox )
    {
        return DoAdd();
    }
    else
    {
        return DoRemove();
    }
}


/*********************************************************************

    NAME:       SET_CONTROL::EnableMoves

    SYNOPSIS:   enable the set control or not

    ENTRY:      BOOL fEnable - the enable flag of the set control

    NOTES:      It will disable the 2 push buttons if the flag is
                FALSE.

    HISTORY:
                terryk  15-Aug-1991     Created

*********************************************************************/

VOID SET_CONTROL::EnableMoves( BOOL fEnable )
{
    if ( _fEnableMove == fEnable )
        return;

    _fEnableMove = fEnable;
    if ( _fEnableMove )
    {
        EnableButtons();
    }
    else
    {
        _butAdd.Enable( FALSE );
        _butDelete.Enable( FALSE );
    }
}


/*********************************************************************

    NAME:       SET_CONTROL::EnableButtons

    SYNOPSIS:   enable or disable the push button

    NOTES:      Depending the select count of each listbox, it will enable
                or disable the 2 push buttons

    HISTORY:
                terryk  15-Aug-1991     Created

*********************************************************************/

VOID SET_CONTROL::EnableButtons()
{
    // set the buttons disable mode

    UIASSERT( _fEnableMove );

    _butAdd.Enable( _plbOrigBox->QuerySelCount() != 0 );
    _butDelete.Enable( _plbNewBox->QuerySelCount() != 0 );
}

/*********************************************************************

    NAME:       SET_CONTROL::OtherListbox

    SYNOPSIS:   Gets pointer to the other listbox

    HISTORY:
        jonn        09-Sep-1993 Created

*********************************************************************/
LISTBOX * SET_CONTROL::OtherListbox( LISTBOX * plb ) const
{
    LISTBOX * plbRet = _plbNewBox;
    if (plb != _plbOrigBox)
    {
        if (plb == _plbNewBox)
        {
            plbRet = _plbOrigBox;
        }
        else
        {
            ASSERT( FALSE );
        }
    }
    return plbRet;
}

/*********************************************************************

    NAME:       SET_CONTROL::HandleOnLMouseButtonDown

    SYNOPSIS:   Response to a left-mouse-button-down event

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::HandleOnLMouseButtonDown( LISTBOX * plb,
                                            CUSTOM_CONTROL * pcc,
                                            const MOUSE_EVENT & e )
{
    if (   _fInFakeClick  // This is a faked mouse-down.  Punt to superclass.
        || !_fEnableMove )  // Moves are disabled
    {
        return FALSE;
    }

    ASSERT(!_fInDrag);

    XYPOINT xy = e.QueryPos(); // n.b. already in client coords

    if (!IsWithinHitZone(plb, OtherListbox(plb), xy))
        return FALSE; // let defproc handle it

    _fAlreadyFakedClick = FALSE; // Prevents faking the click twice

    if (!IsOnSelectedItem(plb, OtherListbox(plb), xy))
    {
        // If item not selected, fake a click on it before dragging.
        // Have to do it this way because underlying lb captures the
        // mouse itself....

        ASSERT(!_fInFakeClick);
        _fInFakeClick = TRUE;
        MOUSE_EVENT eFakeDown = e;
        eFakeDown.SendTo(plb->WINDOW::QueryHwnd());
        MOUSE_EVENT eFakeUp(WM_LBUTTONUP, e.QueryWParam(), e.QueryLParam());
        eFakeUp.SendTo(plb->WINDOW::QueryHwnd());
        _fInFakeClick = FALSE;

        _fAlreadyFakedClick = TRUE;
    }

    // Mousedown took place on the draggable region of an already
    // selected item: initiate the drag proper.

    pcc->CaptureMouse();
    _fInDrag = TRUE;
    _eMouseDownSave = e; // save it in case we have to fake one later,
                         // or to remember where the mousedown took place

    // Prep various cursors.  (Wait until actual "pull" of the drag
    // before setting the cursor to hcurUse, so that a single down, up
    // click on the hit zone won't strobe the cursor.)

    _hcurUse = (plb->QuerySelCount() > 1) ? _hcurMultiple : _hcurSingle;
    _hcurSave = CURSOR::Query();

    return TRUE; // message handled - don't pass along
}


/*********************************************************************

    NAME:       SET_CONTROL::HandleOnLMouseButtonUp

    SYNOPSIS:   Response to a left-mouse-button-up event

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::HandleOnLMouseButtonUp( LISTBOX * plb,
                                          CUSTOM_CONTROL * pcc,
                                          const MOUSE_EVENT & e )
{
    if (!_fInDrag || _fInFakeClick)
        return FALSE;

    XYPOINT xy = e.QueryPos();

    BOOL fNeedsFakeClick = FALSE;

    if (IsOverTarget(plb, OtherListbox(plb), xy)) // In the crosshairs? Drop the bomb
    {
        // DoAddOrRemove may do a MsgPopup, so release the mouse now
        CURSOR::Set(_hcurSave);
        pcc->ReleaseMouse();
        DoAddOrRemove(plb, OtherListbox(plb));
    }
    else if (!_fAlreadyFakedClick && IsOnDragStart(plb, OtherListbox(plb), xy))
    {
        // If mouse went down on the hit zone of a selected item, but then
        // the drag didn't go anywhere, then we need to fake a mousedown
        // (since we ate the mouse-down ourselves without passing it along)
        // before passing along the mouse-up.
        //
        // Fake the click only after this routine releases the capture.

        fNeedsFakeClick = TRUE;
    }
    // Otherwise, drag aborted w/ no special handling needed.

    // Clean up from drag-mode

    CURSOR::Set(_hcurSave);
    pcc->ReleaseMouse();

    if (fNeedsFakeClick)
    {
        // Now that capture released, fake the click.

        ASSERT(!_fInFakeClick);
        _fInFakeClick = TRUE;
        _eMouseDownSave.SendTo(plb->WINDOW::QueryHwnd());
        _fInFakeClick = FALSE;
    }

    _fInDrag = FALSE;

    // If faking click, don't eat the message, so that the superclass
    // gets this mouseup to compliment the (faked) mousedown.

    return fNeedsFakeClick ? FALSE : TRUE;
}


/*********************************************************************

    NAME:       SET_CONTROL::HandleOnMouseMove

    SYNOPSIS:   Response to a mouse-move event

    HISTORY:
        beng        27-May-1992 Created
        jonn        09-Sep-1993 Moved from SET_CONTROL_LISTBOX to SET_CONTROL

*********************************************************************/

BOOL SET_CONTROL::HandleOnMouseMove( LISTBOX * plb, const MOUSE_EVENT & e )
{
    if (!_fInDrag)
        return FALSE;

    XYPOINT xy = e.QueryPos();

    CURSOR::Set( CalcAppropriateCursor(plb, OtherListbox(plb), xy) );
    return TRUE;
}


/*********************************************************************

    NAME:       SET_CONTROL::BLTMoveItems

    SYNOPSIS:   Move the selected LBIs from one listbox to the other.

    ENTRY:
        plbFrom - the listbox containing selected items, from which
                  those items will be moved
        plbTo   - the destination listbox, which will receive the
                  moved items

    RETURN:     APIERR

    HISTORY:
        terryk      02-Jul-91   Created
        beng        27-May-1992 Takes plbFrom, plbTo instead of fWhichWay
        jonn        09-Sep-1993 Moved to BLTMoveItems

*********************************************************************/

APIERR SET_CONTROL::BLTMoveItems( BLT_LISTBOX * plbFrom,
                                  BLT_LISTBOX * plbTo )
{
    ASSERT( plbFrom == _plbOrigBox || plbFrom == _plbNewBox );
    ASSERT( plbTo == _plbOrigBox || plbTo == _plbNewBox );
    ASSERT( plbFrom != plbTo );

    INT clbiSel = plbFrom->QuerySelCount();
    APIERR err = NERR_Success;
    INT iPos;           // index Position

    if ( clbiSel == 0 )
        return err;

    INT *aiLBI = new INT[ clbiSel ];
    if ( aiLBI == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;

    REQUIRE( plbFrom->QuerySelItems( aiLBI, clbiSel ) == NERR_Success );
    plbFrom->SetRedraw( FALSE );
    plbTo->SetRedraw( FALSE );

    for ( INT i = clbiSel - 1; i >= 0; i -- )
    {
        const INT ilbiSource = aiLBI[i];

        LBI * plbi = plbFrom->QueryItem( ilbiSource );
        // set the pointer to move. Otherwise, DeleteItem will clear up
        // the memory space.
        plbFrom->SetItem( ilbiSource, NULL );

        // Assume the sorting method is the same, the last added item
        // must be in the top of all the added items.

        iPos = plbTo->AddItem( plbi );
        if ( iPos < 0 )
        {
            plbFrom->SetItem( ilbiSource, plbi );
            err = ERROR_NOT_ENOUGH_MEMORY;
            plbTo->RemoveSelection();
            break;
        }
        else
        {
            plbTo->SelectItem( iPos, TRUE );
            plbFrom->DeleteItem( ilbiSource );
        }

    }

    delete aiLBI;

    if ( iPos >= 0 )
    {
        plbTo->SetTopIndex( iPos );
    }

    plbFrom->SetRedraw( TRUE );
    plbTo->SetRedraw( TRUE );

    plbFrom->Invalidate( TRUE );
    plbTo->Invalidate( TRUE );
    EnableButtons();

    return err;
}


/*********************************************************************

    NAME:       BLT_SET_CONTROL::MoveItems

    SYNOPSIS:   Move the selected LBIs from one listbox to the other.

    ENTRY:
        plbFrom - the listbox containing selected items, from which
                  those items will be moved
        plbTo   - the destination listbox, which will receive the
                  moved items

    RETURN:     APIERR

    HISTORY:
        jonn        09-Sep-1993 Created

*********************************************************************/

APIERR BLT_SET_CONTROL::MoveItems( LISTBOX * plbFrom,
                                   LISTBOX * plbTo )
{
    return BLTMoveItems( (BLT_LISTBOX *)plbFrom, (BLT_LISTBOX *)plbTo );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltsi.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltsi.cxx
    Source file the BLT spin item

    FILE HISTORY:
	terryk	    15-Apr-1991 Created
	terryk	    20-Jun-1991 code review changed. Attend: beng
	terryk	    11-Nov-1991	changed SPIN_ITEM type from INT to LONG
	terryk	    20-Dec-1991	long conversions
	terryk	    22-Mar-1992	changed LONG to ULONG
*/

#include "pchblt.hxx"  // Precompiled header


/*********************************************************************

    NAME:       SPIN_ITEM::SPIN_ITEM

    SYNOPSIS:   constructor

    ENTRY:      HWND hwnd - pass the hwnd to the dispatcher

    HISTORY:
                terryk  01-May-1991 Created
                terryk  20-Jun-1991 Use dispatcher method

*********************************************************************/

SPIN_ITEM::SPIN_ITEM( CONTROL_WINDOW *pWin )
    : CUSTOM_CONTROL( pWin )
{
    // do nothing
}


/*********************************************************************

    NAME:       SPIN_ITEM::~SPIN_ITEM

    SYNOPSIS:   destrcutor

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

SPIN_ITEM::~SPIN_ITEM()
{
    // do nothing
}


/*********************************************************************

    NAME:       SPIN_ITEM::OnFocus

    SYNOPSIS:   OnFocus

    ENTRY:      FOCUS_EVENT & event

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

BOOL SPIN_ITEM::OnFocus( const FOCUS_EVENT & event )
{
    UNREFERENCED( event );

    SPIN_GROUP  * pSB = (SPIN_GROUP *)QueryGroup();
    return pSB->DoNewFocus( this );
}


/*********************************************************************

    NAME:       SPIN_ITEM::OnChar

    SYNOPSIS:   Pass the character to the spin group.

    ENTRY:      CHAR_EVENT event.

    RETURN:     return a BOOL from DoChar method of SPIN_GROUP

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL SPIN_ITEM::OnChar( const CHAR_EVENT & event )
{
    SPIN_GROUP  *pSB = (SPIN_GROUP *)QueryGroup();
    return pSB->DoChar( (CHAR_EVENT & )event );
}


/*********************************************************************

    NAME:       SPIN_ITEM::QueryGroup

    SYNOPSIS:   return the associated group of this spin item

    RETURN:     CONTROL_GROUP * control_group

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

CONTROL_GROUP * SPIN_ITEM::QueryGroup()
{
    CONTROL_WINDOW *pcw=QueryControlWin();
    return pcw->QueryGroup();
}


/*********************************************************************

    NAME:       SPIN_ITEM::SetAccKey

    SYNOPSIS:   set the internal variable for accelerator keys.

    ENTRY:      NLS_STR nlsStr - it is the accelerator keys string
                OR
                USHORT usMsgID - string ID

    NOTES:      It get the accelerator key string from the caller
                and set the string to an internal string.

    HISTORY:
	terryk	    23-May-91	Created
	beng	    04-Oct-1991 Win32 conversion

*********************************************************************/

APIERR SPIN_ITEM::SetAccKey( const NLS_STR & nlsStr )
{
    APIERR apierr = nlsStr.QueryError();

    if ( apierr != NERR_Success )
    {
        return apierr;
    }

    _nlsAccKey = nlsStr;

    return _nlsAccKey.QueryError();
}

APIERR SPIN_ITEM::SetAccKey( MSGID msgid )
{
    NLS_STR nlsStr;

    APIERR err = nlsStr.Load( msgid ) ;

    if ( err != NERR_Success )
    {
        return err;
    }

    return SetAccKey( nlsStr );
}


/*********************************************************************

    NAME:       SPIN_ITEM::QueryAccCharPos

    SYNOPSIS:   check whether the given character is one of
                accelerator key within the object.

    ENTRY:      WCHAR cInput - key to be checked

    RETURN:     the position of the character within the accelerator
                or -1 if the character does not belong to the accelerator
                key set.

    NOTE:       CODEWORK. change to NLS_STR if it returns an integer

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

LONG SPIN_ITEM::QueryAccCharPos( WCHAR wchInput )
{
    ISTR istrAccKey( _nlsAccKey );
    LONG cwcNumChar = _nlsAccKey.QueryNumChar();
    LONG i;

    // AnsiUpperBuff( (TCHAR *)&wchInput, 1 );

    // CODEWORK: create a virtual function call LeadingChar for each string
    //           object
    for ( i=0; ( wchInput != _nlsAccKey.QueryChar( istrAccKey )) &&
        i < cwcNumChar; i++, ++istrAccKey )
        ;

    return ( i < cwcNumChar ) ? i : ( -1 );
}

/*********************************************************************

    NAME:       SPIN_ITEM::QueryAccKey

    SYNOPSIS:   return the accelator key string in NLS_STR format

    ENTRY:      NLS_STR *nlsAccKey - the returned accelator key list

    EXIT:       NLS_STR *nlsAccKey - the returned key list

    RETURN:     APIERR. return code.

    HISTORY:
                terryk  20-Jun-91   Created

*********************************************************************/

APIERR SPIN_ITEM::QueryAccKey( NLS_STR * pnlsAccKey )
{
    UIASSERT( pnlsAccKey != NULL );

    *pnlsAccKey = _nlsAccKey;
    return pnlsAccKey->QueryError();
}


/*****************************************************************/


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::CHANGEABLE_SPIN_ITEM

    SYNOPSIS:   constructor

    ENTRY:      CONTROL_WINDOW *pWin - a control window pointer
                ULONG nValue - the default value
                ULONG nMin - min number
                ULONG dRange - the range
                BOOL fWrap - wrap-around or not

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

CHANGEABLE_SPIN_ITEM::CHANGEABLE_SPIN_ITEM( CONTROL_WINDOW *pWin, ULONG nValue,
                                            ULONG nMin, ULONG dRange, BOOL fWrap)
    : SPIN_ITEM ( pWin),
    _nValue( nValue ),
    _nMin( nMin ),
    _dRange( dRange ),
    _fWrap( fWrap ),
    _dBigIncValue( 10 ),
    _dSmallIncValue( 1 ),
    _dBigDecValue( 10 ),
    _dSmallDecValue( 1 )
{
    // No action needed here
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetRange

    SYNOPSIS:   Set the object's range

    ENTRY:      ULONG dRange - range of the object

    EXIT:       set the internal dRange variable

    NOTE:       CODEWORK: use itoa in NLS_STR when available.

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetRange( const ULONG dRange )
{
    _dRange = dRange;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetMin

    SYNOPSIS:   set the minimal number of the object

    ENTRY:      ULONG nMin - the minimal number

    EXIT:       set the minimal number within the object

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetMin( const ULONG nMin )
{
    _nMin = nMin;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetValue

    SYNOPSIS:   set the current value of the control item

    ENTRY:      ULONG nValue - value to be set

    NOTES:      The program will die if the value is invalid

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetValue( const ULONG nValue )
{
    UIASSERT ( CheckRange( nValue ) == 0 );

    _nValue = nValue;

}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetBigIncValue

    SYNOPSIS:   set the big increase value

    ENTRY:      ULONG dBigIncValue - the value to be increased by.

    NOTES:      The big increase value for the SPIN_GROUP .
                The default is 10.

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetBigIncValue( const ULONG dBigIncValue )
{
    _dBigIncValue = dBigIncValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetSmallIncValue

    SYNOPSIS:   set the small increase value

    ENTRY:      ULONG dSmallIncValue - the value to be increased by

    NOTES:      The small increase value for the SPIN_GROUP .
                The default is 1.

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetSmallIncValue( const ULONG dSmallIncValue )
{
    _dSmallIncValue = dSmallIncValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetBigDecValue

    SYNOPSIS:   set the big decrease value

    ENTRY:      ULONG dBigDecValue - the value to be decreased by.

    NOTES:      The big decrease value for the SPIN_GROUP .
                The default is 10.

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetBigDecValue( const ULONG dBigDecValue )
{
    _dBigDecValue = dBigDecValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SetSmallDecValue

    SYNOPSIS:   set the small decrease value

    ENTRY:      ULONG dSmallDecValue - the value to be decreased by

    NOTES:      The small decrease value for the SPIN_GROUP .
                The default is 1.

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::SetSmallDecValue( const ULONG dSmallDecValue )
{
    _dSmallDecValue = dSmallDecValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::QuerySmallIncValue

    SYNOPSIS:   return the small increase value

    RETURN:     the small increase value

    HISTORY:
                terryk  23-Jul-91   Created

*********************************************************************/

ULONG CHANGEABLE_SPIN_ITEM::QuerySmallIncValue() const
{
    return _dSmallIncValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::QueryBigIncValue

    SYNOPSIS:   return the big increase value

    RETURN:     the big increase value

    HISTORY:
                terryk  23-Jul-91   Created

*********************************************************************/

ULONG CHANGEABLE_SPIN_ITEM::QueryBigIncValue() const
{
    return _dBigIncValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::QuerySmallDecValue

    SYNOPSIS:   return the small decrease value

    RETURN:     the small decrease value

    HISTORY:
                terryk  23-Jul-91   Created

*********************************************************************/

ULONG CHANGEABLE_SPIN_ITEM::QuerySmallDecValue() const
{
    return _dSmallDecValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::QueryBigDecValue

    SYNOPSIS:   return the bid decrease value

    RETURN:     the big decrease value

    HISTORY:
                terryk  23-Jul-91   Created

*********************************************************************/

ULONG CHANGEABLE_SPIN_ITEM::QueryBigDecValue() const
{
    return _dBigDecValue;
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::operator+=

    SYNOPSIS:   add an integer value to the object

    ENTRY:      ULONG nValue - integer value to be added to the object

    NOTES:      Increase the internal value of the object

    HISTORY:
                terryk  01-May-1991 	Created
		terryk	20-Dec-1991	Long conversion

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::operator+=( const ULONG nValue )
{
    UIASSERT( _dRange > 0 );

    if ( _nValue > ( _nValue + nValue ))
    {
	// okay we are overflow.
	_nValue = _fWrap
                  ? _nMin + ( nValue - ( QueryMax() - _nValue + 1)) %_dRange
		  : QueryMax();
    }
    else
    {

    	_nValue += nValue;

    	if ( _nValue > QueryMax() )
            _nValue = _fWrap
                      ? _nMin + (( _nValue - QueryLimit()) % _dRange )
		      : QueryMax();
    }
    Update();
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::operator-=

    SYNOPSIS:   subtract an integer value from the object

    ENTRY:      ULONG nValue - an inetger to be subtracted

    NOTES:      decrease the internal value of the object.
                Depending on the wrap variable, the function will
                wrap the number or set it to the min number.

    HISTORY:
                terryk  01-May-1991 	Created
		terryk	20-Dec-1991	Long conversions

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::operator-=( const ULONG nValue )
{
    UIASSERT( _dRange > 0 );

    if (( _nValue < ( _nValue - nValue )) || (( _nValue - nValue ) < _nMin ))
    {
    	// okay, we are underflow
    	_nValue = _fWrap
                  ? QueryMax() - (nValue - (_nValue - QueryMin() + 1)) % _dRange
    		  : _nMin;
    }
    else
    {
	_nValue -= nValue;
    }
    Update();
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::Update

    SYNOPSIS:   update the item value

    NOTE:       This is a virtual function.

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

VOID CHANGEABLE_SPIN_ITEM::Update( )
{
    // do nothing
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::CheckRange

    SYNOPSIS:   check withthe the given number is within the range

    ENTRY:      ULONG nValue - number to be checked

    RETURN:     -1 if the nValue is smaller than the range
                0 if the nValue is within the range
                1 if the nValue is bigger than the range

    HISTORY:
                terryk  23-May-91   Created

*********************************************************************/

INT CHANGEABLE_SPIN_ITEM::CheckRange( const ULONG nValue ) const
{
    if ( nValue < _nMin )
    {
        return -1;
    }
    else
    {
        if ( nValue >= ( _nMin + _dRange ))
        {
            return 1;
        }
        else
        {
            return 0;
        }
    }
}


/*********************************************************************

    NAME:       CHANGEABLE_SPIN_ITEM::SaveCurrentData

    SYNOPSIS:   save the window text into the internal variable

    RETURN:     APIERR - since this is a vritual function, it always
                return NERR_Success.

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

APIERR CHANGEABLE_SPIN_ITEM::SaveCurrentData()
{
    return NERR_Success;
}


/*********************************************************************

    NAME:       STATIC_SPIN_ITEM::STATIC_SPIN_ITEM

    SYNOPSIS:   constructor

    ENTRY:      HWND hWnd - window handler

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

STATIC_SPIN_ITEM::STATIC_SPIN_ITEM( CONTROL_WINDOW *pWin )
    : SPIN_ITEM( pWin )
{
    // No action needed
}

/*********************************************************************

    NAME:       STATIC_SPIN_ITEM::OnFocus

    SYNOPSIS:   OnFocus

    ENTRY:      FOCUS_EVENT & event

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

BOOL STATIC_SPIN_ITEM::OnFocus( const FOCUS_EVENT & event )
{
    UNREFERENCED( event );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltsplit.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    bltsplit.cxx
        Source file for the Splitter Bar custom control

    FILE HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)
*/


#include "pchblt.hxx"  // Precompiled header

#include "bltsplit.hxx"


const TCHAR * H_SPLITTER_BAR::_pszClassName = SZ("static");


/*********************************************************************

    NAME:       H_SPLITTER_BAR::H_SPLITTER_BAR

    SYNOPSIS:   Splitter bars can seperate the window pane into two or
                more parts.  This splitter bar is modelled after
                WinWord 6's splitter bar with visual modifications
                recommended by KeithL.

    ENTRY:      OWNER_WINDOW *powin - owner window of the control
                CID cid - cid of the control

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

H_SPLITTER_BAR::H_SPLITTER_BAR( OWNER_WINDOW *powin, CID cid )
    : CONTROL_WINDOW( powin, cid ),
      CUSTOM_CONTROL( this ),
      _fCapturedMouse( 0 ),
      _dxActiveArea( 0 ),
      _dyLineWidth( 0 ),
      _xyrectHitZone(),
      _xyrectNotHitZone(),
      _pdcDrag( NULL ),
      _fInDrag( FALSE ),
      _fShowingDragBar( FALSE ),
      _xyLastDragPoint( 0, 0 ),
      _hcurActive( NULL ),
      _hcurSave( NULL )
{
    ASSERT( powin != NULL );

    CtAux();
}

H_SPLITTER_BAR::H_SPLITTER_BAR( OWNER_WINDOW *powin, CID cid,
              XYPOINT xy, XYDIMENSION dxy, ULONG flStyle )
    : CONTROL_WINDOW ( powin, cid, xy, dxy, flStyle, _pszClassName ),
      CUSTOM_CONTROL( this ),
      _fCapturedMouse( 0 ),
      _dxActiveArea( 0 ),
      _dyLineWidth( 0 ),
      _xyrectHitZone(),
      _xyrectNotHitZone(),
      _pdcDrag( NULL ),
      _fInDrag( FALSE ),
      _fShowingDragBar( FALSE ),
      _xyLastDragPoint( 0, 0 ),
      _hcurActive( NULL ),
      _hcurSave( NULL )
{
    ASSERT( powin != NULL );

    CtAux();
}

VOID H_SPLITTER_BAR::CtAux()
{
    if (QueryError() != NERR_Success)
    {
        DBGEOL( "H_SPLITTER_BAR::CtAux(): parent ctor failed" );
        return;
    }

    APIERR err;
    if (   (err = _xyrectHitZone.QueryError()) != NERR_Success
        || (err = _xyrectNotHitZone.QueryError()) != NERR_Success
       )
    {
        DBGEOL( "H_SPLITTER_BAR error: ctor failed " << err );
        ReportError( err );
        return ;
    }

    _hcurActive = CURSOR::Load( ID_CURS_BLT_VSPLIT );
    if (_hcurActive == NULL)
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        DBGEOL( "H_SPLITTER_BAR error: CURSOR::Load failed" );
        return ;
    }

    _dxActiveArea = ::GetSystemMetrics( SM_CXVSCROLL );
    _dyLineWidth  = ::GetSystemMetrics( SM_CYBORDER  );

    TRACEEOL( "H_SPLITTER_BAR ctor: _dxActiveArea = " << _dxActiveArea );
    TRACEEOL( "H_SPLITTER_BAR ctor: _dyLineWidth  = " << _dyLineWidth  );
}


H_SPLITTER_BAR::~H_SPLITTER_BAR()
{
    if (_hcurSave != NULL)
    {
        CURSOR::Set(_hcurSave);
        _hcurSave = NULL;
    }

    if (_hcurActive != NULL)
    {
        ::DeleteObject( _hcurActive );
        _hcurActive = NULL;
    }

    delete _pdcDrag;
    _pdcDrag = NULL;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnPaintReq

    SYNOPSIS:   Redraw the whole object

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

BOOL H_SPLITTER_BAR::OnPaintReq()
{
    BOOL fWasShowingDrag = _fShowingDragBar;
    ClearDragBar();

    PAINT_DISPLAY_CONTEXT dc(this);

    HBRUSH hbrBlack = NULL;

    do {   // false loop

        INT xActiveArea = QueryActiveArea();

        hbrBlack = ::CreateSolidBrush( 0x00000000 );
        SOLID_BRUSH brushBkgnd( COLOR_BTNFACE );
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   hbrBlack == NULL
            || (err = brushBkgnd.QueryError()) != NERR_Success
           )
        {
            DBGEOL( "H_SPLITTER_BAR::OnPaintReq(): SOLID_BRUSH error " << err );
            break;
        }

        /*
         *   Draw active area (in scrollbar zone) black and rest white
         */
        ::FillRect(  dc.QueryHdc(),
                     (const RECT *)_xyrectHitZone,
                     hbrBlack );

        ::FillRect(  dc.QueryHdc(),
                     (const RECT *)_xyrectNotHitZone,
                     brushBkgnd.QueryHandle() );

        ::FrameRect( dc.QueryHdc(),
                     (const RECT *)_xyrectNotHitZone,
                     hbrBlack );

    } while (FALSE);  // false loop

    if (hbrBlack != NULL)
    {
        ::DeleteObject( hbrBlack );
    }

#if 0 // old look

    HPEN hpenOld = NULL;
    HBRUSH hbrBlack = NULL;

    do {   // false loop

        INT xActiveArea = QueryActiveArea();

        // are these the right colors?
        hbrBlack = ::CreateSolidBrush( 0x00000000 );
        SOLID_BRUSH brushBkgnd( COLOR_WINDOW );
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (   hbrBlack == NULL
            || (err = brushBkgnd.QueryError()) != NERR_Success
           )
        {
            DBGEOL( "H_SPLITTER_BAR::OnPaintReq(): SOLID_BRUSH error " << err );
            break;
        }

        /*
         *   Draw active area (in scrollbar zone) black and rest white
         */
        ::FillRect( dc.QueryHdc(),
                    (const RECT *)_xyrectHitZone,
                    hbrBlack );

        ::FillRect( dc.QueryHdc(),
                    (const RECT *)_xyrectNotHitZone,
                    brushBkgnd.QueryHandle() );

        HPEN hpenBlack = ::CreatePen( PS_SOLID, _dyLineWidth, 0x00000000 );
        if (hpenBlack == NULL)
        {
            DBGEOL( "H_SPLITTER_BAR::OnPaintReq(): HPEN error" );
            break;
        }
        hpenOld = dc.SelectPen( hpenBlack );

        /*
         *  Draw splitter lines through main area
         */
        dc.MoveTo( 0,                              2 * _dyLineWidth );
        dc.LineTo( _xyrectNotHitZone.CalcWidth(),  2 * _dyLineWidth );
        dc.MoveTo( 0,                              4 * _dyLineWidth );
        dc.LineTo( _xyrectNotHitZone.CalcWidth(),  4 * _dyLineWidth );

        /*
         *  Draw line to set off lower column header
         */
        dc.MoveTo( 0,                              7 * _dyLineWidth );
        dc.LineTo( _xyrectNotHitZone.CalcWidth(),  7 * _dyLineWidth );

    } while (FALSE);  // false loop

    if (hpenOld != NULL)
    {
        HPEN hpenNew = dc.SelectPen( hpenOld );
        if (hpenNew != NULL)
        {
            ::DeleteObject( hpenNew );
        }
    }

    if (hbrBlack != NULL)
    {
        ::DeleteObject( hbrBlack );
    }

#endif // old look

    if (fWasShowingDrag)
        ShowDragBar( _xyLastDragPoint );

    return TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnResize

    SYNOPSIS:   Change on object size

    HISTORY:
        jonn    11-Oct-93   Created

**********************************************************************/

BOOL H_SPLITTER_BAR::OnResize( const SIZE_EVENT & ev )
{
    XYPOINT     xyOrigin( 0, 0 );
    XYDIMENSION dxySize( ev.QueryWidth(), ev.QueryHeight() );
    XYRECT      xyrectClient( xyOrigin, dxySize );

    INT dxActiveArea = QueryActiveArea();
    ASSERT( xyrectClient.CalcWidth() > dxActiveArea );

    // must adjust top/bottom to make golumn headers look right
    // CODEWORK column headers should take care of themselves
    xyrectClient.AdjustTop( -1 );
    xyrectClient.AdjustBottom( -1 );

    _xyrectHitZone = _xyrectNotHitZone = xyrectClient;

    _xyrectHitZone.AdjustLeft( _xyrectHitZone.CalcWidth() - dxActiveArea );
    _xyrectNotHitZone.AdjustRight( -dxActiveArea );

    return TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::QueryActiveArea

    SYNOPSIS:   Get width of active area, defaults to width of scrollbar thumb

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

INT H_SPLITTER_BAR::QueryActiveArea()
{
    return _dxActiveArea;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::QueryDesiredHeight

    SYNOPSIS:   Get height desired by control

    HISTORY:
        jonn    08-Oct-93   Created (loosely based on bltmeter and bltlhour)

**********************************************************************/

INT H_SPLITTER_BAR::QueryDesiredHeight()
{
    return 8 * _dyLineWidth;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnLMouseButtonDown

    SYNOPSIS:   Response to a left-mouse-button-down event

    HISTORY:
        jonn        11-Oct-1993 Templated from SET_CONTROL

*********************************************************************/

BOOL H_SPLITTER_BAR::OnLMouseButtonDown( const MOUSE_EVENT & e )
{
    TRACEEOL( "H_SPLITTER_BAR::OnLMouseButtonDown()" );

    ASSERT(!_fInDrag);

    XYPOINT xy = e.QueryPos(); // n.b. already in client coords

    if (!IsWithinHitZone(xy))
        return FALSE; // let defproc handle it

    MakeDisplayContext( &_pdcDrag );
    if (_pdcDrag == NULL)
    {
        DBGEOL( "H_SPLITTER_BAR::OnLMouseButtonDown: MakeDisplayContext failed" );
        return FALSE;
    }

    // Mousedown took place on the draggable region of an already
    // selected item: initiate the drag proper.

    CaptureMouse();
    _fInDrag = TRUE;
    ShowDragBar( xy );
    ShowSpecialCursor( TRUE );

    return TRUE; // message handled - don't pass along
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnLMouseButtonUp

    SYNOPSIS:   Response to a left-mouse-button-up event

    HISTORY:
        jonn        11-Oct-1993 Templated from SET_CONTROL

*********************************************************************/

BOOL H_SPLITTER_BAR::OnLMouseButtonUp( const MOUSE_EVENT & e )
{
    TRACEEOL( "H_SPLITTER_BAR::OnLMouseButtonUp()" );

    if (!_fInDrag)
        return FALSE;

    // Clean up from drag-mode

    ShowSpecialCursor( FALSE );
    ClearDragBar();
    _fInDrag = FALSE;
    ReleaseMouse();

    delete _pdcDrag;
    _pdcDrag = NULL;

    OnDragRelease( e.QueryPos() );

    return TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::OnMouseMove

    SYNOPSIS:   Response to a mouse-move event

    HISTORY:
        jonn        11-Oct-1993 Templated from SET_CONTROL

*********************************************************************/

BOOL H_SPLITTER_BAR::OnMouseMove( const MOUSE_EVENT & e )
{
    TRACEEOL( "H_SPLITTER_BAR::OnMouseMove()" );

    if (_fInDrag)
    {
        ShowDragBar( e.QueryPos() );
    }

    return TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::IsWithinHitZone

    SYNOPSIS:   Determines whether cursor is inside active area

    HISTORY:
        jonn        11-Oct-1993 Templated from SET_CONTROL

*********************************************************************/

BOOL H_SPLITTER_BAR::IsWithinHitZone( const XYPOINT & xy )
{
    return _xyrectHitZone.ContainsXY( xy );
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::ShowSpecialCursor

    SYNOPSIS:   Changes to/from special splitter-bar cursor

    HISTORY:
        jonn        11-Oct-1993 Created

*********************************************************************/

VOID H_SPLITTER_BAR::ShowSpecialCursor( BOOL fSpecialCursor )
{
    if ( fSpecialCursor )
    {
        if (_hcurSave == NULL)
        {
            _hcurSave = CURSOR::Query();
            if (_hcurSave == NULL)
            {
                DBGEOL( "H_SPLITTER_BAR::ShowSpecialCursor(): CURSOR::Query failed" );
            }
            else
            {
                CURSOR::Set( _hcurActive );
            }
        }
    }
    else
    {
        if (_hcurSave != NULL)
        {
            CURSOR::Set( _hcurSave );
            _hcurSave = NULL;
        }
    }
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::ShowDragBar

    SYNOPSIS:   Adds/moves drag bar

    HISTORY:
        jonn        11-Oct-1993 Created

*********************************************************************/

VOID H_SPLITTER_BAR::ShowDragBar( const XYPOINT & xyClientCoords )
{
    if ( _fShowingDragBar )
    {
        /*
         *  Do nothing if vertical position has not changed
         */
        if ( xyClientCoords.QueryY() == _xyLastDragPoint.QueryY() )
        {
            return;
        }

        ClearDragBar();
    }

    InvertDragBar( xyClientCoords );
    _xyLastDragPoint = xyClientCoords;
    _fShowingDragBar = TRUE;
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::ClearDragBar

    SYNOPSIS:   Removes drag bar

    HISTORY:
        jonn        11-Oct-1993 Created

*********************************************************************/

VOID H_SPLITTER_BAR::ClearDragBar()
{
    if ( _fShowingDragBar )
    {
        InvertDragBar( _xyLastDragPoint );
        _fShowingDragBar = FALSE;
    }
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::InvertDragBar

    SYNOPSIS:   Adds/moves drag bar

    CODEWORK:   The appearance of the drag bar is somewhat different from
                WinWord6.  WinWord6 seems to combine a gray bar with what
                is already on screen, then restore the screen contents
                somehow.  I invert the screen contents, which looks more like
                a black bar which turns white over text.

    HISTORY:
        jonn        11-Oct-1993 Created

*********************************************************************/

VOID H_SPLITTER_BAR::InvertDragBar( const XYPOINT & xyClientCoords )
{
    if (_pdcDrag == NULL)
    {
        DBGEOL( " H_SPLITTER_BAR::InvertDragBar(): no DISPLAY_CONTEXT" );
    }
    else
    {
        XYRECT xyrectOwner( WINDOW::QueryOwnerHwnd() );

        ::PatBlt( _pdcDrag->QueryHdc(),
                  0,
                  xyClientCoords.QueryY() - ((_dyLineWidth-1) / 2),
                  xyrectOwner.CalcWidth(),
                  _dyLineWidth,
                  DSTINVERT
                );
    }
}


/*******************************************************************

    NAME:       H_SPLITTER_BAR::OnQMouseCursor

    SYNOPSIS:   Callback determining whether mouse movement should
                change the cursor

    HISTORY:
        jonn        11-Oct-1993 Templated from bltlhour.cxx
        jonn        11-Oct-1993 only hit in active area

********************************************************************/

BOOL H_SPLITTER_BAR::OnQMouseCursor( const QMOUSEACT_EVENT & e )
{
    BOOL fInActiveArea = (e.QueryHitTest() == HTCLIENT);
    if (fInActiveArea)
        CURSOR::Set( _hcurActive );

    return fInActiveArea;
}


/*******************************************************************

    NAME:       H_SPLITTER_BAR::OnQHitTest

    SYNOPSIS:   Callback determining the subloc within a window

    HISTORY:
        jonn        11-Oct-1993 Templated from bltlhour.cxx
        jonn        11-Oct-1993 only hit in active area

********************************************************************/

ULONG H_SPLITTER_BAR::OnQHitTest( const XYPOINT & xy )
{
    XYPOINT xyTmp = xy;
    xyTmp.ScreenToClient( WINDOW::QueryHwnd() );

    return ( IsWithinHitZone(xyTmp) ) ? HTCLIENT : HTNOWHERE;
}


/*******************************************************************

    NAME:       H_SPLITTER_BAR::OnDragRelease

    SYNOPSIS:   Subclasses will redefine this

    HISTORY:
        jonn        11-Oct-1993 Created

********************************************************************/

VOID H_SPLITTER_BAR::OnDragRelease( const XYPOINT & xyClientCoords )
{
    DBGEOL( "H_SPLITTER_BAR::OnDragRelease: why wasn't this redefined??" );
}


/*********************************************************************

    NAME:       H_SPLITTER_BAR::Dispatch

    SYNOPSIS:   Main routine to dispatch the event appropriately

    ENTRY:      EVENT event - general event

    CODEWORK:   There should be a common routine to deal with this,
                rather than having so many copies of this code.

    HISTORY:
        jonn        12-Oct-1993 templated from bltcolh.cxx

*********************************************************************/

BOOL H_SPLITTER_BAR::Dispatch( const EVENT &event, ULONG * pnRes )
{
    if ( event.QueryMessage() == WM_ERASEBKGND )
    {
        DWORD dwColor = ::GetSysColor( COLOR_WINDOW );

        HBRUSH hBrush = ::CreateSolidBrush( dwColor );
        ASSERT( hBrush != NULL );

        RECT r;
        QueryClientRect( &r );
        REQUIRE( ::FillRect( (HDC)event.QueryWParam(), &r, hBrush ) != FALSE );

        REQUIRE( ::DeleteObject( hBrush ) != FALSE );

        return TRUE;
    }

    return CUSTOM_CONTROL::Dispatch( event, pnRes );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltspobj.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    spinobj.cxx
    Spin button object source file.

    This file contain some spin button object as:
	DISK_SPACE_SUBCLASS

    FILE HISTORY:
	terryk	    30-Jun-91	Created
	terryk	    05-Aug-91	Add initial status parameter to the object
	terryk	    30-Aug-91	Code review changes.
				Attend: o-simop davidbul beng
	terryk	    11-Nov-91	change SPIN_ITEM's type from INT to LONG
	terryk	    17-Apr-92	changed LONG to ULONG

*/

#include "pchblt.hxx"  // Precompiled header


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::SPIN_SLE_VALID_SECOND

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - owner window
		CID cid - cid of the spin item
		const TCHAR * pszFieldName - field name ( NULL is default)
		LONG nValue - the initial value
		LONG nMin - min value
		LONG nRange - the range
		LONG nSecondInc - Increase figure
		BOOL fWrap - wrap around or not

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

SPIN_SLE_VALID_SECOND::SPIN_SLE_VALID_SECOND(OWNER_WINDOW * powin, CID cid,
    LONG nValue, LONG nMin, LONG nRange, LONG nSecondInc, BOOL fWrap )
    : SPIN_SLE_NUM_VALID( powin, cid, nValue, nMin, nRange, fWrap ),
    _nSecondInc( nSecondInc )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
    SetBigIncValue( _nSecondInc );
    SetSmallIncValue( _nSecondInc );
}


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::QuerySmallIncValue

    SYNOPSIS:   return the small increase value. It is the different
		between nearest multiple of the _nSecondInc and the
		current value.

    RETURN:     the nearest multiple of _nSecondInc

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ULONG SPIN_SLE_VALID_SECOND::QuerySmallIncValue() const
{
    return _nSecondInc - (LONG)QueryValue() % _nSecondInc;
}


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::QueryBigIncValue

    SYNOPSIS:   the same as QuerySmallIncValue

    RETURN:     the different between the nearest number of the multiple
		of _nSecondInc and the current value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ULONG SPIN_SLE_VALID_SECOND::QueryBigIncValue() const
{
    return QuerySmallIncValue();
}


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::QuerySmallDecValue

    SYNOPSIS:   return the different between the nearest multiple of
		_nSecondInc, which is below the current value, and the
		current value.

    RETURN:     the different between the current value and the
		nearest multiple of _nSecondInc which is below
		the current value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ULONG SPIN_SLE_VALID_SECOND::QuerySmallDecValue() const
{
    LONG nNum = (LONG)QueryValue() % _nSecondInc;

    return ( nNum == 0 ) ? _nSecondInc : nNum;
}


/*********************************************************************

    NAME:       SPIN_SLE_VALID_SECOND::QueryBigDecValue

    SYNOPSIS:   same as QuerySmallDecValue

    RETURN:     return the different between the current value and the
		nearest multiple of _nSecondInc which is below
		the current value.

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ULONG SPIN_SLE_VALID_SECOND::QueryBigDecValue() const
{
    return QuerySmallDecValue();
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::ELAPSED_TIME_CONTROL

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * pointer to the owner window
		CID cidMinute - minute field cid
		CID cidSeparator - sepaprator field cid
		CID cidSecond - second field cid
		CID cidSpinButton - spin button cid
		CID cidUpArrow - up arrow cid
		CID cidDownArrow - down arrow cid
		SLT &sltMinute - associated minute string
		LONG nMinuteDefault - default value of the minute field
		LONG nMinuteMin - min value of the minute field
		LONG dMinuteRange - the range of the minute field
		SLT &sltSeparator - associate separator string
		SLT &sltSecond - associate second string
		LONG nSecondDefault - default second field value
		LONG nSecondMin - min second value
		LONG dSecondRange - the range of the second field
		LONG nSecondInc - Increase second value
		BOOL fActive - initial status of the button

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

ELAPSED_TIME_CONTROL::ELAPSED_TIME_CONTROL(
	OWNER_WINDOW * powin,
        CID cidMinute,
        CID cidSeparator,
        CID cidSecond,
        CID cidSpinButton,
        CID cidUpArrow,
        CID cidDownArrow,
        SLT & sltMinute,
        LONG nMinuteDefault,
        LONG nMinuteMin,
        LONG dMinuteRange,
        SLT & sltSeparator,
        SLT & sltSecond,
        LONG nSecondDefault,
        LONG nSecondMin,
        LONG dSecondRange,
	LONG nSecondInc,
	BOOL fActive )
    : SPIN_GROUP( powin, cidSpinButton, cidUpArrow, cidDownArrow, fActive ),
    _spsleMinute( powin, cidMinute, nMinuteDefault, nMinuteMin,
                  dMinuteRange ),
    _spsltSeparator( powin, cidSeparator ),
    _spsleSecond( powin, cidSecond, nSecondDefault, nSecondMin,
                  dSecondRange, nSecondInc )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }

    // set the Accelator key
    APIERR err = SetSpinItemAccKey( & _spsleMinute, sltMinute, 1 );

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = SetSpinItemAccKey( & _spsltSeparator, sltSeparator, 0 );

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = SetSpinItemAccKey( & _spsleSecond, sltSecond, 1 );

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ((( err = AddAssociation( & _spsleMinute )) != NERR_Success ) ||
	(( err = AddAssociation( & _spsltSeparator )) != NERR_Success ) ||
    	(( err = AddAssociation( & _spsleSecond )) != NERR_Success ))
    {
	ReportError( err );
	return;
    }
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetSpinItemAccKey

    SYNOPSIS:   set the spin items' accelerator key.
		Get the first character of each of the associate SLT
		string and set them as the accelerator key

    ENTRY:      SPIN_ITEM * psi - spin item to be associated
		SLT & slt - the slt string which contains the
		    accelerator key
		INT cchPos - the accelerator key position

    EXIT:       NERR_Success if success. Otherwise it is failure.

    HISTORY:
		terryk	29-Jun-1991	Created

*********************************************************************/

APIERR ELAPSED_TIME_CONTROL::SetSpinItemAccKey( SPIN_ITEM * psi, SLT & slt,
    INT cchPos )
{
    NLS_STR nlsAccKey;

    APIERR err = slt.QueryText( & nlsAccKey );

    if ( err != NERR_Success )
    {
        DBGEOL( SZ("ELAPSED_TIME_CONTROL: constructor failed.") );
        return err;
    }

    ISTR istrFirstChar( nlsAccKey );
    istrFirstChar += cchPos;

    ISTR istrSecondChar = istrFirstChar;
    ++istrSecondChar;

    NLS_STR *pnlsTemp = nlsAccKey.QuerySubStr( istrFirstChar, istrSecondChar );
    if (NULL == pnlsTemp)
        return ERROR_NOT_ENOUGH_MEMORY; // JonN 01/27/00 PREFIX bug 444899

    if ((( err = pnlsTemp->QueryError()) != NERR_Success ) ||
    	(( err = psi->SetAccKey( *pnlsTemp )) != NERR_Success ))
    {
	DBGEOL( SZ("ELAPSED_TIME_CONTROL: constructor failed.") );
    }

    delete pnlsTemp;

    return err;
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetMinuteMin

    SYNOPSIS:   set the minute field min value

    ENTRY:      const LONG nMin - min value to be set

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetMinuteMin( const LONG nMin )
{
    _spsleMinute.SetMin( nMin );
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetMinuteRange

    SYNOPSIS:   set the minute field range

    ENTRY:      const LONG dRange - the new range value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetMinuteRange( const LONG dRange )
{
    _spsleMinute.SetRange( dRange );
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetSecondMin

    SYNOPSIS:   set the second field min value

    ENTRY:      const LONG nMin - min value number

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetSecondMin( const LONG nMin )
{
    _spsleSecond.SetMin( nMin );
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetSecondRange

    SYNOPSIS:   set the second field range value

    ENTRY:      const LONG dRange - the new range value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetSecondRange( const LONG dRange )
{
    _spsleSecond.SetRange( dRange );
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetMinuteValue

    SYNOPSIS:   set the minute field current value

    ENTRY:      const LONG nMinute - new current value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetMinuteValue( const LONG nMinute )
{
    _spsleMinute.SetValue( nMinute );
    _spsleMinute.Update();
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::SetSecondValue

    SYNOPSIS:   set the second field current value

    ENTRY:      const LONG nSecond - new current value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetSecondValue( const LONG nSecond )
{
    _spsleSecond.SetValue( nSecond );
    _spsleSecond.Update();
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::QueryMinuteValue

    SYNOPSIS:   get the minute field current value

    RETURN:     current minute field value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

LONG ELAPSED_TIME_CONTROL::QueryMinuteValue() const
{
    return _spsleMinute.QueryValue();
}


/*********************************************************************

    NAME:       ELAPSED_TIME_CONTROL::QuerySecondValue

    SYNOPSIS:   get the second field current value

    RETURN:     current second field value

    HISTORY:
		terryk	30-Jun-1991	Created

*********************************************************************/

LONG ELAPSED_TIME_CONTROL::QuerySecondValue() const
{
    return _spsleSecond.QueryValue();
}


/*******************************************************************

    NAME:	ELAPSED_TIME_CONTROL::SetMinuteFieldName

    SYNOPSIS:	If the Minute field's value is too big or too small, it
		will display a message as:
			The XXXX field value is invalid
		This function will set the string XXXX in the display
		message.

    ENTRY:	USHORT uIDS - id number of the string in the string
		table

    HISTORY:
	terryk	    30-Aug-91	Created
	beng	    04-Oct-1991 Win32 conversion

********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetMinuteFieldName( MSGID msgid )
{
    _spsleMinute.SetFieldName( msgid );
}


/*******************************************************************

    NAME:	ELAPSED_TIME_CONTROL::SetSecondFieldName

    SYNOPSIS:	If the Second field's value is too big or too small, it
		will display a message as:
			The XXXX field value is invalid
		This function will set the string XXXX in the display
		message.

    ENTRY:	USHORT uIDS - id number of the string in the string
		table

    HISTORY:
	terryk	    30-Aug-91	Created
	beng	    04-Oct-1991 Win32 conversion

********************************************************************/

VOID ELAPSED_TIME_CONTROL::SetSecondFieldName( MSGID msgid )
{
    _spsleSecond.SetFieldName( msgid );
}


/*********************************************************************

    NAME:       DISK_SPACE_SUBCLASS::DISK_SPACE_SUBCLASS

    SYNOPSIS:   Disk space subclass constructor

    ENTRY:      OWNER_WINDOW * powin - owner window pointer
                CID cidSpinButton    - cid for the spin button
                CID cidUpArrow       - cid for the up arrow
                CID cidDownArrow     - cid for the down arrow
                CID cidDiskSpace     - cid for the disk space item
                CID cidUnit          - cid for the Unit item
		LONG nInitDkSp	     - Inital value of the disk space field
		LONG nMinDkSp 	     - Min value of the disk space field
		LONG nRangeDkSp	     - the range of disk space field
		LONG nStartUnit       - the ID of the first string for
				       the unit field
		LONG nUnit 	     - Number of the unit string
		BOOL fActive	     - initial status of the
					DISK_SPACE_SUBCLASS

    HISTORY:
                terryk  20-Jun-1991 Created

*********************************************************************/

DISK_SPACE_SUBCLASS::DISK_SPACE_SUBCLASS( OWNER_WINDOW * powin,
	CID cidSpinButton, CID cidUpArrow, CID cidDownArrow,
	CID cidDiskSpace, CID cidUnit,
	LONG nInitDkSp, LONG nMinDkSp, LONG nRangeDkSp,
	LONG nStartUnit, LONG nUnit,
	BOOL fActive )
    : SPIN_GROUP( powin, cidSpinButton, cidUpArrow, cidDownArrow, fActive),
    _spsleDiskSpace( powin, cidDiskSpace, nInitDkSp, nMinDkSp, nRangeDkSp ),
    _spsleUnit( powin, cidUnit, nStartUnit, nUnit ),
    _nStartUnit( nStartUnit )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }

    APIERR err;

    if ((( err = AddAssociation( & _spsleDiskSpace )) != NERR_Success ) ||
	(( err = AddAssociation( & _spsleUnit )) != NERR_Success ))
    {
	ReportError( err );
	UIASSERT( !SZ("DISK_SPACE_SUBCLASS error: assoication failure.\n"));
	return;
    }
}


/*******************************************************************

    NAME:	DISK_SPACE_SUBCLASS::SetDSFieldName

    SYNOPSIS:	If the disk spaec field's value is too big or too small, it
		will display a message as:
			The XXXX field value is invalid
		This function will set the string XXXX in the display
		message.

    ENTRY:	USHORT uIDS - id number of the string in the string
		table

    HISTORY:
	terryk	    30-Aug-91	Created
	beng	    04-Oct-1991 Win32 conversion

********************************************************************/

VOID DISK_SPACE_SUBCLASS::SetDSFieldName( MSGID msgid )
{
    _spsleDiskSpace.SetFieldName( msgid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltsss.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltsss.cxx
    Spin button edit field - implementation

    SLE object but only accept number and it will live only in
    a spin button.

    FILE HISTORY:
        terryk      01-May-1991 Created
        beng        18-Sep-1991 Pruned UIDEBUGs
        terryk      08-Oct-1991 Change SendMessage Position
        terryk      11-Nov-1991 Change SPIN_ITEM's type from INT to LONG
        terryk      11-Nov-1991 cast QueryRange to LONG
        YiHsinS     15-Dec-1992 Got rid of redundant MessageBeep
*/

#include "pchblt.hxx"  // Precompiled header


const TCHAR * SPIN_SLE_STR::_pszClassName = SZ("EDIT");


/*********************************************************************

    NAME:       SPIN_SLE_STR::SPIN_SLE_STR

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - pointer to owner window
                CID cidEdit - id for the edit field
                CID cidFrame - id for the frame
                LONG idsStart - the IDS number of the first string
                LONG cIDString - the total number of string
                BOOL fWrap - wrap around flag

    NOTES:      It will pass the information to the SLE and SPIN_ITEM
                parent classes.

    HISTORY:
        terryk      01-May-1991     Created
        beng        31-Jul-1991     Control error handling changed

*********************************************************************/

SPIN_SLE_STR::SPIN_SLE_STR( OWNER_WINDOW * powin, CID cidEdit,
                            LONG idsStart, LONG cIDString, BOOL fWrap,
                            CID cidFrame )
    : SLE( powin, cidEdit ),
      CHANGEABLE_SPIN_ITEM( this, 0, 0, cIDString, fWrap ),
      _pbkgndframe( NULL ),
      _anlsStr( NULL )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = Initialize( idsStart, powin, cidFrame );
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}

SPIN_SLE_STR::SPIN_SLE_STR( OWNER_WINDOW * powin, CID cidEdit,
                            LONG idsStart, LONG cIDString,
                            XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit, xy, dxy, flStyle, _pszClassName ),
      CHANGEABLE_SPIN_ITEM( this, 0, 0, cIDString, fWrap ),
      _pbkgndframe( NULL ),
      _anlsStr( NULL )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = Initialize( idsStart, powin, cidFrame );
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}

SPIN_SLE_STR::SPIN_SLE_STR( OWNER_WINDOW * powin, CID cidEdit,
                            const TCHAR *apszString[],
                            LONG cIDString, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit ),
      CHANGEABLE_SPIN_ITEM( this, 0, 0, cIDString, fWrap ),
      _pbkgndframe( NULL ),
      _anlsStr( NULL )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = Initialize( apszString, powin, cidFrame );
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}

SPIN_SLE_STR::SPIN_SLE_STR( OWNER_WINDOW * powin, CID cidEdit,
                            const TCHAR *apszString[],
                            LONG cIDString, XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit, xy, dxy, flStyle, _pszClassName ),
      CHANGEABLE_SPIN_ITEM( this, 0, 0, cIDString, fWrap ),
      _pbkgndframe( NULL ),
      _anlsStr( NULL )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = Initialize( apszString, powin, cidFrame );
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::~SPIN_SLE_STR

    SYNOPSIS:   destructor

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

SPIN_SLE_STR::~SPIN_SLE_STR()
{
    delete _pbkgndframe;
    delete [ QueryRange() ] _anlsStr;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::SetRange

    SYNOPSIS:   you cannot set range again

    ENTRY:      LONG dRange - range

    NOTES:      display UIDEBUG message to warn the  programmer

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID SPIN_SLE_STR::SetRange( const LONG dRange )
{
    UNREFERENCED( dRange );

    DBGEOL( "NETUI2: BLTSSS: does not allow to change range." );
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::Initialize

    SYNOPSIS:   Initialize the internal string

    HISTORY:
        terryk      20-Jun-1991 Created
        beng        05-Oct-1991 Win32 conversion

**********************************************************************/

APIERR SPIN_SLE_STR::Initialize( LONG idsStart,
                                 OWNER_WINDOW * powin,
                                 CID cidFrame )
{
    APIERR err;
    if (cidFrame != -1)
    {
        _pbkgndframe = new BLT_BACKGROUND_EDIT( powin, cidFrame );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pbkgndframe == NULL
            || (err = _pbkgndframe->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "NETUI2: BLTSSS: bkgndframe error " << err );
            return err;
        }
    }

    _anlsStr= new NLS_STR[ QueryRange() ];

    if ( _anlsStr == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for ( LONG i = 0; i < (LONG)QueryRange() ; i++ )
    {
        _anlsStr[ i ].Load((INT)( idsStart + i ));
        if (( err = _anlsStr[ i ].QueryError()) != NERR_Success )
        {
            return err;
        }
    }

    if (( err = SaveCurrentData()) != NERR_Success )
    {
        return err;
    }

    NLS_STR nlsAccKey;

    if (( err = GetAccKey( & nlsAccKey )) != NERR_Success )
    {
        return err;
    }

    return SetAccKey( nlsAccKey );
}

APIERR SPIN_SLE_STR::Initialize( const TCHAR *apszString[],
                                 OWNER_WINDOW * powin,
                                 CID cidFrame )
{
    APIERR err;

    if (cidFrame != -1)
    {
        _pbkgndframe = new BLT_BACKGROUND_EDIT( powin, cidFrame );
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pbkgndframe == NULL
            || (err = _pbkgndframe->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "NETUI2: BLTSSS: bkgndframe error " << err );
            return err;
        }
    }

    _anlsStr= new NLS_STR[ QueryRange() ];

    if ( _anlsStr == NULL )
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    for ( LONG i = 0; i < (LONG)QueryRange() ; i++ )
    {
        _anlsStr[ i ] = apszString[ i ];
        if (( err =  _anlsStr[ i ].QueryError()) != NERR_Success )
        {
            return err;
        }
    }

    if (( err = SaveCurrentData()) != NERR_Success )
    {
        return err;
    }

    NLS_STR nlsAccKey;

    if (( err = GetAccKey( & nlsAccKey )) != NERR_Success )
    {
        return err;
    }

    return SetAccKey( nlsAccKey );
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::OnKeyDown

    SYNOPSIS:   do the action when a key is hit

    ENTRY:      VKEY_EVENT event - contain the key

    RETURN:     TRUE if the routine handles the character
                FALSE otherwise

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL SPIN_SLE_STR::OnKeyDown( const VKEY_EVENT & event )
{
    SPIN_GROUP  * psb = ( SPIN_GROUP * )SPIN_ITEM::QueryGroup();
    switch ( event.QueryVKey() )
    {
    case VK_UP:
    case VK_PRIOR:
        psb->ChangeFieldValue( SPN_INCREASE, event.QueryRepeat() );
        break;

    case VK_DOWN:
    case VK_NEXT:
        psb->ChangeFieldValue( SPN_DECREASE, event.QueryRepeat() );
        break;

    case VK_LEFT:
        psb->JumpPrevField();
        break;

    case VK_RIGHT:
        psb->JumpNextField();
        break;

    case VK_HOME:
        psb->SetFieldMinMax( SPN_MIN );
        break;

    case VK_END:
        psb->SetFieldMinMax( SPN_MAX );
        break;

    default:
        return FALSE;
    }
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::SaveCurrentData

    SYNOPSIS:   save the current window data to the internal variable

    NOTES:      Assume the current value is correct, otherwise,
                the first element is set

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

APIERR SPIN_SLE_STR::SaveCurrentData()
{
    SPIN_GROUP * psg = ( SPIN_GROUP * ) SPIN_ITEM::QueryGroup();

    if ( ( psg != NULL ) && ! psg->IsActive() )
        return NERR_Success;

    NLS_STR nlsValue;

    APIERR err = QueryText( &nlsValue );
    if ( err != NERR_Success )
    {
        return err;
    }

    LONG nValue = QueryStrNum( nlsValue, (LONG)QueryRange());

    if ( nValue < 0 )
        nValue = QueryValue();

    SetValue( nValue );
    Update();
    return err;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::QueryStrNum

    SYNOPSIS:   Find the position of the given string within the array of
                string.

    ENTRY:      NLS_STR & nlsStr - string to look for.
                NLS_STR anlsStr[] - array of string
                LONG cStr - number of string within the array

    RETURN:     The location of the given string within the array of string.
                It will return -1 if the given string is not in the array
                list.

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

LONG SPIN_SLE_STR::QueryStrNum( const NLS_STR & nlsStr, LONG cStr )
{
    for ( LONG i = 0; i < cStr; i++ )
    {
        if ( nlsStr.strcmp( _anlsStr[ i ] ) == 0 )
            return i;
    }
    return -1;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::QueryContent

    SYNOPSIS:   Get the current value in the object

    ENTRY:      You can request the value in one of the following forms:
                NLS_STR *pnlsStr - return as a nls string

    EXIT:       return the value to the data structure

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

APIERR SPIN_SLE_STR::QueryContent( NLS_STR * pnlsStr ) const
{
    UIASSERT( pnlsStr != NULL );
    UIASSERT( pnlsStr->QueryError() == NERR_Success );

    * pnlsStr = _anlsStr[ QueryValue() ];

    return pnlsStr->QueryError();
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::SetStr

    SYNOPSIS:   set the window text to the given number

    ENTRY:      LONG iStringIndex - number to be set

    HISTORY:
        terryk      01-May-1991 Created
        beng        13-Aug-1992 Hide and show caret appropriately

*********************************************************************/

VOID SPIN_SLE_STR::SetStr( LONG iStringIndex )
{
    ::HideCaret(WINDOW::QueryHwnd());
    SetText( _anlsStr[ iStringIndex ] );
    ::ShowCaret(WINDOW::QueryHwnd());
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::Update

    SYNOPSIS:   update the window text

    NOTES:      call SetNum to update the number

    HISTORY:
        terryk      01-May-1991 Created
        beng        16-Oct-1991 Win32 conversion
        beng        13-Aug-1992 Send EN_UPDATE and EN_CHANGE correctly
        beng        16-Aug-1992 Disabled EN_UPDATE

*********************************************************************/

VOID SPIN_SLE_STR::Update()
{
    // CODEWORK: this and SPIN_SLE_NUM::Update should share the
    // below sendmessages.  e.g. embed it in an CHANGEABLE_SPIN_ITEM::Update
    // call and give the class another virtual for the SetStr/SetValue calls.

#if 0 // Nobody listens for this message, anyway
#if defined(WIN32)
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   MAKELONG(QueryCid(), EN_UPDATE), (LPARAM)SLE::QueryHwnd() );
#else
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   QueryCid(), MAKELONG( SLE::QueryHwnd(), EN_UPDATE ) );
#endif
#endif // disabled

    SetStr( QueryValue() );

    // Tell the spin group that we have been changed

    // CODEWORK - roll this into BLT for proper portability.

#if defined(WIN32)
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   MAKELONG(QueryCid(), EN_CHANGE), (LPARAM)SLE::QueryHwnd() );
#else
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   QueryCid(), MAKELONG( SLE::QueryHwnd(), EN_CHANGE ) );
#endif
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::OnChar

    SYNOPSIS:   function to be called if the WM_CHAR message is received.

    ENTRY:      CHAR_EVENT & event

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

BOOL SPIN_SLE_STR::OnChar( const CHAR_EVENT & event )
{
    LONG iString = QueryAccCharPos( event.QueryChar() );

    if ( iString == (-1) )
    {
        // cannot find it
        CHANGEABLE_SPIN_ITEM::OnChar( event );
        return TRUE;
    }
    else
    {
        SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();

        pSB->SetModified( TRUE );
        SetValue( iString );
        Update();
        SLE::SetControlValueFocus();
    }
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::OnFocus

    SYNOPSIS:   select the whole string

    ENTRY:      FOCUS_EVENT & event

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

BOOL SPIN_SLE_STR::OnFocus( const FOCUS_EVENT & event )
{
    UNREFERENCED( event );

#if 0
    SPIN_GROUP * psg = ( SPIN_GROUP * ) SPIN_ITEM::QueryGroup();
    if ( ( psg != NULL ) && ! psg->IsActive() )
        return FALSE;
#endif

    SLE::SetControlValueFocus();
    SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();
    pSB->DoNewFocus((SPIN_ITEM *)this);
    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::GetAccKey

    SYNOPSIS:   get the accelerated key - the first character of
                each string

    ENTRY:      NLS_STR *pnlsStr - the accelerated key list

    EXIT:       NLS_STR *pnlsStr - the accelerated key list

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

APIERR SPIN_SLE_STR::GetAccKey( NLS_STR * pnlsStr )
{
    APIERR apierr = pnlsStr->QueryError();
    if ( apierr != NERR_Success )
    {
        return apierr;
    }

    *pnlsStr = NULL;

    apierr = pnlsStr->QueryError();
    if ( apierr != NERR_Success )
    {
        return apierr;
    }

    for ( LONG i = 0; i < (LONG)QueryRange(); i++ )
    {
        ISTR istrFirstChar( _anlsStr[ i ] );
        ISTR istrEndChar = istrFirstChar;

        ++istrEndChar;

        // CODEWORK: need AppendChar in NLS_STR
        NLS_STR *pnlsFirstChar = _anlsStr[ i ].QuerySubStr( istrFirstChar,
                                                            istrEndChar );
        if ( NULL == pnlsFirstChar ) // JonN 01/23/00 PREFIX bug 444893
        {
            UIASSERT(FALSE);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        apierr = pnlsFirstChar->QueryError();
        if ( apierr != NERR_Success )
        {
            return apierr;
        }

        if ( pnlsFirstChar->QueryTextLength() == 0 )
            pnlsStr->strcat( SZ(" ") );
        else
            pnlsStr->strcat( *pnlsFirstChar );

        apierr = pnlsStr->QueryError();
        if ( apierr != NERR_Success )
        {
            return apierr;
        }
        delete pnlsFirstChar;

    }
    pnlsStr->_strupr();

    return NERR_Success;
}


/*********************************************************************

    NAME:       SPIN_SLE_STR::QueryAccCharPos

    SYNOPSIS:   given a character. return the character position
                in the accelator keys list depended on whether
                the character is an accelerator key or not

    ENTRY:      WCHAR wcInput - character to be tested

    EXIT:       if the given character is one of the accelator key,
                it will return the position. Otherwise, it will return 0.

    HISTORY:
        terryk  29-May-91       Created
        beng    05-Mar-1992     Eliminate wsprintf calls; Unicode fixes

*********************************************************************/

LONG SPIN_SLE_STR::QueryAccCharPos( WCHAR wcInput )
{
    NLS_STR nlsAccKey;

    QueryAccKey( &nlsAccKey );
    ASSERT( !!nlsAccKey );
    ISTR istrAccKey( nlsAccKey );

    // setup a circular search
    INT iResult = (INT)QueryValue();
    INT iOldIndex = iResult;

    // Uppercase search char (this is really awkward)

    WCHAR wcSearch;
    {
        NLS_STR nlsTmp;
        nlsTmp.AppendChar(wcInput);
        nlsTmp._strupr();
        ASSERT(!!nlsTmp);
        ISTR istrTmp(nlsTmp);
        wcSearch = nlsTmp.QueryChar(istrTmp);
    }

    istrAccKey += iResult;

    for (;;)
    {
        if ( (UINT)(iResult + 1) > nlsAccKey.QueryTextLength() )
        {
            iResult = 0;
            istrAccKey.Reset();
        }
        else
        {
            iResult ++;
            ++istrAccKey;
        }
        if ( wcSearch == nlsAccKey.QueryChar( istrAccKey ))
        {
            return iResult;
        }

        if ( iResult == iOldIndex )
        {
            return -1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltssn.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltssn.cxx
        SLE object but only accept number and it will live only in
        a spin button.

    FILE HISTORY:
        terryk      01-May-1991 Created
        beng        18-Sep-1991 prune UIDEBUG clauses
        terryk      07-Oct-1991 Change SendMessage Position
        terryk      11-Nov-1991 change SPIN_ITEM's type from INT to LONG
        terryk      20-Dec-1991 change all the %d to %ld
        beng        05-Mar-1992 Remove all wsprintf usage
        terryk      22-Mar-1992 change LONG to ULONG
*/

#include "pchblt.hxx"  // Precompiled header


const TCHAR * SPIN_SLE_NUM::_pszClassName = SZ("EDIT");


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SPIN_SLE_NUM

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - pointer to owner window
                CID cidEdit - id for the edit field
                CID cidFrame - id for the frame
                ULONG nValue - default value
                ULONG nMin - min value
                ULONG dRange - range
                BOOL fWrap - wrap around boolean flag

    NOTES:      It will pass the information to the SLE and SPIN_ITEM
                parent classes.

    HISTORY:
        terryk      01-May-1991     Created
        beng        31-Jul-1991     Control error reporting changed
        beng        05-Mar-1992     Use DEC_STR

*********************************************************************/

SPIN_SLE_NUM::SPIN_SLE_NUM( OWNER_WINDOW * powin, CID cidEdit, ULONG nValue,
                            ULONG nMin, ULONG dRange, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit ),
      _pbkgndframe( NULL ),
      CHANGEABLE_SPIN_ITEM( this, nValue, nMin, dRange, fWrap)
{
    if ( QueryError() != NERR_Success )
        return;

    if ( cidFrame != -1 )
    {
        _pbkgndframe = new BLT_BACKGROUND_EDIT( powin, cidFrame );
        APIERR frameerr = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pbkgndframe == NULL
            || (frameerr = _pbkgndframe->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "NETUI2: BLTSSN: bkgndframe error " << frameerr );
            ReportError( frameerr );
            return;
        }
    }

    DEC_STR nlsValue(nValue);
    APIERR err = nlsValue.QueryError();
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    SetText( nlsValue );
    SetMaxInput();

    err = SaveCurrentData();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    Update();
}

SPIN_SLE_NUM::SPIN_SLE_NUM( OWNER_WINDOW * powin, CID cidEdit,
                            XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle, ULONG nValue,
                            ULONG nMin, ULONG dRange, BOOL fWrap, CID cidFrame )
    : SLE( powin, cidEdit, xy, dxy, flStyle, _pszClassName ),
      _pbkgndframe( NULL ),
      CHANGEABLE_SPIN_ITEM( this, nValue, nMin, dRange, fWrap )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( cidFrame != -1 )
    {
        _pbkgndframe = new BLT_BACKGROUND_EDIT( powin, cidFrame );
        APIERR frameerr = ERROR_NOT_ENOUGH_MEMORY;
        if (   _pbkgndframe == NULL
            || (frameerr = _pbkgndframe->QueryError()) != NERR_Success
           )
        {
            DBGEOL( "NETUI2: BLTSSN: bkgndframe error " << frameerr );
            ReportError( frameerr );
            return;
        }
    }

    DEC_STR nlsValue(nValue);
    APIERR err = nlsValue.QueryError();
    if (err != NERR_Success)
    {
        ReportError(err);
        return;
    }

    SetText( nlsValue );
    SetMaxInput();

    err = SaveCurrentData();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    Update();
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::~SPIN_SLE_NUM

    SYNOPSIS:   destructor

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

SPIN_SLE_NUM::~SPIN_SLE_NUM()
{
      delete _pbkgndframe;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SetMaxInput

    SYNOPSIS:   get the max number and find out how many character in it

    HISTORY:
        terryk  10-Jul-1991 Created
        beng    05-Mar=1992 Replaced wsprintf

*********************************************************************/

VOID SPIN_SLE_NUM::SetMaxInput()
{
    DEC_STR nlsMaxVal(QueryMax());
    ASSERT(!!nlsMaxVal);

    SetMaxLength( _cchMaxInput = nlsMaxVal.QueryTextLength() );
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SetMin

    SYNOPSIS:   whenever we set min, we need to recompute the max length

    ENTRY:      ULONG nMin - min number

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID SPIN_SLE_NUM::SetMin( const ULONG nMin )
{
    CHANGEABLE_SPIN_ITEM::SetMin( nMin );
    SetMaxInput();
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SetRange

    SYNOPSIS:   whenever we set the range, we need to recompute the
                max length

    ENTRY:      ULONG dRange - range

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

VOID SPIN_SLE_NUM::SetRange( const ULONG dRange )
{
    CHANGEABLE_SPIN_ITEM::SetRange( dRange );
    SetMaxInput();
}

/*********************************************************************

    NAME:       SPIN_SLE_NUM::SetSaveValue

    SYNOPSIS:

    ENTRY:

    HISTORY:

*********************************************************************/

APIERR SPIN_SLE_NUM::SetSaveValue( const ULONG nValue )
{
    SetValue( nValue );

    APIERR err;
    DEC_STR nlsFormatted(nValue, (SLE::QueryStyle() & SPIN_SSN_ADD_ZERO)
                                 ? _cchMaxInput : 1 );

    if ( (err = nlsFormatted.QueryError()) == NERR_Success )
    {
        err = SLE::SetSaveValue( nlsFormatted );
    }

    return err;

}

/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnKeyDown

    SYNOPSIS:   When the user hit a key, perform the proper action

    ENTRY:      VKEY_EVENT event - the WM_MESSAGE

    RETURN:     TRUE if the routine handle the character.
                FALSE otherwise

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnKeyDown( const VKEY_EVENT & event )
{
    SPIN_GROUP  * psb = ( SPIN_GROUP * )SPIN_ITEM::QueryGroup();
    switch ( event.QueryVKey() )
    {
    case VK_UP:
        psb->ChangeFieldValue( SPN_INCREASE, event.QueryRepeat() );
        break;

    case VK_DOWN:
        psb->ChangeFieldValue( SPN_DECREASE, event.QueryRepeat() );
        break;

    case VK_PRIOR:
        psb->ChangeFieldValue( SPN_BIGINCREASE, event.QueryRepeat() );
        break;

    case VK_NEXT:
        psb->ChangeFieldValue( SPN_BIGDECREASE, event.QueryRepeat() );
        break;

    case VK_LEFT:
        psb->JumpPrevField();
        break;

    case VK_RIGHT:
        psb->JumpNextField();
        break;

    case VK_HOME:
        psb->SetFieldMinMax( SPN_MIN );
        break;

    case VK_END:
        psb->SetFieldMinMax( SPN_MAX );
        break;

    default:
        return FALSE;
    }
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::SaveCurrentData

    SYNOPSIS:   get the current data from the window and set the
                internal variable value

    NOTES:      Assume the data in the window is corrected, save the
                current data

    HISTORY:
                terryk  29-May-91   Created

*********************************************************************/

APIERR SPIN_SLE_NUM::SaveCurrentData()
{
    SPIN_GROUP * psg = (SPIN_GROUP *) SPIN_ITEM::QueryGroup();

    if ( ( psg != NULL ) && ! psg->IsActive() )
        return NERR_Success;

    NLS_STR nlsValue;

    APIERR err = QueryText( &nlsValue );

    if ( err != NERR_Success )
    {
        CONTROL_WINDOW::ReportError( err );
        return err;
    }

    ULONG nValue;

    if ( nlsValue.strlen() == 0 )
        nValue = QueryValue();
    else
        nValue = nlsValue.atoul();

    INT nCheckRange = CheckRange( nValue );

    nValue = ( nCheckRange < 0 ) ? QueryMin() :
             ( nCheckRange > 0 ) ? QueryMax() : nValue;

    SetValue( nValue );
    Update();
    return err;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::QueryContent

    SYNOPSIS:   Get the current value in the object

    ENTRY:      You can request the value in one of the following forms:
                ULONG * nValue - integer
                NLS_STR *nlsStr - return as a nls string

    EXIT:       return the value to the data structure

    HISTORY:
        terryk  01-May-1991 Created
        beng    05-mar-1992 Replace wsprintf

*********************************************************************/

VOID SPIN_SLE_NUM::QueryContent( ULONG * pnValue ) const
{
    UIASSERT( pnValue != NULL );

    *pnValue = QueryValue() ;
}

VOID SPIN_SLE_NUM::QueryContent( NLS_STR * pnlsStr ) const
{
    ASSERT( pnlsStr != NULL );
    ASSERT( pnlsStr->QueryError() == NERR_Success );

    DEC_STR nlsValue(QueryValue());
    ASSERT(!!nlsValue);

    *pnlsStr = nlsValue;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::DisplayNum

    SYNOPSIS:   set the window text to the given number

    ENTRY:      ULONG nNum - number to be set

    HISTORY:
        terryk      01-May-1991 Created
        beng        16-Oct-1991 Win32 conversion
        beng        05-Mar-1992 Use DEC_STR for formatting
        beng        13-Aug-1992 Hide and show caret appropriately

*********************************************************************/

VOID SPIN_SLE_NUM::DisplayNum( ULONG nValue )
{
    DEC_STR nlsFormatted(nValue, (SLE::QueryStyle() & SPIN_SSN_ADD_ZERO)
                                 ? _cchMaxInput : 1 );
    if (!nlsFormatted) return; // JonN 01/23/00 PREFIX bug 444894

    ::HideCaret(WINDOW::QueryHwnd());
    SetText(nlsFormatted);
    ::ShowCaret(WINDOW::QueryHwnd());
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::Update

    SYNOPSIS:   update the window text

    NOTES:      call DisplayNum to update the number

    HISTORY:
        terryk      01-May-1991 Created
        beng        16-Oct-1991 Win32 conversion
        beng        13-Aug-1992 Send EN_UPDATE and EN_CHANGE correctly
        beng        16-Aug-1992 Disabled EN_UPDATE

*********************************************************************/

VOID SPIN_SLE_NUM::Update()
{
    // CODEWORK: should share code with SPIN_SLE_STR::Update (qv).

#if 0 // Nobody listens for this message, anyway
#if defined(WIN32)
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   MAKELONG(QueryCid(), EN_UPDATE), (LPARAM)SLE::QueryHwnd() );
#else
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   QueryCid(), MAKELONG( SLE::QueryHwnd(), EN_UPDATE ) );
#endif
#endif // disabled

    DisplayNum( QueryValue() );

    // Tell the spin group that we are changed

    // CODEWORK - roll this into BLT for proper portability.

#if defined(WIN32)
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   MAKELONG(QueryCid(), EN_CHANGE), (LPARAM)SLE::QueryHwnd() );
#else
    ::SendMessage( QueryOwnerHwnd(), WM_COMMAND,
                   QueryCid(), MAKELONG( SLE::QueryHwnd(), EN_CHANGE ) );
#endif
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnChar

    SYNOPSIS:   The object only accept backspace key and numerical input.
                Other input is sent to the parent - SPIN_GROUP

    ENTRY:      CHAR_EVENT event - character event

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnChar( const CHAR_EVENT & event )
{
    SPIN_GROUP  * pSB = (SPIN_GROUP *)SPIN_ITEM::QueryGroup();

    // check for backspace
    if (event.QueryChar() == VK_BACK )
    {
        pSB->SetModified( TRUE );
        // return FALSE and let the window handle it
        // pretend I do nothing
        return FALSE;
    }
    if (IsCharAlphaNumeric( event.QueryChar() ) &&
        !IsCharAlpha( event.QueryChar()))
    {
        pSB->SetModified( TRUE );
        // return FALSE and let the window handle it
        // pretend I do nothing
        return FALSE;
    }
    if ( QueryAccCharPos( event.QueryChar() ) >= 0 )
    {
        SLE::SetControlValueFocus();
        return TRUE;
    }
    else
    {
        // I don't want this character
        pSB->DoChar( (CHAR_EVENT &)event );
        return TRUE;
    }
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnEnter

    SYNOPSIS:   check for valid when the user hits ENTER

    ENTRY:      CONTROL_EVENT & event

    HISTORY:
                terryk  6-Jun-91    Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnEnter( const CONTROL_EVENT & event )
{
    UNREFERENCED( event );

    SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();

    pSB->SetModified( TRUE );
    SaveCurrentData();
    Update();
    return TRUE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnDefocus

    SYNOPSIS:   if the object is defocused, save the current data.

    ENTRY:      FOCUS_EVENT & event

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnDefocus( const FOCUS_EVENT &event )
{
    UNREFERENCED( event );

    SaveCurrentData();
    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM::OnFocus

    SYNOPSIS:   if the object is focused, highlight the string in the window

    ENTRY:      FOCUS_EVENT & fEvent

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

BOOL SPIN_SLE_NUM::OnFocus( const FOCUS_EVENT &event )
{
    UNREFERENCED( event );

#if 0
    SPIN_GROUP * psg = ( SPIN_GROUP * ) SPIN_ITEM::QueryGroup();
    if ( ( psg != NULL ) && ! psg->IsActive() )
        return FALSE;
#endif

    SLE::SetControlValueFocus();
    SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();
    pSB->DoNewFocus( (SPIN_ITEM *)this );
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltssnv.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltssnv.cxx

    SLE object but only accept number and it will live only in
    a spin button. It will also check for valid when the object lose
    focus.

    FILE HISTORY:
        terryk      27-Jun-91   Created
        beng        18-Sep-1991 pruned UIDEBUG clauses
        terryk      29-Sep-1991 Does not display the message on error
        terryk      11-Nov-1991 Change SPIN_ITEM's type from INT to LONG
        terryk      20-Dec-1991 Change all the %d to %ld
        terryk      22-Mar-1992 Converted LONG to ULONG
*/

#include "pchblt.hxx"  // Precompiled header


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::SPIN_SLE_NUM_VALID

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW * powin - pointer to owner window
                CID cid - id for the object

    NOTES:      It will pass the information to the SLE and SPIN_ITEM
                parent classes.

    HISTORY:
        terryk      01-May-1991     Created
        beng        31-Jul-1991     Control error preorting changed

*********************************************************************/

SPIN_SLE_NUM_VALID::SPIN_SLE_NUM_VALID( OWNER_WINDOW * powin, CID cid,
                                        ULONG nValue, ULONG nMin, ULONG nRange,
                                        BOOL fWrap )
    : SPIN_SLE_NUM( powin, cid, nValue, nMin, nRange, fWrap ),
    _nlsFieldName()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsFieldName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}

SPIN_SLE_NUM_VALID::SPIN_SLE_NUM_VALID( OWNER_WINDOW * powin, CID cid,
                            XYPOINT xy, XYDIMENSION dxy,
                            ULONG flStyle, ULONG nValue, ULONG nMin, ULONG nRange,
                            BOOL fWrap )
    : SPIN_SLE_NUM( powin, cid, xy, dxy, flStyle, nValue, nMin, nRange, fWrap ),
    _nlsFieldName()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsFieldName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
    }
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::~SPIN_SLE_NUM_VALID

    SYNOPSIS:   destructor

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

SPIN_SLE_NUM_VALID::~SPIN_SLE_NUM_VALID()
{
    // do nothing
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::CheckValid

    SYNOPSIS:   check whether the field is valid or not. If not,
                then display an error message.

    RETURN:     BOOL - TRUE if valid. FALSE otherwise

    HISTORY:
                terryk  10-Jul-1991 Created

*********************************************************************/

BOOL SPIN_SLE_NUM_VALID::CheckValid()
{
    BOOL fValid = IsValid();

    if ( ! fValid )
    {
        //DisplayErrorMsg();
    }
    return fValid;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::IsValid

    SYNOPSIS:   handle the special requirement for SPIN_SLE_NUM_VALID

    ENTRY:      HWND hWnd - window handler
                WORD message - message
                WPARAM wParam - word parameter
                LPARAM lParam - LONG paramter

    NOTES:      It is a call back function

    HISTORY:
                terryk  01-May-1991 Created

*********************************************************************/

BOOL SPIN_SLE_NUM_VALID::IsValid( )
{
    NLS_STR nlsValue;

    if ( QueryText( & nlsValue ) != NERR_Success )
    {
        return FALSE;
    }

    ULONG nValue;

    if (nlsValue.strlen() != 0 )
    {
        nValue = nlsValue.atoul();
    }
    else
    {
        nValue = QueryValue();
    }

    INT nCheckRange = CheckRange( nValue );
    if ( nCheckRange == 0 )
    {
        return TRUE;
    }
    // fix the data
    nValue = ( nCheckRange < 0 ) ? QueryMin() : QueryMax();
    SetValue( nValue );
    Update();

    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::DisplayErrorMsg

    SYNOPSIS:   display an error message if the field is not valid

    NOTES:
        Does anybody call this?  Can I nuke it?

    HISTORY:
        terryk  10-Jul-1991 Created
        beng    05-Mar-1992 Removed wsprintfs

*********************************************************************/

VOID SPIN_SLE_NUM_VALID::DisplayErrorMsg()
{
    // CODEWORK - what does this do upon failure?  what will it display?

    NLS_STR * apnlsInsert[3] ;
    NLS_STR nlsFieldName;

    if ( _nlsFieldName.strlen() == 0 )
    {
        nlsFieldName.Load( IDS_FIELD );
    }
    else
    {
        nlsFieldName = _nlsFieldName;
    }

    ASSERT(!!nlsFieldName);

    apnlsInsert[0] = &nlsFieldName ;

    DEC_STR nlsMin(QueryMin());
    DEC_STR nlsMax(QueryMax());

    ASSERT(!!nlsMin);
    ASSERT(!!nlsMax);

    apnlsInsert[1] = &nlsMin ;
    apnlsInsert[2] = &nlsMax ;

    ::MessageBeep( 0 );

    MsgPopup( QueryOwnerHwnd(), IDS_BLT_SB_SLENUM_OUTRANGE, MPSEV_INFO, 0,
              MP_OK, apnlsInsert );
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::OnEnter

    SYNOPSIS:   check for valid when the user hits ENTER

    ENTRY:      CONTROL_EVENT & event

    HISTORY:
                terryk  6-Jun-91    Created

*********************************************************************/

BOOL SPIN_SLE_NUM_VALID::OnEnter( const CONTROL_EVENT & event )
{
    UNREFERENCED( event );
    SPIN_GROUP  *pSB=(SPIN_GROUP *)SPIN_ITEM::QueryGroup();

    pSB->SetModified( TRUE );
    if ( CheckValid() != FALSE )
    {
        SaveCurrentData();
    }
    Update();
    return TRUE;
}


BOOL SPIN_SLE_NUM_VALID::OnDefocus( const FOCUS_EVENT & event )
{
    UNREFERENCED( event );

    if ( CheckValid() != FALSE )
    {
        SaveCurrentData();
    }
    return FALSE;
}


/*********************************************************************

    NAME:       SPIN_SLE_NUM_VALID::SetFieldName

    SYNOPSIS:   set the field name of the item

    ENTRY:      msgid - string table id

    RETURN:     APIERR err - load string error

    HISTORY:
        terryk      10-Jul-1991 Created
        beng        04-Oct-1991 Win32 conversion

*********************************************************************/

APIERR SPIN_SLE_NUM_VALID::SetFieldName( MSGID msgid )
{
    return _nlsFieldName.Load( msgid );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\blttd.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    blttd.cxx
    BLT time/date control object

    FILE HISTORY:
        terryk      01-Jun-91   Created
        terryk      11-Jul-91   Make it to a group
        terryk      12-Aug-91   Create its own timer and change the spacing
        terryk      29-Aug-91   Code review changes
        terryk      11-Nov-91   Change SPIN_ITEM's return type from INT to LONG
        terryk      26-Nov-91   Added Update to the AMPM field
        terryk      17-Apr-92   changed LONG to ULONG
        beng        13-Aug-1992 Disabled unused TIME_DATE_DIALOG
        YiHsinS	    15-Dec-1992 Use SelectFont and call QueryTextWidth only
				if the string is non-empty
*/

#include "pchblt.hxx"  // Precompiled header


#if defined(DEBUG) && 0
static DBGSTREAM & operator<< (DBGSTREAM & dbg, const XYPOINT & xy)
{
    dbg << "(x = " << xy.QueryX()
        << ", y = " << xy.QueryY()
        << ")";
    return dbg;
}

static DBGSTREAM & operator<< ( DBGSTREAM & dbg, const XYDIMENSION & dxy)
{
    dbg << "(dx = " << dxy.QueryWidth()
        << ", dy = " << dxy.QueryHeight()
        << ")";
    return dbg;
}
#endif // DEBUG


/*
 * CalcMaxDigitWidth
 * Determine the width of the widest digit, taking proportional fonts
 * into account.
 *
 * HISTORY
 *      beng     13-Aug-1992 Written (design stolen from control panel)
 */

static INT CalcMaxDigitWidth( const DEVICE_CONTEXT & dc )
{
    INT adxDigit[10];

    ASSERT( ('9' - '0' + 1) == (sizeof(adxDigit)/sizeof(adxDigit[0])) );

    if (! ::GetCharWidth(dc.QueryHdc(), (UINT)'0', (UINT)'9', adxDigit) )
    {
        DBGEOL("BLT: GetCharWidth failed, very bad");

        // Make a last desperate try

        TEXTMETRIC tm;
        REQUIRE( dc.QueryTextMetrics(&tm) );
        return tm.tmMaxCharWidth;
    }

    INT * pdxDigit;
    INT   dxMax;
    for (pdxDigit = adxDigit+1, dxMax = adxDigit[0];
         pdxDigit < adxDigit+10;
         pdxDigit++)
    {
        if (*pdxDigit > dxMax)
            dxMax = *pdxDigit;
    }

    return dxMax;
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::BLT_TIME_SPIN_GROUP

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *powin - owner window
                CID cidTimeControl - the group box for the time control
                CID cidSpinButton - the spin button control
                CID cidUpArrow - up arrow object
                CID cidDownArrow - down arrow object
                CID cidHour - hour object
                CID cidSeparator1 - separator object 1
                CID cidMin - minute object
                CID cidSeparator2 - the second separator
                CID cidSec - second object
                CID cidAMPM - AM/PM indicator
    NOTES:

    HISTORY:
        terryk       1-Jun-91   Created
        beng        31-Jul-1991 Control error reporting changed
        beng        13-Aug-1992 Change size calculations

*********************************************************************/

BLT_TIME_SPIN_GROUP::BLT_TIME_SPIN_GROUP( OWNER_WINDOW *powin,
                                          const INTL_PROFILE &intlprof,
                                          CID cidSpinButton,
                                          CID cidUpArrow,
                                          CID cidDownArrow,
                                          CID cidHour,
                                          CID cidTimeSep1,
                                          CID cidMin,
                                          CID cidTimeSep2,
                                          CID cidSec,
                                          CID cidAMPM,
                                          CID cidFrame )
    : CONTROL_GROUP(),
    _sbControl( powin, cidSpinButton, cidUpArrow, cidDownArrow, TRUE ),
    _ssnHour( powin, cidHour, 0, 0, 24 ),
    _ssltSeparator1( powin, cidTimeSep1),
    _ssnMin( powin, cidMin, 0, 0, 60 ),
    _ssltSeparator2( powin, cidTimeSep2 ),
    _ssnSec( powin, cidSec, 0, 0, 60 ),
    _psssAMPM( NULL ),
    _bkgndFrame( powin, cidFrame ),
    _f24Hour( FALSE )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    NLS_STR nlsAM;
    NLS_STR nlsPM;
    NLS_STR nlsTimeSep;
    APIERR err;

    if ((( err = _sbControl.QueryError()) != NERR_Success ) ||
        (( err = _ssnHour.QueryError()) != NERR_Success ) ||
        (( err = _ssltSeparator1.QueryError()) != NERR_Success ) ||
        (( err = _ssnMin.QueryError()) != NERR_Success ) ||
        (( err = _ssltSeparator2.QueryError()) != NERR_Success ) ||
        (( err = _ssnSec.QueryError()) != NERR_Success ) ||
        (( err = _bkgndFrame.QueryError()) != NERR_Success ) ||
        (( err = intlprof.QueryAMStr( & nlsAM )) != NERR_Success ) ||
        (( err = intlprof.QueryPMStr( & nlsPM )) != NERR_Success ) ||
        (( err = intlprof.QueryTimeSeparator( & nlsTimeSep )) != NERR_Success ))
    {
        ReportError( err );
        return;
    }

    _f24Hour = intlprof.Is24Hour();

    BOOL	_fTimePrefix = intlprof.IsTimePrefix(); // DBCS only

    // Find out the location of the controls

    DISPLAY_CONTEXT dc( powin->QueryHwnd() );
    dc.SelectFont( _ssnHour.QueryFont() );

    INT dAMPM = 0;

    if ( !_f24Hour )
    {
        INT dxAM = 0;
        INT dxPM = 0;

        if ( nlsAM.QueryTextLength() > 0 )
            dxAM = dc.QueryTextWidth(nlsAM);

        if ( nlsPM.QueryTextLength() > 0 )
            dxPM = dc.QueryTextWidth(nlsPM);

        dAMPM = ((dxAM > dxPM) ? dxAM : dxPM);
    }

    INT dxDigitMax = CalcMaxDigitWidth(dc);
    dxDigitMax += 1; // FE_SB looks nice...
    INT dyLine  = dc.QueryFontHeight();

    // distance for 2 numbers
    INT dTwoNum = 2 * dxDigitMax;

    // distance to use to right of fields
    INT dxRightFudge = dxDigitMax/4;

    // distance to use from the left of fields
    INT dxLeftFudge = dxDigitMax/8;

    // distance for the separator
    INT dTimeSep = dc.QueryTextWidth(nlsTimeSep);

    // spin button control location
    XYPOINT xyTime      = _sbControl.QueryPos();
    xyTime.SetX( xyTime.QueryX() - dxRightFudge);
    XYDIMENSION dxyTime = _sbControl.QuerySize();

    // AMPM location
    if( !NETUI_IsDBCS() || !_fTimePrefix )	xyTime.SetX( xyTime.QueryX() - dAMPM );
    if ( dxyTime.QueryHeight() > (UINT) dyLine )
    {
        xyTime.SetY( xyTime.QueryY()
                     + ( (dxyTime.QueryHeight() / 2) - (dyLine / 2) ));
        dxyTime.SetHeight( dyLine );
    }
    dxyTime.SetWidth( dAMPM );
    XYPOINT xyAMPM( xyTime.QueryX(), xyTime.QueryY() );
    XYDIMENSION dxyAMPM = dxyTime;

    // Second location
    if( NETUI_IsDBCS() && _fTimePrefix )
        xyTime.SetX( xyTime.QueryX() - dTwoNum );
     else
        xyTime.SetX( xyTime.QueryX() - dTwoNum - dxRightFudge );
    dxyTime.SetWidth( dTwoNum );
    XYPOINT xySec( xyTime.QueryX() + dxLeftFudge, xyTime.QueryY() );
    XYDIMENSION dxySec = dxyTime;

    // Separator location
    xyTime.SetX( xyTime.QueryX() - dTimeSep );
    dxyTime.SetWidth( dTimeSep + dxLeftFudge );
    XYPOINT xySep2 = xyTime;
    XYDIMENSION dxySep2 = dxyTime;

    // Minute location
    xyTime.SetX( xyTime.QueryX() - dTwoNum - dxRightFudge );
    dxyTime.SetWidth( dTwoNum );
    XYPOINT xyMin( xyTime.QueryX() + dxLeftFudge, xyTime.QueryY() );
    XYDIMENSION dxyMin = dxyTime;

    // Separator 1 location
    xyTime.SetX( xyTime.QueryX() - dTimeSep );
    dxyTime.SetWidth( dTimeSep + dxLeftFudge );
    XYPOINT xySep1 = xyTime;
    XYDIMENSION dxySep1 = dxyTime;

    // Hour location
    xyTime.SetX( xyTime.QueryX() - dTwoNum - dxRightFudge );
    dxyTime.SetWidth( dTwoNum );
    XYPOINT xyHour( xyTime.QueryX() + dxLeftFudge, xyTime.QueryY() );
    XYDIMENSION dxyHour = dxyTime;

    if( NETUI_IsDBCS() && _fTimePrefix )
    {
        xyTime.SetX( xyTime.QueryX() - dAMPM - dxRightFudge );
        xyAMPM.SetX( xyTime.QueryX() + dxLeftFudge );
    }

    // construction of the object

    // NOTE that when checking each of these included objects' construction
    // status, if it has an error state visible to us then it has already
    // forwarded its error state into us.  Hence we need only return.

    if (intlprof.IsHourLZero())
        _ssnHour.SetStyle( _ssnHour.QueryStyle() | SPIN_SSN_ADD_ZERO );
    _ssnHour.SetPos( xyHour );
    _ssnHour.SetSize( dxyHour);

    // iTime: 0 - 12 hours time
    //        1 - 24 hours time
    if ( _f24Hour )
    {
        _ssnHour.SetMin( 0 );
        _ssnHour.SetRange( 24 );
    }
    else
    {
        _ssnHour.SetMin( 1 );
        _ssnHour.SetRange( 12 );
    }

    _ssnHour.SetValue( 12 ); // since we init as 2 digits, and I don't
                             // want it to change alignment visibly

    _ssltSeparator1.SetText( nlsTimeSep.QueryPch());
    _ssltSeparator1.SetPos( xySep1 );
    _ssltSeparator1.SetSize( dxySep1 );

    _ssnMin.SetStyle( _ssnMin.QueryStyle() | SPIN_SSN_ADD_ZERO );
    _ssnMin.SetPos( xyMin );
    _ssnMin.SetSize( dxyMin );

    _ssltSeparator2.SetText( nlsTimeSep.QueryPch());
    _ssltSeparator2.SetPos( xySep2 );
    _ssltSeparator2.SetSize( dxySep2 );

    _ssnSec.SetStyle( _ssnSec.QueryStyle() | SPIN_SSN_ADD_ZERO );
    _ssnSec.SetPos( xySec );
    _ssnSec.SetSize( dxySec );

    // Show the objects
    _ssnHour.Show();
    _ssltSeparator1.Show();
    _ssnMin.Show();
    _ssltSeparator2.Show();
    _ssnSec.Show();

    _sbControl.SetGroup( this );

    // Associate the objects
    if ((( err = _sbControl.AddAssociation( &_ssnHour )) != NERR_Success) ||
        (( err = _sbControl.AddAssociation( &_ssltSeparator1 )) != NERR_Success ) ||
        (( err = _sbControl.AddAssociation( &_ssnMin )) != NERR_Success) ||
        (( err = _sbControl.AddAssociation( &_ssltSeparator2 )) != NERR_Success ) ||
        (( err = _sbControl.AddAssociation( &_ssnSec )) != NERR_Success))
    {
        ReportError( err );
        DBGEOL("BLT_TIME_SPIN_GROUP: construction failure.");
        return;
    }

    // do we need the AMPM field?
    if ( !_f24Hour )
    {
        // Yes!
        const TCHAR *apszAMPMtemp[3];
        apszAMPMtemp[0] = nlsAM.QueryPch();
        apszAMPMtemp[1] = nlsPM.QueryPch();
        apszAMPMtemp[2] = NULL;

        _psssAMPM = new SPIN_SLE_STR ( powin, cidAMPM, apszAMPMtemp, 2 );

        if ( IsConstructionFail( _psssAMPM ))
        {
            return;
        }

        _psssAMPM->SetPos( xyAMPM, FALSE, &_ssnSec );
        _psssAMPM->SetSize( dxyAMPM, FALSE );
        _psssAMPM->SetBigIncValue( 1 );
        _psssAMPM->SetBigDecValue( 1 );
        _psssAMPM->Enable();
        _psssAMPM->ShowFirst();

        if (( err = _sbControl.AddAssociation( _psssAMPM )) != NERR_Success )
        {
            ReportError( err );
            return;
        }
    }


    // Set the field name
    if ((( err = _ssnHour.SetFieldName( IDS_HOUR )) != NERR_Success ) ||
        (( err = _ssnMin.SetFieldName( IDS_MIN )) != NERR_Success ) ||
        (( err = _ssnSec.SetFieldName( IDS_SEC )) != NERR_Success ))
    {
        ReportError( err );
        DBGEOL("BLT_TIME_SPIN_GROUP: construction failure.");
        return;
    }
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::~BLT_TIME_SPIN_GROUP

    SYNOPSIS:   destructor

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

BLT_TIME_SPIN_GROUP::~BLT_TIME_SPIN_GROUP()
{
    delete _psssAMPM;
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::IsConstructionFail

    SYNOPSIS:   check whether the contrustion of the control is succeed
                or not. If not, then ReportError and UIASSERT.

    ENTRY:      CONTROL_WINDOW * pwin - control window to be test

    RETURNS:    BOOL. TRUE for failure and FALSE for succeed

    HISTORY:
        terryk      29-Aug-91   Created
        beng        13-Aug-1992 Copy from BLT_DATE_SPIN_GROUP

********************************************************************/

BOOL BLT_TIME_SPIN_GROUP::IsConstructionFail( CONTROL_WINDOW * pwin)
{
    APIERR err = (pwin == NULL)
                 ? ERROR_NOT_ENOUGH_MEMORY
                 : pwin->QueryError();

    if (err != NERR_Success)
    {
        ReportError( err );
        DBGEOL("BLT_TIME_SPIN_GROUP: construction failed.");
        return TRUE;
    }

    return FALSE;
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SaveValue

    SYNOPSIS:   Save the current value in the Hour, Min, Sec fields

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SaveValue( BOOL fInvisible )
{
    _sbControl.SaveValue( fInvisible );
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::RestoreValue

    SYNOPSIS:   Restore the current value in the Hour, Min, Sec fields

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::RestoreValue( BOOL fInvisible )
{
    _sbControl.RestoreValue( fInvisible );
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetControlValueFocus

    SYNOPSIS:   Set the current focus

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SetControlValueFocus()
{
    _sbControl.SetControlValueFocus();
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::IsValid

    SYNOPSIS:   check whether the data in the spin button is valid or not

    RETURN:     TRUE if the data is valid. FALSE otherwise

    NOTES:      Since the SPIN_SLE_NUM type will check the input,
                we can ensure that the data is always correct

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

BOOL BLT_TIME_SPIN_GROUP::IsValid()
{
    return TRUE;
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetCurrentTime

    SYNOPSIS:   update the data within the spin button to set it to
                the current time

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

APIERR BLT_TIME_SPIN_GROUP::SetCurrentTime()
{
    WIN_TIME winTime;
    APIERR err;
    if (  ((err = winTime.QueryError()) == NERR_Success )
       && ((err = winTime.SetCurrentTime()) == NERR_Success )
       )
    {
        SetHour( winTime.QueryHour());
        SetMinute( winTime.QueryMinute());
        SetSecond( winTime.QuerySecond());
        SetControlValueFocus();
    }

    return err;
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::QueryHour

    SYNOPSIS:   return the current hour in 24 hour format

    RETURN:     return the hour

    HISTORY:
                terryk  13-Jul-91   Created

*********************************************************************/

INT BLT_TIME_SPIN_GROUP::QueryHour() const
{
    if ( _f24Hour )
    {
        // 24 hour
        return (INT)_ssnHour.QueryValue();
    }

    return (INT)( _ssnHour.QueryValue() % 12 + _psssAMPM->QueryValue() * 12);
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::QueryMin

    SYNOPSIS:   return the minute value

    RETURN:     return the minute value

    HISTORY:
                terryk  13-Jul-91   Created

*********************************************************************/

INT BLT_TIME_SPIN_GROUP::QueryMin() const
{
    return (INT)_ssnMin.QueryValue();
}


/*********************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::QuerySec

    SYNOPSIS:   return the second value

    RETURN:     return the second value

    HISTORY:
                terryk  13-Jul-91   Created

*********************************************************************/

INT BLT_TIME_SPIN_GROUP::QuerySec() const
{
    return (INT)_ssnSec.QueryValue();
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetHour

    SYNOPSIS:   set the hour field value

    ENTRY:      the new hour value

    HISTORY:
        terryk      29-Aug-91   Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SetHour( INT nHour )
{
    UIASSERT(( nHour > -1 ) && ( nHour < 25 ));

    if ( _f24Hour )
    {
        _ssnHour.SetValue( nHour );
    }
    else
    {
        _psssAMPM->SetValue((( nHour < 12 ) || ( nHour == 24 ))? 0 : 1 );
        _psssAMPM->Update();

        nHour = nHour % 12;
        nHour = ( nHour == 0 ) ? 12 : nHour ;
        _ssnHour.SetValue( nHour );
    }
    _ssnHour.Update();
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetMinute

    SYNOPSIS:   set the minute field value

    ENTRY:      the new minute value

    HISTORY:
                terryk  29-Aug-91       Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SetMinute( INT nMinute )
{
    UIASSERT(( nMinute > -1 ) && ( nMinute < 61 ));
    _ssnMin.SetValue( nMinute );
    _ssnMin.Update();
}


/*******************************************************************

    NAME:       BLT_TIME_SPIN_GROUP::SetSecond

    SYNOPSIS:   set the second field value

    ENTRY:      the new second value

    HISTORY:
                terryk  29-Aug-91       Created

********************************************************************/

VOID BLT_TIME_SPIN_GROUP::SetSecond( INT nSecond )
{
    UIASSERT(( nSecond > -1 ) && ( nSecond < 61 ));
    _ssnSec.SetValue( nSecond );
    _ssnSec.Update();
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::BLT_DATE_SPIN_GROUP

    SYNOPSIS:   constructor

    NOTES:      Same as BLT_TIME_SPIN_GROUP, we have 2 types of contrustor.
                One for dialog box and the other one for the app window.

    HISTORY:
        terryk      1-Jun-91    Created
        beng        13-Aug-1992 Min year now 1980

*********************************************************************/

BLT_DATE_SPIN_GROUP::BLT_DATE_SPIN_GROUP( OWNER_WINDOW *powin,
                                          const INTL_PROFILE & intlprof,
                                          CID cidSpinButton,
                                          CID cidUpArrow,
                                          CID cidDownArrow,
                                          CID cidMonth,
                                          CID cidSeparator1,
                                          CID cidDay,
                                          CID cidSeparator2,
                                          CID cidYear,
                                          CID cidFrame)
    : CONTROL_GROUP(),
    _sbControl( powin, cidSpinButton, cidUpArrow, cidDownArrow, TRUE ),
    _ssnMonth( powin, cidMonth, 1, 1, 12 ),
    _ssltSeparator1( powin, cidSeparator1 ),
    _ssnDay( powin, cidDay, 1, 1, 31 ),
    _ssltSeparator2( powin, cidSeparator2 ),
    _ssnYear( powin, cidYear, 0, 0, 100 ), // assume !fYrCentury
    _bkgndFrame( powin, cidFrame ),
    _fYrCentury( intlprof.IsYrCentury() )
{
    if ( QueryError() )
        return;

    APIERR err;

    if ((( err = _sbControl.QueryError()) != NERR_Success ) ||
        (( err = _ssnMonth.QueryError()) != NERR_Success ) ||
        (( err = _ssltSeparator1.QueryError()) != NERR_Success ) ||
        (( err = _ssltSeparator2.QueryError()) != NERR_Success ) ||
        (( err = _ssnDay.QueryError()) != NERR_Success ) ||
        (( err = _ssnYear.QueryError()) != NERR_Success ) ||
        (( err = _bkgndFrame.QueryError()) != NERR_Success ))
    {
        ReportError( err );
        return;
    }

    if (_fYrCentury)
    {
        _ssnYear.SetRange(100);
        _ssnYear.SetMin(1980);
        _ssnYear.SetValue(1980);
    }

    NLS_STR nlsDateSep;
    if (( err = intlprof.QueryDateSeparator( & nlsDateSep )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    DISPLAY_CONTEXT dc( powin->QueryHwnd() );
    dc.SelectFont( _ssnMonth.QueryFont() );

    INT dxDigitMax = CalcMaxDigitWidth(dc);
    dxDigitMax += 1; // FE_SB looks nice...
    INT dyLine  = dc.QueryFontHeight();

    INT dTwoNum = 2 * dxDigitMax;
    INT dFourNum = 4 * dxDigitMax;
    INT dxRightFudge = dxDigitMax/4;
    INT dxLeftFudge = dxDigitMax/8;
    INT dDateSep = dc.QueryTextWidth(nlsDateSep);

    // find out all the position
    XYPOINT xyDate      = _sbControl.QueryPos();
    xyDate.SetX( xyDate.QueryX() - dxRightFudge );
    XYDIMENSION dxyDate = _sbControl.QuerySize();

    if ( dxyDate.QueryHeight() > (UINT) dyLine )
    {
        xyDate.SetY( xyDate.QueryY()
                     + ( (dxyDate.QueryHeight() / 2) - (dyLine / 2) ));
        dxyDate.SetHeight( dyLine );
    }

    INT dYearSize = _fYrCentury ? dFourNum : dTwoNum ;
    INT dxFieldThree = (intlprof.QueryYearPos() == 3) ? dYearSize : dTwoNum;

    // Find year field

    INT xWork = xyDate.QueryX();
    switch (intlprof.QueryYearPos())
    {
    case 1:
        xWork -= dTwoNum + dDateSep + dxRightFudge;
        // fall through
    case 2:
        xWork -= dTwoNum + dDateSep + dxRightFudge;
        // fall through
    case 3:
        xWork -= dYearSize + dxRightFudge;
        break;
    }

    XYPOINT     xyYear(xWork+dxLeftFudge, xyDate.QueryY());
    XYDIMENSION dxyYear( dYearSize, dxyDate.QueryHeight());

    // Find first separator

    xWork = xyDate.QueryX() - dDateSep*2 - dTwoNum - dxRightFudge*2;
    xWork -= (intlprof.QueryYearPos() == 1) ? dTwoNum : dYearSize;

    XYPOINT     xySep1( xWork, xyDate.QueryY());
    XYDIMENSION dxySep1( dDateSep + dxLeftFudge, dxyDate.QueryHeight());

    // Find month field

    xWork = xyDate.QueryX() - dTwoNum - dxRightFudge;
    switch (intlprof.QueryMonthPos())
    {
    case 1:
        xWork -= dYearSize + dTwoNum + dDateSep*2 + dxRightFudge*2;
        break;
    case 2:
        xWork -= dDateSep + dxFieldThree + dxRightFudge;
        break;
    }

    XYPOINT     xyMonth( xWork + dxLeftFudge, xyDate.QueryY());
    XYDIMENSION dxyMonth( dTwoNum, dxyDate.QueryHeight() );

    // Find second separator

    xWork = xyDate.QueryX() - dDateSep - dxFieldThree - dxRightFudge;

    XYPOINT     xySep2( xWork, xyDate.QueryY());
    XYDIMENSION dxySep2( dDateSep + dxLeftFudge, dxyDate.QueryHeight());

    // Find day field

    xWork = xyDate.QueryX() - dTwoNum - dxRightFudge;
    switch (intlprof.QueryDayPos())
    {
    case 1:
        xWork -= dYearSize + dTwoNum + dDateSep*2 + dxRightFudge*2;
        break;
    case 2:
        xWork -= dDateSep + dxFieldThree + dxRightFudge;
        break;
    }

    XYPOINT     xyDay( xWork + dxLeftFudge, xyDate.QueryY());
    XYDIMENSION dxyDay( dTwoNum, dxyDate.QueryHeight() );

    // set up the first control

    if ( PlaceControl( 1, powin, intlprof, xyYear, dxyYear,
        xyMonth, dxyMonth, xyDay, dxyDay ) != NERR_Success )
    {
        return;
    }

    _ssltSeparator1.SetText( nlsDateSep.QueryPch());
    _ssltSeparator1.SetPos( xySep1 );
    _ssltSeparator1.SetSize( dxySep1 );

    if (( err = _sbControl.AddAssociation( &_ssltSeparator1 )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    // set up the second control

    if ( PlaceControl( 2, powin, intlprof, xyYear, dxyYear,
        xyMonth, dxyMonth, xyDay, dxyDay ) != NERR_Success )
    {
        return;
    }

    _ssltSeparator2.SetText( nlsDateSep.QueryPch());
    _ssltSeparator2.SetPos( xySep2 );
    _ssltSeparator2.SetSize( dxySep2 );

    if (( err = _sbControl.AddAssociation( &_ssltSeparator2 )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    // set up the third control

    if ( PlaceControl( 3, powin, intlprof, xyYear, dxyYear,
        xyMonth, dxyMonth, xyDay, dxyDay ) != NERR_Success )
    {
        return;
    }

    // show the item

    _ssnYear.ShowFirst();
    _ssnMonth.ShowFirst();
    _ssnDay.ShowFirst();
    _ssltSeparator1.ShowFirst();
    _ssltSeparator2.ShowFirst();

    // Set field name

    if ((( err = _ssnMonth.SetFieldName( IDS_MONTH )) != NERR_Success) ||
        (( err = _ssnDay.SetFieldName( IDS_DAY )) != NERR_Success ) ||
        (( err = _ssnYear.SetFieldName( IDS_YEAR )) != NERR_Success))
    {
        ReportError( err );
        return;
    }

    _sbControl.SetGroup( this );

}


#define YEAR_LIMIT_1    10000   // the year field is ranged from 0-9999
#define YEAR_LIMIT_2    100     // the year field is ranged from 0-99

APIERR BLT_DATE_SPIN_GROUP::PlaceControl( INT                   nPos,
                                          OWNER_WINDOW *        powin,
                                          const INTL_PROFILE &  intlprof,
                                          const XYPOINT &       xyYear,
                                          const XYDIMENSION &   dxyYear,
                                          const XYPOINT &       xyMonth,
                                          const XYDIMENSION &   dxyMonth,
                                          const XYPOINT &       xyDay,
                                          const XYDIMENSION &   dxyDay )
{
    UNREFERENCED( powin );

    APIERR err;
    static WINDOW * pInsertAfterWin;

    if ( nPos == 1 )
    {
        pInsertAfterWin = NULL;
    }

    if ( intlprof.QueryYearPos() == nPos )
    {
        _ssnYear.SetStyle( _ssnYear.QueryStyle() | SPIN_SSN_ADD_ZERO );
        _ssnYear.SetPos( xyYear, FALSE, pInsertAfterWin );
        _ssnYear.SetSize( dxyYear, FALSE );

        pInsertAfterWin = & _ssnYear;

        if (( err = _sbControl.AddAssociation( &_ssnYear )) != NERR_Success )
        {
            ReportError( err );
            return err;
        }
    }
    else if ( intlprof.QueryMonthPos() == nPos )
    {
        _ssnMonth.SetStyle(_ssnMonth.QueryStyle()
                           | (intlprof.IsMonthLZero() ? SPIN_SSN_ADD_ZERO : 0));
        _ssnMonth.SetPos( xyMonth, FALSE, pInsertAfterWin );
        _ssnMonth.SetSize( dxyMonth, FALSE );

        pInsertAfterWin = & _ssnMonth;

        if (( err = _sbControl.AddAssociation( &_ssnMonth )) != NERR_Success )
        {
            ReportError( err );
            return err;
        }
    }
    else if ( intlprof.QueryDayPos() == nPos )
    {
        _ssnDay.SetStyle(_ssnDay.QueryStyle()
                         | (intlprof.IsDayLZero() ? SPIN_SSN_ADD_ZERO : 0));
        _ssnDay.SetPos( xyDay, FALSE, pInsertAfterWin );
        _ssnDay.SetSize( dxyDay, FALSE );

        pInsertAfterWin = & _ssnDay;

        if (( err = _sbControl.AddAssociation( &_ssnDay )) != NERR_Success )
        {
            ReportError( err );
            return err;
        }
    }
    return NERR_Success;
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::~BLT_DATE_SPIN_GROUP

    SYNOPSIS:   destructor

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

BLT_DATE_SPIN_GROUP::~BLT_DATE_SPIN_GROUP()
{
}


/*******************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::IsConstructionFail

    SYNOPSIS:   check whether the contrustion of the control is succeed
                or not. If not, then ReportError and UIASSERT.

    ENTRY:      CONTROL_WINDOW * pwin - control window to be test

    RETURNS:    BOOL. TRUE for failure and FALSE for succeed

    HISTORY:
        terryk      29-Aug-91   Created
        beng        16-Oct-1991 Tinkered a bit

********************************************************************/

BOOL BLT_DATE_SPIN_GROUP::IsConstructionFail( CONTROL_WINDOW * pwin)
{
    APIERR err = (pwin == NULL)
                 ? ERROR_NOT_ENOUGH_MEMORY
                 : pwin->QueryError();

    if (err != NERR_Success)
    {
        ReportError( err );
        DBGEOL("BLT_DATE_SPIN_GROUP: construction failed.");
        return TRUE;
    }

    return FALSE;
}


/*******************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::SaveValue

    SYNOPSIS:   Save the current value in the Month, Day, Year fields

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_DATE_SPIN_GROUP::SaveValue( BOOL fInvisible )
{
    _sbControl.SaveValue( fInvisible );
}


/*******************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::RestoreValue

    SYNOPSIS:   Restore the current value in the Month, Day, Year fields

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_DATE_SPIN_GROUP::RestoreValue( BOOL fInvisible )
{
    _sbControl.RestoreValue( fInvisible );
}


/*******************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::SetControlValueFocus

    SYNOPSIS:   Set the current focus

    HISTORY:
                terryk  3-Sep-91        Created

********************************************************************/

VOID BLT_DATE_SPIN_GROUP::SetControlValueFocus()
{
    _sbControl.SetControlValueFocus();
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::SetCurrentDay

    SYNOPSIS:   update the data within the spin button to display the current
                date

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

APIERR BLT_DATE_SPIN_GROUP::SetCurrentDay()
{
    WIN_TIME winTime;
    APIERR err;
    if (  ((err = winTime.QueryError()) == NERR_Success )
       && ((err = winTime.SetCurrentTime()) == NERR_Success )
       )
    {
        SetMonth( winTime.QueryMonth() );
        SetDay( winTime.QueryDay() );
        SetYear( winTime.QueryYear() );

        SetControlValueFocus();
    }

    return err;
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::IsValid

    SYNOPSIS:   check the spin button's data is valid or not

    RETURN:     TRUE if the data is valid, FALSE otherwise.

    NOTES:      This subroutine consider ((YEAR/4)*YEAR)==YEAR as a leap year.

    HISTORY:
                terryk  1-Jun-91    Created

*********************************************************************/

BOOL BLT_DATE_SPIN_GROUP::IsValid()
{
    INT nMonth =(INT) _ssnMonth.QueryValue();
    INT nDay =(INT) _ssnDay.QueryValue();
    INT nYear =(INT) _ssnYear.QueryValue();

    if (( nDay > 28 ) && (nMonth == 2))
    {
        BOOL fLeapYear = (0 == nYear%4) && ((0 == nYear%400) || (0 != nYear%100));
        if ( !fLeapYear || (nDay > 29) )
        {
            MsgPopup( _ssnYear.QueryOwnerHwnd(),
                     (fLeapYear) ? IDS_FEBRUARY_LEAP : IDS_FEBRUARY_NOT_LEAP,
                     MPSEV_ERROR, MP_OK );
            _sbControl.SetControlValueFocus();
            return FALSE;
        }
    }
    else
    {
        if (nDay> 31 )
        {
            MsgPopup( _ssnYear.QueryOwnerHwnd(), IDS_DAY_TOO_BIG,
                      MPSEV_ERROR, MP_OK );
            _sbControl.SetControlValueFocus();
            return FALSE;
        }
        else if (nDay > 30)
        {
            switch (nMonth)
            {
            case 4:
            case 6:
            case 9:
            case 11:
                MsgPopup( _ssnYear.QueryOwnerHwnd(), IDS_DAY_TOO_BIG,
                          MPSEV_ERROR, MP_OK );
                _sbControl.SetControlValueFocus();
                return FALSE;

            default:
                break;
            }
        }
    }
    return TRUE;
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::QueryYear

    SYNOPSIS:   Return the year in the range 1980-2079

    NOTE:       Strange range is mandated by mktime()

    HISTORY:
        terryk      12-Jul-91   Created
        beng        13-Aug-1992 mktime doesn't grok pre-1980

*********************************************************************/

INT BLT_DATE_SPIN_GROUP::QueryYear() const
{
    INT nTmp = ((INT)_ssnYear.QueryValue());

    if ( nTmp < 100 )
    {
        if (nTmp < 80)
            nTmp += 2000;  // Adjust for presumably "2079" dates
        else
            nTmp += 1900;  // Adjust for presumably "1995" dates
    }

    return nTmp;
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::QueryMonth

    SYNOPSIS:   return the month in the range 1-12

    RETURN:     return the month value

    HISTORY:
                terryk  12-Jul-91   Created

*********************************************************************/

INT BLT_DATE_SPIN_GROUP::QueryMonth() const
{
    return (INT)_ssnMonth.QueryValue();
}


/*********************************************************************

    NAME:       BLT_DATE_SPIN_GROUP::QueryDay

    SYNOPSIS:   return the day in the range 1-31

    RETURN:     return the day

    HISTORY:
                terryk  12-Jul-91   Created

*********************************************************************/

INT BLT_DATE_SPIN_GROUP::QueryDay() const
{
    return (INT)_ssnDay.QueryValue();
}


VOID BLT_DATE_SPIN_GROUP::SetMonth( INT nMonth )
{
    UIASSERT (( nMonth >= 1 ) && ( nMonth < 13 ));
    _ssnMonth.SetValue( nMonth );
    _ssnMonth.Update();
}


VOID BLT_DATE_SPIN_GROUP::SetDay( INT nDay )
{
    UIASSERT (( nDay > 0 ) && ( nDay < 32 ));
    _ssnDay.SetValue( nDay );
    _ssnDay.Update();
}


VOID BLT_DATE_SPIN_GROUP::SetYear( INT nYear )
{
    UIASSERT( nYear >= 0 );
    if ( !_fYrCentury )
    {
        _ssnYear.SetValue( nYear % 100 );
    }
    else
    {
        if ( nYear < 100 )
        {
            _ssnYear.SetValue( nYear + 1900 );
        }
        else
        {
            _ssnYear.SetValue( nYear );
        }
    }
    _ssnYear.Update();
}


#if 0 // disabled
/*********************************************************************

    NAME:       TIME_DATE_DIALOG::TIME_DATE_DIALOG

    SYNOPSIS:   constructor

    ENTRY:      TCHAR* pszResourceName - dialog resurce name
                HWND hwndOwner - handle for owner window

                // CID for all the controls
                CID cidTimeSpinButton
                CID cidTimeUpArrow
                CID cidTimeDownArrow
                CID cidHour
                CID cidTimeSeparator1
                CID cidMin
                CID cidTimeSeparator2
                CID cidSec
                CID cidAMPM
                CID cidDateSpinButton
                CID cidDateUpArrow
                CID cidDateDownArrow
                CID cidMonth
                CID cidDateSeparator1
                CID cidDay
                CID cidDateSeparator2
                CID cidYear

    HISTORY:
                terryk  11-Jul-91   Created
                rustanl 11-Sep-91   Changed BLT_TIMER to WINDOW_TIMER

*********************************************************************/

TIME_DATE_DIALOG::TIME_DATE_DIALOG( const TCHAR * pszResourceName,
                      HWND hwndOwner, const INTL_PROFILE & intlprof,
                      CID cidTimeSpinButton,
                      CID cidTimeUpArrow, CID cidTimeDownArrow, CID cidHour,
                      CID cidTimeSeparator1, CID cidMin, CID cidTimeSeparator2,
                      CID cidSec, CID cidAMPM,
                      CID cidDateSpinButton,
                      CID cidDateUpArrow, CID cidDateDownArrow, CID cidMonth,
                      CID cidDateSeparator1, CID cidDay, CID cidDateSeparator2,
                      CID cidYear)
    : DIALOG_WINDOW( pszResourceName, hwndOwner ),
    _TimeSG( this, intlprof, cidTimeSpinButton, cidTimeUpArrow,
        cidTimeDownArrow, cidHour, cidTimeSeparator1, cidMin,
        cidTimeSeparator2, cidSec,  cidAMPM ),
    _DateSG( this, intlprof, cidDateSpinButton, cidDateUpArrow,
        cidDateDownArrow, cidMonth, cidDateSeparator1, cidDay,
        cidDateSeparator2, cidYear),
    _pTimer( NULL )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _TimeSG.SetCurrentTime()) != NERR_Success )
       || ((err = _DateSG.SetCurrentDay()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

    _pTimer = new WINDOW_TIMER( QueryHwnd(), 1000 );
    UIASSERT( _pTimer != NULL );
}


TIME_DATE_DIALOG::~TIME_DATE_DIALOG()
{
    delete _pTimer;
}


/*********************************************************************

    NAME:       TIME_DATE_DIALOG::OnOther

    SYNOPSIS:   get the timer message and update the box.

    ENTRY:      USHORT usMsg - message
                USHORT wParam - word parameter
                ULPARAM lParam - lParam

    RETURN:     Always TRUE

    HISTORY:
        terryk      12-Jul-91   Created (as OnOther)
        beng        30-Sep-1991 Converted to OnTimer

*********************************************************************/

BOOL TIME_DATE_DIALOG::OnTimer( const TIMER_EVENT & e )
{
    UNREFERENCED(e);

    if ( _TimeSG.IsModified() || _DateSG.IsModified() )
    {
        // stop the timer if either one of them is modified
        _pTimer->Enable( FALSE );
    }
    else
    {
        APIERR err;
        if (  ((err = _TimeSG.SetCurrentTime()) != NERR_Success )
           || ((err = _DateSG.SetCurrentDay()) != NERR_Success )
           )
        {
            ::MsgPopup( this, err );
        }
    }

    // Event handled
    //
    return TRUE;
}
#endif // disabled entire TIME_DATE_DIALOG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\bltsslt.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltsslt.cxx
    Source file for SPIN_SLT_SEPARATOR class.
    SPIN_ITEM is the same as SLT. However, it is only used within a
    SPIN_GROUP . It cannot used outside a SPIN_GROUP.

    FILE HISTORY:
	terryk	    8-May-91	Creation
	beng	    18-Sep-1991 Prune UIDEBUG clauses
*/

#include "pchblt.hxx"  // Precompiled header


const TCHAR * SPIN_SLT_SEPARATOR::_pszClassName = SZ("STATIC");


/*********************************************************************

    NAME:       SPIN_SLT_SEPARATOR::SPIN_SLT_SEPARATOR

    SYNOPSIS:   constructor

    ENTRY:      OWNER_WINDOW *powin - pointer to the owner window
                CID cid - the current ID for the SPIN_SLT_SEPARATOR object

                For APP_WIN:
                TCHAR * pszText - the initial Text
                ULONG flStyle - the control style
                TCHAR * pszClassName - class name of the control object

    NOTES:      It will call SLT's constructor to create the object.
                Meanwhile, it will also call the STATIC_SPIN_ITEM's
                constructor to setup its properties

    HISTORY:
	terryk	    8-May-91	    Creation
	beng	    31-Jul-1991     Control error reporting changed

*********************************************************************/

SPIN_SLT_SEPARATOR::SPIN_SLT_SEPARATOR( OWNER_WINDOW * powin, CID cid )
    : SLT( powin, cid ),
      STATIC_SPIN_ITEM( this )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    if ( Initialize() != NERR_Success )
    {
	// Init has already reported the error
        return;
    }
}

SPIN_SLT_SEPARATOR::SPIN_SLT_SEPARATOR( OWNER_WINDOW * powin, CID cid,
					const TCHAR * pszText,
					XYPOINT xy, XYDIMENSION dxy,
					ULONG flStyle )
    : SLT( powin, cid, xy, dxy, flStyle, _pszClassName ),
      STATIC_SPIN_ITEM( this )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    SetText( pszText );
    if ( Initialize() != NERR_Success )
    {
        return;
    }
}


/*********************************************************************

    NAME:       SPIN_SLT_SEPARATOR::Initialize

    SYNOPSIS:   Initialize the internal Accelerator key

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

APIERR SPIN_SLT_SEPARATOR::Initialize()
{
    NLS_STR nlsAccKey;
    APIERR  err = GetAccKey( & nlsAccKey );

    if ( err != NERR_Success )
    {
	ReportError( err );
        return err;
    }
    return SetAccKey( nlsAccKey );
}


/*********************************************************************

    NAME:       SPIN_SLT_SEPARATOR::GetAccKey

    SYNOPSIS:   Get the accelerator key. It will always consider the
                first character within the separator as the accelerator
                key.

    ENTRY:      NLS_STR * nlsAccKey - the returned accelerator key string.

    EXIT:       nlsAccKey will contain the accelerator key string

    RETURN:     APIERR err - it will pass the err code to the caller
                             function

    HISTORY:
                terryk  22-May-91   Created

*********************************************************************/

APIERR SPIN_SLT_SEPARATOR::GetAccKey( NLS_STR * pnlsAccKey )
{
    UIASSERT( pnlsAccKey != NULL );

    APIERR err = QueryText( pnlsAccKey );
    if ( err != NERR_Success )
    {
        return pnlsAccKey->QueryError();
    }

    ISTR istrPosition( *pnlsAccKey );

    // we just need the first character
    ++istrPosition;
    pnlsAccKey->DelSubStr( istrPosition );
    return pnlsAccKey->QueryError();
}


/*******************************************************************

    NAME:       SPIN_SLT_SEPARATOR::OnCtlColor

    SYNOPSIS:   Dialogs pass WM_CTLCOLOR* here

    RETURNS:    brush handle if you handle it

    HISTORY:
        jonn        05-Sep-1995 Created

********************************************************************/
HBRUSH SPIN_SLT_SEPARATOR::OnCtlColor( HDC hdc, HWND hwnd, UINT * pmsgid )
{
    UNREFERENCED( hdc );
    UNREFERENCED( hwnd );
    ASSERT( pmsgid != NULL && *pmsgid == WM_CTLCOLORSTATIC );

    // Use same background color handling as an edit control
    *pmsgid = WM_CTLCOLOREDIT;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\dead\bltgcb.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    <file.extension>
    <Single line synopsis>

    <Multi-Line, more detailed synopsis>


    FILE HISTORY:
        <name>	    <curdate>	<comment>

*/

GRAPHICAL_CHECKBOX::GRAPHICAL_CHECKBOX( OWNER_WINDOW *powin, CID cid,
    ULONG ulIDCheck, ULONG ulIDUnCheck )
    : CHECKBOX ( powin, cid ),
    _pbmCheck(( ulIDCheck == 0 ) ? NULL : new BIT_MAP ( ulIDCheck )),
    _pbmUnCheck(( ulIDUnCheck == 0 ) ? NULL : new BIT_MAP ( ulIDUnCheck ))
{
    UIASSERT( ( _pbmCheck == NULL ) || ( _pbmCheck->QueryError() == NERR_Success ));
    UIASSERT( ( _pbmUnCheck == NULL ) || ( _pbmUnCheck->QueryError() == NERR_Success ));
}

GRAPHICAL_CHECKBOX::~GRAPHICAL_CHECKBOX()
{
    delete _pbmCheck;
    delete _pbmUnCheck;
}

BOOL GRAPHICAL_CHECKBOX::CD_Draw( DRAWITEMSTRUCT *pdis, GUILTT_INFO * pGUILTT)
{
	BITMAP bitmap;
	RECT rcImage;

    // excluding the border
	rcImage.left    = pdis->rcItem+1;
    rcImage.top     = pdis->top+1;
    rcImage.right   = pdis->right-1;
    rcImage.bottom  = pdis->bottom-1;

	DEVICE_CONTEXT dcT( CreateCompatibleDC( pdis->hDC ));

    if (( pdis->itemState & ODS_CHECKED ) == 0 )
    {
        // display normal bitmap
    	::GetObject( _pbmCheck, sizeof(bitmap), (LPSTR)&bitmap);
    	dcT.SelectObject( _pbmCheck );
    }
    else
    {
        // display disable bitmap
    	::GetObject( _pbmUnCheck, sizeof(bitmap), (LPSTR)&bitmap);
        dcT.SelectObject( _pbmUnCheck ) ;
    }

    // fit the bitmap into the button position
	::StretchBlt( pdis->hDC, rcImage.left,
		   rcImage.top, rcImage.right - rcImage.left, rcImage.bottom - 
           rcImage.top,
		   dcT.QueryHdc(), 0, 0, bitmap.bmWidth, bitmap.bmHeight, SRCCOPY);

    ::DeleteDC( dcT.QueryHdc() );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\dead\bltlogon.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltlogon.cxx
        Logon control objects

    FILE HISTORY:
        terryk  22-Jul-1991 Created

*/

LOGON_CHECKBOX::LOGON_CHECKBOX( OWNER_WINDOW *powin, CID cid, 
                                TCHAR * pszIDCheck, TCHAR * pszIDUnCheck )
    : GRAPHICAL_CHECKBOX( powin, cid, pszIDCheck, pszIDUnCheck ),
    CUSTOM_CONTROL( this )
{
    if ( QueryError( powin ) != NERR_Success )
        return;
}

LOGON_CHECKBOX::LOGON_CHECKBOX( OWNER_WINDOW *powin, CID cid,
                                TCHAR * pszIDCheck, TCHAR * pszIDUnCheck,
                                XYPOINY xy, XYDIMENSION dxy, ULONG flStyle )
    : GRAPHICAL_CHECKBOX( powin, cid, pszIDCheck, pszIDUnCheck, xy, dxy,
                          flStyle ),
    CUSTOM_CONTROL( this )
{
    if ( QueryError( powin ) != NERR_Success )
        return;
}

LOGON_DIALOG::LOGON_DIALOG( TCHAR * pszResourceName, HWND hwndOwner,
    CID cidClockBitmap, CID cidTopHourLabels, CID cidBotHourLabels,
    CID cidDayLabels, CID cidColumnHeader, CID cidFirstLogonCheckBox,
    CID cidLegends, XYRECT xyRulerPos )
    : DIALOG_WINDOW( pszResourceName, hwndOwner ),
{
    // Load Clock bitmap

    // set SLT
    INT i;

    for ( i = 0; i < 9; i++ )
    {
        sltTopLabel[ i ]( this, cidTopHourLabels + i );
        sltBotLabel[ i ]( this, cidBotHourLabels + i );
    }
}

LOGON_DIALOG::~LOGON_DIALOG()
{
}

VOID LOGON_DIALOG::Initialization()
{
}

VOID LOGON_DIALOG::DrawRuler()
{
}

VOID LOGON_DIALOG::LoadAllBitMap()
{
}

BOOL LOGON_DIALOG::OnKeyDown()
{
    switch ( wParam )
    {
    case VK_SHIFT:
        _fDrag = TRUE;
        break;
    default:
        break;
    }
}

BOOL LOGON_DIALOG::OnKeyUp()
{
    switch ( wParam )
    {
    case VK_SHIFT:
        _fDrag = FALSE;
        break;
    default:
        break;
    }
}

BOOL LOGON_DIALOG::OnChar( const CHAR_EVENT & event )
{
    switch ( event.QueryChar() )
    {
    case ID_CTRL_HOME:
        nCurrentHour = rlcbDayRow[0].FocusFirst();
        nCurrentDay = 0;
        break;

    case ID_CTRL_END:
        nCurrentHour = rlcbDayRow[6].FocusLast();
        nCurrentDay = 0;
        break;

    case ID_LEFT:
        nCurrentHour = rlcbDayRow[ nCurrentDay ].FocusLeft();
        break;

    case ID_RIGHT:
        nCurrentHour = rlcbDayRow[ nCurrentDay ].FocusRight();
        break;

    case ID_UP:
        nCurrentDay --;
        if ( nCurrentDay < 0 )
        {
            nCurrentDay = 0;
        }
        rlcbDayRow[ nCurrentDay].FocusHour( nCurrentHour );
        break;

    case ID_DOWN:
        nCurrentDay ++;
        if ( nCurrentDay > 6 )
        {
            nCurrentDay = 6;
        }
        rlcbDayRow[ nCurrentDay].FocusHour( nCurrentHour );

        break;

    default:
        return FALSE;
    }
    return TRUE;
}

BOOL LOGON_DIALOG::OnDragBegin( const MOUSE_EVENT & event )
{
    XYPOINT xyAnchor = event.QueryPos();
    XYRECT  xyrectTemp( xyAnchor, XYDIMENSION( 0, 0 ));
    _drectRegion = xyrectTemp;
    _drectRegion.Show( TRUE );
    return TRUE;
}

BOOL LOGON_DIALOG::OnDragEnd( const MOUSE_EVENT & event )
{
    UNREFERENCED( event );
    _drectRegion.Show( FALSE );
    return TRUE;    
}

BOOL LOGON_DIALOG::OnDragMove( cosnt MOUSE_EVENT & event )
{
    XYPOINT xyNewPos = event.QueryPos();
    XYPOINT xyAnchor = _drectRegion.QueryPos();
    XYDIMENSION dxyRegion( xyNewPos.QueryX() - xyAnchor.QueryX(),
                           xyNewPos.QueryY() - xyAnchor.QueryY()) ;
    XYRECT xyrectTemp( xyAnchor, dxyRegion );
    _drectRegion = xyrectTemp;                        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\bltcc\dead\bltmeter.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    bltmeter.cxx
        Source file for Activity Meter custom control

    FILE HISTORY:
        terryk  10-Jun-91   Created

*/

#ifdef  LM_3

#define  INCL_WINDOWS
#define  INCL_WINDOWS_GDI
#define  INCL_NETERRORS
#include <lmui.hxx>

extern "C"
{
    #include <netlib.h>
}


#if defined(DEBUG)
static const TCHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif
#include <uiassert.hxx>
#include <uitrace.hxx>

#define _BLT_HXX_ // "private"
#include <bltrc.h>
#include <bltglob.hxx>
#include <bltcons.h>
#include <bltinit.hxx>
#include <bltwin.hxx>
#include <bltmisc.hxx>
#include <bltctlvl.hxx>
#include <bltgroup.hxx>
#include <bltctrl.hxx>
#include <bltdlg.hxx>
#include <bltmsgp.hxx>
#include <bltclwin.hxx>
#include <bltdisph.hxx>
#include <bltcc.hxx>
#include <bltmeter.hxx>

#define DEBUG
#include <dbgstr.hxx>

const TCHAR * METER::_pszClassName = "static";

/**********************************************************\

    NAME:       METER::METER

    SYNOPSIS:   Meter is an activity indicator object. It displays the
                number of percentage complete and mark the specified 
                percentage of the rectangle with the specified color.

    ENTRY:      OWNER_WINDOW *powin - owner window of the control
                CID cid - cid of the control
                COLORREF color - color to paint the rectangle. Optional.
                                 If the color is missing, use BLUE.

    HISTORY:    
	terryk	    15-May-91	    Created
	beng	    31-Jul-1991     Control error reporting changed

\**********************************************************/

METER::METER( OWNER_WINDOW *powin, CID cid, COLORREF color )
    : CONTROL_WINDOW( powin, cid ),
      CUSTOM_CONTROL( this ),
      _nComplete( 0 ),
      _color( color )
{
    APIERR  apierr = QueryError();
    if ( apierr != NERR_Success )
    {
        UIDEBUG("BLTMETER error: constructor failed.\n\r");
    }

}

METER::METER( OWNER_WINDOW *powin, CID cid, 
              XYPOINT xy, XYDIMENSION dxy, ULONG flStyle, COLORREF color )
    : CONTROL_WINDOW ( powin, cid, xy, dxy, flStyle, _pszClassName ),
      CUSTOM_CONTROL( this ),
      _nComplete( 0 ),
      _color( color )
{
    APIERR  apierr = QueryError();
    if ( apierr != NERR_Success )
    {
        UIDEBUG("BLTMETER error: constructor failed.\n\r");
        return ;
    }
}


/**********************************************************\

    NAME:       METER::SetComplete

    SYNOPSIS:   Reset the number of percentage completed

    ENTRY:      INT nComplete - completed percentage

    NOTES:      It will repaint the object every reset the percentage.

    HISTORY:    
                terryk  15-May-91   Created

\**********************************************************/

VOID METER::SetComplete( INT nComplete )
{
    _nComplete = ( nComplete < 0 ) ? 0 : 
                 (( nComplete > 100 ) ? 100 : nComplete );
    Invalidate( TRUE );
}    


/**********************************************************\

    NAME:       METER::OnPaintReq

    SYNOPSIS:   Redraw the whole object

    HISTORY:    
                terryk  15-May-91   Created

\**********************************************************/

BOOL METER::OnPaintReq()
{
    RECT    rectClient, rectPercent;
    TCHAR    pszBuf[ 10 ];

    wsprintf( pszBuf, "%d%%", _nComplete );

    PAINTSTRUCT     ps;

    ::BeginPaint( WINDOW::QueryHwnd(), & ps );
    DISPLAY_CONTEXT dc( WINDOW::QueryHwnd() );

    DWORD dwBkColor      = dc.SetBkColor( GetSysColor( COLOR_WINDOW ) );
    DWORD dwTextColor    = dc.SetTextColor( _color );

    dc.SetTextAlign( TA_CENTER | TA_TOP );

    DWORD   dwColor = dc.GetBkColor( );

    // fill up the rectangle first

    dc.SetBkColor( dc.SetTextColor( dwColor ));
    ::GetClientRect( WINDOW::QueryHwnd(), &rectClient );
    ::SetRect( &rectPercent, 0, 0, 
             (( INT )((( LONG )rectClient.right * ( LONG )_nComplete )/ 100 )), 
             rectClient.bottom );

    TEXTMETRIC  textmetric;

    dc.QueryTextMetrics( &textmetric );

    // draw half of the text
    dc.ExtTextOut( rectClient.right/2, ( rectClient.bottom - 
                   textmetric.tmHeight )/ 2, ETO_OPAQUE | ETO_CLIPPED, 
                   &rectPercent, pszBuf, strlenf( pszBuf ), NULL );

    rectPercent.left = rectPercent.right;
    rectPercent.right = rectClient.right;

    // draw the other half of the text
    dwColor = dc.GetBkColor( );
    dc.SetBkColor( dc.SetTextColor( dwColor ));
    dc.ExtTextOut( rectClient.right /2, ( rectClient.bottom - 
                   textmetric.tmHeight ) / 2, ETO_OPAQUE | ETO_CLIPPED, 
                   &rectPercent, pszBuf, strlenf( pszBuf ), NULL );
    dc.SetBkColor( dwBkColor );
    dc.SetTextColor( dwTextColor );

    ::EndPaint( WINDOW::QueryHwnd(), &ps );
    return TRUE;
    
}

#endif  //  LM_3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\doc\bltmsgp.cs ===
//  Copyright (c) 1990, Microsoft Corp.
//  BLT MsgPopup API code spec


Creation:	Rustan M. Leino
		5 Dec 1990


THE MSGPOPUP API FUNCTION PROTOTYPES:

    Please see the declarations below.


THE MSGPOPUP API:  A COMMON DESCRIPTION:

    The API entry points take some subset of the following parameters.
    This is a general description of the parameters.


    Parameters:

	powin		Pointer to owner Window.  Should never
                        be NULL.

                        (Internally, we could use the MB_TASKMODAL
                        switch if owner is NULL, but I hope this
                        will never be important.)

        usMsg           Standard error code number, or
			application string number.  If the string for
			this number cannot be retrieved, a catch-all
			string is retrieved instead.  Note, the catch-all
			value is not in the functional spec--it is there
			only as a means of catching programming errors.

	insstr		INSERT_STRINGS object including the insert
			string.

			The debug version will make sure that the number
			of insert strings in INSERT_STRINGS matches
			the number of %n entries in the string.
			The retail verion simply ignores additional
			insert strings, and does leaves %n entries
			without corresponding insert strings unchanged.

	msgsev		A MSG_SEVERITY enumeration value, i.e., one of
			the following:
                            MPSEV_INFO
                            MPSEV_WARNING
                            MPSEV_ERROR

                        (Is there ever a need for a system
                        modal message popup?  If so, we should
                        add MPSEV_ERROR_SYSMODAL to above.)

	usButtons	A combination of the following:
                            MP_OK
                            MP_CANCEL
                            MP_YES
                            MP_NO

                        If desired, the following shorthands
                        can be used:
                            MP_OKCANCEL
                            MP_YESNO
                            MP_YESNOCANCEL

                        Note.  All combinations of the MP_
                               primitives may not be implemented.

                        Note.  There is no Help button selection.
			       (See usHelpContext below.)

	usDefButton	Indicates which of the usButtons
                        is to be used as the default button.
			If usDefButton is not one of the wButtons,
			it is added to usButtons.

			If this value is 0, the default button choice
			is made.  This corresponds to the default
			button used by Windows for this button combination,
			where applicable.

	usHelpContext	The help context in the help file, if the
                        Help button is pressed.  If there is
			to be no Help button, usHelpContext should
			be 0L.	Note, that a usHelpContext value (whether
			implicit or explicit) always adds a help button
			to the message box.

			Most of the time, the help context value
			automatically retrieved from the resource file.


    Return value:

        The return value is 0 if an error (such as insufficient
	memory) occurred.  Otherwise, it informs the caller of
        which button was clicked, by one of the following values:
            IDOK
            IDCANCEL
            IDYES
	    IDNO

	Note, that an invalid usMsg parameter is not considered an
	error (see usMsg parameter description above).



NOTES ON THE API:

    The API consists of function calls, rather than a class.
    If desired, these function calls could be made static
    class methods of a MESSAGEPOPUP class.

    To justify this, let's consider the use of a class.
    The one and only method of this class would be Popup.
    The object constructor will need to store pointers to the
    parameters it was given, or store the parameters inside
    the object, so that these are available at the time Popup
    is called.

    This increases the chances of the message popup to fail.
    The only advantage with this model is that once an object has
    been constructed, it can be displayed several times.  This,
    however, is something that never occurs in our UI.


ALTERNATIVES:

    The severity level of all, or some subset of, message numbers, could
    be baked into the resource file, just like the help topic is.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\collect\aheap.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    aheap.cxx
    HEAP_BASE implementation


    FILE HISTORY:
	rustanl     05-Jul-1991     Created
	rustanl     15-Jul-1991     Code review changes (SetAllocCount
				    heuristics).  CR attended by
				    BenG, ChuckC, JimH, Hui-LiCh, TerryK,
				    RustanL.

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*******************************************************************

    NAME:	HEAP_BASE::HEAP_BASE

    SYNOPSIS:	HEAP_BASE constructor

    ENTRY:	cInitialAllocCount -	The number of items that
					the heap should initially
					allocate space for.
		fAutoReadjust - 	Specifies whether or not the
					heap is supposed to auto-readjust
					after each call to AddItem (defined
					in subclasses).  If FALSE,
					Adjust must be called before
					the contents of the heap is
					publically queried.  (Note, Adjust
					sets the auto-readjust state to
					TRUE.)

    NOTES:	On successful construction, the heap guarantees that
		it will be able to add and remove items successfully,
		provided the number of items in the heap never exceeds
		cInitialAllocCount.  If AddItem is called when the
		number of items in the heap is at least cIntialAllocCount,
		the add operation may fail (presumably because of
		insufficient memory).

		The SetAllocCount method can be used to adjust the
		cInitialAllocCount passed to this constructor.	That method
		may also be able to rectify unsuccessful constructions.

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

HEAP_BASE::HEAP_BASE( int cInitialAllocCount, BOOL fAutoReadjust )
    : _cItems( 0 ),
      _fAutoReadjust( fAutoReadjust ),
      _buf( cInitialAllocCount * sizeof( VOID * ))
{
    if ( QueryError() != NERR_Success )
	return;

    UIASSERT( cInitialAllocCount >= 0 );

    APIERR err = _buf.QueryError();
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

}  // HEAP_BASE::HEAP_BASE


/*******************************************************************

    NAME:	HEAP_BASE::~HEAP_BASE

    SYNOPSIS:	HEAP_BASE destructor

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

HEAP_BASE::~HEAP_BASE()
{
    // do nothing else

}  // HEAP_BASE::~HEAP_BASE


/*******************************************************************

    NAME:	HEAP_BASE::I_AddItem

    SYNOPSIS:	Adds another item to the bottom of the heap, but does
		not ajust the heap.

		This method is called by the AddItem methods of derived
		classes.

    ENTRY:	Heap in successful state.

		pv -	    Pointer to item to add to heap

    EXIT:	On success, the new item will be stored in the last
		position in the heap, and the count of items in the
		heap will be increased accordingly.  Note, however,
		the caller is responsible for adjusting the heap
		afterwards.
		On failure, the heap is left unchanged.

    RETURNS:	An API error code, which is NERR_Success on success.

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

APIERR HEAP_BASE::I_AddItem( VOID * pv )
{
    UIASSERT( QueryError() == NERR_Success );

    APIERR err = SetAllocCount( _cItems + 1 );
    if ( err != NERR_Success )
	return err;

    VOID * * ppv = (VOID * *)_buf.QueryPtr();
    UIASSERT( ppv != NULL );	    // this could only happen if the size of
				    // the buffer were 0.
    ppv[ _cItems++ ] = pv;

    return NERR_Success;

}  // HEAP_BASE::I_AddItem


/*******************************************************************

    NAME:	HEAP_BASE::PeekItem

    SYNOPSIS:	Returns a pointer to an item in the heap.

    ENTRY:	The heap must be in a successful state, and must be
		in the auto-readjust state.

		i -	The index of the item to be returned

		The heap must have more than i items.

    EXIT:	The heap is left unchanged.

    RETURNS:	A poitner to the requested item.

    NOTES:	Note, this method is protected, since a general client
		should not be given access to any item but the top
		one (as governed by the properties of a heap).

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

void * HEAP_BASE::PeekItem( int i ) const
{
    UIASSERT( QueryError() == NERR_Success );
    UIASSERT( IsAutoReadjusting());
    UIASSERT( 0 <= i && i < QueryCount());

    return ((VOID * *)_buf.QueryPtr())[ i ];

}  // HEAP_BASE::PeekItem


/*******************************************************************

    NAME:	HEAP_BASE::SetItem

    SYNOPSIS:	Sets an existing item in the heap

    ENTRY:	The heap must be in a successful state

		i -	Index of an existing item
		pv -	New value for item i

    EXIT:	Item i has the value pv.  The heap is not adjusted.

    HISTORY:
	rustanl     08-Jul-1991     Created

********************************************************************/

void HEAP_BASE::SetItem( int i, void * pv )
{
    UIASSERT( QueryError() == NERR_Success );
    UIASSERT( 0 <= i && i < QueryCount());

    VOID * * ppv = (VOID * *)_buf.QueryPtr();

    ppv[ i ] = pv;

}  // HEAP_BASE::SetItem


/*******************************************************************

    NAME:	HEAP_BASE::I_RemoveTopItem

    SYNOPSIS:	Removes the top item and returns it.  Leaves the
		heap in an unadjusted state (see Exit:).

    ENTRY:	A non-empty heap in a successful and auto-readjusting
		state

    EXIT:	Left and right subtrees of the heap are subheaps
		(i.e., they have the heap property), but the
		root may need adjustment (performed by calling
		AdjustDown( 0 )).

    RETURNS:	Pointer to the top (smallest) item.

    HISTORY:
	rustanl     08-Jul-1991     Created

********************************************************************/

void * HEAP_BASE::I_RemoveTopItem( void )
{
    UIASSERT( QueryCount() > 0 );
    UIASSERT( IsAutoReadjusting());

    VOID * pvReturnItem = PeekItem( 0 );

    //	Place bottom-most item as first item

    int iLastItem = _cItems - 1;
    SetItem( 0, PeekItem( iLastItem ));

    _cItems = iLastItem;

    return pvReturnItem;

}  // HEAP_BASE::I_RemoveTopItem


/*******************************************************************

    NAME:	HEAP_BASE::SetAllocCount

    SYNOPSIS:	Resizes the buffer in use.

    ENTRY:	cNewAllocCount -    The smallest number of items that
				    the heap should be able to store
				    upon successful return of this
				    method

    EXIT:	On success, the heap can store at least cNewAllocCount
		items.	The BASE error recorded will then always be
		NERR_Success.
		On failure, the heap is left unchanged.

    RETURNS:	An API error code, which is NERR_Success on success.

    NOTES:	On successful returns from this method, the heap
		is, like after successful construction, guaranteed
		to successfully perform AddItem and RemoveItem operations,
		provided the number of items does not exceed
		cNewAllocCount.  If construction was successful, and if
		Trim has not been called, this guarantee extends to
		max( cInitialAllocCount, cNewAllocCount ) items.
		(See also constructor.)

		This method will never discard any items in the heap,
		and will never shrink the buffer being used,  Hence,
		requests for the new alloc count to be less than the
		number of items currently in the heap will always
		succeed without changing the object at all.

		This method can be applied to objects that were not
		successfully constructed.  If the new alloc count
		is small enough to succeed, the object will, on exit,
		be in a successful state.

		To shrink the buffer to get rid of excess space, use
		the Trim method.

    HISTORY:
	rustanl     05-Jul-1991     Created
	rustanl     15-Jul-1991     If resize of buffer is necessary,
				    resize to next bigger 4Kb boundary.

********************************************************************/

#define NICE_MEMORY_INCREMENT		(0x1000)

APIERR HEAP_BASE::SetAllocCount( int cNewAllocCount )
{
    if ( cNewAllocCount <= _cItems )
	return NERR_Success;

    UINT cbSizeNeeded = cNewAllocCount * sizeof( VOID * );

    if ( cbSizeNeeded <= _buf.QuerySize())
	return NERR_Success;	    // buffer is already big enough

    /*	Resize the buffer.  While we're at it, get a bit extra memory
     *	by rounding up to the nearest 4 Kb boundary.  4 Kb was chosen
     *	as an arbitrary nice number.  It also happens to be the hardware
     *	page size used on x86's.
     *
     *	Note, the rounding is done in two steps, so as to avoid overflows.
     *	The first step really computes the 4Kb boundary next below
     *	cbSizeNeeded.  If cbSizeNeeded is exactly on a 4Kb boundary, then
     *	this is also the next 4Kb boundary above.  If the 4Kb boundary
     *	below is not cbSizeNeeded, then add 4Kb to it.	This will then
     *	produce the desired new alloc size.
     */

    UINT cbNewAllocSize = ( cbSizeNeeded / NICE_MEMORY_INCREMENT )
			  * NICE_MEMORY_INCREMENT;
    if ( cbNewAllocSize < cbSizeNeeded )
    {
	cbNewAllocSize += NICE_MEMORY_INCREMENT;
    }
    UIASSERT( cbSizeNeeded <= cbNewAllocSize );

    APIERR err = _buf.Resize( cbNewAllocSize );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("_buf.Resize failed in HEAP_BASE::SetAllocCount\r\n") );
	return err;
    }

    if ( QueryError() != NERR_Success )
	ReportError( NERR_Success );

    return NERR_Success;

}  // HEAP_BASE::SetAllocCount


/*******************************************************************

    NAME:	HEAP_BASE::Trim

    SYNOPSIS:	Trims the buffer used to store the pointers to the items
		contained in the heap

    ENTRY:	The object in a valid state

    EXIT:	The buffer trimmed.  Note, all items in the heap remain
		the same.

    HISTORY:
	rustanl     05-Jul-1991     Created

********************************************************************/

void HEAP_BASE::Trim( void )
{
    UIASSERT( QueryError() == NERR_Success );

    _buf.Trim();

}  // HEAP_BASE::Trim
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\collect\bitfield.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    Bitfield.cxx

    This file contains generic bitfield implementation.

    Currently it is limited to a field of 32 bits.


    FILE HISTORY:
        Johnl       13-Jul-1991     Created

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*******************************************************************

    NAME:       BITFIELD::BITFIELD

    SYNOPSIS:   Various bitfield constructors

    ENTRY:      See different constructors

    EXIT:       If an allocation occurred, ReportError will be called

    NOTES:      (JonN 10/13/94) These constructors don't really make much
                sense.  Why initialize _cBitsinBitfield to some large number
                if _pbBitVector is zero?  Why initialize both _pbBitVector
                and _ulBitfield if they are in a union?

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BITFIELD::BITFIELD( unsigned cBitsInBitfield,
                    enum BITVALUES bitInit )
    : _cBitsInBitfield( cBitsInBitfield ),
      _pbBitVector ( NULL )
{
    UIASSERT( cBitsInBitfield > 0 ) ;

    APIERR err = AllocBitfield( cBitsInBitfield ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }

    SetAllBits( bitInit ) ;

}

BITFIELD::BITFIELD( const BYTE * pbInitValue,
                    unsigned cInitBytes,
                    unsigned cTotalBits )

/* pbInitValue - Pointer to bitfield initializer
 * cInitBytes  - Count of bytes contained in pbInitValue
 * cTotalBits  - Size of bitfield
 */
    : _cBitsInBitfield( cTotalBits ),       // Warning - Maybe 0
      _pbBitVector ( NULL )
{
    /* If the client passed in 0 for the bitfield size, then assume the
     * size should be the same size as the initializer
     */
    if ( !_cBitsInBitfield )
    {
        _cBitsInBitfield = 8*cInitBytes ;
    }

    APIERR err = AllocBitfield( _cBitsInBitfield ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }


    ::memcpyf( (char *) QueryBitPos( 0, QueryCount()),
               (char *) pbInitValue,
               QueryAllocSize() ) ;
}

BITFIELD::BITFIELD( const BITFIELD & bitfieldSrc )
    : _cBitsInBitfield( bitfieldSrc.QueryCount() ),
      _ulBitfield     ( 0L )
{
    UIASSERT( bitfieldSrc.QueryError() == NERR_Success ) ;

    APIERR err = AllocBitfield( _cBitsInBitfield ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }

    BYTE * pbSrc  = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest = QueryBitPos( 0, QueryCount() ) ;
    ::memcpyf( (char *)pbDest, (char *)pbSrc, QueryAllocSize() ) ;
}


BITFIELD::BITFIELD( USHORT usInit )
    : _cBitsInBitfield( 0 ),
      _ulBitfield     ( (ULONG) usInit )
{
    APIERR err = AllocBitfield( 8*sizeof(usInit) ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }
}

BITFIELD::BITFIELD( ULONG ulInit )
    : _cBitsInBitfield( 0 ),
      _ulBitfield     ( ulInit )
{
    APIERR err = AllocBitfield( 8*sizeof(ulInit) ) ;
    if ( err != NERR_Success )
    {
        ReportError( err ) ;
        return ;
    }
}


/*******************************************************************

    NAME:       BITFIELD::~BITFIELD

    SYNOPSIS:   Bitfield destructor

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BITFIELD::~BITFIELD()
{
    if ( IsAllocated() )
    {
        delete _pbBitVector ;
        _pbBitVector = NULL ;
    }

    _cBitsInBitfield = 0 ;
}


/*******************************************************************

    NAME:       BITFIELD::SetAllBits

    SYNOPSIS:   Sets all of the bits in the bitfield to the value
                specified

    ENTRY:      bit - Either ON or OFF

    EXIT:       All of the bits in the bitfield will be set to "bit"

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

void BITFIELD::SetAllBits( enum BITVALUES bit )
{
    int iFiller = ( bit == ON ? 0xffff : 0x0000 ) ;

    ::memsetf( (char *)QueryBitPos( 0, QueryCount() ),
                       iFiller,
                       QueryAllocSize() ) ;

}

/*******************************************************************

    NAME:       BITFIELD::SetBit

    SYNOPSIS:   Sets a particular bit to the specified value (default is ON)

    ENTRY:      iBitPos - Index of bit to set
                bitVal  - Value to set specified bit to

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

void BITFIELD::SetBit( unsigned iBitPos, enum BITVALUES bitVal )
{
    BYTE * pbDest = QueryBitPos( iBitPos, sizeof(BYTE) ) ;

    if ( bitVal )
        *pbDest |= ( ON << QueryOffset( iBitPos ) ) ;
    else
        *pbDest &= ( ~( ON << QueryOffset( iBitPos ) ) ) ;
}

/*******************************************************************

    NAME:       BITFIELD::IsBitSet

    SYNOPSIS:   Returns BOOLEAN indicating if the specified bit is set

    ENTRY:      iBitPos is the requested bit

    RETURNS:    TRUE if the specified bit is set (ON), FALSE otherwise

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BOOL BITFIELD::IsBitSet( unsigned iBitPos ) const
{
    const BYTE * pbSrc = QueryBitPos( iBitPos, sizeof(BYTE) ) ;

    return ( *pbSrc & ( ON << QueryOffset( iBitPos ) ) );
}

/*******************************************************************

    NAME:       BITFIELD::operator=

    SYNOPSIS:   Assignment between two bitfields

    ENTRY:      bitfieldSrc is the src bitfield, this receives the copy

    NOTES:      Currently requires bitfields to be of the same size.

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BITFIELD & BITFIELD::operator=( const BITFIELD & bitfieldSrc )
{
    UIASSERT( QueryCount() == bitfieldSrc.QueryCount() ) ;

    BYTE * pbSrc  = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest = QueryBitPos( 0, QueryCount() ) ;
    ::memcpyf( (char *)pbDest, (char *)pbSrc, QueryAllocSize() ) ;

    return *this ;
}

BITFIELD & BITFIELD::operator=( USHORT usMask )
{
    UIASSERT( QueryCount() == sizeof(usMask)*8 ) ;

    *((USHORT *)QueryBitPos( 0, QueryCount() )) = usMask ;

    return *this ;
}

BITFIELD & BITFIELD::operator=( ULONG ulMask )
{
    UIASSERT( QueryCount() == sizeof(ulMask)*8 ) ;

    *((ULONG *)QueryBitPos( 0, QueryCount() )) = ulMask ;

    return *this ;
}

/*******************************************************************

    NAME:       BITFIELD::operator&=

    SYNOPSIS:   Performs a bitwise AND between *this and the passed bitfield

    ENTRY:      bitfieldSrc is the mask to apply to *this

    EXIT:       *this contains the result after the AND

    NOTES:      The two bitfields must be the same size

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

void BITFIELD::operator&=( const BITFIELD & bitfieldSrc )
{
    UIASSERT( QueryCount() == bitfieldSrc.QueryCount() ) ;

    BYTE * pbSrc = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest= QueryBitPos( 0, QueryCount() ) ;

    for ( unsigned i = QueryAllocSize() ; i != 0 ; i--, pbSrc++, pbDest++ )
        *pbDest = *pbSrc & *pbDest ;
}

/*******************************************************************

    NAME:       BITFIELD::operator|=

    SYNOPSIS:   Performs a bitwise OR between *this and the passed bitfield

    ENTRY:      bitfieldSrc is the mask to apply to *this

    EXIT:       *this contains the result after the OR

    NOTES:      The two bitfields must be the same size

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

void BITFIELD::operator|=( const BITFIELD & bitfieldSrc )
{
    UIASSERT( QueryCount() == bitfieldSrc.QueryCount() ) ;

    BYTE * pbSrc = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest= QueryBitPos( 0, QueryCount() ) ;

    for ( unsigned i = QueryAllocSize() ; i != 0 ; i--, pbSrc++, pbDest++ )
        *pbDest = *pbSrc | *pbDest ;
}

/*******************************************************************

    NAME:       BITFIELD::operator==

    SYNOPSIS:   Equality operator for the bitfield class

    ENTRY:      bitfieldSrc is the compare item

    RETURNS:    TRUE if bitfieldSrc has the same bits set as *this.

    NOTES:      Bitfields must be of the same size

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BOOL BITFIELD::operator==( BITFIELD & bitfieldSrc )
{
    if ( QueryCount() != bitfieldSrc.QueryCount() )
        return FALSE ;

    BYTE * pbSrc = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest= QueryBitPos( 0, QueryCount() ) ;

    /* Compare all bytes except for the last one (which may overhang)
     */
    for ( unsigned i = QueryAllocSize()-1 ; i != 0 ; i--, pbSrc++, pbDest++ )
    {
        if ( *pbSrc != *pbDest )
            return FALSE ;
    }

    /* For the last byte, since there might be an overhang, mask out
     * the bits we don't care about and only compare the significant
     * bits.
     */
    unsigned uOffset = QueryOffset( QueryCount() ) ;
    BYTE bMask = ((BYTE) 0xff) >> uOffset ;
    *pbSrc  &= bMask ;
    *pbDest &= bMask ;
    if ( *pbDest != *pbSrc )
        return FALSE ;

    return TRUE ;
}

BOOL BITFIELD::operator==( ULONG ulMask ) const
{
    /* If *this isn't at least as big as the ULONG mask, then assume they
     * are not equal.
     */
    if ( QueryCount() != 8*sizeof(ulMask)  ||
         ( ulMask != *( (ULONG *) QueryBitPos( 0, QueryCount())) ) )
        return FALSE ;

    return TRUE ;
}

BOOL BITFIELD::operator==( USHORT usMask ) const
{
    /* If *this isn't at least as big as the USHORT mask, then assume they
     * are not equal.
     */
    if ( QueryCount() != 8*sizeof(usMask)  ||
         ( usMask != *( (USHORT *) QueryBitPos( 0, QueryCount())) ) )
        return FALSE ;

    return TRUE ;
}

/*******************************************************************

    NAME:       BITFIELD::operator&

    SYNOPSIS:   Performs a bitwise AND of this and the passed bitfield.

    ENTRY:

    EXIT:

    RETURNS:    TRUE if any individual AND operations are TRUE, FALSE
                otherwise.

    NOTES:

    HISTORY:
        Johnl   30-Aug-1991     Created
********************************************************************/

BOOL BITFIELD::operator&( const BITFIELD & bitfieldSrc )
{
    if ( QueryCount() != bitfieldSrc.QueryCount() )
        return FALSE ;

    BYTE * pbSrc = bitfieldSrc.QueryBitPos( 0, bitfieldSrc.QueryCount() ) ;
    BYTE * pbDest= QueryBitPos( 0, QueryCount() ) ;

    /* Compare all bytes except for the last one (which may overhang)
     */
    for ( unsigned i = QueryAllocSize()-1 ; i != 0 ; i--, pbSrc++, pbDest++ )
    {
        if ( *pbSrc & *pbDest )
            return TRUE ;
    }

    /* For the last byte, since there might be an overhang, mask out
     * the bits we don't care about and only compare the significant
     * bits.
     */
    unsigned uOffset = QueryOffset( QueryCount() ) ;
    BYTE bMask = ((BYTE) 0xff) >> uOffset ;
    *pbSrc  &= bMask ;
    *pbDest &= bMask ;
    if ( *pbDest & *pbSrc )
        return TRUE ;

    return FALSE ;
}

/*******************************************************************

    NAME:       BITFIELD::operator&=

    SYNOPSIS:   Data type-wise AND operation for BYTE, unsigned & ULONG

    ENTRY:      ?Src is the input mask

    EXIT:       The lowest bits will be operated on according to the mask

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

#if 0
void BITFIELD::operator&=( BYTE     bSrc )
{
    BYTE * pbDest= QueryBitPos( 0, sizeof( bSrc ) ) ;

    *pbDest &= bSrc ;
}
#endif

void BITFIELD::operator&=( USHORT usSrc )
{
    USHORT * pusDest= (USHORT *) QueryBitPos( 0, sizeof( usSrc ) ) ;

    *pusDest &= usSrc ;
}

void BITFIELD::operator&=( ULONG    ulSrc )
{
    ULONG * pulDest= (ULONG *) QueryBitPos( 0, sizeof( ulSrc ) ) ;

    *pulDest &= ulSrc ;
}

/*******************************************************************

    NAME:       BITFIELD::operator|=

    SYNOPSIS:   Data type-wise OR operation for BYTE, unsigned & ULONG

    ENTRY:      ?Src is the input mask

    EXIT:       The lowest bits will be operated on according to the mask

    NOTES:

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

#if 0
void BITFIELD::operator|=( BYTE     bSrc )
{
    BYTE * pbDest= QueryBitPos( 0, sizeof( bSrc ) ) ;

    *pbDest |= bSrc ;
}
#endif

void BITFIELD::operator|=( USHORT usSrc )
{
    USHORT * pusDest= (USHORT *) QueryBitPos( 0, sizeof( usSrc ) ) ;

    *pusDest |= usSrc ;
}

void BITFIELD::operator|=( ULONG    ulSrc )
{
    ULONG * pulDest= (ULONG *) QueryBitPos( 0, sizeof( ulSrc ) ) ;

    *pulDest |= ulSrc ;
}

/*******************************************************************

    NAME:       BITFIELD::operator()

    SYNOPSIS:   These three methods provide easy ways to get the standard
                data types out of the bitfield.

    NOTES:
                The Bitfield must be the same size as the converted type

    HISTORY:
        Johnl   01-Aug-1991     Created

********************************************************************/

BITFIELD::operator ULONG()
{
    UIASSERT( sizeof(ULONG)*8 == QueryCount() ) ;
    return *( (ULONG *)QueryBitPos( 0, sizeof(ULONG)*8 ) ) ;
}

BITFIELD::operator USHORT()
{
    UIASSERT( sizeof(USHORT)*8 == QueryCount() ) ;
    return *((USHORT *)QueryBitPos( 0, sizeof(USHORT)*8 ) ) ;
}

#if 0
BITFIELD::operator BYTE()
{
    UIASSERT( sizeof(BYTE)*8 == QueryCount() ) ;
    return *((BYTE *)QueryBitPos( 0, sizeof(BYTE)*8 ) ) ;
}
#endif

/*******************************************************************

    NAME:       BITFIELD::QueryBitPos

    SYNOPSIS:   Returns a pointer to the BYTE the requested bit is residing
                in

    ENTRY:      iBitOffset is the bit number (or starting bit number) we
                        are interested in.
                cbitsTargetOpSize is the count of bits we will read from
                        or write to.  This value is used for bounds checking.

    RETURNS:    Pointer to the BYTE that contains the requested bit

    NOTES:
                We assert out if the operation is going to go past the
                end of the bitfield or the requested bit is beyond the
                end of the bitfield.

    HISTORY:
        Johnl   31-Jul-1991     Created

********************************************************************/

BYTE * BITFIELD::QueryBitPos( unsigned iBitOffset,
                              unsigned cbitsTargetOpSize ) const
{
    UIASSERT( QueryError() == NERR_Success ) ;

    /* Assert out if the requested bit is out of range
     */
    UIASSERT( iBitOffset < QueryCount() ) ;

    /* Assert out if the operation to be performed will cause us to
     * go out of range
     */
    UIASSERT( iBitOffset + cbitsTargetOpSize <= QueryCount() ) ;

    BYTE * pbBitVec = ( IsAllocated() ? _pbBitVector : (BYTE *)&_ulBitfield ) ;

    return ( pbBitVec + iBitOffset / 8 ) ;
}

/*******************************************************************

    NAME:       BITFIELD::Not

    SYNOPSIS:   Performs a bitwise complement of the bitfield (i.e., '~')

    NOTES:

    HISTORY:
        Johnl   30-Aug-1991     Created
********************************************************************/

void BITFIELD::Not( void )
{
    BYTE * pbSrc = QueryBitPos( 0, QueryCount() ) ;

    for ( unsigned i = QueryAllocSize() ; i != 0 ; i--, pbSrc++ )
    {
        *pbSrc = ~*pbSrc ;
    }
}

/*******************************************************************

    NAME:       BITFIELD::AllocBitfield

    SYNOPSIS:   Sets up bitfield and allocates memory if necessary

    ENTRY:

    EXIT:       All of the size related members are set properly

    RETURNS:    NERR_Success if successful

    NOTES:      (JonN 10/13/94) This is completely wrong, I'm
                amazed we ever got away with it.  We free the old vector
                if the new one is >32 bits, not if the old one is greater
                than 32 bits.

    HISTORY:
        Johnl   31-Jul-1991     Created
        Johnl   18-Sep-1991     Will snap back if the allocation fails

********************************************************************/

APIERR BITFIELD::AllocBitfield( unsigned cBitsInBitfield )
{
    unsigned cBitsInBitFieldTemp = _cBitsInBitfield ;
    _cBitsInBitfield = cBitsInBitfield ;

    if ( QueryMaxNonAllocBitCount() < QueryCount() )
    {
        BYTE * pbTemp = _pbBitVector ;

        if (  (_pbBitVector = new BYTE[ QueryAllocSize() ]) == NULL )
        {
            /* "Snap" back if we fail
             */
            _cBitsInBitfield = cBitsInBitfield ;
            _pbBitVector = pbTemp ;
            return ERROR_NOT_ENOUGH_MEMORY ;
        }
        else
        {
            delete pbTemp ;
        }
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:       BITFIELD::Resize

    SYNOPSIS:   Dynamically resizes the bitfield (contents are not
                preserved).

    ENTRY:      cBitsInBitfield - Count of bytes to resize this bitfield to

    RETURNS:    NERR_Success if successful

    NOTES:

    HISTORY:
        Johnl   18-Sep-1991     Created

********************************************************************/

APIERR BITFIELD::Resize( unsigned cBitsInBitfield )
{
    return AllocBitfield( cBitsInBitfield ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\blt\pch\bltwin.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    bltwin.cxx
    BLT base window class definitions

    FILE HISTORY:
        rustanl     20-Nov-1990 Created
        beng        11-Feb-1991 Uses lmui.hxx
        beng        14-May-1991 Exploded blt.hxx into components
        terryk      10-Jul-1991 Added IsEnable to Window class
        beng        31-Jul-1991 Reloc'd fClientGen'dMsg to class
        terryk      12-Aug-1991 Change QueryWindowRect to QueryClient
                                window rect
        terryk      20-Aug-1991 Change QueryClientRect back to
                                QueryWindowRect
        beng        30-Sep-1991 Added ASSOCHWNDTHIS class
        beng        18-Oct-1991 Threw in some tracing
        Yi-Hsins     8-Jan-1991 Added HasFocus method
        terryk      02-Apr-1992 Added Z position in SetPos
        terryk      28-Apr-1992 fixed Z position problem in SetPos
        KeithMo     11-Nov-1992 Added new ctor form and Center method.
        Yi-HsinS    10-Dec-1992 Added CalcFixedHeight
        DavidHov    17-Sep-1993 Changes for C8 and re-dllization
*/


#include "pchblt.hxx"   // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

#define WIN32_REMOVEPROP_BUG 1

// Indicates that the message was generated internally and not
// by the user manipulating controls.
//
BOOL WINDOW::_fClientGeneratedMessage = FALSE;

const TCHAR * ASSOCHWNDTHIS::_pszPropThisLo = SZ("BltPropThisL");
const TCHAR * ASSOCHWNDTHIS::_pszPropThisHi = SZ("BltPropThisH");


#if defined(DEBUG) && defined(TRACE) && 0
DBGSTREAM& operator<<(DBGSTREAM &out, const WINDOW * pwnd)
{
    TCHAR szBuf[12];
    FMT(szBuf, SZ("%lx"), (ULONG)pwnd);
    out << SZ("WINDOW ") << szBuf;

    return out;
}

DBGSTREAM& operator<<(DBGSTREAM &out, HWND hwnd)
{
    out << (ULONG)hwnd;

    return out;
}
#endif

inline INT max(INT a, INT b)
{
    return (a > b) ? a : b;
}

/**********************************************************************

    NAME:       WINDOW::WINDOW

    SYNOPSIS:   Constructor for the WINDOW object.

    ENTRY:      Without parameters, leaves an empty object which can
                later adopt an existing window (via SetHwnd).

        - or -

                pszClassName - class name of window class
                flStyle      - dword of style bits
                pwndOwner    - pointer to owner window
                cid          - control ID.  Default is 0, which
                               means no ID (and no menu if not
                               a WS_CHILD).


    NOTES:
        The parmless WINDOW object does no real construction;
        rather, it is a repository for a large body of common
        methods and information, much of which can only be
        calculated well into the construction process by one
        of its derived classes.  Hence this version of the ctor
        does nearly nothing.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        25-Apr-1991 Removed unused hwndOwner parm
        beng        07-May-1991 Added CreateWindow versions
        beng        15-May-1991 Added CID child-window support
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

WINDOW::WINDOW(
    const TCHAR * pszClassName,
    ULONG         flStyle,
    const WINDOW *pwndOwner,
    CID           cid )
    : _hwnd(NULL),
      _fCreator(FALSE)
{
    // CODEWORK: make these const with C7

    UIASSERT( ((cid == 0) || (flStyle & WS_CHILD)) );

    HWND hwndOwner = (pwndOwner == 0) ? 0 : pwndOwner->_hwnd;

    HWND hwnd = ::CreateWindow(pszClassName,
                               SZ(""), flStyle,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               CW_USEDEFAULT,
                               hwndOwner, (HMENU)LongToHandle(cid), hmodBlt, 0);
    if (hwnd == 0)
    {
        ReportError(hwnd == 0);
        return;
    }

    _hwnd = hwnd;
    _fCreator = TRUE;
}


WINDOW::WINDOW()
    : _hwnd( NULL ),
    _fCreator( FALSE )
{
    ; // nothing else to do
}


WINDOW::WINDOW( HWND hwnd )
    : _hwnd( hwnd ),
    _fCreator( FALSE )
{
    ; // nothing else to do
}


/**********************************************************************

    NAME:       WINDOW::~WINDOW

    SYNOPSIS:   Destructor of WINDOW

    ENTRY:      Valid WINDOW base.  If _fCreator set, has a window
                object (id'd by _hwnd) which it needs to destroy.

    EXIT:       Window destroyed

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990     Created
        beng        07-May-1991     Added DestroyWindow function

**********************************************************************/

WINDOW::~WINDOW()
{
    if (_fCreator)
    {
        if (!::DestroyWindow(_hwnd))
        {
            DWORD err = ::GetLastError();
            DBGEOL( "NETUI: WINDOW::dtor: DestroyWindow( " << ((DWORD)(DWORD_PTR)_hwnd)
                    << " ) failed with error " << err );
            // ASSERT( FALSE ); removing again
        }
    }
}


/*******************************************************************

    NAME:       WINDOW::ResetCreator

    SYNOPSIS:   Resets the fCreator flag

    ENTRY:      fCreator is set; presumably, we just noticed that
                some cad called DestroyWindow(this->QueryHwnd()).

    EXIT:       fCreator is clear

    NOTES:
        This is for when ClientWindow notices that some outside
        agency called DestroyWindow on its window.  Under normal
        circumstances it should never run.

    HISTORY:
        beng        10-May-1991     Created

********************************************************************/

VOID WINDOW::ResetCreator()
{
    UIASSERT(_fCreator);
    _fCreator = FALSE;
}


/*******************************************************************

    NAME:       WINDOW::SetHwnd

    SYNOPSIS:   Sets the window-handle member of WINDOW.
                This is integral to complete object construction
                (i.e. including derived classes).

    ENTRY:      hwnd - new value of window handle

    EXIT:       _hwnd has been set

    NOTES:
        This method should be called only once in the lifetime of
        a window.

    HISTORY:
        beng        25-Apr-1991     Relocated to here from class def'n
        beng        07-May-1991     Updated to honor _fCreator

********************************************************************/

VOID WINDOW::SetHwnd( HWND hwnd )
{
    UIASSERT(!_fCreator);   // better not have created any window
    UIASSERT(_hwnd == 0);   // or for that matter have already called this

    _hwnd = hwnd;
}


/*******************************************************************

    NAME:       WINDOW::QueryHwnd

    SYNOPSIS:   Return the Windows HWND associated with the WINDOW

    RETURNS:    the value of _hwnd

    NOTES:

    HISTORY:
        beng        25-Apr-1991     Relocated to here from class def'n

********************************************************************/

HWND WINDOW::QueryHwnd() const
{
    return _hwnd;
}


/**********************************************************************

    NAME:       WINDOW::QueryOwnerHwnd

    SYNOPSIS:   Return the hwnd of the window's owner

    RETURNS:    HWND of window's owner

    NOTES:

    HISTORY:
       beng     25-Apr-1991 Moved out of the class def'n
       beng     09-Oct-1991 Win32 conversion

***********************************************************************/

HWND WINDOW::QueryOwnerHwnd() const
{
#if defined(WIN32)
    return (HWND) ::GetWindowLongPtr( _hwnd, GWLP_HWNDPARENT );
#else
    return (HWND) ::GetWindowWord( _hwnd, GWW_HWNDPARENT );
#endif
}


/**********************************************************************

    NAME:       WINDOW::Command

    SYNOPSIS:   This method sends a message to the window.

    ENTRY:
        usMsg               Message
        wParam, lParam      Message parameters

    RETURNS:    The return code of the message.

    CAVEATS:
        This method is obviously not host environment independent.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

ULONG_PTR WINDOW::Command( UINT nMsg, WPARAM wParam, LPARAM lParam ) const
{
    return ::SendMessage( _hwnd, nMsg, wParam, lParam );
}


/**********************************************************************

    NAME:       WINDOW::QueryStyle

    SYNOPSIS:   Return the style bits for the window

    RETURNS:    Style bits (dword)

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

ULONG WINDOW::QueryStyle() const
{
    return (ULONG) ::GetWindowLong( _hwnd, GWL_STYLE );
}


/**********************************************************************

    NAME:       WINDOW::SetStyle

    SYNOPSIS:   Set the style bits for the window

    NOTES:
        This is a protected member function, intended to allow controls
        to change their style.

    HISTORY:
        beng        13-Feb-1992 Created

**********************************************************************/

VOID WINDOW::SetStyle( ULONG nValue )
{
    ::SetWindowLong( _hwnd, GWL_STYLE, (LONG)nValue );
}


/**********************************************************************

    NAME:       WINDOW::QueryClientRect

    SYNOPSIS:   get the client coordinates of a window's client area

    ENTRY:      RECT * pRect - the returned coordinates

    EXIT:       RECT * pRect - fill the data structure with the window's
                               coordinates.

    NOTES:
        Consider instead constructing an XYRECT with this window
        as a parameter.

    HISTORY:
        terryk      20-Jul-1991 Created
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Added XYRECT version

**********************************************************************/

VOID WINDOW::QueryClientRect( RECT * pRect ) const
{
    ::GetClientRect( _hwnd, pRect );
}

VOID WINDOW::QueryClientRect( XYRECT * pxyxy ) const
{
    XYRECT xyxy( _hwnd, TRUE );
    *pxyxy = xyxy;
}


/*********************************************************************

    NAME:       WINDOW::QueryWindowRect

    SYNOPSIS:   get the window's screen coordinate

    ENTRY:      RECT *pRect - rectangle data structure to store the
                information.

    NOTES:
        Consider instead constructing an XYRECT with this window
        as a parameter.

    HISTORY:
        terryk      2-Aug-1991  Created
        beng        09-Oct-1991 Added XYRECT version

**********************************************************************/

VOID WINDOW::QueryWindowRect( RECT * pRect ) const
{
    ::GetWindowRect( _hwnd, pRect );
}

VOID WINDOW::QueryWindowRect( XYRECT * pxyxy ) const
{
    XYRECT xyxy( _hwnd, FALSE );
    *pxyxy = xyxy;
}


/**********************************************************************

    NAME:       WINDOW::SetText

    SYNOPSIS:
        This method sets the text of a window.  The text of an application
        window or dialog is the caption, whereas it is the text contents of
        a controls for many controls.

    ENTRY:
         psz             A pointer to the text
     or
         nls             NLS text string

    EXIT:

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        rustanl     27-Apr-1991 Changed PSZ to const TCHAR *
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

VOID WINDOW::SetText( const TCHAR * psz )
{
    SetClientGeneratedMsgFlag( TRUE ) ;
    ::SetWindowText( _hwnd, psz );
    SetClientGeneratedMsgFlag( FALSE ) ;
}


VOID WINDOW::SetText( const NLS_STR & nls )
{
    SetClientGeneratedMsgFlag( TRUE ) ;
    ::SetWindowText( _hwnd, nls.QueryPch() );
    SetClientGeneratedMsgFlag( FALSE ) ;
}


/**********************************************************************

    NAME:       WINDOW::QueryText

    SYNOPSIS:   Returns the text of a window.

    ENTRY:
        pszBuffer   A pointer to a buffer, where the window text
                    will be copied.
        cbBufSize   The size of this buffer.  The window text
                    copied to the buffer will be truncated if
                    the buffer is not big enough.

            - or -

        pnls        Pointer to a NLS_STR

    RETURNS:
        0 if successful; NERR_BufTooSmall if given buffer too small.

    NOTES:
        The length of the window text can be retrieved by calling
        WINDOW::QueryTextLength, while the storage needed to copy
        that text is available via WINDOW::QueryTextSize.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        23-May-1991 Changed return type; made const
        beng        10-Jun-1991 Tinkered for Unicode
        beng        04-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

**********************************************************************/

APIERR WINDOW::QueryText( TCHAR * pszBuffer, UINT cbBufSize ) const
{
    UINT cbActual = QueryTextSize();

    if (cbBufSize < cbActual)
        return NERR_BufTooSmall;

    if (cbBufSize > 0 && pszBuffer == NULL)
        return ERROR_INVALID_PARAMETER;

    // This Win API works in total TCHARs, including terminator.
    //
    ::GetWindowText(_hwnd, (TCHAR *)pszBuffer, cbBufSize/sizeof(TCHAR) );

    return 0;
}

APIERR WINDOW::QueryText( NLS_STR * pnls ) const
{
    if (pnls == NULL)
        return ERROR_INVALID_PARAMETER;

    UINT cbActual = QueryTextSize();

    BLT_SCRATCH scratch( cbActual );
    if (!scratch)
        return scratch.QueryError();

    ::GetWindowText( _hwnd,
                     (TCHAR*)scratch.QueryPtr(),
                     scratch.QuerySize()/sizeof(TCHAR) );

    return pnls->CopyFrom((TCHAR*)scratch.QueryPtr());
}


/**********************************************************************

    NAME:       WINDOW::QueryTextLength

    SYNOPSIS:   Returns the length of the window text.
                See WINDOW::SetText for a description of "window text".

    RETURNS:    The length, in actual characters (as opposed to the
                byte-characters of strlen), of the window text.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        23-May-1991 Made const
        beng        10-Jun-1991 Changed return type
        beng        09-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

***********************************************************************/

INT WINDOW::QueryTextLength() const
{
    return ::GetWindowTextLength( _hwnd );
}


/*******************************************************************

    NAME:       WINDOW::QueryTextSize

    SYNOPSIS:   Returns the byte count of the window text,
                including the terminating character

    RETURNS:    Count of bytes

    NOTES:

    HISTORY:
        beng        10-Jun-1991 Created
        beng        09-Oct-1991 Win32 conversion
        beng        30-Apr-1992 API changes

********************************************************************/

INT WINDOW::QueryTextSize() const
{
    INT cchRet = ::GetWindowTextLength( _hwnd );

    return (cchRet + 1) * sizeof(TCHAR);
}


/**********************************************************************

    NAME:       WINDOW::ClearText

    SYNOPSIS:   Clears the window text of the window.

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID WINDOW::ClearText()
{
    SetText( SZ("") );
}


/**********************************************************************

    NAME:       WINDOW::Show

    SYNOPSIS:   This method shows or hides a window.

    ENTRY:
       f        Indicates whether to show or hide the window:
                TRUE to show the window, and FALSE to hide it.

    RETURNS:    The previous state of the windows:
                  FALSE if the window was previously hidden
                  TRUE if the window was previously visible

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

BOOL WINDOW::Show( BOOL f )
{
    return ::ShowWindow( _hwnd, ( f ? SW_SHOW : SW_HIDE ));
}


/**********************************************************************

    NAME:       WINDOW::Enable

    SYNOPSIS:   Enables or disables a window.

    ENTRY:
        f       Indicates whether to enable or disable the
                window:  TRUE to enable, and FALSE to disable.

    EXIT:
        Window is enabled or disabled (duh) as requested.

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion
        beng        26-Dec-1991 With full understanding, removed some tracery

**********************************************************************/

VOID WINDOW::Enable( BOOL f )
{
    if ( f != IsEnabled() )
    {
        ::EnableWindow( _hwnd, f );
    }
}


/*********************************************************************

    NAME:       WINDOW::IsEnabled

    SYNOPSIS:   return the current status of the window

    RETURN:     return TRUE if the window is enable, FALSE if the window
                is disable.

    HISTORY:
        terryk      8-Jul-91    Created
        beng        09-Oct-1991 Win32 conversion

**********************************************************************/

BOOL WINDOW::IsEnabled() const
{
    return !! ::IsWindowEnabled( _hwnd );
}


/**********************************************************************

    NAME:       WINDOW::SetRedraw

    SYNOPSIS:   Sets or clears the redraw flag of the window.

    ENTRY:
       f        Indicates whether to set or clear the redraw flag.
                TRUE sets it, whereas FALSE clears it.
                TRUE is the default value for this parameter.

    EXIT:

    NOTES:
        Setting the redraw flag on does not refresh listboxes.

    HISTORY:
        rustanl     20-Nov-1990     Created

**********************************************************************/

VOID WINDOW::SetRedraw( BOOL f )
{
    Command( WM_SETREDRAW, f );
}


/**********************************************************************

    NAME:       WINDOW::Invalidate

    SYNOPSIS:   Invalidates some or all of the client area of the window.

    ENTRY:
       fErase   Indicates whether the window's background is to
                be erased (default FALSE).  This version invalidates
                the entire client region.

       rect     Rectangle to invalidate within client area.  This version
                doesn't erase.

    NOTES:

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        09-Oct-1991 Win32 conversion
        beng        13-Feb-1992 Rolled in CLIENT_WINDOW::Repaint

**********************************************************************/

VOID WINDOW::Invalidate( BOOL fErase )
{
    ::InvalidateRect( _hwnd, NULL, fErase );
}

VOID WINDOW::Invalidate( const XYRECT & rect )
{
    ::InvalidateRect( _hwnd, (RECT*)(const RECT *)rect, FALSE );
}


/*******************************************************************

    NAME:       WINDOW::RepaintNow

    SYNOPSIS:   Force an immediate repaint of the window

    EXIT:       Window is completely valid, and has been repainted
                irregardless of outstanding PAINT messages

    HISTORY:
        beng        10-May-1991 Implemented
        beng        13-Feb-1992 Relocated to WINDOW from CLIENT_WINDOW

********************************************************************/

VOID WINDOW::RepaintNow()
{
    ::UpdateWindow( _hwnd );
}


/*******************************************************************

    NAME:       WINDOW::ShowFirst

    SYNOPSIS:   The first "Show" call for a client or owned window

    ENTRY:      Window has never been shown - just created

    EXIT:       Window is visible on screen

    NOTES:
        A window's creator should make this call when it is ready
        for the window to appear.

    HISTORY:
        beng        31-Jul-1991     Created

********************************************************************/

VOID WINDOW::ShowFirst()
{
    Show(TRUE);
    Invalidate(FALSE);
}


/*******************************************************************

    NAME:      WINDOW::SetPos

    SYNOPSIS:  Moves a windows to the new cooridinates

    ENTRY:     xy - New position of window,
               fRepaint = TRUE if repaint after move
               WINDOW *pwin - the Z value for the control.
                      The TAB order of the control is placed after pwin.
                      If pwin is NULL, the tab order of the control
                      will be the same as its position in the resource
                      file or according to its creation time.

    NOTES:     Cooridinates are relative to:
                Screen if pop-up window
                Client if child window

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Uses XYPOINT
        beng        09-Oct-1991 Win32 conversion
        terryk      02-Apr-1992 Added Z position

********************************************************************/

VOID WINDOW::SetPos( XYPOINT xy, BOOL fRepaint, WINDOW *pwin )
{
#if 0 // this is the old way - required a Query before could Set
    INT nWidth, nHeight;

    QuerySize( &nWidth, &nHeight );

    ::MoveWindow( _hwnd, xy.QueryX(), xy.QueryY(),
                  nWidth, nHeight, fRepaint );
#else
    ::SetWindowPos(_hwnd, ( pwin == NULL ) ? 0 : pwin->QueryHwnd(),
                   xy.QueryX(), xy.QueryY(), 0, 0,
                   ((( pwin == NULL ) ?  SWP_NOZORDER : 0 ) | SWP_NOSIZE |
                   (fRepaint?0:SWP_NOREDRAW)));
#endif
}


/*******************************************************************

    NAME:       WINDOW::QueryPos

    SYNOPSIS:   Get the current position (top left corner) of *this

    RETURNS:    Current position of window

    NOTES:
        Cooridinates are relative to:
        Screen if pop-up window
        Client area of parent if child window

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Added XYPOINT version
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Withdrew vanilla POINT version

********************************************************************/

XYPOINT WINDOW::QueryPos() const
{
    RECT rc;
    ::GetWindowRect(_hwnd, &rc);

    XYPOINT xy(rc.left, rc.top);

    /* If the window is a child window, then we need to get the coordinates
     * relative to the parent's client area
     */
    if (IsChild())
        xy.ScreenToClient(QueryOwnerHwnd());

    return xy;
}


/*******************************************************************

    NAME:       WINDOW::SetSize

    SYNOPSIS:   Sets the width and height of a window

    ENTRY:      nWidth, nHeight - width and height for window
                -or-
                dxy - desired dimensions of window

    EXIT:

    NOTES:
        Size is not the client area, but full size including borders,
        menus and captions.

        This command causes the window to receive OnMove and OnSize
        events.

    HISTORY:
        Johnl        7-Feb-91   Created
        beng        15-May-1991 Added XYDIM version
        beng        09-Oct-1991 Win32 conversion

********************************************************************/

VOID WINDOW::SetSize( INT cxWidth, INT cyHeight, BOOL fRepaint )
{
#if 0 // this is the old way - required a Query before could Set
    XYPOINT xy = QueryPos();

    ::MoveWindow( _hwnd, xy.QueryX(), xy.QueryY(),
                  cxWidth, cyHeight, fRepaint );

#else

    ::SetWindowPos(_hwnd, 0, 0, 0, cxWidth, cyHeight,
                   (SWP_NOZORDER|SWP_NOMOVE|(fRepaint?0:SWP_NOREDRAW)));
#endif
}

VOID WINDOW::SetSize( XYDIMENSION dxy, BOOL fRepaint )
{
    SetSize(dxy.QueryWidth(), dxy.QueryHeight(), fRepaint);
}


/*******************************************************************

    NAME:      WINDOW::QuerySize

    SYNOPSIS:  Get the current size of this window

    ENTRY:     pnWidth, pnHeight - pointers to receive
                                   current size of window

    EXIT:
        If px, py supplied, they've been loaded with X and Y.

        Otherwise, returns XYDIM.

    NOTES:

    HISTORY:
        Johnl       7-Feb-91    Created
        beng        15-May-1991 Added XYDIM version
        beng        31-Jul-1991 Made const
        beng        09-Oct-1991 Win32 conversion

********************************************************************/

VOID WINDOW::QuerySize( INT *pnWidth, INT *pnHeight ) const
{
    RECT rcRect;
    ::GetWindowRect(_hwnd, &rcRect);

    *pnWidth  = rcRect.right - rcRect.left;
    *pnHeight = rcRect.bottom - rcRect.top;
}

XYDIMENSION WINDOW::QuerySize() const
{
    INT dx, dy;

    QuerySize(&dx, &dy);

    return XYDIMENSION(dx, dy);
}


/*******************************************************************

    NAME:       WINDOW::IsChild

    SYNOPSIS:   Determine whether window has CHILD style

    RETURNS:    TRUE if the WS_CHILD window style bits are set for window

    NOTES:

    HISTORY:
        Johnl       14-Feb-1991     Created
        beng        31-Jul-1991     Made 'const'

********************************************************************/

BOOL WINDOW::IsChild() const
{
    return ( WS_CHILD & QueryStyle() ) != 0 ;
}


/*******************************************************************

    NAME:     WINDOW::SetClientGeneratedMsgFlag

    SYNOPSIS: Sets the global flag _fClientGeneratedMessage.

    NOTES:
      Set to TRUE if this is a message we generated ourselves (and you don't
      want the shell dialog proc. to "process" it (i.e., send out notices
      to children etc.).  Be careful you only use this on messages that are
      sent immediately.

    HISTORY:
        Johnl       26-Apr-1991     Created

********************************************************************/

VOID WINDOW::SetClientGeneratedMsgFlag( BOOL fInClientGeneratedMessage )
{
    _fClientGeneratedMessage = fInClientGeneratedMessage;
}


/*******************************************************************

    NAME:     WINDOW::IsClientGeneratedMsg

    SYNOPSIS: Returns TRUE if the _fClientGeneratedMessage flag is set.
              This means the current message is a message we should
              ignore.

    HISTORY:
        Johnl       26-Apr-1991     Created

********************************************************************/

BOOL WINDOW::IsClientGeneratedMessage()
{
    return _fClientGeneratedMessage;
}


/*******************************************************************

    NAME:     WINDOW::HasFocus

    SYNOPSIS: Returns TRUE if the current window has the focus.

    HISTORY:
        Yi-HsinS    8-Jan-1992     Created

********************************************************************/

BOOL WINDOW::HasFocus( VOID ) const
{
    return ( QueryHwnd() == ::GetFocus() );
}


/*******************************************************************

    NAME:     WINDOW::Center

    SYNOPSIS: Centers the window above another window.

    ENTRY:    hwnd      - The window to center *this over.  If this
                          value is NULL, then the window is centered
                          over its parent.

    CODEWORK: It may be more aesthetically appealing to center
              child windows their parent's client area, rather
              than over the parent's window proper.

    HISTORY:
        KeithMo    11-Nov-1992     Created.

********************************************************************/

VOID WINDOW::Center( HWND hwnd )
{
    //
    //  If no window was specified, use the parent.
    //  If there is no parent, use the screen size.
    //

    INT xThis;
    INT yThis;

    XYRECT xycdThis;
    UIASSERT( !!xycdThis );

    QueryWindowRect( &xycdThis );

    if( hwnd == NULL )
    {
        hwnd = QueryOwnerHwnd();
    }

    if( hwnd == NULL )
    {
        HDC hdc;

        hdc = GetDC(_hwnd);
        if (!hdc) // JonN 01/23/00: PREFIX bug 444891
            return;

        xThis =  ( GetDeviceCaps(hdc, HORZRES) - xycdThis.CalcWidth()  ) / 2;

        yThis =  ( GetDeviceCaps(hdc, VERTRES) - xycdThis.CalcHeight() ) / 3;

        (void) ReleaseDC( _hwnd, hdc ); // JonN 01/23/00: PREFIX bug 444892
    }
    else
    {
        WINDOW windowParent( hwnd );
        UIASSERT( !!windowParent );

        //
        //  Get the bounding rectangles of this window & the
        //  parent window.  Note that QueryWindowRect returns
        //  *screen* coordinates!
        //

        XYRECT xycdParent;
        UIASSERT( !!xycdParent );

        windowParent.QueryWindowRect( &xycdParent );

        //
        //  Calculate the new window position relative
        //  to the parent.
        //

        xThis = xycdParent.QueryLeft() +
                ( xycdParent.CalcWidth()  - xycdThis.CalcWidth()  ) / 2;
        yThis = xycdParent.QueryTop() +
                ( xycdParent.CalcHeight() - xycdThis.CalcHeight() ) / 3;

    }

    XYPOINT xyThis( xThis, yThis );

    //
    //  Move the window into position.  The SetWindowPos API
    //  is documented as taking client coordinates when
    //  dealing with child windows, but it seems to actually
    //  want screen coordinates.
    //

    SetPos( xyThis );
}

/* Maximum height we expect bitmaps to be in the owner drawn list boxes
 */
const USHORT yMaxCDBitmap = 16;

/*******************************************************************

    NAME:       WINDOW::CalcFixedHeight

    SYNOPSIS:   Calculate height of fixed-size (single line) owner-draw object

    ENTRY:      hwnd   - handle to the window
                pmis   - as passed by WM_MEASUREITEM in lParam

    EXIT:

    RETURNS:    FALSE if the calculation fails for some reason

    NOTES:
        This is a static member of the class.

        This WM_MEASUREITEM message is sent before the
        WM_INITDIALOG message (except for variable size owner-draw
        list controls).  Since the window properties are not yet set
        up, the owner dialog cannot be called.

        The chosen solution for list controls is to assume that every
        owner-draw control will always have the same height as the font
        of that list control.  This is a very reasonable guess for most
        owner-draw list controls.  Since owner-draw list controls with
        variable size items call the owner for every item, the window
        properties will have been properly initialized by that time.  Hence,
        a client may respond to these messages through OnOther.

        Currently, owner-draw buttons are not supported.

    HISTORY:
        beng        21-May-1991 Created, from old BltDlgProc
        Yi-HsinS    10-Dec-1992 Moved from bltowin.cxx

********************************************************************/

BOOL WINDOW::CalcFixedHeight( HWND hwnd, UINT *pnHeight )
{
    DISPLAY_CONTEXT dc( hwnd );

    HFONT hFont = (HFONT)::SendMessage( hwnd, WM_GETFONT, 0, 0L );
    if ( hFont != NULL )
    {
        // Font isn't the system font
        dc.SelectFont( hFont );
    }

    TEXTMETRIC tm;
    if ( ! dc.QueryTextMetrics( &tm ))
        return FALSE;

    *pnHeight = max((USHORT)tm.tmHeight, yMaxCDBitmap);

    return TRUE;
}

/*******************************************************************

    NAME:       ASSOCHWNDTHIS::ASSOCHWNDTHIS

    SYNOPSIS:   Associates a hwnd with a pwnd

    ENTRY:      hwnd - handle of window
                pwnd - pointer to WINDOW

    EXIT:       Window has two properties added

    NOTES:
        This class inherits from BASE.  If the association fails,
        it will report an error.

    HISTORY:
        beng        30-Sep-1991 Created
        beng        07-Nov-1991 Error mapping

********************************************************************/

ASSOCHWNDTHIS::ASSOCHWNDTHIS( HWND hwnd, const VOID * pv )
    : _hwnd(hwnd)
{
    if (hwnd == 0 || pv == 0)
    {
        ReportError( ERROR_INVALID_PARAMETER );
        return;
    }

#ifdef _WIN64
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)pv ))
    {
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
#else
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)LOWORD( (ULONG_PTR)pv )))
    {
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
    if ( !::SetProp( hwnd, (TCHAR*)_pszPropThisHi, (HANDLE)HIWORD( (ULONG_PTR)pv )))
    {
        ::RemoveProp( hwnd, (TCHAR*)_pszPropThisLo );
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
        return;
    }
#endif
}


/*******************************************************************

    NAME:       ASSOCHWNDTHIS::~ASSOCHWNDTHIS

    SYNOPSIS:   Disassociate a hwnd from the WINDOW object.

    ENTRY:      There are two properties on the hwnd which
                contain the seg:off of the WINDOW object.

    EXIT:       Those two props are dust

    NOTES:
        This might seem unnecessary - after all, won't the
        DestroyWindow delete these properties?

    HISTORY:
        beng        10-May-1991 Created as CLIENT_WINDOW::DisassocHwndPwnd
        beng        30-Sep-1991 Made own class
        beng        04-Jun-1992 A little error checking needed here

********************************************************************/

ASSOCHWNDTHIS::~ASSOCHWNDTHIS()
{
    if (QueryError() == NERR_Success)
    {
#if defined(WIN32) && defined(WIN32_REMOVEPROP_BUG)
        ::SetProp( _hwnd, (TCHAR*)_pszPropThisLo, (HANDLE)0 );
        ::SetProp( _hwnd, (TCHAR*)_pszPropThisHi, (HANDLE)0 );
#else
        ::RemoveProp( _hwnd, (TCHAR*)_pszPropThisLo );
        ::RemoveProp( _hwnd, (TCHAR*)_pszPropThisHi );
#endif
    }
}


/*******************************************************************

    NAME:       ASSOCHWNDTHIS::HwndToThis

    SYNOPSIS:   Given a hwnd, locate the corresponding object

    ENTRY:      hwnd - window handle returned by Windows

    RETURNS:    Pointer to some anonymous object, or NULL
                if nothing found

    NOTES:
        This is a static member function.

    HISTORY:
        beng        10-May-1991 Created as CLIENT_WINDOW::HwndToPwnd
        beng        30-Sep-1991 Made own class

********************************************************************/

VOID * ASSOCHWNDTHIS::HwndToThis( HWND hwnd )
{
    // GetProp returns 0 if it fails; hence these two will build
    // one 0L if they fail.
    //
#ifdef _WIN64
    return ::GetProp( hwnd, (TCHAR*)_pszPropThisLo );
#else
    return (VOID *)MAKELONG( ::GetProp( hwnd, (TCHAR*)_pszPropThisLo ),
                             ::GetProp( hwnd, (TCHAR*)_pszPropThisHi ));
#endif
}


/*********************************************************************

    NAME:       PROC_INSTANCE::PROC_INSTANCE

    SYNOPSIS:   constructor - create a Proc Instance

    ENTRY:      FARPROC fp

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-Oct-1991 Win32 conversion

**********************************************************************/

PROC_INSTANCE::PROC_INSTANCE( MFARPROC fp )
#if defined(WIN32)
    : _fpInstance(fp)
#else
    : _fpInstance( ::MakeProcInstance( fp, BLT::QueryInstance() ))
#endif
{
    if ( _fpInstance == NULL )
    {
        //  Assume memory failure
        ReportError( BLT::MapLastError(ERROR_NOT_ENOUGH_MEMORY) );
    }
}


/*********************************************************************

    NAME:       PROC_INSTANCE::~PROC_INSTANCE

    SYNOPSIS:   destructor - free the procedure instance

    HISTORY:
        rustanl     20-Nov-1990 Created
        beng        17-Oct-1991 Win32 conversion

**********************************************************************/

PROC_INSTANCE::~PROC_INSTANCE()
{
#if !defined(WIN32)
    if ( _fpInstance != NULL )
    {
        ::FreeProcInstance( _fpInstance );
# if defined(DEBUG)
        _fpInstance = NULL;
# endif
    }
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\collect\lhourset.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lhourset.cxx

    This file contains the implementation for the class
    LOGON_HOURS_SETTING, which communicates between LMOBJ and BLTCC.

    FILE HISTORY:
        beng        06-May-1992 Created (from lmouser.cxx)

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

#include "lhourset.hxx"


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::LOGON_HOURS_SETTING

    SYNOPSIS:   constructor for the LOGON_HOURS_SETTING object

    ENTRY:      pLogonHours -   packed bit block
                unitsperweek -  number of bits in LogonHours block

                default means new user defaults

    EXIT:       Object is constructed

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

LOGON_HOURS_SETTING::LOGON_HOURS_SETTING( const BYTE * pbLogonHours,
                                          UINT unitsperweek )
    : BASE(),
      _cUnitsPerWeek( 0 ),
      _buf()
{
    APIERR err = _buf.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ( pbLogonHours == NULL )
        err = MakeDefault();
    else
        err = SetFromBits( pbLogonHours, unitsperweek );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

LOGON_HOURS_SETTING::LOGON_HOURS_SETTING( const LOGON_HOURS_SETTING & lhours )
    : BASE(),
      _cUnitsPerWeek( 0 ),
      _buf()
{
    APIERR err = _buf.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    err = Set( lhours );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::~LOGON_HOURS_SETTING

    SYNOPSIS:   destructor for the LOGON_HOURS_SETTING object

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

LOGON_HOURS_SETTING::~LOGON_HOURS_SETTING()
{
    // Does nothing further of any interest (BUFFER dtor does all)
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::SetFromBits

    SYNOPSIS:   Changes logon hours setting

    ENTRY:      unitsperweek -  number of bits in LogonHours block
                pLogonHours -   packed bit block

    RETURNS:    Standard error code

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::SetFromBits( const BYTE * pLogonHours,
                                         UINT unitsperweek )
{
    UINT cb = QueryByteCount( unitsperweek );

    APIERR err = _buf.Resize( cb );
    if ( err != NERR_Success )
        return err;

    BYTE * pNewLogonHours = _buf.QueryPtr();

    ::memcpy(  (TCHAR *)pNewLogonHours,
                (TCHAR *)pLogonHours,
                cb );

    // clear extra bits in last byte
    UINT cLeftoverBits = (unitsperweek % 8);
    if ( cLeftoverBits != 0 )
        pNewLogonHours[cb - 1] &=
                (BYTE)((WORD)0x00ff >> (8 - cLeftoverBits));

    _cUnitsPerWeek = unitsperweek;

    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::PermitAll

    SYNOPSIS:   Changes logon hours setting to always allow logon

    RETURNS:    Standard error code

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::PermitAll()
{
    BYTE * pNewLogonHours = _buf.QueryPtr();

    ::memset( (TCHAR *)pNewLogonHours, 0xFF, QueryByteCount() );

    // clear extra bits in last byte
    UINT cLeftoverBits = (_cUnitsPerWeek % 8);
    if ( cLeftoverBits != 0 )
        pNewLogonHours[QueryByteCount() - 1] &=
                (BYTE)((WORD)0x00ff >> (8 - cLeftoverBits));

    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::MakeDefault

    SYNOPSIS:   Changes logon hours setting new user default

    RETURNS:    Standard error code

    HISTORY:
        jonn        12/19/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::MakeDefault()
{
    UINT cb = QueryByteCount( cHoursPerWeek );

    APIERR err = _buf.Resize( cb );
    if ( err != NERR_Success )
        return err;

    _cUnitsPerWeek = cHoursPerWeek;

    return PermitAll();
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::IsIdenticalToBits

    SYNOPSIS:   Compares two logon hours settings

    RETURNS:    TRUE iff they are identical

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

BOOL LOGON_HOURS_SETTING::IsIdenticalToBits( const BYTE * pLogonHours,
                                             UINT unitsperweek ) const
{
    return (    (unitsperweek == _cUnitsPerWeek)
            && !(::memcmp( (TCHAR *)(_buf.QueryPtr()),
                           (TCHAR *)pLogonHours,
                            QueryByteCount() ))
           );
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::QueryHourInWeek

    SYNOPSIS:   Determines whether logon is allowed in a specific hour
                of the week.  UnitsPerWeek is required to be
                HoursPerWeek.

    RETURNS:    TRUE iff logon is allowed.  Returns FALSE if
                UnitsPerWeek is not HoursPerWeek (plus assertion for
                DEBUG).

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

BOOL LOGON_HOURS_SETTING::QueryHourInWeek( UINT hourinweek ) const
{
    ASSERT( hourinweek < cHoursPerWeek );
    ASSERT( _cUnitsPerWeek == cHoursPerWeek );
    if ( _cUnitsPerWeek != cHoursPerWeek )
        return FALSE;

    // "!!" moves the matching bit to the first position, just in
    //    case some caller misuses the BOOL return value
    return !!( QueryHoursBlock()[ hourinweek / 8 ]
                        & (0x1 << (hourinweek % 8)) );
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::SetHourInWeek

    SYNOPSIS:   Changes whether logon is allowed in a specific hour
                of the week.  UnitsPerWeek is required to be
                HoursPerWeek.

    RETURNS:    Standard error return, ERROR_INVALID_PARAMETER if
                UnitsPerWeek is not HoursPerWeek (plus assertion for
                DEBUG).

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::SetHourInWeek( BOOL fLogonAllowed,
                                           UINT hourinweek )
{
    ASSERT( hourinweek < cHoursPerWeek );
    ASSERT( _cUnitsPerWeek == cHoursPerWeek );
    if ( _cUnitsPerWeek != cHoursPerWeek )
        return ERROR_INVALID_PARAMETER;

    BYTE byte = 0x1 << (hourinweek % 8);
    UINT byteposition = (hourinweek / 8);
    BYTE *pb = QueryHoursBlock();
    if (fLogonAllowed)
        pb[ byteposition ] |= byte;
    else
        pb[ byteposition ] &= ~byte;
    return NERR_Success;
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::ConvertToHoursPerWeek

    SYNOPSIS:   Converts the logon hours setting to HoursPerWeek
                format.  Only converts from DaysPerWeek or HoursPerWeek
                format.

    RETURNS:    Standard error return, ERROR_INVALID_PARAMETER if
                UnitsPerWeek is not DaysPerWeek or HoursPerWeek (plus
                assertion for DEBUG).

    NOTES:      Failure may leave the LOGON_HOURS_SETTING in an
                incomplete but internally consistent state.

    HISTORY:
        jonn        12/11/91    Created

********************************************************************/

APIERR LOGON_HOURS_SETTING::ConvertToHoursPerWeek()
{
    switch ( _cUnitsPerWeek )
    {
        case HOURS_PER_WEEK:
            return NERR_Success;

        case DAYS_PER_WEEK:
            {
                APIERR err = MakeDefault();
                if ( err != NERR_Success )
                    return err;
                BYTE hoursblock = *( _buf.QueryPtr() );
                for ( UINT day = 0; day < cDaysPerWeek; day++ )
                {
                    BOOL fLogonToday = !!( hoursblock & (0x1 << day) );
                    for ( UINT hour = 0; hour < cHoursPerWeek; hour++ )
                    {
                        err = SetHourInDay( fLogonToday, hour, day );
                        if ( err != NERR_Success )
                            return err;
                    }
                }
            }
            return NERR_Success;

        // case cMinutesPerWeek:
        // default:
            // fall through
    }

    ASSERT( FALSE );
    return ERROR_INVALID_PARAMETER;
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::ConvertToGMT

    SYNOPSIS:   Converts the logon hours setting to relative to GMT

    RETURNS:

    HISTORY:
        thomaspa        3/18/93    Created

********************************************************************/
BOOL LOGON_HOURS_SETTING::ConvertToGMT()
{
    return NetpRotateLogonHours( QueryHoursBlock(),
                                 QueryUnitsPerWeek(),
                                 TRUE );
}


/*******************************************************************

    NAME:       LOGON_HOURS_SETTING::ConvertFromGMT

    SYNOPSIS:   Converts the logon hours setting from relative to GMT

    RETURNS:

    HISTORY:
        thomaspa        3/18/93    Created

********************************************************************/
BOOL LOGON_HOURS_SETTING::ConvertFromGMT()
{
    return NetpRotateLogonHours( QueryHoursBlock(),
                                 QueryUnitsPerWeek(),
                                 FALSE );
}

APIERR LOGON_HOURS_SETTING::SetHourInDay(
    BOOL fLogonAllowed, UINT hourinday, UINT dayinweek )
{
    return SetHourInWeek(fLogonAllowed, hourinday + (dayinweek * cHoursPerDay));
}


BOOL LOGON_HOURS_SETTING::QueryHourInDay(
    UINT hourinday, UINT dayinweek ) const
{
    return QueryHourInWeek( hourinday + (dayinweek * cHoursPerDay) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\collect\dlist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    dlist.cxx
    LM 3.0 Generic dlist package

    This file contains the base routines for the DLIST class defined in
    dlist.hxx

    See the beginning of dlist.hxx for usage examples.

    FILE HISTORY:
        johnl       23-Jul-1990 Created
        Johnl       31-Oct-1990 Updated to reflect new iterator functionality
                                (Current pos. of iter. is the item previously
                                returned by next, remove(iter) removes the
                                element the iter is pointing to).
        Johnl        1-Jan-1991 Updated to use UIAssert
        beng        07-Feb-1991 Uses lmui.hxx
        johnl        7-Mar-1991 Made code review changes
        beng        02-Apr-1991 Replaced nsprintf with sprintf
        terryk      21-Sep-1991 Added {} between UIDEBUG
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        05-Mar-1992 Disabled debug output
*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*********************************************************************

    NAME:       DLIST::DLIST

    SYNOPSIS:   Constructor for the DLIST

    HISTORY:    johnl   23-Jul-90   Created

*********************************************************************/

DLIST::DLIST()
{
    _pdlHead = _pdlTail = NULL;
    _pdliterRegisteredIters = NULL;
}


/*********************************************************************

    NAME:       DLIST::~DLIST

    SYNOPSIS:   Destructor for the DLIST

    HISTORY:    johnl   23-Jul-90   Created

*********************************************************************/

DLIST::~DLIST()
{
    /* Deregister bumps _pdliterRegisteredIters to the next iterator...
     */
    while ( _pdliterRegisteredIters != NULL )
        Deregister( _pdliterRegisteredIters );
}


/*********************************************************************

    NAME:       DLIST::Add

    SYNOPSIS:   Adds the passed element to the beginning of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY of not successful

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR DLIST::Add( VOID *pelem )
{
    UIASSERT( pelem != NULL );

    DL_NODE * pdlnodeNew = new DL_NODE( NULL, _pdlHead, pelem );
    if ( pdlnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;       /* failure */

    if ( _pdlTail == NULL )           /* First item in list */
        _pdlTail = pdlnodeNew;
    else
        _pdlHead->_pdlnodePrev = pdlnodeNew;

    _pdlHead = pdlnodeNew;

    return NERR_Success;
}


/*********************************************************************

    NAME:       DLIST::QueryNumElem

    SYNOPSIS:   Returns the number of elements in the dlist

    ENTRY:      NONE

    EXIT:       A UINT indicating the number of elements in the list.

    HISTORY:    rustanl   15-Jul-90       Created
                johnl     19-Jul-90       Adapted for the DLIST package

*********************************************************************/

UINT DLIST::QueryNumElem()
{
    register DL_NODE * pdlnode = _pdlHead;
    UINT uNumElem = 0;

    while ( pdlnode != NULL )
    {
        uNumElem++;
        pdlnode = pdlnode->_pdlnodeNext;
    }

    return uNumElem;
}


/*********************************************************************

    NAME:       DLIST::Append

    SYNOPSIS:   Adds the passed element to the end of the list.

    ENTRY:      A pointer to a valid element (NOTE: the outer layer actually
                accepts a const reference to the element then copies it and
                sends the address along).

    EXIT:       NERR_Success if successful, otherwise an error code, one of:
                ERROR_NOT_ENOUGH_MEMORY

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR DLIST::Append( VOID *pelem )
{
    UIASSERT( pelem != NULL );

    DL_NODE * pdlnodeNew = new DL_NODE( _pdlTail, NULL, pelem );

    if ( pdlnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    if ( _pdlHead == NULL )
        _pdlHead = pdlnodeNew;
    else
        _pdlTail->_pdlnodeNext = pdlnodeNew;

    _pdlTail = pdlnodeNew;

    return NERR_Success;
}


/*********************************************************************

    NAME:       DLIST::Insert

    SYNOPSIS:   Insert an element into a dlist using the location of the
                passed iterator.

    ENTRY:      Pointer to the element to insert
                Iterator indicating insertion point

    EXIT:       return NERR_Success if successful,
                ERROR_NOT_ENOUGH_MEMORY if an allocation failure occurred
                ERROR_INVALID_DATA if a bad iterator was passed in

    NOTES:      -ITER_DL & RITER_DL
                    If a bad iterator is passed in (i.e., one not registered on
                this list), the current behavior is to assert out.  We may
                want to change this to return an error code (even though this
                should be considered as a programmer's error).

                The insertion point is always "previous" to the element the
                iterator is pointing at (which means the forward and reverse
                iterators have the same logical insertion point, but the
                opposite absolute insertion point).

    HISTORY:    johnl   7-25-90     Created
                Johnl  10-31-90     Reflects new iterator functionality
                MikeMi 6-30-95      Added previous next pointer fix

*********************************************************************/

APIERR DLIST::Insert( VOID *pelem, ITER_DL& dliter )
{
    UIASSERT( pelem != NULL );

    if ( !CheckIter( &dliter ) )
    {
        UIDEBUG(SZ("DLIST::Insert - Attempted to insert w/ Unregistered iterator\n\r"));
        return ERROR_INVALID_DATA;
    }

    DL_NODE *pdlnodeCurrent = dliter._pdlnodeCurrent;

    if ( pdlnodeCurrent == NULL ) /* Check if iter at end */
            return (Append( pelem ));

    DL_NODE * pdlnodeNew = new DL_NODE( pdlnodeCurrent,
                                        pdlnodeCurrent->_pdlnodeNext,
                                        pdlnodeCurrent->_pelem       );

    if ( pdlnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    pdlnodeCurrent->Set( pdlnodeCurrent->_pdlnodePrev,
                         pdlnodeNew, pelem );

    
    if ( _pdlTail == pdlnodeCurrent )   // Fixup tail pointer if necessary
    {
        _pdlTail = pdlnodeNew;
    }
    else
    {
        // rememer to set next's previouses to us
        pdlnodeNew->_pdlnodeNext->_pdlnodePrev = pdlnodeNew;
    }
    BumpIters( pdlnodeCurrent );

    return NERR_Success;
}


/*
 * Insert using a RITER_DL
 */

APIERR DLIST::Insert( VOID *pelem, RITER_DL& dlriter )
{
    UIASSERT( pelem != NULL );

    if ( !CheckIter( &dlriter ) )
    {
        UIDEBUG(SZ("DLIST::Insert - Attempted to insert w/ Unregistered iterator\n\r"));
        return ERROR_INVALID_DATA;
    }

    DL_NODE *pdlnodeCurrent = dlriter._pdlnodeCurrent;

    if ( pdlnodeCurrent == NULL ) /* Check if iter at end/beginning */
            return (Append( pelem ));

    DL_NODE * pdlnodeNew = new DL_NODE( pdlnodeCurrent->_pdlnodePrev,
                                        pdlnodeCurrent,
                                        pdlnodeCurrent->_pelem       );
    if ( pdlnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    pdlnodeCurrent->Set( pdlnodeNew,
                         pdlnodeCurrent->_pdlnodeNext, pelem );

    if ( _pdlHead == pdlnodeCurrent )   // Fixup tail pointer if necessary
    {
        _pdlHead = pdlnodeNew;
    }
    else
    {
        // rememer to set previous next to us
        pdlnodeNew->_pdlnodePrev->_pdlnodeNext = pdlnodeNew;
    }

    BumpIters( pdlnodeCurrent );

    return NERR_Success;
}


/*********************************************************************

    NAME:       DLIST::Remove

    SYNOPSIS:   Removes the element the passed iterator points to

    ENTRY:      A Valid registered iterator

    EXIT:       A pointer to the newly removed element
                NULL if the list is empty or the iterator is at the end of the
                list

    NOTES:      If an unregistered iterator is passed in, the current
                implementation asserts out.

    HISTORY:    johnl   7-25-90     Created
                Johnl  10-31-90     Reflects new iterator functionality

*********************************************************************/

VOID * DLIST::Remove( ITER_DL& dliter )
{
    if ( !CheckIter( &dliter ) )
    {
        UIDEBUG(SZ("DLIST::Remove - Attempted to remove w/ Unregistered iterator\n\r"));
        return NULL;
    }

    return Unlink( dliter._pdlnodeCurrent );
}


/*
 * Reverse iterator version of the above
 */

VOID * DLIST::Remove( RITER_DL& dlriter )
{
    if ( !CheckIter( &dlriter ) )
    {
        UIDEBUG(SZ("DLIST::Remove - Attempted to remove w/ Unregistered iterator\n\r"));
        return NULL;
    }

    return Unlink( dlriter._pdlnodeCurrent );
}


/*******************************************************************

    NAME:     DLIST::Unlink

    SYNOPSIS: Removes and deletes the passed DL_NODE from the dlist.  Returns
              a pointer to the nodes properties if successful, NULL
              if not found.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   7-Mar-1991      Created

********************************************************************/

VOID * DLIST::Unlink( DL_NODE * pdlnodeTarget )
{
    if ( _pdlHead == NULL || pdlnodeTarget == NULL )
        return NULL;  /* Empty dlist or iter on last node of dlist */

    if ( _pdlTail == _pdlHead )       /* Only node in list */
        _pdlTail = _pdlHead = NULL;
    else if ( pdlnodeTarget == _pdlHead )         /* First */
    {
        pdlnodeTarget->_pdlnodeNext->_pdlnodePrev = NULL;
        _pdlHead = pdlnodeTarget->_pdlnodeNext;
    }
    else if ( pdlnodeTarget == _pdlTail )         /* Last */
    {
        pdlnodeTarget->_pdlnodePrev->_pdlnodeNext = NULL;
        _pdlTail = pdlnodeTarget->_pdlnodePrev;
    }
    else                                   /* Middle */
    {
        pdlnodeTarget->_pdlnodePrev->_pdlnodeNext = pdlnodeTarget->_pdlnodeNext;
        pdlnodeTarget->_pdlnodeNext->_pdlnodePrev = pdlnodeTarget->_pdlnodePrev;
    }

    BumpIters( pdlnodeTarget );  /* Move iters to next node... */

    VOID * pelem = pdlnodeTarget->_pelem;
    delete pdlnodeTarget;
    return pelem;
}

/*********************************************************************

    NAME:       DLIST::Register

    SYNOPSIS:   Adds the pointer to the passed iterator to the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator

    EXIT:       0 if successful, non-zero if an error occurred

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID DLIST::Register( ITER_L * pdliter )
{
    pdliter->_pdliterNext = _pdliterRegisteredIters;
    _pdliterRegisteredIters = pdliter;
}


/*********************************************************************

    NAME:       DLIST::Deregister

    SYNOPSIS:   Removes the pointer to the passed iterator from the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator, registered iterator

    EXIT:       NONE

    NOTES:      Deregister must succeed, if it fails, then an internal error
                has occurred.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID DLIST::Deregister( ITER_L * pdliter )
{
    register ITER_L *piter     = _pdliterRegisteredIters,
                    *piterPrev = NULL;

    while ( piter != NULL )
    {
        if ( piter == pdliter )
        {
            if ( piterPrev != NULL ) /* if not first node in list */
                 piterPrev->_pdliterNext = piter->_pdliterNext;
            else
            {
                if ( piter->_pdliterNext == NULL )
                    _pdliterRegisteredIters = NULL; /* only item in list */
                else
                    _pdliterRegisteredIters = piter->_pdliterNext;
            }

            pdliter->_pdlist = NULL;
            pdliter->_pdlnodeCurrent = NULL;
            pdliter->_pdliterNext = NULL;
            return;
        }
        else
        {
            piterPrev = piter;
            piter = piter->_pdliterNext;
        }
    }
    UIASSERT( !SZ("DLIST::Deregister Internal Error") ); /* We should never get here */
}

/*********************************************************************

    NAME:       DLIST::BumpIters

    SYNOPSIS:   Moves iterators to next element that point to the passed node

    ENTRY:      A valid DL_NODE that will be going away

    EXIT:       None

    NOTES:      BumpIters is used in cases where a particular element is going
                to be deleted.  BumpIters finds all of the iterators that
                point to the soon to be deceased node and bumps them to the
                next element using their Next() method.

                If the iterator hasn't been used, then it will need to be
                bumped twice to get its internal info to move to the next
                item in the list

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID DLIST::BumpIters( DL_NODE* pdlnode )
{
    register ITER_L * piter = _pdliterRegisteredIters;

    while ( piter != NULL )
        if ( piter->_pdlnodeCurrent == pdlnode )
            piter->vNext();
        else
            piter = piter->_pdliterNext;
}


/*********************************************************************

    NAME:       DLIST::SetIters

    SYNOPSIS:   Sets all registered iterators to the passed value

    ENTRY:      A pointer to a a DL_NODE (or NULL)

    EXIT:       All iterators will point to the passed value

    NOTES:      This is generally used in cases after the list has been
                emptied, so the passed in value will normally be NULL.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID DLIST::SetIters( DL_NODE *pdlnode )
{
    register ITER_L * piter = _pdliterRegisteredIters;

    while ( piter != NULL )
    {
        piter->_pdlnodeCurrent = pdlnode;
        piter = piter->_pdliterNext;
    }
}


/*********************************************************************

    NAME:       DLIST::CheckIter

    SYNOPSIS:   Confirms the passed iter belongs to this list

    ENTRY:      A pointer to an iterator

    EXIT:       TRUE if the passed iterator belongs, FALSE otherwise.

    NOTES:      CheckIter is generally used with methods that pass in an
                iterator as a parameter (such as Insert).  It is the option
                of the method whether to abort or not when a bad iterator
                is passed in.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

BOOL DLIST::CheckIter( ITER_L *pdliter )
{
    ITER_L * piter = _pdliterRegisteredIters;

    while ( piter != NULL && piter != pdliter )
        piter = piter->_pdliterNext;

    return ( piter != NULL );
}


/*********************************************************************

    NAME:       ITER_DL::ITER_DL

    SYNOPSIS:   Constructor for DLIST iterator

    ENTRY:      Pointer to a valid DLIST

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_DL::ITER_DL( DLIST * pdl )
{
    UIASSERT( pdl != NULL );

    _pdlist         = pdl;
    _pdlnodeCurrent = pdl->_pdlHead;
    _fUsed          = FALSE;
    _pdliterNext    = NULL;

    _pdlist->Register( this );
}


/*********************************************************************

    NAME:       ITER_DL::ITER_DL

    SYNOPSIS:   Constructor for DLIST iterator,
                uses passed iterator for new position

    ENTRY:      Pointer to a valid DLIST iterator

    HISTORY:    johnl   10-16-90     Created

*********************************************************************/

ITER_DL::ITER_DL( const ITER_DL& iterdl )
{
    _pdlist         = iterdl._pdlist;
    _pdlnodeCurrent = iterdl._pdlnodeCurrent;
    _fUsed          = iterdl._fUsed;
    _pdliterNext    = iterdl._pdliterNext;

    _pdlist->Register( this );
}


/*********************************************************************

    NAME:       ITER_DL::~ITER_DL

    SYNOPSIS:   Destructor for ITER_DL

    ENTRY:      Assumes valid (registered) iterator, Deregister aborts if this
                isn't the case.

    EXIT:       NONE

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_DL::~ITER_DL()
{
    if ( _pdlist != NULL )
        _pdlist->Deregister( this );

    _pdlist = NULL;
    _pdlnodeCurrent = NULL;
    _pdliterNext = NULL;
}


/*********************************************************************

    NAME:       ITER_DL::vNext

    SYNOPSIS:   Traversal operator of iterator

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL
                Goes to next node in the list.

    NOTES:

    HISTORY:    johnl   7-25-90     Created
                Johnl  10-31-90     Updated to reflect new iterator functionality

*********************************************************************/

VOID * ITER_DL::vNext()
{
    if ( _pdlnodeCurrent != NULL )
        if ( _fUsed )
            _pdlnodeCurrent = _pdlnodeCurrent->_pdlnodeNext;
        else
            _fUsed = TRUE;

    return ( _pdlnodeCurrent != NULL ? _pdlnodeCurrent->_pelem : NULL );
}


/*********************************************************************

    NAME:       ITER_DL::Reset

    SYNOPSIS:   Resets the iterator to the beginning of the list

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:    johnl   7-25-90     Created
                JohnL   4-16-91     Added check if slist is already destructed

*********************************************************************/

VOID ITER_DL::Reset()
{
    if ( _pdlist != NULL )
        _pdlnodeCurrent = _pdlist->_pdlHead;
    _fUsed = FALSE;
}


/*********************************************************************

    NAME:       RITER_DL::RITER_DL

    SYNOPSIS:   Constructor for DLIST Reverse iterator

    ENTRY:      Pointer to a valid DLIST

    EXIT:

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

RITER_DL::RITER_DL( DLIST * pdl )
{
    _pdlist        = pdl;
    _pdlnodeCurrent= _pdlist->_pdlTail;
    _fUsed         = FALSE;
    _pdliterNext   = NULL;

    _pdlist->Register( this );
}


/*********************************************************************

    NAME:       RITER_DL::RITER_DL

    SYNOPSIS:   Constructor for DLIST iterator, uses passed iterator for new position

    ENTRY:      Pointer to a valid DLIST riterator

    HISTORY:    johnl   10-16-90     Created

*********************************************************************/

RITER_DL::RITER_DL( const RITER_DL& riterdl )
{
    _pdlist         = riterdl._pdlist;
    _pdlnodeCurrent = riterdl._pdlnodeCurrent;
    _fUsed          = riterdl._fUsed;
    _pdliterNext    = riterdl._pdliterNext;

    _pdlist->Register( this );
}


/*********************************************************************

    NAME:       RITER_DL::~RITER_DL

    SYNOPSIS:   Destructor for RITER_DL

    ENTRY:      Assumes valid (registered) iterator, Deregister aborts if this
                isn't the case.

    EXIT:       NONE

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

RITER_DL::~RITER_DL()
{
    if ( _pdlist != NULL )
        _pdlist->Deregister( this );

    _pdlist = NULL;
    _pdlnodeCurrent = NULL;
    _pdliterNext = NULL;
}


/*********************************************************************

    NAME:       RITER_DL::vNext

    SYNOPSIS:   Traversal operator of iterator

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL
                Goes to next node in the list.

    NOTES:

    HISTORY:

*********************************************************************/

VOID * RITER_DL::vNext()
{
    if ( _pdlnodeCurrent != NULL )
        if ( _fUsed )
            _pdlnodeCurrent = _pdlnodeCurrent->_pdlnodePrev;
        else
            _fUsed = TRUE;

    return ( _pdlnodeCurrent != NULL ? _pdlnodeCurrent->_pelem : NULL );
}


/*********************************************************************

    NAME:       RITER_DL::Reset

    SYNOPSIS:   Resets the reverse iterator to the end of the list

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:

*********************************************************************/

VOID RITER_DL::Reset()
{
    if ( _pdlist != NULL )
        _pdlnodeCurrent = _pdlist->_pdlTail;
    _fUsed = FALSE;
}

/*
 * Debug information for DLIST
 */

VOID DLIST::_DebugPrint() const
{
    //  This routine is a no-op if !DEBUG
#if defined(DEBUG) && defined(NOTDEFINED)

    register DL_NODE *_pdlnode = _pdlHead;
    UINT uCnt = 0;
    char buff[250];

    UIDEBUG(SZ("DLIST::DebugPrint - Dlist status:") );

    if ( _pdlHead == NULL )
    {
        UIDEBUG(SZ("Empty dlist"));
    }

    if ( _pdliterRegisteredIters == NULL )
    {
        UIDEBUG(SZ("No registered iterators"));
    }
    else
    {
        register ITER_L * piter = _pdliterRegisteredIters;
        UIDEBUG(SZ("Iter->dlnode:"));
        while ( piter != NULL )
        {
            sprintf(buff, SZ("[%Fp]->[%Fp fEnd=%s]"),
                     piter,
                     piter->_pdlnodeCurrent,
                     piter->_fUsed ? SZ("TRUE") : SZ("FALSE") );
            UIDEBUG(buff);
            piter = piter->_pdliterNext;
        }
    }

    sprintf(buff,SZ("Head = [%Fp], Tail = [%Fp]\n"), _pdlHead, _pdlTail );
    UIDEBUG(buff);

    while ( _pdlnode != NULL )
    {
        register ITER_L *piter = _pdliterRegisteredIters;
        UINT uNumIters = 0;

        while ( piter != NULL ) /* Get # of iters pointing here */
        {
            if ( piter->_pdlnodeCurrent == _pdlnode )
                uNumIters++;
            piter = piter->_pdliterNext;
        }

        sprintf( buff, SZ("[%Fp](%d)"), _pdlnode, uNumIters );
        UIDEBUG( buff );

        _pdlnode = _pdlnode->_pdlnodeNext;
    }

#endif //DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\collect\tree.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    TREE.CXX
    LM 3.0 Generic general tree package

    This file contains the generic TREE code that is declared in the
    file TREE.HXX.  Please see TREE.HXX for a description.


    FILE HISTORY:
        johnl       06-Sep-1990 Created
        beng        07-Feb-1991 Uses lmui.hxx
        johnl       07-Mar-1991 Made code review changes
        beng        02-Apr-1991 Replaced nsprintf with sprintf
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        05-Mar-1992 Disabled debug output
*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*******************************************************************

    NAME:     TREE::TREE

    SYNOPSIS: TREE constructor

    ENTRY:    None

    EXIT:     Initialized TREE node

    NOTES:

    HISTORY:
        johnl     6-Sep-1990  Created
        johnl    16-Nov-1990  Allowed properties to be NULL

********************************************************************/

TREE::TREE( VOID * pvelem )
{
    SetLeft( NULL );
    SetRight( NULL );
    SetParent( NULL );
    SetFirstSubtree( NULL );
    SetProp( pvelem );
}


/*******************************************************************

    NAME:     TREE::~TREE

    SYNOPSIS: TREE node destructor
              Deletes subtree(s) then unlinks itself from the tree

    ENTRY:

    EXIT:     A free floating tree node

    NOTES:

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

TREE::~TREE()
{
    Unlink();
}


/*******************************************************************

    NAME:     TREE::Unlink

    SYNOPSIS: Unlinks this subtree from its parent tree

    ENTRY:    Valid tree

    EXIT:     Free floating tree

    NOTES:    This is an internal helper routine

    HISTORY:  johnl     6-Sep-1990  Created
              johnl     7-Feb-1991  Added fix peterwi suggested (and wrote)

********************************************************************/

VOID TREE::Unlink()
{
    UIASSERT( QueryParent()!= NULL ||
              (QueryParent() == NULL && QueryRight() == NULL && QueryLeft() == NULL ));
    if ( QueryParent() != NULL )                 // Can't unlink the root...
    {
        if ( QueryLeft() != NULL )
            QueryLeft()->SetRight( QueryRight() );
        else
            QueryParent()->SetFirstSubtree( QueryRight() );

        if ( QueryRight() != NULL )
            QueryRight()->SetLeft( QueryLeft()  );

        SetParent( NULL );
        SetLeft( NULL );
        SetRight( NULL );
    }
}


/*******************************************************************

    NAME:     TREE::BreakOut

    SYNOPSIS: Breaks out this subtree from the rest of the tree and
              returns this subtree

    ENTRY:    Valid tree node

    EXIT:     Free floating Subtree

    NOTES:

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

TREE* TREE::BreakOut()
{
    Unlink();
    return this;
}


/*******************************************************************

    NAME:     TREE::QueryLastSubtree

    SYNOPSIS: Gets the right most child tree of this node

    ENTRY:    Valid tree node

    EXIT:     Returns the right most child

    NOTES:

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

TREE * TREE::QueryLastSubtree() const
{
    register TREE * pt = QueryFirstSubtree();

    if ( pt != NULL )
        while ( pt->QueryRight() != NULL )
            pt = pt->QueryRight();

    return pt;
}


/*******************************************************************

    NAME:     TREE::JoinSubtreeLeft

    SYNOPSIS: Joins the passed tree as the left most subtree of this node

    ENTRY:    Valid tree node

    EXIT:     Expanded tree

    NOTES:    Can't Fail

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::JoinSubtreeLeft( TREE * ptree )
{
    /* Don't allow linking in a tree that is part of another tree
     * or recursively joining this tree.
     */
    UIASSERT( ptree->QueryLeft() == NULL &&
              ptree->QueryRight() == NULL &&
              ptree->QueryParent() == NULL    );
    //UIASSERT( ptree != QueryRoot() );  No QueryRoot, will add...

    ptree->SetLeft( NULL );
    ptree->SetRight( QueryFirstSubtree() );
    ptree->SetParent( this );

    if ( QueryFirstSubtree() != NULL )
        QueryFirstSubtree()->SetLeft( ptree );

    SetFirstSubtree( ptree );
}


/*******************************************************************

    NAME:     TREE::JoinSubtreeRight

    SYNOPSIS: Joins the passed tree as the right most subtree of this node

    ENTRY:    Valid tree node

    EXIT:     Expanded tree

    NOTES:    Can't Fail

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::JoinSubtreeRight( TREE * ptree )
{
    /* Don't allow linking in a tree that is part of another tree
     * or recursively joining this tree.
     */
    UIASSERT( ptree->QueryLeft() == NULL &&
              ptree->QueryRight() == NULL &&
              ptree->QueryParent() == NULL    );
    //UIASSERT( ptree != QueryRoot() );    No QueryRoot, will add

    TREE *ptOldRight = QueryLastSubtree();

    ptree->SetLeft( ptOldRight );
    ptree->SetRight( NULL );
    ptree->SetParent( this );

    if ( ptOldRight == NULL )
        SetFirstSubtree( ptree );
    else
        ptOldRight->SetRight( ptree );
}


/*******************************************************************

    NAME:     TREE::JoinSiblingLeft

    SYNOPSIS: Joins the passed tree as the immediate left sibling of "this"

    ENTRY:    Valid tree node

    EXIT:     Expanded tree

    NOTES:    Asserts out if "this" is the root (can't have two roots...)

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::JoinSiblingLeft( TREE * ptree )
{
    UIASSERT( QueryParent() != NULL );    // Can't join a sibling at the root

    ptree->SetParent( QueryParent() );
    ptree->SetLeft( QueryLeft() );
    ptree->SetRight( this );

    if ( QueryLeft() == NULL )           // First tree of this level?
        QueryParent()->SetFirstSubtree( ptree );
    else
        QueryLeft()->SetRight( ptree );

    SetLeft( ptree );
}


/*******************************************************************

    NAME:     TREE::JoinSiblingRight

    SYNOPSIS: Joins the passed tree as the immediate right sibling of "this"

    ENTRY:    Valid tree node

    EXIT:     Expanded tree

    NOTES:    Asserts out if "this" is the root (can't have two roots...)

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::JoinSiblingRight( TREE * ptree )
{
    UIASSERT( QueryParent() != NULL );    // Can't join a sibling at the root

    ptree->SetParent( QueryParent() );
    ptree->SetLeft( this );
    ptree->SetRight( QueryRight() );

    if ( QueryRight() != NULL )
        QueryRight()->SetLeft( ptree );

    SetRight( ptree );
}


/*******************************************************************

    NAME:     TREE::QueryNumElem

    SYNOPSIS: Returns the number of elements in the subtree

    ENTRY:    Valid tree node

    EXIT:     # of elements in the subtree

    NOTES:    Recursively (to the depth of the tree) counts the number of
              tree nodes in the tree.

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

UINT TREE::QueryNumElem() const
{
    UINT uNumElem = 1;      // Count self

    TREE *pt = QueryFirstSubtree();
    for (; pt != NULL; pt = pt->QueryRight() )
        uNumElem += pt->QueryNumElem();

    return uNumElem;
}


/*******************************************************************
    NAME:     TREE::_DebugPrint

    SYNOPSIS: Prints the contents of the tree node

    ENTRY:    Valid tree node

    EXIT:

    NOTES:    Only defined in the DEBUG version

    HISTORY:  johnl     6-Sep-1990  Created

********************************************************************/

VOID TREE::_DebugPrint() const
{
    //  This routine is a no-op if !DEBUG
#if defined(DEBUG) && defined(NOTDEFINED)

    char buff[250];

    sprintf(buff, SZ("TREE::this = %Fp\n"), (VOID *) this );
    UIDEBUG( buff );
    sprintf(buff, SZ("    _ptParent = %Fp, _ptLeftChild = %Fp\n"),
            (VOID *) _ptParent,
             (VOID *) _ptLeftChild );
    UIDEBUG( buff );
    sprintf(buff, SZ("    _ptLeft   = %Fp, _ptRight     = %Fp\n"),
            (VOID *) _ptLeft,
            (VOID *) _ptRight );
    UIDEBUG( buff );

#endif // DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\collect\treeiter.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    treeiter.cxx
    Implements DFS iter for the generic tree class (See treeiter.hxx &
    tree.hxx).


    FILE HISTORY:
	JohnL	Oct. 15, 1990	Created
	beng	07-Feb-1991	Uses lmui.hxx
	Johnl	07-Mar-1991	Made code review changes
	KeithMo	09-Oct-1991	Win32 Conversion.

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/*******************************************************************

    NAME:     DFSITER_TREE::DFSITER_TREE

    SYNOPSIS: Constructor for DFS Iterator for the Tree class

    ENTRY:    TREE * = node to start iterator on
	      uDepth = Maximum depth to traverse to (start node is 0)

    EXIT:

    NOTES:

    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

DFSITER_TREE::DFSITER_TREE( const TREE * pt, const UINT uDepth )
{
    UIASSERT( pt != NULL );	 // Programmer error to pass in a NULL pointer
    SetNode( pt );
    SetStartNode( pt );
    SetMaxDepth( uDepth );
    SetCurDepth( 0 );
}


/*******************************************************************

    NAME:     DFSITER_TREE::DFSITER_TREE

    SYNOPSIS: Constructor for DFS Iterator for the Tree class, takes
	      another DFS iterator and copies it's information

    ENTRY:    pdfsitertree = pointer to iterator to use for start info

    EXIT:     nothing

    NOTES:

    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

DFSITER_TREE::DFSITER_TREE( const DFSITER_TREE * pdfsiterTree )
{
    SetNode( pdfsiterTree->QueryNode() );
    SetMaxDepth( pdfsiterTree->QueryMaxDepth() );
    SetCurDepth( pdfsiterTree->QueryCurDepth() );
    SetStartNode( pdfsiterTree->QueryStartNode() );
}


/*******************************************************************

    NAME:     DFSITER_TREE::~DFSITER_TREE

    SYNOPSIS: destructor for the DFSITER

    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

DFSITER_TREE::~DFSITER_TREE()
{
    SetNode( NULL );	// Nullify this iterator (gp fault on next use)
}


/*******************************************************************

    NAME:     DFSITER_TREE::Next

    SYNOPSIS: Advances iterator to the next node in a Depth first fashion

    NOTES: In pseudo code, the algorithm looks like:
	   (Many thanx to RustanL for his collaboration)

	   Save the current node for return
	   if ( We have iterated to the end of the list )
	       return NULL
	   else if ( there is a child )
	       set current node to first child

	   else if ( We are back from where we started from )
	       Set current node to NULL

	   else if ( there is a right sibling )
	       Set current node to right sibling

	   else
	   {
	       pt = parent of current node
	       while ( we aren't where we started and the parent doesn't
		       have a right sibling )
		  Move up to the next parent

	       if ( we are where we started )
		  set current node to NULL
	       else
		  set current node to right sibling of parent
	   }
	   return the previously saved current node


    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

VOID* DFSITER_TREE::Next()
{
    const TREE *ptreeRet = QueryNode();

    if ( QueryNode() == NULL )
	return NULL;

    else if ( QueryNode()->QueryFirstSubtree() != NULL	&&
	      _uCurDepth < _uMaxDepth 		  )
    {
	SetNode( QueryNode()->QueryFirstSubtree() );
	_uCurDepth++;
    }

    else if ( QueryNode() == QueryStartNode() )
	SetNode( NULL );

    else if ( QueryNode()->QueryRight() != NULL )
	SetNode( QueryNode()->QueryRight() );

    else
    {
	TREE *pt = QueryNode()->QueryParent();
	while ( pt != QueryStartNode() && pt->QueryRight() == NULL )
	{
	    pt = pt->QueryParent();
	    _uCurDepth--;
	}

	if ( pt == QueryStartNode() )
	    SetNode( NULL );
	else
	    SetNode( pt->QueryRight() );
    }
    return ptreeRet->QueryProp();
}


/*******************************************************************

    NAME:     DFSITER_TREE::Reset

    SYNOPSIS: Resets the iterator to the starting node

    NOTES:

    HISTORY:  JohnL   Oct. 15, 1990  Created

********************************************************************/

VOID DFSITER_TREE::Reset()
{
    SetNode( QueryStartNode() );
    SetCurDepth( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\collect\slist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    slist.cxx
    LM 3.0 Generic slist package

    This file contains the base routines for the SLIST class defined in
    slist.hxx

    See the beginning of slist.hxx for usage examples.

    FILE HISTORY:
        johnl       24-Jul-1990 Created
        johnl       30-Oct-1990 Modified to reflect functional shift of
                                iterator (item returned by next is the
                                current item)
        beng        07-Feb-1991 Uses lmui.hxx
        johnl       07-Mar-1991 Code review changes
        beng        02-Apr-1991 Replaced nsprintf with sprintf
        terryk      19-Sep-1991 Added {} between UIDEBUG
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        05-Mar-1992 Disabled debug output

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

/*********************************************************************

    NAME:       SLIST::SLIST

    SYNOPSIS:   Constructor for the SLIST

    HISTORY:    johnl   19-Jul-90   Created

*********************************************************************/

SLIST::SLIST()
{
    _pslHead = _pslTail = NULL;
    _psliterRegisteredIters = NULL;
}


/*********************************************************************

    NAME:       SLIST::~SLIST

    SYNOPSIS:   Destructor for the SLIST

    HISTORY:    johnl   19-Jul-90   Created

*********************************************************************/

SLIST::~SLIST()
{
    /* Deregister modifies _psliterRegisteredIters (moves it to the next
     * iterator in the list).
     */
    while ( _psliterRegisteredIters != NULL )
        Deregister( _psliterRegisteredIters );
}


/*********************************************************************

    NAME:       SLIST::Add

    SYNOPSIS:   Adds the passed element to the beginning of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY otherwise

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR SLIST::Add( VOID* pelem )
{
    SL_NODE * pslnodeNew = new SL_NODE( _pslHead, pelem );
    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;       /* failure */

    if ( _pslTail == NULL )  /* First item in list */
        _pslTail = pslnodeNew;

    _pslHead = pslnodeNew;

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::QueryNumElem

    SYNOPSIS:   Returns the number of elements in the slist

    ENTRY:      NONE

    EXIT:       A UINT indicating the number of elements in the list.

    HISTORY:    rustanl   15-Jul-90       Created
                johnl     19-Jul-90       Adapted for the SLIST package

*********************************************************************/

UINT SLIST::QueryNumElem()
{
    register SL_NODE * pslnode = _pslHead;
    UINT uCount = 0;

    while ( pslnode != NULL )
    {
        uCount++;
        pslnode = pslnode->_pslnodeNext;
    }

    return uCount;
}


/*********************************************************************

    NAME:       SLIST::Append

    SYNOPSIS:   Adds the passed element to the end of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY otherwise

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR SLIST::Append( VOID* pelem )
{
    SL_NODE * pslnodeNew = new SL_NODE( NULL, pelem );

    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    if ( _pslHead == NULL )
        _pslHead = _pslTail = pslnodeNew;
    else
    {
        _pslTail->_pslnodeNext = pslnodeNew;
        _pslTail = pslnodeNew;
    }

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::Insert

    SYNOPSIS:   Insert an element into a slist using the location of the
                passed iterator.  (ITER_SL)

    ENTRY:      Pointer to the element to insert
                Iterator indicating insertion point

    EXIT:       return NERR_Success if successful,
                ERROR_NOT_ENOUGH_MEMORY if an allocation failure occurred
                ERROR_INVALID_DATA if a bad iterator was passed in

    NOTES:      If a bad iterator is passed in (i.e., one not registered on
                this list), the current behavior is to assert out.  We may
                want to change this to return an error code (even though this
                should be considered as a programmer's error).

                The insertion point is always "previous" to the element the
                iterator is pointing at.  If the iterator is at the end of
                the list (i.e., the current position is NULL), then Insert
                is equivalent to Append.

                The algorithm (suggested by PeterWi) looks like:


                    Before         Insert 15 at iter      After

                   A[val=10]                             A[val=10]
                      |                                     |
                   B[val=20]<--iter                      B[val=15]
                      |                                     |
                   C[val=30]                             D[val=20]<--iter
                                                            |
                                                         C[val=30]

    HISTORY:    johnl   7-19-90     Created
                johnl  10-30-90     Modified to reflect functional change in
                                    iterator

*********************************************************************/

APIERR SLIST::Insert( VOID* pelem, ITER_SL& sliter )
{
    if ( !CheckIter( &sliter ) )
    {
        UIDEBUG(SZ("SLIST::Insert - Attempted to insert w/ Unregistered iterator\n\r"));
        return ERROR_INVALID_DATA;
    }

    SL_NODE * pslnodeCurrent = sliter._pslnodeCurrent;

    if ( pslnodeCurrent == NULL )   /* Check if iter at end/beginning */
        return (Append( pelem ));

    SL_NODE * pslnodeNew = new SL_NODE( pslnodeCurrent->_pslnodeNext,
                                        pslnodeCurrent->_pelem);
    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    pslnodeCurrent->Set( pslnodeNew, pelem );

    if ( _pslTail == pslnodeCurrent )   // Fixup tail pointer if necessary
        _pslTail = pslnodeNew;

    BumpIters( pslnodeCurrent );

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::Remove

    SYNOPSIS:   Removes the element the past iterator points at

    ENTRY:      A Valid registered iterator

    EXIT:       A pointer to the newly removed element
                NULL if the list is empty or the iterator is at the end of
                the list.

    NOTES:      NULL is returned if an unregistered iterator is passed in, the
                slist is empty or the iterator is at the end of the list.


    HISTORY:    johnl   7-19-90     Created
                johnl  10-30-90     Changed behavior so it removes the element
                                    the iterator is pointing (as opposed to
                                    the element to the left).

*********************************************************************/

VOID * SLIST::Remove( ITER_SL& sliter )
{
    if ( !CheckIter( &sliter ) )
    {
        UIDEBUG(SZ("SLIST::Remove - Attempted to insert w/ Unregistered iterator\n\r"));
        return NULL;
    }

    SL_NODE *pslnodeCurrent = sliter._pslnodeCurrent;

    if ( pslnodeCurrent == NULL )
        return NULL;  /* Iter at end of Slist */

    register SL_NODE *_pslnodeTarget = NULL;   // Node that's going away
    VOID * _pelem;

    /*
     *  if ( the next node is not NULL )  // Can we fix things up w/o trav.?
     *      save pelem for the return     // Yes
     *      make target the next node
     *      Update iterators so the element position doesn't change in the list
     *      assign the current node the contents of the next node
     *  else // this is the last item in the list
     *      Find the previous item in the list
     *      if there is no prev. item
     *          set head & tail to NULL, this was the only item in the list
     *      else
     *          set the prev. item's next pointer to NULL (last item in list)
     *      set the target node
     *      save the pelem to return it
     */

    if ( pslnodeCurrent->_pslnodeNext != NULL )
    {
        _pelem = pslnodeCurrent->_pelem;

        _pslnodeTarget = pslnodeCurrent->_pslnodeNext;
        SetIters( _pslnodeTarget, pslnodeCurrent );

        pslnodeCurrent->Set( pslnodeCurrent->_pslnodeNext->_pslnodeNext,
                             pslnodeCurrent->_pslnodeNext->_pelem );

        if ( _pslnodeTarget == _pslTail )   // Fixup tail pointer
            _pslTail = pslnodeCurrent;
    }
    else
    {
        // This is the last (position) item in the list
        SL_NODE *_pslnodePrev = FindPrev( pslnodeCurrent );

        if ( _pslnodePrev == NULL )     // If only item in the slist
            _pslHead = _pslTail = NULL;
        else
        {
            _pslnodePrev->_pslnodeNext = NULL;
            _pslTail = _pslnodePrev;
        }

        _pslnodeTarget = pslnodeCurrent;
        _pelem = pslnodeCurrent->_pelem;
    }

    BumpIters( _pslnodeTarget );  /* Move iters to next node... */

    delete _pslnodeTarget;
    return _pelem;
}


/*********************************************************************

    NAME:       SLIST::FindPrev

    SYNOPSIS:   Private method to find the previous element in the list.

    ENTRY:      SL_NODE that we want to find the previous node to.

    EXIT:       The previous node if successful, or NULL.

    HISTORY:    johnl   7-19-90     Created

*********************************************************************/

SL_NODE* SLIST::FindPrev( SL_NODE *pslnode )
{
    if ( pslnode == NULL )
        return NULL;

    register SL_NODE *_pslnode = _pslHead, *_pslnodePrev = NULL;

    while ( _pslnode != NULL && _pslnode != pslnode )
    {
        _pslnodePrev = _pslnode;
        _pslnode = _pslnode->_pslnodeNext;
    }
    return ( _pslnode == NULL ? NULL : _pslnodePrev );
}


/*********************************************************************

    NAME:       SLIST::Register

    SYNOPSIS:   Adds the pointer to the passed iterator to the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator

    EXIT:

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::Register( ITER_SL *psliter )
{
    psliter->_psliterNext = _psliterRegisteredIters;
    _psliterRegisteredIters = psliter;
}


/*********************************************************************

    NAME:       SLIST::Deregister

    SYNOPSIS:   Removes the pointer to the passed iterator from the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator, registered iterator

    EXIT:       NONE

    NOTES:      Deregister must succeed, if it fails, then an internal error
                has occurred.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::Deregister( ITER_SL *psliter )
{
    register ITER_SL * pslitersCur  = _psliterRegisteredIters,
                     * pslitersPrev = NULL;

    while ( pslitersCur != NULL )
    {
        if ( pslitersCur == psliter )
        {
            if ( pslitersPrev != NULL ) /* if not first node in list */
                pslitersPrev->_psliterNext = pslitersCur->_psliterNext;

            else
            {
                if ( pslitersCur->_psliterNext == NULL )
                    _psliterRegisteredIters = NULL; /* only item in list */
                else
                    _psliterRegisteredIters = pslitersCur->_psliterNext;
            }

            pslitersCur->_pslist =         NULL;
            pslitersCur->_psliterNext =    NULL;
            pslitersCur->_pslnodeCurrent = NULL;
            return;
        }
        else
        {
            pslitersPrev = pslitersCur;
            pslitersCur = pslitersCur->_psliterNext;
        }
    }
    ASSERT(FALSE); /* We should never get here */
}


/*********************************************************************

    NAME:       SLIST::BumpIters

    SYNOPSIS:   Moves iterators to next element that point to the passed node

    ENTRY:      A valid SL_NODE that will be going away

    EXIT:       None

    NOTES:      BumpIters is used in cases where a particular element is going
                to be deleted.  BumpIters finds all of the iterators that
                point to the soon to be deceased node and bumps them to the
                next element using their Next() method.

                If the iterator has not been used, then Next needs to be called
                twice to actually move the internal current node, the while loop
                takes care of this.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::BumpIters( SL_NODE* pslnode )
{
    register ITER_SL * psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
        if ( psliter->_pslnodeCurrent == pslnode )
            psliter->Next();
        else
            psliter = psliter->_psliterNext;
}


/*********************************************************************

    NAME:       SLIST::SetIters

    SYNOPSIS:   Sets all registered iterators to the passed value

    ENTRY:      A pointer to a a SL_NODE (or NULL)

    EXIT:       All iterators will point to the passed value

    NOTES:      This is generally used in cases after the list has been
                emptied, so the passed in value will normally be NULL.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::SetIters( SL_NODE *pslnode )
{
    register ITER_SL *psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
    {
        psliter->_pslnodeCurrent = pslnode;
        psliter = psliter->_psliterNext;
    }
}


/*********************************************************************

    NAME:       SLIST::SetIters

    SYNOPSIS:   Changes all registered iterators pointing to the passed SL_NODE
                to point to the passed new SL_NODE

    ENTRY:      Two pointers to SL_NODEs (1st is comparison, second is new)

    EXIT:       All iterators pointing to pslnodeCompVal will point to pslnodeNew

    NOTES:      This is generally used in cases after an element in the list has
                been deleted

    HISTORY:    johnl       30-Oct-90       Created

*********************************************************************/

VOID SLIST::SetIters( SL_NODE *pslnodeCompVal, SL_NODE *pslnodeNew )
{
    register ITER_SL *psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
    {
        if ( psliter->_pslnodeCurrent == pslnodeCompVal )
            psliter->_pslnodeCurrent = pslnodeNew;
        psliter = psliter->_psliterNext;
    }
}


/*********************************************************************

    NAME:       SLIST::CheckIter

    SYNOPSIS:   Confirms the passed iter belongs to this list

    ENTRY:      A pointer to an iterator

    EXIT:       TRUE if the passed iterator belongs, FALSE otherwise.

    NOTES:      CheckIter is generally used with methods that pass in an
                iterator as a parameter (such as Insert).  It is the option
                of the method whether to abort or not when a bad iterator
                is passed in.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

BOOL SLIST::CheckIter( ITER_SL *psliterSearchVal )
{
    register ITER_SL * psliter = _psliterRegisteredIters;

    while ( psliter != NULL && psliter != psliterSearchVal )
        psliter = psliter->_psliterNext;

    return ( psliter != NULL );
}


/*********************************************************************

    NAME:       ITER_SL::ITER_SL

    SYNOPSIS:   Constructor for an SLIST iterator

    ENTRY:      Pointer to a valid SLIST

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::ITER_SL( SLIST *psl )
{
    UIASSERT( psl != NULL );

    _pslist = psl;
    _pslnodeCurrent = _pslist->_pslHead;
    _fUsed = FALSE;
    _psliterNext = NULL;

    _pslist->Register( this );
}


/*********************************************************************

    NAME:       ITER_SL::ITER_SL

    SYNOPSIS:   Constructor for an SLIST iterator that excepts another slist

    ENTRY:      Pointer to a valid SLIST, pointer to valid slist iterator

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::ITER_SL( const ITER_SL &itersl )
{
    _pslist         = itersl._pslist;
    _pslnodeCurrent = itersl._pslnodeCurrent;
    _fUsed          = itersl._fUsed;
    _psliterNext    = itersl._psliterNext;

    _pslist->Register( this );
}


/*********************************************************************

    NAME:       ITER_SL::~ITER_SL

    SYNOPSIS:   Destructor for ITER_SL

    ENTRY:      Assumes valid (registered) iterator, Deregister aborts if this
                isn't the case.

    EXIT:       NONE

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::~ITER_SL()
{
    if ( _pslist != NULL)
        _pslist->Deregister( this );

    _pslist = NULL;
    _pslnodeCurrent = NULL;
    _psliterNext = NULL;
}


/*********************************************************************

    NAME:       ITER_SL::Next

    SYNOPSIS:   Traversal operator of iterator

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL

    NOTES:      The first time Next is called, the iterator isn't bumped, this
                is so the item returned by next is the "current" item.

    HISTORY:

*********************************************************************/

VOID * ITER_SL::Next()
{
    if ( _pslnodeCurrent != NULL )
        if ( _fUsed )
            _pslnodeCurrent = _pslnodeCurrent->_pslnodeNext;
        else
            _fUsed = TRUE;

    return (_pslnodeCurrent!= NULL ? _pslnodeCurrent->_pelem : NULL );
}


/*********************************************************************

    NAME:       ITER_SL::Reset

    SYNOPSIS:   Resets the iterator to the beginning of the list

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   16-Apr-1991     Added check if slist is already destructed

*********************************************************************/

VOID ITER_SL::Reset()
{
    if ( _pslist != NULL )
        _pslnodeCurrent = _pslist->_pslHead;
    _fUsed = FALSE;
}


/*********************************************************************

    NAME:       ITER_SL::QueryProp

    SYNOPSIS:   Returns the "Current" object iterator is pointing to
                (i.e., the object returned by the last call to Next())

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL

    NOTES:

    HISTORY:    JohnL  16-Oct-1990  Created

*********************************************************************/

VOID * ITER_SL::QueryProp()
{
    if ( _pslnodeCurrent != NULL )
        return (_pslnodeCurrent->_pelem);
    else
        return NULL;
}

/*******************************************************************

    NAME:           SLIST::_DebugPrint

    SYNOPSIS:       Prints list & various information

    HISTORY:

********************************************************************/

VOID SLIST::_DebugPrint() const
{
    //  This routine is a no-op if !DEBUG
#if defined(DEBUG) && defined(NOTDEFINED)

    register SL_NODE *_pslnode = _pslHead;
    UINT uCnt = 0;
    char buff[250];

    if ( _pslHead == NULL )
        UIDEBUG(SZ("Empty Slist\n"));

    if ( _psliterRegisteredIters == NULL )
    {
        UIDEBUG(SZ("No registered iterators\n"));
    }
    else
    {
        register ITER_SL *psliter = _psliterRegisteredIters;
        UIDEBUG(SZ("Iter->slnode:\n"));
        while ( psliter != NULL )
        {
            sprintf(buff, SZ("[%Fp]->[%Fp fUsed=%s]\n"),
                     psliter,
                     psliter->_pslnodeCurrent,
                     psliter->_fUsed ? SZ("TRUE") : SZ("FALSE") );
            UIDEBUG( buff );
            psliter = psliter->_psliterNext;
        }
    }

    sprintf(buff,SZ("Head = [%Fp], Tail = [%Fp]\n"), _pslHead, _pslTail );
    UIDEBUG( buff );

    while ( _pslnode != NULL )
    {
        register ITER_SL *psliter = _psliterRegisteredIters;
        UINT uNumIters = 0;

        while ( psliter != NULL ) /* Get # of iters pointing here */
        {
            if ( psliter->_pslnodeCurrent == _pslnode )
                uNumIters++;
            psliter = psliter->_psliterNext;
        }

        sprintf(buff,SZ("[%Fp](%d)\n"), _pslnode, uNumIters );
        UIDEBUG( buff );

        _pslnode = _pslnode->_pslnodeNext;
    }

#endif // debug

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\collect\uatom.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/
/*
    UATOM.CXX
    Universal Atom Management class implementation

    Win32 Atom Management of Unicode strings.


    FILE HISTORY:
        DavidHov    9/10/91     Created

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

/**********************************************************************/
/*         Static variables and Class UATOM                           */
/**********************************************************************/

#define HUATOMSIZE     (sizeof (VOID *))
#define UATOMHASHRANGE (256)
#define UATOMHASHMAX   (UATOMHASHRANGE-1)
#define UATOMINFINITY  (10000)
#define UATOMMAXSTRING (256)

/*************************************************************************

    NAME:       UATOM_LINKAGE

    SYNOPSIS:   Base class for linkable objects

    INTERFACE:  Private!

    PARENT:     none

    USES:       none

    CAVEATS:

    NOTES:

    HISTORY:
        DavidHov   9/10/91  Created

**************************************************************************/

class UATOM ;                                   // Forward Definition

  //   Linkage structure; defined independently of UATOM
  //   for use in hash table

class UATOM_LINKAGE
{
public:
    UATOM_LINKAGE * _puaFwd, * _puaBack ;        //  Doubly-linked list

    UATOM_LINKAGE () ;
    ~ UATOM_LINKAGE () ;

    inline UATOM * Fwd ()
        { return (UATOM *) _puaFwd ; }
    inline UATOM * Back ()
        { return (UATOM *) _puaBack ; }
    inline BOOL QueryLinked ()
        { return this != _puaFwd ; }
    inline void Init()                          //  Initialize link
        { _puaFwd = _puaBack = this ; }
    void Link ( UATOM_LINKAGE * pua ) ;
    void Unlink () ;
};

UATOM_LINKAGE :: UATOM_LINKAGE ()
{
    Init();
}

UATOM_LINKAGE :: ~ UATOM_LINKAGE ()
{
    Unlink() ;
}

VOID UATOM_LINKAGE :: Link ( UATOM_LINKAGE * pua )
{
    Unlink() ;

    _puaBack = pua->_puaBack ;
    _puaFwd = pua ;
    pua->_puaBack->_puaFwd = this ;
    _puaFwd->_puaBack = this ;
}

    //  Delink an atom from its chain

VOID UATOM_LINKAGE :: Unlink ()
{
    if ( QueryLinked() )
    {
        _puaFwd->_puaBack = _puaBack ;
        _puaBack->_puaFwd = _puaFwd ;
        Init() ;
    }
}

    //   Structure definition for UATOM_MANAGER's hash table.

class UATOM_REGION
{
public:
    UATOM_LINKAGE _aualTable [ UATOMHASHRANGE ] ;    //  Hash table
    UATOM_REGION () ;
    ~ UATOM_REGION () ;
};

UATOM_REGION :: UATOM_REGION ()
{
}

UATOM_REGION :: ~ UATOM_REGION ()
{
}

/*************************************************************************

    NAME:       UATOM

    SYNOPSIS:   Internal Universal Atom class


    INTERFACE:  Only through HUATOM!

    PARENT:     UATOM_LINKAGE

    USES:       none

    CAVEATS:

    NOTES:

    HISTORY:
        DavidHov    9/10/91     Created

**************************************************************************/

class UATOM : public UATOM_LINKAGE, public NLS_STR
{
public:
    UATOM ( NLS_STR & nlsStr ) ;
    ~ UATOM () ;
};


    //  Constructor.  Use the given NLS_STR.

UATOM :: UATOM ( NLS_STR & nlsStr )
    : NLS_STR( nlsStr )
{
}


UATOM :: ~ UATOM ()
{
}


//  Pointer to the sole UATOM_MANAGER instance

UATOM_MANAGER * UATOM_MANAGER :: pInstance = NULL ;


/*******************************************************************

    NAME:       UATOM_MANAGER::UATOM_MANAGER

    SYNOPSIS:   Constructor of the Atom Manager

    ENTRY:      ulcbSize =  size of memory desired for base allocation
                pvMem    =  optional pointer to extant memory

    EXIT:       Table initialized.

    RETURNS:    nothing

    NOTES:      if given, the "pvMem" pointed data will be used for
                the atom and hash table.

    HISTORY:
        DavidHov    9/10/91     Created

********************************************************************/

UATOM_MANAGER :: UATOM_MANAGER ()
{
    if ( pInstance )
    {
        ReportError( ERROR_INVALID_ACCESS ) ;
        return ;
    }

    //  Allocate the hash table; construction initializes all
    //  the linkage within.

    _pumRegion = new UATOM_REGION ;

    if ( _pumRegion == NULL )
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
        return ;
    }
}

/*******************************************************************

    NAME:       UATOM_MANAGER::Initialize

    SYNOPSIS:   Static routine to create the sole instance of
                a UATOM_MANAGER.

    ENTRY:      Nothing

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        DavidHov    9/10/91     Created

********************************************************************/
APIERR UATOM_MANAGER :: Initialize ()
{
    if ( pInstance )
    {
        return ERROR_INVALID_ACCESS ;
    }

    pInstance = new UATOM_MANAGER ;

    return pInstance ? pInstance->QueryError()
                     : ERROR_NOT_ENOUGH_MEMORY ;
}

/*******************************************************************

    NAME:       UATOM_MANAGER::Terminate

    SYNOPSIS:   Destroy the instance of the UATOM_MANAGER

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    ERROR_INVALIED_ACCESS if no instance exists.

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/

APIERR UATOM_MANAGER :: Terminate ()
{
    if ( pInstance )
    {
        delete pInstance ;
        pInstance = NULL ;
        return NERR_Success ;
    }
    return ERROR_INVALID_ACCESS ;
}

/*******************************************************************

    NAME:       UATOM_MANAGER::~UATOM_MANAGER

    SYNOPSIS:   Destructor of the atom table manager.

                The linked lists of the UATOM_REGION are walked
                and all UATOMs thereon are destroyed.

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/
UATOM_MANAGER :: ~ UATOM_MANAGER ()
{
    UATOM_LINKAGE * pual = _pumRegion->_aualTable ;

    //  Iterate the link-list anchor table and delete every atom.

    for ( int i = 0 ; i < UATOMHASHRANGE ; i++, pual++ )
    {
        for ( int j = 0 ;
              pual != pual->_puaFwd ;
              j++ )
        {
            UIASSERT( j < UATOMINFINITY ) ;
            delete (UATOM *) pual->_puaFwd ;
        }
    }

    delete _pumRegion ;
}


/*******************************************************************

    NAME:       UATOM_MANAGER::Tokenize

    SYNOPSIS:   Hash the given string into a bounded value.  Then,
                if unique, create the UATOM for it and link it
                into the atom table.

    ENTRY:      const TCHAR *       pointer to string
                BOOL                TRUE if string should already
                                    exists; default is FALSE.

    EXIT:

    RETURNS:    pointer to created/found UATOM or NULL if unsuccessful

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/

UATOM * UATOM_MANAGER :: Tokenize ( const TCHAR * puzStr, BOOL fExists )
{
    register int iHash = UATOMHASHRANGE - 1 ;
    register int carry ;
    UATOM_LINKAGE * pualLink ;
    UATOM * puaNext ;
    TCHAR c ;
    ALIAS_STR nlsNew( puzStr ) ;

    //  Hash the string
    {
        ISTR isIndex( nlsNew ) ;
        for ( iHash = UATOMHASHMAX ;
              c = nlsNew.QueryChar( isIndex ) ;
              ++isIndex )
        {
            carry = iHash >=UATOMHASHMAX ;
            iHash = ( iHash << 1 ) | carry ;
            iHash ^= c ;
        }
        iHash &= UATOMHASHMAX ;
    }

    //  See if it's in the linked lists already.

    pualLink = & _pumRegion->_aualTable[ iHash ] ;

    for ( puaNext = pualLink->Fwd() ;
          puaNext != pualLink ;
          puaNext = puaNext->Fwd() )
    {
        if ( *puaNext == nlsNew )
            break ;
    }

    //  If we returned to ground, we've failed

    if ( puaNext == pualLink )
        puaNext = NULL ;

    //  If failure and it isn't supposed to exist, create it.

    if ( puaNext == NULL && (!fExists) )
    {
        puaNext = new UATOM( nlsNew ) ;

        if ( puaNext && puaNext->QueryError() == 0 )
        {
            puaNext->Link( pualLink ) ;
        }
        else
        {
            UIDEBUG( SZ("Out of memory in UATOM_MANAGER::Tokenize") ) ;
            puaNext = NULL ;
        }
    }

    //  Return the result

    return puaNext ;
}


/*******************************************************************

    NAME:       HUATOM::HUATOM

    SYNOPSIS:   Construct for handle to atom.

    ENTRY:      const TCHAR *       pointer to string
                BOOL                TRUE if string should already
                                    exists; default is FALSE.
    EXIT:       nothing

    RETURNS:    nothing

    NOTES:      Creates NULL HUATOM if no string is specified.

    HISTORY:
         DavidHov   9/10/91     Created
         beng       28-Mar-1992 Fixed char-TCHAR bug

********************************************************************/

HUATOM :: HUATOM (  const TCHAR * puzStr, BOOL fExists )
{
    UIASSERT( UATOM_MANAGER::pInstance != NULL );

    if ( puzStr )
    {
        _puaAtom = UATOM_MANAGER::pInstance->Tokenize( puzStr, fExists ) ;
    }
    else
    {
        _puaAtom = NULL ;
    }
}

/*******************************************************************

    NAME:       HUATOM::QueryText

    SYNOPSIS:   Return a const pointer to the underlying text string

    ENTRY:      nothing

    EXIT:       const TCHAR *           of string or NULL if HUATOM
                                        was NULL.

    RETURNS:

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/
const TCHAR * HUATOM :: QueryText ( ) const
{
    return _puaAtom
         ? _puaAtom->QueryPch()
         : NULL ;
}

/*******************************************************************

    NAME:       HUATOM::QueryNls

    SYNOPSIS:   Return a const pointer to the underlying NLS_STR object

    ENTRY:      nothing

    EXIT:       const NLS_STR *         or NULL if HUATOM was NULL.

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
const NLS_STR * HUATOM :: QueryNls () const
{
    return _puaAtom ;
}

/*******************************************************************

    NAME:       HUATOM::QueryError

    SYNOPSIS:   Return result code from construction of underlying
                NLS_STR.

    ENTRY:

    EXIT:

    RETURNS:   APIERR              of construction of NLS_STR
                                    or NERR_ItemNotVound

    NOTES:

    HISTORY:
         DavidHov    9/10/91     Created

********************************************************************/
APIERR HUATOM :: QueryError () const
{
    return _puaAtom
         ? _puaAtom->QueryError()
         : NERR_ItemNotFound ;
}

/*  End of UATOM.CXX  */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\collect\pch\slist.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    slist.cxx
    LM 3.0 Generic slist package

    This file contains the base routines for the SLIST class defined in
    slist.hxx

    See the beginning of slist.hxx for usage examples.

    FILE HISTORY:
        johnl       24-Jul-1990 Created
        johnl       30-Oct-1990 Modified to reflect functional shift of
                                iterator (item returned by next is the
                                current item)
        beng        07-Feb-1991 Uses lmui.hxx
        johnl       07-Mar-1991 Code review changes
        beng        02-Apr-1991 Replaced nsprintf with sprintf
        terryk      19-Sep-1991 Added {} between UIDEBUG
        KeithMo     09-Oct-1991 Win32 Conversion.
        beng        05-Mar-1992 Disabled debug output

*/

#include "pchcoll.hxx"  //  Precompiled header inclusion

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif

/*********************************************************************

    NAME:       SLIST::SLIST

    SYNOPSIS:   Constructor for the SLIST

    HISTORY:    johnl   19-Jul-90   Created

*********************************************************************/

SLIST::SLIST()
{
    _pslHead = _pslTail = NULL;
    _psliterRegisteredIters = NULL;
}


/*********************************************************************

    NAME:       SLIST::~SLIST

    SYNOPSIS:   Destructor for the SLIST

    HISTORY:    johnl   19-Jul-90   Created

*********************************************************************/

SLIST::~SLIST()
{
    /* Deregister modifies _psliterRegisteredIters (moves it to the next
     * iterator in the list).
     */
    while ( _psliterRegisteredIters != NULL )
        Deregister( _psliterRegisteredIters );
}


/*********************************************************************

    NAME:       SLIST::Add

    SYNOPSIS:   Adds the passed element to the beginning of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY otherwise

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR SLIST::Add( VOID* pelem )
{
    SL_NODE * pslnodeNew = new SL_NODE( _pslHead, pelem );
    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;       /* failure */

    if ( _pslTail == NULL )  /* First item in list */
        _pslTail = pslnodeNew;

    _pslHead = pslnodeNew;

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::QueryNumElem

    SYNOPSIS:   Returns the number of elements in the slist

    ENTRY:      NONE

    EXIT:       A UINT indicating the number of elements in the list.

    HISTORY:    rustanl   15-Jul-90       Created
                johnl     19-Jul-90       Adapted for the SLIST package

*********************************************************************/

UINT SLIST::QueryNumElem()
{
    register SL_NODE * pslnode = _pslHead;
    UINT uCount = 0;

    while ( pslnode != NULL )
    {
        uCount++;
        pslnode = pslnode->_pslnodeNext;
    }

    return uCount;
}


/*********************************************************************

    NAME:       SLIST::Append

    SYNOPSIS:   Adds the passed element to the end of the list.

    ENTRY:      A pointer to a valid element

    EXIT:       NERR_Success if successful, ERROR_NOT_ENOUGH_MEMORY otherwise

    HISTORY:    johnl   19-Jul-90       Created

*********************************************************************/

APIERR SLIST::Append( VOID* pelem )
{
    SL_NODE * pslnodeNew = new SL_NODE( NULL, pelem );

    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    if ( _pslHead == NULL )
        _pslHead = _pslTail = pslnodeNew;
    else
    {
        _pslTail->_pslnodeNext = pslnodeNew;
        _pslTail = pslnodeNew;
    }

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::Insert

    SYNOPSIS:   Insert an element into a slist using the location of the
                passed iterator.  (ITER_SL)

    ENTRY:      Pointer to the element to insert
                Iterator indicating insertion point

    EXIT:       return NERR_Success if successful,
                ERROR_NOT_ENOUGH_MEMORY if an allocation failure occurred
                ERROR_INVALID_DATA if a bad iterator was passed in

    NOTES:      If a bad iterator is passed in (i.e., one not registered on
                this list), the current behavior is to assert out.  We may
                want to change this to return an error code (even though this
                should be considered as a programmer's error).

                The insertion point is always "previous" to the element the
                iterator is pointing at.  If the iterator is at the end of
                the list (i.e., the current position is NULL), then Insert
                is equivalent to Append.

                The algorithm (suggested by PeterWi) looks like:


                    Before         Insert 15 at iter      After

                   A[val=10]                             A[val=10]
                      |                                     |
                   B[val=20]<--iter                      B[val=15]
                      |                                     |
                   C[val=30]                             D[val=20]<--iter
                                                            |
                                                         C[val=30]

    HISTORY:    johnl   7-19-90     Created
                johnl  10-30-90     Modified to reflect functional change in
                                    iterator

*********************************************************************/

APIERR SLIST::Insert( VOID* pelem, ITER_SL& sliter )
{
    if ( !CheckIter( &sliter ) )
    {
        UIDEBUG(SZ("SLIST::Insert - Attempted to insert w/ Unregistered iterator\n\r"));
        return ERROR_INVALID_DATA;
    }

    SL_NODE * pslnodeCurrent = sliter._pslnodeCurrent;

    if ( pslnodeCurrent == NULL )   /* Check if iter at end/beginning */
        return (Append( pelem ));

    SL_NODE * pslnodeNew = new SL_NODE( pslnodeCurrent->_pslnodeNext,
                                        pslnodeCurrent->_pelem);
    if ( pslnodeNew == NULL )
        return ERROR_NOT_ENOUGH_MEMORY;               /* Memory failure */

    pslnodeCurrent->Set( pslnodeNew, pelem );

    if ( _pslTail == pslnodeCurrent )   // Fixup tail pointer if necessary
        _pslTail = pslnodeNew;

    BumpIters( pslnodeCurrent );

    return NERR_Success;
}


/*********************************************************************

    NAME:       SLIST::Remove

    SYNOPSIS:   Removes the element the past iterator points at

    ENTRY:      A Valid registered iterator

    EXIT:       A pointer to the newly removed element
                NULL if the list is empty or the iterator is at the end of
                the list.

    NOTES:      NULL is returned if an unregistered iterator is passed in, the
                slist is empty or the iterator is at the end of the list.


    HISTORY:    johnl   7-19-90     Created
                johnl  10-30-90     Changed behavior so it removes the element
                                    the iterator is pointing (as opposed to
                                    the element to the left).

*********************************************************************/

VOID * SLIST::Remove( ITER_SL& sliter )
{
    if ( !CheckIter( &sliter ) )
    {
        UIDEBUG(SZ("SLIST::Remove - Attempted to insert w/ Unregistered iterator\n\r"));
        return NULL;
    }

    SL_NODE *pslnodeCurrent = sliter._pslnodeCurrent;

    if ( pslnodeCurrent == NULL )
        return NULL;  /* Iter at end of Slist */

    register SL_NODE *_pslnodeTarget = NULL;   // Node that's going away
    VOID * _pelem;

    /*
     *  if ( the next node is not NULL )  // Can we fix things up w/o trav.?
     *      save pelem for the return     // Yes
     *      make target the next node
     *      Update iterators so the element position doesn't change in the list
     *      assign the current node the contents of the next node
     *  else // this is the last item in the list
     *      Find the previous item in the list
     *      if there is no prev. item
     *          set head & tail to NULL, this was the only item in the list
     *      else
     *          set the prev. item's next pointer to NULL (last item in list)
     *      set the target node
     *      save the pelem to return it
     */

    if ( pslnodeCurrent->_pslnodeNext != NULL )
    {
        _pelem = pslnodeCurrent->_pelem;

        _pslnodeTarget = pslnodeCurrent->_pslnodeNext;
        SetIters( _pslnodeTarget, pslnodeCurrent );

        pslnodeCurrent->Set( pslnodeCurrent->_pslnodeNext->_pslnodeNext,
                             pslnodeCurrent->_pslnodeNext->_pelem );

        if ( _pslnodeTarget == _pslTail )   // Fixup tail pointer
            _pslTail = pslnodeCurrent;
    }
    else
    {
        // This is the last (position) item in the list
        SL_NODE *_pslnodePrev = FindPrev( pslnodeCurrent );

        if ( _pslnodePrev == NULL )     // If only item in the slist
            _pslHead = _pslTail = NULL;
        else
        {
            _pslnodePrev->_pslnodeNext = NULL;
            _pslTail = _pslnodePrev;
        }

        _pslnodeTarget = pslnodeCurrent;
        _pelem = pslnodeCurrent->_pelem;
    }

    BumpIters( _pslnodeTarget );  /* Move iters to next node... */

    delete _pslnodeTarget;
    return _pelem;
}


/*********************************************************************

    NAME:       SLIST::FindPrev

    SYNOPSIS:   Private method to find the previous element in the list.

    ENTRY:      SL_NODE that we want to find the previous node to.

    EXIT:       The previous node if successful, or NULL.

    HISTORY:    johnl   7-19-90     Created

*********************************************************************/

SL_NODE* SLIST::FindPrev( SL_NODE *pslnode )
{
    if ( pslnode == NULL )
        return NULL;

    register SL_NODE *_pslnode = _pslHead, *_pslnodePrev = NULL;

    while ( _pslnode != NULL && _pslnode != pslnode )
    {
        _pslnodePrev = _pslnode;
        _pslnode = _pslnode->_pslnodeNext;
    }
    return ( _pslnode == NULL ? NULL : _pslnodePrev );
}


/*********************************************************************

    NAME:       SLIST::Register

    SYNOPSIS:   Adds the pointer to the passed iterator to the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator

    EXIT:

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::Register( ITER_SL *psliter )
{
    psliter->_psliterNext = _psliterRegisteredIters;
    _psliterRegisteredIters = psliter;
}


/*********************************************************************

    NAME:       SLIST::Deregister

    SYNOPSIS:   Removes the pointer to the passed iterator from the current list
                of registered iterators.

    ENTRY:      A pointer to a valid iterator, registered iterator

    EXIT:       NONE

    NOTES:      Deregister must succeed, if it fails, then an internal error
                has occurred.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::Deregister( ITER_SL *psliter )
{
    register ITER_SL * pslitersCur  = _psliterRegisteredIters,
                     * pslitersPrev = NULL;

    while ( pslitersCur != NULL )
    {
        if ( pslitersCur == psliter )
        {
            if ( pslitersPrev != NULL ) /* if not first node in list */
                pslitersPrev->_psliterNext = pslitersCur->_psliterNext;

            else
            {
                if ( pslitersCur->_psliterNext == NULL )
                    _psliterRegisteredIters = NULL; /* only item in list */
                else
                    _psliterRegisteredIters = pslitersCur->_psliterNext;
            }

            pslitersCur->_pslist =         NULL;
            pslitersCur->_psliterNext =    NULL;
            pslitersCur->_pslnodeCurrent = NULL;
            return;
        }
        else
        {
            pslitersPrev = pslitersCur;
            pslitersCur = pslitersCur->_psliterNext;
        }
    }
    ASSERT(FALSE); /* We should never get here */
}


/*********************************************************************

    NAME:       SLIST::BumpIters

    SYNOPSIS:   Moves iterators to next element that point to the passed node

    ENTRY:      A valid SL_NODE that will be going away

    EXIT:       None

    NOTES:      BumpIters is used in cases where a particular element is going
                to be deleted.  BumpIters finds all of the iterators that
                point to the soon to be deceased node and bumps them to the
                next element using their Next() method.

                If the iterator has not been used, then Next needs to be called
                twice to actually move the internal current node, the while loop
                takes care of this.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::BumpIters( SL_NODE* pslnode )
{
    register ITER_SL * psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
        if ( psliter->_pslnodeCurrent == pslnode )
            psliter->Next();
        else
            psliter = psliter->_psliterNext;
}


/*********************************************************************

    NAME:       SLIST::SetIters

    SYNOPSIS:   Sets all registered iterators to the passed value

    ENTRY:      A pointer to a a SL_NODE (or NULL)

    EXIT:       All iterators will point to the passed value

    NOTES:      This is generally used in cases after the list has been
                emptied, so the passed in value will normally be NULL.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

VOID SLIST::SetIters( SL_NODE *pslnode )
{
    register ITER_SL *psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
    {
        psliter->_pslnodeCurrent = pslnode;
        psliter = psliter->_psliterNext;
    }
}


/*********************************************************************

    NAME:       SLIST::SetIters

    SYNOPSIS:   Changes all registered iterators pointing to the passed SL_NODE
                to point to the passed new SL_NODE

    ENTRY:      Two pointers to SL_NODEs (1st is comparison, second is new)

    EXIT:       All iterators pointing to pslnodeCompVal will point to pslnodeNew

    NOTES:      This is generally used in cases after an element in the list has
                been deleted

    HISTORY:    johnl       30-Oct-90       Created

*********************************************************************/

VOID SLIST::SetIters( SL_NODE *pslnodeCompVal, SL_NODE *pslnodeNew )
{
    register ITER_SL *psliter = _psliterRegisteredIters;

    while ( psliter != NULL )
    {
        if ( psliter->_pslnodeCurrent == pslnodeCompVal )
            psliter->_pslnodeCurrent = pslnodeNew;
        psliter = psliter->_psliterNext;
    }
}


/*********************************************************************

    NAME:       SLIST::CheckIter

    SYNOPSIS:   Confirms the passed iter belongs to this list

    ENTRY:      A pointer to an iterator

    EXIT:       TRUE if the passed iterator belongs, FALSE otherwise.

    NOTES:      CheckIter is generally used with methods that pass in an
                iterator as a parameter (such as Insert).  It is the option
                of the method whether to abort or not when a bad iterator
                is passed in.

    HISTORY:    johnl       19-Jul-90       Created

*********************************************************************/

BOOL SLIST::CheckIter( ITER_SL *psliterSearchVal )
{
    register ITER_SL * psliter = _psliterRegisteredIters;

    while ( psliter != NULL && psliter != psliterSearchVal )
        psliter = psliter->_psliterNext;

    return ( psliter != NULL );
}


/*********************************************************************

    NAME:       ITER_SL::ITER_SL

    SYNOPSIS:   Constructor for an SLIST iterator

    ENTRY:      Pointer to a valid SLIST

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::ITER_SL( SLIST *psl )
{
    UIASSERT( psl != NULL );

    _pslist = psl;
    _pslnodeCurrent = _pslist->_pslHead;
    _fUsed = FALSE;
    _psliterNext = NULL;

    _pslist->Register( this );
}


/*********************************************************************

    NAME:       ITER_SL::ITER_SL

    SYNOPSIS:   Constructor for an SLIST iterator that excepts another slist

    ENTRY:      Pointer to a valid SLIST, pointer to valid slist iterator

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::ITER_SL( const ITER_SL &itersl )
{
    _pslist         = itersl._pslist;
    _pslnodeCurrent = itersl._pslnodeCurrent;
    _fUsed          = itersl._fUsed;
    _psliterNext    = itersl._psliterNext;

    _pslist->Register( this );
}


/*********************************************************************

    NAME:       ITER_SL::~ITER_SL

    SYNOPSIS:   Destructor for ITER_SL

    ENTRY:      Assumes valid (registered) iterator, Deregister aborts if this
                isn't the case.

    EXIT:       NONE

    NOTES:

    HISTORY:    johnl   7-25-90     Created

*********************************************************************/

ITER_SL::~ITER_SL()
{
    if ( _pslist != NULL)
        _pslist->Deregister( this );

    _pslist = NULL;
    _pslnodeCurrent = NULL;
    _psliterNext = NULL;
}


/*********************************************************************

    NAME:       ITER_SL::Next

    SYNOPSIS:   Traversal operator of iterator

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL

    NOTES:      The first time Next is called, the iterator isn't bumped, this
                is so the item returned by next is the "current" item.

    HISTORY:

*********************************************************************/

VOID * ITER_SL::Next()
{
    if ( _pslnodeCurrent != NULL )
        if ( _fUsed )
            _pslnodeCurrent = _pslnodeCurrent->_pslnodeNext;
        else
            _fUsed = TRUE;

    return (_pslnodeCurrent!= NULL ? _pslnodeCurrent->_pelem : NULL );
}


/*********************************************************************

    NAME:       ITER_SL::Reset

    SYNOPSIS:   Resets the iterator to the beginning of the list

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        Johnl   16-Apr-1991     Added check if slist is already destructed

*********************************************************************/

VOID ITER_SL::Reset()
{
    if ( _pslist != NULL )
        _pslnodeCurrent = _pslist->_pslHead;
    _fUsed = FALSE;
}


/*********************************************************************

    NAME:       ITER_SL::QueryProp

    SYNOPSIS:   Returns the "Current" object iterator is pointing to
                (i.e., the object returned by the last call to Next())

    ENTRY:      None

    EXIT:       Returns a pointer to the current element or NULL

    NOTES:

    HISTORY:    JohnL  16-Oct-1990  Created

*********************************************************************/

VOID * ITER_SL::QueryProp()
{
    if ( _pslnodeCurrent != NULL )
        return (_pslnodeCurrent->_pelem);
    else
        return NULL;
}

/*******************************************************************

    NAME:           SLIST::_DebugPrint

    SYNOPSIS:       Prints list & various information

    HISTORY:

********************************************************************/

VOID SLIST::_DebugPrint() const
{
    //  This routine is a no-op if !DEBUG
#if defined(DEBUG) && defined(NOTDEFINED)

    register SL_NODE *_pslnode = _pslHead;
    UINT uCnt = 0;
    char buff[250];

    if ( _pslHead == NULL )
        UIDEBUG(SZ("Empty Slist\n"));

    if ( _psliterRegisteredIters == NULL )
    {
        UIDEBUG(SZ("No registered iterators\n"));
    }
    else
    {
        register ITER_SL *psliter = _psliterRegisteredIters;
        UIDEBUG(SZ("Iter->slnode:\n"));
        while ( psliter != NULL )
        {
            sprintf(buff, SZ("[%Fp]->[%Fp fUsed=%s]\n"),
                     psliter,
                     psliter->_pslnodeCurrent,
                     psliter->_fUsed ? SZ("TRUE") : SZ("FALSE") );
            UIDEBUG( buff );
            psliter = psliter->_psliterNext;
        }
    }

    sprintf(buff,SZ("Head = [%Fp], Tail = [%Fp]\n"), _pslHead, _pslTail );
    UIDEBUG( buff );

    while ( _pslnode != NULL )
    {
        register ITER_SL *psliter = _psliterRegisteredIters;
        UINT uNumIters = 0;

        while ( psliter != NULL ) /* Get # of iters pointing here */
        {
            if ( psliter->_pslnodeCurrent == _pslnode )
                uNumIters++;
            psliter = psliter->_psliterNext;
        }

        sprintf(buff,SZ("[%Fp](%d)\n"), _pslnode, uNumIters );
        UIDEBUG( buff );

        _pslnode = _pslnode->_pslnodeNext;
    }

#endif // debug

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\dll3\makefile.inc ===
# Expects: DLL_SOURCELIBS, SOURCE_DEF, TARGET_DEF

#  Define names of target DLLs
!include $(UI)\common\src\names.mk

!IF $(386)
DLL_SRCLIBS=$(DLL_SOURCELIBS:*=i386)
UISWITCH=-s
!ELSEIF $(AMD64)
DLL_SRCLIBS=$(DLL_SOURCELIBS:*=amd64)
UISWITCH=
!ELSEIF $(IA64)
DLL_SRCLIBS=$(DLL_SOURCELIBS:*=ia64)
UISWITCH=-ia64
!ELSE
!ERROR Must have one of (x86, AMD64, or IA64)
!ENDIF

$(TARGET_DEF): $(DLL_SRCLIBS)
    if exist $(TARGET_DEF) del $(TARGET_DEF)
    @echo Building $(TARGET_DEF)
    link -dump -symbols $(**) | qgrep -v ??_G | qgrep -v ??_E |uixport $(UISWITCH) -h:$(SOURCE_DEF) -o:$(TARGET_DEF)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\dll3\dll0\init.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    init.cxx
    Initialization for NETUI0

    FILE HISTORY:
        beng        30-Jul-1992 Header added
        beng        04-Aug-1992 Heap residue added; converted to C++
        jonn        25-Mar-1993 ITG special sort
        jonn        12-Sep-1995 NETUI_InitIsDBCS()
*/

#define INCL_WINDOWS
#define INCL_NETLIB
#include "lmui.hxx"
#include "dbgstr.hxx"

#include "heapdbg.hxx"


extern "C"
{
    #include "lmuicmn.h"
    #include "lmuidbcs.h"

    /* hackety hack hack hack */
    int errno = 0; /* BUGBUG! */

    //  The module handle for this DL

    HMODULE hmodBase = 0 ;

    // This is implemented by misc\misc\lmuidbcs.cxx.  See
    // that module before modifying parameters.
    VOID NETUI_InitIsDBCS();

    //  The init routine itself
    BOOL DllMain( HMODULE hdll, DWORD dwReason, LPVOID lpReserved ) ;

    //  Allow general access to the HMODULE for this DLL.
    extern HMODULE HmodDll0 (void) ;
}


//
    //  As in BLTINIT.CXX, look for NETUI.INI and initialize the
    //  debug output stream.
    //
static
OUTPUTSINK * makeOutputSink ()
{
    OUTPUTSINK * pOsinkResult = NULL ;

#if defined(DEBUG)
    //
    // We must find a netui.ini, which must contain a section:
    // [BLT]
    //      fDebugOutput=1
    //

    UINT nVal = ::GetPrivateProfileInt( SZ("blt"),
                                        SZ("fDebugOutput"),
                                        0,
                                        SZ("netui.ini") ) ;
    if ( nVal )
        pOsinkResult = new OUTPUT_TO_AUX ;
    else
#endif
        pOsinkResult = new OUTPUT_TO_NUL ;

    return pOsinkResult ;
}

BOOL DllMain( HMODULE hdll, DWORD dwReason, LPVOID lpReserved )
{
    //  Pointers to the initial debug stream.  These are created
    //  in lieu of the real, BLT-leel streams created during the
    //  initialization of NETUI2.DLL.

    static OUTPUTSINK * pStreamSink = NULL ;
    static DBGSTREAM * pDebugStream = NULL ;

    UNREFERENCED(lpReserved);

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        DisableThreadLibraryCalls(hdll);

        hmodBase = hdll ;

        NETUI_InitIsDBCS();

        InitCompareParam(); // see string\string\uinetlib.cxx

        if ( pStreamSink = makeOutputSink() )
        {
            pDebugStream = new DBGSTREAM( pStreamSink ) ;
        }
        if ( pDebugStream )
        {
            DBGSTREAM::SetCurrent( pDebugStream ) ;
        }
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        delete pDebugStream ;
        delete pStreamSink ;
        hmodBase = 0 ;
    }

    return TRUE;
}

   //
   //  Allow NETUI2.DLL to access resources in this DLL if necessary.
   //
HMODULE HmodDll0 (void)
{
    return hmodBase ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\dll3\dll0\makefile.inc ===
#
# List of source libraries for the DLL
#

DLL_SOURCELIBS=..\..\collect\collect\$(O)\uicollct.lib \
               ..\..\string\string\$(O)\uistr.lib      \
               ..\..\string\pch\$(O)\uistrpch.lib      \
               ..\..\misc\bin\$(O)\uimisc.lib          \
               ..\..\profile\profile\$(O)\uiprof.lib   \
               ..\..\reg\reg\$(O)\uireg.lib            \

SOURCE_DEF= netui0.hdr
TARGET_DEF= $(O)\netui0.def

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\dll3\dll1\init.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    init.cxx
    Initialization for NETUI1

    FILE HISTORY:
        beng        30-Jul-1992 Header added
        KeithMo     06-May-1993 Optimized into obscurity.
        BruceFo     02-Feb-1996 Added DllMain and DisableThreadLibraryCalls()
*/

#define INCL_WINDOWS
#include "lmui.hxx"

extern "C"
{
    BOOL WINAPI DllMain( HMODULE hdll, DWORD dwReason, LPVOID lpReserved ) ;
}

BOOL WINAPI DllMain( HMODULE hdll, DWORD dwReason, LPVOID lpReserved )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hdll);
        break;

    default:
        break;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\dll3\dll2\makefile.inc ===
#
# How this works: since lmuicmn.def will (should) be identical between
# MIPS and 386 as long as both use cfront, I only run one even if both
# envs are specified in the build.
#
# When these diverge - i.e. when 386 abandons cfront - each will need to
# build its own .def in $(O).
#

#
# List of source libraries for the DLL
#

DLL_SOURCELIBS=..\..\blt\blt\$(O)\uiblt.lib            \
               ..\..\blt\bltcc\$(O)\uibltcc.lib        \
               ..\..\applib\bin\$(O)\uiapplib.lib


SOURCE_DEF= netui2.hdr
TARGET_DEF= $(O)\netui2.def

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\dll3\dll2\init.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    init.cxx
    Initialization for LMUICMN0

    FILE HISTORY:
        beng        30-Jul-1992 Header added
        beng        04-Aug-1992 Heap residue added; converted to C++
        jonn        25-Mar-1993 ITG special sort
*/

#define INCL_WINDOWS
#define INCL_NETLIB
#include "lmui.hxx"

#include "blt.hxx"

#include "heapdbg.hxx"


extern "C"
{
    #include "lmuicmn.h"

    /* hackety hack hack hack */
    int errno = 0; /* BUGBUG! */

    HMODULE hmodBlt = 0;

    BOOL DllMain( HMODULE hmod, DWORD nReason, LPVOID lpReserved ) ;
}


BOOL DllMain( HMODULE hmod, DWORD nReason, LPVOID lpReserved )
{
    UNREFERENCED(lpReserved);

    if (nReason == DLL_PROCESS_ATTACH)
    {
	DisableThreadLibraryCalls(hmod);

	::hmodBlt = hmod;
	if ( BLT::InitDLL() )
	    return FALSE ;
    }
    else if (nReason == DLL_PROCESS_DETACH)
    {
	BLT::TermDLL() ;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\dll3\dll1\makefile.inc ===
DLL_SOURCELIBS=..\..\mnet32\pch\$(O)\pchmn32.lib       \
               ..\..\mnet32\mnet32\$(O)\uimnet32.lib   \
               ..\..\mnet32\netslow\$(O)\netslow.lib   \
               ..\..\lmobj\lmobj\$(O)\lmobj.lib        \
               ..\..\lmobj\lmoenum\$(O)\lmoenum.lib    \
               ..\..\lmobj\log\$(O)\lmlog.lib

SOURCE_DEF= netui1.hdr
TARGET_DEF= $(O)\netui1.def

!INCLUDE ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\apisess.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
 * This module contains the implementation of API_SESSION.
 *
 *
 * History
 *      thomaspa        08/04/92        Created
 */


#include "pchlmobj.hxx"  // Precompiled header

APIERR ConnectToNullSession( const NLS_STR & nlsRemote ) ;

/*******************************************************************

    NAME: API_SESSION::API_SESSION

    SYNOPSIS: Constructor

    ENTRY: pszServer - the server to which to connect.

    EXIT: none

    NOTES:

    HISTORY:
        thomaspa        08/04/92        Created

********************************************************************/
API_SESSION::API_SESSION( const TCHAR * pszServer, BOOL fNullSessionOK ) :
    _pnlsRemote( NULL )
{
    /* We shouldn't have to connect to the local machines IPC$ (i.e.,
     * we've already been validated).
     */
    if ( pszServer == NULL || !*pszServer )
        return ;



    // Construct the UNC path to the IPC$ share on the server
     _pnlsRemote = new NLS_STR(pszServer);

    APIERR err = ERROR_NOT_ENOUGH_MEMORY;
    if ( _pnlsRemote == NULL
        || (err = _pnlsRemote->QueryError()) != NERR_Success )
    {
        delete _pnlsRemote;
        _pnlsRemote = NULL;
        ReportError( err );
        return;
    }

    ISTR istr( *_pnlsRemote );
    if ( _pnlsRemote->QueryChar( istr ) != TCH('\\') )
    {
        ALIAS_STR nlsWhackWhack = SZ("\\\\");
        if ( !_pnlsRemote->InsertStr( nlsWhackWhack, istr ) )
        {
            ReportError( _pnlsRemote->QueryError() );
            return;
        }
    }


    // No need to create session to ourselves
    DWORD cch = MAX_COMPUTERNAME_LENGTH+1;
    BUFFER buf( sizeof(TCHAR)*(cch) );
    if (!buf)
    {
        ReportError( ERROR_NOT_ENOUGH_MEMORY );
        return;
    }

    if ( !::GetComputerName( (LPTSTR)(buf.QueryPtr()), &cch ))
    {
            DWORD errLast = ::GetLastError();
            ReportError( errLast );
            return;
    }

    ISTR istrRemote( *_pnlsRemote );
    istrRemote += 2;

    if( !::I_MNetComputerNameCompare( _pnlsRemote->QueryPch( istrRemote ),
                                      (const TCHAR *)buf.QueryPtr() ) )
    {
        delete _pnlsRemote;
        _pnlsRemote = NULL;
        return;
    }

    ALIAS_STR nlsIPC( SZ("IPC$") );

    if ( (err = _pnlsRemote->AppendChar( TCH('\\') )) != NERR_Success
        || (err = _pnlsRemote->Append( nlsIPC )) != NERR_Success )
    {
        ReportError( err );
        return;
    }


    // Try a connection using the current credentials
    struct use_info_1 ui1;
    ui1.ui1_local = NULL;
    ui1.ui1_remote = (TCHAR *)_pnlsRemote->QueryPch();
    ui1.ui1_password = NULL;
    ui1.ui1_asg_type = USE_IPC;

    err = ::MNetUseAdd( NULL, 1, (BYTE *)&ui1, sizeof(ui1) );

    switch( err )
    {
    case NERR_Success:
        break;
    case ERROR_SESSION_CREDENTIAL_CONFLICT:
        // They must already have a valid session, use it.
        delete _pnlsRemote;
        _pnlsRemote = NULL;
        break;

    default:
        DBGEOL( SZ("ADMIN: API_SESSION: bad first error ") << err );
        // fall through
    case ERROR_ACCESS_DENIED:
    case ERROR_LOGON_FAILURE:
    case ERROR_TRUSTED_DOMAIN_FAILURE:

        if ( err = ::ConnectToNullSession( *_pnlsRemote ) )
        {
            if ( err == ERROR_SESSION_CREDENTIAL_CONFLICT )
            {
                delete _pnlsRemote ;
                _pnlsRemote = NULL ;
                err = NERR_Success ;
            }
            else
                ReportError( err ) ;
        }
        break;
    }

    return;
}



/*******************************************************************

    NAME: API_SESSION::~API_SESSION

    SYNOPSIS: Destructor

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
        thomaspa        08/04/92        Created

********************************************************************/
API_SESSION::~API_SESSION( )
{

    if ( _pnlsRemote != NULL )
    {
        (void)::MNetUseDel( NULL,
                            (TCHAR *)_pnlsRemote->QueryPch(),
                            USE_NOFORCE );

        delete _pnlsRemote;
        _pnlsRemote = NULL;
    }
}

/*******************************************************************

    NAME:       ConnectToNullSession

    SYNOPSIS:   Attempts to connect using the NULL session

    ENTRY:      nlsRemote - Remote resource to connect to

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   03-Dec-1992     Broke out from constructor

********************************************************************/


APIERR ConnectToNullSession( const NLS_STR & nlsRemote )
{
    // Try a connection using the NULL session
    struct use_info_2 ui2;

    ui2.ui2_local = NULL;
    ui2.ui2_remote = (TCHAR *)nlsRemote.QueryPch();
    ui2.ui2_password = SZ("");
    ui2.ui2_asg_type = USE_IPC;
    ui2.ui2_username = SZ("");
    ui2.ui2_domainname = SZ("");

    return ::MNetUseAdd( NULL, 2, (BYTE *)&ui2, sizeof(ui2) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmoacces.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    LMOAcces.cxx
    Definition of the NET_ACCESS_1 class


    FILE HISTORY:
	rustanl     20-May-1991     Created
	Johnl	    05-Aug-1991     Converted ACCPERM to NET_ACCESS
	Johnl	    14-Aug-1991     Modified to conform to NEW_LMOBJ changes
	rustanl     21-Aug-1991     Renamed NEW_LM_OBJ buffer methods
	terryk	    07-Oct-1991	    type changes for NT
	KeithMo	    08-Oct-1991	    Now includes LMOBJP.HXX.
	terryk	    17-Oct-1991	    WIN 32 conversion
	terryk	    21-Oct-1991	    remove memory.h reference
				    change UINT to USHORT2ULONG

*/

#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:	NET_ACCESS::NET_ACCESS

    SYNOPSIS:	NET_ACCESS constructor

    ENTRY:	pszServer -	    Pointer to server name where
				    the pszResource path resides.
				    May be NULL to indicate the local
				    computer.
		pszResource -	    Indicates a resource on the given
				    server.

    NOTES:	For files, psz can be NULL and pszResource can be a local
		path redirected to a remote server.  The QueryName method
		below will return whatever was passed in as pszResource.

    HISTORY:
	rustanl     29-May-1991     Created from ACCPERM constructor
	Johnl	    05-Aug-1991     Converted to NET_ACCESS class

********************************************************************/

NET_ACCESS::NET_ACCESS( const TCHAR * pszServer,
			const TCHAR * pszResource )
    :	LOC_LM_OBJ( pszServer ),
	_nlsServer( MAX_PATH ),
	_nlsResource( 5 )	// Handle common resource names
{
    if ( QueryError() != NERR_Success )
	return ;

    APIERR err ;
    if ( (err = _nlsServer.QueryError() ) != NERR_Success ||
	 (err = _nlsResource.QueryError() ) != NERR_Success ||
	 (err = SetServerName( pszServer )) != NERR_Success ||
	 (err = SetName( pszResource ) )    != NERR_Success   )
    {
	UIDEBUG( SZ("NET_ACCESS_OBJ ct:  failed construction\r\n") );
	ReportError( err ) ;
	return;
    }


}  // NET_ACCESS::NET_ACCESS


/*******************************************************************

    NAME:	NET_ACCESS::~NET_ACCESS

    SYNOPSIS:	Empty destructor

    HISTORY:
	Johnl	16-Aug-1991	Created

********************************************************************/

NET_ACCESS::~NET_ACCESS()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NET_ACCESS::QueryName

    SYNOPSIS:	Returns the (canonicalized version of the) resource name
		passed to the constructor

    RETURNS:	Pointer to said name

    NOTES:	For file permissions, the returned string may be a local
		path or a path on a server, depending on what was passed
		to the constructor.  It is therefore questionable how
		useful this method is in general (i.e., where it is not
		known what was passed to the constructor).

    HISTORY:
	rustanl     20-May-1991     Created

********************************************************************/

const TCHAR * NET_ACCESS::QueryName( VOID ) const
{
    if ( QueryError() == NERR_Success )
    {
	//  Note, that this path may be a local path, or a path
	//  on a server.
	return _nlsResource.QueryPch();
    }

    return NULL;
}

/*******************************************************************

    NAME:	NET_ACCESS::SetName

    SYNOPSIS:	Sets the resource name for this object

    ENTRY:	pszResName is the name of the resource

    RETURNS:	NERR_Success if successful, standard error code otherwise

    NOTES:

    HISTORY:
	Johnl	27-Aug-1991	Created

********************************************************************/

APIERR NET_ACCESS::SetName( const TCHAR * pszResName )
{
    //	Note, the path parameter should really be validated here.
    //	However, the path may be a long file name, and the I_MNetPathType
    //	validation API automatically sets the INPT_FLAGS_OLDPATHS
    //	flag on DOS (and OS/2 1.1) systems.  Since Windows is such
    //	a system, the API would only be able to validate FAT file names
    //	if called locally.  The I_MNetPathType API could be remoted to
    //	the _nlsServer server.	However, this would cause another net
    //	call which would only do a subset of what NetAccessGetInfo
    //	will do later anyway.  Note, that the same argument cannot be
    //	applied to validating the server name above, since, for one,
    //	that validation is done locally.

    _nlsResource = pszResName ;
    return _nlsResource.QueryError() ;
}

/*******************************************************************

    NAME:	NET_ACCESS::SetServerName

    SYNOPSIS:	Sets the server name for this object

    ENTRY:	pszServerName is the name of the server where the resource
		resides (or NULL for a local resource).

    RETURNS:	NERR_Success if successful, standard error code otherwise

    HISTORY:
	Johnl	27-Aug-1991	Created

********************************************************************/

APIERR NET_ACCESS::SetServerName( const TCHAR * pszServerName )
{
    /* Note: nlsServer cannot be an ALIAS_STR because ALIAS_STRs can't be
     * NULL.
     */
    NLS_STR nlsServer( pszServerName ) ;
    if ( nlsServer.QueryError() != NERR_Success )
	return nlsServer.QueryError() ;

    if ( nlsServer.strlen() == 0 )
    {
	//  No server was given.  This is a valid input.
	//  The given path is assumed to be a local resource (including
	//  a local path, redirected to a server).
    }
    else
    {
	//  A server name was given.  Verify that it is a legal one.
	//  We will assume it is illegal (no '\\') or NetNameValidate
	//  will reassign err

	APIERR err = (APIERR)ERROR_INVALID_PARAMETER ;
	ISTR istr( nlsServer );
	if ( nlsServer.QueryChar( istr ) != TCH('\\')    ||
	     nlsServer.QueryChar( ++istr ) != TCH('\\')  ||
	     ( err = ::I_MNetNameValidate( NULL, nlsServer[ ++istr ],
				NAMETYPE_COMPUTER, 0L ) ) != NERR_Success )
	{
	    UIDEBUG( SZ("Invalid server name") );
	    return err ;
	}
    }

    _nlsServer = nlsServer ;

    return _nlsServer.QueryError() ;
}


/*******************************************************************

    NAME:	NET_ACCESS::QueryServerName

    SYNOPSIS:	Returns a pointer to the (canonicalized version of the)
		server name passed to the constructor

    RETURNS:	A pointer to the said name

    HISTORY:
	rustanl     28-May-1991     Created

********************************************************************/

const TCHAR * NET_ACCESS::QueryServerName( VOID ) const
{
    if ( QueryError() == NERR_Success )
    {
	if ( _nlsServer.strlen() == 0 )
	    return NULL ;
	else
	    return _nlsServer.QueryPch();
    }

    UIDEBUG(SZ("NET_ACCESS:QueryName - Calling when object is in error state\n\r")) ;
    return NULL;
}

/*******************************************************************

    NAME:	NET_ACCESS::Delete

    SYNOPSIS:	Deletes the ACL from the net resource

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
	Johnl	10-Apr-1992	Created

********************************************************************/

APIERR NET_ACCESS::Delete( void )
{
    APIERR err = NERR_Success ;
    err = ::MNetAccessDel( QueryServerName(),
			   (TCHAR *)QueryName() ) ;
    return err ;
}



/*******************************************************************

    NAME:	NET_ACCESS_1::NET_ACCESS_1

    SYNOPSIS:	Constructor for NET_ACCESS_1 class

    ENTRY:	pszServer - server the resource resides (can be NULL)
		pszResource - Resource info we want to get

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
	Johnl	06-Aug-1991	Created

********************************************************************/

NET_ACCESS_1::NET_ACCESS_1( const TCHAR * pszServer,
			    const TCHAR * pszResource )
    : NET_ACCESS( pszServer, pszResource ),
      _strlstAccountNames(),
      _cACE( 0 )
{
    if ( QueryError() != NERR_Success )
	return ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::~NET_ACCESS_1

    SYNOPSIS:	Empty destructor

    HISTORY:
	Johnl	16-Aug-1991	Created

********************************************************************/

NET_ACCESS_1::~NET_ACCESS_1()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:	NET_ACCESS_1::I_GetInfo

    SYNOPSIS:	Calls NetAccessGetInfo with the given buffer, resizing
		the buffer until the call is successful or some non-
		buffer size related error occurs.

    ENTRY:	pbuf -		Pointer to BUFFER object which will
				receive the ACL.

    EXIT:	On success, the *pbuf buffer will contain the ACL.

    RETURNS:	An API error code, which is NERR_Success on success.

    HISTORY:
	rustanl     24-May-1991     Created
	rustanl     15-Jul-1991     Modified to work with new BUFFER::Resize
				    return code.
	Johnl	    06-Aug-1991     Made into NET_ACCESS_1

********************************************************************/

APIERR NET_ACCESS_1::I_GetInfo( VOID )
{
    while ( TRUE )
    {
	UIDEBUG(SZ("NET_ACCESS_1::I_GetInfo - Resource Name ==")) ;
	UIDEBUG(QueryName()) ;
	UIDEBUG(SZ("\n\r")) ;
	UIDEBUG(SZ("Server parameter is :")) ;
#ifdef DEBUG
        if ( QueryServerName() == NULL )
        {
            UIDEBUG( SZ("NULL") ) ;
	    UIDEBUG( QueryServerName() ) ;
        }
#endif
	UIDEBUG(SZ("\n\r")) ;

	BYTE * pBuffer = NULL;		// pointer to the buffer

	APIERR err = ::MNetAccessGetInfo( QueryServerName(),
				   	  (TCHAR *)QueryName(),
				   	  1,
				   	  &pBuffer );
	if ( err )
	{
	    SetBufferPtr( NULL ) ;
	    return err ;
	}

	SetBufferPtr( pBuffer );

	switch ( err )
	{
	case NERR_Success:
	{
	    _cACE = (UINT)((access_info_1 *)QueryBufferPtr())->acc1_count;

	    //	Set resource name to NULL, so that no mistake will be made
	    //	trying to access the resource name from there.
	    ((access_info_1 *)QueryBufferPtr())->acc1_resource_name = NULL;

	    return NERR_Success ;
	}

	case NERR_ResourceNotFound:
	    _cACE = 0;
	    // Fall through
	default:
	    return err;

	}
    }

    UIASSERT( !SZ("Should never get here") );
    return NERR_InternalError;

}  // NET_ACCESS_1::GetNetAccessInfo

/*******************************************************************

    NAME:	NET_ACCESS_1::I_CreateNew

    SYNOPSIS:	Initializes to no permissions

    NOTES:

    HISTORY:
	Johnl	30-Sep-1991	Created

********************************************************************/

APIERR NET_ACCESS_1::I_CreateNew( VOID )
{
    APIERR err = NERR_Success ;
    if ( (err = ResizeBuffer( QueryRequiredSpace( 0 ) )) ||
	 (err = SetAuditFlags( 0 )) ||
	 (err = ClearPerms() ) )
    {
	/* Fall through
	 */
    }

    return err ;
}


APIERR NET_ACCESS_1::I_WriteInfo( VOID )
{
    return I_WriteInfoAux() ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::I_WriteNew

    SYNOPSIS:	Writes the ACL

    EXIT:

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	We simply call through to I_WriteInfo since it will
		attach the ACL if there isn't one there (thus
		circumventing the need for WriteNew).

    HISTORY:
	Johnl	01-Oct-1991	Created

********************************************************************/

APIERR NET_ACCESS_1::I_WriteNew( VOID )
{
    return I_WriteInfoAux() ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::WriteInfoAux

    SYNOPSIS:	Writes the ACL - can be called from WriteInfo or
		WriteNew.

    RETURNS:	An API error, which is NERR_Success on success.

    NOTES:	If the return code is NERR_UserNotFound, the
		QueryFailingName method can be used to find the
		failing name.

    HISTORY:
	rustanl     24-May-1991     Created
	Johnl	    01-Oct-1991     Created from WriteInfo

********************************************************************/

APIERR NET_ACCESS_1::I_WriteInfoAux( VOID )
{
    if ( QueryError() != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
	return ERROR_GEN_FAILURE;
    }

    APIERR err;
    {
	//
	//  Any set method will resize the buffer appropriately, and
	//  somebody had better set the data before writing the data out
	//
	UIASSERT( QueryBufferSize() >= QueryRequiredSpace( 0 ) ) ;

	access_info_1 * pai1   = (access_info_1 *)QueryBufferPtr();
	UINT		cbBuf  = QueryBufferSize() ;

	pai1->acc1_resource_name = (TCHAR *)QueryName();
	pai1->acc1_count = _cACE;

	err = ::MNetAccessSetInfo( QueryServerName(),
				   (TCHAR *)QueryName(),
				   1,
				   (BYTE *)pai1,
				   cbBuf,
				   PARMNUM_ALL );

	if ( err == NERR_ResourceNotFound )
	{
	    err = ::MNetAccessAdd( QueryServerName(),
				   1,
				   (BYTE *)pai1,
				   cbBuf );
	}

	//  Set the resource name pointer to NULL, so that accidental
	//  referencing of this object will be detected sooner.
	pai1->acc1_resource_name = NULL;
    }

    return err;

}  // NET_ACCESS_1::WriteInfoAux

/*******************************************************************

    NAME:	NET_ACCESS_1::QueryACECount

    SYNOPSIS:	Returns the number of access control entries (ACEs) for
		the resource

    RETURNS:	The said count

    HISTORY:
	rustanl     08-May-1991     Created

********************************************************************/

UINT NET_ACCESS_1::QueryACECount( VOID ) const
{
    if ( QueryError() == NERR_Success )
	return _cACE;

    UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
    return 0;

}  // NET_ACCESS_1::QueryACECount


/*******************************************************************

    NAME:	NET_ACCESS_1::SetAuditFlags

    SYNOPSIS:	Sets the audit flags of this object

    ENTRY:	sAuditFlags - Mask of audit flags

    EXIT:

    RETURNS:	APIERR if successful

    NOTES:

    HISTORY:
	Johnl	28-Oct-1991	Moved from header file so we can
				reallocate if necessary

********************************************************************/

APIERR NET_ACCESS_1::SetAuditFlags( short sAuditFlags )
{
    APIERR err = NERR_Success  ;

    /* we only want resize if NULL or empty buffer. otherwise,
       it was something we got back from NETAPI with pointers to
       itself and reallocating will be badness,
     */
    if ( QueryBufferPtr() == NULL || QueryBufferSize() < QueryRequiredSpace(0) )
	err = ResizeBuffer( QueryRequiredSpace( 0 )) ;

    if ( !err )
	((access_info_1 *)QueryBufferPtr())->acc1_attr = sAuditFlags ;

    return err ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::ClearPerms

    SYNOPSIS:	Clears all permissions for the resource

    RETURNS:	An API error code, which is NERR_Success on success

    HISTORY:
	rustanl     20-May-1991     Created

********************************************************************/

APIERR NET_ACCESS_1::ClearPerms( VOID )
{
    UIASSERT( QueryError() == NERR_Success );
    _cACE = 0;

    _strlstAccountNames.Clear() ;
    return ( QueryError() == NERR_Success ? NERR_Success : ERROR_INVALID_FUNCTION );

}  // NET_ACCESS_1::ClearPerms

/*******************************************************************

    NAME:	NET_ACCESS_1::CopyAccessPerms

    SYNOPSIS:	Copies all of the access permissions from the passed
		NET_ACCESS_1 object.  This may eventually be replaced
		by a clone method, but clone is currently broken
		under NT.

    ENTRY:	netaccess1Src - Where to get the access permissions from

    EXIT:	The state of the LMOBJ doesn't change (i.e. valid etc.)

    RETURNS:	NERR_Success if successful

    NOTES:	This method replaces any current ACEs in *this.

    HISTORY:
	Johnl	28-Oct-1991	Created

********************************************************************/

APIERR NET_ACCESS_1::CopyAccessPerms( const NET_ACCESS_1 & netaccess1Src )
{
    UIASSERT( QueryError() == NERR_Success );
    UIASSERT( netaccess1Src.QueryError() == NERR_Success ) ;

    APIERR err ;
    if ( err = ResizeBuffer( netaccess1Src.QueryRequiredSpace(
					    netaccess1Src.QueryACECount() ) ) )
    {
	return err ;
    }

    // cast city
    access_list * palSrc  = netaccess1Src.QueryACE( 0 );
    access_list * palDest = QueryACE( 0 );

    for ( UINT i = netaccess1Src.QueryACECount() ; i > 0 ; i--, palSrc++, palDest++ )
    {
#ifdef WIN32
	NLS_STR * pnlsAccount = new NLS_STR( palSrc->acl_ugname ) ;

	err = ERROR_NOT_ENOUGH_MEMORY ;
	if ( (pnlsAccount == NULL) ||
	     (err = pnlsAccount->QueryError()) ||
	     (err = _strlstAccountNames.Add( pnlsAccount )) )
	{
	    return err ;
	}

	palDest->acl_ugname = (LPTSTR) pnlsAccount->QueryPch() ;
#else
	COPYTOARRAY( palDest->acl_ugname, palSrc->acl_ugname );
#endif //WIN32

	palDest->acl_access = palSrc->acl_access ;
    }

    _cACE = netaccess1Src.QueryACECount() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::FindACE

    SYNOPSIS:	Returns a pointer to the ACE for a given user or group

    ENTRY:	pszName -	    Pointer to name of user or group
				    Caution:  See Notes section below.
		nt -		    Specifies whether pszName points to
				    a group name or a user name.

    RETURNS:	Pointer to specified ACE, or NULL if no ACE was found
		for the given user/group

    NOTES:	This method assumes that pszName points to an already
		canonicalized user or group name.

    HISTORY:
	rustanl     24-May-1991     Created

********************************************************************/

access_list * NET_ACCESS_1::FindACE( const TCHAR * pszName,
				enum PERMNAME_TYPE nt ) const
{
    UIASSERT( QueryError() == NERR_Success );	    // here, it's okay to simply assert for the
				// valid state, since the method is private
    UIASSERT( pszName != NULL );

    if ( _cACE == 0 )
    {
	//  If the count is 0, we don't want to reference the _buf object.
	return NULL;
    }

    // cast city
    access_list * pal = QueryACE( 0 );

    //	Note, this is an important assignment, because it ensures that
    //	fUserName is either 0 or 1.  See also the use of operator! below.
    BOOL fUserName = ( nt == PERMNAME_USER );

    for ( UINT i = _cACE; i > 0; i--, pal++ )
    {
	//  Note, the following comparison checks whether
	//  !( pal->acl_access & ACCESS_GROUP ) and fUserName are either
	//  both true or both false.  (Note, operator! must be used on
	//  the left hand side with the & expression, and cannot be used
	//  on the right hand side with fUserName.  This is because we
	//  need to ensure that both sides of operator!= are either 0 or 1.
	//  See also comment at fUserName assignment above.)
	if ( ( ! ( pal->acl_access & ACCESS_GROUP )) != fUserName )
	{
#ifdef DEBUG
	    if ( strcmpf( pszName, pal->acl_ugname ) == 0 )
	    {
		//  In current versions of LAN Man (pre-NT), the following
		//  could be an assert.  However, under NT groups and users
		//  share the  same name space, so asserting out would be
		//  the wrong thing to do.  Hence, a UIDEBUG is used, so
		//  that some degree of noise is made.
		UIDEBUG( SZ("NET_ACCESS_1::FindACE:  Name matches but perm name type value does not\r\n") );
	    }
#endif
	    continue;
	}

	//  Note, strcmpf is fine here since szName is assumed to have
	//  been canonicalized, and acl_ugname should come back
	//  canonicalized.
	if ( strcmpf( pszName, pal->acl_ugname ) == 0 )
	    return pal;
    }

    //	user/group not found among ACEs
    return NULL;

}  // NET_ACCESS_1::FindACE


/*******************************************************************

    NAME:	NET_ACCESS_1::QueryPerm

    SYNOPSIS:	Returns the permissions set for a given user or
		group for the resource

    ENTRY:	pszName -	    Pointer to name of user or group
		nt -		    Specifies whether pszName points to
				    a group name or a user name.

    RETURNS:	A PERM value corresponding to the permissions of the
		given user/group.  This value can be one of the following:

		    PERM_NO_SETTING	There are no explicit permissions
					set on this user or group.  Users
					thus inherit permissions from
					their group memberships

		    PERM_DENY_ACCESS	The user is denied access to the
					resource.  A group cannot have
					PERM_DENY_ACCESS permission.

		    A non-empty (since	The user/group has the indicated
		    PERM_NO_SETTING is	permissions.
		    defined to be 0)
		    union of the
		    following bits:
			PERM_READ
			PERM_WRITE
			PERM_EXEC
			PERM_CREATE
			PERM_DELETE
			PERM_ATTRIB
			PERM_PERM

    HISTORY:
	rustanl     24-May-1991     Created
	rustanl     28-May-1991     Added ACCESS_-to-PERM_ conversions

********************************************************************/

PERM NET_ACCESS_1::QueryPerm( const TCHAR * pszName, enum PERMNAME_TYPE nt ) const
{
    if ( QueryError() != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
	return PERM_NO_SETTING;
    }

    UIASSERT( pszName != NULL );

    TCHAR szName[ UNLEN + 1 ];
    APIERR err = ::I_MNetNameCanonicalize( NULL, pszName,
					szName,
                                        sizeof szName / sizeof (TCHAR) - 1,
					( ( nt == PERMNAME_USER ) ?
						   NAMETYPE_USER :
						   NAMETYPE_GROUP ),
					0L );
    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1::QueryPerm given invalid user/group name") );
	return PERM_NO_SETTING;
    }

    access_list * pal = FindACE( szName, nt );
    if ( pal == NULL )
    {
	return PERM_NO_SETTING;
    }

    PERM perm = (UINT)( pal->acl_access & ( ~ACCESS_GROUP )); // strip off group bit
    UIASSERT( ! ( perm & PERM_DENY_ACCESS ));	// we assume that
						// PERM_DENY_ACCESS is unused
						// by the NetAccess API
    if ( perm == 0 )
    {
	//  There is an ACE with no permission bits.  This means deny.
	UIASSERT( nt != PERMNAME_GROUP );   //	Groups cannot have deny bits.
	return PERM_DENY_ACCESS;
    }

    return perm;

}  // NET_ACCESS_1::QueryPerm

/*******************************************************************

    NAME:	NET_ACCESS_1::SetPerm

    SYNOPSIS:	Sets the permissions for a given user or group

    ENTRY:	pszName -	    Pointer to name of user or group
		nt -		    Specifies whether pszName points to
				    a group name or a user name.
		perm -		    New permissions.  It may take the
				    same values as are returned from
				    QueryPerm.

    RETURNS:	An API error code, which is NERR_Success on success.

    HISTORY:
	rustanl     24-May-1991     Created
	rustanl     28-May-1991     Added PERM_-to-ACCESS_ conversions
	rustanl     15-Jul-1991     Modified to work with new BUFFER::Resize
				    return code.

********************************************************************/

APIERR NET_ACCESS_1::SetPerm( const TCHAR * pszName,
			 enum PERMNAME_TYPE nt,
			 PERM perm )
{
    if ( QueryError() != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
	return ERROR_INVALID_FUNCTION;
    }

    UIASSERT( pszName != NULL );

    TCHAR szName[ UNLEN + 1 ];
    APIERR err = ::I_MNetNameCanonicalize( NULL, pszName,
					szName,
                                        sizeof szName  / sizeof (TCHAR) - 1,
					( ( nt == PERMNAME_USER ) ?
						   NAMETYPE_USER :
						   NAMETYPE_GROUP ),
					0L );
    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1::SetPerm given invalid user/group name") );
	return ERROR_INVALID_PARAMETER;
    }

    //	Convert permissions to an ACCESS_ value
    PERM permNew = ( ( nt == PERMNAME_GROUP ) ? ACCESS_GROUP : 0 );
    if ( perm == PERM_DENY_ACCESS )
    {
	if ( nt == PERMNAME_GROUP )
	{
	    UIASSERT( SZ("Groups don't have a deny bit") );
	    return ERROR_INVALID_PARAMETER;
	}
	//  Don't modify permNew any further
    }
    else if ( ( perm & ( ~( PERM_READ | PERM_WRITE | PERM_EXEC |
			    PERM_CREATE | PERM_DELETE | PERM_ATTRIB |
			    PERM_PERM ))) == 0 )
    {
	//  Note, that the following assignment will leave permNew unchanged
	//  if perm==PERM_NO_SETTING.  This is checked for below, since
	//  this requires special action on the API side.
	permNew |= perm;
    }
    else
    {
	UIASSERT( !SZ("Unexpected perm value") );
	return ERROR_INVALID_PARAMETER;
    }

    access_list * pal = FindACE( szName, nt );
    if ( pal != NULL )
    {
	if ( perm == PERM_NO_SETTING )	// Note, perm is compared, not permNew
	{
	    //	Need to remove ACE from buffer.  We do that by copying the
	    //	last ACE to this spot.
	    _cACE--;
	    access_list * palLast = QueryACE( _cACE );
	    if ( palLast == pal )
	    {
		// The ACE being removed is the last one; thus, we're done.
	    }
	    else
	    {
#ifdef WIN32
		pal->acl_ugname = palLast->acl_ugname ;

		/* Note that we could remove the account name from the accounts
		 * strlist but we will leave it there since it is harmless
		 */
#else
		COPYTOARRAY( pal->acl_ugname, palLast->acl_ugname);
#endif //WIN32

		pal->acl_access = palLast->acl_access;
	    }
	    return NERR_Success;
	}
	else
	{
	    pal->acl_access = permNew;
	    return NERR_Success;
	}
    }

    if ( perm == PERM_NO_SETTING )	// Note, perm is compared, not permNew
    {
	//  We are done, since there is no ACE for this user/group
	return NERR_Success;
    }

    //	Need to add an ACE for this user/group

    err = ResizeBuffer( QueryRequiredSpace( _cACE + 1 ));
    if ( err != NERR_Success )
    {
	return err;
    }

    pal = QueryACE( _cACE );

#ifdef WIN32
    NLS_STR * pnlsAccount = new NLS_STR( szName ) ;

    err = ERROR_NOT_ENOUGH_MEMORY ;
    if ( (pnlsAccount == NULL) ||
	 (err = pnlsAccount->QueryError()) ||
	 (err = _strlstAccountNames.Add( pnlsAccount )) )
    {
	return err ;
    }

    pal->acl_ugname = (LPTSTR) pnlsAccount->QueryPch() ;
#else
    COPYTOARRAY( pal->acl_ugname, szName );
#endif //WIN32

    pal->acl_access = permNew;
    _cACE++;

    return NERR_Success;

}  // NET_ACCESS_1::SetPerm


/*******************************************************************

    NAME:	NET_ACCESS_1::CompareACL

    SYNOPSIS:	Compares the ACL (not the audit info) for the passed ACL

    ENTRY:	pnetacc1 - The item to compare against

    RETURNS:	TRUE if the ACLs grant the same access, FALSE if they do not

    NOTES:

    HISTORY:
	Johnl	10-Nov-1992	Created

********************************************************************/

BOOL NET_ACCESS_1::CompareACL( NET_ACCESS_1 * pnetacc1 )
{
    UIASSERT( pnetacc1 != NULL ) ;

    if ( QueryACECount() != pnetacc1->QueryACECount() )
    {
	return FALSE ;
    }

    for ( UINT i = 0 ; i < QueryACECount() ; i++ )
    {
	access_list * pacclist = QueryACE( i ) ;

	if ( pacclist == NULL )
	{
	    UIASSERT( FALSE ) ;
	    return FALSE ;
	}

	//
	//  Note that QueryPerm strips out the ACCESS_GROUP bit so
	//  we need to do the same before checking for equality
	//

	if ( (pacclist->acl_access & ~ACCESS_GROUP) !=
	     QueryPerm( pacclist->acl_ugname,
			pacclist->acl_access & ACCESS_GROUP ?
			    PERMNAME_GROUP :
			    PERMNAME_USER ))
	{
	    return FALSE ;
	}
    }

    return TRUE ;
}

/*******************************************************************

    NAME:	NET_ACCESS_1::QueryFailingName

    SYNOPSIS:	Finds a user or group name mentioned in an ACE,
		but no longer in the UAS.

    ENTRY:	pnls -	    Pointer to NLS_STR which will received
			    the failing name
		pnt -	    Pointer to PERMNAME_TYPE object which
			    will receive the type (user or group)
			    of the failing name.

    EXIT:	On success, *pnls contains the name of the failing
		user or group name, and *pnt contains the type thereof.
		If *pnls is the empty string (pnls->strlen() == 0)
		on a successful exit, then no name is failing.

    RETURNS:	The return code is an API error code, which is
		NERR_Success on success.  It indicates the success
		of finding the failing name.

    NOTES:	This function is not necessarily very efficient.
		For example, the user and group enum objects and/or
		the ACEs could be sorted, which may reduce the running
		time from quadratic to linear.	However, for small
		numbers of ACEs, this hardly seems worth it.

		Also, separate NetUserGetInfo and NetGroupGetInfo calls
		(through USER0 and GROUP0, of course) could be made.  This
		may end up taking much longer than searching the enumerated
		list every time, since a net call would be made for
		every user.

		Since it is not clear how much either of these
		alternatives would speed up the function, the implementation
		is left the way it is:	simple, and possibly efficient.

		Moreover, this function will not be called very often
		in reality, since changing the permissions while a user
		or group with permissions on the current resource is being
		deleted happens very infrequently.

    HISTORY:
	rustanl     28-May-1991     Created

********************************************************************/

APIERR NET_ACCESS_1::QueryFailingName( NLS_STR * pnls,
				  enum PERMNAME_TYPE * pnt  ) const
{
    if ( QueryError() != NERR_Success )
    {
	UIASSERT( !SZ("NET_ACCESS_1 object is invalid") );
	return ERROR_INVALID_FUNCTION;
    }

    UIASSERT( pnls != NULL );
    UIASSERT( pnt != NULL );

    GROUP0_ENUM ge0( (TCHAR *)QueryServerName());
    APIERR err = ge0.GetInfo();
    if ( err != NERR_Success )
	return err;

    USER0_ENUM ue0( (TCHAR *)QueryServerName());
    err = ue0.GetInfo();
    if ( err != NERR_Success )
	return err;

    access_list * pal = QueryACE( 0 );
    for ( UINT iACE = 0; iACE < _cACE; iACE++, pal++ )
    {
	if ( pal->acl_access & ACCESS_GROUP )
	{
	    GROUP0_ENUM_ITER gei0( ge0 );
	    const GROUP0_ENUM_OBJ * pgi0;
	    while ( ( pgi0 = gei0()) != NULL )
	    {
		if ( strcmpf( pal->acl_ugname, pgi0->QueryName() ) == 0 )
		    break;
	    }

	    if ( pgi0 == NULL )
	    {
		// group was not found
		*pnls = pal->acl_ugname;
		return pnls->QueryError();
	    }
	}
	else
	{
	    USER0_ENUM_ITER uei0( ue0 );
	    const USER0_ENUM_OBJ * pui0;
	    while ( ( pui0 = uei0( &err )) != NULL )
	    {
                if ( err != NERR_Success )
                    return err;

		if ( strcmpf( pal->acl_ugname, pui0->QueryName() ) == 0 )
		    break;
	    }

	    if ( pui0 == NULL )
	    {
		// user was not found
		*pnls = pal->acl_ugname;
		return pnls->QueryError();
	    }
	}
    }

    //	No failing name found
    *pnls = NULL;
    return pnls->QueryError();

}  // NET_ACCESS_1::QueryFailingName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmobjnew.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*  HISTORY:
 *      JonN        24-Jul-1991     Created
 *      rustanl     21-Aug-1991     Renamed NEW_LM_OBJ buffer methods
 *      rustanl     26-Aug-1991     Changed [W_]CloneFrom parameter
 *                                  from * to &
 *      jonn    8/29/91         Added ChangeToNew()
 *      jonn    9/05/91         Changes related to IsOKState()
 *      jonn    9/17/91         Moved CHECK_OK / CHECK_VALID strings to static
 *      terryk  10/7/91         type changes for NT
 *      KeithMo 10/8/91         Now includes LMOBJP.HXX.
 *      terryk  10/17/91        WIN 32 conversion
 *      terryk  10/21/91        change _pBuf from TCHAR * to BYTE *
 *      jonn    11/20/91        Fixed ResizeBuffer( 0 )
 *      jonn    5/08/92         Added ClearBuffer()
 *
 *      This file contains basic methods for the LM_OBJ root classes.
 */

#include "pchlmobj.hxx"  // Precompiled header

#if !defined(_CFRONT_PASS_)
#pragma hdrstop            //  This file creates the PCH
#endif


/**********************************************************\

   NAME:        NEW_LM_OBJ::NEW_LM_OBJ

   SYNOPSIS:    constructor and destructor

   NOTES:       The BUFFER object must construct successfully

   HISTORY:
        JonN        12-Aug-1991     Created

\**********************************************************/

NEW_LM_OBJ::NEW_LM_OBJ( BOOL fValidate )
    : LM_OBJ_BASE( fValidate ),
      _pBuf( NULL )
{
    if ( QueryError() )
        return;
}

/*******************************************************************

    NAME:       NEW_LM_OBJ::~NEW_LM_OBJ

    SYNOPSIS:   destrcutor

    NOTES:      free up the memory

    HISTORY:
                terryk  17-Oct-91       Created

********************************************************************/

NEW_LM_OBJ::~NEW_LM_OBJ()
{
    if (_pBuf != NULL)
        ::MNetApiBufferFree( &_pBuf );
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::GetInfo

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::GetInfo()
{
    if ( IsUnconstructed() || IsNew() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeValid();

    APIERR err = I_GetInfo();
    if (err != NERR_Success)
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::WriteInfo

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::WriteInfo()
{
    if ( !IsValid() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    return I_WriteInfo();
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::CreateNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::CreateNew()
{
    if ( IsUnconstructed() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeNew();

    APIERR err = I_CreateNew();
    if ( err != NERR_Success )
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;

}

/**********************************************************\

    NAME:       NEW_LM_OBJ::WriteNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    NOTES:      For Delete(), see the specific subclass for the
                interpretation of the usForce() parameter.

    HISTORY:
        JonN        06-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::WriteNew()
{
    if ( !IsNew() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    APIERR err = I_WriteNew();
    if (err != NERR_Success)
        return err;

    MakeValid(); // the object is no longer new

    return NERR_Success;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::Write

    SYNOPSIS:   This method calls either WriteInfo() or WriteNew()
                depending on the state of the object.

    HISTORY:
        JonN        13-Sep-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::Write()
{
    if ( IsNew() )
        return WriteNew();
    else
        return WriteInfo();
}

/*
    See the specific subclass for the interpretation of usForce.
*/
APIERR NEW_LM_OBJ::Delete( UINT uiForce )
{
    if ( IsUnconstructed() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    return I_Delete( uiForce );
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::ChangeToNew

    SYNOPSIS:   These methods call their corresponding virtuals
                to perform the stated operations.  They handle the state
                transitions, while the I_ methods perform the real work.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::ChangeToNew()
{
    if ( !IsValid() )
    {
        UIASSERT( FALSE ); // not valid in this state
        return ERROR_GEN_FAILURE;
    }

    MakeNew();

    APIERR err = I_ChangeToNew();
    if ( err != NERR_Success )
    {
        MakeInvalid();
        return err;
    }

    return NERR_Success;

}


/**********************************************************\

    NAME:       NEW_LM_OBJ::QueryName

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

const TCHAR * NEW_LM_OBJ::QueryName() const
{
    UIASSERT( FALSE ); // not valid unless redefined
    return NULL;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_GetInfo

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_GetInfo()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_WriteInfo

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_WriteInfo()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_CreateNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_CreateNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_WriteNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_WriteNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/*
    See the specific subclass for the interpretation of usForce.
*/
APIERR NEW_LM_OBJ::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}

/**********************************************************\

    NAME:       NEW_LM_OBJ::I_ChangeToNew

    SYNOPSIS:   These methods are not usable unless redefined by
                subclasses.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::I_ChangeToNew()
{
    UIASSERT( FALSE ); // not valid unless redefined
    return ERROR_GEN_FAILURE;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_CloneFrom

    SYNOPSIS:   Copies object, including base API buffer

    NOTES:      W_CloneFrom should copy all component objects at each
                level.  Every level which has component objects should
                define W_CloneFrom.  Every W_CloneFrom should start with a call
                to the predecessor W_CloneFrom.

    CAVEATS:    Note that NEW_LM_OBJ::W_CloneFrom copies the API buffer but
                does not update the pointers in the API buffer.  Only
                the CloneFrom method at the outermost layer can do this.

    HISTORY:
        JonN        24-Jul-1991     Created
        rustanl     26-Aug-1991     Changed parameter from * to &
        terryk      14-Oct-1991     Use NT NetApi to allocate a new
                                    buffer. It may not work for some
                                    instance. BUGBUG
        JonN        31-Oct-1991     Enabled

\**********************************************************/

APIERR NEW_LM_OBJ::W_CloneFrom( const NEW_LM_OBJ & lmobj )
{
    UINT uBufSize = lmobj.QueryBufferSize();
    APIERR err = ResizeBuffer( uBufSize );
    if ( err != NERR_Success )
        return err;

    if ( uBufSize > 0 )
    {
        UIASSERT( _pBuf != NULL );
        ::memcpyf( (TCHAR *)_pBuf,
                   (const TCHAR *)lmobj.QueryBufferPtr(),
                   uBufSize );
    }

    _usState = lmobj._usState;

    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_CreateNew

    SYNOPSIS:   initializes fields with accessors

    NOTES:      Every level of the NEW_LM_OBJ hierarchy determines the
                default values for its own private data members.  This
                is done in W_CreateNew(), where each level calls up to
                its parent.  Every level which has component objects should
                define W_CreateNew.  Every W_CreateNew should start with a call
                to the predecessor W_CreateNew.

    CAVEATS:    Note that NEW_LM_OBJ::W_CreateNew copies the API buffer but
                does not initialize the fields in the API buffer.  These
                fields need only be initialized if they have no accessors.
                Only the I_CreateNew method at the outermost layer can do this.

    HISTORY:
        JonN        24-Jul-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::W_CreateNew()
{
    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::W_ChangeToNew

    SYNOPSIS:   Transforms object from VALID to NEW

    NOTES:      Every level of the NEW_LM_OBJ hierarchy determines
                whether its shadow members take different forms between
                the NEW and VALID states.  W_ChangeToNew changes the
                shadow members, but not the API buffer, from VALID to NEW.
                Only levels with component objects which are different
                between VALID and NEW must define W_ChangeToNew.  Every
                W_ChangeToNew should start with a call to the predecessor
                W_ChangeToNew.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR NEW_LM_OBJ::W_ChangeToNew()
{
    return NERR_Success;
}


/**********************************************************\

    NAME:       NEW_LM_OBJ::FixupPointer

    SYNOPSIS:   Fixes pointer inside a copied API buffer

    NOTES:      This is a utility routine for the use of CloneFrom() variants.
                When an API buffer is CloneFrom'd, some of its internal
                components may be pointers to strings inside the buffer.
                These pointers should be fixed-up to point into the new
                buffer, otherwise the cloned NEW_LM_OBJ points to a
                string in the old NEW_LM_OBJ and may break it the old
                one is freed.  Only pointers pointing within the old
                buffer need be fixed, NULL pointers  and pointers not
                pointing withing the old buffer can be left alone.
                Pointers which have a shadow NLS_STR can be left
                alone, Query() will use the NLS_STR and the API buffer
                will be fixed by the next WriteInfo/WriteNew.

    ENTRY:      *ppchar is the pointer to be fixed up.
                bufOld is the API buffer for the old NEW_LM_OBJ
                bufNew is the API buffer for the new NEW_LM_OBJ

    CAVEATS:    Note that NEW_LM_OBJ::W_CloneFrom copies the API buffer but
                does not update the pointers in the API buffer.  Only
                the CloneFrom method at the outermost layer can do this.

                Also note that you must walk on eggshells to do the
                pointer addition/subtraction without C6 leaving off the
                upper word.

                The pointer is not necessarily either NULL or within the old
                buffer.  In some cases, an obscure pointer may or may
                not point within the buffer, depending on whether the
                object was created with GetInfo or CreateNew.  We must
                handle this case by leaving alone any pointers which are
                non-NULL but point outside the buffer.

                Also note that this will not work for pointers in API
                buffers other than the default API buffer.

    HISTORY:
        JonN        04-Aug-1991     Created

\**********************************************************/

VOID NEW_LM_OBJ::FixupPointer( TCHAR ** ppchar,
                   const NEW_LM_OBJ * plmobjOld
                 )
{
    ULONG_PTR ulCurrPtr = (ULONG_PTR)(*ppchar);

    // return if null pointer
    if ( ulCurrPtr == 0 )
        return;

    ULONG_PTR ulOld = (ULONG_PTR)plmobjOld->QueryBufferPtr();

    // the object size should never be equal to 0

    UIASSERT( plmobjOld->QueryBufferSize() != 0 );

    // return if not pointing in old buffer
    if  (    ( ulCurrPtr < ulOld )
          || ( ulCurrPtr >= ulOld + ((UINT)plmobjOld->QueryBufferSize()) )
        )
    {
        return;
    }

    // do not assume 2's complement math -- avoid overflow
    ULONG_PTR ulNew = (ULONG_PTR)QueryBufferPtr();
    if ( ulOld >= ulNew )
        *ppchar = (TCHAR *)(ulCurrPtr - (ulOld - ulNew));
    else
        *ppchar = (TCHAR *)(ulCurrPtr + (ulNew - ulOld));

}


/*******************************************************************

    NAME:       NEW_LM_OBJ::QueryBufferSize

    SYNOPSIS:   query the buffer size

    HISTORY:
                jonn    31-Oct-91       Created

********************************************************************/

UINT NEW_LM_OBJ::QueryBufferSize() const
{
    UINT uSize = 0;
    APIERR err = NERR_Success;
    if (_pBuf != NULL)
        err = ::MNetApiBufferSize( _pBuf, &uSize );
    if ( err != NERR_Success )
    {
        DBGEOL( "Failure in NEW_LM_OBJ::QueryBufferSize() " << err );
        ASSERT( FALSE );
        return 0;
    }
    return uSize;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::SetBufferPtr

    SYNOPSIS:   set the buffer pointer

    ENTRY:      TCHAR *pBuffer - new pointer

    NOTES:      remove the old buffer if necessary

    HISTORY:
                terryk  16-Oct-91       Created

********************************************************************/

VOID NEW_LM_OBJ::SetBufferPtr( BYTE * pBuffer )
{
    if (_pBuf != NULL)
        ::MNetApiBufferFree( &_pBuf );

    _pBuf = pBuffer;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::ResizeBuffer

    SYNOPSIS:   resize the current buffer and copy the old content to
                the new one

    ENTRY:      UINT cbSize - new buffer size

    RETURNS:    APIERR for buffer creation error

    NOTES:      MNetApiBufferAlloc returns NULL when asked to allocate a
                buffer of length 0.  To get around this, we allocate a
                buffer of length 1 where the requested size is 0.

    HISTORY:
                terryk  14-Oct-91       Created
                jonn    31-Oct-91       Enabled
                jonn    31-Oct-91       Allocate 1 where 0 requested

********************************************************************/

APIERR NEW_LM_OBJ::ResizeBuffer( UINT cbNewRequestedSize )
{
    if ( cbNewRequestedSize == 0 )
        cbNewRequestedSize = 1;

    BYTE * pTemp = ::MNetApiBufferAlloc( cbNewRequestedSize );
    if ( pTemp == NULL )
        return ( ERROR_NOT_ENOUGH_MEMORY );

    if ( _pBuf != NULL )
    {
        UINT uMinSize = QueryBufferSize();
        if ( uMinSize > cbNewRequestedSize )
            uMinSize = cbNewRequestedSize;

        ::memcpyf((TCHAR *) pTemp, (TCHAR *) _pBuf, uMinSize );
    }

    SetBufferPtr( pTemp );

    return NERR_Success;
}


/*******************************************************************

    NAME:       NEW_LM_OBJ::ClearBuffer

    SYNOPSIS:   Set all bits in the current buffer to 0

    RETURNS:    APIERR for error

    HISTORY:
                jonn    08-May-92       Created

********************************************************************/

APIERR NEW_LM_OBJ::ClearBuffer()
{
    BYTE * pTemp = QueryBufferPtr();
    if ( pTemp == NULL )
    {
        UIASSERT( FALSE );
    }
    else
    {
        ::memsetf( (TCHAR *) pTemp, 0, QueryBufferSize() );
    }

    return NERR_Success;
}


/**********************************************************\

   NAME:        LOC_LM_OBJ::LOC_LM_OBJ

   SYNOPSIS:    constructors

   NOTES:       The LOCATION object must construct successfully

   HISTORY:
        JonN        07-Aug-1991     Created

\**********************************************************/

VOID LOC_LM_OBJ::CtAux( VOID )
{
    if ( QueryError() )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
        ReportError( err );
}

LOC_LM_OBJ::LOC_LM_OBJ( const TCHAR * pszLocation, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(pszLocation)
{
    CtAux();
}

LOC_LM_OBJ::LOC_LM_OBJ( enum LOCATION_TYPE loctype, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(loctype)
{
    CtAux();
}

LOC_LM_OBJ::LOC_LM_OBJ( const LOCATION & loc, BOOL fValidate )
        : NEW_LM_OBJ( fValidate ),
          _loc(loc)
{
    CtAux();
}


/**********************************************************\

   NAME:        LOC_LM_OBJ::W_CloneFrom

   SYNOPSIS:    Copies object

   NOTES:       see NEW_LM_OBJ::W_CloneFrom

   HISTORY:
        JonN        26-Jul-1991     Created
        rustanl     26-Aug-1991     Changed parameter from * to &

\**********************************************************/

APIERR LOC_LM_OBJ::W_CloneFrom( const LOC_LM_OBJ & lmobj )
{
    APIERR err = NEW_LM_OBJ::W_CloneFrom( lmobj );
    if ( err != NERR_Success )
        return err;

    err = _loc.Set( lmobj._loc );
    if ( err != NERR_Success )
    {
        DBGEOL( "LOC_LM_OBJ::W_CloneFrom failed on LOCATION copy " << err );
        return err;
    }

    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmocnfg.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmocnfg.cxx
    Class definitions for the CONFIG class.

    This file contains the class definitions for the LM_CONFIG class.
    The LM_CONFIG class is used for reading & writing a remote server's
    LANMAN.INI configuration file.

    FILE HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.
        terryk      07/Oct-1991 type changes for NT
        KeithMo     08-Oct-1991 Now includes LMOBJP.HXX.
        terryk      17-Oct-1991 WIN 32 conversion
                                Check strlen of the comment. if the
                                comment is empty string, use the default
                                string
        terryk      21-Oct-1991 WIN 32 conversion

*/

#include "pchlmobj.hxx"  // Precompiled header


//
//  LM_CONFIG methods.
//

/*******************************************************************

    NAME:       LM_CONFIG :: LM_CONFIG

    SYNOPSIS:   LM_CONFIG class constructor.

    ENTRY:      pszServerName           - The name of the target server
                                          (with the leading '\\' slashes).

                pszSectionName          - The LANMAN.INI section name.

                pszKeyName              - The LANMAN.INI key name.

    EXIT:       The object is contructed.

    HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Removed all LanMan version checking.
        KeithMo     21-Aug-1991 Changed const TCHAR * to NLS_STR.
        KeithMo     22-Aug-1991 Removed funky LoadModule stuff.

********************************************************************/
LM_CONFIG :: LM_CONFIG( const TCHAR * pszServerName,
                  const TCHAR * pszSectionName,
                  const TCHAR * pszKeyName )
  : _nlsServerName( pszServerName ),
    _nlsSectionName( pszSectionName ),
    _nlsKeyName( pszKeyName )
{
    //
    //  Ensure that we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsServerName.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsSectionName.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsKeyName.QueryError()     ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

#ifdef  DEBUG
    if ( _nlsServerName.strlen() != 0 )
    {
        //
        //  Ensure that the server name has the leading backslashes.
        //

        ISTR istrDbg( _nlsServerName );

        UIASSERT( _nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
        ++istrDbg;
        UIASSERT( _nlsServerName.QueryChar( istrDbg ) == TCH('\\') );
    }
#endif  // DEBUG

}   // LM_CONFIG :: LM_CONFIG


/*******************************************************************

    NAME:       LM_CONFIG :: ~LM_CONFIG

    SYNOPSIS:   LM_CONFIG class destructor.  Will free the current
                NETAPI.DLL reference if this was loaded in the
                constructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.

********************************************************************/
LM_CONFIG :: ~LM_CONFIG()
{
    //
    //  This space intentionally left blank.
    //

}   // LM_CONFIG :: ~LM_CONFIG


/*******************************************************************

    NAME:       LM_CONFIG :: QueryValue

    SYNOPSIS:   Read a configuration entry from the target LANMAN.INI.

    ENTRY:      pnlsValue               - This buffer receives the
                                          configuration entry.

                pszDefaultValue         - The default value to be used if
                                          LANMAN.INI cannot be accessed or
                                          if the section/entry name cannot
                                          be found.

    EXIT:       The entry is read.  If the entry was not found, then
                the default value is used.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.
        KeithMo     21-Aug-1991 Changed const TCHAR * to NLS_STR.
        terryk      17-Oct-1991 Check the string lenght, if it is
                                equal to 0, use the default string

********************************************************************/
APIERR LM_CONFIG :: QueryValue( NLS_STR    * pnlsValue,
                             const TCHAR * pszDefaultValue )
{
    APIERR err;

    //
    //  Determine our buffer length.
    //
    BYTE *pBuffer = NULL;
    err = ::MNetConfigGet( _nlsServerName.QueryPch(),
                           NULL,
                           _nlsSectionName.QueryPch(),
                           _nlsKeyName.QueryPch(),
                           &pBuffer );

    if( ( err == NERR_CfgCompNotFound ) ||
        ( err == NERR_CfgParamNotFound ) ||
        ( ( pBuffer != NULL ) &&
          ( ::strlenf((TCHAR *) pBuffer ) == 0 ) ) )
    {
        //
        //  Either the component or the parameter were
        //  not found.  Ergo, use the default.
        //

        *pnlsValue = pszDefaultValue;

        ::MNetApiBufferFree( &pBuffer );

        return pnlsValue->QueryError();
    }

    if( ( err != NERR_Success     ) &&
        ( err != NERR_BufTooSmall ) &&
        ( err != ERROR_MORE_DATA  ) )
    {
        //
        //  Unknown error.
        //

        return err;
    }

    *pnlsValue = (TCHAR *)pBuffer;

    ::MNetApiBufferFree( &pBuffer );

    return pnlsValue->QueryError();

}   // LM_CONFIG :: QueryValue


/*******************************************************************

    NAME:       LM_CONFIG :: SetValue

    SYNOPSIS:   Write a configuration entry to the target LANMAN.INI.

    ENTRY:      pnlsNewValue            - This buffer is written to
                                          the LANMAN.INI entry.

    EXIT:       The entry is written.

    RETURNS:    APIERR                  - Any error encountered.

    HISTORY:
        KeithMo     21-Jul-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Mapped ERROR_NOT_SUPPORTED to
                                NERR_Success if NetConfigSet() fails.
        KeithMo     21-Aug-1991 Changed const TCHAR * to NLS_STR.
        KeithMo     03-Jan-1993 Removed ERROR_NOT_SUPPORTED mapping.

********************************************************************/
APIERR LM_CONFIG :: SetValue( NLS_STR * pnlsNewValue )
{
    //
    //  Update LANMAN.INI.
    //

    APIERR err = ::MNetConfigSet( _nlsServerName.QueryPch(),
                                  _nlsSectionName.QueryPch(),
                                  _nlsKeyName.QueryPch(),
                                  pnlsNewValue->QueryPch() );

    return err;

}   // LM_CONFIG :: SetValue
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmocomp.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

/*  HISTORY:
 *	ChuckC	    07-Dec-1990     Created
 *	ChuckC	    3/6/91	    Code Review changes from 2/28/91
 *				    (chuckc,johnl,rustanl,annmc,jonshu)
 *	terryk	    9/17/91	    Change parent class from LM_OBJ to
 *	KeithMo	    10/8/91	    Now includes LMOBJP.HXX.
 *	terryk	    10/17/91	    WIN 32 conversion
 *	terryk	    10/21/91	    Include Windows
 *
 */
#include "pchlmobj.hxx"  // Precompiled header

/*************************** computer *************************/

/**********************************************************\

   NAME:       COMPUTER::COMPUTER

   SYNOPSIS:   constructor for the computer class

   ENTRY:      TCHAR * pszName computer name

   HISTORY:
 	   ChuckC	    07-Dec-1990     Created
	   terryk	    17-Sep-1991	    change LM_OBJ to LOC_LM_OBJ

\**********************************************************/

COMPUTER::COMPUTER(const TCHAR * pszName)
    : LOC_LM_OBJ( pszName ),
    _nlsName( pszName )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
    APIERR err = ValidateName( pszName );
    if ( err != NERR_Success )
    {
	UIASSERT( FALSE );
	ReportError( err );
	return;
    }
}

/**********************************************************\

   NAME:       COMPUTER::~COMPUTER

   SYNOPSIS:   destructor for the computer class

   HISTORY:
 	   ChuckC	    07-Dec-1990     Created
	   terryk           17-Sep-1991	    return the delete stuff

\**********************************************************/

COMPUTER::~COMPUTER()
{
    // do nothing
}

/**********************************************************\

   NAME:       COMPUTER::ValidateName

   SYNOPSIS:   validate the computer name

   HISTORY:
 	   ChuckC	    07-Dec-1990     Created
	   terryk	    17-Sep-1991	    add the computer name as a
					    parameter

\**********************************************************/

APIERR COMPUTER::ValidateName( const TCHAR * pszName )
{
    /*
     * null case is valid
     */

    if (( pszName == NULL ) || ( pszName[0] == TCH('\0')))
	return (NERR_Success) ;

    /*
     * else insist on \\ and valid computer name
     */
    if ( (pszName[0] != TCH('\\') || pszName[1] != TCH('\\')) ||
    	 (::I_MNetNameValidate(NULL, &pszName[2], NAMETYPE_COMPUTER, 0L)
	 != NERR_Success))
	return (ERROR_INVALID_PARAMETER) ;
    else
	return (NERR_Success) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmodev.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*  HISTORY:
 *      RustanL     07-Dec-1990     Created
 *      ChuckC      08-Jan-1991     Added more meat
 *      ChuckC      20-Jan-1991     Added ITER_DEVICE
 *      beng        11-Feb-1991     Uses lmui.hxx
 *      rustanl     06-Mar-1991     Change PSZ Connect param to const TCHAR *
 *      ChuckC      06-Mar-1991     Code Review changes from 2/28/91
 *                                  (chuckc,johnl,rustanl,annmc,jonshu)
 *      ChuckC      22-Mar-1991     Validation moves to GetInfo()
 *      ChuckC      27-Mar-1991     Code Review changes (chuckc,gregj,
 *                                  jonn,ericch)
 *      ChuckC      12-Apr-1991     Made pchAlias const (AliasToUNC)
 *      terryk      10-Oct-1991     type changes for NT
 *      KeithMo     10/8/91         Now includes LMOBJP.HXX.
 *      terryk      10/17/91        WIN 32 conversion
 *      terryk      10/21/91        WIN 32 conversion (part 2)
 *      terryk      10/29/91        add DEVICE2 object
 *      terryk      11/08/91        DEVICE2 code review changes
 *      terryk      11/18/91        change I_GetInfo to CallAPI
 *                                  change W_GetInfo to SetInfo
 *                                  change #ifndef WIN32 to #ifdef LAN_SERVER
 *      jonn        05/19/92        Added LMO_DEV_ALLDEVICES
 *
 *  CODEWORK - DEVICE and DEVICE2 are inconsistent in the way they
 *             handle deviceless connections. This module deserves
 *             serious surgery.
 */

#include "pchlmobj.hxx"  // Precompiled header



/************************* DEVICE *****************************************/


/**********************************************************\

   NAME:       DEVICE::DEVICE

   SYNOPSIS:   constructor for the device type

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

DEVICE::DEVICE( const TCHAR * pchName ) :
    _nlsDeviceName(pchName),
    _pBuf( NULL )
{
    /*
     * if parent not constructed bag out
     */
    if (IsUnconstructed())
        return ;

    /*
     * make sure string was alloced ok
     */
    if (_nlsDeviceName.QueryError() != NERR_Success)
    {
        MakeUnconstructed() ;
        return ;
    }

    /*
     * setup initial values
     * set both the device state (remote, unavail, etc. to error
     * initially. Ditto for the device type (disk, spool, etc).
     */
    _szServerName[0] = TCH('\0') ;
    _szRemoteName[0] = TCH('\0') ;
    _lmoDevState = LMO_DEV_BADSTATE ;
    _lmoDevType = LMO_DEV_ERROR ;
    _uStatus = USE_NETERR ;
    _uRemoteType = 0 ;

    /*
     * canonicalize name
     */
    _nlsDeviceName._strupr() ;

    MakeConstructed();
    return;
}


/**********************************************************\

   NAME:       DEVICE::~DEVICE

   SYNOPSIS:   destructor for the device class

   ENTRY:

   EXIT:

   NOTES:       nothing more to do

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

DEVICE::~DEVICE()
{
    ;
}


/**********************************************************\

   NAME:       DEVICE::QueryName

   SYNOPSIS:   return the device name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

const TCHAR * DEVICE::QueryName( VOID ) const
{
    if (IsUnconstructed())
        return NULL ;

    return (_nlsDeviceName.QueryPch()) ;
}  // DEVICE::QueryName

/**********************************************************\

   NAME:       DEVICE::QueryServerName

   SYNOPSIS:   returns the server name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        Johnl   14-Aug-1991     Created

\**********************************************************/

const TCHAR * DEVICE::QueryServer( VOID ) const
{
    if (IsUnconstructed())
        return NULL ;

    return (_szServerName) ;
}  // DEVICE::QueryServerName


/**********************************************************\

   NAME:       DEVICE::GetInfo

   SYNOPSIS:   get the information about the device

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created
        terryk      31-Oct-1991     Add CallAPI worker function

\**********************************************************/

APIERR DEVICE::GetInfo( VOID )
{
    /*
     * must be constructed
     */
    if (IsUnconstructed())
        return ERROR_GEN_FAILURE;

    /*
     * init to no such device and invalid. we will setup properly
     * if all goes well.
     */
    _lmoDevState = LMO_DEV_NOSUCH ;
    MakeInvalid() ;

    /*
     * special case the empty string
     */
    if (_nlsDeviceName.strlen() == 0)
    {
        _lmoDevState = LMO_DEV_UNKNOWN ;
        _lmoDevType = LMO_DEV_ANY ;
    }

    /*
     * validate the name. This has side effect
     * of setting the type, _lmoDevType.
     */
    if (ValidateName() != NERR_Success)
        return(ERROR_INVALID_PARAMETER);

    switch (_lmoDevType)
    {
        case LMO_DEV_DISK :
            if (CheckLocalDrive(_nlsDeviceName.QueryPch()) == NERR_Success)
                _lmoDevState = LMO_DEV_LOCAL ;     // its local
            break ;                                // to remote checking

        case LMO_DEV_PRINT :
            if (CheckLocalLpt(_nlsDeviceName.QueryPch()) == NERR_Success)
                _lmoDevState = LMO_DEV_LOCAL ;     // its local
            break ;                                // to remote checking

        case LMO_DEV_COMM :
            if (CheckLocalComm(_nlsDeviceName.QueryPch()) == NERR_Success)
                _lmoDevState = LMO_DEV_LOCAL ;     // its local
            break ;                                // to remote checking

        case LMO_DEV_ANY :
            _lmoDevState = LMO_DEV_UNKNOWN ;       // unknown since null dev
            break ;                                // to remote checking
        case LMO_DEV_ERROR :
        default:
            UIASSERT(!SZ("DEVICE object passed invalid dev type"));
            return NERR_InternalError;
    }

    /*
     * make it valid. we know it is either local or no such device
     */
    MakeValid();

    /*
     * here we call NET APIs to see if remote.
     * we declare a buffer big enuff for the API call.
     * CODEWORK - this assumption not good under NT.
     */
    APIERR Err = CallAPI( );
    switch( Err )
    {
    case NERR_Success:
        /*
         * if redirected, overwrite current value with Remote
         */
        _lmoDevState = LMO_DEV_REMOTE;
        break;

    case NERR_WkstaNotStarted:
    case NERR_NetNotStarted:
    case NERR_UseNotFound:
    default:
        /*
         * if NetUseGetInfo fails we see if it is an unavail drive.
         */
        INT sType ;
        if (CheckUnavailDevice(_nlsDeviceName.QueryPch(),
                               _szRemoteName,
                               &sType) == NERR_Success)
        {
            /* above would have set _szRemoteName, set the rest now */
            _lmoDevState = LMO_DEV_UNAVAIL ;
            _lmoDevType = ::NetTypeToLMOType(sType) ;
        }
        ::MNetApiBufferFree( &_pBuf );
        return(NERR_Success);
    }

    /*
     * only get here if have redirected device
     */
     SetInfo( );

    /* Copy the server name to _szServerName
     */
    TCHAR * pszEndServerName = ::strchrf( _szRemoteName+2, TCH('\\') ) ;
    UIASSERT( pszEndServerName != NULL ) ;
    ::strncpyf( _szServerName, _szRemoteName,
                (ULONG)(pszEndServerName - _szRemoteName)) ;
    *(_szServerName + (pszEndServerName-_szRemoteName)) = TCH('\0') ;
    UIASSERT( ::strlenf( _szServerName ) <= MAX_PATH ) ;
    ::MNetApiBufferFree( &_pBuf );

    return NERR_Success;

}  // DEVICE::GetInfo

/*******************************************************************

    NAME:       DEVICE::CallAPI

    SYNOPSIS:   worker function for GetInfo - get the info

    RETURNS:    APIERR - return MNetUseGetInfo error code

    HISTORY:
                terryk  13-Oct-1991     Created

********************************************************************/

APIERR DEVICE::CallAPI( )
{
    return ::MNetUseGetInfo( NULL, _nlsDeviceName.QueryPch(), 1, &_pBuf );
}

/*******************************************************************

    NAME:       DEVICE::SetInfo

    SYNOPSIS:   worker function for GetInfo - setup the internal
                variables

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

VOID DEVICE::SetInfo( )
{
    struct use_info_1 *pui1 = (struct use_info_1 *)_pBuf;

    _lmoDevType = ::NetTypeToLMOType ( pui1->ui1_asg_type ) ;
    _uStatus = (UINT)pui1->ui1_status;
    _uRemoteType = (UINT)pui1->ui1_asg_type ;
    ::strcpyf( _szRemoteName, pui1->ui1_remote );
}

/**********************************************************\

   NAME:       DEVICE::WriteInfo

   SYNOPSIS:   Write the device information

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

APIERR DEVICE::WriteInfo( VOID )
{
    UIASSERT(!SZ("WriteInfo not defined for DEVICE objects"));
    return ERROR_GEN_FAILURE ;
}  // DEVICE::WriteInfo


/**********************************************************\

   NAME:       DEVICE::QueryType

   SYNOPSIS:   reutrn _lmoDevType

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

UINT DEVICE::QueryType( VOID ) const
{
    if ( ! IsValid())
        return LMO_DEV_ERROR;

    return _lmoDevType;

}  // DEVICE::QueryType


/**********************************************************\

   NAME:       DEVICE::QueryState

   SYNOPSIS:   check for device state

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

LMO_DEV_STATE DEVICE::QueryState( VOID ) const
{
    if ( ! IsValid())
        return LMO_DEV_BADSTATE;

    return _lmoDevState;

}  // DEVICE::QueryState


/**********************************************************\

   NAME:       DEVICE::QueryStatus

   SYNOPSIS:   check for device status

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

UINT DEVICE::QueryStatus( VOID ) const
{
    if ( QueryState() != LMO_DEV_REMOTE )
        return (UINT) -1;

    return _uStatus;

}  // DEVICE::QueryStatus


/**********************************************************\

   NAME:       DEVICE::QueryRemoteType

   SYNOPSIS:   check for remote type

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

UINT DEVICE::QueryRemoteType( VOID ) const
{
    if ( QueryState() != LMO_DEV_REMOTE && QueryState() != LMO_DEV_UNAVAIL )
        return (UINT)-1;

    return _uRemoteType;

}  // DEVICE::QueryRemoteType


/**********************************************************\

   NAME:       DEVICE::QueryRemoteName

   SYNOPSIS:   check for remote name of the deivce

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

const TCHAR * DEVICE::QueryRemoteName( VOID ) const
{
    if ( QueryState() != LMO_DEV_REMOTE && QueryState() != LMO_DEV_UNAVAIL )
        return NULL;
    return (_szRemoteName) ;

}  // DEVICE::QueryRemoteName



/**********************************************************\

   NAME:       DEVICE::Connect

   SYNOPSIS:   set up connection

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

APIERR DEVICE::Connect( const TCHAR * pszResource, const TCHAR * pszPassword )
{
    struct use_info_1 UseInfo ;
    TCHAR szRemoteName[MAX_PATH+1] ;
    APIERR Err ;

    if (!IsValid())
    {
        UIASSERT(!SZ("Connect called on InValid device")) ;
        return(ERROR_GEN_FAILURE);
    }

    // setup API buffer
    COPYTOARRAY( UseInfo.ui1_local, (TCHAR *) _nlsDeviceName.QueryPch());
    UseInfo.ui1_asg_type = ::LMOTypeToNetType(_lmoDevType) ;

    /*
     * if Resource we are trying to connect to does not start
     * with \\ we try as alias.
     */
    if (!(*pszResource == TCH('\\') && *(pszResource+1) == TCH('\\')))
    {
        /*
         * validate alias as SHARE. The reason we do this is to
         * catch an invalid name as soon as we can.
         * If the user typed a bogus netpath without the leading \\
         * on a domain that does not support aliases, better we
         * fail with bad name before going out to the PDC and come
         * back with some other error.
         */
        if ((Err = ::I_MNetNameValidate(NULL,pszResource,NAMETYPE_SHARE,0L))
            != NERR_Success)
            return(ERROR_INVALID_PARAMETER) ;
#ifdef LAN_SERVER
        if ((Err = AliasToUNC(szRemoteName, (TCHAR *)pszResource))
            != NERR_Success)
            return(Err);
#endif
    }
    else
    {
        // no need validate here, NetUseAdd will fail us appropriately.
        ::strcpyf(szRemoteName,pszResource) ;
    }

    // setup rest of UseInfo struct
    UseInfo.ui1_remote   = szRemoteName ;
    UseInfo.ui1_password = (TCHAR *) pszPassword ;

    // make the connection
    Err = ::MNetUseAdd ( NULL, 1, (BYTE *)&UseInfo, sizeof(UseInfo)) ;
    if (Err == NERR_Success)
    {
        _lmoDevState = LMO_DEV_REMOTE;
        _uStatus = USE_OK;
        ::strcpyf(_szRemoteName,szRemoteName) ;
    }
    return(Err) ;

}  // DEVICE::Connect


/**********************************************************\

   NAME:       DEVICE::Disconnect

   SYNOPSIS:   disconnect the device

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

APIERR DEVICE::Disconnect( UINT uiForce )
{
    APIERR Err ;

    Err =  ::MNetUseDel( NULL,
                         _nlsDeviceName.strlen() ?
                             _nlsDeviceName.QueryPch() : _szRemoteName,
                         uiForce );

    if (Err == NERR_Success)
        MakeConstructed() ;     // no longer valid, force another GetInfo call.

    return(Err) ;

}  // DEVICE::Disconnect

APIERR DEVICE::Disconnect( const TCHAR *pszRemote, UINT uiForce )
{
    UIASSERT(QueryType() == LMO_DEV_ANY) ;

    APIERR Err ;
    Err =  ::MNetUseDel( NULL,
                           pszRemote,
                           uiForce );

    if (Err == NERR_Success)
        MakeConstructed() ;     // no longer valid, force another GetInfo call.

    return(Err) ;

}  // DEVICE::Disconnect

/******************************** ITER_DEVICE *******************************/

/**********************************************************\

   NAME:       ITER_DEVICE::ITER_DEVICE

   SYNOPSIS:   constructor for the iterator device

   ENTRY:

   EXIT:

   NOTES:
      constructor takes 2 flags,
      DevType tells us if Drive/LPT/Comm, as defined by LMO_DEVICE enum,
      Usage tells us what kind of state we are interested in.

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

ITER_DEVICE::ITER_DEVICE(LMO_DEVICE DevType, LMO_DEV_USAGE Usage)
{
    _DevType = DevType ;
    _Usage  = Usage ;           // store it, EnumLPTs, etc will use it.

    switch (DevType)
    {
        case LMO_DEV_PRINT :
            _pszDevices = (TCHAR *)EnumLPTs() ;
            break ;
        case LMO_DEV_DISK :
            _pszDevices = (TCHAR *)EnumDrives() ;
            break ;
        case LMO_DEV_COMM :
            _pszDevices = (TCHAR *)EnumComms() ;
            break ;
        case LMO_DEV_ANY :
        case LMO_DEV_ERROR :
        default:
            _pszDevices = NULL ;                        // this error state
    }

    _pszNext = _pszDevices ;
}

/**********************************************************\

   NAME:       ITER_DEVICE::~ITER_DEVICE

   SYNOPSIS:   destructor of ITER_DEVICE

   ENTRY:

   EXIT:

   NOTES:      destructor just frees the memory we allocated

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

ITER_DEVICE::~ITER_DEVICE()
{
   delete _pszDevices ;
   _pszDevices = NULL ;
}

/**********************************************************\

   NAME:       ITER_DEVICE::Next

   SYNOPSIS:
      Next returns the next item in the list. During constructor we
      expect to generate list of devices separated by spaces.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

const TCHAR * ITER_DEVICE::Next( VOID )
{
    TCHAR * pszTmp ;

    if (!_pszNext || !*_pszNext)
        return(NULL) ;

    pszTmp = _pszNext ;
    _pszNext = (TCHAR *) ::strpbrkf((TCHAR *)_pszNext,SZ(" ")) ;
    if (_pszNext)
    {
        *_pszNext = TCH('\0') ;         // null terminate it
        if (! * ++ _pszNext )           // if there anything after it?
            _pszNext = NULL ;
    }
    return(pszTmp);
}

/**********************************************************\

   NAME:       ITER_DEVICE::EnumDrives

   SYNOPSIS:
      EnumDrives is called by constructor to enumarate the drives
      of interest. Uses member _Usage.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created
        JonN        19-May-1992     Added LMO_DEV_ALLDEVICES

\**********************************************************/

const TCHAR * ITER_DEVICE:: EnumDrives()
{
    ULONG ulMap;
    UINT  uiCount ;
    TCHAR  szTmp[DEVLEN + 1] ;

    /*
     * allocate worst case memory requirements
     */
    if ( !(_pszDevices = new TCHAR [(DEVLEN + 1) * 26]) )
        return (NULL) ;

    switch (_Usage)
    {
        case LMO_DEV_CANCONNECT :
            // we define 'can connect' as all drives not already used
            ulMap = ~(EnumLocalDrives() | EnumNetDrives()) ;
            break ;
        case LMO_DEV_CANDISCONNECT :
            // we define 'can disconnect' as all redirected or unavail ones
            ulMap = EnumNetDrives() | EnumUnavailDrives() ;
            break ;
        case LMO_DEV_ISCONNECTED :
            // net drives is net drives
            ulMap = EnumNetDrives() ;
            break ;
        case LMO_DEV_ALLDEVICES :
            // all valid drive designations
            ulMap = EnumAllDrives();
            break ;
        default:
            ulMap = 0L ;
    }

    /*
     * below does not worry about DBCS, nor does it need to
     */
    *_pszDevices = TCH('\0') ;
    ::strcpyf(szTmp,SZ("A: ")) ;
    for (uiCount = 0 ; uiCount < 26; uiCount++ )
    {
        /*
         * if its of interest, add to string
         */
        if (ulMap & 1L)
            ::strcatf((TCHAR *)_pszDevices,szTmp) ;
        ulMap >>= 1 ;
        ++szTmp[0] ;
    }

    return(_pszDevices) ;
}

/**********************************************************\

   NAME:       ITER_DEVICE::EnumLPTs

   SYNOPSIS:
      EnumLPTs is called by constructor to enumarate the lpts
      of interest. Uses member _Usage.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created
        JonN        19-May-1992     Added LMO_DEV_ALLDEVICES

\**********************************************************/

const TCHAR * ITER_DEVICE:: EnumLPTs()
{
    ULONG ulMap;
    UINT  uiCount ;
    TCHAR szTmp[DEVLEN+1] ;

    /*
     * allocate worst case memory requirements.
     */
    if ( !(_pszDevices = new TCHAR [(DEVLEN + 1) * 11]) )
        return (NULL) ;

    switch (_Usage)
    {
        case LMO_DEV_CANCONNECT :
            // can connect to all that are not redirected
            ulMap = (EnumLocalLPTs() & ~EnumNetLPTs()) ;
            break ;
        case LMO_DEV_CANDISCONNECT :
            // can disconnect to redirected or unavail
            ulMap = EnumNetLPTs() | EnumUnavailLPTs() ;
            break ;
        case LMO_DEV_ISCONNECTED :
            // isconnected = redirected
            ulMap = EnumNetLPTs() ;
            break ;
        case LMO_DEV_ALLDEVICES :
            // all valid LPT designations
            ulMap = EnumAllLPTs();
            break ;
        default:
            ulMap = 0L ;
    }

    /*
     * below does not worry about DBCS, nor does it need to
     * our convention is that bit 0 is LPT1, ... bit 8 is LPT9,
     * bit 9 is LPT1.OS2, bit 10 is LPT2.OS2
     */
    *_pszDevices = TCH('\0') ;
    ::strcpyf(szTmp,SZ("LPT1: ")) ;
    for (uiCount = 0 ; uiCount < 9; uiCount++ )
    {
        /*
         * if its of interest, add to string
         */
        if (ulMap & 1L)
            ::strcatf((TCHAR *)_pszDevices,szTmp) ;
        ulMap >>= 1 ;
        ++szTmp[3] ;
    }

    /*
     * as above, except handle LPT1.OS2, LPT2.OS2
     */
    ::strcpyf(szTmp,SZ("LPT1.OS2 ")) ;
    for (uiCount = 0 ; uiCount < 2; uiCount++ )
    {
        /*
         * if its of interest, add to string
         */
        if (ulMap & 1L)
            ::strcatf((TCHAR *)_pszDevices,szTmp) ;
        ulMap >>= 1 ;
        ++szTmp[3] ;
    }

    return(_pszDevices);
}

/**********************************************************\

   NAME:       ITER_DEVICE::EnumComms

   SYNOPSIS:
      EnumComms is called by constructor to enumarate the Comm ports
      of interest. Uses member _Usage.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

const TCHAR * ITER_DEVICE:: EnumComms()
{
    // BUGBUG not implemented
    UIASSERT(!SZ("EnumComms is not implemented")) ;
    return(NULL);
}



/*
 * NetTypeToLMOType takes a NETAPI device type as defined
 * by USE.H (ie for uiX_asg_type field) and maps it to
 * an LMOBJ device type.
 */
LMO_DEVICE NetTypeToLMOType( ULONG netDevType)
{
    switch (netDevType)
    {
    case USE_DISKDEV:
        return(LMO_DEV_DISK);
    case USE_SPOOLDEV:
        return(LMO_DEV_PRINT);
    case USE_CHARDEV:
        return(LMO_DEV_COMM);
    case USE_WILDCARD:
        return(LMO_DEV_ANY);
    default:
        return(LMO_DEV_ERROR);
    }
}

/*
 * LMOTypeToNetType takes an LMOBJ device type as defined by
 * LMOBJ.HXX and maps it to a device type NETAPI understands,
 * as defined in USE.H. Note that LMOBJ devices do not have a
 * wildcard. If we return the wildcard type it means we do not
 * understand it, and hence it is an error.
 */
INT LMOTypeToNetType(LMO_DEVICE lmoDevType)
{
    switch (lmoDevType)
    {
        case LMO_DEV_DISK:
            return(USE_DISKDEV) ;
        case LMO_DEV_PRINT:
            return(USE_SPOOLDEV) ;
        case LMO_DEV_COMM:
            return(USE_CHARDEV) ;
        case LMO_DEV_ANY:
            return(USE_WILDCARD);
        case LMO_DEV_ERROR:
        default:
            UIASSERT(SZ("bad Dev type")) ;
            return(USE_WILDCARD);
    }
}

#ifdef LAN_SERVER
/**********************************************************\

   NAME:       DEVICE::AliasToUNC

   SYNOPSIS:   Map Alias name to UNC name.

   ENTRY:
      pchRemoteName - where remote name is returned
      we assume this is at least MAX_PATH+1,
      it is the caller's responsibilty.
      pchAlias      - alias name

   RETURN:
      0 - success
      API error code otherwise

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created

\**********************************************************/

UINT DEVICE::AliasToUNC(TCHAR *pchRemoteName, const TCHAR *pchAlias)
{
    APIERR             Err;
    TCHAR               szPDC[MAX_PATH+1];          /* domain controller */
    share_info_92     *ShareInfo92;

    /*
     * use wksta object to get logon domain. If cannot get,
     * cant do much anyway, return error now.
     */
    WKSTA_10 wksta ;
    if ( (Err = wksta.GetInfo()) != NERR_Success )
        return(Err) ;
    TCHAR *pchDomain = (TCHAR *)wksta.QueryLogonDomain() ;

    /*
     * use domain object to get PDC. If cannot get, return no DC.
     */
    DOMAIN domain(pchDomain);
    if (domain.GetInfo() == NERR_Success)
    {
        strcpyf(szPDC,domain.QueryPDC()) ;
    }
    else
        return( NERR_DCNotFound );

    /*
     * use buffer object to get alias stuff. We
     * derive max size from the components and add 16 for safety.
     */
    BYTE *pBuffer = NULL;

    if( Err = ::MNetShareGetInfo( szPDC,
                                    (TCHAR *)pchAlias,
                                    92,
                                    &pBuffer ))
    {
        /*
         * if we get an error and it is in the alias range, we map
         * to something we can understand. Else user sees ERROR xxxx.
         * BUGBUG, need define upper bound in NETERR.H
         */
        if (Err >= ALERR_BASE)
            Err = ERROR_BAD_NETPATH ;
        return(Err);
    }

    ShareInfo92 = ( share_info_92 * ) pBuffer;
    ShareInfo92->shi92_alias = (TCHAR *)pchAlias;
    /*
     * copy the info over
     */
    ::strcpyf( pchRemoteName, ShareInfo92->shi92_server );
    ::strcatf( pchRemoteName, SZ("\\") );
    ::strcatf( pchRemoteName, ShareInfo92->shi92_netname );
    ::MNetApiBufferFree( &pBuffer );
    return(NERR_Success) ;
}
#endif

/**********************************************************\

   NAME:       DEVICE::ValidateName

   SYNOPSIS:   validate device name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL     07-Dec-1990     Created
        Johnl       19-Feb-1992     Added check for UNC name, changed
                                    comparisons to be case insensitive

\**********************************************************/

APIERR DEVICE::ValidateName()
{
    TCHAR *pszDev = (TCHAR *) _nlsDeviceName.QueryPch() ;

    /*
     * check for null case and for invalid length
     */
    UINT uiLen ;
    if (pszDev[0] == TCH('\0') ||
        ( pszDev[0] == TCH('\\') && pszDev[1] == TCH('\\') ))
    {
        _lmoDevType = LMO_DEV_ANY ;
        return(NERR_Success) ;
    }

    if ((uiLen = strlenf( pszDev )) > DEVLEN )
    {
        return(ERROR_INVALID_PARAMETER) ;
    }

    /*
     * now validate the string as valid device and set type
     */
    // try as disk
    if ( uiLen == 2 && pszDev[1] == TCH(':') &&
        ((pszDev[0] >= TCH('A') && pszDev[0] <= TCH('Z')) ||
         (pszDev[0] >= TCH('a') && pszDev[0] <= TCH('a')) ))
    {
        // it is a drive letter
        _lmoDevType = LMO_DEV_DISK ;
        return(NERR_Success) ;
    }

    /*
     * By now we know it is not a disk, so we make sure it is at least 4
     * chars long, and if there is colon insist it is last.
     */
    TCHAR *    pszColon;
    if (uiLen < 4)
        return(ERROR_INVALID_PARAMETER) ;
    if (pszColon = ::strpbrkf(pszDev, SZ(":")))
    {
        /*
         * found a colon
         */
        if ( *(pszColon+1) != TCH('\0') )
            return(ERROR_INVALID_PARAMETER) ; // if colon, it must be last char

        // we decrement usLen to ignore the colon in further checks
        --uiLen ;
    }

    /*
     * try as print device, we are assured of at least 4 chars.
     * first we try match LPT[1-9]. If this succeeds,
     * we need assure usLen==4 or it is one of those LPTx.OS2
     * drives. usLen will be 4 iff:
     *          it is LPTx or
     *          it is LPTx:
     * note we did the decrement to ignore the colon a few lines back.
     */
    if (::strnicmpf(pszDev,SZ("LPT"),3) == 0 &&
             pszDev[3] >= TCH('1') && pszDev[3] <= TCH('9'))
    {
        if (uiLen == 4 ||
            ::strnicmpf( pszDev,
                         SZ("LPT1.OS2"),8) == 0 ||
            ::strnicmpf( pszDev,SZ("LPT2.OS2"),8) == 0)
        {
            _lmoDevType = LMO_DEV_PRINT ;
            return(NERR_Success) ;
        }
        return(ERROR_INVALID_PARAMETER) ;
    }

    /*
     * try comm. same assumptions as above.
     */
    if (::strnicmpf( pszDev,SZ("COM"),3) == 0
        && (pszDev[3] >= TCH('1') && pszDev[3] <= TCH('9'))
        && (uiLen == 4))
    {
        _lmoDevType = LMO_DEV_COMM ;
        return(NERR_Success) ;
    }

    /*
     * if get here, it must be bad
     */
    return(ERROR_INVALID_PARAMETER) ;
}

/*******************************************************************

    NAME:       DEVICE::SetRemoteName

    SYNOPSIS:   set the remote name of the device

    ENTRY:      const TCHAR * pszRemoteName - new remote name

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

VOID DEVICE::SetRemoteName( const TCHAR * pszRemoteName )
{
    ::strcpy( _szRemoteName, pszRemoteName );
}

/*******************************************************************

    NAME:       DEVICE::SetServerName

    SYNOPSIS:   set the server name

    ENTRY:      const TCHAR * pszServername - new server name

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

VOID DEVICE::SetServerName( const TCHAR * pszServerName )
{
    strcpyf(_szServerName, pszServerName) ;
}

#ifdef WIN32

/*******************************************************************

    NAME:       DEVICE2::DEVICE2

    SYNOPSIS:   constructor

    ENTRY:      const TCHAR * pszName - device name

    HISTORY:
                terryk  31-Oct-91       Created
                JohnL   30-Jan-1992     Added Domain Name

********************************************************************/

DEVICE2::DEVICE2( const TCHAR * pszName )
    : DEVICE( pszName ),
      _nlsUsername(),
      _nlsDomainName()
{
    APIERR err ;
    if ( (err = _nlsUsername.QueryError()) ||
         (err = _nlsDomainName.QueryError()) )
    {
        return;
    }
}

/*******************************************************************

    NAME:       DEVICE2::CallAPI

    SYNOPSIS:   worker function for get info - get net info

    RETURNS:    APIERR - net api error code

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

APIERR DEVICE2::CallAPI( )
{
    BYTE *pBuf = NULL;
    APIERR err = ::MNetUseGetInfo( NULL, QueryName(), 2, &pBuf );
    SetBufPtr( pBuf );
    return err;
}

/*******************************************************************

    NAME:       DEVICE2::SetInfo

    SYNOPSIS:   worker function get GetInfo - set internal variables

    HISTORY:
                terryk  31-Oct-91       Created

********************************************************************/

VOID DEVICE2::SetInfo( )
{
    struct use_info_2 * pui2 = (struct use_info_2 *)QueryBufPtr();
    SetUsername( pui2->ui2_username );
    SetDomainName( pui2->ui2_domainname ) ;
    SetDevType( ::NetTypeToLMOType ( pui2->ui2_asg_type )) ;
    SetStatus( (UINT) pui2->ui2_status );
    SetRemoteType( (UINT) pui2->ui2_asg_type );
    SetRemoteName( pui2->ui2_remote );
}


/*******************************************************************

    NAME:       DEVICE2::Connect

    SYNOPSIS:   connect device 2 to the network

    ENTRY:      const TCHAR *pszResource - resource name
                const TCHAR *pszPassword - password
                const TCHAR *pszUsername - username
                const TCHAR *pszDomainName - Domain name
                ULONG ulFlags - flags for NetUseAdd level 3
                    (defaults to 0, in which case this is the
                    same as calling NetUseAdd level 2)

    RETURNS:    APIERR - net api error code

    HISTORY:
                terryk   31-Oct-91      Created
                anirudhs 16-Jan-96      Changed to level 3 call

********************************************************************/

APIERR DEVICE2::Connect( const TCHAR * pszResource,
                         const TCHAR * pszPassword,
                         const TCHAR * pszUsername,
                         const TCHAR * pszDomainName,
                         ULONG ulFlags )
{
    USE_INFO_3 UseInfo ;
    TCHAR szRemoteName[MAX_PATH+1] ;
    APIERR Err ;

    if (!IsValid())
    {
        UIASSERT(!SZ("Connect called on InValid device")) ;
        return(ERROR_GEN_FAILURE);
    }

    // setup API buffer
    COPYTOARRAY( UseInfo.ui3_ui2.ui2_local, (TCHAR *)QueryName());
    UseInfo.ui3_ui2.ui2_asg_type = ::LMOTypeToNetType(QueryDevType()) ;

    if ( pszUsername != NULL && *pszUsername != TCH('\0') )
    {
        if (( Err = ::I_NetNameValidate( NULL, (TCHAR *)pszUsername, NAMETYPE_USER,
            0L)) != NERR_Success )
        {
            return Err ;
        }
    }

    /*
     * if Resource we are trying to connect to does not start
     * with \\ we try as alias.
     */
    if (!(*pszResource == TCH('\\') && *(pszResource+1) == TCH('\\')))
    {
        /*
         * validate alias as SHARE. The reason we do this is to
         * catch an invalid name as soon as we can.
         * If the user typed a bogus netpath without the leading \\
         * on a domain that does not support aliases, better we
         * fail with bad name before going out to the PDC and come
         * back with some other error.
         */
        if ((Err = ::I_MNetNameValidate(NULL,pszResource,NAMETYPE_SHARE,0L))
            != NERR_Success)
            return(ERROR_INVALID_PARAMETER) ;
#ifdef LAN_SERVER
        if ((Err = AliasToUNC(szRemoteName, (TCHAR *)pszResource))
            != NERR_Success)
            return(Err);
#endif
    }
    else
    {
        // no need validate here, NetUseAdd will fail us appropriately.
        ::strcpyf(szRemoteName,pszResource) ;
    }

    // setup rest of UseInfo struct
    UseInfo.ui3_ui2.ui2_remote   = szRemoteName ;
    UseInfo.ui3_ui2.ui2_password = (TCHAR *) pszPassword ;
    UseInfo.ui3_ui2.ui2_username = (TCHAR *) pszUsername;
    UseInfo.ui3_ui2.ui2_domainname = (TCHAR *) pszDomainName ;
    UseInfo.ui3_flags = ulFlags;

    // make the connection
    Err = ::MNetUseAdd ( NULL, 3, (BYTE *)&UseInfo, sizeof(UseInfo)) ;
    if (Err == NERR_Success)
    {
        SetDevState( LMO_DEV_REMOTE );
        SetStatus( USE_OK );
        SetRemoteName(szRemoteName) ;
    }
    return(Err) ;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmofile.cxx ===
/**********************************************************************/
/**              Microsoft LAN Manager                               **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
    lmofile.cxx
	LM_FILE source file.

	LM_FILE object is use to handle the ::NetFileClose2 and
	::NetFileGetInfo2 netapi.

    FILE HISTORY:
	terryk	16-Aug-1991	Created
	terryk	20-Aug-1991	Add QueryError to constructor
	terryk	26-Aug-1991	Code review changed. Attend: Chuckc
				Keithmo hui-lich terryk
	terryk	10-Oct-1991	type changes for NT
	KeithMo	08-Oct-1991	Now includes LMOBJP.HXX.
	terryk	17-Oct-1991	WIN 32 conversion
	terryk	21-Oct-1991	cast _pBuffer variable

*/

#include "pchlmobj.hxx"  // Precompiled header


/**********************************************************\

    NAME:       LM_FILE::LM_FILE

    SYNOPSIS:   constructor

    ENTRY:      const TCHAR * pszServer - server name
		ULONG ulFileId - file id of the file

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

LM_FILE::LM_FILE( const TCHAR * pszServer, ULONG ulFileId )
    : NEW_LM_OBJ(),
    _nlsServer( pszServer ),
    _ulFileId( ulFileId )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("LM_FILE error: construction failure.") );
	ReportError( err );
	return;
    }

    err = _nlsServer.QueryError();
    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("LM_FILE error: construction failure.") );
	ReportError( err );
	return;
    }
}

/**********************************************************\

    NAME:       LM_FILE::~LM_FILE

    SYNOPSIS:   destructor

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

LM_FILE::~LM_FILE()
{
    // do nothing
}

/**********************************************************\

    NAME:       LM_FILE::QueryFileId

    SYNOPSIS:   return the current file id of the object

    RETURN:     ULONG - the current file id

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

ULONG LM_FILE::QueryFileId() const
{
    return _ulFileId;
}

/**********************************************************\

    NAME:       LM_FILE::QueryServer

    SYNOPSIS:   return the server name

    RETURN:     const TCHAR * - the server name

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

const TCHAR * LM_FILE::QueryServer() const
{
    return _nlsServer.QueryPch();
}

/**********************************************************\

    NAME:       LM_FILE::SetFileId

    SYNOPSIS:   set the object file id to the new value

    ENTRY:      ULONG ulFileId - new file id

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE::SetFileId( ULONG ulFileId )
{
    _ulFileId = ulFileId;
    return NERR_Success;
}

/**********************************************************\

    NAME:       LM_FILE::SetServer

    SYNOPSIS:   set the object server name to the new value

    ENTRY:      const TCHAR * pszServer - new server name

    RETURN:	APIERR for set string error

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE::SetServer( const TCHAR * pszServer )
{
    _nlsServer = pszServer;
    return _nlsServer.QueryError();
}

/**********************************************************\

    NAME:       LM_FILE::CloseFile

    SYNOPSIS:   close the file

    RETURN:	return the APIERR for NetFileClose2

    NOTES:      It will call ::NetFileClose2 to close the file

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE::CloseFile()
{
    return ::MNetFileClose( QueryServer(), QueryFileId() );
}

/**********************************************************\

    NAME:       LM_FILE_2::LM_FILE_2

    SYNOPSIS:   constructor

    ENTRY:      const TCHAR * pszServer - server name
		ULONG ulFileId - file id

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

LM_FILE_2::LM_FILE_2( const TCHAR * pszServer, ULONG ulFileId )
    : LM_FILE( pszServer, ulFileId )
{
    APIERR err = QueryError();

    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("LM_FILE_2 error: construction failure.") );
	ReportError( err );
	return;
    }
}

/**********************************************************\

    NAME:       LM_FILE_2::I_GetInfo

    SYNOPSIS:   level 2 get file information

    RETURN:     APIERR - NERR_Success for sucess. Failure otherwise.

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE_2::I_GetInfo()
{
    struct file_info_2	*pfi2 = NULL;

    // since fi2 does not contain any pointer reference, we don't need
    // to allocate a buffer for it.
    APIERR err = ::MNetFileGetInfo( QueryServer(), QueryFileId(), 2,
	(BYTE ** )&pfi2 );

    if ( err == NERR_Success )
    {
	err = SetFileId( pfi2->fi2_id );
    }

    ::MNetApiBufferFree( (BYTE **)&pfi2 );

    return err;
}

/**********************************************************\

    NAME:       LM_FILE_3::LM_FILE_3

    SYNOPSIS:   file level 3 object. It will return the permission
		and number of locks information.

    ENTRY:      const TCHAR * pszServer - the server name
		ULONG ulFileId - file id

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

LM_FILE_3::LM_FILE_3( const TCHAR * pszServer, ULONG ulFileId )
    : LM_FILE_2( pszServer, ulFileId ),
    _uLock( 0 ),
    _uPermission( 0 ),
    _nlsPathname(),
    _nlsUsername()
{
    APIERR err = QueryError();

    if ( err != NERR_Success )
    {
	UIASSERT( !SZ("LM_FILE_3 error: construction failure.") );
	ReportError( err );
	return;
    }

    if ((( err = _nlsPathname.QueryError()) != NERR_Success ) ||
	(( err = _nlsUsername.QueryError()) != NERR_Success ))
    {
	UIASSERT( !SZ("LM_FILE_3 error: construction failure.") );
	ReportError( err );
	return;
    }
}


/**********************************************************\

    NAME:       LM_FILE_3::I_GetInfo

    SYNOPSIS:   get the level 3 file information

    NOTES:      It will call the ::NetGetInfo2() function will level 3
		specification. After it gets the information, it will
		set up the internal variables.

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

APIERR LM_FILE_3::I_GetInfo()
{
    BYTE *pBuffer = NULL;
    APIERR err = ::MNetFileGetInfo( QueryServer(), QueryFileId(), 3,
	 &pBuffer );

    struct file_info_3 * fi3 = ( struct file_info_3 * )pBuffer;

    if ( err == NERR_Success )
    {
	err = SetFileId( fi3->fi3_id );
	UIASSERT( err == NERR_Success );

	_uPermission  = (UINT)fi3->fi3_permissions;
	_uLock        = (UINT)fi3->fi3_num_locks;
	_nlsPathname  = fi3->fi3_pathname;
	err = _nlsPathname.QueryError();
	if ( err != NERR_Success )
	{
	    ::MNetApiBufferFree( &pBuffer );
	    return ( err );
	}
	_nlsUsername  = fi3->fi3_username;
	err = _nlsUsername.QueryError();
	if ( err != NERR_Success )
	{
	    ::MNetApiBufferFree( &pBuffer );
	    return ( err );
	}
    }

    ::MNetApiBufferFree( &pBuffer );

    return err;
}

/**********************************************************\

    NAME:       LM_FILE_3::QueryPathname

    SYNOPSIS:   return the pathname of the currect object

    RETURN:     const TCHAR * - return the path name

    NOTES:      must call after GetInfo is called.

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

const TCHAR * LM_FILE_3::QueryPathname() const
{
    return _nlsPathname.QueryPch();
}

/**********************************************************\

    NAME:       LM_FILE_3::QueryUsername

    SYNOPSIS:   return the username of the current object

    ENTRY:      const TCHAR * - return the user name

    NOTES:      must call after GetInfo is called

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

const TCHAR * LM_FILE_3::QueryUsername() const
{
    return _nlsUsername.QueryPch();
}

/**********************************************************\

    NAME:       LM_FILE_3::QueryNumLock

    SYNOPSIS:   return the number of lock to the current file

    RETURN:     UINT - the total number of locks

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

UINT LM_FILE_3::QueryNumLock() const
{
    return _uLock;
}

/**********************************************************\

    NAME:       LM_FILE_3::QueryPermission

    SYNOPSIS:   return the permission field of the object

    RETURN:     UINT - permission field of the object

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

UINT LM_FILE_3::QueryPermission() const
{
    return _uPermission;
}

/**********************************************************\

    NAME:       LM_FILE_3::IsPermRead

    SYNOPSIS:   return whether the current object is readable or not

    RETURN:     BOOL - TRUE for readable, FALSE otherwise.

    NOTES:	must call after GetInfo is called

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

BOOL LM_FILE_3::IsPermRead() const
{
    return ( _uPermission & PERM_FILE_READ ) != 0;
}

/**********************************************************\

    NAME:       LM_FILE_3::IsPermWrite

    SYNOPSIS:   return whether the current object is writable or not

    RETURN:     BOOL - TRUE for writable, FALSE otherwise.

    NOTES:	must call after GetInfo is called

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

BOOL LM_FILE_3::IsPermWrite() const
{
    return ( _uPermission & PERM_FILE_WRITE ) != 0;
}

/**********************************************************\

    NAME:       LM_FILE_3::IsPermCreate

    SYNOPSIS:   return whether the current object( directory ) can
		created file or not

    RETURN:     BOOL - TRUE for can, FALSE otherwise.

    NOTES:	must call after GetInfo is called

    HISTORY:
		terryk	16-Aug-1991	Created

\**********************************************************/

BOOL LM_FILE_3::IsPermCreate() const
{
    return ( _uPermission & PERM_FILE_CREATE ) != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmogroup.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
 *  lmogroup.cxx
 *
 *  HISTORY:
 *	o-SimoP	12-Aug-1991	Created, cloned from lmouser.cxx
 *	o-SimoP 20-Apr-91	CR changes, attended by ChuckC,	
 *				ErichCh, RustanL, JonN and me
 *	terryk	07-Oct-91	type changes for NT
 *	KeithMo	10/8/91		Now includes LMOBJP.HXX.
 *	jonn	09-Oct-91	Added GROUP_0 and GROUP_1
 *	terryk	17-Oct-91	WIN 32 conversion
 *	terryk	21-Oct-91	cast _pBuffer variable to TCHAR *
 *	jonn	31-Oct-91	Removed SetBufferSize
 *
 */
#include "pchlmobj.hxx"  // Precompiled header



/*******************************************************************

    NAME:	GROUP::GROUP

    SYNOPSIS:	constructor for the GROUP object

    ENTRY:	pszGroup -	account name

		pszLocation -	server or domain name to execute on;
				default (NULL) means the local computer
		OR:
		loctype -	type of location, local computer or
				logon domain
		OR:
		loc -		location, local computer or logon domain

    NOTE:	Constructors differs only in param that is passed to
    		LOC_LM_OBJ

    HISTORY:
    	o-SimoP	12-Aug-1991	Created

********************************************************************/

GROUP::GROUP(const TCHAR *pszGroup, const TCHAR *pszLocation)
	: LOC_LM_OBJ( pszLocation ),
	  _nlsGroup()
{

    if ( QueryError() != NERR_Success )
	return;

    CtAux( pszGroup );
}


GROUP::GROUP(const TCHAR *pszGroup, enum LOCATION_TYPE loctype)
	: LOC_LM_OBJ( loctype ),
	  _nlsGroup()
{

    if ( QueryError() != NERR_Success )
	return;
	
    CtAux( pszGroup );
}


GROUP::GROUP(const TCHAR *pszGroup, const LOCATION & loc )
	: LOC_LM_OBJ( loc ),
	  _nlsGroup()
{

    if ( QueryError() != NERR_Success )
	return;
	
    CtAux( pszGroup );
}



/*******************************************************************

    NAME:	GROUP::CtAux

    SYNOPSIS:	Worker function for constructors

    HISTORY:
    	o-SimoP	12-Aug-1991	Created
		
********************************************************************/

VOID GROUP::CtAux( const TCHAR * pszGroup )
{
    APIERR err = _nlsGroup.QueryError();
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    err = SetName( pszGroup );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }
}


/*******************************************************************

    NAME:	GROUP::~GROUP

    SYNOPSIS:	Destructor for GROUP class

    HISTORY:
    	o-SimoP	12-Aug-1991	Created

********************************************************************/

GROUP::~GROUP()
{
}


/*******************************************************************

    NAME:	GROUP::W_CloneFrom

    SYNOPSIS:	Copies information on the group

    EXIT:	Returns an API error code

    HISTORY:
	jonn	10/9/91		Created

********************************************************************/

APIERR GROUP::W_CloneFrom( const GROUP & group )
{
    APIERR err = LOC_LM_OBJ::W_CloneFrom( group );
    if ( err != NERR_Success )
	return err;

    return _nlsGroup.CopyFrom( group.QueryName() );
}


/*******************************************************************

    NAME:	GROUP::QueryName

    SYNOPSIS:	Returns the name of the group

    EXIT:	Returns a pointer to the group name

    NOTES:	Will be the same as the account name supplied at
		construction.

    HISTORY:
    	o-SimoP	12-Aug-1991	Created

********************************************************************/

const TCHAR *GROUP::QueryName() const
{
    return _nlsGroup.QueryPch();
}


/*******************************************************************

    NAME:	GROUP::SetName

    SYNOPSIS:	Changes the name of the group

    ENTRY:	new group name

    EXIT:	Returns an API error code

    HISTORY:
    	o-SimoP	12-Aug-1991	Created

********************************************************************/

APIERR GROUP::SetName( const TCHAR * pszGroup )
{
    APIERR err;	
    if ( pszGroup != NULL && strlenf( pszGroup ) != 0 )
    {
	err = ::I_MNetNameValidate(
		NULL,
		pszGroup,
		NAMETYPE_GROUP,
		0L );
        if ( err != NERR_Success )
	    return err;
    }

// BUGBUG use NLS_STR safe copy
    _nlsGroup = pszGroup;
    err = _nlsGroup.QueryError();
    if( err != NERR_Success )
	_nlsGroup.Reset();
    return err;
}


/*******************************************************************

    NAME:	GROUP::I_Delete

    SYNOPSIS:	Deletes the group (calls NET API)

    RETURNS:	Returns an API error code

    HISTORY:	
    	o-SimoP		13-Aug-91	Created
********************************************************************/

APIERR GROUP::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    return ::MNetGroupDel( QueryServer(), (TCHAR *)QueryName() );
}


/*******************************************************************

    NAME:	GROUP_1::GROUP_1

    SYNOPSIS:	constructor for the GROUP_1 object

    ENTRY:	pszGroup -	account name

		pszLocation -	server or domain name to execute on;
				default (NULL) means the local computer
		OR:
		loctype -	type of location, local computer or
				logon domain
		OR:
		loc -		location, local computer or logon domain

    NOTE:	Constructors differs only in param that is passed to
    		LOC_LM_OBJ

    HISTORY:
    	JonN	09-Oct-1991	Created

********************************************************************/

GROUP_1::GROUP_1(const TCHAR *pszGroup, const TCHAR *pszLocation)
    : GROUP_0( pszGroup, pszLocation ),
      _nlsComment()
{
    CtAux();
}

GROUP_1::GROUP_1(const TCHAR *pszGroup, enum LOCATION_TYPE loctype)
    : GROUP_0( pszGroup, loctype ),
      _nlsComment()
{
    CtAux();
}

GROUP_1::GROUP_1(const TCHAR *pszGroup, const LOCATION & loc)
    : GROUP_0( pszGroup, loc ),
      _nlsComment()
{
    CtAux();
}

GROUP_1::~GROUP_1()
{
}

VOID GROUP_1::CtAux()
{
    APIERR err = _nlsComment.QueryError();
    if ( err != NERR_Success )
	ReportError( err );
}



/*******************************************************************

    NAME:	GROUP_1::I_GetInfo

    SYNOPSIS:	Gets information about the group

    ENTRY:

    EXIT:	Returns a standard LANMAN error code

    HISTORY:
	jonn	    09-Oct-1991     Templated from USER_11
	jonn	    31-Oct-1991     Removed SetBufferSize

********************************************************************/

APIERR GROUP_1::I_GetInfo()
{

    // BUGBUG who validates group name?

    BYTE *pBuffer = NULL;
    APIERR err = ::MNetGroupGetInfo ( QueryServer(), (TCHAR *)QueryName(), 1,
			&pBuffer );

    if ( err != NERR_Success )
	return err;

    SetBufferPtr( pBuffer );

    struct group_info_1 *lpgi1 = (struct group_info_1 *)QueryBufferPtr();
    UIASSERT( lpgi1 != NULL );


    if (   ((err = SetComment( lpgi1->grpi1_comment )) != NERR_Success)
       )
    {
	return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:	GROUP_1::I_WriteInfo

    SYNOPSIS:	Writes information about the group

    EXIT:	Returns API error code

    HISTORY:
	jonn	    09-Oct-91	    Created

********************************************************************/

APIERR GROUP_1::I_WriteInfo()
{
    APIERR err = W_Write();
    if ( err != NERR_Success )
	return err;

    return ::MNetGroupSetInfo ( QueryServer(), (TCHAR *)QueryName(), 1,
				QueryBufferPtr(),
				sizeof(struct group_info_1 ), PARMNUM_ALL );
}



APIERR GROUP_1::I_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = W_CreateNew()) != NERR_Success )
	|| ((err = ResizeBuffer( sizeof(group_info_1) )) != NERR_Success )
	|| ((err = ClearBuffer()) != NERR_Success )
       )
    {
	return err;
    }

    return NERR_Success;

}

APIERR GROUP_1::I_WriteNew()
{

    APIERR err = W_Write();
    if ( err != NERR_Success )
	return err;

/*
    We pass size sizeof(struct group_info_1) instead of QueryBufferSize()
    to force all pointers to point outside of the buffer.
*/

    return ::MNetGroupAdd ( QueryServer(), 1,
			    QueryBufferPtr(),
			    sizeof( struct group_info_1 ) );
}


/**********************************************************\

    NAME:	GROUP_1::I_ChangeToNew

    SYNOPSIS:	NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
		to NEW status only when a corresponding I_ChangeToNew()
		exists.  The group_info_1 API buffer is the same for new
		and valid objects, so this nethod doesn't have to do
		much.

    HISTORY:
   	JonN	    09-Oct-1991     Created

\**********************************************************/

APIERR GROUP_1::I_ChangeToNew()
{
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:	GROUP_1::CloneFrom

    SYNOPSIS:	Copies information on the group

    EXIT:	Returns an API error code

    HISTORY:
	jonn	10/9/91		Created

********************************************************************/

APIERR GROUP_1::CloneFrom( const GROUP_1 & group1 )
{
    APIERR err = W_CloneFrom( group1 );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("GROUP_1::W_CloneFrom failed with error code ") );
	UIDEBUGNUM( (LONG)err );
	UIDEBUG( SZ("\r\n") );

	ReportError( err ); // BUGBUG make unconstructed here??
	return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:	GROUP_1::W_Write

    SYNOPSIS:	Helper function for WriteNew and WriteInfo -- loads
		current values into the API buffer

    EXIT:	Returns API error code

    HISTORY:
	jonn	    10/9/91	    Created

********************************************************************/

APIERR GROUP_1::W_Write()
{
    struct group_info_1 *lpgi1 = (struct group_info_1 *)QueryBufferPtr();
    ASSERT( lpgi1 != NULL );
    ASSERT( strlenf(QueryName()) <= GNLEN );
    // grpi1_name is a buffer rather than a pointer
    COPYTOARRAY(lpgi1->grpi1_name, (TCHAR *)QueryName() );
    lpgi1->grpi1_comment = (TCHAR *)QueryComment();

    return NERR_Success;
}


/*******************************************************************

    NAME:	GROUP_1::W_CreateNew

    SYNOPSIS:	initializes private data members for new object

    EXIT:	Returns an API error code

    HISTORY:
	jonn	10/9/91		Created

********************************************************************/

APIERR GROUP_1::W_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = GROUP::W_CreateNew()) != NERR_Success )
	|| ((err = SetComment( NULL )) != NERR_Success )
       )
    {
	UIDEBUG( SZ("GROUP_1::W_CreateNew failed\r\n") );
	return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:	GROUP_1::W_CloneFrom

    SYNOPSIS:	Copies information on the group

    EXIT:	Returns an API error code

    HISTORY:
	jonn	10/9/91		Created

********************************************************************/

APIERR GROUP_1::W_CloneFrom( const GROUP_1 & group1 )
{
    APIERR err = NERR_Success;
    if (   ((err = GROUP::W_CloneFrom( group1 )) != NERR_Success )
	|| ((err = SetComment( group1.QueryComment() )) != NERR_Success )
       )
    {
	UIDEBUG( SZ("GROUP_1::W_CloneFrom failed\r\n") );
	return err;
    }

    return NERR_Success;
}



APIERR GROUP_1::SetComment( const TCHAR * pszComment )
{
    return _nlsComment.CopyFrom( pszComment );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmodom.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
 *  lmodom.cxx
 *
 *  HISTORY:
 *      RustanL         08-Jan-1991     Created
 *      beng            11-Feb-1991     Uses lmui.hxx
 *      rustanl         06-Mar-1991     Changed PSZ to const TCHAR * in ct
 *      ChuckC          3/6/91          Code Review changes from 2/28/91
 *                                      (chuckc,johnl,rustanl,annmc,jonshu)
 *      rustanl         23-Mar-1991     Added IsLANServerDomain method
 *      terryk          10-Oct-1991     type changes for NT
 *      KeithMo         10/8/91         Now includes LMOBJP.HXX.
 *      terryk          17-Oct-1991     WIN 32 conversion
 *      terryk          21-Oct-1991     cast _pBuffer to TCHAR *
 *      KeithMo         31-Aug-1992     Added ctor form with server name.
 *      JonN            14-Oct-1993     Now tries to call NetGetAnyDCName
 *      JonN            18-May-1998     Replaced NetGetAnyDCName with DsGetDCName
 *
 */

/*
 *  When searching for any DC, we first try NetGetAnyDCName, then if that
 *  fails, we try I_NetGetDCList.  NetGetAnyDCName only works reliably
 *  when remoted to a machine which trusts the domain in question,
 *  while I_NetGetDCList does not like to be remoted at all (it is a
 *  Bowser internal routine which only returns DCs on the same transport
 *  as the connection).
 *
 * JonN 5/18/98: NetGetAnyDCName(servername) has the following problem
 * associated with networks which do not route NETBIOS throughout:
 * Suppose we call NetGetAnyDCName and specify a servername as well as a
 * domainname.  NetGetAnyDCName will ask the target server to identify a DC
 * it can reach in the target domain.  This DC must share some transport with
 * the target server, but it does not necessarily share any transports with
 * the local machine.
 *
 * On the other hand, if we don't pass the servername, NetGetAnyDCName will fail
 * for workstations in a domain other than the target domain.  For these and other
 * reasons, I am replacing the call to NetGetAnyDCName with a call to DsGetDCName.
 *
 * SPECIAL CAUTION: with these changes, the pszServer parameter
 * no longer has any effect!
 */

/*
 * BUGBUG - this module needs cleanup. the methods QueryDC and QueryPDC
 * both return the same the same thing, which is confusing.
 *
 * THe DOMAIN_WITH_DC_CACHE subclass has been added in a manner to
 * minimize impact on existing code. its functionality should be folded
 * into the DOMAIN class for a cleaner class organization.
 */

#include "pchlmobj.hxx"  // Precompiled header
#include <dsgetdc.h> // DsGetDCName


/**********************************************************\

   NAME:       DOMAIN::DOMAIN

   SYNOPSIS:   constructor for the domain class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created
        DavidHov        6/4/92          Fixed UNICODE "sizeof" problem
                                        in call to ::strncpyf().
        KeithMo         31-Aug-1992     Moved "guts" to CtAux, added
                                        ctor form with server name.

\**********************************************************/

DOMAIN::DOMAIN( const TCHAR * pchDomain,
                BOOL fBackupDCsOK)
  : _fBackupDCsOK(fBackupDCsOK)
{
    CtAux( NULL, pchDomain );

}  // DOMAIN::DOMAIN

// SPECIAL CAUTION: the pszServer parameter no longer has any effect!
DOMAIN::DOMAIN( const TCHAR * pszServer,
                const TCHAR * pszDomain,
                BOOL fBackupDCsOK )
  : _fBackupDCsOK( fBackupDCsOK )
{
    CtAux( pszServer, pszDomain );

}  // DOMAIN::DOMAIN

/**********************************************************\

   NAME:       DOMAIN::~DOMAIN

   SYNOPSIS:   destructor for the domain class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created

\**********************************************************/

DOMAIN::~DOMAIN()
{
}  // DOMAIN::~DOMAIN


/**********************************************************\

   NAME:        DOMAIN::CtAux

   SYNOPSIS:    Constructor helper.

   ENTRY:       pszServer               - Target server (may be NULL).

                pszDomain               - Target domain (may be NULL).

   EXIT:        Private data members initialized.

   HISTORY:
        KeithMo         31-Aug-1992     Created from old ctor.

\**********************************************************/
VOID DOMAIN::CtAux( const TCHAR * pszServer,
                    const TCHAR * pszDomain )
{
    //
    //  Mark the object as unconstructed until proven otherwise.
    //

    MakeUnconstructed();

    //
    //  Blank out our private strings.
    //

    ::memsetf( _szDomain, 0, sizeof(_szDomain) );
    ::memsetf( _szDC,     0, sizeof(_szDC)     );
    ::memsetf( _szServer, 0, sizeof(_szServer) );

    //
    //  If a server name was specified, copy it over.
    //

    if( pszServer != NULL )
    {
        ::strncpyf( _szServer,
                    pszServer,
                    ( sizeof(_szServer) - 1 ) / sizeof(TCHAR) );
    }

    //
    //  If a domain name was specified, copy it over.
    //

    if( pszDomain != NULL )
    {
        ::strncpyf( _szDomain,
                    pszDomain,
                    ( sizeof(_szDomain) - 1 ) / sizeof(TCHAR) );
    }

    //
    //  Construction successful!
    //

    MakeConstructed();

}  // DOMAIN::CtAux


/**********************************************************\

   NAME:       DOMAIN::QueryName

   SYNOPSIS:   query the domain name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created

\**********************************************************/

const TCHAR * DOMAIN::QueryName( VOID ) const
{
    if ( IsUnconstructed())
    {
        DBGEOL(   "DOMAIN::QueryName(): "
               << "Operation applied to unconstructed object" );
        ASSERT( FALSE );
        return NULL;
    }

    return _szDomain;

}  // DOMAIN::QueryName


/**********************************************************\

   NAME:       DOMAIN::GetInfo

   SYNOPSIS:   get information about the domain

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created
        CongpaY         18-Aug-1992     Add GetAnyDC.

\**********************************************************/

APIERR DOMAIN::GetInfo( VOID )
{
    if ( IsUnconstructed())
    {
        DBGEOL(   "DOMAIN::GetInfo(): "
               << "Operation applied to unconstructed object" );
        ASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }

    // Validate the name
    if (ValidateName() != NERR_Success)
    {
        return (ERROR_INVALID_PARAMETER) ;
    }

    //  Make object invalid until proven differently
    MakeInvalid();

    APIERR err;
    NLS_STR nlsDC;
    if ((err = nlsDC.QueryError()) != NERR_Success)
        return err;

    if (_fBackupDCsOK)
    {
        err = DOMAIN::GetAnyValidDC(_szServer,
                               _szDomain,
                               &nlsDC);
        if (err != NERR_Success)
            return err;

        strcpy(_szDC, nlsDC);
    }
    else
    {
        TCHAR * pszPDC = NULL;
        err = ::MNetGetDCName( _szServer,
                               _szDomain,
                               (BYTE **)&pszPDC );
        if (err != NERR_Success)
            return err;
        ::strcpyf(_szDC, pszPDC);
        ::MNetApiBufferFree( (BYTE **)&pszPDC);
    }

    MakeValid();

    return err;

}  // DOMAIN::GetInfo


/**********************************************************\

   NAME:       DOMAIN::WriteInfo

   SYNOPSIS:   write information to domain

   ENTRY:

   EXIT:

   NOTES:      not supported

   HISTORY:
        RustanL         08-Jan-1991     Created

\**********************************************************/

APIERR DOMAIN::WriteInfo( VOID )
{
    return ERROR_NOT_SUPPORTED;

}  // DOMAIN::WriteInfo


/**********************************************************\

   NAME:       DOMAIN::QueryPDC

   SYNOPSIS:   query pointer of the domain string

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        RustanL         08-Jan-1991     Created
        CongpaY         18-Aug-1992     Change _pszPDC to _szDC.

\**********************************************************/

const TCHAR * DOMAIN::QueryPDC( VOID ) const
{
    if ( IsUnconstructed() || IsInvalid())
    {
        DBGEOL(   "DOMAIN::QueryPdc(): "
               << "Operation applied to unconstructed or invalid object" );
        ASSERT( FALSE );
        return NULL;
    }

    return _szDC;

}  // DOMAIN::QueryPDC


/**********************************************************\

   NAME:       DOMAIN::QueryAnyDC

   SYNOPSIS:   query pointer of the domain string

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        KeithMo         31-Aug-1992     Created.

\**********************************************************/
const TCHAR * DOMAIN::QueryAnyDC( VOID ) const
{
    //
    //  CODEWORK:  Should we ASSERT if !fBackupDCsOK??
    //

    return QueryPDC();

}  // DOMAIN::QueryAnyDC



/**********************************************************\

   NAME:       DOMAIN::GetAnyValidDC

   SYNOPSIS:   return a PDC or BDC which is known to be available.

   ENTRY:      pszServer points to Server name.
               pszDomain points to Domain name.

   EXIT:       pnlsDC stores a BDC name if there is one available,
               otherwise it stores the PDC name.

   NOTES:      returns error if there isn't any DC available.

   HISTORY:
        thomaspa        14-Oct-1992     Created

\**********************************************************/
APIERR DOMAIN::GetAnyValidDC(const TCHAR * pszServer,
                             const TCHAR * pszDomain,
                             NLS_STR * pnlsDC)
{
    return DOMAIN::GetAnyDCWorker(pszServer,
                                  pszDomain,
                                  pnlsDC,
                                  TRUE);
}



/**********************************************************\

   NAME:       DOMAIN::GetAnyDC

   SYNOPSIS:   return a PDC or BDC without validation

   ENTRY:      pszServer points to Server name.
               pszDomain points to Domain name.

   EXIT:       pnlsDC stores a BDC name if there is one available,
               otherwise it stores the PDC name.

   NOTES:      returns error if there isn't any DC available.

   HISTORY:
        thomaspa        14-Oct-1992     Created

\**********************************************************/
APIERR DOMAIN::GetAnyDC(const TCHAR * pszServer,
                             const TCHAR * pszDomain,
                             NLS_STR * pnlsDC)
{
    return DOMAIN::GetAnyDCWorker(pszServer,
                                  pszDomain,
                                  pnlsDC,
                                  FALSE);
}


/**********************************************************\

   NAME:       DOMAIN::GetAnyDCWorker

   SYNOPSIS:   return a PDC or BDC.

   ENTRY:      pszServer points to Server name.
               pszDomain points to Domain name.

   EXIT:       pnlsDC stores a BDC name if there is one available,
               otherwise it stores the PDC name.

   NOTES:      returns error if there isn't any DC available.

   HISTORY:
        CongpaY         18-Aug-1992     Created
        ChuckC          30-Sep-1992     Fixed to correctly return PDCs
        Thomaspa        14-Oct-1992     Made into worker function, added
                                        validation
        JonN            20-Sep-1993     Now tries NetGetAnyDCName before
                                        resorting to I_NetGetDCList.
        JonN            15-May-1998     Now uses DsGetDCName

\**********************************************************/

APIERR DOMAIN::GetAnyDCWorker( const TCHAR * pszServer,
                               const TCHAR * pszDomain,
                               NLS_STR     * pnlsDC,
                               BOOL          fValidate)
{
    ASSERT( pnlsDC != NULL && pnlsDC->QueryError() == NERR_Success );

    BOOL fFound = FALSE;
    ULONG cDC;
    PUNICODE_STRING punistrDCList = NULL;
    PDOMAIN_CONTROLLER_INFO pdcinfo = NULL;
    APIERR err = NERR_Success;

    if( pszServer && *pszServer == TCH('\0') )
    {
        pszServer = NULL;
    }

    //
    //  Passing in NULL to I_NetGetDCList will cause it to access violate
    //
    if( (pszDomain == NULL) ||
        (*pszDomain == TCH('\0')) )
    {
        DBGEOL( "DOMAIN::GetAnyDCWorker - NULL or empty domain name" );
        return ERROR_INVALID_PARAMETER ;
    }

    /*
     *  First try DsGetDCName
     */

    do {   // false loop

        //
        // If the fValidate flag is set, first try DsGetDCName without
        // DS_FORCE_RECOVERY.  If validation then fails, retry with DS_FORCE_RECOVERY.
        //
        ULONG flags = DS_IS_FLAT_NAME | DS_RETURN_FLAT_NAME;
        if (fValidate)
        {
            // note that we ignore pszServer
            err = (APIERR) DsGetDcNameW(
                NULL,      // IN LPCWSTR ComputerName OPTIONAL,
                pszDomain, // IN LPCWSTR DomainName OPTIONAL,
                NULL,      // IN GUID *DomainGuid OPTIONAL,
                NULL,      // IN LPCWSTR SiteName OPTIONAL,
                flags,     // IN ULONG Flags,
                &pdcinfo ); // OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
            if ( NERR_Success == err )
            {
                if (   NULL == pdcinfo
                    || NULL == pdcinfo->DomainControllerName
                    || TEXT('\0') == pdcinfo->DomainControllerName[0] )
                {
                    ASSERT(FALSE);
                    break;
                }
                if ( DOMAIN::IsValidDC( pdcinfo->DomainControllerName, pszDomain ) )
                {
                    if (   (err = pnlsDC->CopyFrom( pdcinfo->DomainControllerName )) != NERR_Success
                       )
                    {
                        DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                               << "\", \"" << pszDomain
                               << "\" ), CopyFrom error " << err );
                        break;
                    }
                    fFound = TRUE;
                    break;
                }
            }
        } // if (fValidate)

        flags |= DS_FORCE_REDISCOVERY;

        // note that we ignore pszServer
        err = (APIERR) DsGetDcNameW(
            NULL,      // IN LPCWSTR ComputerName OPTIONAL,
            pszDomain, // IN LPCWSTR DomainName OPTIONAL,
            NULL,      // IN GUID *DomainGuid OPTIONAL,
            NULL,      // IN LPCWSTR SiteName OPTIONAL,
            flags,     // IN ULONG Flags,
            &pdcinfo ); // OUT PDOMAIN_CONTROLLER_INFOW *DomainControllerInfo
        if ( NERR_Success == err )
        {
            if (   NULL == pdcinfo
                || NULL == pdcinfo->DomainControllerName
                || TEXT('\0') == pdcinfo->DomainControllerName[0] )
            {
                ASSERT(FALSE);
                break;
            }
            if ( !fValidate || DOMAIN::IsValidDC( pdcinfo->DomainControllerName, pszDomain ) )
            {
                if (   (err = pnlsDC->CopyFrom( pdcinfo->DomainControllerName )) != NERR_Success
                   )
                {
                    DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                           << "\", \"" << pszDomain
                           << "\" ), CopyFrom error " << err );
                    break;
                }
                fFound = TRUE;
                break;
            }
        }

    } while (FALSE); // false loop

    /*
     *  Don't try I_NetGetDCList if DsGetDCName fails
     *  with ERROR_NO_LOGON_SERVERS
     *
     *  Don't ever try to call I_NetGetDCList remotely, it will only
     *  find DCs on the same transport.
     */

    do {        //error breakout.

        if ( fFound )
        {
            TRACEEOL( "DOMAIN::GetAnyDCWorker: skipping I_NetGetDCList" );
            break;
        }
        else if (err == ERROR_NO_LOGON_SERVERS)
        {
            /*
             *  Check whether the target machine is a DC of pszDomain
             */

            TRACEEOL( "DOMAIN::GetAnyDCWorker: checking local machine" );
            if ( DOMAIN::IsValidDC( pszServer, pszDomain ) )
            {
                err = pnlsDC->CopyFrom(pszServer);
                DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                       << "\", \"" << pszDomain
                       << "\" ) returns target machine" );
            }

            /*
             *  There is no point in continuing with I_NetGetDCList
             *  after DsGetDCName returns ERROR_NO_LOGON_SERVERS.
             */
            break;
        }



        if ((err = ::I_NetGetDCList(NULL,
                                    (LPTSTR) pszDomain,
                                    &cDC,
                                    &punistrDCList)) != NERR_Success)
        {
            DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                   << "\", \"" << pszDomain
                   << "\" ), I_NetGetDCList error " << err );
            break;
        }

        if( cDC == 0  ||  punistrDCList == NULL)
        {
            DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                   << "\", \"" << pszDomain
                   << "\" ), I_NetGetDCList found nothing " << err );
            err = NERR_DCNotFound;
            break;
        }

        // GetTickCount() is subject to the granularity of the clock
        // of the system on which it is run.  Shift right to make sure
        // we get an mix of odd and even numbers.

        ULONG i = (::GetTickCount() >> 5) % cDC ;

        ULONG j = i;
        do {
            if ( punistrDCList[j].Length == 0 )
            {
                continue;
            }
            err = pnlsDC -> MapCopyFrom(punistrDCList[j].Buffer,
                                            punistrDCList[j].Length);
            if ( err != NERR_Success )
            {
                DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                       << "\", \"" << pszDomain
                       << "\" ), MapCopyFrom error " << err );
                break;
            }

            if( fValidate &&
                !DOMAIN::IsValidDC( pnlsDC->QueryPch(), pszDomain ) )
            {
                //
                //  Whoops, not a valid DC in the target domain.
                //

                continue;
            }

            fFound = TRUE;
            break;

        } while ( (j = (j + 1) % cDC) != i );

        if ( !fFound )
        {
            err = NERR_DCNotFound;
            DBGEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                   << "\", \"" << pszDomain
                   << "\" ), found nothing " << err );
            break;
        }

    } while (FALSE); // false loop

    if (punistrDCList)
        ::MNetApiBufferFree( (BYTE **)&punistrDCList);

    if (pdcinfo)
        ::NetApiBufferFree( pdcinfo );

    if (fFound)
    {
        TRACEEOL(   "DOMAIN::GetAnyDCWorker( \"" << pszServer
                    << "\", \"" << pszDomain
                    << "\" ), found \"" << *pnlsDC << "\"" );
    }

    return err;

} //GetAnyDCWorker


/**********************************************************\

   NAME:       DOMAIN::IsValidDC

   SYNOPSIS:   Determines if the specified server is the Primary
               or a Backup in the the specified domain.

   ENTRY:      pszServer points to Server name.
               pszDomain points to Domain name.

   RETURNS:    BOOL     - TRUE  if the server is the Primary or
                                a Backup in the domain, and the
                                server was indeed active at some
                                point during this method.
                          FALSE if the server is not available, or
                                is not a member of the domain.

   NOTES:      This is a static method.

   HISTORY:
        KeithMo         12-Jan-1993     Created.

\**********************************************************/

BOOL DOMAIN::IsValidDC( const TCHAR * pszServer,
                        const TCHAR * pszDomain )
{
    BOOL fIsValid = TRUE;       // until proven otherwise...

    //
    //  Establish a NULL session to the target server.
    //

    API_SESSION apisess( pszServer );

    APIERR err = apisess.QueryError();

    if( err == NERR_Success )
    {
        //
        //  NULL session established.  Validate domain membership.
        //

        WKSTA_10 wksta( pszServer );

        err = wksta.GetInfo();

        if( ( err == NERR_Success ) &&
            ::I_MNetComputerNameCompare( pszDomain, wksta.QueryWkstaDomain() ) )
        {
            //
            //  Stale data, DC is no longer a domain member.
            //

            fIsValid = FALSE;
        }
    }

    if( fIsValid && ( err == NERR_Success ) )
    {
        //
        //  DC is a member of the target domain.  Now validate
        //  domain role (Primary or Backup).
        //

        LSA_POLICY policy( pszServer, POLICY_VIEW_LOCAL_INFORMATION );

        LSA_ACCT_DOM_INFO_MEM    lsaadim;
        LSA_PRIMARY_DOM_INFO_MEM lsaprim;

        //
        //  Verify construction.
        //

        err = policy.QueryError();
        err = err ? err : lsaadim.QueryError();
        err = err ? err : lsaprim.QueryError();

        //
        //  Query the primary & account domains.
        //

        err = err ? err : policy.GetAccountDomain( &lsaadim );
        err = err ? err : policy.GetPrimaryDomain( &lsaprim );

        if( err == NERR_Success )
        {
            //
            //  The DC is a Primary or Backup if the account & primary
            //  PSIDs are non-NULL and equal.
            //

            if( ( lsaadim.QueryPSID() == NULL ) ||
                ( lsaprim.QueryPSID() == NULL ) ||
                !EqualSid( lsaadim.QueryPSID(), lsaprim.QueryPSID() ) )
            {
                fIsValid = FALSE;
            }
        }
    }

    return fIsValid && ( err == NERR_Success );

}   // DOMAIN::IsValidDC


/**********************************************************\

   NAME:       DOMAIN::ValidateName

   SYNOPSIS:   validate the domain name

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
           rustanl     23-Mar-1991     Created

\**********************************************************/

APIERR DOMAIN::ValidateName()
{
    /*
     * null case is invalid
     */
    if (_szDomain[0] == TCH('\0'))
        return (ERROR_INVALID_PARAMETER) ;

    /*
     * else insist on valid domain name
     */
    if (::I_MNetNameValidate(NULL, _szDomain, NAMETYPE_DOMAIN, 0L)
        != NERR_Success)
    {
        return (ERROR_INVALID_PARAMETER) ;
    }

    return (NERR_Success) ;
}


/*
 * defines and macros for DC cache manipulation
 */

#define DC_CACHE_EXPIRY 180000
#define DC_CACHE_SIZE   8
#define DC_CACHE_ENTRY_EXPIRED(t_cache, t_current) \
    ( (t_cache == 0) || \
      (t_current < t_cache) || \
      ((t_current - t_cache) > DC_CACHE_EXPIRY) )

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::DOMAIN_WITH_DC_CACHE

   SYNOPSIS:   constructor for the domain with DC cache class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

DOMAIN_WITH_DC_CACHE::DOMAIN_WITH_DC_CACHE( const TCHAR * pchDomain,
                BOOL fBackupDCsOK)
  : DOMAIN(pchDomain, fBackupDCsOK)
{
    ;  // nothing more to do
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::DOMAIN_WITH_DC_CACHE

   SYNOPSIS:   constructor for the domain with DC cache class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

// SPECIAL CAUTION: the pszServer parameter no longer has any effect!
DOMAIN_WITH_DC_CACHE::DOMAIN_WITH_DC_CACHE( const TCHAR * pszServer,
                                const TCHAR * pszDomain,
                                BOOL fBackupDCsOK )
  : DOMAIN( pszServer, pszDomain, fBackupDCsOK )
{
    ;  // nothing more to do
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::~DOMAIN_WITH_DC_CACHE

   SYNOPSIS:   destructor for the domain with DC cache class

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

DOMAIN_WITH_DC_CACHE::~DOMAIN_WITH_DC_CACHE()
{
    ;  // nothing more to do
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::GetInfo

   SYNOPSIS:   the standard GetInfo method.

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::GetInfo( VOID )
{
    if ( IsUnconstructed())
    {
        DBGEOL(   "DOMAIN_WITH_DC_CACHE::GetInfo(): "
               << "Operation applied to unconstructed object" );
        ASSERT( FALSE );
        return ERROR_GEN_FAILURE;
    }

    // Validate the name
    if (ValidateName() != NERR_Success)
    {
        return (ERROR_INVALID_PARAMETER) ;
    }

    //  Make object invalid until proven differently
    MakeInvalid();

    APIERR err;
    NLS_STR nlsDC;
    if ((err = nlsDC.QueryError()) != NERR_Success)
        return err;

    if (_fBackupDCsOK)
    {
        if ( (err = DOMAIN_WITH_DC_CACHE::GetAnyValidDC(_szServer,
                                                        _szDomain,
                                                        &nlsDC) ) )
        {
            return err;
        }

        strcpy(_szDC, nlsDC);
    }
    else
    {
        TCHAR * pszPDC = NULL;

        if (pszPDC = (TCHAR *)FindDcCache(_pPrimaryDcCacheTable,_szDomain))
            ::strcpyf(_szDC, pszPDC);
        else
        {
            err = ::MNetGetDCName( _szServer,
                                   _szDomain,
                                   (BYTE **)&pszPDC );
            if ( err != NERR_Success )
                return err;

            ::strcpyf(_szDC, pszPDC);
            ::MNetApiBufferFree( (BYTE **)&pszPDC);
            (void) AddDcCache( &_pPrimaryDcCacheTable,
                               _szDomain,
                               _szDC) ;
        }

    }

    MakeValid();
    return err;
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::GetAnyDC

   SYNOPSIS:   as DOMAIN::GetAnyDC, except it uses the cache

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        Thomaspa        14-Oct-1992     Created
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::GetAnyDC(const TCHAR * pszServer,
                                      const TCHAR * pszDomain,
                                      NLS_STR * pnlsDC)
{
    return DOMAIN_WITH_DC_CACHE::GetAnyDCWorker( pszServer,
                                                 pszDomain,
                                                 pnlsDC,
                                                 FALSE );
}




/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::GetAnyValidDC

   SYNOPSIS:   as DOMAIN::GetAnyValidDC, except it uses the cache

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        Thomaspa        14-Oct-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::GetAnyValidDC(const TCHAR * pszServer,
                                      const TCHAR * pszDomain,
                                      NLS_STR * pnlsDC)
{
    return DOMAIN_WITH_DC_CACHE::GetAnyDCWorker( pszServer,
                                                 pszDomain,
                                                 pnlsDC,
                                                 TRUE );
}



/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::GetAnyDCWorker

   SYNOPSIS:   as DOMAIN::GetAnyDCWorker, except it uses the cache

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created
        Thomaspa        14-Oct-1992     Made into Worker

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::GetAnyDCWorker(const TCHAR * pszServer,
                                      const TCHAR * pszDomain,
                                      NLS_STR * pnlsDC,
                                      BOOL fValidate)
{
    APIERR err ;
    const TCHAR *pszDC ;

    if (pszDC = FindDcCache(_pAnyDcCacheTable,
                            pszDomain))
    {
        err = pnlsDC->CopyFrom(pszDC) ;
    }
    else
    {
        err = DOMAIN::GetAnyDCWorker(pszServer, pszDomain, pnlsDC, fValidate) ;
        if (err == NERR_Success)
        {
            (void) AddDcCache( &_pAnyDcCacheTable,
                               pszDomain,
                               pnlsDC->QueryPch()) ;
        }
    }

    return err ;
}

#if 0
// Not currently used
/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::FreeDcCache

   SYNOPSIS:   deletes the appropriate Cache

   ENTRY:      ppDcCacheEntry is address of pointer to table to look at.

   EXIT:       the table is freed and contents of ppDcCacheEntry cleared.

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::FreeDcCache(DC_CACHE_ENTRY **ppDcCacheEntry)
{
    if (!ppDcCacheEntry)
        return(ERROR_INVALID_PARAMETER) ;

    ::GlobalFree ( (HGLOBAL) *ppDcCacheEntry) ;
    *ppDcCacheEntry = NULL ;

    return NERR_Success ;
}
#endif

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::ClearDcCache

   SYNOPSIS:   clears the data in the DC cache

   ENTRY:      pDcCacheEntry is pointer to cache table

   EXIT:       all entries in table are null-ed out

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::ClearDcCache(DC_CACHE_ENTRY *pDcCacheEntry)
{
    // nothing to clear
    if (!pDcCacheEntry)
        return(ERROR_INVALID_PARAMETER) ;

    // loop thru and init
    int i ;
    for (i = 0; i < DC_CACHE_SIZE; i++, pDcCacheEntry++)
    {
        pDcCacheEntry->szDomain[0] = TCH('\0') ;
        pDcCacheEntry->szServer[0] = TCH('\0') ;
        pDcCacheEntry->dwTickCount = 0 ;
    }

    return(NERR_Success) ;
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::AddDcCache

   SYNOPSIS:   add a entry to the cache. will allocate the
               cache table if need.

   ENTRY:      ppDcCacheEntry is address of pointer to table.
               of the table is not yet allocated (NULL), we will allocate.
               pszDomain and pszDC are the entries to enter in the cache.

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

APIERR DOMAIN_WITH_DC_CACHE::AddDcCache(DC_CACHE_ENTRY **ppDcCacheEntry,
                  const TCHAR *pszDomain,
                  const TCHAR *pszDC)
{
    // if weird parameters, just ignore. they dont get in cache
    if (!ppDcCacheEntry)
        return ERROR_INVALID_PARAMETER ;
    if (!pszDC || ::strlenf(pszDC) > MAX_PATH)
        return ERROR_INVALID_PARAMETER ;
    if (!pszDomain || ::strlenf(pszDomain) > DNLEN)
        return ERROR_INVALID_PARAMETER ;

    APIERR err = EnterCriticalSection() ;
    if ( err )
        return err ;

    DC_CACHE_ENTRY *pDcCacheEntry = *ppDcCacheEntry ;

    // allocate if need. note its OK not to free this. there is
    // one per process, we can let the system cleanup when
    // the process exits.
    if (pDcCacheEntry == NULL)
    {
        if ( !(pDcCacheEntry = (DC_CACHE_ENTRY *) ::GlobalAlloc( GPTR,
                                    sizeof(DC_CACHE_ENTRY)*DC_CACHE_SIZE) ) )
        {
            LeaveCriticalSection() ;
            return ERROR_NOT_ENOUGH_MEMORY ;
        }
        (void) ClearDcCache(pDcCacheEntry) ;
        *ppDcCacheEntry = pDcCacheEntry ;
    }

    DWORD dwCurrentTicks = ::GetTickCount() ;

    // go thru looking for free entry
    int i ;
    for (i = 0; i < DC_CACHE_SIZE; i++, pDcCacheEntry++)
    {
        // if domain is empty string or time is expired,
        // we can reuse this entry.
        if ( (pDcCacheEntry->szDomain[0] == TCH('\0')) ||
             DC_CACHE_ENTRY_EXPIRED(pDcCacheEntry->dwTickCount,
                                    dwCurrentTicks) )
        {
            // found either an empty or expired entry. lets use it.
            ::strcpyf( pDcCacheEntry->szDomain, pszDomain ) ;
            ::strcpyf( pDcCacheEntry->szServer , pszDC ) ;
            pDcCacheEntry->dwTickCount = dwCurrentTicks ;

            // we're done
            LeaveCriticalSection() ;
            return NERR_Success ;
        }
    }

    // else no free entry. note this is never reported
    // to the user. if this fails, we just dont get the
    // benefits of a cache.
    LeaveCriticalSection() ;
    return(ERROR_NOT_ENOUGH_MEMORY) ;
}

/**********************************************************\

   NAME:       DOMAIN_WITH_DC_CACHE::FindDcCache

   SYNOPSIS:   find a domain the the passed in cache table

   ENTRY:      pDcCacheEntry is pointer to cache.
               pszDomain is the domain whose DC/PDC we wish to lookup.

   EXIT:

   NOTES:

   HISTORY:
        ChuckC          30-Sep-1992     Created

\**********************************************************/

const TCHAR * DOMAIN_WITH_DC_CACHE::FindDcCache(
                        const DC_CACHE_ENTRY *pDcCacheEntry,
                        const TCHAR *pszDomain)
{
    // if weird parameters, just ignore.
    if (!pszDomain || !pszDomain[0])
        return NULL ;

    // if no cache, it aint found
    if (pDcCacheEntry == NULL)
        return NULL ;

    if ( EnterCriticalSection() )
        return NULL ;

    // go thru looking for the entry
    DWORD dwCurrentTicks = ::GetTickCount() ;
    int i ;
    for (i = 0; i < DC_CACHE_SIZE; i++, pDcCacheEntry++)
    {
        if ( !DC_CACHE_ENTRY_EXPIRED(pDcCacheEntry->dwTickCount,
                                     dwCurrentTicks) &&
             !::I_MNetComputerNameCompare( pDcCacheEntry->szDomain, pszDomain ) )
        {
            const TCHAR * pszServer = pDcCacheEntry->szServer ;
            LeaveCriticalSection() ;
            return  pszServer ;
        }
    }

    LeaveCriticalSection() ;

    // not found
    return NULL ;
}

/*******************************************************************

    NAME:       DOMAIN_WITH_DC_CACHE::EnterCriticalSection

    SYNOPSIS:   Locks the cache for lookup or change

    RETURNS:    NERR_Success if the cache was successfully locked

    NOTES:

    HISTORY:
        Johnl   13-Dec-1992     Created

********************************************************************/

APIERR DOMAIN_WITH_DC_CACHE::EnterCriticalSection( void )
{
    APIERR err = NERR_Success ;

    //
    //  Created semaphore protection for the cache table before we start
    //  using the cache
    //
    if ( DOMAIN_WITH_DC_CACHE::_hCacheSema4 == NULL )
    {
        if ( (DOMAIN_WITH_DC_CACHE::_hCacheSema4 = ::CreateSemaphore(
                                                       NULL,
                                                       1,
                                                       1,
                                                       NULL )) == NULL )
        {
            return ::GetLastError() ;
        }
    }

    switch ( WaitForSingleObject( DOMAIN_WITH_DC_CACHE::_hCacheSema4, INFINITE ) )
    {
    case 0:
        break ;

    default:
        err = ::GetLastError() ;
        break ;
    }

    return err ;
}

void DOMAIN_WITH_DC_CACHE::LeaveCriticalSection( void )
{
    REQUIRE( ReleaseSemaphore( DOMAIN_WITH_DC_CACHE::_hCacheSema4, 1, NULL ) ) ;
}


DC_CACHE_ENTRY * DOMAIN_WITH_DC_CACHE::_pAnyDcCacheTable = NULL ;

DC_CACHE_ENTRY * DOMAIN_WITH_DC_CACHE::_pPrimaryDcCacheTable = NULL ;

HANDLE DOMAIN_WITH_DC_CACHE::_hCacheSema4 = NULL ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmoloc.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990, 1991          **/
/**********************************************************************/

/*  HISTORY:
 *      gregj   5/21/91         Removed from USER for general use
 *      gregj   5/22/91         Added LOCATION_TYPE constructor
 *      rustanl 6/14/91         Inherit from LM_OBJ
 *      rustanl 7/01/91         Code review changes from code review
 *                              attended by TerryK, JonN, o-SimoP, RustanL.
 *                              Main change:  inherit from BASE.
 *      rustanl 7/15/91         Code review changes from code review
 *                              attended by ChuckC, Hui-LiCh, TerryK, RustanL.
 *      jonn    7/26/91         added Set(const LOCATION & loc);
 *      terryk  10/7/91         type changes for NT
 *      KeithMo 10/8/91         Now includes LMOBJP.HXX.
 *      terryk  10/17/91        WIN 32 conversion
 *      terryk  10/21/91        WIN 32 conversion part 2
 *      Yi-HsinS 1/24/92        Check if the workstation service is started.
 *      jonn    4/21/92         Added LOCATION_NT_TYPE to CheckIfNT()
 *      Yi-HsinS 5/13/92        Added QueryDisplayName
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


/* These define the starting level of the NOS for NT.  All versions greater
 * or equal to this are assumed to be NT.
 */
#define NT_NOS_MAJOR_VER    3
#define NT_NOS_MINOR_VER    0

/*******************************************************************

    NAME:       LOCATION::LOCATION

    SYNOPSIS:   constructor for the LOCATION object

    ENTRY:      pszLocation -   server or domain name to validate;
                                NULL or "" means the local computer;
                                default is NULL.

                loctype -       type of local location, local computer
                                or logon domain

                loc -           LOCATION object to be copied; must be
                                a valid LOCATION object; new object
                                will not refresh information, but rather
                                copies everything verbatim from loc

    EXIT:       Object is constructed

    NOTES:      Validation is not done until Validate() is called.

    HISTORY:
        gregj   5/21/91         Created
        gregj   5/22/91         Added LOCATION_TYPE constructor
        jonn    4/21/92         Added LOCATION_NT_TYPE to CheckIfNT()

********************************************************************/

LOCATION::LOCATION( const TCHAR * pszLocation, BOOL fGetPDC )
    :   CT_NLS_STR( _nlsDomain ),
        CT_NLS_STR( _nlsServer ),
        _loctype( LOC_TYPE_LOCAL ),
        _locnttype( LOC_NT_TYPE_UNKNOWN )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = W_Set( pszLocation, LOC_TYPE_LOCAL, fGetPDC );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOCATION::LOCATION


LOCATION::LOCATION( enum LOCATION_TYPE loctype, BOOL fGetPDC )
    :   CT_NLS_STR( _nlsDomain ),
        CT_NLS_STR( _nlsServer ),
        _loctype( LOC_TYPE_LOCAL ),
        _locnttype( LOC_NT_TYPE_UNKNOWN )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = W_Set( NULL, loctype, fGetPDC );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOCATION::LOCATION


LOCATION::LOCATION( const LOCATION & loc )
    :   CT_NLS_STR( _nlsDomain ),
        CT_NLS_STR( _nlsServer ),
        _loctype( LOC_TYPE_LOCAL ),
        _locnttype( LOC_NT_TYPE_UNKNOWN )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = Set( loc );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOCATION::LOCATION


/*******************************************************************

    NAME:       LOCATION::~LOCATION

    SYNOPSIS:   LOCATION destructor

    HISTORY:
        rustanl     01-Jul-1991     Created

********************************************************************/

LOCATION::~LOCATION()
{
    // nothing else to do

}  // LOCATION::~LOCATION


/*******************************************************************

    NAME:       LOCATION::W_Set

    SYNOPSIS:   Sets the object to have a new value.  "Snaps back"
                to previous value if an error occurs.

    ENTRY:      pszLocation -   Pointer to server or domain name
                loctype -       Location type

                pszLocation and loctype can be one of the following
                combinations:

                pszLocation     loctype                 means
                -----------     -------                 -----
                NULL or empty   LOC_TYPE_LOCAL          use local wksta
                    string
                NULL            LOC_TYPE_LOGONDOMAIN    use logon domain
                \\server        LOC_TYPE_LOCAL          use specified server
                domain          LOC_TYPE_LOCAL         use specified domain


                Note, when pszLocation is non-NULL, loctype must be passed
                in as LOC_TYPE_LOCAL.  The reason is that the constructor
                or Set method that is calling W_Set may have received an
                empty string rather than a \\server or domain string.
                Instead of it doing the checking for empty string or NULL,
                loctype is passed in as LOC_TYPE_LOCAL.  Then, this method
                (whose reason for existence is to provide a common place
                to accomodate all the above cases) can easily treat
                this case along with the others.

                fGetPDC -       BOOL that says whether or not to get the PDC
                                name for the domain passed in, so that
                                subsequent calls to QueryServer will return
                                the PDC name in the event of domains.
                                THIS WAS DONE AS AN OPTIMIZATION SO THAT
                                YOU DON'T HAVE TO HAVE THE OVERHEAD OF
                                NETGETDCNAME.

    EXIT:       Object is set to new value if successful; otherwise,
                object snaps back to the state it was in on entry.

    RETURNS:    An API return code, which is NERR_Success on success.

    NOTES:      This method is always defined--even on objects that were
                not constructed properly.  The reason is that this
                method really reconstructs the object.  Note, if this
                class is subclassed, subclasses must be updated somehow
                as well.  This is currently not accounted for.

    HISTORY:
        rustanl     01-Jul-1991 Created from GetInfo
        beng        22-Nov-1991 Remove STR_OWNERALLOC
        Yi-HsinS    24-Jan-1992 Remove multiple declaration of APIERR err.

********************************************************************/

APIERR LOCATION::W_Set( const TCHAR * pszLocation,
                        enum LOCATION_TYPE loctype,
                        BOOL fGetPDC )
{
    //  Note, QueryError is not called, since this method is valid on both
    //  constructed and unconstructed objects.

    APIERR err = NERR_Success;

    //
    // JonN 3/10/99: Removed use of STACK_NLS_STR,
    // invalid server/domain names can cause us to assert below.
    //
    NLS_STR nlsDomain;
    NLS_STR nlsServer;
    BOOL fLogndomainIsLocal = FALSE;

    if ( loctype == LOC_TYPE_LOGONDOMAIN )
    {
        UIASSERT( pszLocation == NULL );

        WKSTA_10 wksta;
        err = wksta.GetInfo();
        if ( err != NERR_Success )
            return err;

        nlsDomain = wksta.QueryLogonDomain();

#ifdef WIN32

        DWORD cch = MAX_COMPUTERNAME_LENGTH+1;
        BUFFER buf( sizeof(TCHAR)*(cch) );
        if (!buf)
            return buf.QueryError();

        // BUGBUG should have own class
        if ( !::GetComputerName( (LPTSTR)(buf.QueryPtr()),
                                 &cch ))
        {
            DWORD errLast = ::GetLastError();
            DBGEOL(   SZ("NETUI: LOCATION::W_Set: ::GetComputerName() failed with ")
                   << errLast );
            return errLast; // BUGBUG map this?
        }

        TRACEEOL(   SZ("NETUI: LOCATION::W_Set: Comparing ")
                 << wksta.QueryLogonDomain()
                 << SZ(" and ")
                 << (TCHAR *)(buf.QueryPtr()) );

        fLogndomainIsLocal =
                        !::I_MNetComputerNameCompare( wksta.QueryLogonDomain(),
                                                      (TCHAR *)buf.QueryPtr() );
#endif // WIN32

    }
    else
    {
        if ( pszLocation == NULL || pszLocation[ 0 ] == TCH('\0') )
        {
            //  local wksta; nlsDomain and nlsServer are
            //  already set to the correct values
        }
        else
        {
            //  Need to cast pszLocation from const TCHAR * to TCHAR *
            //  in order to create nlsLocation.  To justify this,
            //  nlsLocation is declared as a const object.
            const ALIAS_STR nlsLocation( pszLocation );
            ISTR istr( nlsLocation );

            if ( nlsLocation.QueryChar(   istr ) == TCH('\\') &&
                 nlsLocation.QueryChar( ++istr ) == TCH('\\') &&
                 nlsLocation.QueryChar( ++istr ) != TCH('\0') )
            {
                err = ::I_MNetNameValidate( NULL,
                                            nlsLocation.QueryPch(istr),
                                            NAMETYPE_COMPUTER, 0L );
                if ( err != NERR_Success )
                {
                    UIDEBUG( SZ("LOCATION::W_Set given invalid server name") );
                    return err;
                }

                //  nlsLocation is a valid server name, prepended with two
                //  backslashes
                nlsServer = nlsLocation;
            }
            else
            {
                //  pszLocation does not start with two backslashes followed
                //  by at least one more character.  Attempt to validate as
                //  domain name.
                err = ::I_MNetNameValidate( NULL, pszLocation,
                                            NAMETYPE_DOMAIN, 0L );
                if ( err != NERR_Success )
                {
                    UIDEBUG( SZ("LOCATION::W_Set given invalid domain name") );
                    return err;
                }

                //  pszLocation is a domain name
                nlsDomain = pszLocation;
            }
        }
    }


    /*  Nothing should have been assigned to nlsServer or nlsDomain that
     *  would have caused an error.
     */

    UIASSERT( nlsServer.QueryError() == NERR_Success );
    UIASSERT( nlsDomain.QueryError() == NERR_Success );


    if ( fGetPDC )
    {
        /*      If domain is filled in, fill in the server field, too  */

        if ( nlsDomain.strlen() > 0 )
        {
            if (fLogndomainIsLocal)
            {
                nlsServer = SZ("\\\\");
                nlsServer += nlsDomain;
            }
            else
            {
                //  The above should not have assigned nlsServer
                UIASSERT( nlsServer.strlen() == 0 );

                DOMAIN domain( nlsDomain.QueryPch());
                err = domain.GetInfo();
                if ( err != NERR_Success )
                    return err;

                nlsServer = domain.QueryPDC();
            }
        }
    }


    /*  At this time, nlsServer, nlsDomain, and loctype contain the
     *  value that we want to set to the private data members of the
     *  LOCATION object.
     */
    _nlsDomain     = nlsDomain;
    _nlsServer     = nlsServer;
    _loctype       = loctype;
    _locnttype     = LOC_NT_TYPE_UNKNOWN; // we do not know this anymore
    _uiNOSMajorVer = 0 ;
    _uiNOSMinorVer = 0 ;

    /*  _nlsDomain and _nlsServer should be big enough to hold a domain
     *  and server name, respectively.
     */
    UIASSERT( _nlsDomain.QueryError() == NERR_Success );
    UIASSERT( _nlsServer.QueryError() == NERR_Success );

    /*  If the object had not constructed properly until this call,
     *  report success as the 'error'.
     */
    if ( QueryError() != NERR_Success )
        ReportError( NERR_Success );

    return NERR_Success;

}  // LOCATION::W_Set


/*******************************************************************

    NAME:       LOCATION::Set

    SYNOPSIS:   This form of Set simply copies an existing LOCATION
                object.

    ENTRY:      loc -           an existing LOCATION object which
                                should not be in an error state

    EXIT:       Object is set to new value if successful; otherwise,
                object remains in the state it was in on entry.

    RETURNS:    An API return code, which is NERR_Success on success.

    HISTORY:
        jonn        26-Jul-1991     Created

********************************************************************/

APIERR LOCATION::Set( const LOCATION & loc )
{
    //  Note, QueryError is not called, since this method is valid on both
    //  constructed and unconstructed objects.


    if ( loc.QueryError() != NERR_Success )
    {
        UIASSERT( !SZ("Attempted LOCATION::Set from bad LOCATION object") );
        return ERROR_INVALID_PARAMETER;
    }

    _nlsDomain     = loc._nlsDomain;
    _nlsServer     = loc._nlsServer;
    _loctype       = loc._loctype;
    _locnttype     = loc._locnttype;
    _uiNOSMajorVer = loc._uiNOSMajorVer ;
    _uiNOSMinorVer = loc._uiNOSMinorVer ;

    UIASSERT( _nlsDomain.QueryError() == NERR_Success );
    UIASSERT( _nlsServer.QueryError() == NERR_Success );

    /*  If the object had not constructed properly until this call,
     *  report success as the 'error'.
     */
    if ( QueryError() != NERR_Success )
        ReportError( NERR_Success );

    return NERR_Success;

}  // LOCATION::Set

/*******************************************************************

    NAME:       LOCATION::CheckIfNT

    SYNOPSIS:   Sets the passed bool to TRUE if the location this location
                object is "pointing" at is an NT machine.  If we are pointing
                at a domain, then the PDC of the domain is checked.

    ENTRY:      pfIsNT - Pointer to BOOL that will be set if NERR_Success
                    is returned.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      If we are pointing at a domain, then this method checks
                the PDC of the domain.

                This method assumes that the NT NOS (Network OS) can be
                determined by its major version (i.e., NOSs > 3.x are
                NT only).  This is easy to rectify if this isn't the case.

    HISTORY:
        Johnl   15-Nov-1991     Created

********************************************************************/

APIERR LOCATION::CheckIfNT( BOOL * pfIsNT )
{
    ASSERT( pfIsNT != NULL );

    if ( QueryError() )
        return QueryError() ;

    APIERR err ;
    if ( err = QueryNOSVersion( &_uiNOSMajorVer, &_uiNOSMinorVer ) )
        return err ;

    *pfIsNT = _uiNOSMajorVer >= NT_NOS_MAJOR_VER ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       LOCATION::QueryNOSVersion

    SYNOPSIS:   Gets the Network Operating System version number

    ENTRY:      puiVersMajor - pointer to UINT that will receive the major NOS version
                puiVersMinor - pointer to UINT that will receive the minor NOS version

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      It is safe to call this method passing in the
                _uiNOSMajorVer and _uiNOSMinorVer private members
                as parameters.

                This method will also retrieve the version number of a
                domain by retrieving the version number of the PDC.

    HISTORY:
        Johnl   02-Dec-1991     Created
        Yi-HsinS24-Jan-1992     Check version number of local machine without
                                having the workstaiton started

********************************************************************/

APIERR LOCATION::QueryNOSVersion( UINT * puiVersMajor, UINT * puiVersMinor )
{
    if ( QueryError() )
        return QueryError() ;

    /* If the version numbers are zero, then we haven't been called
     * yet.
     */
    if ( !_uiNOSMajorVer && !_uiNOSMinorVer )
    {
        /* If this is a domain location and we haven't gotten the PDC, then
         * get it.
         */
        if ( IsDomain() && _nlsServer.strlen() == 0 )
        {
            DOMAIN domain( QueryDomain() );
            APIERR err = domain.GetInfo();
            if ( err != NERR_Success )
                return err;

            _nlsServer = domain.QueryPDC();
            if ( _nlsServer.QueryError() )
                return _nlsServer.QueryError() ;
        }

#if defined(WIN32)
        if ( _nlsServer.strlen() != 0 )
        {
#endif
            SERVER_1 srv1( QueryServer() ) ;
            APIERR err = srv1.GetInfo();

            // BUGBUG : Have to check for specific error. Will wait
            //          till API maps the error from RPC
            if ( err != NERR_Success )
            {
                WKSTA_10 wksta( QueryServer() );
                err = wksta.GetInfo();
                switch (err)
                {
                case NERR_Success:
                    _uiNOSMajorVer = (UINT) wksta.QueryMajorVer();
                    _uiNOSMinorVer = (UINT) wksta.QueryMinorVer();
                    break;
#if defined(WIN32)
                case NERR_WkstaNotStarted:
                case NERR_NetNotStarted:
                    _uiNOSMajorVer = NT_NOS_MAJOR_VER;
                    _uiNOSMinorVer = NT_NOS_MINOR_VER;
                    break;

                default:
                    return err;
#endif
                }
            }
            else
            {
                _uiNOSMajorVer = (UINT) srv1.QueryMajorVer();
                _uiNOSMinorVer = (UINT) srv1.QueryMinorVer();
            }

#if defined(WIN32)
        }
        else
        {

            // BUGBUG: Not safe on 16 bit side.

            _uiNOSMajorVer = NT_NOS_MAJOR_VER;
            _uiNOSMinorVer = NT_NOS_MINOR_VER;
        }
#endif
    }

    *puiVersMajor = _uiNOSMajorVer ;
    *puiVersMinor = _uiNOSMinorVer ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       LOCATION::IsDomain

    SYNOPSIS:   Returns TRUE if the current location was constructed
                as a domain

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        Johnl       31-May-1991     Created
        rustanl     01-Jul-1991     Call QueryError (no longer IsValid())

********************************************************************/

BOOL LOCATION::IsDomain( VOID ) const
{
    UIASSERT( QueryError() == NERR_Success );

    return ( _nlsDomain.strlen() > 0 );

}  // LOCATION::IsDomain


/*******************************************************************

    NAME:       LOCATION::IsServer

    SYNOPSIS:   Returns TRUE if the current location was constructed
                as a server

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        rustanl     15-Jul-1991     Code review change:  move to .cxx file

********************************************************************/

BOOL LOCATION::IsServer( VOID ) const
{
    UIASSERT( QueryError() == NERR_Success );

    return ( ! IsDomain());

}  // LOCATION::IsServer


/*******************************************************************

    NAME:       LOCATION::QueryServer

    SYNOPSIS:   Returns the server name of the location.

    RETURNS:    The server name of the location.  This server name
                is the given one, if the object was constructed with
                a server name (or NULL if local wksta was specified),
                or the PDC of the domain, if the object was constructed
                specifying a domain.

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        rustanl     14-Jun-1991     Clarified behavior
        rustanl     01-Jul-1991     Changed to use _nlsServer

********************************************************************/

const TCHAR * LOCATION::QueryServer( VOID ) const
{
    UIASSERT( QueryError() == NERR_Success );

    if ( _nlsServer.strlen() == 0 )
        return NULL;        // return NULL rather than empty string

    return _nlsServer.QueryPch();

}  // LOCATION::QueryServer


/*******************************************************************

    NAME:       LOCATION::QueryDomain

    SYNOPSIS:   Returns the domain name of the location

    RETURNS:    The domain name of the location, if it was constructed
                specifying a domain, or NULL otherwise.

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        rustanl     14-Jun-1991     Clarified behavior

********************************************************************/

const TCHAR * LOCATION::QueryDomain() const
{
    UIASSERT( QueryError() == NERR_Success );

    if ( _nlsDomain.strlen() == 0 )
        return NULL;        // return NULL rather than empty string

    return _nlsDomain.QueryPch();

}  // LOCATION::QueryDomain


/*******************************************************************

    NAME:       LOCATION::QueryName

    SYNOPSIS:   Returns the name of the location

    RETURNS:    The name passed in to specify the location.  It is:
                    NULL                if local wksta was specified
                    the server name     if one was passed in
                    domain name         if one was specified

    NOTES:      Asserts out under DEBUG if object was not constructed
                properly.

    HISTORY:
        rustanl     14-Jun-1991     Created

********************************************************************/

const TCHAR * LOCATION::QueryName( VOID ) const
{
    UIASSERT( QueryError() == NERR_Success );

    if ( IsDomain())
        return QueryDomain();

    return QueryServer();

}  // LOCATION::QueryName

/*******************************************************************

    NAME:       LOCATION::QueryDisplayName

    SYNOPSIS:   Returns the display name of the location

    RETURNS:    The name passed in to specify the location.  It is:
                    NULL                if local wksta was specified
                    the server name     if one was passed in
                    domain name         if one was specified

    NOTES:      This does not depend on the workstation or server
                service being started.

    HISTORY:
        Yi-HsinS     20-May-1991     Created

********************************************************************/

APIERR LOCATION::QueryDisplayName( NLS_STR *pnls ) const
{
    UIASSERT( QueryError() == NERR_Success );

    APIERR err = NERR_Success;

    if ( IsDomain())
    {
        *pnls = QueryDomain();
    }
    else
    {
        if ( _nlsServer.QueryTextLength() != 0 )
        {
            *pnls = QueryServer();
        }
        else
        {
            TCHAR pszServer[ MAX_COMPUTERNAME_LENGTH+1 ];
            DWORD dwLength = sizeof(pszServer) / sizeof(TCHAR);

            if ( ::GetComputerName( pszServer, &dwLength ) )
            {
                *pnls = SZ("\\\\");
                err = pnls->Append( pszServer );
            }
            else
            {
                err = ::GetLastError();
            }
        }
    }


    return ( err? err : pnls->QueryError() );

}  // LOCATION::QueryDisplayName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmomemb.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmomemb.cxx
    MEMBERSHIP_LM_OBJ class implementation


    FILE HISTORY:
        rustanl     20-Aug-1991     Created
        KeithMo     08-Oct-1991     Now includes LMOBJP.HXX.
        jonn        14-Oct-1991     Added GROUP_MEMB::SetName, I_CreateNew
        terryk      17-Oct-1991     WIN 32 conversion
        terryk      21-Oct-1991     cast _pBuffer variable to TCHAR *
        o-SimoP     12-Dec-1991     Create/ChangeToNew rips off any
                                    user priv group
        jonn        07-Jun-1992     Added _slAddedNames to MEMBERSHIP_LM_OBJ
*/

#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::ENUM_CALLER_LM_OBJ

    SYNOPSIS:   ENUM_CALLER_LM_OBJ constructor

    ENTRY:      loc -       Location at which all network operations
                            will take place

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

ENUM_CALLER_LM_OBJ::ENUM_CALLER_LM_OBJ( const LOCATION & loc )
  : LOC_LM_OBJ( loc ),
    ENUM_CALLER()
{
    if ( QueryError() != NERR_Success )
        return;

}  // ENUM_CALLER_LM_OBJ::ENUM_CALLER_LM_OBJ


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::EC_QueryBufferPtr

    SYNOPSIS:   Returns the pointer to the buffer used in the API
                calls

    RETURNS:    Pointer to said buffer area

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

BYTE * ENUM_CALLER_LM_OBJ::EC_QueryBufferPtr() const
{
    return (BYTE *)QueryBufferPtr();

}  // ENUM_CALLER_LM_OBJ::EC_QueryBufferPtr

APIERR ENUM_CALLER_LM_OBJ::EC_SetBufferPtr( BYTE * pBuffer )
{
    SetBufferPtr( pBuffer );
    // BUGBUG
    // need to set the size here
    return NERR_Success;
}


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::EC_QueryBufferSize

    SYNOPSIS:   Returns the size of the buffer used in the API calls.

    RETURNS:    The said size

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

UINT ENUM_CALLER_LM_OBJ::EC_QueryBufferSize() const
{
    return QueryBufferSize();

}  // ENUM_CALLER_LM_OBJ::EC_QueryBufferSize


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::EC_ResizeBuffer

    SYNOPSIS:   Resizes the buffer used in API calls

    ENTRY:      cbNewRequestedSize -    Requested new buffer size

    EXIT:       On success, buffer will be able to store
                cbNewRequestedSize bytes
                On failure, buffer will not have changed

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR ENUM_CALLER_LM_OBJ::EC_ResizeBuffer( UINT cNewRequestedSize )
{
    return ResizeBuffer( cNewRequestedSize );

}  // ENUM_CALLER_LM_OBJ::EC_ResizeBuffer


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::W_CreateNew

    SYNOPSIS:   Sets up shadow members for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created
        jonn        05-Sep-1991     Changed from I_CreateNew

********************************************************************/

APIERR ENUM_CALLER_LM_OBJ::W_CreateNew()
{
    SetCount( 0 );

    return NERR_Success;

}  // ENUM_CALLER_LM_OBJ::W_CreateNew


/*******************************************************************

    NAME:       ENUM_CALLER_LM_OBJ::W_CloneFrom

    SYNOPSIS:   Creates this ENUM_CALLER_LM_OBJ object from another one

    ENTRY:      eclmobj -   Source of clone operation

    EXIT:       On success, *this will be a clone of eclmobj

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     22-Aug-1991     Created

********************************************************************/

APIERR ENUM_CALLER_LM_OBJ::W_CloneFrom( const ENUM_CALLER_LM_OBJ & eclmobj )
{
    APIERR err = LOC_LM_OBJ::W_CloneFrom( eclmobj );
    if ( err != NERR_Success )
        return err;

    SetCount( eclmobj.QueryCount());

    return NERR_Success;

}  // ENUM_CALLER_LM_OBJ::W_CloneFrom


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::MEMBERSHIP_LM_OBJ

    SYNOPSIS:   MEMBERSHIP_LM_OBJ constructor

    ENTRY:      loc -               Location at which network operations
                                    will take place
                usAssocNameType -   NAMETYPE_ value of associated items

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

MEMBERSHIP_LM_OBJ::MEMBERSHIP_LM_OBJ( const LOCATION & loc,
                                      UINT             uAssocNameType )
  : ENUM_CALLER_LM_OBJ( loc ),
    _uAssocNameType( uAssocNameType )
{
    if ( QueryError() != NERR_Success )
        return;

    //  This class supports groups and users

    UIASSERT( _uAssocNameType == NAMETYPE_GROUP ||
              _uAssocNameType == NAMETYPE_USER     );

}  // MEMBERSHIP_LM_OBJ::MEMBERSHIP_LM_OBJ


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::I_WriteNew

    SYNOPSIS:   Creates a new membership object

    RETURNS:    An API return code, which is NERR_Success on success

    NOTES:      It is assumed that write new is the same as
                write info.  If this proves to be an invalid assumption
                in the future, subclasses can always override this.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::I_WriteNew()
{
    return I_WriteInfo();

}  // MEMBERSHIP_LM_OBJ::I_WriteNew


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::I_GetInfo

    SYNOPSIS:   Gets membership information from the network

    RETURNS:    An API error value, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::I_GetInfo()
{
    return W_GetInfo();

}  // MEMBERSHIP_LM_OBJ::I_GetInfo


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::QueryItemSize

    SYNOPSIS:   Returns the size of an enumeration item

    RETURNS:    Size of said item

    NOTES:      This method assumes that the user_info_0 and
                group_info_0 structures are the only structures
                that subclasses will ever use.  Moreoever, it
                assumes that these structures have the same
                size and format.  This is true today (8/21/91).
                It this will no longer stay true in the future,
                this class needs to be rewritten, most easily
                accomplished by simply making appropriate methods
                virtual and replacing them in subclasses.

                See also note in class declaration header.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

UINT MEMBERSHIP_LM_OBJ::QueryItemSize() const
{
    //  CODEWORK.  Could do some more checks here.  For example,
    //  davidhov's data member offset macro could be used.  Also,
    //  it would be nice if these tests were made at compile-time
    //  rather than at run-time.
    UIASSERT( sizeof( struct user_info_0 ) == sizeof( struct group_info_0 ));

    return sizeof( struct user_info_0 );

}  // MEMBERSHIP_LM_OBJ::QueryItemSize


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::QueryAssocName

    SYNOPSIS:   Returns the name of a particular associated item

    ENTRY:      i -     Valid index of item whose name is to be
                        retured

    RETURNS:    Pointer to name of specified item

    NOTES:      See note on assumptions in MEMBERSHIP_LM_OBJ::QueryItemSize
                method header.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

const TCHAR * MEMBERSHIP_LM_OBJ::QueryAssocName( UINT i ) const
{
    UIASSERT( i <= QueryCount());

    struct user_info_0 * puiBase = (struct user_info_0 *)QueryBufferPtr();
    return puiBase[ i ].usri0_name;

}  // MEMBERSHIP_LM_OBJ::QueryAssocName


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::FindAssocName

    SYNOPSIS:   Finds a particular associated name

    ENTRY:      pszName -       Pointer to associated name to be
                                found
                pi -            Pointer to location where the index
                                of the found item should be placed.
                                *pi will only be valid when this
                                method returns TRUE

    EXIT:       On success, *pi will be the lowest index of an item with
                the given name.

    RETURNS:    TRUE if an item was found; FALSE otherwise

    NOTES:      See note on assumptions in MEMBERSHIP_LM_OBJ::QueryItemSize
                method header.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

BOOL MEMBERSHIP_LM_OBJ::FindAssocName( const TCHAR * pszName, UINT * pi )
{
    UIASSERT( pi != NULL );

    struct user_info_0 * pui = (struct user_info_0 *)QueryBufferPtr();

    for ( UINT i = 0; i < QueryCount(); i++, pui++ )
    {
        if ( ::I_MNetNameCompare( NULL,
                               pszName,
                               pui->usri0_name,
                               _uAssocNameType,
                               0L ) == NERR_Success )
        {
            *pi = i;
            return TRUE;    // found
        }
    }

    return FALSE;           // not found

}  // MEMBERSHIP_LM_OBJ::FindAssocName


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::AddAssocName

    SYNOPSIS:   Adds an associated name

    ENTRY:      pszName -       Name to be added

    EXIT:       On success, item is added.  On failure, object is
                unchanged.

    RETURNS:    An API return code, which is NERR_Success on success

    NOTES:      See note on assumptions in MEMBERSHIP_LM_OBJ::QueryItemSize
                method header.

                Under Win32, the new user_info_0 may step on memory used
                by a string to which some other user_info_0 points.
                Therefore, we move all strings out of the buffer and
                into the STRLIST before proceeding.  We also place the
                new string in the STRLIST.

    HISTORY:
        rustanl     21-Aug-1991     Created
        jonn        07-Jun-1992     Added _slAddedNames to MEMBERSHIP_LM_OBJ

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::AddAssocName( const TCHAR * pszName )
{
    APIERR err = ::I_MNetNameValidate( NULL, pszName, _uAssocNameType, 0L );
    if ( err != NERR_Success )
    {
        DBGEOL( "MEMBERSHIP_LM_OBJ::AddAssocName: given invalid name " << err );
        return err;
    }

    INT cNewTotal = QueryCount() + 1;

    UIASSERT( QueryBufferSize() >= QueryCount() * QueryItemSize());

#ifdef WIN32

    struct user_info_0 * puiBaseOld = (struct user_info_0 *)QueryBufferPtr();

    BYTE * pbBegin = QueryBufferPtr();
    BYTE * pbEnd   = pbBegin + QueryBufferSize();
    INT i;
    for (i = 0; i < (INT)QueryCount(); i++)
    {
        const TCHAR * pchAssocName = QueryAssocName(i);
        if ( ((BYTE *)pchAssocName >= pbBegin) && ((BYTE *)pchAssocName < pbEnd) )
        {
            // CODEWORK should clean this repeated code into a method
            NLS_STR * pnls = new NLS_STR( pchAssocName );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   pnls == NULL
                || (err = pnls->QueryError()) != NERR_Success
                || (err = _slAddedNames.Add( pnls )) != NERR_Success
               )
            {
               delete pnls;
               return err;
            }
            puiBaseOld[ i ].usri0_name = (TCHAR *)(pnls->QueryPch());
        }
    }

#endif // WIN32

    err = ResizeBuffer( cNewTotal * QueryItemSize());
    if ( err != NERR_Success )
        return err;

    struct user_info_0 * puiBaseNew = (struct user_info_0 *)QueryBufferPtr();


#ifdef WIN32

    NLS_STR * pnls = new NLS_STR( pszName );
    err = ERROR_NOT_ENOUGH_MEMORY;
    if (   pnls == NULL
        || (err = pnls->QueryError()) != NERR_Success
        || (err = _slAddedNames.Add( pnls )) != NERR_Success
       )
    {
       delete pnls;
       return err;
    }
    puiBaseNew[ QueryCount() ].usri0_name = (TCHAR *)(pnls->QueryPch());

#else // WIN32

    COPYTOARRAY( puiBaseNew[ QueryCount() ].usri0_name, (TCHAR *)pszName );

#endif // WIN32


    SetCount( cNewTotal );

    return NERR_Success;

}  // MEMBERSHIP_LM_OBJ::AddAssocName


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::DeleteAssocName

    SYNOPSIS:   Deletes an associated name

    ENTRY:      pszName -       Existing name to be deleted (if more
                                than one exists, the first is deleted)
                    --OR--
                i -             Valid index of item to be deleted

    EXIT:       On success, associated name deleted.  On failure,
                object is unchanged.

    RETURNS:    An API return code, which is NERR_Success on success.

    NOTES:      After the deletion, indices for all items may have
                changed

                These methods assume that the specified item does exist.

                See note on assumptions in MEMBERSHIP_LM_OBJ::QueryItemSize
                method header.

                Under WIN32, we keep the added strings in a STRLIST,
                so that the caller does not have to keep them around.
                At this point, we must check whether the deleted string
                is one that the user added and should thus be removed
                from the array.  JonN 07-Jun-1992

    HISTORY:
        rustanl     21-Aug-1991     Created
        jonn        07-Jun-1992     Added _slAddedNames to MEMBERSHIP_LM_OBJ

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::DeleteAssocName( const TCHAR * pszName )
{
    UINT i;
    REQUIRE( FindAssocName( pszName, &i ));

    return DeleteAssocName( i );

}  // MEMBERSHIP_LM_OBJ::DeleteAssocName


APIERR MEMBERSHIP_LM_OBJ::DeleteAssocName( UINT i )
{
    UIASSERT( i < QueryCount());

    struct user_info_0 * puiBase = (struct user_info_0 *)QueryBufferPtr();
    UIASSERT( puiBase != NULL );

    UINT cNewTotal = QueryCount() - 1;

    struct user_info_0 * puiDel = puiBase + i ;
    struct user_info_0 * puiLast = puiBase + cNewTotal;

#ifdef WIN32

    ITER_STRLIST itersl( _slAddedNames );
    NLS_STR *pnls = NULL;
    while ( (pnls = itersl.Next()) != NULL )
    {
        if ( puiDel->usri0_name == pnls->QueryPch() )
        {
            pnls = _slAddedNames.Remove( itersl );
            delete pnls;
            pnls = NULL;
            break;
        }
    }

#endif

    *puiDel = *puiLast; // copy entire user_info_0 structure

    SetCount( cNewTotal );

    return NERR_Success;

}  // MEMBERSHIP_LM_OBJ::DeleteAssocName


/*******************************************************************

    NAME:       MEMBERSHIP_LM_OBJ::W_CloneFrom

    SYNOPSIS:   Creates this ENUM_CALLER_LM_OBJ object from another one

    ENTRY:      eclmobj -   Source of clone operation

    EXIT:       On success, *this will be a clone of eclmobj

    RETURNS:    An API error, which is NERR_Success on success

                Since the NT variant of these buffers can contain
                internal pointers, we must fix these pointers.
                Also, those pointers which point to elements in the
                STRLIST must point to elements in a copy of the
                STRLIST.

    HISTORY:
        jonn        07-Jun-1992     Created

********************************************************************/

APIERR MEMBERSHIP_LM_OBJ::W_CloneFrom( const MEMBERSHIP_LM_OBJ & memblmobj )
{
    APIERR err = ENUM_CALLER_LM_OBJ::W_CloneFrom( memblmobj );
    if ( err != NERR_Success )
        return err;

#ifdef WIN32

    _slAddedNames.Clear();

    struct user_info_0 * puiBaseNew = (struct user_info_0 *)QueryBufferPtr();

    UINT i;
    for (i = 0; (err == NERR_Success) && (i < QueryCount()); i++)
    {
        BOOL fFixedPointer = FALSE;
        const TCHAR * pchClonedMemb = QueryAssocName( i );
        ITER_STRLIST itersl( *((STRLIST *) & memblmobj._slAddedNames) );
        NLS_STR *pnlsIter = NULL;
        while (   (err == NERR_Success)
               && ((pnlsIter = itersl.Next()) != NULL)
               && (!fFixedPointer)
              )
        {
            if ( pchClonedMemb == pnlsIter->QueryPch() )
            {

                NLS_STR * pnlsNew = new NLS_STR( *pnlsIter );
                err = ERROR_NOT_ENOUGH_MEMORY;
                if (   pnlsNew == NULL
                    || (err = pnlsNew->QueryError()) != NERR_Success
                    || (err = _slAddedNames.Add( pnlsNew )) != NERR_Success
                   )
                {
                    delete pnlsNew;
                    break;
                }

                puiBaseNew[ i ].usri0_name = (TCHAR *)(pnlsNew->QueryPch());

                fFixedPointer = TRUE;
            }
        }

        // If the string was not in the STRLIST, it must be in the buffer.
        // We must patch it.

        if ( (err == NERR_Success) && (!fFixedPointer) )
        {
            FixupPointer( (TCHAR **)&(puiBaseNew[i].usri0_name), &memblmobj );
        }

    }

#endif

    return err;

}  // MEMBERSHIP_LM_OBJ::W_CloneFrom


/*******************************************************************

    NAME:       USER_MEMB::USER_MEMB

    SYNOPSIS:   USER_MEMB constructor

    ENTRY:      loc -           Location at which all network operations
                                will take place

                pszUser -       Pointer to user name, whose group
                                memberships will be revealed by
                                this class

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

USER_MEMB::USER_MEMB( const LOCATION & loc,
                      const TCHAR     * pszUser )
  : MEMBERSHIP_LM_OBJ( loc, NAMETYPE_GROUP ), // 2nd param: ASSOC.-name type
    CT_NLS_STR(_nlsUser)
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _nlsUser.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ( (pszUser != NULL) && (strlenf(pszUser) > 0) )
    {
        err = SetName( pszUser );
        if ( err != NERR_Success )
        {
            ReportError( err );
            return;
        }
    }

}  // USER_MEMB::USER_MEMB


/*******************************************************************

    NAME:       USER_MEMB::~USER_MEMB

    SYNOPSIS:   USER_MEMB destructor

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

USER_MEMB::~USER_MEMB()
{
    // do nothing else

}  // USER_MEMB::~USER_MEMB


/*******************************************************************

    NAME:       USER_MEMB::CallAPI

    SYNOPSIS:   Calls the NetUserGetGroups API to get the groups
                in which the user is a member

    ENTRY:      pBuffer -           Pointer to buffer to be used
                cbBufSize -         Size of buffer pointed to by
                                    pBuffer
                pcEntriesRead -     Pointer to location receiving the
                                    number of entries read

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR USER_MEMB::CallAPI( BYTE ** pBuffer,
                           UINT * pcEntriesRead )
{
    return ::MNetUserGetGroups( QueryServer(),
                               _nlsUser.QueryPch(),
                               0,
                               pBuffer,
                               pcEntriesRead );

}  // USER_MEMB::CallAPI


/*******************************************************************

    NAME:       USER_MEMB::I_WriteInfo

    SYNOPSIS:   Calls NetUserSetGroups to set the group memberships
                of the user

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR USER_MEMB::I_WriteInfo()
{
    return ::MNetUserSetGroups( (TCHAR *)QueryServer(),
                                (TCHAR *)_nlsUser.QueryPch(),
                                0,
                                QueryBufferPtr(),
                                QueryBufferSize(),
                                QueryCount() );

}  // USER_MEMB::I_WriteInfo


/*******************************************************************

    NAME:       USER_MEMB::I_CreateNew

    SYNOPSIS:   Sets up object for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     26-Aug-1991     Created
        o-SimoP     12-Dec-1991     Now new user hasn't any group
********************************************************************/

APIERR USER_MEMB::I_CreateNew()
{
    //  Normally, work is done, and then the parent W_CreateNew is
    //  called.  Here, however, the parent must be called first,
    //  since it will call SetCount.  This method will then make
    //  another call to SetCount to set the count of associated names
    //  appropriately for this class.

    return W_CreateNew();

}  // USER_MEMB::I_CreateNew


/*******************************************************************

    NAME:       USER_MEMB::W_CreateNew

    SYNOPSIS:   Sets up shadow members for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        jonn        05-Sep-1991     Split from I_CreateNew

********************************************************************/

APIERR USER_MEMB::W_CreateNew()
{
    APIERR err = MEMBERSHIP_LM_OBJ::W_CreateNew();
    if ( err != NERR_Success )
        return err;

    err = SetName( NULL );
    if ( err != NERR_Success )
        return err;

    return NERR_Success;

}  // USER_MEMB::W_CreateNew


/**********************************************************\

    NAME:       USER_MEMB::I_ChangeToNew

    SYNOPSIS:   NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
                to NEW status only when a corresponding I_ChangeToNew()
                exists.  The API buffer is the same for new and valid objects,
                so this nethod doesn't have to do much.

    HISTORY:
        JonN        06-Sep-1991     Templated from USER_2
        o-SimoP     12-Dec-1991     Takes a special group away, there
                                    shouldn't be more than one special group
\**********************************************************/

APIERR USER_MEMB::I_ChangeToNew()
{
    UINT i;
    if(    FindAssocName( (TCHAR *)GROUP_SPECIALGRP_USERS, &i )
        || FindAssocName( (TCHAR *)GROUP_SPECIALGRP_ADMINS, &i )
        || FindAssocName( (TCHAR *)GROUP_SPECIALGRP_GUESTS, &i ) )
        DeleteAssocName( i );
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:       USER_MEMB::CloneFrom

    SYNOPSIS:   Clones a USER_MEMB object

    ENTRY:      umemb -         Source of clone operation

    EXIT:       On success, *this is a clone of umemb

    RETURNS:    An API return value, which is NERR_Success on success

    HISTORY:
        rustanl     26-Aug-1991     Created

********************************************************************/

APIERR USER_MEMB::CloneFrom( const USER_MEMB & umemb )
{
    //  This class doesn't have an W_CloneFrom method, so this will
    //  call that of the parent class.

    return W_CloneFrom( umemb );

}  // USER_MEMB::CloneFrom


/*******************************************************************

    NAME:       USER_MEMB::QueryName

    SYNOPSIS:   Returns the account name of a user

    EXIT:       Returns a pointer to the account name

    NOTES:      Valid for objects in CONSTRUCTED state, thus no CHECK_OK

    HISTORY:
        jonn    9/05/91         Templated from USER

********************************************************************/

const TCHAR *USER_MEMB::QueryName() const
{
    return _nlsUser.QueryPch();
}


/*******************************************************************

    NAME:       USER_MEMB::SetName

    SYNOPSIS:   Changes the account name of a user

    ENTRY:      new account name

    EXIT:       Returns an API error code

    HISTORY:
        jonn    9/05/91         Templated from USER

********************************************************************/

APIERR USER_MEMB::SetName( const TCHAR * pszAccount )
{
    if ( (pszAccount != NULL) && (strlenf(pszAccount) > UNLEN) )
        return ERROR_INVALID_PARAMETER;
    else
    {
        if ( (pszAccount != NULL) && ( strlenf(pszAccount) > 0 ) )
        {
            // BUGBUG should return some other error
            APIERR err = ::I_MNetNameValidate( NULL, pszAccount, NAMETYPE_USER, 0L );
            if ( err != NERR_Success )
                return err;
        }

        return _nlsUser.CopyFrom( pszAccount );
    }
}


/*******************************************************************

    NAME:       GROUP_MEMB::GROUP_MEMB

    SYNOPSIS:   GROUP_MEMB constructor

    ENTRY:      loc -           Location at which all network operations
                                will take place

                pszGroup -      Pointer to group name, whose user
                                members will be revealed by
                                this class

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

GROUP_MEMB::GROUP_MEMB( const LOCATION & loc,
                        const TCHAR     * pszGroup )
  : MEMBERSHIP_LM_OBJ( loc, NAMETYPE_USER ), // 2nd param: ASSOC.-name type
    CT_NLS_STR(_nlsGroup)
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _nlsGroup.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    if ( (pszGroup != NULL) && (strlenf(pszGroup) > 0) )
    {
        err = SetName( pszGroup );
        if ( err != NERR_Success )
        {
            ReportError( err );
            return;
        }
    }

}  // GROUP_MEMB::GROUP_MEMB


/*******************************************************************

    NAME:       GROUP_MEMB::~GROUP_MEMB

    SYNOPSIS:   GROUP_MEMB destructor

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

GROUP_MEMB::~GROUP_MEMB()
{
    // do nothing else

}  // GROUP_MEMB::~GROUP_MEMB


/*******************************************************************

    NAME:       GROUP_MEMB::CallAPI

    SYNOPSIS:   Calls the NetGroupGetUsers API to retrieve the group
                members of the group

    ENTRY:      pBuffer -           Pointer to buffer to be used
                pcEntriesRead -     Pointer to location receiving the
                                    number of entries read

    RETURNS:    An API error, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR GROUP_MEMB::CallAPI( BYTE ** pBuffer,
                            UINT * pcEntriesRead )
{
    // BUGBUG pcTotalAvail should not needed to cast
    return ::MNetGroupGetUsers( QueryServer(),
                                _nlsGroup.QueryPch(),
                                0,
                                pBuffer,
                                pcEntriesRead);

}  // GROUP_MEMB::CallAPI


/*******************************************************************

    NAME:       GROUP_MEMB::I_WriteInfo

    SYNOPSIS:   Calls NetGroupSetUsers to set the members of this
                group

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

APIERR GROUP_MEMB::I_WriteInfo()
{
    return ::MNetGroupSetUsers( (TCHAR *)QueryServer(),
                                (TCHAR *)_nlsGroup.QueryPch(),
                                0,
                                QueryBufferPtr(),
                                QueryBufferSize(),
                                QueryCount());

}  // GROUP_MEMB::I_WriteInfo


/*******************************************************************

    NAME:       GROUP_MEMB::I_CreateNew

    SYNOPSIS:   Sets up object for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        JonN        14-Sep-1991     Templated from GROUP_1

********************************************************************/

APIERR GROUP_MEMB::I_CreateNew()
{
    APIERR err = W_CreateNew();
    if ( err != NERR_Success )
        return err;

    return NERR_Success;

}  // GROUP_MEMB::I_CreateNew


/*******************************************************************

    NAME:       GROUP_MEMB::W_CreateNew

    SYNOPSIS:   Sets up shadow members for subsequent WriteNew

    RETURNS:    An API return code, which is NERR_Success on success

    HISTORY:
        JonN        14-Sep-1991     Templated from GROUP_1

********************************************************************/

APIERR GROUP_MEMB::W_CreateNew()
{
    APIERR err = MEMBERSHIP_LM_OBJ::W_CreateNew();
    if ( err != NERR_Success )
        return err;

    err = SetName( NULL );
    if ( err != NERR_Success )
        return err;

    return NERR_Success;

}  // GROUP_MEMB::W_CreateNew


/**********************************************************\

    NAME:       GROUP_MEMB::I_ChangeToNew

    SYNOPSIS:   NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
                to NEW status only when a corresponding I_ChangeToNew()
                exists.  The API buffer is the same for new and valid objects,
                so this nethod doesn't have to do much.

    HISTORY:
        JonN        14-Sep-1991     Templated from GROUP_1

\**********************************************************/

APIERR GROUP_MEMB::I_ChangeToNew()
{
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:       GROUP_MEMB::CloneFrom

    SYNOPSIS:   Clones a GROUP_MEMB object

    ENTRY:      gmemb -         Source of clone operation

    EXIT:       On success, *this is a clone of gmemb

    RETURNS:    An API return value, which is NERR_Success on success

    HISTORY:
        rustanl     26-Aug-1991     Created

********************************************************************/

APIERR GROUP_MEMB::CloneFrom( const GROUP_MEMB & gmemb )
{
    //  This class doesn't have an W_CloneFrom method, so this will
    //  call that of the parent class.

    return W_CloneFrom( gmemb );

}  // GROUP_MEMB::CloneFrom


/*******************************************************************

    NAME:       GROUP_MEMB::QueryName

    SYNOPSIS:   Returns the account name of a group

    EXIT:       Returns a pointer to the account name

    NOTES:      Valid for objects in CONSTRUCTED state, thus no CHECK_OK

    HISTORY:
        jonn    10/11/91        Templated from USER_MEMB

********************************************************************/

const TCHAR *GROUP_MEMB::QueryName() const
{
    return _nlsGroup.QueryPch();
}


/*******************************************************************

    NAME:       GROUP_MEMB::SetName

    SYNOPSIS:   Changes the account name of a group

    ENTRY:      new account name

    EXIT:       Returns an API error code

    HISTORY:
        jonn    10/11/91        Templated from USER_MEMB

********************************************************************/

APIERR GROUP_MEMB::SetName( const TCHAR * pszAccount )
{
    if ( (pszAccount != NULL) && (strlenf(pszAccount) > GNLEN) )
        return ERROR_INVALID_PARAMETER;
    else
    {
        if ( (pszAccount != NULL) && ( strlenf(pszAccount) > 0 ) )
        {
            // BUGBUG should return some other error
            APIERR err = ::I_MNetNameValidate( NULL, pszAccount,
                NAMETYPE_GROUP, 0L );
            if ( err != NERR_Success )
                return err;
        }

        return _nlsGroup.CopyFrom( pszAccount );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmolocrg.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*  HISTORY:
 *      jonn    4/21/92         Added LOCATION_NT_TYPE to CheckIfNT()
 *
 *  This form of CheckIfNT is kept seperate from the smaller form so that
 *  clients which do not need to distinguish between WinNt and LanManNt
 *  will not have to link with the registry APIs.
 */

#include "pchlmobj.hxx"  // Precompiled header

#include "lmow32.hxx"    // ::GetW32ComputerName


#define REGPATH SZ("SYSTEM\\CurrentControlSet\\Control\\ProductOptions")
#define REGKEY  SZ("ProductType")
#define REGVALUE_WINNT SZ("WinNt")
#define REGVALUE_LANMANNT SZ("LanManNt")
#define REGVALUE_SERVERNT SZ("ServerNt")


/*******************************************************************

    NAME:	LOCATION::CheckIfNT

    SYNOPSIS:	Sets the passed bool to TRUE if the location this location
		object is "pointing" at is an NT machine.  If we are pointing
		at a domain, then the PDC of the domain is checked.

    ENTRY:	pfIsNT - Pointer to BOOL that will be set if NERR_Success
		    is returned.

                plocnttype - Pointer to LOCATION_NT_TYPE that will be set
                    if the pointer is not NULL, if the target is an NT
                    machine and if NERR_Success is returned.

    RETURNS:	NERR_Success if successful, error code otherwise.

    NOTES:	If we are pointing at a domain, then this method checks
		the PDC of the domain.

		This method assumes that the NT NOS (Network OS) can be
		determined by its major version (i.e., NOSs > 3.x are
		NT only).  This is easy to rectify if this isn't the case.

    HISTORY:
        JonN    06-May-1992     Enabled registry check

********************************************************************/

APIERR LOCATION::CheckIfNT( BOOL * pfIsNT,
                            enum LOCATION_NT_TYPE * plocnttype )
{
    if ( QueryError() )
	return QueryError() ;

    APIERR err  = CheckIfNT( pfIsNT );
    if ( err != NERR_Success )
        return err;

    if (   (*pfIsNT)
        && (plocnttype != NULL)
        && (_locnttype == LOC_NT_TYPE_UNKNOWN ) )
    {
        REG_KEY * pregkeyRoot = NULL;
        do { // false loop

            //
            // Check whether this is the local machine
            //

            const TCHAR * pchServer = QueryServer();
            BOOL fLocalComputer = (    pchServer == NULL
                                   || *pchServer == TCH('\0') );
            if (!fLocalComputer)
            {
                NLS_STR nlsLocalComputer;
                if (   (err = nlsLocalComputer.QueryError()) != NERR_Success
                    || (err = ::GetW32ComputerName( nlsLocalComputer ))
                                != NERR_Success
                   )
                {
                    DBGEOL(   "LOCATION::CheckIfNT: ::GetW32ComputerName err "
                           << err );
                    break;
                }
                fLocalComputer = !(::I_MNetComputerNameCompare(
                        (LPTSTR)pchServer,
                        nlsLocalComputer.QueryPch() ));
            }

            if (fLocalComputer) {
                pregkeyRoot = new REG_KEY( HKEY_LOCAL_MACHINE );
            } else {
                pregkeyRoot = new REG_KEY( HKEY_LOCAL_MACHINE, pchServer );
            }
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   (pregkeyRoot == NULL)
                || ((err = pregkeyRoot->QueryError()) != NERR_Success)
               )
            {
                DBGEOL(   "LOCATION::CheckIfNT: Could not open pregkeyRoot "
                       << err );
                break;
            }

            ALIAS_STR nlsPath( REGPATH );
            REG_KEY regkeyNode( *pregkeyRoot, nlsPath );
            REG_VALUE_INFO_STRUCT rviStruct;
            BUFFER buf( MAXPATHLEN );

            if (   (err = regkeyNode.QueryError()) != NERR_Success
                || (err = rviStruct.nlsValueName.CopyFrom( REGKEY )) != NERR_Success
                || (err = buf.QueryError()) != NERR_Success
               )
            {
                DBGEOL(   "LOCATION::CheckIfNT: Could not open regkeyNode "
                       << err );
                break;
            }

            rviStruct.ulTitle = 0;
            rviStruct.ulType = 0;
            rviStruct.pwcData = buf.QueryPtr();
            rviStruct.ulDataLength = buf.QuerySize();

            err = regkeyNode.QueryValue( &rviStruct );

            if (err != NERR_Success)
            {
                DBGEOL(   "LOCATION::CheckIfNT: Could not query regkeyNode "
                       << err );
                break;
            }

            if (rviStruct.ulType != REG_SZ)
            {
                DBGEOL(   "LOCATION::CheckIfNT: regkeyNode value bad type "
                       << rviStruct.ulType );
                UIASSERT( FALSE );
                err = ERROR_INVALID_PARAMETER;
                break;
            }

            TCHAR * pchEos = (TCHAR *) (rviStruct.pwcData + rviStruct.ulDataLengthOut);
            *pchEos = TCH('\0');

            TCHAR * pchData = (TCHAR *) rviStruct.pwcData;
            // BUGBUG BUGBUG strings
            if ( !::stricmpf( pchData, REGVALUE_LANMANNT ))
            {
                DBGEOL( "LOCATION::CheckIfNT: focus on LanManNt" );
                _locnttype = LOC_NT_TYPE_LANMANNT;
            }
            else if ( !::stricmpf( pchData, REGVALUE_WINNT ))
            {
                DBGEOL( "LOCATION::CheckIfNT: focus on WinNt" );
                _locnttype = LOC_NT_TYPE_WINDOWSNT;
            }
            else if ( !::stricmpf( pchData, REGVALUE_SERVERNT ))
            {
                DBGEOL( "LOCATION::CheckIfNT: focus on WinNt(Server)" );
                _locnttype = LOC_NT_TYPE_SERVERNT;
            }
#ifdef DEBUG
            else
            {
                DBGEOL(    "LOCATION::CheckIfNT: invalid regkeyNode value "
                        << pchData );
                UIASSERT( FALSE );
                _locnttype = LOC_NT_TYPE_WINDOWSNT;
            }
#endif // DEBUG

        } while (FALSE);

        delete pregkeyRoot;
    }

    if (err == NERR_Success && plocnttype != NULL)
        *plocnttype = _locnttype;

    return err ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmomisc.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    LM_MISC.CXX
	Misc. objects

	LOGON_USER - wrapper class which handles NetWkstaSetUID2() net
	    api call
	TIME_DAY_SERVER - wrapper class which handles NetRemoteTOD() net
	    api
	LM_MESSAGE - wrapper class which handles NetMessageBuffSend()
	    net api

    FILE HISTORY:
	terryk	    6-Sep-91	    Created
	terryk	    11-Sep-91	    Code review changes. Attend: jimh
				    yi-hsins jonn
	terryk	    20-Sep-91	    Move LOGON_USER from lmouser.cxx to here
	terryk	    07-Oct-91	    type changes for NT
	KeithMo	    08-Oct-91	    Now includes LMOBJP.HXX.
	terryk	    17-Oct-91	    WIN 32 conversion
	terryk	    21-Oct-91	    remove LOGON_USER from NT

*/

#include "pchlmobj.hxx"  // Precompiled header


#ifndef WIN32

/*******************************************************************

    NAME:	LOGON_USER::LOGON_USER

    SYNOPSIS:	Constructor for the logon user object.

    ENTRY:	TCHAR * pszUsername - user name
		TCHAR * pszServername

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

LOGON_USER::LOGON_USER( const TCHAR * pszUsername, const TCHAR * pszDomain )
    : BASE( ),
    _state( INVALID_STATE ),
    _fValid( TRUE ),
    _pszPasswd( NULL ),
    _buffer( 0 ),
    _nlsDomain( pszDomain ),
    _nlsUsername( pszUsername )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
    APIERR err;

    if ((( err = _buffer.QueryError()) != NERR_Success ) ||
	(( err = _nlsDomain.QueryError()) != NERR_Success ) ||
	(( err = _nlsUsername.QueryError()) != NERR_Success ))
    {
	UIASSERT( FALSE );
	ReportError( err );
	return;
    }

    // CheckName validation
    if ((( _nlsUsername.strlen() != 0 ) && ( err = ::I_MNetNameValidate(
	NULL, (TCHAR *)_nlsUsername.QueryPch(), NAMETYPE_USER, 0 )) !=
	NERR_Success ))
    {
	UIASSERT( FALSE );
	ReportError( err );
	return;
    }
    if ((( _nlsDomain.strlen() != 0 ) && ( err =
	::I_MNetNameValidate( NULL, (TCHAR *)_nlsDomain.QueryPch(),
	NAMETYPE_DOMAIN, 0 )) != NERR_Success ))
    {
	UIASSERT( FALSE );
	ReportError( err );
	return;
    }
}

// BUGBUG - we need to change it for NT
#define USER_LOGON_INFO_SIZE ( sizeof( struct user_logon_info_1 ) + \
	MAX_PATH + DNLEN + PATHLEN + 3 )

/*******************************************************************

    NAME:	LOGON_USER::Logon

    SYNOPSIS:	Logon the user.

    ENTRY:	TCHAR * pszPasswd
		APIERR *pLogonRetCode - return the logon code within the
		    usr_logoninfo_1 object

    RETURNS:	APIERR - NERR_Success if succeed.

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

APIERR LOGON_USER::Logon( const TCHAR * pszPasswd, APIERR *pLogonRetCode )
{
    UINT cTotalAvail;

    _fValid = FALSE;
    _state = LOGGED_ON;
    APIERR err = ::I_MNetNameValidate( NULL, pszPasswd, NAMETYPE_PASSWORD, 0 );
    if ( err != NERR_Success )
    {
	return NERR_BadPassword;
    }
    _pszPasswd = ( TCHAR * )pszPasswd;
    err = _buffer.Resize( USER_LOGON_INFO_SIZE );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("LOGON_USER error: cannot resize buffer.\n\r") );
	return err;
    }
    err = ::MNetWkstaSetUID( NULL, (TCHAR *)_nlsDomain.QueryPch(),
	(TCHAR *)_nlsUsername.QueryPch(), _pszPasswd, SZ(""), 0, 1,
	_buffer.QueryPtr(), _buffer.QuerySize(), &cTotalAvail );
    *pLogonRetCode = QueryLogonInfo()->usrlog1_code;
    if (( err == NERR_Success ) || ( *pLogonRetCode == NERR_Success ))
    {
	_fValid = TRUE;
    }
    return err;
}

/*******************************************************************

    NAME:	LOGON_USER::Logoff

    SYNOPSIS:	Logoff the user.

    ENTRY:	UINT uslogoff_level - these are 4 level of
		logoff
		WKSTA_NOFORCE - log off the user if the user has no
		    connections to redirected resources. Do not log off if
		    the user has connections.
		WKSTA_FORCE - log off the user with connections to redirected
		    resources. Do not log off if the user has pending
		    activities on redirected resources, or if the user uses
		    the resource as the current drive.
		WKSTA_LOTS_OF_FORCE - log off the user with connections or
		    pending activities on redirected resources. Do not log
		    off if a user process uses the resource as the current
		    drive.
		WKSTA_MAX_FORCE - log off the user under any conditions.
		APIERR *pLogoffRetCode - return code for the
		    usr_logoffInfo_1 object

    RETURNS:	APIERR - NERR_Success if the function encountered no
		errors.

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

APIERR LOGON_USER::Logoff( UINT uslogoff_level, APIERR *pLogoffRetCode )
{
    UINT cTotalAvail;
    APIERR err;

    _state = LOGGED_OFF;
    _fValid = FALSE;
    err = _buffer.Resize( sizeof( struct user_logoff_info_1 ));
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("LOGON_USER error: cannot resize buffer.\n\r") );
	return err;
    }
    err = ::MNetWkstaSetUID( NULL, NULL, NULL, NULL, SZ(""),
	uslogoff_level, 1, _buffer.QueryPtr(),
	_buffer.QuerySize(), &cTotalAvail );
    *pLogoffRetCode = QueryLogoffInfo()->usrlogf1_code;
    if (( err == NERR_Success ) || ( *pLogoffRetCode == NERR_Success ))
    {
	_fValid = TRUE;
    }
    return err;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogonInfo

    SYNOPSIS:	return the user_logon_info_1 struct pointer

    RETURNS:	return the user_logon_info_1 struct pointer

    NOTES:	It will also check the state and see whether the object
		is in logon state or not.

    HISTORY:
		terryk	9-Sep-91	Created

********************************************************************/

struct user_logon_info_1 * LOGON_USER::QueryLogonInfo() const
{
    UIASSERT( _state == LOGGED_ON );
    return  ( struct user_logon_info_1 *) _buffer.QueryPtr();
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogoffInfo

    SYNOPSIS:	return the user_logoff_info_1 struct pointer

    RETURNS:	return the user_logoff_info_1 struct pointer

    NOTES:	It will also check the state and see whether the object
		is in logoff state or not.

    HISTORY:
		terryk	9-Sep-91	Created

********************************************************************/

struct user_logoff_info_1 * LOGON_USER::QueryLogoffInfo() const
{
    UIASSERT( _state == LOGGED_OFF );
    return  ( struct user_logoff_info_1 *) _buffer.QueryPtr();
}

/*******************************************************************

    NAME:	LOGON_USER::QueryPriv

    SYNOPSIS:	return the user's privilege level

    RETURNS:	UINT level.
		   It specifies the user's privilege level. The ACCESS.H
		   header file defines these possible values:
		   CODE			VALUE	MEANING
		   USER_PRIV_GUEST	0	Guest privilege
		   USER_PRIV_USER	1	User privilege
		   USER_PRIV_ADMIN	2	Admin privilege
					10	ERROR

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

UINT LOGON_USER::QueryPriv() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return 10;
    }
    return QueryLogonInfo()->usrlog1_priv;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryPasswdAge

    SYNOPSIS:	return the time since the user password was changed

    RETURNS:	LONG time - the time specifies in seconds
		-1 if the object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

LONG LOGON_USER::QueryPasswdAge() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return -1;
    }
    return QueryLogonInfo()->usrlog1_password_age;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryPasswdCanChange

    SYNOPSIS:	return the specifies time when the user is allowed to
		change the password.

    RETURNS:	ULONG userlog1_pw_can_change. This value is stored as
		the number of seconds elapsed since 00:00:00, January 1, 1970.
		A value of -1 means the user can never change the
		password.
		A value of 0 means object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

ULONG LOGON_USER::QueryPasswdCanChange() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return 0;
    }
    return QueryLogonInfo()->usrlog1_pw_can_change;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryPasswdMustChange

    SYNOPSIS:	return the time when the user must change the password.

    RETURNS:	ULONG userlog1_pw_must_change. This value is stored as
		the number of seconds elapsed since 00:00:00, January 1, 1970.
		A value of 0 means object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

ULONG LOGON_USER::QueryPasswdMustChange() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return 0;
    }
    return QueryLogonInfo()->usrlog1_pw_must_change;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogonComputer

    SYNOPSIS:	return the computer where the user is logged on

    RETURNS:	TCHAR * computer name
		NULL means the object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

const TCHAR * LOGON_USER::QueryLogonComputer() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return NULL;
    }
    return QueryLogonInfo()->usrlog1_computer;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogonDomain

    SYNOPSIS:	return the domain where the user is logged on

    RETURNS:	TCHAR * domain name
		NULL means the object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

const TCHAR * LOGON_USER::QueryLogonDomain() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return NULL;
    }
    return QueryLogonInfo()->usrlog1_domain;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogoffDuration

    SYNOPSIS:	return the logon return code.

    RETURNS:	APIERR err - apierr code. NERR_Success for succeed.
		-1 means the object is in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

ULONG LOGON_USER::QueryLogoffDuration() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return ((ULONG)-1);
    }
    return QueryLogoffInfo()->usrlogf1_duration;
}

/*******************************************************************

    NAME:	LOGON_USER::QueryLogoffNumLogons

    SYNOPSIS:	return the logon return code.

    RETURNS:	APIERR err - apierr code. NERR_Success for succeed.
		0 means the objects in in invalid state

    HISTORY:
		Terryk	9-Sep-91	Created

********************************************************************/

ULONG LOGON_USER::QueryLogoffNumLogons() const
{
    if ( _fValid != TRUE )
    {
	UIASSERT( FALSE );
	return 0;
    }
    return QueryLogoffInfo()->usrlogf1_num_logons;
}

#endif

/*******************************************************************

    NAME:	LM_MESSAGE::LM_MESSAGE

    SYNOPSIS:	message class constructor

    ENTRY:	one of the following parameters
		    enum LOCATION_TYPE loctype;
		    TCHAR * pszLocation;
		    LOCATION & loc;

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

LM_MESSAGE::LM_MESSAGE( enum LOCATION_TYPE loctype )
    : LOC_LM_OBJ( loctype )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

LM_MESSAGE::LM_MESSAGE( const TCHAR * pszLocation )
    : LOC_LM_OBJ( pszLocation )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

LM_MESSAGE::LM_MESSAGE( LOCATION & loc )
    : LOC_LM_OBJ( loc )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

/*******************************************************************

    NAME:	LM_MESSAGE::SendBuffer

    SYNOPSIS:	send a buffer of data to the recipient

    ENTRY:	const TCHAR * pszRecipient
		one of the followings:
		BUFFER & buffer;
		OR
		const TCHAR * pbBuffer;
		UINT cbBufferSize;

    RETURNS:	APIERR - NERR_Success for succeed.

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

APIERR LM_MESSAGE::SendBuffer( const TCHAR * pszRecipient, const BUFFER & buffer )
{
    UIASSERT( buffer.QueryError() == NERR_Success );
    return ::MNetMessageBufferSend( QueryServer(), (TCHAR *)pszRecipient,
	buffer.QueryPtr(), buffer.QuerySize());
}

APIERR LM_MESSAGE::SendBuffer( const TCHAR * pszRecipient, const TCHAR *
    pbBuffer, UINT cbBuffer )
{
    UIASSERT( pbBuffer != NULL );
    return ::MNetMessageBufferSend( QueryServer(), (TCHAR *)pszRecipient,
	(BYTE *)pbBuffer, cbBuffer );
}

/*******************************************************************

    NAME:	TIME_OF_DAY::TIME_OF_DAY

    SYNOPSIS:	constructor. This object will get the server time and
		date information.

    ENTRY:	One of the followings:
		const TCHAR * pszLocation
		enum LOCATION_TYPE loctype
		LOCATION & loc

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

TIME_OF_DAY::TIME_OF_DAY( const TCHAR * pszLocation )
    : LOC_LM_OBJ( pszLocation ),
    _ptodi( NULL )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

TIME_OF_DAY::TIME_OF_DAY( LOCATION & loc )
    : LOC_LM_OBJ( loc ),
    _ptodi( NULL )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

TIME_OF_DAY::TIME_OF_DAY( enum LOCATION_TYPE loctype )
    : LOC_LM_OBJ( loctype ),
    _ptodi( NULL )
{
    if ( QueryError() != NERR_Success )
    {
	return;
    }
}

/*******************************************************************

    NAME:	TIME_OF_DAY::~TIME_OF_DAY

    SYNOPSIS:	destructor - free up the memory

    HISTORY:
		terryk	15-Oct-91	Created

********************************************************************/

TIME_OF_DAY::~TIME_OF_DAY()
{
    ::MNetApiBufferFree( (BYTE **)&_ptodi );
}


/*******************************************************************

    NAME:	TIME_OF_DAY::I_GetInfo

    SYNOPSIS:	Worker function for GetInfo. It will actually set up the
		connection and get the time/day information.

    RETURNS:	APIERR - NERR_Success for succeed

    HISTORY:
		terryk	6-Sep-91	Created

********************************************************************/

APIERR TIME_OF_DAY::I_GetInfo()
{
    ::MNetApiBufferFree( (BYTE **)&_ptodi );

    return ::MNetRemoteTOD( QueryServer(), (BYTE **)&_ptodi );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmomod.cxx ===
/**********************************************************************/
/**           Microsoft LAN Manager                                  **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
 * lmomod.cxx
 *
 * History
 *  o-SimoP 6/12/91     Created
 *  o-SimoP 7/02/91     Code Review changes and
 *                      changes in LOCATION obj
 *  terryk  10/7/91	type changes for NT
 *  KeithMo 10/8/91	Now includes LMOBJP.HXX.
 *  terryk  10/17/91	WIN 32 conversion
 *  terryk  10/21/91	change UINT to USHORT2ULONG
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


/**********************************************************\

   NAME:       USER_MODALS::USER_MODALS

   SYNOPSIS:   constructor for the user_modals class

   ENTRY:      pszDomain - name of domain or server

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

USER_MODALS::USER_MODALS( const TCHAR * pszDomain )
    :   _loc( pszDomain )
{
    if( IsUnconstructed() )
        return;

}  // USER_MODALS::USER_MODALS



/**********************************************************\

   NAME:       USER_MODALS::GetInfo

   SYNOPSIS:   get information about the user_modals

   RETURNS:    An error code, which is NERR_Success on
               success
   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

APIERR USER_MODALS::GetInfo( VOID )
{
    if ( IsUnconstructed() )
    {
        DBGEOL( "USER_MODALS::GetInfo: IsUnconstructed" );
        return ERROR_GEN_FAILURE;
    }

    //  Make object invalid until proven differently
    MakeInvalid();

    APIERR err = _loc.QueryError();
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS::GetInfo: _loc.QueryError error " << err );
        return err;
    }

    user_modals_info_0 *pModals = NULL;
    err = ::MNetUserModalsGet ( _loc.QueryServer(),
            0, (BYTE **)&pModals );
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS::GetInfo: error in NUModalsGet " << err );
	::MNetApiBufferFree( (BYTE **)&pModals );
        return err;
    }

    _uMinPasswdLen  = (UINT)pModals->usrmod0_min_passwd_len;
    _ulMaxPasswdAge = pModals->usrmod0_max_passwd_age;
    _ulMinPasswdAge = pModals->usrmod0_min_passwd_age;
    _ulForceLogoff  = pModals->usrmod0_force_logoff;
    _uPasswdHistLen = (UINT)pModals->usrmod0_password_hist_len;
    ::MNetApiBufferFree( (BYTE **)&pModals );

    MakeValid();

    return NERR_Success;

}  // USER_MODALS::GetInfo


/**********************************************************\

   NAME:       USER_MODALS::WriteInfo

   SYNOPSIS:   Write information about the user_modals

   RETURNS:    An error code, which is NERR_Success on
               success
   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

APIERR USER_MODALS::WriteInfo( VOID )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    if( _ulMinPasswdAge > _ulMaxPasswdAge )
    {
        DBGEOL( "USER_MODALS::WriteInfo: PasswdMinAge > MaxAge" );
        ASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    user_modals_info_0 modals;

    modals.usrmod0_min_passwd_len = _uMinPasswdLen;
    modals.usrmod0_max_passwd_age = _ulMaxPasswdAge;
    modals.usrmod0_min_passwd_age = _ulMinPasswdAge;
    modals.usrmod0_force_logoff = _ulForceLogoff;
    modals.usrmod0_password_hist_len = _uPasswdHistLen;
    // where is this one coming from??
    //modals.usrmod0_lockout_count = 0;

    APIERR err = ::MNetUserModalsSet ( _loc.QueryServer(),
           0, (BYTE *)&modals,
           sizeof( modals ), PARMNUM_ALL );
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS::WriteInfo: error " << err );
    }

    return err;

}  // USER_MODALS::WriteInfo


/**********************************************************\

   NAME:       USER_MODALS::QueryName

   SYNOPSIS:   query the user_modals name

   RETURNS:    if ok returns pointer to name (given in
               constructor).
               otherwise NULL.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

const TCHAR * USER_MODALS::QueryName( VOID ) const
{
    CHECK_VALID( NULL );

    return _loc.QueryName();
}  // USER_MODALS::QueryName



/**********************************************************\

   NAME:       USER_MODALS::QueryMinPasswdLen

   SYNOPSIS:   get information about the min passwd len

   RETURNS:    returns minpasswdlen if ok.
               otherwise -1.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

UINT USER_MODALS::QueryMinPasswdLen( VOID ) const
{
    CHECK_VALID( (UINT)-1 );

    return _uMinPasswdLen;
}  // USER_MODALS::QueryMinPasswdLen



/**********************************************************\

   NAME:       USER_MODALS::QueryMaxPasswdAge

   SYNOPSIS:   get information about the max passwd age

   RETURNS:    maxpasswdage if ok.
               otherwise 0.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

ULONG USER_MODALS::QueryMaxPasswdAge( VOID ) const
{
    CHECK_VALID( 0 );

    return _ulMaxPasswdAge;
}  // USER_MODALS::QueryMaxPasswdAge


/**********************************************************\

   NAME:       USER_MODALS::QueryMinPasswdAge

   SYNOPSIS:   get information about the min passwd age

   RETURNS:    Minpasswdage if ok.
               otherwise -1.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

ULONG USER_MODALS::QueryMinPasswdAge( VOID ) const
{
    CHECK_VALID((ULONG) -1 );

    return _ulMinPasswdAge;
}  // USER_MODALS::QueryMinPasswdAge


/**********************************************************\

   NAME:       USER_MODALS::QueryForceLogoff

   SYNOPSIS:   get information about the force logoff time

   RETURNS:    force logoff time if ok.
               otherwise 0.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

ULONG USER_MODALS::QueryForceLogoff( VOID ) const
{
    CHECK_VALID( 0 );

    return _ulForceLogoff;
}  // USER_MODALS::QueryForceLogoff



/**********************************************************\

   NAME:       USER_MODALS::QueryPasswdHistLen

   SYNOPSIS:   get information about the passwd history lenght

   RETURNS:    passwd history lenght if ok.
               otherwise -1.

   HISTORY:
     o-SimoP    12-Jun-1991 Created

\**********************************************************/

UINT USER_MODALS::QueryPasswdHistLen( VOID ) const
{
    CHECK_VALID( (UINT)-1 );

    return _uPasswdHistLen;
}  // USER_MODALS::QueryPasswdHistLen




/**********************************************************\

   NAME:       USER_MODALS::SetMinPasswdLen

   SYNOPSIS:   set information about the USER_MODALS object

   RETURNS:    ERROR_GEN_FAILURE if USER_MODALS obj not valid
               ERROR_INVALID_PARAM if input param invalid
               NERR_Success if ok.

   HISTORY:
     o-SimoP    13-Jun-1991 Created

\**********************************************************/

APIERR  USER_MODALS::SetMinPasswdLen( UINT uMinLen )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    if( uMinLen > PWLEN )
    {
        DBGEOL( "USER_MODALS::SetMinPasswdLen: uMinLen > PWLEN" );
        ASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    _uMinPasswdLen = uMinLen;
    return NERR_Success;

} // USER_MODALS::SetMinPasswdLen


/**********************************************************\

    NAME:       USER_MODALS::SetMaxPasswdAge

    SYNOPSIS:   set the max password age

    HISTORY:
        o-SimoP 13-Jun-1991 Created

\**********************************************************/

APIERR  USER_MODALS::SetMaxPasswdAge( ULONG ulMaxAge )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    if( ulMaxAge < ONE_DAY )
    {
        DBGEOL( "USER_MODALS::SetMaxPasswdAge: ulMaxAge < ONE_DAY" );
        ASSERT( FALSE );
        return ERROR_INVALID_PARAMETER;
    }

    _ulMaxPasswdAge = ulMaxAge;
    return NERR_Success;

} // USER_MODALS::SetMaxPasswdAge


/**********************************************************\

    NAME:       USER_MODALS::SetMinPasswdAge

    SYNOPSIS:   set the min password age

    HISTORY:
        o-SimoP 13-Jun-1991 Created

\**********************************************************/

APIERR  USER_MODALS::SetMinPasswdAge( ULONG ulMinAge )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _ulMinPasswdAge = ulMinAge;
    return NERR_Success;

} // USER_MODALS::SetMinPasswdAge


/**********************************************************\

    NAME:       USER_MODALS::SetForceLogoff

    SYNOPSIS:   set the force logoff

    HISTORY:
        o-SimoP 13-Jun-1991 Created

\**********************************************************/

APIERR  USER_MODALS::SetForceLogoff( ULONG ulForceLogoff )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _ulForceLogoff = ulForceLogoff;
    return NERR_Success;

} // USER_MODALS::SetForceLogoff


/**********************************************************\

    NAME:       USER_MODALS::SetPasswdHistLen

    SYNOPSIS:   set the password history len

    HISTORY:
        o-SimoP 13-Jun-1991 Created
        JonN    17-Jun-1994 Removed DEF_MAX_PWHIST limitation -- this was
                            always meant to be a default, not an upper limit

\**********************************************************/

APIERR  USER_MODALS::SetPasswdHistLen( UINT uHistLen )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _uPasswdHistLen = uHistLen;
    return NERR_Success;

} // USER_MODALS::SetPasswdHistLen




/**********************************************************\

   NAME:       USER_MODALS_3::USER_MODALS_3

   SYNOPSIS:   constructor for the USER_MODALS_3 class

   ENTRY:      pszDomain - name of domain or server

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

USER_MODALS_3::USER_MODALS_3( const TCHAR * pszDomain )
    :   _loc( pszDomain )
{
    if( IsUnconstructed() )
        return;

}  // USER_MODALS_3::USER_MODALS_3



/**********************************************************\

   NAME:       USER_MODALS_3::GetInfo

   SYNOPSIS:   get information about the USER_MODALS_3

   RETURNS:    An error code, which is NERR_Success on
               success
   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR USER_MODALS_3::GetInfo( VOID )
{
    if ( IsUnconstructed() )
    {
        DBGEOL( "USER_MODALS_3::GetInfo: IsUnconstructed" );
        return ERROR_GEN_FAILURE;
    }

    //  Make object invalid until proven differently
    MakeInvalid();

    APIERR err = _loc.QueryError();
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS_3::GetInfo: _loc error" << err );
        return err;
    }

    USER_MODALS_INFO_3 *pModals = NULL;
    err = ::MNetUserModalsGet ( _loc.QueryServer(),
            3, (BYTE **)&pModals );
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS_3::GetInfo: NUModalsGet error " << err );
	::MNetApiBufferFree( (BYTE **)&pModals );
        return err;
    }

    _dwDuration    = pModals->usrmod3_lockout_duration;
    _dwObservation = pModals->usrmod3_lockout_observation_window;
    _dwThreshold   = pModals->usrmod3_lockout_threshold;
    ::MNetApiBufferFree( (BYTE **)&pModals );

    MakeValid();

    return NERR_Success;

}  // USER_MODALS_3::GetInfo


/**********************************************************\

   NAME:       USER_MODALS_3::WriteInfo

   SYNOPSIS:   Write information about the USER_MODALS_3

   RETURNS:    An error code, which is NERR_Success on
               success
   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR USER_MODALS_3::WriteInfo( VOID )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    USER_MODALS_INFO_3 modals;

    modals.usrmod3_lockout_duration           = _dwDuration;
    modals.usrmod3_lockout_observation_window = _dwObservation;
    modals.usrmod3_lockout_threshold          = _dwThreshold;

    APIERR err = ::MNetUserModalsSet ( _loc.QueryServer(),
           3, (BYTE *)&modals,
           sizeof( modals ), PARMNUM_ALL );
    if( err != NERR_Success )
    {
        DBGEOL( "USER_MODALS_3::WriteInfo error " << err );
    }

    return err;

}  // USER_MODALS_3::WriteInfo


/**********************************************************\

   NAME:       USER_MODALS_3::QueryName

   SYNOPSIS:   query the USER_MODALS_3 name

   RETURNS:    if ok returns pointer to name (given in
               constructor).
               otherwise NULL.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

const TCHAR * USER_MODALS_3::QueryName( VOID ) const
{
    CHECK_VALID( NULL );

    return _loc.QueryName();
}  // USER_MODALS_3::QueryName



/**********************************************************\

   NAME:       USER_MODALS_3::QueryDuration

   SYNOPSIS:   get information about the lockout duration

   RETURNS:    returns duration if ok.
               otherwise 0.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

DWORD USER_MODALS_3::QueryDuration( VOID ) const
{
    CHECK_VALID( 0 );

    return _dwDuration;
}  // USER_MODALS_3::QueryDuration



/**********************************************************\

   NAME:       USER_MODALS_3::QueryObservation

   SYNOPSIS:   get information about the lockout observation window

   RETURNS:    observation window if ok.
               otherwise 0.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

DWORD USER_MODALS_3::QueryObservation( VOID ) const
{
    CHECK_VALID( 0 );

    return _dwObservation;
}  // USER_MODALS_3::QueryObservation


/**********************************************************\

   NAME:       USER_MODALS_3::QueryThreshold

   SYNOPSIS:   get information about the lockout threshold

   RETURNS:    Threshold if ok.
               otherwise -1.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

DWORD USER_MODALS_3::QueryThreshold( VOID ) const
{
    CHECK_VALID( 0 );

    return _dwThreshold;
}  // USER_MODALS_3::QueryThreshold;




/**********************************************************\

   NAME:       USER_MODALS_3::SetDuration

   SYNOPSIS:   set information about the USER_MODALS_3 object

   RETURNS:    ERROR_GEN_FAILURE if USER_MODALS_3 obj not valid
               ERROR_INVALID_PARAM if input param invalid
               NERR_Success if ok.

   HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR  USER_MODALS_3::SetDuration( DWORD dwDuration )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _dwDuration = dwDuration;
    return NERR_Success;

} // USER_MODALS_3::SetDuration


/**********************************************************\

    NAME:       USER_MODALS_3::SetObservation

    SYNOPSIS:   set the lockout observation window

    HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR  USER_MODALS_3::SetObservation( DWORD dwObservation )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _dwObservation = dwObservation;
    return NERR_Success;

} // USER_MODALS_3::SetObservation


/**********************************************************\

    NAME:       USER_MODALS_3::SetThreshold

    SYNOPSIS:   set the lockout threshold

    HISTORY:
        jonn     12/23/93       Created

\**********************************************************/

APIERR  USER_MODALS_3::SetThreshold( DWORD dwThreshold )
{
    CHECK_VALID( ERROR_GEN_FAILURE );

    _dwThreshold = dwThreshold;
    return NERR_Success;

} // USER_MODALS_3::SetThreshold
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmorepld.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    lmorepld.hxx
    Class definitions for the REPL_DIR_BASE class.

    REPL_DIR_BASE is an abstract superclass that contains common methods
    and data members shared between the REPL_EDIR_? and REPL_IDIR_?
    classes.

    The classes are structured as follows:

    	LOC_LM_OBJ
	|
	\---REPL_DIR_BASE
	    |
	    +---REPL_EDIR
	    |   |
	    |   \---REPL_EDIR_0
	    |       |
	    |       \---REPL_EDIR_1
	    |           |
	    |           \---REPL_EDIR_2
	    |
	    \---REPL_IDIR
		|
		\---REPL_IDIR_0
		    |
		    \---REPL_IDIR_1

    FILE HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.
	
*/

#include "pchlmobj.hxx"  // Precompiled header


//
//  REPL_DIR_BASE methods
//

/*******************************************************************

    NAME:	REPL_DIR_BASE :: REPL_DIR_BASE

    SYNOPSIS:	REPL_DIR_BASE class constructor.

    ENTRY:	pszServerName		- Name of the target server.

		pszDirName		- Name of the exported/imported
					  directory.

		nInfoLevel		- The info-level this object
					  represents.  For exported
					  directories, this may be
					  0, 1, or 2.  For imported
					  directories, this may be
					  0 or 1.

		cbBuffer		- The size (in BYTEs) of the
					  API buffer.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_DIR_BASE :: REPL_DIR_BASE( const TCHAR * pszServerName,
				const TCHAR * pszDirName )
  : LOC_LM_OBJ( pszServerName ),
    _nlsDirName( pszDirName ),
    _nInfoLevel( 0 ),
    _cbBuffer( 0 ),
    _nLockBias( 0 )
{
    UIASSERT( pszDirName != NULL );

    //
    //	Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
    	return;
    }

    if( !_nlsDirName )
    {
	ReportError( _nlsDirName.QueryError() );
	return;
    }

}   // REPL_DIR_BASE :: REPL_DIR_BASE


/*******************************************************************

    NAME:	REPL_DIR_BASE :: ~REPL_DIR_BASE

    SYNOPSIS:	REPL_DIR_BASE class destructor.

    EXIT:	The object is destroyed.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_DIR_BASE :: ~REPL_DIR_BASE( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_DIR_BASE :: ~REPL_DIR_BASE


/*******************************************************************

    NAME:	REPL_DIR_BASE :: SetDirName

    SYNOPSIS:	This method sets the exported/imported directory
		name as stored in the _nlsDirName member.

    EXIT:	The _nlsDirName member has been updated.

    RETURNS:	APIERR			- Any errors that occurred.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_DIR_BASE :: SetDirName( const TCHAR * pszDirName )
{
    UIASSERT( pszDirName != NULL );

    return _nlsDirName.CopyFrom( pszDirName );

}   // REPL_DIR_BASE :: SetDirName


/*******************************************************************

    NAME:	REPL_DIR_BASE :: I_CreateNew

    SYNOPSIS:	Virtual callout used by NEW_LM_OBJ to create a new
		object.

    EXIT:	If successful, the private data members for this
		object have been initialized to the default values
		for a new object.

    RETURNS:	APIERR			- Any errors which occurred.

    NOTES:	This method assumes that all fields in the API buffer
		are either initialized to zero (the buffer is zeroed)
		or represented by private members in the derived
		subclass(es).

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_DIR_BASE :: I_CreateNew( VOID )
{
    APIERR err;

    //
    //  The W_CreateNew virtual callout will initialize the
    //  private data members to their default state.  This
    //  virtual method is designed to start at the "bottom"
    //  of the heirarchy and work its way up towards the "top".
    //

    err = W_CreateNew();

    if( err == NERR_Success )
    {
	//
	//  Resize the API buffer to the appropriate size.
	//

	err = ResizeBuffer( QueryReplBufferSize() );
    }

    return err;

}   // REPL_DIR_BASE :: I_CreateNew
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmorepli.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmorepli.hxx
    Class definitions for the REPL_IDIR_BASE and REPL_IDIR_x classes.

    REPL_IDIR_BASE is an abstract superclass that contains common methods
    and data members shared between the REPL_IDIR_x classes.

    The REPL_IDIR_x classes each represent a different info-level "view"
    of an imported directory in the Replicator's import path.

    The classes are structured as follows:

        LOC_LM_OBJ
        |
        \---REPL_DIR_BASE
            |
            \---REPL_IDIR_BASE
                |
                \---REPL_IDIR_0
                    |
                    \---REPL_IDIR_1

    NOTE:   While MNetReplImportDirGetInfo() may use any valid info-level
            (0 - 1), MNetReplImportDirAdd() may only use info-level 0.

    FILE HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

*/

#include "pchlmobj.hxx"  // Precompiled header



//
//  These are default values used during CreateNew operations.
//

#define DEFAULT_STATE            REPL_STATE_NO_MASTER
#define DEFAULT_MASTER_NAME      SZ("")
#define DEFAULT_LAST_UPDATE_TIME 0
#define DEFAULT_LOCK_COUNT       0
#define DEFAULT_LOCK_TIME        0



//
//  REPL_IDIR_BASE methods
//

/*******************************************************************

    NAME:       REPL_IDIR_BASE :: REPL_IDIR_BASE

    SYNOPSIS:   REPL_IDIR_BASE class constructor.

    ENTRY:      pszServerName           - Name of the target server.

                pszDirName              - Name of the exported/imported
                                          directory.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_IDIR_BASE :: REPL_IDIR_BASE( const TCHAR * pszServerName,
                                  const TCHAR * pszDirName )
  : REPL_DIR_BASE( pszServerName, pszDirName )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // REPL_IDIR_BASE :: REPL_IDIR_BASE


/*******************************************************************

    NAME:       REPL_IDIR_BASE :: ~REPL_IDIR_BASE

    SYNOPSIS:   REPL_IDIR_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_IDIR_BASE :: ~REPL_IDIR_BASE( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_IDIR_BASE :: ~REPL_IDIR_BASE


/*******************************************************************

    NAME:       REPL_IDIR_BASE :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                MNetReplImportDirGetInfo API.

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_BASE :: I_GetInfo( VOID )
{
    //
    //  Get the info-level.
    //

    UINT nInfoLevel = QueryReplInfoLevel();
    UIASSERT( nInfoLevel <= 1 );

    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.
    //

    APIERR err = ::MNetReplImportDirGetInfo( QueryName(),
                                             QueryDirName(),
                                             nInfoLevel,
                                             &pbBuffer );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    //
    //  Extract the data to cache.
    //

    err = W_CacheApiData( pbBuffer );

    return err;

}   // REPL_IDIR_BASE :: I_GetInfo


/*******************************************************************

    NAME:       REPL_IDIR_BASE :: I_WriteInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                MNetReplImportDirSetInfo API.

    EXIT:       If successful, the target directory has been updated.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_BASE :: I_WriteInfo( VOID )
{
    //
    //  Update the REPL_IDIR_INFO_x structure.
    //

    APIERR err = W_Write();

    if( err == NERR_Success )
    {
        //
        //  Adjust the locks.
        //

        err = W_AdjustLocks();
    }

    return err;

}   // REPL_IDIR_BASE :: I_WriteInfo


/*******************************************************************

    NAME:       REPL_IDIR_BASE :: I_Delete

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                MNetReplImportDirDel API.

    ENTRY:      nForce                  - The "force" to apply to the
                                          deletion.  This value is
                                          not used by this method.

    EXIT:       If successful, the target directory has been deleted.
                Note that this does not delete the actual directory,
                just the data in the Replicators configuration.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_BASE :: I_Delete( UINT nForce )
{
    UNREFERENCED( nForce );

    //
    //  Invoke the API to delete the directory.
    //

    return ::MNetReplImportDirDel( QueryName(),
                                   QueryDirName() );

}   // REPL_IDIR_BASE :: I_Delete


/*******************************************************************

    NAME:       REPL_IDIR_BASE :: I_WriteNew

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                MNetReplImportDirAdd API.

    EXIT:       If successful, the new directory has been added
                to the Replicator's Import path.  Note that this
                does not actually create the directory, it merely
                adds the data to the Replicator's configuration.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_BASE :: I_WriteNew( VOID )
{
    //
    //  Map info-level 1 to info-level 0.
    //

    UINT nInfoLevel = QueryReplInfoLevel();
    UIASSERT( nInfoLevel <= 1 );

    if( nInfoLevel == 1 )
    {
        nInfoLevel = 0;
    }

    //
    //  Update the REPL_IDIR_INFO_x structure.
    //

    APIERR err = W_Write();

    if( err == NERR_Success )
    {
        //
        //  Invoke the API to add the directory.
        //

        err = ::MNetReplImportDirAdd( QueryName(),
                                      nInfoLevel,
                                      QueryBufferPtr() );
    }

    if( err == NERR_Success )
    {
        //
        //  Adjust the locks.
        //

        err = W_AdjustLocks();
    }

    return err;

}   // REPL_IDIR_BASE :: I_WriteNew


/*******************************************************************

    NAME:       REPL_IDIR_BASE :: W_AdjustLocks

    SYNOPSIS:   Adjust the directory locks based on the lock bias
                as stored in REPL_DIR_BASE.  If the lock bias is
                positive, then locks need to be applied.  If the
                lock bias is negative, then locks need to be removed.
                If the lock bias is zero, then no adjustment is
                necessary.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     25-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_BASE :: W_AdjustLocks( VOID )
{
    APIERR err = NERR_Success;

    while( ( QueryLockBias() != 0 ) && ( err == NERR_Success ) )
    {
        if( QueryLockBias() > 0 )
        {
            UnlockDirectory();

            err = ::MNetReplImportDirLock( QueryName(),
                                           QueryDirName() );
        }
        else
        {
            LockDirectory();

            err = ::MNetReplImportDirUnlock( QueryName(),
                                             QueryDirName(),
                                             REPL_UNLOCK_NOFORCE );
        }
    }

    return err;

}   // REPL_IDIR_BASE :: W_AdjustLocks



//
//  REPL_IDIR_0 methods
//

/*******************************************************************

    NAME:       REPL_IDIR_0 :: REPL_IDIR_0

    SYNOPSIS:   REPL_IDIR_0 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

                pszDirName              - Name of the exported/imported
                                          directory.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_IDIR_0 :: REPL_IDIR_0( const TCHAR * pszServerName,
                            const TCHAR * pszDirName )
  : REPL_IDIR_BASE( pszServerName, pszDirName )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Initialize the info-level & buffer size values.
    //

    SetReplInfoLevel( 0 );
    SetReplBufferSize( sizeof(REPL_IDIR_INFO_0) );

}   // REPL_IDIR_0 :: REPL_IDIR_0


/*******************************************************************

    NAME:       REPL_IDIR_0 :: ~REPL_IDIR_0

    SYNOPSIS:   REPL_IDIR_0 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_IDIR_0 :: ~REPL_IDIR_0( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_IDIR_0 :: ~REPL_IDIR_0


/*******************************************************************

    NAME:       REPL_IDIR_0 :: W_Write

    SYNOPSIS:   Virtual helper function to initialize the
                REPL_IDIR_INFO_0 API structure.

    EXIT:       The API buffer has been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_0 :: W_Write( VOID )
{
    REPL_IDIR_INFO_0 * prii0 = (REPL_IDIR_INFO_0 *)QueryBufferPtr();
    UIASSERT( prii0 != NULL );

    prii0->rpid0_dirname = (LPTSTR)QueryDirName();

    return NERR_Success;

}   // REPL_IDIR_0 :: W_Write


/*******************************************************************

    NAME:       REPL_IDIR_0 :: W_CreateNew

    SYNOPSIS:   Virtual helper function to initialize the private
                data member to reasonable defaults whenever a new
                object is being created.

    EXIT:       Any necessary private data members have been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_0 :: W_CreateNew( VOID )
{
    //
    //  The buck stops here...
    //

    return NERR_Success;

}   // REPL_IDIR_0 :: W_CreateNew


/*******************************************************************

    NAME:       REPL_IDIR_0 :: W_CacheApiData

    SYNOPSIS:   Virtual helper function to cache any data from the
                API buffer which must be "persistant".  This data
                is typically held in private data members.

    ENTRY:      pbBuffer                - Points to an API buffer.  Is
                                          actually a REPL_IDIR_0 *.

    EXIT:       Any cacheable data has been saved into private data
                members.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_0 :: W_CacheApiData( const BYTE * pbBuffer )
{
    UNREFERENCED( pbBuffer );

    return NERR_Success;

}   // REPL_IDIR_0 :: W_CacheApiData



//
//  REPL_IDIR_1 methods
//

/*******************************************************************

    NAME:       REPL_IDIR_1 :: REPL_IDIR_1

    SYNOPSIS:   REPL_IDIR_1 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

                pszDirName              - Name of the exported/imported
                                          directory.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_IDIR_1 :: REPL_IDIR_1( const TCHAR * pszServerName,
                            const TCHAR * pszDirName )
  : REPL_IDIR_0( pszServerName, pszDirName ),
    _lState( 0 ),
    _nlsMasterName(),
    _lLastUpdateTime( 0 ),
    _lLockCount( 0 ),
    _lLockTime( 0 )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsMasterName )
    {
        ReportError( _nlsMasterName.QueryError() );
        return;
    }

    //
    //  Initialize the info-level & buffer size values.
    //

    SetReplInfoLevel( 1 );
    SetReplBufferSize( sizeof(REPL_IDIR_INFO_1) );

}   // REPL_IDIR_1 :: REPL_IDIR_1


/*******************************************************************

    NAME:       REPL_IDIR_1 :: ~REPL_IDIR_1

    SYNOPSIS:   REPL_IDIR_1 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_IDIR_1 :: ~REPL_IDIR_1( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_IDIR_1 :: ~REPL_IDIR_1


/*******************************************************************

    NAME:       REPL_IDIR_1 :: W_Write

    SYNOPSIS:   Virtual helper function to initialize the
                REPL_IDIR_INFO_1 API structure.

    EXIT:       The API buffer has been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_1 :: W_Write( VOID )
{
    REPL_IDIR_INFO_1 * prii1 = (REPL_IDIR_INFO_1 *)QueryBufferPtr();
    UIASSERT( prii1 != NULL );

    prii1->rpid1_dirname          = (LPTSTR)QueryDirName();
    prii1->rpid1_state            = (DWORD)QueryState();
    prii1->rpid1_mastername       = (LPTSTR)QueryMasterName();
    prii1->rpid1_last_update_time = (DWORD)QueryLastUpdateTime();
    prii1->rpid1_lockcount        = (DWORD)QueryLockCount();
    prii1->rpid1_locktime         = (DWORD)QueryLockTime();

    return NERR_Success;

}   // REPL_IDIR_1 :: W_Write


/*******************************************************************

    NAME:       REPL_IDIR_1 :: W_CreateNew

    SYNOPSIS:   Virtual helper function to initialize the private
                data member to reasonable defaults whenever a new
                object is being created.

    EXIT:       Any necessary private data members have been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_1 :: W_CreateNew( VOID )
{
    APIERR err;

    err = REPL_IDIR_0::W_CreateNew();

    if( err == NERR_Success )
    {
        SetState( DEFAULT_STATE );
        SetLastUpdateTime( DEFAULT_LAST_UPDATE_TIME );
        SetLockCount( DEFAULT_LOCK_COUNT );
        SetLockTime( DEFAULT_LOCK_TIME );

        err = SetMasterName( DEFAULT_MASTER_NAME );
    }

    return err;

}   // REPL_IDIR_1 :: W_CreateNew


/*******************************************************************

    NAME:       REPL_IDIR_1 :: W_CacheApiData

    SYNOPSIS:   Virtual helper function to cache any data from the
                API buffer which must be "persistant".  This data
                is typically held in private data members.

    ENTRY:      pbBuffer                - Points to an API buffer.  Is
                                          actually a REPL_IDIR_1 *.

    EXIT:       Any cacheable data has been saved into private data
                members.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_1 :: W_CacheApiData( const BYTE * pbBuffer )
{
    REPL_IDIR_INFO_1 * prii1 = (REPL_IDIR_INFO_1 *)pbBuffer;

    SetState( (ULONG)prii1->rpid1_state );
    SetLastUpdateTime( (ULONG)prii1->rpid1_last_update_time );
    SetLockCount( (ULONG)prii1->rpid1_lockcount );
    SetLockTime( (ULONG)prii1->rpid1_locktime );

    return SetMasterName( (const TCHAR *)prii1->rpid1_mastername );

}   // REPL_IDIR_1 :: W_CacheApiData


/*******************************************************************

    NAME:       REPL_IDIR_1 :: SetMasterName

    SYNOPSIS:   Sets the name of the most recent master for this
                import directory.  This corresponds to the
                rpid1_mastername field.

    ENTRY:      pszMasterName           - The new master name.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     24-Feb-1992 Created for the Server Manager.
        beng        29-Mar-1992 Fixed CHAR/TCHAR bug

********************************************************************/
APIERR REPL_IDIR_1 :: SetMasterName( const TCHAR * pszMasterName )
{
    return _nlsMasterName.CopyFrom( pszMasterName );

}   // REPL_IDIR_1 :: SetMasterName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmosess.cxx ===
/**********************************************************************/
/**              Microsoft NT Windows                                **/
/**        Copyright(c) Microsoft Corp., 1991                        **/
/**********************************************************************/

/*
    lmosess.cxx
        LM_SESSION source file.

        The LM_SESSION is as of the followings:
                LOC_LM_OBJ
                    LM_SESSION_0
                        LM_SESSION_10
                            LM_SESSION_1
                                LM_SESSION_2

    FILE HISTORY:
        terryk  20-Aug-91       Created
        terryk  26-Aug-91       Code review. Attened: keithmo chuckc
                                terryk
        terryk  07-Oct-91       type changes for NT
        KeithMo 08-Oct-1991     Now includes LMOBJP.HXX.
        terryk  17-Oct-91       WIN 32 conversion
        terryk  21-Oct-91       WIN 32 conversion

*/

#include "pchlmobj.hxx"  // Precompiled header


/**********************************************************\

    NAME:       LM_SESSION::LM_SESSION

    SYNOPSIS:   constructor

    ENTRY:      const TCHAR * pszClientname - client computer name
                The second parameter can be one of the following:
                const TCHAR * pszLocation - location name
                enum LOCATION_TYPE location_type - location type
                const LOCATION &loc - location object

    HISTORY:
                terryk    20-Aug-91    Created

\**********************************************************/

LM_SESSION::LM_SESSION(const TCHAR *pszComputername, const TCHAR *pszLocation )
    : LOC_LM_OBJ( pszLocation ),
    _nlsComputername()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    ULONG ulPathType;
    APIERR err = ::I_MNetPathType( QueryServer(), pszComputername,
        &ulPathType, 0L );
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }
    if ( ulPathType != ITYPE_UNC_COMPNAME)
    {
        ReportError( NERR_InvalidComputer );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }

    _nlsComputername = pszComputername;
    err = _nlsComputername.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( !SZ("LM_SESSION error: construction failure.") );
        return;
    }
}

LM_SESSION::LM_SESSION(const TCHAR *pszComputername, enum LOCATION_TYPE loctype)
    : LOC_LM_OBJ( loctype ),
    _nlsComputername()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    ULONG ulPathType;
    APIERR err = ::I_MNetPathType( QueryServer(), pszComputername,
        &ulPathType, 0L );
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }
    if ( ulPathType != ITYPE_UNC_COMPNAME)
    {
        ReportError( NERR_InvalidComputer );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }

    _nlsComputername = pszComputername;
    err = _nlsComputername.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( !SZ("LM_SESSION error: construction failure.") );
        return;
    }
}

LM_SESSION::LM_SESSION(const TCHAR *pszComputername, const LOCATION & loc)
    : LOC_LM_OBJ( loc ),
    _nlsComputername()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    ULONG ulPathType;
    APIERR err = ::I_MNetPathType( QueryServer(), pszComputername,
        &ulPathType, 0L );
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }
    if ( ulPathType != ITYPE_UNC_COMPNAME)
    {
        ReportError( NERR_InvalidComputer );
        UIASSERT( SZ("LM_SESSION error: invalid computername.") );
        return;
    }

    _nlsComputername = pszComputername;
    err = _nlsComputername.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        UIASSERT( !SZ("LM_SESSION error: construction failure.") );
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION::QueryName

    SYNOPSIS:   return the client name

    RETURN:     TCHAR * pszClientname - the client name

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

const TCHAR * LM_SESSION::QueryName( VOID ) const
{
    return _nlsComputername.QueryPch();
}

/**********************************************************\

    NAME:       LM_SESSION::I_Delete

    SYNOPSIS:   delete the current session

    ENTRY:      UINT usForce - unused

    RETURN:     APIERR err - return the netapi error code

    NOTES:      It will call ::NetSessionClose to close the session

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    UIASSERT( uiForce == 0 );
    return ::MNetSessionDel( QueryServer(), QueryName(), NULL );
}

/**********************************************************\

    NAME:       LM_SESSION::SetName

    SYNOPSIS:   set the client name

    ENTRY:      const TCHAR * pszClientname

    RETURN:     APIERR err - return from the set NLS_STR

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION::SetName( const TCHAR * pszComputername )
{
    ULONG ulPathType;

    UIASSERT(( ::I_MNetPathType( QueryServer(), pszComputername,
        &ulPathType, 0L ) == NERR_Success ) && ( ulPathType ==
        ITYPE_UNC_COMPNAME ));

    _nlsComputername = pszComputername;
    return _nlsComputername.QueryError();
}

/**********************************************************\

    NAME:       LM_SESSION_0::LM_SESSION_0

    SYNOPSIS:   level 0 object constructor

    ENTRY:      const TCHAR * pszServer - server name
                The second parameter is:
                const TCHAR * pszLocation - location name
                OR
                enum LOCATION_TYPE location_type - location type
                OR
                const & LOCATION loc - location object

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

LM_SESSION_0::LM_SESSION_0( const TCHAR * pszComputername, const TCHAR *
        pszLocation )
    : LM_SESSION( pszComputername, pszLocation )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

LM_SESSION_0::LM_SESSION_0( const TCHAR *pszComputername,
        enum LOCATION_TYPE loctype )
    : LM_SESSION( pszComputername, loctype )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

LM_SESSION_0::LM_SESSION_0( const TCHAR *pszComputername, const LOCATION & loc)
    : LM_SESSION( pszComputername, loc )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION_0::I_GetInfo

    SYNOPSIS:   get the level 0 session information

    RETURN:     APIERR err - err code returned by ::NetSessionGetInfo

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_0::I_GetInfo( VOID )
{
    // BUGBUG. No buffer allocation for NT
    BYTE *pBuffer = NULL;

    APIERR err = ::MNetSessionGetInfo( QueryServer(), QueryName(),
        0, &pBuffer );

    // Do nothing. Since we don't need the computer name
    ::MNetApiBufferFree( &pBuffer );

    return err;
}

/**********************************************************\

    NAME:       LM_SESSION_10::LM_SESSION_10

    SYNOPSIS:   level 10 object constructor

    ENTRY:      const TCHAR * pszServer - server name
                The second parameter is:
                const TCHAR * pszLocation - location name
                OR
                enum LOCATION_TYPE location_type - location type
                OR
                const & LOCATION loc - location object

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

LM_SESSION_10::LM_SESSION_10( const TCHAR * pszComputername, const TCHAR *
        pszLocation )
    : LM_SESSION_0( pszComputername, pszLocation ),
    _nlsUsername(),
    _ulTime( 0 ),
    _ulIdleTime( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsUsername.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( !SZ("LM_SESSION_10 error: construction failure.") );
        ReportError( err );
        return;
    }
}

LM_SESSION_10::LM_SESSION_10( const TCHAR *pszComputername,
        enum LOCATION_TYPE loctype )
    : LM_SESSION_0( pszComputername, loctype ),
    _nlsUsername(),
    _ulTime( 0 ),
    _ulIdleTime( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsUsername.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( !SZ("LM_SESSION_10 error: construction failure.") );
        ReportError( err );
        return;
    }
}

LM_SESSION_10::LM_SESSION_10( const TCHAR *pszComputername, const LOCATION & loc)
    : LM_SESSION_0( pszComputername, loc ),
    _nlsUsername(),
    _ulTime( 0 ),
    _ulIdleTime( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsUsername.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( !SZ("LM_SESSION_10 error: construction failure.") );
        ReportError( err );
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION_10::I_GetInfo

    SYNOPSIS:   call the netapi and get the information

    RETURN:     APIERR err - the netapi error code

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_10::I_GetInfo( VOID )
{
    BYTE *pBuffer = NULL;

    APIERR err = ::MNetSessionGetInfo( QueryServer(), QueryName(),
        10, &pBuffer );

    if ( err == NERR_Success )
    {
        struct session_info_10 *si10 = ( struct session_info_10 * )
            pBuffer;
        err = SetUsername( si10->sesi10_username );
        if ( err != NERR_Success )
        {
            ::MNetApiBufferFree( &pBuffer );
            return err;
        }
        SetTime( si10->sesi10_time );
        SetIdleTime( si10->sesi10_idle_time );
    }

    ::MNetApiBufferFree( &pBuffer );

    return err;
}

/**********************************************************\

    NAME:       LM_SESSION_10::QueryUsername

    SYNOPSIS:   return the username

    RETURN:     const TCHAR * pszUsername - return the username string

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

const TCHAR * LM_SESSION_10::QueryUsername( VOID ) const
{
    // CODEWORK: Check GetInfo state
    return _nlsUsername.QueryPch();
}

/**********************************************************\

    NAME:       LM_SESSION_10::QueryTime

    SYNOPSIS:   query how long ( in seconds ) a session has been active

    RETURN:     ULONG - return the session active time in seconds

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

ULONG LM_SESSION_10::QueryTime( VOID ) const
{
    // CODEWORK: Check GetInfo state
    return _ulTime;
}

/**********************************************************\

    NAME:       LM_SESSION_10::QueryIdleTime

    SYNOPSIS:   query how long ( in seconds ) a session has been idle

    RETURN:     ULONG - return the session idle time in seconds

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

ULONG LM_SESSION_10::QueryIdleTime( VOID ) const
{
    // CODEWORK: Check GetInfo state
    return _ulIdleTime;
}

/**********************************************************\

    NAME:       LM_SESSION_10::SetUsername

    SYNOPSIS:   Protected method to change the user name

    ENTRY:      const TCHAR * pszUsername - username to be changed to

    RETURN:     APIERR err - string assignment error flag

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_10::SetUsername( const TCHAR * pszUsername )
{
    UIASSERT( ::I_MNetNameValidate( QueryServer(), pszUsername,
        NAMETYPE_USER, 0 ) == NERR_Success );

    _nlsUsername = pszUsername;
    return _nlsUsername.QueryError();
}

/**********************************************************\

    NAME:       LM_SESSION_10::SetTime

    SYNOPSIS:   protected method to change the connection time variable

    ENTRY:      ULONG ulTime - new connection time

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_10::SetTime( ULONG ulTime )
{
    _ulTime = ulTime;
}

/**********************************************************\

    NAME:       LM_SESSION_10::SetIdleTime

    SYNOPSIS:   protected method to change the idle connection time
                variable

    ENTRY:      ULONG ulTime - new idle time

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_10::SetIdleTime( ULONG ulTime )
{
    _ulIdleTime = ulTime;
}

/**********************************************************\

    NAME:       LM_SESSION_1::LM_SESSION_1

    SYNOPSIS:   level 1 object constructor

    ENTRY:      const TCHAR * pszServer - server name
                The second parameter is:
                const TCHAR * pszLocation - location name
                OR
                enum LOCATION_TYPE location_type - location type
                OR
                const & LOCATION loc - location object

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

LM_SESSION_1::LM_SESSION_1( const TCHAR * pszComputername, const TCHAR *
        pszLocation )
    : LM_SESSION_10( pszComputername, pszLocation ),
#ifndef WIN32
    _uiNumConns( 0 ),
    _uiNumUsers( 0 ),
#endif
    _uNumOpens( 0 ),
    _ulUserFlags( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

LM_SESSION_1::LM_SESSION_1( const TCHAR *pszComputername,
        enum LOCATION_TYPE loctype )
    : LM_SESSION_10( pszComputername, loctype ),
#ifndef WIN32
    _uiNumConns( 0 ),
    _uiNumUsers( 0 ),
#endif
    _uNumOpens( 0 ),
    _ulUserFlags( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

LM_SESSION_1::LM_SESSION_1( const TCHAR *pszComputername, const LOCATION & loc)
    : LM_SESSION_10( pszComputername, loc ),
#ifndef WIN32
    _uiNumConns( 0 ),
    _uiNumUsers( 0 ),
#endif
    _uNumOpens( 0 ),
    _ulUserFlags( 0 )
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION_1::I_GetInfo

    SYNOPSIS:   Get the session information. Worker function for
                GetInfo().

    RETURN:     APIERR err - the error code for ::NetSessionGetInfo

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_1::I_GetInfo( VOID )
{
    BYTE *pBuffer = NULL;

    APIERR err = ::MNetSessionGetInfo( QueryServer(), QueryName(),
        1, &pBuffer );

    if ( err == NERR_Success )
    {
        struct session_info_1 *si1 = ( struct session_info_1 * )
            pBuffer;
        err = SetUsername( si1->sesi1_username );
        if ( err != NERR_Success )
        {
            ::MNetApiBufferFree( &pBuffer );
            return err;
        }
        SetTime( si1->sesi1_time );
        SetIdleTime( si1->sesi1_idle_time );
#ifndef WIN32
        // WIN32BUGBUG
        SetNumConns( (UINT)si1->sesi1_num_conns );
        SetNumUsers( si1->sesi1_num_users );
#endif
        SetNumOpens( si1->sesi1_num_opens );
        SetUserFlags( si1->sesi1_user_flags );
    }
    ::MNetApiBufferFree( &pBuffer );

    return err;
}

#ifndef WIN32
/**********************************************************\

    NAME:       LM_SESSION_1::QueryNumConns

    SYNOPSIS:   query how many connections have been made during the
                session

    RETURN:     UINT - connections number

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

UINT LM_SESSION_1::QueryNumConns( VOID ) const
{
    // CODEWORK: check GetInfo State
    return _uiNumConns;
}

/**********************************************************\

    NAME:       LM_SESSION_1::QueryNumUsers

    SYNOPSIS:   query how many user have made connections via the
                session

    RETURN:     UINT - user number

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

UINT LM_SESSION_1::QueryNumUsers( VOID ) const
{
    // CODEWORK: check GetInfo State
    return _uiNumUsers;
}

#endif

/**********************************************************\

    NAME:       LM_SESSION_1::QueryNumOpens

    SYNOPSIS:   query how many files, devices, and pipes have been
                opened during the session

    RETURN:     UINT - files, devices, and pipes opened number

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

UINT LM_SESSION_1::QueryNumOpens( VOID ) const
{
    // CODEWORK: check GetInfo State
    return _uNumOpens;
}

/**********************************************************\

    NAME:       LM_SESSION_1::QueryUserFlags

    SYNOPSIS:   query how the user established the session. The shares.h
                header file defines this bit mask for sesil_user_flags.

    RETURN:     ULONG user_flags - user flags
                SESS_GUEST      1       User specified by sesil_username
                                        established the session using a
                                        guest account
                SESS_NOENCRYPTION       2       User specified by
                                                sesil_username established
                                                the session without using
                                                password encryption

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

ULONG LM_SESSION_1::QueryUserFlags( VOID ) const
{
    // CODEWORK: check GetInfo State
    return _ulUserFlags;
}

/**********************************************************\

    NAME:       LM_SESSION_1::IsGuest

    SYNOPSIS:   return whether the session is a guest account

    RETURN:     BOOL which indicates the session is a guest account or
                not

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  23-Aug-91       Created

\**********************************************************/

BOOL LM_SESSION_1::IsGuest( VOID ) const
{
    // CODEWORK: check GetInfo State
    return ( _ulUserFlags & SESS_GUEST ) != 0;
}

/**********************************************************\

    NAME:       LM_SESSION_1::IsEncrypted

    SYNOPSIS:   return whether the session is using password encryption
                or not

    RETURN:     BOOL which indicates the session is using encryption or
                not

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  23-Aug-91       Created

\**********************************************************/

BOOL LM_SESSION_1::IsEncrypted( VOID ) const
{
    // CODEWORK: check GetInfo State
    return ( _ulUserFlags & SESS_NOENCRYPTION ) == 0;
}

#ifndef WIN32
/**********************************************************\

    NAME:       LM_SESSION_1::SetNumConns

    SYNOPSIS:   Protected method which is used to change the number of
                connections variable.

    ENTRY:      UINT uiNumConns - the new number of connections number

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_1::SetNumConns( UINT uiNumConns )
{
    _uiNumConns = uiNumConns;
}

/**********************************************************\

    NAME:       LM_SESSION_1::SetNumUsers

    SYNOPSIS:   protected method which used to set the new number of
                users

    ENTRY:      UINT uiNumUser - number of new user

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_1::SetNumUsers( UINT uiNumUser )
{
    _uiNumUsers = uiNumUser;
}

#endif

/**********************************************************\

    NAME:       LM_SESSION_1::SetNumOpens

    SYNOPSIS:   protected method which is used to set the number of
                opens device

    ENTRY:      UINT uiNumOpens - new open devices and files number

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_1::SetNumOpens( UINT uNumOpens )
{
    _uNumOpens = uNumOpens;
}

/**********************************************************\

    NAME:       LM_SESSION_1::SetUserFlags

    SYNOPSIS:   protected method which used to set the new user flags

    ENTRY:      ULONG ulUserFlags - new user flags

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

VOID LM_SESSION_1::SetUserFlags( ULONG ulUserFlags )
{
    _ulUserFlags = ulUserFlags;
}

/**********************************************************\

    NAME:       LM_SESSION_2::LM_SESSION_2

    SYNOPSIS:   level 2 object constructor

    ENTRY:      const TCHAR * pszServer - server name
                The second parameter is:
                const TCHAR * pszLocation - location name
                OR
                enum LOCATION_TYPE location_type - location type
                OR
                const & LOCATION loc - location object

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

LM_SESSION_2::LM_SESSION_2( const TCHAR *pszComputername,
        const TCHAR *pszLocation )
    : LM_SESSION_1( pszComputername , pszLocation ),
    _nlsClientType()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsClientType.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( SZ("LM_SESSION_2 error: construction failure.") );
        ReportError( err );
        return;
    }
}

LM_SESSION_2::LM_SESSION_2( const TCHAR *pszComputername,
        enum LOCATION_TYPE loctype )
    : LM_SESSION_1( pszComputername, loctype ),
    _nlsClientType()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsClientType.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( SZ("LM_SESSION_2 error: construction failure.") );
        ReportError( err );
        return;
    }
}

LM_SESSION_2::LM_SESSION_2( const TCHAR *pszComputername, const LOCATION & loc)
    : LM_SESSION_1( pszComputername, loc ),
    _nlsClientType()
{
    if ( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err = _nlsClientType.QueryError();
    if ( err != NERR_Success )
    {
        UIASSERT( SZ("LM_SESSION_2 error: construction failure.") );
        ReportError( err );
        return;
    }
}

/**********************************************************\

    NAME:       LM_SESSION_2::I_GetInfo

    SYNOPSIS:   get the server information

    RETURN:     APIERR - from the netapi call

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_2::I_GetInfo( VOID )
{
    BYTE *pBuffer = NULL;

    APIERR err = ::MNetSessionGetInfo( QueryServer(), QueryName(),
        2, &pBuffer );

    if ( err == NERR_Success )
    {
        struct session_info_2 *si2 = ( struct session_info_2 * ) pBuffer;
        err = SetUsername( si2->sesi2_username );
        if ( err != NERR_Success )
        {
            ::MNetApiBufferFree( &pBuffer );
            return err;
        }
        err = SetClientType( si2->sesi2_cltype_name );
        if ( err != NERR_Success )
        {
            ::MNetApiBufferFree( &pBuffer );
            return err;
        }
        SetTime( si2->sesi2_time );
        SetIdleTime( si2->sesi2_idle_time );
#ifndef WIN32
        SetNumConns( (UINT)si2->sesi2_num_conns );
        SetNumUsers( si2->sesi2_num_users );
#endif
        SetNumOpens( si2->sesi2_num_opens );
        SetUserFlags( si2->sesi2_user_flags );
    }
    ::MNetApiBufferFree( &pBuffer );

    return err;
}

/**********************************************************\

    NAME:       LM_SESSION_2::QueryClientType

    SYNOPSIS:   query the type of client that established the session

    RETURN:     TCHAR * - an ASCIIZ string
                NAME                    TYPE
                DOWN LEVEL      Old clients
                DOS LM          LAN Manager 1.0 for ms-dos client &
                                LAN Manager 2.0 for ms-dos basic clients
                DOS LM 2.0      LAN Manager 2.0 for ms-dos enhanced
                                clients
                OS/2 LM 1.0     LAN Manager 1.0 for ms os/2 client or
                                LAN Manager 2.0 for ms os/2 with ms os/2 1.1
                OS/2 LM 2.0     LAN Manager 2.0 for MS os/2 clients

    NOTES:      The caller should call GetInfo before he queries the
                variable

    HISTORY:
                terryk  20-Aug-91       Created

\**********************************************************/

const TCHAR * LM_SESSION_2::QueryClientType( VOID ) const
{
    // CODEWORK: check GetInfo state
    return _nlsClientType.QueryPch();
}

/**********************************************************\

    NAME:       LM_SESSION_2::SetClientType

    SYNOPSIS:   protected method which used to set the cltype_name
                variable

    ENTRY:      const TCHAR * pszClientType - new cltype_name

    RETURN:     APIERR err - error flag for assignment

    HISTORY:
                terryk  22-Aug-91       Created

\**********************************************************/

APIERR LM_SESSION_2::SetClientType( const TCHAR * pszClientType )
{
    _nlsClientType = pszClientType;
    return _nlsClientType.QueryError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmorepl.cxx ===
/**********************************************************************/
/**			  Microsoft Windows/NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    lmorepl.hxx
    Class definitions for the REPLICATOR_0 class.

    The REPLICATOR_0 class is used to configure the Replicator service
    on a target server.

    The classes are structured as follows:

    	LOC_LM_OBJ
	|
	\---REPLICATOR_0

    FILE HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.
	
*/
#include "pchlmobj.hxx"  // Precompiled header


//
//  REPLICATOR_0 methods
//

/*******************************************************************

    NAME:	REPLICATOR_0 :: REPLICATOR_0

    SYNOPSIS:	REPLICATOR_0 class constructor.

    ENTRY:	pszServerName		- Name of the target server.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPLICATOR_0 :: REPLICATOR_0( const TCHAR * pszServerName )
  : LOC_LM_OBJ( pszServerName ),
    _lRole( 0 ),
    _nlsExportPath(),
    _nlsExportList(),
    _nlsImportPath(),
    _nlsImportList(),
    _nlsLogonUserName(),
    _lInterval( 0 ),
    _lPulse( 0 ),
    _lGuardTime( 0 ),
    _lRandom( 0 ),
    _pstrlistExport( NULL ),
    _pstrlistImport( NULL )
{
    //
    //	Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
    	return;
    }

    if( !_nlsExportPath )
    {
	ReportError( _nlsExportPath.QueryError() );
	return;
    }

    if( !_nlsExportList )
    {
	ReportError( _nlsExportList.QueryError() );
	return;
    }

    if( !_nlsImportPath )
    {
	ReportError( _nlsImportPath.QueryError() );
	return;
    }

    if( !_nlsImportList )
    {
	ReportError( _nlsImportList.QueryError() );
	return;
    }

    if( !_nlsLogonUserName )
    {
	ReportError( _nlsLogonUserName.QueryError() );
	return;
    }

}   // REPLICATOR_0 :: REPLICATOR_0


/*******************************************************************

    NAME:	REPLICATOR_0 :: ~REPLICATOR_0

    SYNOPSIS:	REPLICATOR_0 class destructor.

    EXIT:	The object is destroyed.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPLICATOR_0 :: ~REPLICATOR_0( VOID )
{
    //
    //  Delete anything we've allocated.
    //

    delete _pstrlistExport;
    _pstrlistExport = NULL;

    delete _pstrlistImport;
    _pstrlistImport = NULL;

}   // REPLICATOR_0 :: ~REPLICATOR_0


/*******************************************************************

    NAME:	REPLICATOR_0 :: I_GetInfo

    SYNOPSIS:	Virtual callout used by NEW_LM_OBJ to invoke the
    		MNetReplGetInfo API (info-level 0).

    EXIT:	The API has been invoked, and any "persistant" data
    		has been cached.

    RETURNS:	APIERR			- The result of the API.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPLICATOR_0 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //	Invoke the API.
    //

    APIERR err = ::MNetReplGetInfo( QueryName(),
				    0,
				    &pbBuffer );

    if( err != NERR_Success )
    {
    	return err;
    }

    //
    //	Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    REPL_INFO_0 * pri0 = (REPL_INFO_0 *)pbBuffer;

    //
    //  Extract the data to cache.
    //

    SetRole( (DWORD)pri0->rp0_role );
    SetInterval( (DWORD)pri0->rp0_interval );
    SetPulse( (DWORD)pri0->rp0_pulse );
    SetGuardTime( (DWORD)pri0->rp0_guardtime );
    SetRandom( (DWORD)pri0->rp0_random );

    err = SetExportPath( (const TCHAR *)pri0->rp0_exportpath );

    if( err == NERR_Success )
    {
	err = SetExportList( (const TCHAR *)pri0->rp0_exportlist );
    }

    if( err == NERR_Success )
    {
	err = SetImportPath( (const TCHAR *)pri0->rp0_importpath );
    }

    if( err == NERR_Success )
    {
	err = SetImportList( (const TCHAR *)pri0->rp0_importlist );
    }

    if( err == NERR_Success )
    {
	err = SetLogonUserName( (const TCHAR *)pri0->rp0_logonusername );
    }

    return err;

}   // REPLICATOR_0 :: I_GetInfo


/*******************************************************************

    NAME:	REPLICATOR_0 :: I_WriteInfo

    SYNOPSIS:	Virtual callout used by NEW_LM_OBJ to invoke the
    		MNetReplSetInfo API (info-level 0).

    EXIT:	If successful, the target server has been updated.

    RETURNS:	APIERR			- The result of the API.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPLICATOR_0 :: I_WriteInfo( VOID )
{
    //
    //	Update the REPL_INFO_0 structure.
    //

    APIERR err = W_Write();

    if( err != NERR_Success )
    {
	return err;
    }

    //
    //	Invoke the API to do the actual replicator update.
    //

    return ::MNetReplSetInfo( QueryName(),
			      0,
			      QueryBufferPtr() );

}   // REPLICATOR_0 :: I_WriteInfo


/*******************************************************************

    NAME:	REPLICATOR_0 :: W_Write

    SYNOPSIS:	Helper function for WriteNew and WriteInfo -- loads
		current values into the API buffer.

    EXIT:	The API buffer has been filled.

    RETURNS:	APIERR			- The result of the API.

    NOTES:	Note that we cannot use QueryExportList to initialize
		the rp0_exportlist field, since QueryExportList returns
		a STRLIST * type.  The same holds true for rp0_importlist
		also.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPLICATOR_0 :: W_Write( VOID )
{
    REPL_INFO_0 * pri0 = (REPL_INFO_0 *)QueryBufferPtr();
    ASSERT( pri0 != NULL );

    pri0->rp0_role	    = (DWORD)QueryRole();
    pri0->rp0_exportpath    = (LPTSTR)QueryExportPath();
    pri0->rp0_exportlist    = (LPTSTR)_nlsExportList.QueryPch();
    pri0->rp0_importpath    = (LPTSTR)QueryImportPath();
    pri0->rp0_importlist    = (LPTSTR)_nlsImportList.QueryPch();
    pri0->rp0_logonusername = (LPTSTR)QueryLogonUserName();
    pri0->rp0_interval	    = (DWORD)QueryInterval();
    pri0->rp0_pulse	    = (DWORD)QueryPulse();
    pri0->rp0_guardtime	    = (DWORD)QueryGuardTime();
    pri0->rp0_random	    = (DWORD)QueryRandom();

    return NERR_Success;

}   // REPLICATOR_0 :: W_Write


/*******************************************************************

    NAME:	REPLICATOR_0 :: SetExportPath

    SYNOPSIS:	This method will set the replicator's Export path.

    ENTRY:	pszExportPath		- The new Export path.

    RETURNS:	APIERR			- Any errors encountered.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPLICATOR_0 :: SetExportPath( const TCHAR * pszExportPath )
{
    UIASSERT( pszExportPath != NULL );

    return _nlsExportPath.CopyFrom( pszExportPath );

}   // REPLICATOR_0 :: SetExportPath


/*******************************************************************

    NAME:	REPLICATOR_0 :: SetExportList

    SYNOPSIS:	This method will set the replicator's Export list.
		This is the list of computers & domains to which
		files should be replicated.  Items within this
		list must be separated by semicolons (;).

    ENTRY:	pszExportList		- The new Export list.

    RETURNS:	APIERR			- Any errors encountered.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPLICATOR_0 :: SetExportList( const TCHAR * pszExportList )
{
    //
    //  Create a new string list.
    //

    STRLIST * pstrlst = new STRLIST( pszExportList, SZ(";") );
    APIERR    err = ( pstrlst == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
					: NERR_Success;

    if( err == NERR_Success )
    {
	//
	//  Now that we've got a new string list, update the
	//  "plain text" representation.
	//
	
	err = _nlsExportList.CopyFrom( pszExportList );
    }

    if( err == NERR_Success )
    {
	//
	//  Everything's cool, so delete our old string list
	//  and save the pointer to the new string list.
	//
	
	delete _pstrlistExport;
	_pstrlistExport = pstrlst;
    }
    else
    {
	//
	//  Whoops.  The CopyFrom() method must have failed.
	//  Delete our new string list before we bag out.
	//
	
	delete pstrlst;
    }

    return err;

}   // REPLICATOR_0 :: SetExportList


/*******************************************************************

    NAME:	REPLICATOR_0 :: SetImportPath

    SYNOPSIS:	This method will set the replicator's Import path.

    ENTRY:	pszImportPath		- The new Import path.

    RETURNS:	APIERR			- Any errors encountered.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPLICATOR_0 :: SetImportPath( const TCHAR * pszImportPath )
{
    UIASSERT( pszImportPath != NULL );

    return _nlsImportPath.CopyFrom( pszImportPath );

}   // REPLICATOR_0 :: SetImportPath


/*******************************************************************

    NAME:	REPLICATOR_0 :: SetImportList

    SYNOPSIS:	This method will set the replicator's Import list.
		This is the list of computers & domains to which
		files should be replicated.  Items within this
		list must be separated by semicolons (;).

    ENTRY:	pszImportList		- The new Import list.

    RETURNS:	APIERR			- Any errors encountered.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPLICATOR_0 :: SetImportList( const TCHAR * pszImportList )
{
    //
    //  Create a new string list.
    //

    STRLIST * pstrlst = new STRLIST( pszImportList, SZ(";") );
    APIERR    err = ( pstrlst == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
					: NERR_Success;

    if( err == NERR_Success )
    {
	//
	//  Now that we've got a new string list, update the
	//  "plain text" representation.
	//
	
	err = _nlsImportList.CopyFrom( pszImportList );
    }

    if( err == NERR_Success )
    {
	//
	//  Everything's cool, so delete our old string list
	//  and save the pointer to the new string list.
	//
	
	delete _pstrlistImport;
	_pstrlistImport = pstrlst;
    }
    else
    {
	//
	//  Whoops.  The CopyFrom() method must have failed.
	//  Delete our new string list before we bag out.
	//
	
	delete pstrlst;
    }

    return err;

}   // REPLICATOR_0 :: SetImportList


/*******************************************************************

    NAME:	REPLICATOR_0 :: SetLogonUserName

    SYNOPSIS:	This method will set the user name the replicator
		Importer will use when logging onto an Exporter.

    ENTRY:	pszLogonUserName	- The new logon user name.

    RETURNS:	APIERR			- Any errors encountered.

    HISTORY:
	KeithMo	    20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPLICATOR_0 :: SetLogonUserName( const TCHAR * pszLogonUserName )
{
    UIASSERT( pszLogonUserName != NULL );

    return _nlsLogonUserName.CopyFrom( pszLogonUserName );

}   // REPLICATOR_0 :: SetLogonUserName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmoshare.cxx ===
/**********************************************************************/
/**                     Microsoft NT Windows 			     **/
/**		Copyright(c) Microsoft Corp., 1991	             **/
/**********************************************************************/

/*
 *  lmoshare.cxx
 *
 *  This file contains the implementation of share classes.
 *
 *  HISTORY:
 *	t-yis	8/9/91		Created
 *	rustanl 8/27/91 	Changed CloneFrom param from * to &
 *	terryk	10/7/91		types change for NT
 *	KeithMo	10/8/91		Now includes LMOBJP.HXX.
 *	terryk	10/17/91	WIN 32 conversion
 *	terryk	10/21/91	WIN 32 conversion
 *	jonn	10/31/91	Removed SetBufferSize
 *      Yi-HsinS 12/9/91        Remove SetPath in cloneFrom and I_GetInfo
 *				because we don't need to do extra validation.
 *      Yi-HsinS 1/21/92        Remove the strupr of password and move it
 *			        to the UI level.
 *      Yi-HsinS 11/20/92       Add fNew to SetWriteBuffer
 *
 */
#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:	SHARE::SHARE

    SYNOPSIS:	constructor for the SHARE object

    ENTRY:	pszShareName  -	share name
            	pszServerName -	server name
				default (NULL) means the local computer

    EXIT:	Object is constructed, validation is done

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

SHARE::SHARE( const TCHAR *pszShareName,
              const TCHAR *pszServerName,
              BOOL fValidate )
	: LOC_LM_OBJ( pszServerName, fValidate ),
	  _nlsShareName()
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    // Validate share name, server name is validated in LOC_LM_OBJ
    if ( ( err = SetName( pszShareName )) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:	SHARE::~SHARE

    SYNOPSIS:	Destructor for SHARE class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE::~SHARE()
{
}


/*******************************************************************

    NAME:	SHARE::SetName

    SYNOPSIS:	Set the name of the share ( used in
                creating a new share )

    ENTRY:	pszShareName  -	share name

    EXIT:	Return an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE::SetName( const TCHAR *pszShareName )
{
    APIERR err = NERR_Success;

    if ( pszShareName != NULL )
    {
        if ( IsValidationOn() )
            err = ::I_MNetNameValidate( NULL, pszShareName, NAMETYPE_SHARE, 0L);

        if ( err == NERR_Success )
        {
  	    _nlsShareName.CopyFrom( pszShareName );
	    if ( (err = _nlsShareName.QueryError()) != NERR_Success )
	        _nlsShareName.Reset();
        }
    }

    return err;

}

/*******************************************************************

    NAME:	SHARE::W_CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share - reference to the SHARE to copy from

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE::W_CloneFrom( const SHARE & share )
{

    APIERR err = LOC_LM_OBJ::W_CloneFrom( share );

    // Don't want to call SetName because we don't need to validate the name
    // The name is validated when constructing share
    _nlsShareName = share.QueryName();

    if (   ( err != NERR_Success )
       || (( err = _nlsShareName.QueryError() ) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE::W_CreateNew

    SYNOPSIS:	Set up default new share

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE::W_CreateNew( VOID )
{

    APIERR err = LOC_LM_OBJ::W_CreateNew();
    if ( err != NERR_Success )
    {
        return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE::I_Delete

    SYNOPSIS:	Delete the share

    EXIT:	Returns an API error code

    NOTE:       usForce is ignored

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/
APIERR SHARE::I_Delete( UINT uiForce )
{

    UNREFERENCED( uiForce );

    // The last parameter in NetShareDel is not the force, it is
    //  reserved and has to be zero.
    return ::MNetShareDel( QueryServer(), QueryName(), 0);

}

/*******************************************************************

    NAME:	SHARE_1::SHARE_1

    SYNOPSIS:	Constructor for SHARE_1 class

    ENTRY:	pszShareName - share name
                pszServerName -	server name to execute on
		                default (NULL) means the logon domain

    EXIT:	Object is constructed

    NOTES:      share name and server name are validated in parent classes

    CAVEATS:	

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE_1::SHARE_1( const TCHAR *pszShareName,
                  const TCHAR *pszServerName,
                  BOOL fValidate )
	: SHARE( pszShareName, pszServerName, fValidate ),
          _uResourceType( (UINT)-1 ), // initialized to invalid value
          _fAdminOnly( FALSE ),
	  _nlsComment()
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err = _nlsComment.QueryError();
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

}

/*******************************************************************

    NAME:	SHARE_1::~SHARE_1

    SYNOPSIS:	Destructor for SHARE_1 class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE_1::~SHARE_1()
{
}


/*******************************************************************

    NAME:	SHARE_1::I_GetInfo

    SYNOPSIS:	Get the information about the share

    ENTRY:

    EXIT:	Returns a standard LANMAN error code

    HISTORY:
	t-yis	8/9/1991		Created
	jonn	10/31/1991		Removed SetBufferSize

********************************************************************/

APIERR SHARE_1::I_GetInfo( VOID )
{
    BYTE *pBuffer = NULL;
    APIERR err = ::MNetShareGetInfo( QueryServer(), QueryName(), 1,
		    &pBuffer );
    SetBufferPtr( pBuffer );
    if ( err != NERR_Success )
	return err ;

    struct share_info_1 *lpsi1 = (struct share_info_1 *) QueryBufferPtr();
    UIASSERT( lpsi1 != NULL );

#if defined(WIN32)
    SetAdminOnly( (lpsi1->shi1_type & STYPE_SPECIAL) != 0 );
    lpsi1->shi1_type &= ~STYPE_SPECIAL;
#endif

    if (   (( err = SetResourceType( (UINT)lpsi1->shi1_type )) != NERR_Success )
        || (( err = SetComment( lpsi1->shi1_remark )) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE_1::I_WriteInfo

    SYNOPSIS:	Writes information about the share

    EXIT:	Returns API error code

    HISTORY:
	t-yis	    8/9/91	    Created

********************************************************************/

APIERR SHARE_1::I_WriteInfo( VOID )
{

    struct share_info_1 *lpsi1 = (struct share_info_1 *) QueryBufferPtr();
    UIASSERT( lpsi1 != NULL );

    lpsi1->shi1_remark = (TCHAR *) QueryComment();

    return ::MNetShareSetInfo ( QueryServer(),
      	                        QueryName(), 1,
			        QueryBufferPtr(),
			        sizeof( share_info_1 ), PARMNUM_ALL);

}


/*******************************************************************

    NAME:	SHARE_1::CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share1 - reference to the share to copy information from

    EXIT:	Returns an API error code

    NOTES:	W_CloneFrom copies all member objects, but it does not
    		update the otherwise unused pointers in the API buffer.
		This is left for the outermost routine, CloneFrom().
		Only the otherwise unused pointers need to be fixed
		here, the rest will be fixed in WriteInfo/WriteNew.

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE_1::CloneFrom( const SHARE_1 & share1 )
{
    APIERR err = W_CloneFrom( share1 );

    if ( err != NERR_Success )
    {
	ReportError( err );
	return err;
    }

    /*
     *  No unused pointers - don't need to fix up pointers
     */

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_1::W_CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share1 - reference to the share to copy information from

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE_1::W_CloneFrom( const SHARE_1 & share1 )
{

    APIERR err = SHARE::W_CloneFrom( share1 );

    if (   ( err != NERR_Success )
	|| (( err = SetResourceType( share1.QueryResourceType())) != NERR_Success)
	|| (( err = SetComment( share1.QueryComment())) != NERR_Success)
       )
    {
	return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_1::W_CreateNew

    SYNOPSIS:	Sets default on the new share

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE_1::W_CreateNew( VOID )
{

    APIERR err = SHARE::W_CreateNew();

    if ( err != NERR_Success )
    {
	return err;
    }

    _uResourceType = (UINT)(-1);
    _nlsComment = NULL;
    if ( (err = _nlsComment.QueryError()) != NERR_Success )
    {
        return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_1::SetComment

    SYNOPSIS:	Changes the comment set for the share

    ENTRY:      pszComment - comment

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE_1::SetComment( const TCHAR *pszComment )
{

    APIERR err = NERR_Success;

    if ( pszComment != NULL )
    {
        ALIAS_STR nlsComment( pszComment );

        if ( IsValidationOn() )
            err = ::I_MNetNameValidate( NULL, pszComment, NAMETYPE_COMMENT, 0L);

        if ( err == NERR_Success )
        {
            err = _nlsComment.CopyFrom( nlsComment );
            if ( err != NERR_Success )
	        _nlsComment.Reset();
        }
    }

    return err;
}

/*******************************************************************

    NAME:	SHARE_1::SetResourceType

    SYNOPSIS:	Set the share's resource type

    ENTRY:      usResourceType - Type of the share

    EXIT:	error code.

    NOTE:       Used only when creating a new share (SHARE_2)

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE_1::SetResourceType( UINT uResourceType )
{

    if ( IsValidationOn() )
    {
        // Validate Resource Type
        switch ( uResourceType )
        {
            case STYPE_DISKTREE:
            case STYPE_PRINTQ:
            case STYPE_DEVICE:
            case STYPE_IPC:
                 break;

            default:
                 return ERROR_INVALID_PARAMETER;
        }
    }

    _uResourceType = uResourceType;
    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::SHARE_2

    SYNOPSIS:	Constructor for SHARE_2 class

    ENTRY:	pszShareName -	share name
                pszServerName -	server name
                    	        default (NULL) means the local server

    EXIT:	Object is constructed and validated

    NOTES:      Share name and server name are validated in parent classes

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE_2::SHARE_2( const TCHAR *pszShareName,
                  const TCHAR *pszServerName,
                  BOOL fValidate )
	: SHARE_1( pszShareName, pszServerName, fValidate ),
          _uMaxUses( (UINT)-1 ),
          _uCurrentUses(0),
          _fs2lPermissions(0),
	  _nlsPath(),
	  _nlsPassword()
{

    if ( QueryError() != NERR_Success )
    	return;

    APIERR err = NERR_Success;
    if (   (( err = _nlsPath.QueryError()) != NERR_Success )
        || (( err = _nlsPassword.QueryError()) != NERR_Success)
       )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:	SHARE_2::~SHARE_2

    SYNOPSIS:	Destructor for SHARE_2 class

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

SHARE_2::~SHARE_2()
{
    memsetf((LPVOID)_nlsPassword.QueryPch(),
            0,
            _nlsPassword.QueryTextSize()) ;
}


/*******************************************************************

    NAME:	SHARE_2::I_GetInfo

    SYNOPSIS:	Get information about the share

    EXIT:	Returns API error code

    HISTORY:
	t-yis	    8/9/91	    Created
	jonn	    10/31/1991	    Removed SetBufferSize

********************************************************************/

APIERR SHARE_2::I_GetInfo( VOID )
{

    BYTE *pBuffer = NULL;
    APIERR err = ::MNetShareGetInfo ( QueryServer(), QueryName(), 2,
			&pBuffer );
    SetBufferPtr( pBuffer );
    if ( err != NERR_Success )
	return err ;

    struct share_info_2 *lpsi2 = (struct share_info_2 *) QueryBufferPtr();
    UIASSERT( lpsi2 != NULL );

    // Don't want to call SetPath because we don't need to validate the path
    _nlsPath = lpsi2->shi2_path;

#if defined(WIN32)
    SetAdminOnly( (lpsi2->shi2_type & STYPE_SPECIAL) != 0 );
    lpsi2->shi2_type &= ~STYPE_SPECIAL;
#endif

    if (   (( err = _nlsPath.QueryError()) != NERR_Success )
	|| (( err = SetPermissions( (UINT)lpsi2->shi2_permissions )) != NERR_Success )
	|| (( err = SetMaxUses( (UINT)lpsi2->shi2_max_uses )) != NERR_Success )
	|| (( err = SetCurrentUses( (UINT)lpsi2->shi2_current_uses )) != NERR_Success )
	|| (( err = SetPassword( lpsi2->shi2_passwd )) != NERR_Success )
	|| (( err = SetResourceType( (UINT)lpsi2->shi2_type)) != NERR_Success )
	|| (( err = SetComment( lpsi2->shi2_remark )) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE_2::I_CreateNew

    SYNOPSIS:	Sets up object for subsequent WriteNew

    EXIT:	Returns a standard LANMAN error code

    NOTES:	Name validation and memory allocation are done
		at this point, not at construction.  The string-valued
		fields are only valid in the NLS_STR members and are not
		valid in the buffer until WriteNew.

    HISTORY:
	t-yis    8/9/91	    Created
        JonN    05/08/92    Calls ClearBuffer()

********************************************************************/

APIERR SHARE_2::I_CreateNew( VOID )
{

    APIERR err = NERR_Success;

    if (   (( err = W_CreateNew()) != NERR_Success )
	|| (( err = ResizeBuffer( sizeof( share_info_2 ))) != NERR_Success )
	|| (( err = ClearBuffer()) != NERR_Success )
       )
    {
	return err;
    }

    struct share_info_2 *lpsi2 = (struct share_info_2 *) QueryBufferPtr();
    UIASSERT( lpsi2 != NULL );

    /*
     *  All fields of user_info_2 are listed here.  All are commented
     *  out because the effective values are stored in an NLS_SLR or
     *  other data member
     */

    // lpsi2->shi2_netname = _nlsShareName.QueryPch();
    // lpsi2->shi2_type = _uResourceType;
    // lpsi2->shi2_remark = _nlsComment.QueryPch();
    // lpsi2->shi2_permissions = _fsPermissions;
    // lpsi2->shi2_max_uses = _usMaxUses;
    // lpsi2->shi2_current_uses = _usCurrentUses;
    // lpsi2->shi2_path = _nlsPath.QueryPch();
    // lpsi2->shi2_passwd = _nlsPassword.QueryPch();

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::W_CreateNew

    SYNOPSIS:	Sets default on the new share

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created

********************************************************************/

APIERR SHARE_2::W_CreateNew( VOID )
{

    APIERR err = SHARE_1::W_CreateNew();

    if ( err != NERR_Success )
    {
	return err;
    }

    // The following statements sets the values of data members
    // We bypass the set methods so that we could assign invalid values

    _fs2lPermissions = 0;
    // 0xFFFF = -1 in unsigned short, use 0xFFFF to get rid of warnings
    _uMaxUses = (UINT)-1;
    _uCurrentUses = 0;
    _nlsPath = NULL;
    _nlsPassword = NULL;

    if (   ((err = _nlsPath.QueryError()) != NERR_Success )
        || ((err = _nlsPassword.QueryError()) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share2 - reference to the share to copy info. from

    EXIT:	Returns an API error code

    NOTES:	W_CloneFrom copies all member objects, but it does not
    		update the otherwise unused pointers in the API buffer.
		This is left for the outermost routine, CloneFrom().
		Only the otherwise unused pointers need to be fixed
		here, the rest will be fixed in WriteInfo/WriteNew.

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE_2::CloneFrom( const SHARE_2 & share2 )
{

    APIERR err = W_CloneFrom( share2 );

    if ( err != NERR_Success )
    {
	ReportError( err );
	return err;
    }

    /*
     *  No unused pointers - don't need to fix up pointers
     */

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE_2::W_CloneFrom

    SYNOPSIS:	Copies information on the share

    ENTRY:	share2 - reference to the share to copy info. from

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	8/9/91		Created
	rustanl 8/27/91 	Changed param from * to &

********************************************************************/

APIERR SHARE_2::W_CloneFrom( const SHARE_2 & share2 )
{

    APIERR err = SHARE_1::W_CloneFrom( share2 );

    // Don't want to call SetPath because we don't need to validate the path
    _nlsPath = share2.QueryPath();

    if (   ( err != NERR_Success )
	|| (( err = _nlsPath.QueryError()) != NERR_Success)
	|| (( err = SetPermissions( share2.QueryPermissions())) != NERR_Success)
	|| (( err = SetMaxUses( share2.QueryMaxUses())) != NERR_Success)
	|| (( err = SetCurrentUses( share2.QueryCurrentUses())) != NERR_Success)
	|| (( err = SetPassword( share2.QueryPassword())) != NERR_Success)
       )
    {
	return err;
    }

    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::SetWriteBuffer

    SYNOPSIS:	Helper function for WriteNew and WriteInfo -- loads
		current values into the API buffer

    ENTRY:      fNew - TRUE if we are creating a new share, FALSE otherwise

    EXIT:	Returns API error code

    HISTORY:
	t-yis    8/9/91	    Created

********************************************************************/

APIERR SHARE_2::SetWriteBuffer( BOOL fNew )
{

    struct share_info_2 *lpsi2 = (struct share_info_2 *) QueryBufferPtr();
    UIASSERT( lpsi2 != NULL );

    // If no share name is null, return error
    // Share name is validated in SetName() already
    if ( QueryName() == NULL )
       return ERROR_INVALID_PARAMETER;

    // shi2_netname is a array within share_info_2 rather than a pointer
    COPYTOARRAY( lpsi2->shi2_netname, (TCHAR *)QueryName() );

    lpsi2->shi2_type = QueryResourceType();
    lpsi2->shi2_permissions = QueryPermissions();
    lpsi2->shi2_max_uses = QueryMaxUses();
    lpsi2->shi2_path = (TCHAR *) QueryPath();

    lpsi2->shi2_remark = (TCHAR *) QueryComment();

    // When creating a new share ( fNew is true), we need to pass
    // NULL instead of empty string as comment because of ADMIN$ and IPC$.
    // However, when clearing the comment via NetShareSetInfo, an
    // empty string needs to be passed instead of NULL.

    if ( fNew )
    {
        ALIAS_STR nls( lpsi2->shi2_remark );
        if ( nls.QueryTextLength() == 0 )
            lpsi2->shi2_remark = NULL;
    }

    // password is validated in SetPassword(), so don't need to validate again
    // NULL password is acceptable.

    // shi2_passwd is an array within share_info_2  rather than a pointer
    COPYTOARRAY( lpsi2->shi2_passwd, (TCHAR *)QueryPassword() );

    return NERR_Success;

}


/*******************************************************************

    NAME:	SHARE_2::I_WriteInfo

    SYNOPSIS:	Writes information about the share

    EXIT:	Returns API error code

    HISTORY:
	t-yis	    8/9/91	    Created

********************************************************************/

APIERR SHARE_2::I_WriteInfo( VOID )
{

    APIERR err = SetWriteBuffer( FALSE );
    if ( err != NERR_Success )
        return err;

    return ::MNetShareSetInfo ( QueryServer(),
               		        QueryName(), 2,
			        QueryBufferPtr(),
			        sizeof( share_info_2 ), PARMNUM_ALL);

}


/*******************************************************************

    NAME:	SHARE_2::I_WriteNew

    SYNOPSIS:	Creates a new share

    ENTRY:

    EXIT:	Returns an API error code

    NOTES:	

    HISTORY:
	t-yis	    8/9/91	    Created

********************************************************************/

APIERR SHARE_2::I_WriteNew( VOID )
{

    APIERR err = SetWriteBuffer( TRUE );
    if ( err != NERR_Success )
	return err;

    return ::MNetShareAdd ( QueryServer(), 2,
			    QueryBufferPtr(),
			    sizeof( struct share_info_2 ));

}


/*******************************************************************

    NAME:	SHARE_2::SetPermissions

    SYNOPSIS:	Set the permissions of the share

    ENTRY:	fs2lPermissions -	permissions

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetPermissions( UINT fs2lPermissions )
{

    // Validate Permissions
    if ( IsValidationOn() )
    {
        if ( (fs2lPermissions & ACCESS_ALL) > ACCESS_ALL )
            return ERROR_INVALID_PARAMETER;
    }

    _fs2lPermissions = fs2lPermissions;
    return NERR_Success;

}

/*******************************************************************

    NAME:	SHARE_2::SetMaxUses

    SYNOPSIS:	Set the maximum concurrent connections allowed
                on the share

    ENTRY:	usMaxUses - maximum uses

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetMaxUses( UINT uMaxUses )
{
    _uMaxUses = uMaxUses;
    return NERR_Success;
}

/*******************************************************************

    NAME:	SHARE_2::SetCurrentUses

    SYNOPSIS:	Set the current number of connections
                This value is ignored in WriteInfo/WriteNew

    ENTRY:	uCurrentUses - current uses

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetCurrentUses( UINT uCurrentUses )
{
    _uCurrentUses = uCurrentUses;
    return NERR_Success;
}

/*******************************************************************

    NAME:	SHARE_2::SetPath

    SYNOPSIS:	Set the local path name of the share

    ENTRY:	pszPath - local path

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetPath( const TCHAR *pszPath )
{


    ALIAS_STR nlsPath( pszPath );
    APIERR err = NERR_Success;

    if ( IsValidationOn() )
    {
        ULONG ulType; // ulType is not used, it's just a place holder
        if ( nlsPath.QueryTextLength() != 0 )
            err = ::I_MNetPathType( NULL, pszPath, &ulType, 0L);
    }

    if ( err == NERR_Success)
    {
        _nlsPath = nlsPath;

        err = _nlsPath.QueryError();
        if ( err != NERR_Success )
            _nlsPath.Reset();
    }

    return err;
}

/*******************************************************************

    NAME:	SHARE_2::SetPassword

    SYNOPSIS:	Set the password of the share on share-level server

    ENTRY:	pszPassword  - password

    EXIT:	Returns an API error code

    HISTORY:
	t-yis	 8/9/91		Created	

********************************************************************/

APIERR SHARE_2::SetPassword( const TCHAR *pszPassword )
{
    APIERR err = NERR_Success;

    if ( pszPassword != NULL )
    {
        if ( IsValidationOn() )
        {
            err = ::I_MNetNameValidate( NULL, pszPassword,
                                        NAMETYPE_SHAREPASSWORD, 0L);
        }

        if ( err == NERR_Success )
   	{
	    ALIAS_STR nlsPassword( pszPassword );
	    err = _nlsPassword.CopyFrom( nlsPassword );
	    if ( err != NERR_Success )
		_nlsPassword.Reset();
	}
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmosrv.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmosrv.cxx
    Class definitions for the SERVER_0, SERVER_1, and SERVER_2 classes.

    The SERVER_x classes are used to manipulate servers.  The classes
    are structured as follows:

        LOC_LM_OBJ
            SERVER_0
                SERVER_1
                    SERVER_2


    FILE HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        RustanL     10-Dec-1990 Added meat for SERVER_0
        KevinL      08-Jan-1991 Added SERVER_TYPE
        BenG        11-Feb-1991 Uses lmui.hxx
        ChuckC      20-Mar-1991 Cleanup construction/GetInfo
        KeithMo     01-May-1991 Added QueryDomainRole to SERVER_2
                                and SERVER_TYPE.
        KevinL      12-Aug-1991 Made SERVER_2 provide SERVER_1 funcs.
        TerryK      18-Sep-1991 Change COMPUTER's parent class to
                                LOC_LM_OBJ
        TerryK      29-Sep-1991 Add nlsComment field to the server
                                objects
        TerryK      30-Sep-1991 Code review change. Attend: jonn
                                keithmo terryk
        KeithMo     02-Oct-1991 Removed QueryDomainRole() methods.
        TerryK      07-Oct-1991 types change for NT
        KeithMo     08-Oct-1991 Now includes LMOBJP.HXX.
        TerryK      10-Oct-1991 WIN 32 conversion
        TerryK      21-Oct-1991 change UINT to USHORT2ULONG
        JonN        31-Oct-1991 Removed SetBufferSize
        KeithMo     25-Nov-1991 Rewrote almost everything.
        KeithMo     04-Dec-1991 Code review changes (from 12/04,
                                Beng, EricCh, KeithMo, TerryK).
        KeithMo     08-Sep-1992 Fixed problems with long server names.

*/

#include "pchlmobj.hxx"  // Precompiled header


//
//  IBM Lan Server version number
//

#define CURRENT_MAJOR_VER 2
#define IBMLS_MAJ         1
#define IBMLS_MIN         2


//
//  SERVER_0 methods
//

/*******************************************************************

    NAME:       SERVER_0 :: SERVER_0

    SYNOPSIS:   SERVER_0 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      18-Sep-1991 Remove MakeConstruction
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_0 :: SERVER_0( const TCHAR * pszServerName )
  : LOC_LM_OBJ( pszServerName )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // SERVER_0 :: SERVER_0


/*******************************************************************

    NAME:       SERVER_0 :: ~SERVER_0

    SYNOPSIS:   SERVER_0 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_0 :: ~SERVER_0( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SERVER_0 :: ~SERVER_0


/*******************************************************************

    NAME:       SERVER_0 :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxGetInfo API (info-level 0).

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.  For SERVER_0, there is no data
                to cache.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      18-Sep-1991 change GetInfo to I_GetInfo
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_0 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.  Note that the mapping layer will allocate
    //  the buffer for us.  We must free this buffer before we
    //  return the API result.
    //

    APIERR err = ::MNetServerGetInfo( QueryName(),
                                      SERVER_INFO_LEVEL( 0 ),
                                      &pbBuffer );

    ::MNetApiBufferFree( &pbBuffer );

    return err;

}   // SERVER_0 :: I_GetInfo



//
//  SERVER_1 methods
//

/*******************************************************************

    NAME:       SERVER_1 :: SERVER_1

    SYNOPSIS:   SERVER_1 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      18-Sep-1991 Remove MakeConstruction
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_1 :: SERVER_1( const TCHAR * pszServerName )
  : SERVER_0( pszServerName ),
    _nMajorVer( 0 ),
    _nMinorVer( 0 ),
    _lServerType( 0 ),
    _nlsComment()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsComment )
    {
        ReportError( _nlsComment.QueryError() );
        return;
    }

}   // SERVER_1 :: SERVER_1


/*******************************************************************

    NAME:       SERVER_1 :: ~SERVER_1

    SYNOPSIS:   SERVER_1 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Remove delete pBuffer
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_1 :: ~SERVER_1( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SERVER_1 :: ~SERVER_1


/*******************************************************************

    NAME:       SERVER_1 :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxGetInfo API (info-level 1).

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.  For SERVER_1, this includes the
                major/minor versions, server type, and server comment.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Change GetInfo to I_GetInfo
        jonn        13-Oct-1991 Removed SetBufferSize
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_1 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.
    //

    APIERR err = ::MNetServerGetInfo( QueryName(),
                                      SERVER_INFO_LEVEL( 1 ),
                                      &pbBuffer );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    struct server_info_1 * psi1 = (struct server_info_1 *)pbBuffer;

    //
    //  Extract the major/minor version numbers.
    //

    SetMajorMinorVer( (UINT)( psi1->sv1_version_major & MAJOR_VERSION_MASK ),
                      (UINT)( psi1->sv1_version_minor ) );

    //
    //  Extract the server type.
    //

    SetServerType( psi1->sv1_type );

    //
    //  Save away the server comment.  Note that this may fail.
    //

    return SetComment( psi1->sv1_comment );

}   // SERVER_1 :: I_GetInfo


/*******************************************************************

    NAME:       SERVER_1 :: I_WriteInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxSetInfo API (info-level 1).

    EXIT:       If successful, the target server has been updated.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Change WriteInfo to I_WriteInfo
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_1 :: I_WriteInfo( VOID )
{
    //
    //  Update the server_info_1 structure.
    //

    APIERR err = W_Write();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Invoke the API to do the actual server update.
    //

    return ::MNetServerSetInfo ( QueryServer(),
                                 SERVER_INFO_LEVEL( 1 ),
                                 QueryBufferPtr(),
                                 sizeof( struct server_info_1 ),
                                 PARMNUM_ALL );

}   // SERVER_1 :: I_WriteInfo


/*******************************************************************

    NAME:       SERVER_1 :: W_Write

    SYNOPSIS:   Helper function for WriteNew and WriteInfo -- loads
                current values into the API buffer.

    EXIT:       The API buffer has been filled.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        TerryK      19-Sep-1991 Created.
        DavidHov    28-May-1992 Changed to allow for NULL server name

********************************************************************/
APIERR SERVER_1 :: W_Write( VOID )
{
    const TCHAR * pszServer = QueryName() ;
    struct server_info_1 * psi1 = (struct server_info_1 *)QueryBufferPtr();

    ASSERT( psi1 != NULL );

    if ( pszServer )
    {
        ASSERT( ::strlenf(pszServer) <= MAX_PATH );

        COPYTOARRAY( psi1->sv1_name, (TCHAR *) pszServer );
    }

    psi1->sv1_version_major = QueryMajorVer();
    psi1->sv1_version_minor = QueryMinorVer();
    psi1->sv1_type          = QueryServerType();
    psi1->sv1_comment       = (TCHAR *)QueryComment();

    return NERR_Success;

}   // SERVER_1 :: W_Write


/*******************************************************************

    NAME:       SERVER_1 :: QueryMajorVer

    SYNOPSIS:   Returns the major version of the target server.

    RETURNS:    UINT                    - The major version number.

    NOTES:      This method will return zero if the SERVER_1 object
                was not constructed properly.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 use CHECK_OK macro

********************************************************************/
UINT SERVER_1 :: QueryMajorVer( VOID ) const
{
    CHECK_OK( 0 );

    return _nMajorVer;

}   // SERVER_1 :: QueryMajorVer


/*******************************************************************

    NAME:       SERVER_1 :: QueryMinorVer

    SYNOPSIS:   Returns the minor version of the target server.

    RETURNS:    UINT                    - The minor version number.

    NOTES:      This method will return zero if the SERVER_1 object
                was not constructed properly.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 use CHECK_OK macro

********************************************************************/
UINT SERVER_1 :: QueryMinorVer( VOID ) const
{
    CHECK_OK( 0 );

    return _nMinorVer;

}   // SERVER_1 :: QueryMinorVer


/*******************************************************************

    NAME:       SERVER_1 :: QueryComment

    SYNOPSIS:   Returns the target server's comment.

    RETURNS:    const TCHAR *           - The target server's comment.

    NOTES:      This method will return NULL if the SERVER_1 object
                was not constructed properly.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 use CHECK_OK macro

********************************************************************/
const TCHAR * SERVER_1 :: QueryComment( VOID ) const
{
    CHECK_OK( NULL );

    return _nlsComment.QueryPch();

}   // SERVER_1 :: QueryMinorVer


/*******************************************************************

    NAME:       SERVER_1 :: QueryServerType

    SYNOPSIS:   Returns the target server's type vector.

    RETURNS:    ULONG                   - The target server's type vector.

    NOTES:      This method will return zero if the SERVER_1 object
                was not constructed properly.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 use CHECK_OK macro

********************************************************************/
ULONG SERVER_1 :: QueryServerType( VOID ) const
{
    CHECK_OK( 0 );

    return _lServerType;

}   // SERVER_1 :: QueryServerType


/*******************************************************************

    NAME:       SERVER_1::SetComment

    SYNOPSIS:   Sets the target server's comment.

    ENTRY:      pszComment              - The new comment.

    RETURNS:    APIERR                  - Error for setting the comment.

    HISTORY:
        TerryK      30-Sep-1991 Created

********************************************************************/
APIERR SERVER_1 :: SetComment( const TCHAR * pszComment )
{
    CHECK_OK( ERROR_GEN_FAILURE );

    return _nlsComment.CopyFrom( pszComment );

}   // SERVER_1 :: SetComment


/*******************************************************************

    NAME:       SERVER_1 :: SetMajorMinorVer

    SYNOPSIS:   This protected method will set the _nMajorVer and
                _nMinorVer members to the specified values.

    ENTRY:      uMajorVer               - The new major version number.

                uMinorVer               - The new minor version number.

    NOTES:      This method may only be called by derived subclases.

    HISTORY:
        KeithMo     25-Nov-1991 Created.
        KeithMo     04-Dec-1992 Nuked IBM LanServer & downlevel hacks.

********************************************************************/
VOID SERVER_1 :: SetMajorMinorVer( UINT nMajorVer, UINT nMinorVer )
{
    _nMajorVer = nMajorVer;
    _nMinorVer = nMinorVer;

#if 0
    //
    //  Do we really care about IBM LanServers and LM 1.0 machines??
    //  This logic screws up Window for Workgroup servers, which
    //  return version 1.5.
    //

    if( _nMajorVer < CURRENT_MAJOR_VER )
    {
        if( ( _nMajorVer >= IBMLS_MAJ ) && ( _nMinorVer >= IBMLS_MIN ) )
        {
            _nMajorVer = 2;
            _nMinorVer = 0;
        }
        else
        {
            _nMajorVer = 1;
            _nMinorVer = 0;
        }
    }
#endif

}   // SERVER_1 :: SetMajorVer


/*******************************************************************

    NAME:       SERVER_1 :: SetServerType

    SYNOPSIS:   This protected method will set the _lServerType data
                member to the specified value.

    ENTRY:      ulServerType            - The new server type vector.

    NOTES:      This method may only be called by derived subclases.

    HISTORY:
        KeithMo     25-Nov-1991 Created.

********************************************************************/
VOID SERVER_1 :: SetServerType( ULONG lServerType )
{
    _lServerType = lServerType;

}   // SERVER_1 :: SetServerType



//
//  SERVER_2 methods
//

/*******************************************************************

    NAME:       SERVER_2 :: SERVER_2

    SYNOPSIS:   SERVER_2 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

    EXIT:       The object is constructed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Remove MakeConstructed
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_2 :: SERVER_2( const TCHAR * pszServerName )
  : SERVER_1( pszServerName ),
    _nSecurity( 0 )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // SERVER_2 :: SERVER_2


/*******************************************************************

    NAME:       SERVER_2 :: ~SERVER_2

    SYNOPSIS:   SERVER_2 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
SERVER_2 :: ~SERVER_2( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SERVER_2 :: ~SERVER_2


/*******************************************************************

    NAME:       SERVER_2 :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxGetInfo API (info-level 2).

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.  For SERVER_2, this includes the
                major/minor versions, server type, server comment,
                and security type.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        KeithMo     01-May-1991 Added code to determine domain role.
        TerryK      19-Sep-1991 Change GetInfo to I_GetInfo
        KeithMo     02-Oct-1991 Removed QueryDomainRole method.
        jonn        13-Oct-1991 Removed SetBufferSize
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_2 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.
    //

    APIERR err = ::MNetServerGetInfo( QueryName(),
                                      SERVER_INFO_LEVEL( 2 ),
                                      &pbBuffer );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    struct server_info_2 * psi2 = (struct server_info_2 *)pbBuffer;

    //
    //  Extract the major/minor version numbers.
    //

    SetMajorMinorVer( (UINT)( psi2->sv2_version_major & MAJOR_VERSION_MASK ),
                      (UINT)( psi2->sv2_version_minor ) );

    //
    //  Extract the server type.
    //

    SetServerType( psi2->sv2_type );

    //
    //  Save away the server comment.  Note that this may fail.
    //

    err = SetComment( psi2->sv2_comment );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Extract the security type.
    //

#if defined( WIN32 )

    //
    //  In their on-going efforts to add needless complexity to our
    //  lives, the designers of the Win32 network API have decided
    //  to split the old server_info_x structures into a number of
    //  separate SERVER_INFO_xxx structures.  Unfortunately (for us)
    //  the "security" field is in a separate structure whose info-
    //  level depends on the target machines platform ID.  Ergo, we
    //  must decipher the platform ID, issue an appropriate API
    //  info-level, and interpret the results.  Ack!  Pfft!!!
    //

    switch( psi2->sv102_platform_id )
    {
    case SV_PLATFORM_ID_OS2 :
        //
        //  OS/2 servers can be either user or share security.
        //

        //
        //  The following MNetServerGetInfo will perform an infolevel 402
        //  getinfo.  The number 402 can be derived by SV_PLADFORM_ID + 2.
        //  The SERVER_INFO_402 structure contains platform-specific info
        //  for OS/2 servers.  The security field is held in this structure.
        //

        err = ::MNetServerGetInfo( QueryName(),
                                   402,
                                   &pbBuffer );

        if( err != NERR_Success )
        {
            return err;
        }

        SetSecurity( (UINT)(((SERVER_INFO_402 *)pbBuffer)->sv402_security) );

        ::MNetApiBufferFree( &pbBuffer );
        break;

    case SV_PLATFORM_ID_NT :
        //
        //  NT servers are always (for the moment...) user security.
        //

        SetSecurity( SV_USERSECURITY );
        break;

    default :
        //
        //  Hmm...  This should probably never happen, but we should
        //  set the security field to something reasonable.
        //

#ifdef TRACE
        UITRACE( SZ("Got invalid platform ID : ") );
        UITRACENUM( (LONG)psi2->sv102_platform_id );
        UITRACE( SZ(", assuming security = SHARE\n\r") );
#endif

        SetSecurity( (UINT)SV_SHARESECURITY );
        break;
    }

#else   // !WIN32

    //
    //  Since we not running Win32, we can just extract
    //  the security field from the server_info_2 structure.
    //

    SetSecurity( psi2->sv2_security );

#endif  // WIN32

    SetMaxUsers( psi2->sv2_users );

    return NERR_Success;

}   // SERVER_2 :: I_GetInfo


/*******************************************************************

    NAME:       SERVER_2 :: I_WriteInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxSetInfo API (info-level 2).

    EXIT:       If successful, the target server has been updated.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Change WriteInfo to I_WriteInfo
        KeithMo     25-Nov-1991 Recreated in the new class structure.

********************************************************************/
APIERR SERVER_2 :: I_WriteInfo( VOID )
{
    //
    //  Update the server_info_2 structure.
    //

    APIERR err = W_Write();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Invoke the API to do the actual server update.
    //

    return ::MNetServerSetInfo ( QueryServer(),
                                 SERVER_INFO_LEVEL( 2 ),
                                 QueryBufferPtr(),
                                 sizeof( struct server_info_2 ),
                                 PARMNUM_ALL );

}   // SERVER_2 :: I_WriteInfo


/*******************************************************************

    NAME:       SERVER_2 :: W_Write

    SYNOPSIS:   Helper function for WriteNew and WriteInfo -- loads
                current values into the API buffer.

    EXIT:       The API buffer has been filled.

    RETURNS:    APIERR                  - The result of the API.

    NOTES:      As currently written, this method will *NOT* update
                the target server's security field if this code is
                running under Win32.

    HISTORY:
        TerryK      19-Sep-1991 Created.
        DavidHov    28-May-1992 Changed to allow for NULL server name

********************************************************************/
APIERR SERVER_2 :: W_Write( VOID )
{
    const TCHAR * pszServer = QueryName() ;
    struct server_info_2 * psi2 = (struct server_info_2 *)QueryBufferPtr();

    ASSERT( psi2 != NULL );

    if ( pszServer )
    {
        ASSERT( ::strlenf(pszServer) <= MAX_PATH );

        COPYTOARRAY( psi2->sv2_name, (TCHAR *) pszServer );
    }

    psi2->sv2_version_major = QueryMajorVer();
    psi2->sv2_version_minor = QueryMinorVer();
    psi2->sv2_type          = QueryServerType();
    psi2->sv2_comment       = (TCHAR *)QueryComment();

#if !defined( WIN32 )
    psi2->sv2_security      = QuerySecurity();
#endif  // WIN32

    psi2->sv2_users         = QueryMaxUsers();

    return NERR_Success;

}   // SERVER_2 :: W_Write


/*******************************************************************

    NAME:       SERVER_2 :: QuerySecurity

    SYNOPSIS:   Returns the target server's security type (either
                SV_SHARESECURITY or SV_USERSECURITY).

    RETURNS:    UINT                    - The target server's security
                                          type.

    NOTES:      This method will return SV_SHARESECURITY if the
                SERVER_2 object was not properly constructed.

    HISTORY:
        ChuckC      07-Dec-1990 Created stubs
        TerryK      19-Sep-1991 Use CHECK_OK macro

********************************************************************/
UINT SERVER_2 :: QuerySecurity( VOID ) const
{
    CHECK_OK ( SV_SHARESECURITY );

    return _nSecurity;

}   // SERVER_2 :: QuerySecurity


/*******************************************************************

    NAME:       SERVER_2 :: SetSecurity

    SYNOPSIS:   This protected method will set the target server's
                security type (either SV_SHARESECURITY or
                SV_USERSECURITY).

    ENTRY:      uSecurity               - The target server's new
                                          security type.

    NOTES:      This method may only be called by derived subclases.

    HISTORY:
        KeithMo     25-Nov-1991 Created.

********************************************************************/
VOID SERVER_2 :: SetSecurity( UINT uSecurity )
{
    _nSecurity = uSecurity;

}   // SERVER_2 :: SetSecurity


/*******************************************************************

    NAME:       SERVER_2 :: QueryMaxUsers

    SYNOPSIS:   Queries the maximum number of users allowed by the server

    RETURNS:    UINT                    - The target server's max # of users

    HISTORY:
        BruceFo     26-Sep-1995 Created

********************************************************************/
UINT SERVER_2 :: QueryMaxUsers( VOID ) const
{
    return _nMaxUsers;

}   // SERVER_2 :: QueryMaxUsers


/*******************************************************************

    NAME:       SERVER_2 :: SetMaxUsers

    SYNOPSIS:   Sets the maximum number of users allowed by the server. Note
                that the server allows you to set it to anything, but on
                reboot, the server will reset the number to be <= its maximum
                session count.

    ENTRY:      uMaxUsers       - The target server's new max number of users

    NOTES:      This method may only be called by derived subclases.

    HISTORY:
        BruceFo     26-Sep-1995 Created

********************************************************************/
VOID SERVER_2 :: SetMaxUsers( UINT uMaxUsers )
{
    _nMaxUsers = uMaxUsers;

}   // SERVER_2 :: SetMaxUsers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmoreple.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmoreple.hxx
    Class definitions for the REPL_EDIR_BASE and REPL_EDIR_x classes.

    REPL_EDIR_BASE is an abstract superclass that contains common methods
    and data members shared between the REPL_EDIR_x classes.

    The REPL_EDIR_x classes each represent a different info-level "view"
    of an exported directory in the Replicator's export path.

    The classes are structured as follows:

        LOC_LM_OBJ
        |
        \---REPL_DIR_BASE
            |
            +---REPL_EDIR_BASE
                |
                \---REPL_EDIR_0
                    |
                    \---REPL_EDIR_1
                        |
                        \---REPL_EDIR_2

    NOTE:   While MNetReplExportDirGetInfo() may use any valid info-level
            (0 - 2), MNetReplExportDirSetInfo() and MNetReplExportDirAdd()
            may only use info-level 1.

    FILE HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

*/

#include "pchlmobj.hxx"  // Precompiled header


//
//  These are default values used during CreateNew operations.
//

#define DEFAULT_INTEGRITY       REPL_INTEGRITY_TREE
#define DEFAULT_EXTENT          REPL_EXTENT_TREE
#define DEFAULT_LOCK_COUNT      0
#define DEFAULT_LOCK_TIME       0



//
//  REPL_EDIR_BASE methods
//

/*******************************************************************

    NAME:       REPL_EDIR_BASE :: REPL_EDIR_BASE

    SYNOPSIS:   REPL_EDIR_BASE class constructor.

    ENTRY:      pszServerName           - Name of the target server.

                pszDirName              - Name of the exported/imported
                                          directory.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_EDIR_BASE :: REPL_EDIR_BASE( const TCHAR * pszServerName,
                                  const TCHAR * pszDirName )
  : REPL_DIR_BASE( pszServerName, pszDirName )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // REPL_EDIR_BASE :: REPL_EDIR_BASE


/*******************************************************************

    NAME:       REPL_EDIR_BASE :: ~REPL_EDIR_BASE

    SYNOPSIS:   REPL_EDIR_BASE class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_EDIR_BASE :: ~REPL_EDIR_BASE( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_EDIR_BASE :: ~REPL_EDIR_BASE


/*******************************************************************

    NAME:       REPL_EDIR_BASE :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                MNetReplExportDirGetInfo API.

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_BASE :: I_GetInfo( VOID )
{
    //
    //  Get the info-level.
    //

    UINT nInfoLevel = QueryReplInfoLevel();
    UIASSERT( nInfoLevel <= 2 );

    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.
    //

    APIERR err = ::MNetReplExportDirGetInfo( QueryName(),
                                             QueryDirName(),
                                             nInfoLevel,
                                             &pbBuffer );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    //
    //  Extract the data to cache.
    //

    err = W_CacheApiData( pbBuffer );

    return err;

}   // REPL_EDIR_BASE :: I_GetInfo


/*******************************************************************

    NAME:       REPL_EDIR_BASE :: I_WriteInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                MNetReplExportDirSetInfo API.

    EXIT:       If successful, the target directory has been updated.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_BASE :: I_WriteInfo( VOID )
{
    //
    //  Map info-level 2 to info-level 1.
    //

    UINT nInfoLevel = QueryReplInfoLevel();
    UIASSERT( ( nInfoLevel >= 1 ) && ( nInfoLevel <= 2 ) );

    if( nInfoLevel == 2 )
    {
        nInfoLevel = 1;
    }

    //
    //  Update the REPL_EDIR_INFO_x structure.
    //

    APIERR err = W_Write();

    if( err == NERR_Success )
    {
        //
        //  Invoke the API to do the actual directory update.
        //

        err = ::MNetReplExportDirSetInfo( QueryName(),
                                          QueryDirName(),
                                          nInfoLevel,
                                          QueryBufferPtr() );
    }

    if( err == NERR_Success )
    {
        //
        //  Adjust the locks.
        //

        err = W_AdjustLocks();
    }

    return err;

}   // REPL_EDIR_BASE :: I_WriteInfo


/*******************************************************************

    NAME:       REPL_EDIR_BASE :: I_Delete

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                MNetReplExportDirDel API.

    ENTRY:      nForce                  - The "force" to apply to the
                                          deletion.  This value is
                                          not used by this method.

    EXIT:       If successful, the target directory has been deleted.
                Note that this does not delete the actual directory,
                just the data in the Replicators configuration.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_BASE :: I_Delete( UINT nForce )
{
    UNREFERENCED( nForce );

    //
    //  Invoke the API to delete the directory.
    //

    return ::MNetReplExportDirDel( QueryName(),
                                   QueryDirName() );

}   // REPL_EDIR_BASE :: I_Delete


/*******************************************************************

    NAME:       REPL_EDIR_BASE :: I_WriteNew

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                MNetReplExportDirAdd API.

    EXIT:       If successful, the new directory has been added
                to the Replicator's export path.  Note that this
                does not actually create the directory, it merely
                adds the data to the Replicator's configuration.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_BASE :: I_WriteNew( VOID )
{
    //
    //  Map info-level 2 to info-level 1.
    //

    UINT nInfoLevel = QueryReplInfoLevel();
    UIASSERT( ( nInfoLevel >= 1 ) || ( nInfoLevel <= 2 ) );

    if( nInfoLevel == 2 )
    {
        nInfoLevel = 1;
    }

    //
    //  Update the REPL_EDIR_INFO_x structure.
    //

    APIERR err = W_Write();

    if( err == NERR_Success )
    {
        //
        //  Invoke the API to add the directory.
        //

        err = ::MNetReplExportDirAdd( QueryName(),
                                      nInfoLevel,
                                      QueryBufferPtr() );
    }

    if( err == NERR_Success )
    {
        //
        //  Adjust the locks.
        //

        err = W_AdjustLocks();
    }

    return err;

}   // REPL_EDIR_BASE :: I_WriteNew


/*******************************************************************

    NAME:       REPL_EDIR_BASE :: W_AdjustLocks

    SYNOPSIS:   Adjust the directory locks based on the lock bias
                as stored in REPL_DIR_BASE.  If the lock bias is
                positive, then locks need to be applied.  If the
                lock bias is negative, then locks need to be removed.
                If the lock bias is zero, then no adjustment is
                necessary.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     25-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_BASE :: W_AdjustLocks( VOID )
{
    APIERR err = NERR_Success;

    while( ( QueryLockBias() != 0 ) && ( err == NERR_Success ) )
    {
        if( QueryLockBias() > 0 )
        {
            UnlockDirectory();

            err = ::MNetReplExportDirLock( QueryName(),
                                           QueryDirName() );
        }
        else
        {
            LockDirectory();

            err = ::MNetReplExportDirUnlock( QueryName(),
                                             QueryDirName(),
                                             REPL_UNLOCK_NOFORCE );
        }
    }

    return err;

}   // REPL_EDIR_BASE :: W_AdjustLocks



//
//  REPL_EDIR_0 methods
//

/*******************************************************************

    NAME:       REPL_EDIR_0 :: REPL_EDIR_0

    SYNOPSIS:   REPL_EDIR_0 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

                pszDirName              - Name of the exported/imported
                                          directory.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_EDIR_0 :: REPL_EDIR_0( const TCHAR * pszServerName,
                            const TCHAR * pszDirName )
  : REPL_EDIR_BASE( pszServerName, pszDirName )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Initialize the info-level & buffer size values.
    //

    SetReplInfoLevel( 0 );
    SetReplBufferSize( sizeof(REPL_EDIR_INFO_0) );

}   // REPL_EDIR_0 :: REPL_EDIR_0


/*******************************************************************

    NAME:       REPL_EDIR_0 :: ~REPL_EDIR_0

    SYNOPSIS:   REPL_EDIR_0 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_EDIR_0 :: ~REPL_EDIR_0( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_EDIR_0 :: ~REPL_EDIR_0


/*******************************************************************

    NAME:       REPL_EDIR_0 :: W_Write

    SYNOPSIS:   Virtual helper function to initialize the
                REPL_EDIR_INFO_0 API structure.

    EXIT:       The API buffer has been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_0 :: W_Write( VOID )
{
    REPL_EDIR_INFO_0 * prei0 = (REPL_EDIR_INFO_0 *)QueryBufferPtr();
    UIASSERT( prei0 != NULL );

    prei0->rped0_dirname = (LPTSTR)QueryDirName();

    return NERR_Success;

}   // REPL_EDIR_0 :: W_Write


/*******************************************************************

    NAME:       REPL_EDIR_0 :: W_CreateNew

    SYNOPSIS:   Virtual helper function to initialize the private
                data member to reasonable defaults whenever a new
                object is being created.

    EXIT:       Any necessary private data members have been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_0 :: W_CreateNew( VOID )
{
    //
    //  The buck stops here...
    //

    return NERR_Success;

}   // REPL_EDIR_0 :: W_CreateNew


/*******************************************************************

    NAME:       REPL_EDIR_0 :: W_CacheApiData

    SYNOPSIS:   Virtual helper function to cache any data from the
                API buffer which must be "persistant".  This data
                is typically held in private data members.

    ENTRY:      pbBuffer                - Points to an API buffer.  Is
                                          actually a REPL_EDIR_0 *.

    EXIT:       Any cacheable data has been saved into private data
                members.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_0 :: W_CacheApiData( const BYTE * pbBuffer )
{
    UNREFERENCED( pbBuffer );

    return NERR_Success;

}   // REPL_EDIR_0 :: W_CacheApiData



//
//  REPL_EDIR_1 methods
//

/*******************************************************************

    NAME:       REPL_EDIR_1 :: REPL_EDIR_1

    SYNOPSIS:   REPL_EDIR_1 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

                pszDirName              - Name of the exported/imported
                                          directory.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_EDIR_1 :: REPL_EDIR_1( const TCHAR * pszServerName,
                            const TCHAR * pszDirName )
  : REPL_EDIR_0( pszServerName, pszDirName ),
    _lIntegrity( REPL_INTEGRITY_TREE ),
    _lExtent( REPL_EXTENT_TREE )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Initialize the info-level & buffer size values.
    //

    SetReplInfoLevel( 1 );
    SetReplBufferSize( sizeof(REPL_EDIR_INFO_1) );

}   // REPL_EDIR_1 :: REPL_EDIR_1


/*******************************************************************

    NAME:       REPL_EDIR_1 :: ~REPL_EDIR_1

    SYNOPSIS:   REPL_EDIR_1 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_EDIR_1 :: ~REPL_EDIR_1( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_EDIR_1 :: ~REPL_EDIR_1


/*******************************************************************

    NAME:       REPL_EDIR_1 :: W_Write

    SYNOPSIS:   Virtual helper function to initialize the
                REPL_EDIR_INFO_1 API structure.

    EXIT:       The API buffer has been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_1 :: W_Write( VOID )
{
    REPL_EDIR_INFO_1 * prei1 = (REPL_EDIR_INFO_1 *)QueryBufferPtr();
    UIASSERT( prei1 != NULL );

    prei1->rped1_dirname   = (LPTSTR)QueryDirName();
    prei1->rped1_integrity = QueryIntegrity();
    prei1->rped1_extent    = QueryExtent();

    return NERR_Success;

}   // REPL_EDIR_1 :: W_Write


/*******************************************************************

    NAME:       REPL_EDIR_1 :: W_CreateNew

    SYNOPSIS:   Virtual helper function to initialize the private
                data member to reasonable defaults whenever a new
                object is being created.

    EXIT:       Any necessary private data members have been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_1 :: W_CreateNew( VOID )
{
    APIERR err;

    err = REPL_EDIR_0::W_CreateNew();

    if( err == NERR_Success )
    {
        SetIntegrity( DEFAULT_INTEGRITY );
        SetExtent( DEFAULT_EXTENT );
    }

    return err;

}   // REPL_EDIR_1 :: W_CreateNew


/*******************************************************************

    NAME:       REPL_EDIR_1 :: W_CacheApiData

    SYNOPSIS:   Virtual helper function to cache any data from the
                API buffer which must be "persistant".  This data
                is typically held in private data members.

    ENTRY:      pbBuffer                - Points to an API buffer.  Is
                                          actually a REPL_EDIR_1 *.

    EXIT:       Any cacheable data has been saved into private data
                members.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_1 :: W_CacheApiData( const BYTE * pbBuffer )
{
    REPL_EDIR_INFO_1 * prei1 = (REPL_EDIR_INFO_1 *)pbBuffer;

    SetIntegrity( prei1->rped1_integrity );
    SetExtent( prei1->rped1_extent );

    return NERR_Success;

}   // REPL_EDIR_1 :: W_CacheApiData



//
//  REPL_EDIR_2 methods
//

/*******************************************************************

    NAME:       REPL_EDIR_2 :: REPL_EDIR_2

    SYNOPSIS:   REPL_EDIR_2 class constructor.

    ENTRY:      pszServerName           - Name of the target server.

                pszDirName              - Name of the exported/imported
                                          directory.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_EDIR_2 :: REPL_EDIR_2( const TCHAR * pszServerName,
                            const TCHAR * pszDirName )
  : REPL_EDIR_1( pszServerName, pszDirName ),
    _lLockCount( 0 ),
    _lLockTime( 0 )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Initialize the info-level & buffer size values.
    //

    SetReplInfoLevel( 2 );
    SetReplBufferSize( sizeof(REPL_EDIR_INFO_2) );

}   // REPL_EDIR_2 :: REPL_EDIR_2


/*******************************************************************

    NAME:       REPL_EDIR_2 :: ~REPL_EDIR_2

    SYNOPSIS:   REPL_EDIR_2 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
REPL_EDIR_2 :: ~REPL_EDIR_2( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // REPL_EDIR_2 :: ~REPL_EDIR_2


/*******************************************************************

    NAME:       REPL_EDIR_2 :: W_Write

    SYNOPSIS:   Virtual helper function to initialize the
                REPL_EDIR_INFO_2 API structure.

    EXIT:       The API buffer has been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_2 :: W_Write( VOID )
{
    REPL_EDIR_INFO_2 * prei2 = (REPL_EDIR_INFO_2 *)QueryBufferPtr();
    UIASSERT( prei2 != NULL );

    prei2->rped2_dirname = (LPTSTR)QueryDirName();
    prei2->rped2_integrity = QueryIntegrity();
    prei2->rped2_extent    = QueryExtent();
    prei2->rped2_lockcount = (DWORD)QueryLockCount();
    prei2->rped2_locktime  = (DWORD)QueryLockTime();

    return NERR_Success;

}   // REPL_EDIR_2 :: W_Write


/*******************************************************************

    NAME:       REPL_EDIR_2 :: W_CreateNew

    SYNOPSIS:   Virtual helper function to initialize the private
                data member to reasonable defaults whenever a new
                object is being created.

    EXIT:       Any necessary private data members have been initialized.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_2 :: W_CreateNew( VOID )
{
    APIERR err;

    err = REPL_EDIR_1::W_CreateNew();

    if( err == NERR_Success )
    {
        SetLockCount( DEFAULT_LOCK_COUNT );
        SetLockTime( DEFAULT_LOCK_TIME );
    }

    return err;

}   // REPL_EDIR_2 :: W_CreateNew


/*******************************************************************

    NAME:       REPL_EDIR_2 :: W_CacheApiData

    SYNOPSIS:   Virtual helper function to cache any data from the
                API buffer which must be "persistant".  This data
                is typically held in private data members.

    ENTRY:      pbBuffer                - Points to an API buffer.  Is
                                          actually a REPL_EDIR_2 *.

    EXIT:       Any cacheable data has been saved into private data
                members.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     20-Feb-1992 Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_2 :: W_CacheApiData( const BYTE * pbBuffer )
{
    REPL_EDIR_INFO_2 * prei2 = (REPL_EDIR_INFO_2 *)pbBuffer;

    SetIntegrity( prei2->rped2_integrity );
    SetExtent( prei2->rped2_extent );
    SetLockCount( (ULONG)prei2->rped2_lockcount );
    SetLockTime( (ULONG)prei2->rped2_locktime );

    return NERR_Success;

}   // REPL_EDIR_2 :: W_CacheApiData
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmouser.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**                Copyright(c) Microsoft Corp., 1990                **/
/**********************************************************************/

/*  HISTORY:
 *      gregj   4/16/91         Created.
 *      gregj   4/22/91         Added USER, USER_11.
 *      gregj   4/29/91         Results of 4/29/91 code review
 *                              with chuckc, jimh, terryk, ericch
 *      gregj   5/21/91         Use new LOCATION class
 *      gregj   5/22/91         Support LOCATION's LOCATION_TYPE constructor
 *      jonn    7/22/91         USER_11 now writable
 *      rustanl 8/21/91         Renamed NEW_LM_OBJ buffer methods
 *      rustanl 8/26/91         Changed [W_]CloneFrom parameter from * to &
 *      jonn    8/29/91         Added ChangeToNew(), Query/SetAccountDisabled
 *      jonn    9/03/91         Added Query/SetUserComment()
 *      jonn    9/03/91         Added Query/SetParms()
 *      terryk  9/11/91         Added LOGON_USER here
 *      terryk  9/19/91         Added CHECK_OK to LOGON_USER
 *      terryk  9/20/91         Move LOGON_USER to Lmomisc.cxx
 *      terryk  10/7/91         types change for NT
 *      KeithMo 10/8/91         Now includes LMOBJP.HXX.
 *      terryk  10/17/91        WIN 32 conversion
 *      jonn    10/17/91        Fixed up password plus cleared bug-bugs.
 *      terryk  10/21/91        WIN 32 conversion ( part 2 )
 *      jonn    10/31/91        Removed SetBufferSize
 *      jonn    11/01/91        Added parms filter
 *      jonn    12/11/91        Added LogonHours accessors
 *      thoamspa 1/21/92        Added Rename()
 *      jonn     2/26/92        Fixups for 32-bit
 *      beng    05/07/92        Removed LOGON_HOURS_SETTING to collections
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


// string constant for "any logon server"
#define SERVER_ANY SZ("\\\\*")



/*******************************************************************

    NAME:       USER::USER

    SYNOPSIS:   constructor for the USER object

    ENTRY:      pszAccount -    account name
                pszLocation -   server or domain name to execute on;
                                default (NULL) means the local computer
                OR:
                loctype -       type of location, local computer or
                                logon domain

    EXIT:       Object is constructed

    NOTES:      Validation is not done until GetInfo() time.

    HISTORY:
        gregj       4/22/91     Created
        gregj       5/22/91     Added LOCATION_TYPE constructor
        beng        22-Nov-1991 Corrected owner-alloc members

********************************************************************/

VOID USER::CtAux( const TCHAR * pszAccount )
{
    if ( QueryError() )
        return;

    APIERR err = SetName( pszAccount );
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }
}

USER::USER(const TCHAR *pszAccount, const TCHAR *pszLocation)
        : LOC_LM_OBJ( pszLocation ),
          CT_NLS_STR(_nlsAccount)
{
    CtAux( pszAccount );
}

USER::USER(const TCHAR *pszAccount, enum LOCATION_TYPE loctype)
        : LOC_LM_OBJ( loctype ),
          CT_NLS_STR(_nlsAccount)
{
    CtAux( pszAccount );
}

USER::USER(const TCHAR *pszAccount, const LOCATION & loc)
        : LOC_LM_OBJ( loc ),
          CT_NLS_STR(_nlsAccount)
{
    CtAux( pszAccount );
}


/*******************************************************************

    NAME:       USER::~USER

    SYNOPSIS:   Destructor for USER class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

USER::~USER()
{
}


/*******************************************************************

    NAME:       USER::HandleNullAccount

    SYNOPSIS:   Validates the account name

    ENTRY:

    EXIT:       Returns a standard LANMAN error code

    NOTES:      Modifies _nlsAccount if it was empty

    HISTORY:
        gregj   4/29/91         Created
        jonn    8/12/91         Renamed from ValidateAccount()

********************************************************************/

APIERR USER::HandleNullAccount()
{
    if ( _nlsAccount.strlen() == 0 ) {
        WKSTA_10 wksta(NULL);

        APIERR err = wksta.GetInfo();
        if (err != NERR_Success)
            return err;

        TCHAR *pszLogonUser = (TCHAR *)wksta.QueryLogonUser();
        if ( pszLogonUser != NULL )
        {
            UIASSERT( strlenf(pszLogonUser) <= UNLEN );
            err =_nlsAccount.CopyFrom(pszLogonUser);
            if ( err != NERR_Success )
                return err;
        }
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER::QueryName

    SYNOPSIS:   Returns the account name of a user

    EXIT:       Returns a pointer to the account name

    NOTES:      Will be the same as the account name supplied at
                construction, except it will probably be uppercased
                by the API.

                Valid for objects in CONSTRUCTED state, thus no CHECK_OK

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

const TCHAR *USER::QueryName() const
{
    return _nlsAccount.QueryPch();
}


/*******************************************************************

    NAME:       USER::Rename

    SYNOPSIS:   renames the given username

    ENTRY:      TCHAR * pszAccount, new account name

    EXIT:       error code

    NOTES:      CODEWORK This is no longer used by User Manager and is
                probably not needed anymore.

    HISTORY:
        thomaspa        1/23/92         Created

********************************************************************/

APIERR USER::Rename( const TCHAR * pszAccount )
{

    ASSERT( strlenf(pszAccount) <= UNLEN );

    APIERR err = ::MNetUserSetInfo( QueryServer(),
                                  (TCHAR *) QueryName(),
                                  0,
                                  (PBYTE) &pszAccount,
                                  sizeof( user_info_0 ),
                                  PARMNUM_ALL );

    if ( err == NERR_Success )
    {
        // NOTE: we are not validating the new name.  It is assumed
        // that the user will do this.

        REQUIRE( _nlsAccount.CopyFrom(pszAccount) == NERR_Success );
    }

    return err;
}


/*******************************************************************

    NAME:       USER::SetName

    SYNOPSIS:   Changes the account name of a user

    ENTRY:      new account name

    EXIT:       Returns an API error code

    HISTORY:
        jonn    7/24/91         Created

********************************************************************/

APIERR USER::SetName( const TCHAR * pszAccount )
{
    if ( (pszAccount != NULL) && (strlenf(pszAccount) > UNLEN) )
        return ERROR_INVALID_PARAMETER;
    else
    {
        if ( (pszAccount != NULL) && ( strlenf(pszAccount) > 0 ) )
        {
            APIERR err = ::I_MNetNameValidate( NULL, pszAccount, NAMETYPE_USER, 0L );
            if ( err != NERR_Success )
                return NERR_BadUsername;
        }

        return _nlsAccount.CopyFrom(pszAccount);
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER::W_CloneFrom

    SYNOPSIS:   Copies information on the user

    EXIT:       Returns an API error code

    HISTORY:
        jonn    7/24/91         Created
        rustanl 8/26/91         Changed parameter from * to &

********************************************************************/

APIERR USER::W_CloneFrom( const USER & user )
{
    APIERR err = LOC_LM_OBJ::W_CloneFrom( user );
    if ( err != NERR_Success )
        return err;

    _nlsAccount = user.QueryName();
    ASSERT( _nlsAccount.QueryError() == NERR_Success );

    return NERR_Success;
}

/*******************************************************************

    NAME:       USER::I_Delete

    SYNOPSIS:   Deletes the user (calls NET API)

    RETURNS:    Returns an API error code

    HISTORY:
        o-SimoP         12-Aug-91       Created
********************************************************************/

APIERR USER::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );
    return ::MNetUserDel( QueryServer(), (TCHAR *)QueryName() );
}


/*******************************************************************

    NAME:       USER_11::USER_11

    SYNOPSIS:   Constructor for USER_11 class

    ENTRY:      pszAccount -    account name
                pszLocation -   server or domain name to execute on;
                                default (NULL) means the logon domain

    EXIT:       Object is constructed

    NOTES:      Validation is not done until GetInfo() time.

    CAVEATS:    Should we create a ctor-helper to perform the common
                work?
    HISTORY:
        gregj   4/22/91         Created
        gregj   5/22/91         Added LOCATION_TYPE constructor

********************************************************************/

VOID USER_11::CtAux()
{

    if ( QueryError() )
        return;

    APIERR err = NERR_Success;
    if (   ( (err = _nlsComment.QueryError()) != NERR_Success )
        || ( (err = _nlsUserComment.QueryError()) != NERR_Success )
        || ( (err = _nlsFullName.QueryError()) != NERR_Success )
        || ( (err = _nlsHomeDir.QueryError()) != NERR_Success )
        || ( (err = _nlsParms.QueryError()) != NERR_Success )
        || ( (err = _nlsWorkstations.QueryError()) != NERR_Success )
        || ( (err = _logonhrs.QueryError()) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

USER_11::USER_11( const TCHAR *pszAccount, const TCHAR *pszLocation )
        : USER( pszAccount, pszLocation ),
          _uPriv( USER_PRIV_USER ),
          _flAuth( 0L ),
          _nlsComment(),
          _nlsUserComment(),
          _nlsFullName(),
          _nlsHomeDir(),
          _nlsParms(),
          _nlsWorkstations(),
          _logonhrs()
{
    CtAux();
}

USER_11::USER_11( const TCHAR *pszAccount, enum LOCATION_TYPE loctype )
        : USER( pszAccount, loctype ),
          _uPriv( USER_PRIV_USER ),
          _flAuth( 0L ),
          _nlsComment(),
          _nlsUserComment(),
          _nlsFullName(),
          _nlsHomeDir(),
          _nlsParms(),
          _nlsWorkstations(),
          _logonhrs()
{
    CtAux();
}

USER_11::USER_11( const TCHAR *pszAccount, const LOCATION & loc )
        : USER( pszAccount, loc ),
          _uPriv( USER_PRIV_USER ),
          _flAuth( 0L ),
          _nlsComment(),
          _nlsUserComment(),
          _nlsFullName(),
          _nlsHomeDir(),
          _nlsParms(),
          _nlsWorkstations(),
          _logonhrs()
{
    CtAux();
}


/*******************************************************************

    NAME:       USER_11::~USER_11

    SYNOPSIS:   Destructor for USER_11 class

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

USER_11::~USER_11()
{
}


/*******************************************************************

    NAME:       USER_11::I_GetInfo

    SYNOPSIS:   Gets information about the local user

    ENTRY:

    EXIT:       Returns a standard LANMAN error code

    NOTES:      Name validation and memory allocation are done
                at this point, not at construction.

    HISTORY:
        gregj       4/16/91         Created
        beng        15-Jul-1991     BUFFER::Resize changed return type
        jonn        13-Oct-1991     Removed SetBufferSize

********************************************************************/

APIERR USER_11::I_GetInfo()
{
    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
        return err;

    // Location is validated in LOC_LM_OBJ ctor
    BYTE *pBuffer = NULL;
    err = ::MNetUserGetInfo ( QueryServer(), (TCHAR *)_nlsAccount.QueryPch(), 11,
        &pBuffer );
    SetBufferPtr( pBuffer );

    if ( err != NERR_Success )
        return err;

    struct user_info_11 *lpui11 = (struct user_info_11 *)QueryBufferPtr();
    UIASSERT( lpui11 != NULL );

    _uPriv  = (UINT)lpui11->usri11_priv;
    _flAuth = lpui11->usri11_auth_flags;

    if (   ((err = SetName( lpui11->usri11_name )) != NERR_Success )
        || ((err = SetComment( lpui11->usri11_comment )) != NERR_Success)
        || ((err = SetUserComment( lpui11->usri11_usr_comment )) != NERR_Success)
        || ((err = SetFullName( lpui11->usri11_full_name )) != NERR_Success )
        || ((err = SetHomeDir( lpui11->usri11_home_dir )) != NERR_Success )
        || ((err = SetParms( lpui11->usri11_parms )) != NERR_Success )
        || ((err = SetWorkstations( lpui11->usri11_workstations )) != NERR_Success )
        || ((err = SetLogonHours( (BYTE *)lpui11->usri11_logon_hours,
                                  (UINT)lpui11->usri11_units_per_week)) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:       USER_11::W_CloneFrom

    SYNOPSIS:   Copies information on the user

    EXIT:       Returns an API error code

    HISTORY:
        jonn    7/24/91         Created
        rustanl 8/26/91         Changed parameter from * to &

********************************************************************/

APIERR USER_11::W_CloneFrom( const USER_11 & user11 )
{
    APIERR err = NERR_Success;
    if (   ((err = USER::W_CloneFrom( user11 )) != NERR_Success )
        || ((err = SetPriv( user11.QueryPriv())) != NERR_Success )
        || ((err = SetAuthFlags( user11.QueryAuthFlags())) != NERR_Success )
        || ((err = SetComment( user11.QueryComment())) != NERR_Success)
        || ((err = SetUserComment( user11.QueryUserComment())) != NERR_Success)
        || ((err = SetFullName( user11.QueryFullName())) != NERR_Success)
        || ((err = SetHomeDir( user11.QueryHomeDir())) != NERR_Success )
        || ((err = SetParms( user11.QueryParms())) != NERR_Success )
        || ((err = SetWorkstations( user11.QueryWorkstations() )) != NERR_Success )
        || ((err = SetLogonHours( user11.QueryLogonHours() )) != NERR_Success )
       )
    {
        UIDEBUG( SZ("USER_11::W_CloneFrom failed\r\n") );
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_11::W_CreateNew

    SYNOPSIS:   initializes private data members for new object

    EXIT:       Returns an API error code

    HISTORY:
        jonn    8/13/91         Created

********************************************************************/

APIERR USER_11::W_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = USER::W_CreateNew()) != NERR_Success )
        || ((err = SetComment( NULL )) != NERR_Success )
        || ((err = SetUserComment( NULL )) != NERR_Success )
        || ((err = SetFullName( NULL )) != NERR_Success )
        || ((err = SetPriv( USER_PRIV_USER )) != NERR_Success )
        || ((err = SetAuthFlags( 0L )) != NERR_Success )
        || ((err = SetHomeDir( NULL )) != NERR_Success )
        || ((err = SetParms( NULL )) != NERR_Success )
        || ((err = SetWorkstations( NULL )) != NERR_Success )
        || ((err = SetLogonHours( NULL )) != NERR_Success )
       )
    {
        UIDEBUG( SZ("USER_11::W_CreateNew failed\r\n") );
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_11::QueryPriv

    SYNOPSIS:   Returns the privilege level of a user

    ENTRY:

    EXIT:       USER_PRIV_GUEST, USER_PRIV_USER, or USER_PRIV_ADMIN

    NOTES:

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

UINT USER_11::QueryPriv() const
{
    CHECK_OK(USER_PRIV_USER);
    return( _uPriv ) ;
}


/*******************************************************************

    NAME:       USER_11::QueryAuthFlags

    SYNOPSIS:   Returns the authorization flags (operator rights)
                of a user

    EXIT:       Mask containing any of the following:

                AF_OP_PRINT     Print operator
                AF_OP_COMM      Comm queue operator
                AF_OP_SERVER    Server operator
                AF_OP_ACCOUNTS  Accounts operator

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

ULONG USER_11::QueryAuthFlags() const
{
    CHECK_OK(0L);
    return( _flAuth ) ;
}


/*******************************************************************

    NAME:       USER_11::IsXXXOperator

    SYNOPSIS:   Returns whether the user has XXX operator rights

    EXIT:       TRUE if the user is a XXX operator

    NOTES:      Will return FALSE if the user is an administrator

                Why "!!"?  If the flag is in the top word, we will lose
                it in translation to BOOL (SHORT) without this.

    HISTORY:
        gregj   4/29/91         Created

********************************************************************/

BOOL USER_11::IsPrintOperator() const
{
    return !!(QueryAuthFlags() & AF_OP_PRINT);
}

BOOL USER_11::IsCommOperator() const
{
    return !!(QueryAuthFlags() & AF_OP_COMM);
}

BOOL USER_11::IsServerOperator() const
{
    return !!(QueryAuthFlags() & AF_OP_SERVER);
}

BOOL USER_11::IsAccountsOperator() const
{
    return !!(QueryAuthFlags() & AF_OP_ACCOUNTS);
}


/*******************************************************************

    NAME:       USER_11::SetComment

    SYNOPSIS:   Changes the comment set by administrator

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        jonn    7/23/91         Created

********************************************************************/

APIERR USER_11::SetComment( const TCHAR * pszComment )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsComment.CopyFrom( pszComment );

}


/*******************************************************************

    NAME:       USER_11::SetUserComment

    SYNOPSIS:   Changes the comment set by user

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        jonn    7/23/91         Created

********************************************************************/

APIERR USER_11::SetUserComment( const TCHAR * pszUserComment )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsUserComment.CopyFrom( pszUserComment );

}


/*******************************************************************

    NAME:       USER_11::SetFullName

    SYNOPSIS:   Changes the user's fullname

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        jonn    7/23/91         Created

********************************************************************/

APIERR USER_11::SetFullName( const TCHAR * pszFullName )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsFullName.CopyFrom( pszFullName );
}


/*******************************************************************

    NAME:       USER_11::SetPriv

    SYNOPSIS:   Changes the user's privilege level

    EXIT:       error code.

    HISTORY:
        jonn    7/30/91         Created

********************************************************************/

APIERR USER_11::SetPriv( UINT uPriv )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _uPriv = uPriv;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_11::SetAuthFlags

    SYNOPSIS:   Changes the user's authorization flags (operator rights)

    EXIT:       error code.

    HISTORY:
        jonn    8/07/91         Created

********************************************************************/

APIERR USER_11::SetAuthFlags( ULONG flAuth )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _flAuth = flAuth;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_11::SetHomeDir

    SYNOPSIS:   Changes the user's home directory

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP 08/27/91        Created

********************************************************************/

APIERR USER_11::SetHomeDir( const TCHAR * pszHomeDir )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsHomeDir.CopyFrom( pszHomeDir );
}


/*******************************************************************

    NAME:       USER_11::SetParms

    SYNOPSIS:   Changes the user's application-defined parameters

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP 08/27/91        Created

********************************************************************/

APIERR USER_11::SetParms( const TCHAR * pszParms )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsParms.CopyFrom( pszParms );
}


/*******************************************************************

    NAME:       USER_11::SetWorkstations

    SYNOPSIS:   Sets the user's valid logon workstations

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP 10/02/91        Created

********************************************************************/

APIERR USER_11::SetWorkstations( const TCHAR * pszWstations )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsWorkstations.CopyFrom( pszWstations );
}


/*******************************************************************

    NAME:       USER_11::SetLogonHours

    SYNOPSIS:   Changes the user's logon hours

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        jonn    12/11/91        Created

********************************************************************/

APIERR USER_11::SetLogonHours( const UCHAR * pLogonHours,
                               UINT unitsperweek )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    if ( pLogonHours == NULL )
        return _logonhrs.MakeDefault();
    else
        return _logonhrs.SetFromBits( pLogonHours, unitsperweek );
}


/*******************************************************************

    NAME:       USER_11::TrimParams

    SYNOPSIS:   Like LM21 NIF, User Manager trims certain Dialin
                information out of the parms field when a user is
                cloned.  This does not happen automatically on
                CloneFrom, instead the caller must call TrimParms
                explicitly.

    EXIT:       error code.  If not NERR_Success the object is still valid.

    NOTES:      As per agreement with LM21, program management and other
                concerned parties, this method trims the Dialin
                information from the parms string but not the Macintosh
                Access information.  This is because the Dialin
                information may carry significant security privileges,
                but the Macintosh primary group is not as significant a
                security risk.

    HISTORY:
        JonN    11/01/91        Copied from
                        \\deficit\lm!ui\nif\nif\utils2.c:CloneUsrParams
        jonN    12/10/92        UNICODE cleanup

********************************************************************/

// JonN: from utils.h
// usr_parms munging stuff
#define UP_CLIENT_MAC   TCH('m')
#define UP_CLIENT_DIAL  TCH('d')

// JonN: from utils2.c
// definitions et al for usr_parms functions
#define UP_LEN_MAC              LM20_GNLEN
#define UP_LEN_DIAL             (48 - 3 - UP_LEN_MAC)

typedef struct {
        TCHAR   up_MACid;
        TCHAR   up_PriGrp[UP_LEN_MAC];
        TCHAR   up_MAC_Terminater;
        TCHAR   up_DIALid;
        TCHAR   up_CBNum[UP_LEN_DIAL];
        TCHAR   up_Null;
} USER_PARMS;
typedef USER_PARMS FAR * PUP;

#ifndef max
#define max(a,b)            (((a) > (b)) ? (a) : (b))
#endif

APIERR USER_11::TrimParams()
{
    const TCHAR * pchParms = QueryParms();
    if ( pchParms == NULL )
        return NERR_Success;

    // check if the buffer is large enough to hold RAS info.
    // UP_LEN_MAC + 4  will do it

    if ( strlenf(pchParms) < UP_LEN_MAC + 4 )
        return NERR_Success;

    USER_PARMS * pupBuf = (USER_PARMS *)pchParms;

    // Check signature bytes.
    if ((pupBuf->up_MACid != UP_CLIENT_MAC)
        || (pupBuf->up_DIALid != UP_CLIENT_DIAL))
    {
        return NERR_Success;
    }

    size_t cbParmLen = (::strlenf(pchParms)+1) * sizeof(TCHAR);
    cbParmLen = max(sizeof(USER_PARMS), cbParmLen );
    BUFFER bufNewParms( cbParmLen );
    APIERR err = bufNewParms.QueryError();
    if (err != NERR_Success)
    {
        return err;
    }

    TCHAR * pchParmsNew = (TCHAR *) bufNewParms.QueryPtr();
    ::strcpyf( pchParmsNew, pchParms );

    // Ok, it's valid. Do our thing.
    USER_PARMS * pupBufNew = (USER_PARMS *)pchParmsNew;
    pupBufNew->up_CBNum[0] = 1;     // no RAS perms
    for ( int i = 1; i < UP_LEN_DIAL; i++ )
        pupBufNew->up_CBNum[i] = TCH(' ');

    // Make sure the buffer is null terminated.
    pchParmsNew[ cbParmLen/sizeof(TCHAR) - 1 ] = TCH('\0');

    err = SetParms( pchParmsNew );

    return err;
}


/*******************************************************************

    NAME:       USER_2::CtAux

    SYNOPSIS:   Constructor helper for USER_2 class

    EXIT:       ReportError is called if nesessary

    HISTORY:
        o-SimoP 08/27/91        Created

********************************************************************/

VOID USER_2::CtAux()
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (   ((err = _nlsScriptPath.QueryError()) != NERR_Success)
        || ((err = _nlsPassword.QueryError()) != NERR_Success) )
    {
        ReportError( err );
        return;
    }
}

/*******************************************************************

    NAME:       USER_2::USER_2

    SYNOPSIS:   Constructor for USER_2 class

    ENTRY:      pszAccount -    account name
                pszLocation -   server or domain name to execute on;
                                default (NULL) means the logon domain

    EXIT:       Object is constructed

    NOTES:      Validation is not done until GetInfo() time.

                These constructors/destructors are not strictly
                necessary, but may be needed later if we add accessors
                to USER_2-specific fields.

    HISTORY:
        jonn    7/24/91         Created

********************************************************************/


USER_2::USER_2( const TCHAR *pszAccount, const TCHAR *pszLocation )
        : USER_11( pszAccount, pszLocation ),
          _afUserFlags( UF_SCRIPT ),
          _lAcctExpires( TIMEQ_FOREVER ),
          _nlsPassword(),
          _nlsScriptPath()
{
    CtAux();
}

USER_2::USER_2( const TCHAR *pszAccount, enum LOCATION_TYPE loctype )
        : USER_11( pszAccount, loctype ),
          _afUserFlags( UF_SCRIPT ),
          _lAcctExpires( TIMEQ_FOREVER ),
          _nlsPassword(),
          _nlsScriptPath()
{
    CtAux();
}

USER_2::USER_2( const TCHAR *pszAccount, const LOCATION & loc )
        : USER_11( pszAccount, loc ),
          _afUserFlags( UF_SCRIPT ),
          _lAcctExpires( TIMEQ_FOREVER ),
          _nlsPassword(),
          _nlsScriptPath()
{
    CtAux();
}



/*******************************************************************

    NAME:       USER_2::~USER_2

    SYNOPSIS:   Destructor for USER_2 class

    HISTORY:
        jonn    7/24/91         Created

********************************************************************/

USER_2::~USER_2()
{
    // clear password from pagefile
    ::memsetf( (void *)(_nlsPassword.QueryPch()),
               0x20,
               _nlsPassword.strlen() );
}


/*******************************************************************

    NAME:       USER_2::I_GetInfo

    SYNOPSIS:   Gets information about the local user

    EXIT:       Returns API error code

    NOTES:      In I_GetInfo, we set the password to NULL_USERSETINFO_PASSWD.
                NetUserGetInfo[2] will never give us a real password, but
                only this value.  If this value is passed though to
                SetInfo, the user's password will not be changed.

    HISTORY:
        jonn        7/24/91         Created
        jonn        13-Oct-1991     Removed SetBufferSize
        beng        29-Mar-1992     Removed verboten PCH type

********************************************************************/

APIERR USER_2::I_GetInfo()
{
    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
        return err;

    BYTE *pBuffer = NULL;
    err = ::MNetUserGetInfo ( QueryServer(), (TCHAR*)_nlsAccount.QueryPch(), 2,
                              &pBuffer );
    SetBufferPtr( pBuffer );
    if ( err != NERR_Success )
        return err;

    struct user_info_2 *lpui2 = (struct user_info_2 *)QueryBufferPtr();
    UIASSERT( lpui2 != NULL );

    if (   ((err = SetName( lpui2->usri2_name )) != NERR_Success )
        || ((err = SetPriv( (UINT)lpui2->usri2_priv )) != NERR_Success )
        || ((err = SetAuthFlags( (UINT)lpui2->usri2_auth_flags )) != NERR_Success )
        || ((err = SetComment( lpui2->usri2_comment )) != NERR_Success)
        || ((err = SetUserComment( lpui2->usri2_usr_comment )) != NERR_Success)
        || ((err = SetFullName( lpui2->usri2_full_name )) != NERR_Success )
        || ((err = SetHomeDir( lpui2->usri2_home_dir )) != NERR_Success )
        || ((err = SetParms( lpui2->usri2_parms )) != NERR_Success )
        || ((err = SetScriptPath( lpui2->usri2_script_path )) != NERR_Success )
        || ((err = SetAccountExpires( lpui2->usri2_acct_expires )) != NERR_Success )
        || ((err = SetUserFlags( (UINT)lpui2->usri2_flags )) != NERR_Success )
        || ((err = SetPassword( UI_NULL_USERSETINFO_PASSWD )) != NERR_Success )
        || ((err = SetWorkstations( lpui2->usri2_workstations )) != NERR_Success )
        || ((err = SetLogonHours( (BYTE *)lpui2->usri2_logon_hours,
                                  (UINT)lpui2->usri2_units_per_week )) != NERR_Success )
       )
    {
        return err;
    }

    return NERR_Success;

}


/*******************************************************************

    NAME:       USER_2::W_CreateNew

    SYNOPSIS:   initializes private data members for new object

    EXIT:       Returns an API error code

    NOTES:      Unlike I_GetInfo, we set the password to NULL.  This is
                an appropriate initial value for a new user.

    HISTORY:
        o-SimoP         08/28/91        Created
        JonN            10/17/91        Sets password to NULL

********************************************************************/

APIERR USER_2::W_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = USER_11::W_CreateNew()) != NERR_Success )
        || ((err = SetScriptPath( NULL )) != NERR_Success )
        || ((err = SetPassword( NULL )) != NERR_Success )
        || ((err = SetAccountExpires( TIMEQ_FOREVER )) != NERR_Success )
        || ((err = SetUserFlags( UF_SCRIPT )) != NERR_Success )
       )
    {
        UIDEBUG( SZ("USER_2::W_CreateNew failed\r\n") );
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::I_CreateNew

    SYNOPSIS:   Sets up object for subsequent WriteNew

    EXIT:       Returns a standard LANMAN error code

    NOTES:      Name validation and memory allocation are done
                at this point, not at construction.  The string-valued
                fields are only valid in the NLS_STR members and are not
                valid in the buffer until WriteNew.

                EXCEPTION: We don't validate the account name until
                WriteNew.

                Default values taken from NetCmd::user_add().

    HISTORY:
        jonn        7/22/91         Created
        JonN        05/08/92        Calls ClearBuffer()

********************************************************************/

APIERR USER_2::I_CreateNew()
{

    APIERR err = NERR_Success;
    if (   ((err = W_CreateNew()) != NERR_Success )
        || ((err = ResizeBuffer( sizeof(user_info_2) )) != NERR_Success )
        || ((err = ClearBuffer()) != NERR_Success )
       )
    {
        return err;
    }

    struct user_info_2 *lpui2 = (struct user_info_2 *)QueryBufferPtr();
    UIASSERT( lpui2 != NULL );

    /*
        All fields of user_info_2 are listed here.  Some are commented
        out because:
        (1) They are adequately initialized by BufferClear()
        (2) The effective value is stored in an NLS_SLR or other data member
    */
    // lpui2->usri2_name =
    // strcpyf( lpui2->usri2_password, QueryPassword() );
    // lpui2->usri2_password_age =
    // lpui2->usri2_priv = _usPriv = USER_PRIV_USER;
    // lpui2->usri2_home_dir =
    // lpui2->usri2_comment = (PSZ)_nlsComment.QueryPch();
    // lpui2->usri2_flags = UF_SCRIPT;
    // lpui2->usri2_script_path =
    // lpui2->usri2_auth_flags = _flAuth = 0L;
    // lpui2->usri2_full_name = (PSZ)_nlsFullName.QueryPch();
    // lpui2->usri2_usr_comment = (PSZ)_nlsUserComment.QueryPch();
    // lpui2->usri2_parms =
    // lpui2->usri2_workstations =
    // lpui2->usri2_last_logon =
    // lpui2->usri2_last_logoff =
    lpui2->usri2_acct_expires = TIMEQ_FOREVER;
    lpui2->usri2_max_storage = USER_MAXSTORAGE_UNLIMITED;
    // lpui2->usri2_units_per_week =
    // lpui2->usri2_logon_hours =
    // lpui2->usri2_bad_pw_count =
    // lpui2->usri2_num_logons =
    lpui2->usri2_logon_server = SERVER_ANY;
    // lpui2->usri2_country_code =
    // lpui2->usri2_code_page =

    return NERR_Success;

}


/*******************************************************************

    NAME:       USER_2::W_CloneFrom

    SYNOPSIS:   Copies information on the user

    EXIT:       Returns an API error code

    HISTORY:
        jonn    7/24/91         Created
        rustanl 8/26/91         Changed parameter from * to &
        o-SimoP 08/28/91        Cloned from USER_11::W_CloneFrom

********************************************************************/

APIERR USER_2::W_CloneFrom( const USER_2 & user2 )
{
    APIERR err = NERR_Success;
    if (   ((err = USER_11::W_CloneFrom( user2 )) != NERR_Success )
        || ((err = SetScriptPath( user2.QueryScriptPath() )) != NERR_Success )
        || ((err = SetPassword( user2.QueryPassword() )) != NERR_Success )
        || ((err = SetAccountExpires( user2.QueryAccountExpires() )) != NERR_Success )
        || ((err = SetUserFlags( user2.QueryUserFlags() )) != NERR_Success)
       )
    {
        UIDEBUG( SZ("USER_2::W_CloneFrom failed\r\n") );
        return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::CloneFrom

    SYNOPSIS:   Copies information on the user

    EXIT:       Returns an API error code

    NOTES:      W_CloneFrom copies all member objects, but it does not
                update the otherwise unused pointers in the API buffer.
                This is left for the outermost routine, CloneFrom().
                Only the otherwise unused pointers need to be fixed
                here, the rest will be fixed in WriteInfo/WriteNew.

                usri2_logon_server is an "obscure" pointer which may
                have one of two origins:
                (1) It may have been pulled in by GetInfo, in which case
                    it is in the buffer;
                (2) It may have been created by CreateNew, in which case
                    it points to a static string outside the buffer.
                To handle these cases, FixupPointer must try to fixup
                logon_server except where it points outside the buffer.

    HISTORY:
        jonn    7/24/91         Created
        rustanl 8/26/91         Changed parameter from * to &

********************************************************************/

APIERR USER_2::CloneFrom( const USER_2 & user2 )
{
    APIERR err = W_CloneFrom( user2 );
    if ( err != NERR_Success )
    {
        UIDEBUG( SZ("USER_2::W_CloneFrom failed with error code ") );
        UIDEBUGNUM( (LONG)err );
        UIDEBUG( SZ("\r\n") );

        ReportError( err ); // make unconstructed here
        return err;
    }

    /*
        This is where I fix up the otherwise unused pointers.
    */
    user_info_2 *pAPIuser2 = (user_info_2 *)QueryBufferPtr();


    /*
        Do not attempt to merge these into a macro, the compiler will not
        interpret the "&(p->field)" correctly if you do.
    */
    FixupPointer32(((TCHAR**)&(pAPIuser2->usri2_name)), (& user2));
    FixupPointer( (TCHAR **)&(pAPIuser2->usri2_script_path), &user2 );
    FixupPointer( (TCHAR **)&(pAPIuser2->usri2_logon_server), &user2 );

    FixupPointer( (TCHAR **)&(pAPIuser2->usri2_full_name), &user2 );

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::W_Write

    SYNOPSIS:   Helper function for WriteNew and WriteInfo -- loads
                current values into the API buffer

    EXIT:       Returns API error code

    HISTORY:
        jonn        8/12/91         Created

********************************************************************/

APIERR USER_2::W_Write()
{
    struct user_info_2 *lpui2 = (struct user_info_2 *)QueryBufferPtr();
    ASSERT( lpui2 != NULL );
    ASSERT( _nlsAccount.QueryError() == NERR_Success );
    ASSERT( _nlsAccount.strlen() <= UNLEN );
    // usri2_name is a buffer rather than a pointer
    COPYTOARRAY( lpui2->usri2_name, (TCHAR *)_nlsAccount.QueryPch() );
    lpui2->usri2_comment = (TCHAR *)QueryComment();
    lpui2->usri2_usr_comment = (TCHAR *)QueryUserComment();
    lpui2->usri2_full_name = (TCHAR *)QueryFullName();
    lpui2->usri2_priv = QueryPriv();
    lpui2->usri2_auth_flags = QueryAuthFlags();
    lpui2->usri2_flags = QueryUserFlags();
    lpui2->usri2_home_dir = (TCHAR *)QueryHomeDir();
    lpui2->usri2_parms = (TCHAR *)QueryParms();
    lpui2->usri2_script_path = (TCHAR *)QueryScriptPath();
    lpui2->usri2_acct_expires = QueryAccountExpires();
    lpui2->usri2_workstations = (TCHAR *)QueryWorkstations();
    lpui2->usri2_units_per_week = QueryLogonHours().QueryUnitsPerWeek();
    lpui2->usri2_logon_hours = (UCHAR *)(QueryLogonHours().QueryHoursBlock());

#ifndef WIN32
    memsetf( lpui2->usri2_password, 0, ENCRYPTED_PWLEN );
#endif // WIN32
    COPYTOARRAY( lpui2->usri2_password, (TCHAR*)QueryPassword() );

    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::I_WriteInfo

    SYNOPSIS:   Writes information about the local user

    EXIT:       Returns API error code

    HISTORY:
        jonn        7/24/91         Created

********************************************************************/

APIERR USER_2::I_WriteInfo()
{
    APIERR err = W_Write();
    if ( err != NERR_Success )
        return err;

    return ::MNetUserSetInfo ( QueryServer(), (TCHAR *)_nlsAccount.QueryPch(), 2,
                        QueryBufferPtr(),
                        sizeof( struct user_info_2 ), PARMNUM_ALL );

}


/*******************************************************************

    NAME:       USER_2::I_WriteNew

    SYNOPSIS:   Creates a new user

    ENTRY:

    EXIT:       Returns an API error code

    NOTES:

    HISTORY:
        jonn        7/22/91         Created

********************************************************************/

APIERR USER_2::I_WriteNew()
{
    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
        return err;

    err = W_Write();
    if ( err != NERR_Success )
        return err;

/*
    We pass size sizeof(struct user_info_2) instead of QueryBufferSize()
    to force all pointers to point outside of the buffer.
*/

    return ::MNetUserAdd( QueryServer(), 2,
                          QueryBufferPtr(),
                          sizeof( struct user_info_2 ) );
}


/**********************************************************\

    NAME:       USER_2::I_ChangeToNew

    SYNOPSIS:   NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
                to NEW status only when a corresponding I_ChangeToNew()
                exists.  The user_info_2 API buffer is the same for new
                and valid objects, so this nethod doesn't have to do
                much.

    HISTORY:
        JonN        29-Aug-1991     Created

\**********************************************************/

APIERR USER_2::I_ChangeToNew()
{
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:       USER_2::SetAccountExpires

    SYNOPSIS:   Changes the user's account expires time

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP         08/28/91        Created

********************************************************************/

APIERR USER_2::SetAccountExpires( LONG lExpires )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _lAcctExpires = lExpires;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::SetUserFlags

    SYNOPSIS:   Changes the user's user flags

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP         08/28/91        Created

********************************************************************/

APIERR USER_2::SetUserFlags( UINT afFlags )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _afUserFlags = afFlags;
    return NERR_Success;
}


/*******************************************************************

    NAME:       USER_2::SetScriptPath

    SYNOPSIS:   Changes the user's script path

    EXIT:       error code.  If not NERR_Success the object is still valid.

    HISTORY:
        o-SimoP         08/28/91        Created

********************************************************************/

APIERR USER_2::SetScriptPath( const TCHAR * pszScriptPath )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsScriptPath.CopyFrom( pszScriptPath );
}


/*******************************************************************

    NAME:       USER_2::SetPassword

    SYNOPSIS:   Changes the user password

    ENTRY:      Expects a pointer to a valid password

    EXIT:       error code.

    NOTES:      This must be a null-terminated string of length at most
                PWLEN TCHAR.

    HISTORY:
        jonn    8/27/91         Created
        jonn    6/13/93         Clear password from pagefile

********************************************************************/

APIERR USER_2::SetPassword( const TCHAR * pszPassword )
{
    CHECK_OK( ERROR_GEN_FAILURE );

    //  NULL and NULL_USERSETINFO_PASSWD must also validate
    APIERR err = NERR_Success;
    if (   pszPassword != NULL
        && (::strcmpf(pszPassword, UI_NULL_USERSETINFO_PASSWD) != 0)
        && (err = ::I_MNetNameValidate( NULL, pszPassword, NAMETYPE_PASSWORD, 0L ))
                != NERR_Success
       )
    {
        return NERR_BadPassword;
    }

    // clear password from pagefile
    ::memsetf( (void *)(_nlsPassword.QueryPch()),
               0x20,
               _nlsPassword.strlen() );
    return _nlsPassword.CopyFrom( pszPassword );
}


/*******************************************************************

    NAME:       USER_2::QueryUserFlag

    SYNOPSIS:   Queries a specific flag (usriX_flags)

    EXIT:       BOOL whether flag is set

    NOTES:      "!!" ensures that result is in first 16 bits -- not
                strictly necessary at present, but a precaution in case
                this moves to ULONG

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

BOOL USER_2::QueryUserFlag( UINT afMask ) const
{
    return !!( QueryUserFlags() & afMask );
}


/*******************************************************************

    NAME:       USER_2::SetUserFlag

    SYNOPSIS:   Sets a specific flag (usriX_flags)

    ENTRY:      BOOL whether flag should be set

    EXIT:       error code

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

APIERR USER_2::SetUserFlag( BOOL fSetTo, UINT afMask )
{
    if ( fSetTo )
        return SetUserFlags( QueryUserFlags() | afMask );
    else
        return SetUserFlags( QueryUserFlags() & ~afMask );
}


/*******************************************************************

    NAME:       USER_2::QueryAccountDisabled

    SYNOPSIS:   Queries the account disabled flag (usriX_flags)

    EXIT:       BOOL whether account is disabled

    NOTES:      "!!" ensures that the data is not lost in the conversion
                to BOOL

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

BOOL USER_2::QueryAccountDisabled() const
{
    return QueryUserFlag( UF_ACCOUNTDISABLE );
}


/*******************************************************************

    NAME:       USER_2::SetAccountDisabled

    SYNOPSIS:   Sets the account disabled flag (usriX_flags)

    ENTRY:      BOOL whether account is disabled

    EXIT:       error code

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

APIERR USER_2::SetAccountDisabled( BOOL fAccountDisabled )
{
    return SetUserFlag( fAccountDisabled, UF_ACCOUNTDISABLE );
}


/*******************************************************************

    NAME:       USER_2::QueryUserCantChangePass

    SYNOPSIS:   Queries the user-cannot-change-password flag (usriX_flags)

    EXIT:       BOOL whether user cannot change password

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

BOOL USER_2::QueryUserCantChangePass() const
{
    return QueryUserFlag( UF_PASSWD_CANT_CHANGE );
}


/*******************************************************************

    NAME:       USER_2::SetUserCantChangePass

    SYNOPSIS:   Sets the user-cannot-change-password flag (usriX_flags)

    ENTRY:      BOOL whether user cannot change password

    EXIT:       error code

    HISTORY:
        jonn    8/28/91         Created

********************************************************************/

APIERR USER_2::SetUserCantChangePass( BOOL fUserCantChangePass )
{
    return SetUserFlag( fUserCantChangePass, UF_PASSWD_CANT_CHANGE );
}


/*******************************************************************

    NAME:       USER_2::QueryNoPasswordExpire

    SYNOPSIS:   Queries the password-does-not-expire flag (usriX_flags)

    EXIT:       BOOL whether the password does not expire

    HISTORY:
        thomaspa    8/5/92         Created

********************************************************************/

BOOL USER_2::QueryNoPasswordExpire() const
{
    return QueryUserFlag( UF_DONT_EXPIRE_PASSWD );
}


/*******************************************************************

    NAME:       USER_2::SetNoPasswordExpire

    SYNOPSIS:   Sets the password-does-not-expire flag (usriX_flags)

    ENTRY:      BOOL whether the password does not expire

    EXIT:       error code

    HISTORY:
        thomaspa    8/05/92         Created

********************************************************************/

APIERR USER_2::SetNoPasswordExpire( BOOL fNoPasswordExpire )
{
    return SetUserFlag( fNoPasswordExpire, UF_DONT_EXPIRE_PASSWD );
}


/*******************************************************************

    NAME:       USER_2::QueryUserPassRequired

    SYNOPSIS:   Queries the password-required flag (usriX_flags)

    EXIT:       BOOL whether a password is required for this account

    HISTORY:
        jonn    8/29/91         Created

********************************************************************/

BOOL USER_2::QueryUserPassRequired() const
{
    return !( QueryUserFlag( UF_PASSWD_NOTREQD ) );
}


/*******************************************************************

    NAME:       USER_2::SetUserPassRequired

    SYNOPSIS:   Sets the password-required flag (usriX_flags)

    ENTRY:      BOOL whether a password is required for this account

    EXIT:       error code

    HISTORY:
        jonn    8/29/91         Created

********************************************************************/

APIERR USER_2::SetUserPassRequired( BOOL fUserPassRequired )
{
    return SetUserFlag( !fUserPassRequired, UF_PASSWD_NOTREQD );
}


/*******************************************************************

    NAME:       USER_2::QueryLockout

    SYNOPSIS:   Queries the locked-out flag (usriX_flags)

    EXIT:       BOOL whether the account is locked out

    HISTORY:
        jonn    12/28/93        Created

********************************************************************/

BOOL USER_2::QueryLockout() const
{
    return QueryUserFlag( UF_LOCKOUT );
}


/*******************************************************************

    NAME:       USER_2::SetLockout

    SYNOPSIS:   Sets the locked-out flag (usriX_flags)

    ENTRY:      BOOL whether the account is locked out

    EXIT:       error code

    HISTORY:
        jonn    12/28/93        Created

********************************************************************/

APIERR USER_2::SetLockout( BOOL fLockout )
{
    return SetUserFlag( fLockout, UF_LOCKOUT );
}




/*******************************************************************

    NAME:       LOCAL_USER::LOCAL_USER

    SYNOPSIS:   Constructor for LOCAL_USER class

    ENTRY:      pszLocation -   server or domain to execute on;
                                default (NULL) means logon domain

                pszPassword -   password for down-level ADMIN$ share

    EXIT:       object is constructed

    HISTORY:
        gregj   4/22/91         Created
        gregj   5/22/91         Added LOCATION_TYPE constructor

********************************************************************/

LOCAL_USER::LOCAL_USER (const TCHAR *pszLocation, const TCHAR *pszPassword)
        : USER_11(NULL, pszLocation)
{
    _fAdminConnect = FALSE;

    memsetf( _szPassword, 0, sizeof(_szPassword) );
    if (pszPassword)
        strncpyf( _szPassword, pszPassword,
                  sizeof _szPassword / sizeof (TCHAR) - 1 ) ;
}


LOCAL_USER::LOCAL_USER ( enum LOCATION_TYPE loctype )
        : USER_11(NULL, loctype)
{
    _fAdminConnect = FALSE;

    memsetf( _szPassword, 0, sizeof(_szPassword) );
}


/*******************************************************************

    NAME:       LOCAL_USER::~LOCAL_USER

    SYNOPSIS:   Destructor for LOCAL_USER class

    EXIT:       Automatically disconnects the ADMIN$ share if one
                was created in I_GetInfo()

    HISTORY:
        gregj   4/22/91         Created

********************************************************************/

LOCAL_USER::~LOCAL_USER()
{
    //  Disconnect from ADMIN$ if necessary

    if (_fAdminConnect) {
        TCHAR remote_buf [MAX_PATH+1];
        APIERR err;

        strcpyf ( remote_buf, QueryServer() );
        strcatf ( remote_buf, SZ("\\ADMIN$") );
        err = ::MNetUseDel ( NULL, remote_buf, USE_LOTS_OF_FORCE );
        if ( err != NERR_Success ) {
            UIDEBUG(SZ("Error disconnecting ADMIN$ in ~USER_11.\r\n"));
        }
    }
}


/*******************************************************************

    NAME:       LOCAL_USER::I_GetInfo

    SYNOPSIS:   Gets information about the local user

    EXIT:       Automatically creates an ADMIN$ share to share-level
                servers

    RETURNS:    Returns a standard LANMAN error code

    NOTES:      The difference between this and USER_11::I_GetInfo
                is some extra fiddling around to handle share-level
                servers.

    HISTORY:
        gregj   4/23/91         Created

********************************************************************/

APIERR LOCAL_USER::I_GetInfo()
{
    APIERR err = USER_11::I_GetInfo();

    if (err == ERROR_NOT_SUPPORTED) {
        //  Try connecting to ADMIN$, maybe this is share-level

        //  CODEWORK: Move the following NetUseAdd call, and the
        //  corresponding NetUseDel in the destructor, into a
        //  separate CONNECTION class.

        use_info_1 ui1;
        TCHAR remote_buf [MAX_PATH+1];
        TCHAR local_buf [MAX_PATH+1];

        ui1.ui1_local = local_buf;
        ui1.ui1_local [0] = TCH('\0');  // no local device name
        strcpyf ( remote_buf, QueryServer() );
        strcatf ( remote_buf, SZ("\\ADMIN$") );
        ui1.ui1_remote = remote_buf;
        ui1.ui1_password = _szPassword;
        ui1.ui1_asg_type = USE_WILDCARD;

        err = ::MNetUseAdd (NULL, 1, (BYTE *)&ui1, sizeof (ui1));
        if (err == NERR_Success) {
            //  Connected successfully.  Fake up account info.

            _fAdminConnect = TRUE;      // so destructor will disconnect
        }
    }

    return err;
}


/*******************************************************************

    NAME:       LOCAL_USER::QueryPriv

    SYNOPSIS:   Returns the privilege level of a user

    RETURNS:    USER_PRIV_GUEST, USER_PRIV_USER, or USER_PRIV_ADMIN

    HISTORY:
        gregj   4/23/91         Created

********************************************************************/

UINT LOCAL_USER::QueryPriv() const
{
    return((!QueryError()) ?
           (_fAdminConnect ? USER_PRIV_ADMIN : USER_11::QueryPriv()) : 0) ;
}


/*******************************************************************

    NAME:       LOCAL_USER::QueryAuthFlags

    SYNOPSIS:   Returns the authorization flags (operator rights)
                of a user

    RETURNS:    Mask containing any of the following:

                AF_OP_PRINT     Print operator
                AF_OP_COMM      Comm queue operator
                AF_OP_SERVER    Server operator
                AF_OP_ACCOUNTS  Accounts operator

    HISTORY:
        gregj   4/23/91         Created

********************************************************************/

ULONG LOCAL_USER::QueryAuthFlags() const
{
    return((!QueryError() && !_fAdminConnect) ? USER_11::QueryAuthFlags() : 0L) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmow32.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

/*
 * History
 *	jonn        9/16/92       Created
 */

#include "pchlmobj.hxx"  // Precompiled header

#include "lmow32.hxx"


/**********************************************************\

    NAME:       ::GetW32ComputerName

    SYNOPSIS:   loads ::GetComputerName into an NLS_STR

    RETURNS:    APIERR

    HISTORY:
        jonn        9/16/92       Created

\**********************************************************/

APIERR GetW32ComputerName( NLS_STR & nls )
{
    DWORD cbBufLen = (MAX_COMPUTERNAME_LENGTH+1) * sizeof(TCHAR);
    BUFFER buf( (UINT)cbBufLen );
    APIERR err = buf.QueryError();
    if ( err == NERR_Success )
    {
        if ( !::GetComputerName( (TCHAR *)buf.QueryPtr(), &cbBufLen ) )
        {
            err = ::GetLastError();
            DBGEOL( "::GetW32ComputerName: error " << err );
        }
        else
        {
            err = nls.CopyFrom( (const TCHAR *)buf.QueryPtr() );
            DBGEOL( "::GetW32ComputerName: string error " << err );
        }
    }

    return err;
}


/**********************************************************\

    NAME:       ::GetW32UserName

    SYNOPSIS:   loads ::GetUserName into an NLS_STR

    RETURNS:    APIERR

    NOTES:      Note that, contrary to the documentation, this will
                always get the username and never the fullname.

    HISTORY:
        jonn        9/16/92       Created

\**********************************************************/

APIERR GetW32UserName( NLS_STR & nls )
{
    DWORD cbBufLen = (UNLEN+1) * sizeof(TCHAR);
    BUFFER buf( (UINT)cbBufLen );
    APIERR err = buf.QueryError();
    if ( err == NERR_Success )
    {
        if ( !::GetUserName( (TCHAR *)buf.QueryPtr(), &cbBufLen ) )
        {
            err = ::GetLastError();
            DBGEOL( "::GetW32UserName: error " << err );
        }
        else
        {
            err = nls.CopyFrom( (const TCHAR *)buf.QueryPtr() );
            DBGEOL( "::GetW32UserName: string error " << err );
        }
    }

    return err;
}


/**********************************************************\

    NAME:       ::GetW32UserAndDomainName

    SYNOPSIS:   loads username and domain name into two NLS_STRs

    RETURNS:    APIERR

    NOTES:      Note that, contrary to the documentation, this will
                always get the username and never the fullname.

                Unlike ::GetUserName, this information is always for
                the calling process, and does not take impersonation
                into account.

                This code was stolen from ADVAPI32.DLL and slightly
                modified, thus the mixed metaphor between RTL calls
                and NETUI primitives.

    HISTORY:
        jonn        9/17/92       Templated from windows\base\advapi\username.c

\**********************************************************/

APIERR GetW32UserAndDomainName( NLS_STR & nlsUserName,
                                NLS_STR & nlsDomainName )
{
    APIERR err = NERR_Success;

    // Never mind about impersonating anybody.
    // Instead, lets get the token out of the process.

    HANDLE hToken = NULL;
    if (!::OpenProcessToken( ::GetCurrentProcess(), TOKEN_QUERY, &hToken ))
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        DBGEOL(   "ADMIN: GetW32UserAndDomainName: ::OpenProcessToken() error "
               << err );
    }

    // determine how much space will be needed for token information
    // we expect ERROR_INSUFFICIENT_BUFFER

    DWORD cbTokenBuffer = 0;
    TOKEN_USER *pUserToken = NULL;
    if (   (err == NERR_Success)
        && !::GetTokenInformation( hToken, TokenUser, pUserToken,
                                   cbTokenBuffer, &cbTokenBuffer )
       )
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            err = NERR_Success;
        }
        else if (err != NERR_Success)
        {
            DBGEOL(   "ADMIN: GetW32UserAndDomainName: first call to ::GetTokenInformation() error"
                   << err);
        }
    }
    TRACEEOL( "ADMIN: GetW32UserAndDomainName: token buffer " << cbTokenBuffer );

    // now get token information

    BUFFER bufTokenInformation( (UINT)cbTokenBuffer );
    if (   err == NERR_Success
        && (err = bufTokenInformation.QueryError()) == NERR_Success
        && (pUserToken = (TOKEN_USER *)bufTokenInformation.QueryPtr(), TRUE)
        && (!::GetTokenInformation( hToken, TokenUser,  pUserToken,
                                    cbTokenBuffer, &cbTokenBuffer))
       )
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        DBGEOL(   "ADMIN: GetW32UserAndDomainName: second call to ::GetTokenInformation() error "
               << err);
    }

    if (hToken != NULL)
    {
        ::CloseHandle( hToken );
    }

    // determine how much space is needed for username and domainname

    TCHAR * pchUserNameBuffer = NULL;
    DWORD cchUserNameBuffer = 0;
    TCHAR * pchDomainNameBuffer = NULL;
    DWORD cchDomainNameBuffer = 0;
    SID_NAME_USE SidNameUse;
    if (   err == NERR_Success
        && (!::LookupAccountSid( NULL, pUserToken->User.Sid,
                                 pchUserNameBuffer, &cchUserNameBuffer,
                                 pchDomainNameBuffer, &cchDomainNameBuffer,
                                 &SidNameUse))
       )
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            err = NERR_Success;
        }
        else if (err != NERR_Success)
        {
            DBGEOL( "ADMIN: GetW32UserAndDomainName: first call to ::LookupAccountSid() error "
                   << err );
        }
    }
    TRACEEOL( "ADMIN: GetW32UserAndDomainName: user buffer " << cchUserNameBuffer );
    TRACEEOL( "ADMIN: GetW32UserAndDomainName: domain buffer " << cchDomainNameBuffer );

    // now get username and domainname

    BUFFER  bufUserName( (UINT)cchUserNameBuffer*sizeof(TCHAR) );
    BUFFER  bufDomainName( (UINT)cchDomainNameBuffer*sizeof(TCHAR) );
    if (   err == NERR_Success
        && (err = bufUserName.QueryError()) == NERR_Success
        && (err = bufDomainName.QueryError()) == NERR_Success
        && (pchUserNameBuffer = (TCHAR *)bufUserName.QueryPtr(), TRUE)
        && (pchDomainNameBuffer = (TCHAR *)bufDomainName.QueryPtr(), TRUE)
        && (!::LookupAccountSid( NULL, pUserToken->User.Sid,
                                 pchUserNameBuffer, &cchUserNameBuffer,
                                 pchDomainNameBuffer, &cchDomainNameBuffer,
                                 &SidNameUse))
       )
    {
        REQUIRE( (err = ::GetLastError()) != NERR_Success );
        DBGEOL( "ADMIN: GetW32UserAndDomainName: second call to ::LookupAccountSid() error "
               << err );
    }

    // now copy the username and domainname

    if (err == NERR_Success)
    {
        if (   (err = nlsUserName.CopyFrom( pchUserNameBuffer )) != NERR_Success
            || (err = nlsDomainName.CopyFrom( pchDomainNameBuffer )) != NERR_Success
           )
        {
            DBGEOL(   "ADMIN: GetW32UserAndDomainName: final copy error "
                   << err );
        }
    }

#ifdef DEBUG
    if (err != NERR_Success)
    {
        DBGEOL( "ADMIN: GetW32UserAndDomainName: returns " << err );
    }
    else
    {
        TRACEEOL(   "ADMIN: GetW32UserAndDomainName: username    \""
                 << nlsUserName
                 << "\"" );
        TRACEEOL(   "ADMIN: GetW32UserAndDomainName: domain name \""
                 << nlsDomainName
                 << "\"" );
    }
#endif DEBUG

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmowks.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

/*  HISTORY:
 *	ChuckC	    07-Dec-1990     Created
 *	beng	    11-Feb-1991     Uses lmui.hxx
 *	ChuckC	    3/6/91	    Code Review changes from 2/28/91
 *				    (chuckc,johnl,rustanl,annmc,jonshu)
 *	terryk	    9/17/91	    Change the parent class from LM_OBJ
 *				    to LOC_LM_BOJ
 *	terryk	    10/7/91	    types changes for NT
 *	KeithMo	    10/8/91	    Now includes LMOBJP.HXX.
 *	terryk	    10/17/91	    WIN 32 conversion
 *	terryk	    10/21/91	    WIN 32 conversion
 *	KeithMo	    10/22/91	    Would you believe more WIN 32 conversion?
 *	jonn        10/31/91	    Removed SetBufferSize
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


/************************* workstation, Level 10 ************************/

/**********************************************************\

    NAME:       WKSTA_10::WKSTA_10

    SYNOPSIS:   workstation 10 constructor

    ENTRY:      const TCHAR * pszName - computer name

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    17-Sep-1991	    Add QueryError()

\**********************************************************/

WKSTA_10::WKSTA_10(const TCHAR * pszName)
    : COMPUTER (pszName),
    uMinorVer( 0 ),
    uMajorVer( 0 ),
    pszLogonUser( NULL ),
    pszWkstaDomain( NULL ),
    pszLogonDomain( NULL ),
    pslOtherDomains( NULL )
#ifdef WIN32
    , _pwkui1( NULL )
#endif	// WIN32
{
}

/**********************************************************\

    NAME:       WKSTA_10::~WKSTA_10

    SYNOPSIS:   destructor for workstation 10 object

    HISTORY:
	ChuckC	    07-Dec-1990     Created

\**********************************************************/

WKSTA_10::~WKSTA_10()
{
    // destroy what we had allocated
    delete pslOtherDomains ;
    pslOtherDomains = NULL ;

#ifdef WIN32
    ::MNetApiBufferFree( (BYTE **)&_pwkui1 );
#endif	// WIN32
}


/**********************************************************\

    NAME:       WKSTA_10::I_GetInfo

    SYNOPSIS:   Get information for the workstation object

    RETURN:     APIERR err - NERR_Success for succeed. otherwise,
			    failure.

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    17-Sep-1991	    use internal buffer object
	jonn	    13-Oct-1991     Removed SetBufferSize
        jonn        25-Jun-1992     Changed from NetWkstaUserEnum
                                            to   NetWkstaUserGetInfo

\**********************************************************/

APIERR WKSTA_10::I_GetInfo()
{
#ifdef WIN32

    PWKSTA_INFO_100	pwki100	 = NULL;

    APIERR err = ::MNetWkstaGetInfo( QueryName(), 100, (BYTE **)&pwki100 );
    SetBufferPtr( (BYTE *)pwki100 );

    if( err != NERR_Success )
    {
    	return err;
    }

    // BUGBUG should be an assert
    if ( (QueryName() != NULL) && (QueryName()[0] != TCH('\0')) )
    {
        // BUGBUG what???
        // UIDEBUG( SZ("WKSTA_10::I_GetInfo(): WARNING: non-NULL server") );
    }

    err = ::MNetWkstaUserGetInfo( NULL, 1, (BYTE **)&_pwkui1 );

    // This may have been called during setup when no one is logged on.
    if( err == ERROR_NO_SUCH_LOGON_SESSION )
    {
        _pwkui1 = NULL;
        err = NERR_Success;
    }

    if( err != NERR_Success )
    {
	return err;
    }

    err = SetName( pwki100->wki100_computername );

    if( err != NERR_Success )
    {
	return err;
    }

    //
    //	WIN32BUGBUG!
    //
    //	If NetWkstaUserEnum() is invoked against a down-level
    //	server, it returns NERR_Success but a NULL _pwkui1 pointer.
    //

    if( _pwkui1 == NULL )
    {
    	pszLogonUser   = NULL;
	pszLogonDomain = NULL;
    }
    else
    {
	pszLogonUser = (TCHAR *)_pwkui1->wkui1_username;
	if( ( pszLogonUser != NULL ) && ( *pszLogonUser == TCH('\0') ) )
	{
	    pszLogonUser = NULL;
	}

	pszLogonDomain = (TCHAR *)_pwkui1->wkui1_logon_domain;
	if( ( pszLogonDomain != NULL ) && ( *pszLogonDomain == TCH('\0') ) )
	{
	    pszLogonDomain = NULL;
	}
    }

    pszWkstaDomain = (TCHAR *)pwki100->wki100_langroup ;
    uMajorVer = (UINT)pwki100->wki100_ver_major ;
    uMinorVer = (UINT)pwki100->wki100_ver_minor ;

    if( pslOtherDomains != NULL )
    {
	delete pslOtherDomains; // delete old
	pslOtherDomains = NULL;
    }

    //
    //	WIN32BUGBUG!
    //
    //	oth_domains is not currently available via any
    //	non-priveledged API.
    //

    pslOtherDomains = new STRLIST( SZ(""), SZ(" ") );
    if( pslOtherDomains == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NERR_Success;

#else	// !WIN32

    struct  wksta_info_10 * lpwki10Buffer ;

    /*
     * We get the info by doing a NetWkstaGetInfo. No need to
     * realloc, since MAX_WKSTA_INFO_SIZE guarantees correct size.
     */

    BYTE *pBuffer = NULL;
    APIERR err = ::MNetWkstaGetInfo (QueryName(), 10, &pBuffer );

    if ( ! err )
    {
	SetBufferPtr( pBuffer );
	lpwki10Buffer = (struct wksta_info_10 *) QueryBufferPtr() ;
        err = SetName( lpwki10Buffer->wki10_computername) ;
	if ( err != NERR_Success )
	{
	    return err;
	}
	pszLogonUser = (TCHAR *) lpwki10Buffer->wki10_username ;
	if (pszLogonUser && *pszLogonUser == TCH('\0'))
	    pszLogonUser = NULL ;
	pszLogonDomain = (TCHAR *) lpwki10Buffer->wki10_logon_domain ;
	if (pszLogonDomain && *pszLogonDomain == TCH('\0'))
	    pszLogonDomain = NULL ;
	pszWkstaDomain = (TCHAR *) lpwki10Buffer->wki10_langroup ;
	uMajorVer = lpwki10Buffer->wki10_ver_major ;
	uMinorVer = lpwki10Buffer->wki10_ver_minor ;
	if (pslOtherDomains)
	    delete pslOtherDomains ; // delete old
	if (!(pslOtherDomains =
	    new STRLIST(lpwki10Buffer->wki10_oth_domains,SZ(" "))))
	{
	    return ERROR_NOT_ENOUGH_MEMORY;
	}
    }

    return err;

#endif	// WIN32
}

/**********************************************************\

    NAME:       WKSTA_10::QueryMajorVer

    SYNOPSIS:   query major version of the workstation object

    RETURN:     UINT - 0 if the object is in invalid state
		return usMajorVer otherwise

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

UINT WKSTA_10::QueryMajorVer() const
{
    CHECK_OK( 0 );
    return uMajorVer;
}

/**********************************************************\

    NAME:       WKSTA_10::QueryMinorVer

    SYNOPSIS:   query minor version of object

    RETURN:     UINT - 0 if the object is in invalid state
		return usMinorVer otherwise

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

UINT WKSTA_10::QueryMinorVer() const
{
    CHECK_OK( 0 );
    return uMinorVer;
}


/**********************************************************\

    NAME:       WKSTA_10::QueryLogonUser

    SYNOPSIS:   query the current logon user on the workstation object

    RETURN:	PSZ - NULL if the object is invalid
		otherwise it will return the logon user name

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_10::QueryLogonUser() const
{
    CHECK_OK( NULL );
    return pszLogonUser;
}

/**********************************************************\

    NAME:       WKSTA_10::QueryWkstaDomain

    SYNOPSIS:   query the current workstation domain

    RETURN:     PSZ - NULL if the object is invalid
		otherwise it will return the wkstation domain name

    HISTORY:
   	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_10::QueryWkstaDomain() const
{
    CHECK_OK( NULL );
    return pszWkstaDomain;
}

/**********************************************************\

    NAME:       WKSTA_10::QueryLogonDomain

    SYNOPSIS:   query the current logon user domain

    RETURN:     PSZ - NULL if the object is invalid
		otherwise it will return the logon domain name

    HISTORY:
   	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_10::QueryLogonDomain() const
{
    CHECK_OK( NULL );
    return pszLogonDomain;
}

/**********************************************************\

    NAME:       WKSTA_10::QueryOtherDomains

    SYNOPSIS:   query other domains

    RETURN:     PSZ - NULL if the object is invalid
		otherwise it will return the logon domain name

    HISTORY:
   	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

STRLIST * WKSTA_10::QueryOtherDomains() const
{
    CHECK_OK( NULL );
    return pslOtherDomains;
}

/************************* workstation, Level 1 *************************/

/**********************************************************\

    NAME:       WKSTA_1::WKSTA_1

    SYNOPSIS:   workstation 1 constructor

    ENTRY:      const TCHAR * pszName - workstation name

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    use LOC_LM_OBJ as parent's parent class

\**********************************************************/

WKSTA_1::WKSTA_1(const TCHAR * pszName)
    : WKSTA_10(pszName),
    pszLogonServer( NULL ),
    pszLMRoot( NULL )
#ifdef WIN32
    , _pwkui1( NULL )
#endif	// WIN32
{
}

/**********************************************************\

    NAME:       WKSTA_1::~WKSTA_1

    SYNOPSIS:   destructor for thw workstation 1

    HISTORY:
	ChuckC	    07-Dec-1990     Created

\**********************************************************/

WKSTA_1::~WKSTA_1()
{
#ifdef WIN32
    ::MNetApiBufferFree( (BYTE **)&_pwkui1 );
#endif	// WIN32
}

/**********************************************************\

    NAME:       WKSTA_1::I_GetInfo

    SYNOPSIS:   Get information for the workstation

    RETURN:	APIERR err - NERR_Successs for succeed.
		Failure otherwise.

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	jonn	    13-Oct-1991     Removed SetBufferSize
        jonn        25-Jun-1992     Changed from NetWkstaUserEnum
                                            to   NetWkstaUserGetInfo

\**********************************************************/

APIERR WKSTA_1::I_GetInfo()
{
#ifdef WIN32

    PWKSTA_INFO_101	pwki101	 = NULL;

    APIERR err = ::MNetWkstaGetInfo( QueryName(), 101, (BYTE **)&pwki101 );
    SetBufferPtr( (BYTE *)pwki101 );

    if( err != NERR_Success )
    {
    	return err;
    }

    // BUGBUG should be an assert
    if ( (QueryName() != NULL) && (QueryName()[0] != TCH('\0')) )
    {
        // BUGBUG what???
        // UIDEBUG( SZ("WKSTA_1::I_GetInfo(): WARNING: non-NULL server") );
    }

    err = ::MNetWkstaUserGetInfo( NULL, 1, (BYTE **)&_pwkui1 );

    if( err != NERR_Success )
    {
	return err;
    }

    err = SetName( pwki101->wki101_computername );

    if( err != NERR_Success )
    {
	return err;
    }

    pszLogonUser = (TCHAR *)_pwkui1->wkui1_username;
    if( ( pszLogonUser != NULL ) && ( *pszLogonUser == TCH('\0') ) )
    {
	pszLogonUser = NULL;
    }

    pszLogonDomain = (TCHAR *)_pwkui1->wkui1_logon_domain;
    if( ( pszLogonDomain != NULL ) && ( *pszLogonDomain == TCH('\0') ) )
    {
	pszLogonDomain = NULL;
    }

    pszWkstaDomain = (TCHAR *)pwki101->wki101_langroup ;
    pszLMRoot = (TCHAR *)pwki101->wki101_lanroot;
    pszLogonServer = (TCHAR *)_pwkui1->wkui1_logon_server;
    uMajorVer = (UINT)pwki101->wki101_ver_major ;
    uMinorVer = (UINT)pwki101->wki101_ver_minor ;

    if( pslOtherDomains != NULL )
    {
	delete pslOtherDomains; // delete old
	pslOtherDomains = NULL;
    }

    //
    //	WIN32BUGBUG!
    //
    //	oth_domains is not currently available via any
    //	non-priveledged API.
    //

    pslOtherDomains = new STRLIST( SZ(""), SZ(" ") );
    if( pslOtherDomains == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY;
    }

    return NERR_Success;

#else	// !WIN32

    struct  wksta_info_1 * lpwki1Buffer ;
    BYTE *pBuffer = NULL;
    APIERR err = ::MNetWkstaGetInfo (QueryName(), 1, &pBuffer );
    /*
     * We get the info by doing a NetWkstaGetInfo. No need to
     * realloc, since MAX_WKSTA_INFO_SIZE guarantees correct size.
     */
    if ( ! err )
    {
        SetBufferPtr( pBuffer );

	lpwki1Buffer = (struct wksta_info_1 *) QueryBufferPtr() ;
	err =  SetName( lpwki1Buffer->wki1_computername) ;
	if ( err != NERR_Success )
	{
	    return err;
	}
	pszLogonUser = (TCHAR *) lpwki1Buffer->wki1_username ;
	if (pszLogonUser && *pszLogonUser == TCH('\0'))
	    pszLogonUser = NULL ;
	pszLogonDomain = (TCHAR *) lpwki1Buffer->wki1_logon_domain ;
	if (pszLogonDomain && *pszLogonDomain == TCH('\0'))
	    pszLogonDomain = NULL ;
	pszWkstaDomain = (TCHAR *) lpwki1Buffer->wki1_langroup ;
	pszLMRoot = (TCHAR *) lpwki1Buffer->wki1_root ;
	pszLogonServer = (TCHAR *) lpwki1Buffer->wki1_logon_server ;
	uMajorVer = lpwki1Buffer->wki1_ver_major ;
	uMinorVer = lpwki1Buffer->wki1_ver_minor ;
	if (pslOtherDomains)
	    delete pslOtherDomains ; // delete old
	if (!(pslOtherDomains =
		new STRLIST(lpwki1Buffer->wki1_oth_domains,SZ(" "))))
	{
	    return(ERROR_NOT_ENOUGH_MEMORY) ;
	}
    }

    return( err ) ;

#endif	// WIN32
}

/**********************************************************\

    NAME:       WKSTA_1::QueryLMRoot

    SYNOPSIS:   query the lan manager root for the workstation object

    RETURN:     PSZ - NULL if the object is invalid
		return pszLMRoot if the object is valid

    HISTORY:
	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_1::QueryLMRoot() const
{
    CHECK_OK( NULL );
    return pszLMRoot;
}

/**********************************************************\

    NAME:       WKSTA_1::QueryLogonServer

    SYNOPSIS:   query logon server

    RETURN:	PSZ - NULL if the object is invalid
		otherwise, it will return the logon server name

    HISTORY:
   	ChuckC	    07-Dec-1990     Created
	terryk	    18-Sep-1991	    Use CHECK_OK macro

\**********************************************************/

const TCHAR * WKSTA_1::QueryLogonServer() const
{
    CHECK_OK( NULL );
    return pszLogonServer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmowksu.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmowksu.hxx
    Class definitions for the WKSTA_USER_1 class.

    The WKSTA_USER_1 class represents the local logged-on user.


    FILE HISTORY:
        KeithMo     14-Apr-1992 Created.

*/

#include "pchlmobj.hxx"  // Precompiled header


//
//  WKSTA_USER_1 methods.
//

/*******************************************************************

    NAME:       WKSTA_USER_1 :: WKSTA_USER_1

    SYNOPSIS:   WKSTA_USER_1 class constructor.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
WKSTA_USER_1 :: WKSTA_USER_1( VOID )
  : NEW_LM_OBJ(),
    _nlsUserName(),
    _nlsLogonDomain(),
    _nlsOtherDomains(),
    _nlsLogonServer()
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    APIERR err;

    if( ( ( err = _nlsUserName.QueryError()     ) != NERR_Success ) ||
        ( ( err = _nlsLogonDomain.QueryError()  ) != NERR_Success ) ||
        ( ( err = _nlsOtherDomains.QueryError() ) != NERR_Success ) ||
        ( ( err = _nlsLogonServer.QueryError()  ) != NERR_Success ) )
    {
        ReportError( err );
        return;
    }

}   // WKSTA_USER_1 :: WKSTA_USER_1


/*******************************************************************

    NAME:       WKSTA_USER_1 :: ~WKSTA_USER_1

    SYNOPSIS:   WKSTA_USER_1 class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
WKSTA_USER_1 :: ~WKSTA_USER_1( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // WKSTA_USER_1 :: ~WKSTA_USER_1


/*******************************************************************

    NAME:       WKSTA_USER_1 :: I_GetInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxGetInfo API (info-level 1).

    EXIT:       The API has been invoked, and any "persistant" data
                has been cached.  For WKSTA_USER_1, this includes the
                user name, logon domain, other domains, and logon
                server.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
APIERR WKSTA_USER_1 :: I_GetInfo( VOID )
{
    BYTE * pbBuffer = NULL;

    //
    //  Invoke the API.
    //
    //          BUGBUG!!!  WE NEED MNET SUPPORT FOR THIS API!!!
    //

    APIERR err = ::NetWkstaUserGetInfo( NULL,
                                        1,
                                        (LPBYTE *)&pbBuffer );

    //
    //  Tell NEW_LM_OBJ where the buffer is.
    //

    SetBufferPtr( pbBuffer );

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Extract the relevant structure fields.
    //

    WKSTA_USER_INFO_1 * pwkui1 = (WKSTA_USER_INFO_1 *)pbBuffer;

    err = SetUserName( pwkui1->wkui1_username );

    if( err == NERR_Success )
    {
        err = SetLogonDomain( pwkui1->wkui1_logon_domain );
    }

    if( err == NERR_Success )
    {
        err = SetOtherDomains( pwkui1->wkui1_oth_domains );
    }

    if( err == NERR_Success )
    {
        err = SetLogonServer( pwkui1->wkui1_logon_server );
    }

    return err;

}   // WKSTA_USER_1 :: I_GetInfo


/*******************************************************************

    NAME:       WKSTA_USER_1 :: I_WriteInfo

    SYNOPSIS:   Virtual callout used by NEW_LM_OBJ to invoke the
                NetXxxSetInfo API (info-level 1).

    EXIT:       If successful, the local workstation has been updated.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
APIERR WKSTA_USER_1 :: I_WriteInfo( VOID )
{
    //
    //  Update the WKSTA_USER_INFO_1 structure.
    //

    APIERR err = W_Write();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Invoke the API to do the actual workstation update.
    //
    //          BUGBUG!!!  WE NEED MNET SUPPORT FOR THIS API!!!
    //

#if 0   // BUGBUG! not in NETAPI.LIB???

    return ::NetWkstaUserSetInfo( NULL,
                                  1,
                                  (LPBYTE)QueryBufferPtr(),
                                  NULL );

#else

    return ERROR_NOT_SUPPORTED;

#endif

}   // WKSTA_USER_1 :: I_WriteInfo


/*******************************************************************

    NAME:       WKSTA_USER_1 :: W_Write

    SYNOPSIS:   Helper function for WriteNew and WriteInfo -- loads
                current values into the API buffer.

    EXIT:       The API buffer has been filled.

    RETURNS:    APIERR                  - The result of the API.

    HISTORY:
        KeithMo     14-Apr-1992 Created.

********************************************************************/
APIERR WKSTA_USER_1 :: W_Write( VOID )
{
    WKSTA_USER_INFO_1 * pwkui1 = (WKSTA_USER_INFO_1 *)QueryBufferPtr();
    ASSERT( pwkui1 != NULL );

    pwkui1->wkui1_username     = (LPTSTR)QueryUserName();
    pwkui1->wkui1_logon_domain = (LPTSTR)QueryLogonDomain();
    pwkui1->wkui1_oth_domains  = (LPTSTR)QueryOtherDomains();
    pwkui1->wkui1_logon_server = (LPTSTR)QueryLogonServer();

    return NERR_Success;

}   // WKSTA_USER_1 :: W_Write
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmsrvres.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    lmsrvres.hxx
    Implementation of the LM_SRVRES class.

    The LM_SRVRES class is a container for a number of utility
    functions pertaining to resources.  These functions mainly
    deal with collecting various run-time server statistics,
    such as counts of open files and print jobs.

    FILE HISTORY:
        KeithMo     27-Aug-1991 Created.
        KeithMo     06-Oct-1991 Win32 Conversion.
        ChuckC      01-Dec-1991 Split from SERVER/H, cleanup to remove
                                stuff that dont belong, no pixel drawing
                                in this baby.
        ChuckC      17-Feb-1992 Code review changes
*/

#include "pchlmobj.hxx"  // Precompiled header

extern "C"
{
    #include <mnet.h>

}   // extern "C"


//
//  LM_SRVRES methods.
//

/*******************************************************************

    NAME:       LM_SRVRES :: LM_SRVRES

    SYNOPSIS:   LM_SRVRES class constructor.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
LM_SRVRES :: LM_SRVRES()
{
    //
    //  This space intentionally left blank.
    //

}   // LM_SRVRES :: LM_SRVRES


/*******************************************************************

    NAME:       LM_SRVRES :: ~LM_SRVRES

    SYNOPSIS:   LM_SRVRES class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
LM_SRVRES :: ~LM_SRVRES()
{
    //
    //  This space intentionally left blank.
    //

}   // LM_SRVRES :: ~LM_SRVRES


/*******************************************************************

    NAME:       LM_SRVRES :: GetResourceCount

    SYNOPSIS:   This method retrieves the number of open named
                pipes, open files, and file locks on the target
                server.

    ENTRY:      pszServerName           - The name of the target server.

                pcOpenFiles             - Will receive a count of the
                                          remotely opened files.

                pcFileLocks             - Will receive a count of the
                                          remotely locked files.

                pcOpenNamedPipes        - Will receive a count of the
                                          remotely opened named pipes.

                pcOpenCommQueues        - Will receive a count of the
                                          remotely opened comm queues.

                pcOpenPrintQueues       - Will receive a count of the
                                          remotely opened print queues.

                pcOtherResources        - Will receive a count of the
                                          remotely opened "other"
                                          (unknown) resources.

    RETURNS:    APIERR                  - Any errors encountered.  If
                                          not NERR_Success, then the
                                          returned counts are invalid.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
APIERR LM_SRVRES :: GetResourceCount( const TCHAR * pszServerName,
                                      ULONG *      pcOpenFiles,
                                      ULONG *      pcFileLocks,
                                      ULONG *      pcOpenNamedPipes,
                                      ULONG *      pcOpenCommQueues,
                                      ULONG *      pcOpenPrintQueues,
                                      ULONG *      pcOtherResources )
{
    UIASSERT(pcOpenFiles != NULL) ;
    UIASSERT(pcFileLocks != NULL) ;
    UIASSERT(pcOpenNamedPipes != NULL) ;
    UIASSERT(pcOpenCommQueues != NULL) ;
    UIASSERT(pcOpenPrintQueues != NULL) ;
    UIASSERT(pcOtherResources != NULL) ;

    FILE3_ENUM  enumFile3( pszServerName, NULL, NULL );

    APIERR err = enumFile3.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  We've got our enumeration, now tally up the
    //  open named pipes, open files and file locks.
    //

    ULONG cOpenNamedPipes  = 0L;
    ULONG cOpenFiles       = 0L;
    ULONG cFileLocks       = 0L;
    ULONG cOpenCommQueues  = 0L;
    ULONG cOpenPrintQueues = 0L;
    ULONG cOtherResources  = 0L;

    FILE3_ENUM_ITER iterFile3( enumFile3 );
    const FILE3_ENUM_OBJ * pfi3;

    while( ( pfi3 = iterFile3( &err ) ) != NULL )
    {
        if( IS_FILE( pfi3->QueryPathName() ) )
        {
            //
            //  It's a "normal" file.
            //

            cOpenFiles++;
        }
        else
        if( IS_PIPE( pfi3->QueryPathName() ) )
        {
            //
            //  It's a pipe.
            //

            cOpenNamedPipes++;
        }
        else
        if( IS_COMM( pfi3->QueryPathName() ) )
        {
            //
            //  It's a comm queue.
            //

            cOpenCommQueues++;
        }
        else
        if( IS_PRINT( pfi3->QueryPathName() ) )
        {
            //
            //  It's a print queue.
            //

            cOpenPrintQueues++;
        }
        else
        {
            //
            //  It's some other resource.
            //

            cOtherResources++;
        }

        cFileLocks += (ULONG)pfi3->QueryNumLocks();
    }

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Update the counters.
    //

    *pcOpenFiles       = cOpenFiles;
    *pcFileLocks       = cFileLocks;
    *pcOpenNamedPipes  = cOpenNamedPipes;
    *pcOpenCommQueues  = cOpenCommQueues;
    *pcOpenPrintQueues = cOpenPrintQueues;
    *pcOtherResources  = cOtherResources;

    return NERR_Success;

}   // LM_SRVRES :: GetResourceCount


/*******************************************************************

    NAME:       LM_SRVRES :: GetSessionCount

    SYNOPSIS:   This method retrieves the number of sessions
                active on the target server.

    ENTRY:      pszServerName           - The name of the target server.

                pcSessions              - Will receive a count of the
                                          active sessions.

    RETURNS:    APIERR                  - Any errors encountered.  If
                                          not NERR_Success, then the
                                          returned counts are invalid.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
APIERR LM_SRVRES :: GetSessionsCount( const TCHAR * pszServerName,
                                      ULONG *      pcSessions )
{
    //
    // CODEWORK - this can be faster, info is avail from single API
    // call, but there is no LMOBJ for it
    //

    SESSION0_ENUM enumSession0( pszServerName );

    APIERR err = enumSession0.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  We've got our enumeration, now tally up the
    //  active sessions.
    //

    ULONG cSessions = 0L;

    SESSION0_ENUM_ITER iterSession0( enumSession0 );
    const SESSION0_ENUM_OBJ * psi0;

    while( ( psi0 = iterSession0() ) != NULL )
    {
        cSessions++;
    }

    //
    //  Update the counter.
    //

    *pcSessions = cSessions;

    return NERR_Success;

}   // LM_SRVRES :: GetSessionsCount


#if 0   // not supported in NT product 1


/*******************************************************************

    NAME:       LM_SRVRES :: GetPrintJobCount

    SYNOPSIS:   This method retrieves the number of print jobs
                active on the target server.

    ENTRY:      pszServerName           - The name of the target server.

                pcPrintJobs             - Will receive a count of the
                                          active print jobs.

    RETURNS:    APIERR                  - Any errors encountered.  If
                                          not NERR_Success, then the
                                          returned counts are invalid.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
APIERR LM_SRVRES :: GetPrintJobCount( const TCHAR * pszServerName,
                                      ULONG *      pcPrintJobs )
{
    PRINTQ1_ENUM enumPrintQ1( (TCHAR *)pszServerName );

    APIERR err = enumPrintQ1.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  We've got our enumeration, now tally up the
    //  active print jobs.
    //

    ULONG cPrintJobs = 0L;

    PRINTQ1_ENUM_ITER iterPrintQ1( enumPrintQ1 );
    const PRINTQ1_ENUM_OBJ * ppqi1;

    while( ( ppqi1 = iterPrintQ1() ) != NULL )
    {
        cPrintJobs += (ULONG)ppqi1->QueryJobCount();
    }

    //
    //  Update the counter.
    //

    *pcPrintJobs = cPrintJobs;

    return NERR_Success;

}   // LM_SRVRES :: GetPrintJobCount


/*******************************************************************

    NAME:       LM_SRVRES :: GetOpenCommCount

    SYNOPSIS:   This method retrieves the number of comm ports
                remotedly opened on the target server.

    ENTRY:      pszServerName           - The name of the target server.

                pcOpenCommPorts         - Will receive a count of the
                                          remotely opened comm ports.

    RETURNS:    APIERR                  - Any errors encountered.  If
                                          not NERR_Success, then the
                                          returned counts are invalid.

    HISTORY:
        KeithMo     27-Aug-1991 Created.

********************************************************************/
APIERR LM_SRVRES :: GetOpenCommCount( const TCHAR * pszServerName,
                                      ULONG *      pcOpenCommPorts )
{
    CHARDEVQ1_ENUM enumCharDevQ1( pszServerName, NULL );

    APIERR err = enumCharDevQ1.GetInfo();

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  We've got our enumeration, now tally up the
    //  open comm ports.
    //

    ULONG cOpenCommPorts = 0L;

    CHARDEVQ1_ENUM_ITER iterCharDevQ1( enumCharDevQ1 );
    const CHARDEVQ1_ENUM_OBJ * pcqi1;

    while( ( pcqi1 = iterCharDevQ1() ) != NULL )
    {
        cOpenCommPorts += (ULONG)pcqi1->QueryNumUsers();
    }

    //
    //  Update the counter.
    //

    *pcOpenCommPorts = cOpenCommPorts;

    return NERR_Success;

}   // LM_SRVRES :: GetOpenCommCount


#endif  // 0


/*******************************************************************

    NAME:       LM_SRVRES :: NukeUsersSession

    SYNOPSIS:   Blow off the user's session to the target server.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     26-Aug-1991 Created.
        KeithMo     03-Sep-1991 Use ALIAS_STR for nlsWithoutPrefix.
        KevinL      15-Sep-1991 Moved from resbase.cxx
        KeithMo     17-Jul-1992 Removed an overactive assert.
        KeithMo     11-Apr-1993 Map NERR_ClientNameNotFound to success.
        KeithMo     01-Oct-1993 Add pszUserName, call MNetSessionDel directly.

********************************************************************/
APIERR LM_SRVRES :: NukeUsersSession( const TCHAR * pszServerName,
                                      const TCHAR * pszComputerName,
                                      const TCHAR * pszUserName )
{
    //
    //  Since the computer name (as stored in the LBI) does not
    //  contain the leading backslashes ('\\'), we must add them
    //  before we can delete the session.
    //

    NLS_STR nlsWithPrefix( SZ("\\\\") );

    if( pszComputerName != NULL )
    {
        const ALIAS_STR nlsWithoutPrefix( pszComputerName );
        nlsWithPrefix.strcat( nlsWithoutPrefix );
    }

    APIERR err = nlsWithPrefix.QueryError();

    if( err != NERR_Success )
    {
        return err;
    }

    err = ::MNetSessionDel( pszServerName,
                            pszComputerName ? nlsWithPrefix.QueryPch() : NULL,
                            pszUserName );

    if( err == NERR_ClientNameNotFound )
    {
        err = NERR_Success;
    }

    return err;

}   // LM_SRVRES :: NukeUsersSession
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lmsvc.cxx ===
/**********************************************************************/
/**                       Microsoft Windows/NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*  HISTORY:
 *      ChuckC      17-Aug-1991     Created
 *      terryk      19-Sep-1991     Change comment header
 *      ChuckC      23-Sep-1991     Code review changes.
 *                                  Attended by JimH, KeithMo, EricCh, O-SimoP
 *      KeithMo     30-Sep-1991     Moved polling logic from UI_SERVICE
 *                                  to LM_SERVICE.
 *      terryk      07-Oct-1991     types change for NT
 *      KeithMo     10/8/91         Now includes LMOBJP.HXX.
 *      terryk      10/17/91        WIN 32 conversion
 *      terryk      10/21/91        cast buffer to TCHAR * for
 *                                  MNetApiBufferFree
 *
 */

#include "pchlmobj.hxx"  // Precompiled header


#ifdef UNICODE
#define ADVANCE_CHAR(p)     p++
#define COPY_CHAR(p,q)     *p = *q
#else
#error BARF - the macros below need to be tested in non Unicode case
#define ADVANCE_CHAR(p)     if(isleadbyte(*p)) p+=2; else p++
#define COPY_CHAR(p,q)      if(isleadbyte(*p)) {*p = *q; *(p+1) = *(q+1);} \
                            else *p = *q
#endif

//
// forward declare
//
DWORD MakeNullNull(const TCHAR *pszOld, TCHAR **ppszNew)  ;
VOID  SkipWhiteSpace(TCHAR **ppsz) ;
BOOL  IsWhiteSpace(TCHAR c) ;

//
//  This is the maximum allowed polling time we'll
//  wait for a service that does not support checkpoints
//  and wait hints.
//

#define NOHINT_WAIT_TIME        ( 10 * 1000 )   // milliseconds


/*******************************************************************

    NAME:       LM_SERVICE::LM_SERVICE

    SYNOPSIS:   constructor just records service & server names,
                with validation.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

#define LM_SVC_BUFFER_SIZE      512     // reasonable initial estimate

LM_SERVICE::LM_SERVICE(const TCHAR *pszServer, const TCHAR *pszServiceName)
  : BASE(),
    CT_NLS_STR( _nlsService ),
    CT_NLS_STR( _nlsServer ),
    _pBuffer( NULL ),
    _ulServiceStatus( 0 ),
    _ulServiceCode( 0 ),
    _svcStat( LM_SVC_STATUS_UNKNOWN ),
    _uiMaxTries( DEFAULT_MAX_TRIES ),
    _uiCurrentTry( 0 ),
    _uiSleepTime( DEFAULT_SLEEP_TIME ),
    _ulOldCheckPoint( 0L ),
    _lmsvcDesiredStat( LM_SVC_STATUS_UNKNOWN ),
    _lmsvcPollStat( LM_SVC_STATUS_UNKNOWN ),
    _errExit( NERR_Success ),
    _errSpecific( NERR_Success ),
    _fIsWellKnownService( FALSE )
{
    UIASSERT(pszServiceName != NULL) ;

    if (QueryError() != NERR_Success)
        return ;

    APIERR err = SetName(pszServiceName) ;
    if (err == NERR_Success)
        err = SetServerName(pszServer) ;

    if (err != NERR_Success)
        ReportError(err) ;

    _fIsWellKnownService = W_IsWellKnownService();
}

/*******************************************************************

    NAME:       LM_SERVICE::~LM_SERVICE

    SYNOPSIS:   destructor and free up the memory

    HISTORY:
                terryk  16-Oct-91       Created

********************************************************************/

LM_SERVICE::~LM_SERVICE()
{
    ::MNetApiBufferFree( &_pBuffer );
}


/*******************************************************************

    NAME:       LM_SERVICE::Start

    SYNOPSIS:   Starts a service.

    EXIT:       Service either started or starting

    RETURNS:    API error from Service Control Operation

    NOTES:      This operation returns immediately, the service
                may not be in the desired state yet.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

APIERR LM_SERVICE::Start( const TCHAR * pszArgs,
                          UINT         uiSleepTime,
                          UINT         uiMaxTries )
{
    _uiMaxTries   = uiMaxTries;
    _uiCurrentTry = 0;
    _uiSleepTime  = uiSleepTime;
    _ulOldCheckPoint = 0L;

    _lmsvcDesiredStat = LM_SVC_STARTED;
    _lmsvcPollStat    = LM_SVC_STARTING;

    _errExit = _errSpecific = NERR_Success;

    return( W_ServiceStart(pszArgs) ) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::Pause

    SYNOPSIS:   Pause a service

    EXIT:       Service paused or pausing.

    RETURNS:    API error from Service Control Operation

    NOTES:      This operation returns immediately, the service
                may not be in the desired state yet.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

APIERR LM_SERVICE::Pause( UINT uiSleepTime, UINT uiMaxTries )
{
    _uiMaxTries   = uiMaxTries;
    _uiCurrentTry = 0;
    _uiSleepTime  = uiSleepTime;
    _ulOldCheckPoint = 0L;

    _lmsvcDesiredStat = LM_SVC_PAUSED;
    _lmsvcPollStat    = LM_SVC_PAUSING;

    _errExit = _errSpecific = NERR_Success;

    return( W_ServiceControl(SERVICE_CTRL_PAUSE) ) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::Continue

    SYNOPSIS:   Continue a service.

    EXIT:       Service continued or continuing.

    RETURNS:    API error from Service Control Operation

    NOTES:      This operation returns immediately, the service
                may not be in the desired state yet.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

APIERR LM_SERVICE::Continue( UINT uiSleepTime, UINT uiMaxTries )
{
    _uiMaxTries   = uiMaxTries;
    _uiCurrentTry = 0;
    _uiSleepTime  = uiSleepTime;
    _ulOldCheckPoint = 0L;

    _lmsvcDesiredStat = LM_SVC_STARTED;
    _lmsvcPollStat    = LM_SVC_CONTINUING;

    _errExit = _errSpecific = NERR_Success;

    return( W_ServiceControl(SERVICE_CTRL_CONTINUE) ) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::Stop

    SYNOPSIS:   Stop a service.

    EXIT:       Service stopped or stopping.

    RETURNS:    API error from Service Control Operation

    NOTES:      This operation returns immediately, the service
                may not be in the desired state yet.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     30-Sep-1991     Added polling logic from UI_SERVICE.

********************************************************************/

APIERR LM_SERVICE::Stop( UINT uiSleepTime, UINT uiMaxTries )
{
    _uiMaxTries   = uiMaxTries;
    _uiCurrentTry = 0;
    _uiSleepTime  = uiSleepTime;
    _ulOldCheckPoint = 0L;

    _lmsvcDesiredStat = LM_SVC_STOPPED;
    _lmsvcPollStat    = LM_SVC_STOPPING;

    _errExit = _errSpecific = NERR_Success;

    return( W_ServiceControl(SERVICE_CTRL_UNINSTALL) ) ;
}


/*******************************************************************

    NAME:       LM_SERVICE::IsStarted

    SYNOPSIS:   Check whether the service is started or not

    RETURNS:    TRUE if service is started.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsStarted(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_STARTED) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsPaused

    SYNOPSIS:   Check whether the service is paused or not

    RETURNS:    TRUE if service is paused

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsPaused(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_PAUSED) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsStopped

    SYNOPSIS:   Check whether the service is stopped or not

    RETURNS:    TRUE if service is stopped

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsStopped(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_STOPPED) ;
}


/*******************************************************************

    NAME:       LM_SERVICE::IsStarting

    SYNOPSIS:   Check whether the service is starting or not

    RETURNS:    TRUE if service is starting

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsStarting(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_STARTING) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsPausing

    SYNOPSIS:   Check whether the service is pausing or not

    RETURNS:    TRUE if service is pausing

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsPausing(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_PAUSING) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsStopping

    SYNOPSIS:   Check whether the service is stopping or not

    RETURNS:    TRUE if service is stopping

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsStopping(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_STOPPING) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::IsContinuing

    SYNOPSIS:   Check whether the service is continuing or not

    RETURNS:    TRUE if service is continuing

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

BOOL LM_SERVICE::IsContinuing(APIERR *pErr)
{
    return (QueryStatus(pErr) == LM_SVC_CONTINUING) ;
}


/*******************************************************************

    NAME:       LM_SERVICE::QueryStatus

    SYNOPSIS:   Query status of service. Error returned in pErr.

    RETURNS:    LM_SERVICE_STATUS indicating current status of service.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

LM_SERVICE_STATUS LM_SERVICE::QueryStatus(APIERR *pErr)
{

    LM_SERVICE_STATUS svcstat ;
    APIERR err = W_QueryStatus(&svcstat) ;
    if (pErr != NULL)
        *pErr = err ;

    return(svcstat) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::QueryFullStatus

    SYNOPSIS:   Query full status of service, including extended
                info like hints, check points, etc.

    RETURNS:    API return code from Service interrogate.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::QueryFullStatus(LM_SERVICE_STATUS *pSvcStat,
                                   LM_SERVICE_OTHER_STATUS *pSvcOtherStat)
{
    return W_QueryStatus(pSvcStat, pSvcOtherStat);
}

/*******************************************************************

    NAME:       LM_SERVICE::SetName

    SYNOPSIS:   Validates the name as valid service name, then record it.

    RETURNS:    NERR_Success if ok, ERROR_INVALID_PARAMETER other wise.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::SetName(const TCHAR *pszServiceName)
{
    APIERR err = ::I_MNetNameValidate(NULL,pszServiceName,NAMETYPE_SERVICE,0) ;
    if (err != NERR_Success)
        return(ERROR_INVALID_PARAMETER) ;

    _nlsService = pszServiceName ;
    UIASSERT(_nlsService.QueryError() == NERR_Success) ; // since CLASS_NLS_STR
    return(NERR_Success) ;
}

/*******************************************************************

    NAME:       LM_SERVICE::SetServerName

    SYNOPSIS:   Validates the name as valid server name, then record it.

    RETURNS:    NERR_Success if ok, ERROR_INVALID_PARAMETER other wise.

    HISTORY:
        ChuckC      21-Aug-1991     Created
        KeithMo     17-Jul-1992     Rewrote to take a server name *with*
                                    the leading backslashes.

********************************************************************/

APIERR LM_SERVICE::SetServerName(const TCHAR *pszServerName)
{
    //
    //  NULL/empty name always allowed.
    //

    if( ( pszServerName == NULL ) || ( *pszServerName == TCH('\0') ) )
    {
        _nlsServer = SZ("");
        return NERR_Success;
    }

    //
    //  Save away the server name.
    //

    _nlsServer = pszServerName;
    UIASSERT( _nlsServer.QueryError() == NERR_Success ); // CLASS_NLS_STR!

    //
    //  Validate the server name.
    //

    ISTR istr( _nlsServer );
    istr += 2;

#ifdef DEBUG
    {
        ISTR istrDbg( _nlsServer );
        UIASSERT( _nlsServer.QueryChar( istrDbg ) == L'\\' );
        ++istrDbg ;
        UIASSERT( _nlsServer.QueryChar( istrDbg ) == L'\\' );
    }
#endif

    APIERR err = ::I_MNetNameValidate( NULL,
                                       _nlsServer[istr],
                                       NAMETYPE_COMPUTER,
                                       0 );

    if( err != NERR_Success )
    {
        err = ERROR_INVALID_PARAMETER;
    }

    return err;

}   // LM_SERVICE::SetServerName

/*******************************************************************

    NAME:       LM_SERVICE::W_ServiceControl

    SYNOPSIS:   worker function that calls out to NetApi service control.

    ENTRY:      opcode defines the operation, fbArgs defines service
                specific information if any.

    RETURNS:    API return code.

    HISTORY:    ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::W_ServiceControl( UINT opcode, UINT fbArg)
{
    ::MNetApiBufferFree( &_pBuffer );

    APIERR err = ::MNetServiceControl( QueryServerName(),
                                       QueryName(),
                                       opcode,
                                       fbArg,
                                       &_pBuffer );

    return err;
}

/*******************************************************************

    NAME:       LM_SERVICE::W_ServiceStart

    SYNOPSIS:   worker function that actually calls ther service start
                APIs.

    RETURNS:    API return code.

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::W_ServiceStart( const TCHAR * pszArgs )
{

    TCHAR *pszNewArgs ;
    APIERR err ;

    //
    // convert pszArgs we get from UI, which is in the 'standard'
    // cmd.exe form (white space separated) to a NULL-NULL string
    // for the NetServiceInstall API.
    //
    err = MakeNullNull(pszArgs, &pszNewArgs) ;
    if( err != NERR_Success )
        return err ;

    ::MNetApiBufferFree( &_pBuffer );
    err = ::MNetServiceInstall( QueryServerName(),
                                QueryName(),
                                pszNewArgs,
                                &_pBuffer );
    delete pszNewArgs ;

    if( err == NERR_Success )
    {
        LM_SERVICE_STATUS SvcStat;

        W_InterpretStatus( (struct service_info_2 *)_pBuffer,
                           &SvcStat,
                           NULL );
    }

    return err;
}

/*******************************************************************

    NAME:       LM_SERVICE::W_QueryStatus

    SYNOPSIS:   worker method that calls NETAPI for service status info.

    RETURNS:    API return code

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

APIERR LM_SERVICE::W_QueryStatus(LM_SERVICE_STATUS *pSvcStat,
                                 LM_SERVICE_OTHER_STATUS *pSvcOtherStat)
{
    ::MNetApiBufferFree( &_pBuffer );

    /*
     * call out to NET to to get info
     */
    APIERR err = ::MNetServiceGetInfo( QueryServerName(),
                                       QueryName(),
                                       2,
                                       &_pBuffer );

    if( err == NERR_ServiceNotInstalled )
    {
        //
        //  Map to success.
        //

        *pSvcStat = LM_SVC_STOPPED;
        err = NERR_Success;
    }
    else
    if( err == NERR_Success )
    {
        W_InterpretStatus( (struct service_info_2 *)_pBuffer,
                           pSvcStat,
                           pSvcOtherStat );
    }

    return err;
}


/*******************************************************************

    NAME:       LM_SERVICE::W_InterpretStatus

    SYNOPSIS:   Worker method that interprets service status info.

    HISTORY:
        KeithMo     18-Nov-1992     Created from ChuckC's W_QueryStatus.

********************************************************************/
VOID LM_SERVICE :: W_InterpretStatus( const service_info_2    * psvi2,
                                      LM_SERVICE_STATUS       * pSvcStat,
                                      LM_SERVICE_OTHER_STATUS * pSvcOtherStat )
{
    UIASSERT( psvi2 != NULL );
    UIASSERT( pSvcStat != NULL );

    *pSvcStat = LM_SVC_STATUS_UNKNOWN ;

    if (pSvcOtherStat)
    {
        pSvcOtherStat->fUnInstallable =
            pSvcOtherStat->fPauseable =
            pSvcOtherStat->fRdrDiskPaused =
            pSvcOtherStat->fRdrPrintPaused =
            pSvcOtherStat->fRdrCommPaused =
            pSvcOtherStat->fHint = FALSE ;
        pSvcOtherStat->ulSecCode =
            pSvcOtherStat->ulCheckPointNum =
            pSvcOtherStat->ulWaitTime = 0 ;
        pSvcOtherStat->errExit =
            pSvcOtherStat->errSpecific = NERR_Success;
    }

    _ulServiceStatus = psvi2->svci2_status ;
    _ulServiceCode   = psvi2->svci2_code ;

    ULONG ulInstallState = _ulServiceStatus & (ULONG)SERVICE_INSTALL_STATE ;

    switch (ulInstallState)
    {
        case SERVICE_INSTALLED:
        {
            ULONG ulPauseState = _ulServiceStatus &
                                 (ULONG)SERVICE_PAUSE_STATE ;
            switch(ulPauseState)
            {
                case LM20_SERVICE_ACTIVE:
                    _svcStat = LM_SVC_STARTED ;
                    if( HIWORD(_ulServiceCode) == SERVICE_UIC_SYSTEM )
                        _errExit = (APIERR)LOWORD(_ulServiceCode);
                    _errSpecific = (APIERR)psvi2->svci2_specific_error;
                    break ;

                case LM20_SERVICE_CONTINUE_PENDING:
                    _svcStat = LM_SVC_CONTINUING ;
                    break ;

                case LM20_SERVICE_PAUSE_PENDING:
                    _svcStat = LM_SVC_PAUSING ;
                    break ;

                case LM20_SERVICE_PAUSED:
                    _svcStat = LM_SVC_PAUSED ;
                    break ;

                default:
                    UIASSERT(0) ;
                    break ;
            }
            break ;
        }

        case SERVICE_UNINSTALLED:
            _svcStat = LM_SVC_STOPPED ;
            if( HIWORD(_ulServiceCode) == SERVICE_UIC_SYSTEM )
                _errExit = (APIERR)LOWORD(_ulServiceCode);
            _errSpecific = (APIERR)psvi2->svci2_specific_error;
            break ;

        case SERVICE_INSTALL_PENDING:
            _svcStat = LM_SVC_STARTING ;
            break ;

        case SERVICE_UNINSTALL_PENDING:
            _svcStat = LM_SVC_STOPPING ;
            break ;

        default:
            UIASSERT(0) ;
            break ;
    }

    /*
     * calculate the other status info
     */
    W_ComputeOtherStatus(pSvcOtherStat) ;

    /*
     * set the stat, and we're outta here
     */
    *pSvcStat = _svcStat ;
}


/*******************************************************************

    NAME:       LM_SERVICE::W_ComputeOtherStatus

    SYNOPSIS:   helper function for W_QueryStatus

    ENTRY:      pSvcOtherStat initialized to all FALSE & zeros

    EXIT:       appropriate fields of pSvcOtherStat now set

    HISTORY:
        ChuckC      21-Aug-1991     Created

********************************************************************/

VOID LM_SERVICE::W_ComputeOtherStatus(LM_SERVICE_OTHER_STATUS *pSvcOtherStat)
{
    if (pSvcOtherStat == NULL)
        return ;

    pSvcOtherStat->fUnInstallable =
        (_ulServiceStatus & (ULONG)SERVICE_UNINSTALLABLE) != 0 ;

    pSvcOtherStat->fPauseable =
        (_ulServiceStatus & (ULONG)SERVICE_PAUSABLE) != 0 ;

    /*
     * following info only given with stopped services.
     * Sorry, no manifest for the shift. RTFM.
     */
    if (_ulServiceStatus & (ULONG)SERVICE_UNINSTALLED)
        pSvcOtherStat->ulSecCode = (_ulServiceCode >> 16) ;
    else
        pSvcOtherStat->ulSecCode = SERVICE_UIC_NORMAL ;

    /*
     * following info only given with starting/stopping services
     */
    if (_svcStat == LM_SVC_STARTING || _svcStat == LM_SVC_STOPPING)
    {
        pSvcOtherStat->fHint =
            ((_ulServiceCode & (ULONG)SERVICE_CCP_QUERY_HINT) != 0) ;
        if (pSvcOtherStat->fHint)
        {
            /*
             * below only valid if hint is given. Time is in 1/10
             * seconds, hence the 100 * to make it millisecs.
             */
            pSvcOtherStat->ulWaitTime =
                100L * (ULONG)SERVICE_NT_WAIT_GET(_ulServiceCode);

            pSvcOtherStat->ulCheckPointNum =
                (_ulServiceCode & SERVICE_IP_CHKPT_NUM) ;
        }
    }

    pSvcOtherStat->errExit     = _errExit;
    pSvcOtherStat->errSpecific = _errSpecific;

}


/*******************************************************************

    NAME:       LM_SERVICE :: Poll

    SYNOPSIS:   Polls the service after a Start(), Stop(), Pause(),
                or Continue() operation to see if the operation has
                completed.

    ENTRY:      pfDone                  - Will receive TRUE if the
                                          operation has completed (either
                                          successfully or with failure).
                                          Will receive FALSE otherwise.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:

    HISTORY:
        KeithMo     30-Sep-1991     Created.

********************************************************************/
APIERR LM_SERVICE :: Poll( BOOL * pfDone )
{
    UIASSERT( pfDone != NULL );

    LM_SERVICE_STATUS       lmsvcStat;
    LM_SERVICE_OTHER_STATUS lmsvcOtherStat;

    //
    //  Assume we'll finish the operation.  In this context, "finish"
    //  means either the operation (i.e. Pause) is complete OR a
    //  fatal error occurred.
    //

    *pfDone = TRUE;

    //
    //  Retrieve the service status.
    //

    APIERR err = QueryFullStatus( &lmsvcStat, &lmsvcOtherStat );

    if( err != NERR_Success )
    {
        //
        //  Error retrieving service status.  We're done.
        //

        return err;
    }

    if( lmsvcStat == _lmsvcDesiredStat )
    {
        //
        //  The service has reached its desired state.  We're done.
        //

        return NERR_Success;
    }

    if( lmsvcStat != _lmsvcPollStat )
    {
        //
        //  The service is returning a bogus status.  Bail out.
        //

        err = QueryExitCode();

        if( err == NERR_Success )
        {
            err = NERR_InternalError;
        }

        return err;
    }

    //
    //  At this point, we can assume the operation is not yet complete.
    //

    *pfDone = FALSE;

    if( !lmsvcOtherStat.fHint )
    {
        //
        //  This service does not support checkpoints & wait hints.
        //  We'll cobble up some fake ones.
        //

        UINT uiTmp = ( NOHINT_WAIT_TIME / _uiSleepTime ) + 1;

        if( _uiMaxTries < uiTmp )
        {
            _uiMaxTries = uiTmp;
        }
    }
    else
    {
        //
        //  We have checkpoints & wait hints.  Use 'em.
        //

        if( ( _uiMaxTries * _uiSleepTime ) < lmsvcOtherStat.ulWaitTime )
        {
            //
            //  Time to recalculate the max tries counter.
            //

            _uiMaxTries = (UINT)( lmsvcOtherStat.ulWaitTime /
                                      _uiSleepTime ) + 1;

            _uiMaxTries *= 4;   // Be generous, some machines are slow...

            _uiCurrentTry = 0;
        }

        if( _ulOldCheckPoint != lmsvcOtherStat.ulCheckPointNum )
        {
            //
            //  Check point updated, reset counter.
            //

            _uiCurrentTry    = 0;
            _ulOldCheckPoint = lmsvcOtherStat.ulCheckPointNum;
        }
    }

    if( ++_uiCurrentTry > _uiMaxTries )
    {
        //
        //  Service timed out.
        //

        *pfDone = TRUE;
        return NERR_ServiceCtlTimeout;
    }

    //
    //  If we made it this far, then the operation is
    //  proceeding as expected.  Return success so that
    //  the client will sleep and try again later.
    //

    return NERR_Success;

}   // LM_SERVICE :: Poll


/*******************************************************************

    NAME:       LM_SERVICE :: QueryExitCode

    SYNOPSIS:   Returns the exit code for this service.  If this is
                a well known service and the exit code is
                ERROR_SERVICE_SPECIFIC_ERROR, then return the service
                specific error instead.

    RETURNS:    APIERR                  - The exit code.

    HISTORY:
        KeithMo     19-Nov-1991     Created.

********************************************************************/
APIERR LM_SERVICE :: QueryExitCode( VOID ) const
{
    APIERR err = _errExit;

    if( _fIsWellKnownService && ( err == ERROR_SERVICE_SPECIFIC_ERROR ) )
    {
        err = _errSpecific;
    }

    return err;

}   // LM_SERVICE :: QueryExitCode


/*******************************************************************

    NAME:       LM_SERVICE :: W_IsWellKnownService

    SYNOPSIS:   Determine if this is a "well known" service that
                returns NERR_* codes as service specific errors.

    RETURNS:    BOOL                    - TRUE if this is a well-known
                                          service, FALSE otherwise.

    HISTORY:
        KeithMo     18-Nov-1992     Created.

********************************************************************/
BOOL LM_SERVICE :: W_IsWellKnownService( VOID ) const
{
    const TCHAR * apszServices[] = { (TCHAR *)SERVICE_WORKSTATION,
                                     (TCHAR *)SERVICE_SERVER,
                                     (TCHAR *)SERVICE_BROWSER,
                                     (TCHAR *)SERVICE_MESSENGER,
                                     (TCHAR *)SERVICE_NETRUN,
                                     (TCHAR *)SERVICE_ALERTER,
                                     (TCHAR *)SERVICE_NETLOGON,
                                     (TCHAR *)SERVICE_REPL,
                                     (TCHAR *)SERVICE_UPS,
                                     (TCHAR *)SERVICE_TCPIP,
                                     (TCHAR *)SERVICE_NBT,
                                     (TCHAR *)SERVICE_TELNET,

//                                   (TCHAR *)SERVICE_SPOOLER,
//                                   (TCHAR *)SERVICE_NETPOPUP,
//                                   (TCHAR *)SERVICE_SQLSERVER,
//                                   (TCHAR *)SERVICE_RIPL,
//                                   (TCHAR *)SERVICE_TIMESOURCE,
//                                   (TCHAR *)SERVICE_AFP,
//                                   (TCHAR *)SERVICE_XACTSRV,
//                                   (TCHAR *)SERVICE_SCHEDULE,

                                     NULL
                                   };

    BOOL fResult = FALSE;

    const TCHAR * pszKeyName = QueryName();

    for( const TCHAR ** ppsz = apszServices ; *ppsz ; ppsz++ )
    {
        if( ::stricmpf( pszKeyName, *ppsz ) == 0 )
        {
            fResult = TRUE;
            break;
        }
    }

    return fResult;

}   // LM_SERVICE :: W_IsWellKnownService

/*******************************************************************

    NAME:       :: MakeNullNull

    SYNOPSIS:   Creates a NULL-NULL string from a normal PSZ.
                Space & tab are the accepted separators, quotes
                may be used to enclose a separator, and \ may be
                used to escape the quote.

                hello "bar \"&\" foo" world

                will generate:
                    hello\0bar "&" foo\0world\0\0

                the new string is alloced by this functions and should
                be deleted by caller with 'delete'.


    ENTRY:      pszOld -  input string to be parsed
                ppszNew - used to return new string that is allocated

    RETURNS:    APIERR                  - The exit code.

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
DWORD MakeNullNull(const TCHAR *pszOld, TCHAR **ppszNew)
{
    BOOL fInQuote = FALSE ;
    TCHAR *pszNew, *pszNewTmp, *pszOldTmp ;

    //
    // check against null return buffer
    //
    if (ppszNew == NULL)
        return ERROR_INVALID_PARAMETER ;

    //
    // the trivial case
    //
    if (pszOld == NULL || *pszOld == 0)
    {
        *ppszNew = NULL ;
        return NERR_Success ;
    }

    //
    // allocate memory. the new string is never bigger than the old by
    // more than 1 char (ie. the last null).
    //
    pszNew = (TCHAR *) new CHAR[(strlenf(pszOld)+2) * sizeof(TCHAR)] ;
    if (pszNew == NULL)
        return ERROR_NOT_ENOUGH_MEMORY ;
    *ppszNew = pszNew ;

    //
    // setup pointers, skip initial white space
    //
    pszOldTmp = (TCHAR *) pszOld ;
    pszNewTmp = pszNew ;
    SkipWhiteSpace(&pszOldTmp) ;

    while (*pszOldTmp)
    {
        if (IsWhiteSpace(*pszOldTmp) && !fInQuote)
        {
            //
            // found end of one token, null terminate it
            //
            *pszNewTmp++ = 0 ;
            SkipWhiteSpace(&pszOldTmp) ;

            //
            // if this was last, back step one since we
            // will add 'null null' as result of exiting loop.
            // note: backing up from \0 has no DBCS problems.
            //
            if (! *pszOldTmp)
                pszNewTmp-- ;
        }
        else if (*pszOldTmp == '"')
        {
            //
            // found a quote. just eat it.
            //
            fInQuote = !fInQuote ;
            ADVANCE_CHAR(pszOldTmp) ;
        }
        else if (*pszOldTmp == '\\')
        {
            //
            // found a back slash. skip it & take whatever is next
            // this advance is always safe, since it is not a leadbyte.
            //
            pszOldTmp++ ;
            if (*pszOldTmp)
            {
                COPY_CHAR(pszNewTmp, pszOldTmp) ;
                ADVANCE_CHAR(pszNewTmp) ;
                ADVANCE_CHAR(pszOldTmp) ;
            }
        }
        else
        {
            COPY_CHAR(pszNewTmp, pszOldTmp) ;
            ADVANCE_CHAR(pszOldTmp) ;
            ADVANCE_CHAR(pszNewTmp) ;
        }
    }

    //
    // do the NULL NULL termination
    //
    *pszNewTmp++ = 0 ;
    *pszNewTmp++ = 0 ;
    return NERR_Success ;
}


/*******************************************************************

    NAME:       :: SkipWhiteSpace

    SYNOPSIS:   takes a pointer to a PSZ and advances
                the pointer past any white spaces

    ENTRY:

    RETURNS:    no return

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
VOID  SkipWhiteSpace(TCHAR **ppsz)
{
    TCHAR *psz = *ppsz;

    if (!psz)
        return ;

    while (IsWhiteSpace(*psz))
        ADVANCE_CHAR(psz) ;

    *ppsz = psz ;
}

/*******************************************************************

    NAME:       :: IsWhiteSpace

    SYNOPSIS:   return TRUE if space or tab, FALSE otherwise

    ENTRY:

    RETURNS:    TRUE if space or tab, FALSE otherwise

    HISTORY:
        ChuckC     18-Mar-1993     Created.

********************************************************************/
BOOL  IsWhiteSpace(TCHAR c)
{
    return ( c == ' ' || c == '\t' ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\netname.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
 *  netname.cxx
 *      This file contain the NET_NAME class for manipulating path names.
 *
 *
 *  History:
 *      Yi-HsinS        12/8/91         Created, separated from sharebas.cxx
 *                                      and combine the 3 classes -
 *                                      FULL_SHARE_NAME, UNC_NAME and
 *                                      RELATIVE_PATH_NAME  into a NET_NAME
 *                                      class.
 *
 *      Yi-HsinS        12/15/91        Clean up for general use, added
 *                                      QueryLocalDrive
 *
 *      Yi-HsinS        12/31/91        Move string and character constants
 *                                      from netname.hxx to here plus
 *                                      Unicode work
 */

#include "pchlmobj.hxx"  // Precompiled header



#define PATH_SEPARATOR          TCH('\\')
#define STRING_TERMINATOR       TCH('\0')
#define COLON                   TCH(':')

#define SERVER_INIT_STRING      SZ("\\\\")

/*******************************************************************

    NAME:       NET_NAME::NET_NAME

    SYNOPSIS:   Manipulate info. of the form \\Server\Share\..\..
                or x:\..\..\..  where x: may be local or redirected

    ENTRY:      pszNetName - full name of the path

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        11/15/91                Created

********************************************************************/

NET_NAME::NET_NAME( const TCHAR *pszNetName, NETNAME_TYPE netNameType )
    : _nlsComputer(),
      _nlsShare(),
      _nlsRelativePath(),
      _nlsDrive(),
      _nlsLocalPath(),
      _fLocal( BOOL_UNINITIALIZED ),
      _fSharable( BOOL_UNINITIALIZED ),
      _netNameType( netNameType )
{

    if ( QueryError() != NERR_Success )
        return;

    UIASSERT( pszNetName != NULL );

    APIERR err = NERR_Success;
    NLS_STR nlsNetName = pszNetName;

    if ( (err = nlsNetName.QueryError() ) != NERR_Success )
    {
        ReportError( err );
        return;
    }

    ULONG ulType;
    if ( (err = I_MNetPathType( NULL, pszNetName, &ulType, 0)) == NERR_Success)
    {

        switch ( ulType )
        {
            case ITYPE_UNC:
            {
                if ( netNameType == TYPE_UNKNOWN  || netNameType == TYPE_PATH_UNC )
                    err = SetUNCPath( nlsNetName );
                else
                    err = ERROR_INVALID_NAME;
                break;
            }

            case ITYPE_DEVICE_DISK:
                // To be consistent with what netcmd does
                nlsNetName.AppendChar( PATH_SEPARATOR );
                // Falls through!

            case ITYPE_PATH_ABSD:
            {
                if ( netNameType == TYPE_UNKNOWN  || netNameType == TYPE_PATH_ABS )
                    err = SetABSPath( nlsNetName );
                else
                    err = ERROR_INVALID_NAME;
                break;
            }

            default:
            {
                err = ERROR_INVALID_NAME;
                break;
            }

        }
    }

    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}

/*******************************************************************

    NAME:       NET_NAME::~NET_NAME

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        12/15/91                Created

********************************************************************/
NET_NAME::~NET_NAME()
{
}

/*******************************************************************

    NAME:       NET_NAME::SetUNCPath

    SYNOPSIS:   The name passed in is a UNC path, so set members accordingly.
                \\server\share\relativepath

    ENTRY:      pszNetName - the UNC path name

    EXIT:

    RETURNS:

    NOTES:      _fLocal, and _nlsLocalPath are not set initially. They
                will be set only when queried because getting these
                information will involved some net API calls.

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/

APIERR NET_NAME::SetUNCPath( const TCHAR *pszNetName )
{
    APIERR err = NERR_Success;


    /*
     * Get server name
     */

    _nlsComputer = pszNetName;
    ISTR istrSvrStart( _nlsComputer), istrSvrEnd( _nlsComputer);

    istrSvrStart += 2;  // to skip past "\\"
    _nlsComputer.strchr( &istrSvrEnd, PATH_SEPARATOR, istrSvrStart);

    _nlsComputer.DelSubStr( istrSvrEnd );

    /*
     * Get share name
     */

    _nlsShare = pszNetName;

    ISTR istrShare( _nlsShare ), istrShStart( _nlsShare ), istrShEnd( _nlsShare );
    istrShStart += 2;  // skip past "\\"
    _nlsShare.strchr( &istrShEnd, PATH_SEPARATOR, istrShStart);

    // delete "\\server\"
    _nlsShare.DelSubStr( istrShare, ++istrShEnd );

    ISTR istrShStart2( _nlsShare ), istrShEnd2( _nlsShare );

    if ( _nlsShare.strchr( &istrShEnd2, PATH_SEPARATOR, istrShStart2) )
    {
        _nlsRelativePath = _nlsShare;
        _nlsShare.DelSubStr( istrShEnd2 );

       /*
        * Get relative path only if another PATH_SEPARATOR exists
        */

        // _nlsRelativePath initially equals "share\restpath"

        ISTR istrRelStart( _nlsRelativePath );
        ISTR istrRelEnd( _nlsRelativePath );

        _nlsRelativePath.strchr( &istrRelEnd, PATH_SEPARATOR, istrRelStart);
        _nlsRelativePath.DelSubStr( istrRelStart, ++istrRelEnd );
    }

    if (  (( err = _nlsComputer.QueryError() ) != NERR_Success )
       || (( err = _nlsShare.QueryError() ) != NERR_Success )
       || (( err = _nlsRelativePath.QueryError()) != NERR_Success )
       )
    {
        return err;
    }

    _fSharable = BOOL_TRUE;
    _netNameType = TYPE_PATH_UNC;
    return NERR_Success;
}

/*******************************************************************

    NAME:       NET_NAME::SetABSPath

    SYNOPSIS:   The name is an absolute path, so set members accordingly
                x:\relativepath

    ENTRY:      pszNetName - the absolute path name

    EXIT:

    RETURNS:

    NOTES:      Only _nlsDrive, _nlsRelativePath
                and _netNameType are set. All other members are
                set only when needed.

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/

APIERR NET_NAME::SetABSPath( const TCHAR *pszNetName )
{

    TCHAR szDev[3];
    ::strncpyf( szDev, pszNetName, 2);
    szDev[2] = STRING_TERMINATOR;

    _netNameType = TYPE_PATH_ABS;
    _nlsDrive = szDev;

    if ( _nlsDrive.QueryError() != NERR_Success )
        return _nlsDrive.QueryError();

    // Get the relative path name minus device "x:\"
    _nlsRelativePath = pszNetName;
    ISTR istrStart( _nlsRelativePath ), istrEnd( _nlsRelativePath );
    istrEnd += 3;    // Skip past "x:\"
    _nlsRelativePath.DelSubStr( istrStart, istrEnd );

    return _nlsRelativePath.QueryError();
}


/*******************************************************************

    NAME:       NET_NAME::GetDeviceInfo

    SYNOPSIS:   Set the members if the class is constructed with absolute path
                x:\relativepath

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:
        If device x: is redirected,
           then find \\server\share associated with it and
                set _nlsComputer, _nlsShare and  _fSharable.
        else if device x: is local,
           then set _fLocal and _nlsLocalPath.


    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::GetDeviceInfo( void )
{

    APIERR err = NERR_Success;

    DEVICE dev( _nlsDrive );
    if ( ( err = dev.GetInfo() ) != NERR_Success )
    {
        return err;
    }

    switch ( dev.QueryState() )
    {
        case LMO_DEV_LOCAL:
            {
                // Set the flag to TRUE indicating it's a local device
                _fLocal = BOOL_TRUE;
                _nlsLocalPath = _nlsDrive;
                _nlsLocalPath.AppendChar( PATH_SEPARATOR );
                _nlsLocalPath += _nlsRelativePath;

                err = _nlsLocalPath.QueryError();
            }
            break;

        case LMO_DEV_REMOTE:
            {
                _fSharable = BOOL_TRUE;
                if ( dev.QueryStatus() == USE_SESSLOST )
                {
                    return NERR_UseNotFound;
                }

                NLS_STR nlsRemoteName( dev.QueryRemoteName() );

                if ( (err = nlsRemoteName.QueryError()) == NERR_Success )
                {
                   err = SetUNCPath( nlsRemoteName );
                   // Set the type back 'cause SetUNCPath will
                   // change the type to TYPE_PATH_UNC
                   _netNameType = TYPE_PATH_ABS;
                }

            }
            break;

       default:
            err = (APIERR) NERR_InvalidDevice;
            break;
    }

    return err;

}



/*******************************************************************

    NAME:       NET_NAME::QueryComputerName

    SYNOPSIS:   Get the computer name

    ENTRY:

    EXIT:       pnlsComp - the computer name

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryComputerName( NLS_STR *pnlsComp )
{
    APIERR err = QueryError();

    if ( err != NERR_Success )
        return err;

    // If _nlsComputer is not initialized ( empty string),
    // then it is constructed with x:\..\..
    if ( _nlsComputer.QueryTextLength() == 0)
    {
        // Get information about x:
        err = GetDeviceInfo();

        // If _nlsComputer is still empty string, then  the class must be
        // constructed with x:\..\.. where x: is local device
        if (  ( err == NERR_Success)
           && ( _nlsComputer.QueryTextLength() == 0 )
           )
        {
            // Get local computer name!
            LOCATION loc;
            if (  ((err = loc.QueryError()) == NERR_Success )
               && ((err = loc.QueryDisplayName( &_nlsComputer)) == NERR_Success)
               )
            {
                // nothing to do
            }
        }
    }

    if ( err == NERR_Success )
    {
        *pnlsComp = _nlsComputer;
        err = pnlsComp->QueryError();
    }

#ifdef netname_debug
UIDEBUG(SZ("Computer:#"));
UIDEBUG(*pnlsComp);
UIDEBUG(SZ("#\n\r"));
#endif

    return err;
}

/*******************************************************************

    NAME:       NET_NAME::QueryShare

    SYNOPSIS:   Get the share name

    ENTRY:

    EXIT:       pnlsShare - the share name

    RETURNS:    Returns NERR_RemoteOnly if constructed with
                x:\..\.. where x: is a local device.

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryShare( NLS_STR *pnlsShare )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return err;

    // If _nlsComputer is not initialized, then it is constructed with x:\..\..
    if ( _nlsComputer.QueryTextLength() == 0)
        err = GetDeviceInfo();

    // After GetDeviceInfo() is called, if _nlsShare is still empty,
    // then it is constructed with x:\..\.. where x: is local. Hence,
    // it's an error to query the share name.
    if ( (err == NERR_Success) && ( _nlsShare.QueryTextLength() == 0 ))
    {
        UIASSERT( FALSE );
        return NERR_RemoteOnly;
    }

    *pnlsShare = _nlsShare;

#ifdef netname_debug
UIDEBUG(SZ("Share:#"));
UIDEBUG( *pnlsShare);
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsShare->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryDrive

    SYNOPSIS:   Get the drive letter

    ENTRY:

    EXIT:       pnlsDrive - the drive letter
                    will point to empty string if constructed with UNC path

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryDrive( NLS_STR *pnlsDrive )
{
    if ( QueryError() != NERR_Success )
        return QueryError();

    *pnlsDrive = _nlsDrive;

#ifdef netname_debug
UIDEBUG(SZ("Drive:#"));
UIDEBUG( *pnlsDrive );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsDrive->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryLocalDrive

    SYNOPSIS:   Get the drive letter of the local path on the computer

    ENTRY:

    EXIT:       pnlsLocalDrive - the drive letter

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryLocalDrive( NLS_STR *pnlsLocalDrive )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return err;

    if ( (err = QueryLocalPath( pnlsLocalDrive )) != NERR_Success )
        return err;

    ISTR istr( *pnlsLocalDrive );
    istr += 2;   // jump past "x:"

    pnlsLocalDrive->DelSubStr( istr );

#ifdef netname_debug
UIDEBUG(SZ("Local Drive:#"));
UIDEBUG( *pnlsLocalDrive );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsLocalDrive->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryRelativePath

    SYNOPSIS:   Get the Relative Path

    ENTRY:

    EXIT:       pnlsRelativePath - the relative path

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryRelativePath( NLS_STR *pnlsRelativePath )
{
    if ( QueryError() != NERR_Success )
        return QueryError();

    *pnlsRelativePath = _nlsRelativePath;

#ifdef netname_debug
UIDEBUG(SZ("Relative Path:#"));
UIDEBUG( *pnlsRelativePath );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsRelativePath->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryLastComponent

    SYNOPSIS:   Get the last directory in the path
                e.g. if path is x:\....\foo or \\server\share\..\foo
                     then return foo

    ENTRY:

    EXIT:       pnlsLastComp  - the last directory

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/

APIERR NET_NAME::QueryLastComponent( NLS_STR *pnlsLastComp )
{

    if ( QueryError() != NERR_Success )
        return QueryError();

    *pnlsLastComp = _nlsRelativePath;
    ISTR istrStart( *pnlsLastComp ), istrEnd( *pnlsLastComp );

    if ( pnlsLastComp->strrchr( &istrEnd, PATH_SEPARATOR ))
        pnlsLastComp->DelSubStr( istrStart, ++istrEnd);

#ifdef netname_debug
UIDEBUG(SZ("Last Comp:#"));
UIDEBUG(*pnlsLastComp );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsLastComp->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryServerShare

    SYNOPSIS:   Get the \\server\share

    ENTRY:

    EXIT:       pnlsServerShare - \\server\share

    RETURNS:    Returns NERR_RemoteOnly if constructed with
                x:\..\.. where x: is a local device.

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryServerShare( NLS_STR *pnlsServerShare )
{

    APIERR err = QueryError();
    NLS_STR nlsShare;

    if (  (err != NERR_Success )
       || ((err = QueryComputerName( pnlsServerShare )) != NERR_Success )
       || ((err = QueryShare( &nlsShare ) ) != NERR_Success )
       )
    {
        return err;
    }

    pnlsServerShare->AppendChar( PATH_SEPARATOR );
    *pnlsServerShare += nlsShare;

#ifdef netname_debug
UIDEBUG(SZ("ServerShare:#"));
UIDEBUG(*pnlsServerShare);
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsServerShare->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryUNCPath

    SYNOPSIS:   Get the \\server\share\relativepath

    ENTRY:

    EXIT:       pnlsUNCPath  - the UNC path

    RETURNS:    Returns NERR_RemoteOnly if constructed with
                x:\..\.. where x: is a local device.
    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/
APIERR NET_NAME::QueryUNCPath( NLS_STR *pnlsUNCPath )
{

    APIERR err = QueryError();

    if (   (err != NERR_Success )
       || ((err = QueryServerShare( pnlsUNCPath ))  != NERR_Success )
       )
    {
        return err;
    }

    if ( _nlsRelativePath.QueryTextLength() != 0 )
    {
        pnlsUNCPath->AppendChar( PATH_SEPARATOR );
        *pnlsUNCPath += _nlsRelativePath;
    }

#ifdef netname_debug
UIDEBUG(SZ("UNCPath:#"));
UIDEBUG(*pnlsUNCPath);
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsUNCPath->QueryError();
}

/*******************************************************************

    NAME:       NET_NAME::QueryLocalPath

    SYNOPSIS:   Get the local path on the computer
                x:\..\..    where x: is a local drive on the computer

    ENTRY:

    EXIT:       pnlsLocalPath - pointer to the local path on the computer

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        8/15/91         Created

********************************************************************/

APIERR NET_NAME::QueryLocalPath( NLS_STR *pnlsLocalPath )
{
    APIERR err = QueryError();
    if ( err != NERR_Success )
        return err;

    // Check if _nlsLocalPath is initialized already
    if ( _nlsLocalPath.QueryTextLength() == 0 )
    {
        // If not initialized, initialize it!
        NLS_STR nlsComp; // Initialize to empty string for local computer
        NLS_STR nlsShare;

        if ( (err = nlsComp.QueryError()) == NERR_Success )
        {
            if ( !IsLocal( &err ) && (err == NERR_Success))
                err = QueryComputerName( &nlsComp );
        }

        if (  (err != NERR_Success )
           || ((err = nlsShare.QueryError()) != NERR_Success )
           || ((err = QueryShare( &nlsShare )) != NERR_Success )
           )
        {
            return err;
        }

        SHARE_2 sh2( nlsShare, nlsComp );

        if (  ((err = sh2.QueryError() ) != NERR_Success )
           || ((err = sh2.GetInfo()) != NERR_Success )
           )
        {
            return err;
        }

        _nlsLocalPath = sh2.QueryPath() ;

        // Add an extra '\' after if the path is not of the form "x:\"
        // i.e. does not end with "\"
        ISTR istrLocalPath( _nlsLocalPath );
        if (  ( _nlsLocalPath.strrchr( &istrLocalPath, PATH_SEPARATOR) )
           && ( !istrLocalPath.IsLastPos() )
           && ( _nlsRelativePath.QueryTextLength() != 0 )
           )
        {
            _nlsLocalPath.AppendChar( PATH_SEPARATOR );
        }

        _nlsLocalPath.strcat( _nlsRelativePath );

        if ( (err = _nlsLocalPath.QueryError()) != NERR_Success )
            return err;

    }

    *pnlsLocalPath = _nlsLocalPath;

#ifdef netname_debug
UIDEBUG(SZ("Local Path:#"));
UIDEBUG( *pnlsLocalPath );
UIDEBUG(SZ("#\n\r"));
#endif

    return pnlsLocalPath->QueryError();

}

/*******************************************************************

    NAME:       NET_NAME::IsLocal

    SYNOPSIS:   Check if the path is on a local machine,

    ENTRY:

    EXIT:       perr - pointer to the error

    RETURNS:    Returns TRUE if the  path is on a local machine,
                        FALSE otherwise.

    NOTES:

    HISTORY:
        Yi-HsinS        12/15/91                Created

********************************************************************/

BOOL NET_NAME::IsLocal( APIERR *perr )
{

    APIERR err = QueryError();

    if (  ( err == NERR_Success )
       && ( _fLocal == BOOL_UNINITIALIZED )
       )
    {
        /*
         * _fLocal is not initialized
         */

        // If the class is constructed with an absolute path
        // and neither _nlsComputer nor _nlsLocalPath is initialized,
        // call GetDeviceInfo.
        if (  ( _netNameType == TYPE_PATH_ABS )
           && ( _nlsComputer.QueryTextLength() == 0 )
           && ( _nlsLocalPath.QueryTextLength() == 0)
           )
        {
            err = GetDeviceInfo();
        }

        // If the class is constructed with an UNC name or if
        // the class is constructed with x:\..\.. where x: is redirected
        if (( err == NERR_Success ) && ( _fLocal == BOOL_UNINITIALIZED ))
        {
            // Get Local Computer Name to set the _fLocal flag
            LOCATION loc;
            NLS_STR  nlsLocalComp;
            if (  ((err = loc.QueryError()) == NERR_Success )
               && ((err = nlsLocalComp.QueryError()) == NERR_Success )
               && ((err = loc.QueryDisplayName( &nlsLocalComp)) == NERR_Success)
               )
            {
                if( !::I_MNetComputerNameCompare( _nlsComputer, nlsLocalComp ) )
                    _fLocal = BOOL_TRUE;
                else
                    _fLocal = BOOL_FALSE;
            }
        }
    }

    if ( perr != NULL )
        *perr = err;

#ifdef netname_debug
UIDEBUG(SZ("Local:#"));
UIDEBUGNUM( _fLocal );
UIDEBUG(SZ("#\n\r"));
#endif

    return ( (_fLocal == BOOL_TRUE) ? TRUE : FALSE);

}

/*******************************************************************

    NAME:       NET_NAME::IsSharable

    SYNOPSIS:   Check if the path is on a computer that can share directories

    ENTRY:

    EXIT:       perr - pointer to the error

    RETURNS:    Returns TRUE if the computer can share directories
                        FALSE otherwise.

    NOTES:

    HISTORY:
        Yi-HsinS        12/15/91                Created

********************************************************************/

BOOL NET_NAME::IsSharable( APIERR *perr )
{
    APIERR err = QueryError();
    if (  ( err == NERR_Success )
       && ( _fSharable == BOOL_UNINITIALIZED )
       )
    {

        // If the class is constructed with an absolute path
        // and neither _nlsComputer nor _nlsLocalPath is initialized,
        // call GetDeviceInfo.
        if (  ( _netNameType == TYPE_PATH_ABS )
           && ( _nlsComputer.QueryTextLength() == 0 )
           && ( _nlsLocalPath.QueryTextLength() == 0 )
           )
        {
                err = GetDeviceInfo();
        }

        if (( err == NERR_Success ) && (_fSharable == BOOL_UNINITIALIZED))
        {
            LOCATION loc;   // local machine

            //  Check whether local machine is a NT server
            BOOL fNT;
            if (  ((err = loc.QueryError()) == NERR_Success )
               && ((err = loc.CheckIfNT( &fNT )) == NERR_Success )
               )
            {

                if ( !fNT )
                {
                    // NOTE: What happens if we admin NT from Winball machine?
                    _fSharable = BOOL_FALSE;
                }
                else
                {
                    // The local computer is NT
                    // Check whether the server service has started.

                    LM_SERVICE lmsvc( NULL, (const TCHAR *)SERVICE_SERVER );
                    if ( (err = lmsvc.QueryError()) == NERR_Success )
                    {

                        // If not started, return err
                        if ( !lmsvc.IsStarted() )
                            _fSharable = BOOL_FALSE;
                        else
                            _fSharable = BOOL_TRUE;
                    }
                }
            }
        }
    }

    if ( perr != NULL )
        *perr = err;

#ifdef netname_debug
UIDEBUG(SZ("Sharable:#"));
UIDEBUGNUM( _fSharable );
UIDEBUG(SZ("#\n\r"));
#endif

    return ( (_fSharable == BOOL_TRUE) ? TRUE : FALSE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\ntacutil.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    NTAcUtil.cxx

    This file contains the implemenation for the NT Account utilities



    FILE HISTORY:
        JohnL   13-Mar-1992     Created
        thomaspa 14-May-1992    Added GetQualifiedAccountNames
        KeithMo  20-Jul-1992    Added ValidateQualifiedAccountName.
        JonN    16-Nov-1992     Fix DC-focus problem, get group comments

*/

#include "pchlmobj.hxx"  // Precompiled header



// used in GetQualifiedAccountNames
DECLARE_SLIST_OF( API_SESSION );
DEFINE_SLIST_OF( API_SESSION );

DECLARE_SLIST_OF( ADMIN_AUTHORITY );
DEFINE_SLIST_OF( ADMIN_AUTHORITY );


//
// locally-defined worker routines for GetQualifiedAccountNames
//

APIERR I_FetchDCList(       const LSA_TRANSLATED_NAME_MEM & lsatnm,
                            const LSA_REF_DOMAIN_MEM &  lsardm,
                            PSID                        psidLSAAcctDom,
                            PSID                        psidBuiltIn,
                            NLS_STR **                  apnlsPDCs,
                            STRLIST *                   pstrlistPDCs,
                            BOOL *                      afDCFound,
                            APIERR *                    perrNonFatal = FALSE,
                            const TCHAR *               pszServer = NULL,
                            BOOL                        fFetchUserFlags = FALSE,
                            BOOL                        fFetchFullNames = FALSE,
                            BOOL                        fFetchComments = FALSE );

APIERR I_FetchGroupFields(  NLS_STR *       pnlsComment,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal = NULL );

APIERR I_FetchAliasFields(  NLS_STR *       pnlsComment,
                            ADMIN_AUTHORITY ** ppadminauth,
                            SLIST_OF(ADMIN_AUTHORITY) * pslistADMIN_AUTH,
                            ULONG           ulRID,
                            BOOL            fDomainIsBuiltIn,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal = NULL );

APIERR I_FetchUserFields(   NLS_STR *       pnlsComment,
                            NLS_STR *       pnlsFullName,
                            ULONG *         pulUserFlags,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal = NULL );

APIERR I_AppendToSTRLIST(   STRLIST *       pstrlist,
                            NLS_STR &       nlsToCopy );


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName

    SYNOPSIS:   Builds a fully qualified Account name of the form
                "NtProject\JohnL".

    ENTRY:
        pnlsQualifiedAccountName - Pointer to NLS_STR to receive the qualified
             Account name.
        nlsAccountName - contains the Account name (such as "JohnL")
        nlsDomainName - Contains the domain the Account lives in (such as
             "NtProject")
        pnlsCurrentDomain - Optional name of the domain the current logged on
             Account lives in.
             If this domain name matches nlsDomainName, then
             nlsDomainName is omitted as the prefix for the qualified name.
             If this parameter is NULL, then nlsDomainName is always prefixed
             to the qualified name.

    EXIT:       *pnlsQualifiedAccountName will contain either "JohnL" or
                "NtProject\JohnL" depending on where "JohnL" lives.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   13-Mar-1992     Created

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                             NLS_STR *       pnlsQualifiedAccountName,
                             const NLS_STR & nlsAccountName,
                             const NLS_STR & nlsDomainName,
                             const NLS_STR * pnlsFullName,
                             const NLS_STR * pnlsCurrentDomain,
                             SID_NAME_USE    sidType )
{
    UIASSERT( pnlsQualifiedAccountName != NULL ) ;

    *pnlsQualifiedAccountName = SZ("") ;

    if (  (pnlsCurrentDomain == NULL) ||
          ::I_MNetComputerNameCompare( pnlsCurrentDomain->QueryPch(),
                                       nlsDomainName ) )
    {
        /* Only put on the domain name if it is not the empty string
         */
        if ( nlsDomainName.strlen() > 0)
        {
            *pnlsQualifiedAccountName += nlsDomainName ;
            pnlsQualifiedAccountName->AppendChar( QUALIFIED_ACCOUNT_SEPARATOR ) ;
        }
    }

    return W_BuildQualifiedAccountName( pnlsQualifiedAccountName,
                                        nlsAccountName,
                                        pnlsFullName,
                                        sidType );

}




/*******************************************************************

    NAME:       BuildQualifiedAccountName

    SYNOPSIS:   Same as above only SIDs are used for determining
                whether or not to include the domain name

        pnlsQualifiedAccountName - Pointer to NLS_STR to receive the qualified
             Account name.
        nlsAccountName - contains the Account name (such as "JohnL")
        nlsDomainName - Contains the domain the Account lives in (such as
             "NtProject")
        psidDomain - PSID for the domain the Account lives in
        psidCurrentDomain - Optional PSID of the domain the current logged on
             Account lives in.
             If this domain PSID matches psidDomain, then
             nlsDomainName is omitted as the prefix for the qualified name.
             If this parameter is NULL, then nlsDomainName is always prefixed
             to the qualified name.

    EXIT:       Same as above.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   13-Mar-1992     Created

********************************************************************/
APIERR NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                             NLS_STR *       pnlsQualifiedAccountName,
                             const NLS_STR & nlsAccountName,
                             PSID psidDomain,
                             const NLS_STR & nlsDomainName,
                             const NLS_STR * pnlsFullName,
                             PSID psidCurrentDomain,
                             SID_NAME_USE    sidType )
{
    UIASSERT( pnlsQualifiedAccountName != NULL ) ;

    *pnlsQualifiedAccountName = SZ("") ;

    if (  (psidCurrentDomain == NULL) ||
          (psidDomain        == NULL) ||
        !(::EqualSid( psidDomain, psidCurrentDomain )) )
    {
#ifdef TRACE
        if ( psidDomain == NULL )
            TRACEEOL("NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName - " <<
                     "Warning - psidDomain is NULL!") ;
#endif //TRACE

        /* Only put on the domain name if it is not the empty string
         */
        if ( nlsDomainName.strlen() > 0)
        {
            *pnlsQualifiedAccountName += nlsDomainName ;
            pnlsQualifiedAccountName->AppendChar( QUALIFIED_ACCOUNT_SEPARATOR ) ;
        }
    }

    return W_BuildQualifiedAccountName( pnlsQualifiedAccountName,
                                        nlsAccountName,
                                        pnlsFullName,
                                        sidType );
}






/*******************************************************************

    NAME:       W_BuildQualifiedAccountName

    SYNOPSIS:   Worker function for BuildQualifiedAccountName

    ENTRY:

    EXIT:       Same as above.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Thomaspa        09-Jul-1992     Created

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::W_BuildQualifiedAccountName(
                             NLS_STR * pnlsQualifiedAccountName,
                             const NLS_STR & nlsAccountName,
                             const NLS_STR * pnlsFullName,
                             SID_NAME_USE    sidType )
{
    NLS_STR nls;
    APIERR err;
    switch ( sidType )
    {
    case SidTypeUnknown:
    case SidTypeInvalid:
        err = nls.Load( IDS_LMOBJ_SIDUNKNOWN, NLS_BASE_DLL_HMOD );
        if ( err == NERR_Success )
        {
            *pnlsQualifiedAccountName += nls;
        }
        else
        {
            DBGEOL( SZ("Can't load IDS_LMOBJ_SIDUNKNOWN.") );
            // If we can't load the string, just display what is passed in
            *pnlsQualifiedAccountName += nlsAccountName ;
        }
        break;
    case SidTypeDeletedAccount:
        err = nls.Load( IDS_LMOBJ_SIDDELETED, NLS_BASE_DLL_HMOD );
        if ( err == NERR_Success )
        {
            *pnlsQualifiedAccountName += nls;
        }
        else
        {
            DBGEOL( SZ("Can't load IDS_LMOBJ_SIDDELETED.") );
            // If we can't load the string, just display what is passed in
            *pnlsQualifiedAccountName += nlsAccountName ;
        }
        break;
    default:
        *pnlsQualifiedAccountName += nlsAccountName ;
        break;
    }

    /* Append the fullname if it was specified
     */
    if ( (pnlsFullName != NULL) &&
         (pnlsFullName->strlen() > 0) )
    {
        // CODEWORK: the text constants should come from a common place.
        *pnlsQualifiedAccountName += SZ(" (") ;
        *pnlsQualifiedAccountName += *pnlsFullName ;
        *pnlsQualifiedAccountName += SZ(")") ;
    }

    return pnlsQualifiedAccountName->QueryError() ;
}

/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName

    SYNOPSIS:   Breaks a qualified account name into its components.

    ENTRY:      nlsQualifiedAccountName - An account name of the form
                    "JohnL" or "NtProject\JohnL (Ludeman, John)".  If the
                    domain name is requested but isn't contained in the
                    account name, then the empty string will be returned
                    in the domain name.
                pnlsAccountName - Pointer to NLS_STR that will receive the
                    account name (or NULL if you don't want the account name).
                pnlsDomainName - Same as pnlsAccountName only for the domain.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The domain name will be set to the empty string if one wasn't
                found (same for user name).

    HISTORY:
        Johnl   13-Mar-1992     Created
        KeithMo 20-Jul-1992     Added support for ".\user" syntax.

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                             const NLS_STR & nlsQualifiedAccountName,
                                   NLS_STR * pnlsAccountName,
                                   NLS_STR * pnlsDomainName )
{
    APIERR err = NERR_Success ;

    /* We write to the string so make a copy and use it.
     */
    NLS_STR nlsScratch( nlsQualifiedAccountName ) ;
    if ( err = nlsScratch.QueryError())
        return err ;

    ISTR istrSep( nlsScratch ) ;
    BOOL fContainsDomain = nlsScratch.strchr( &istrSep,
                                              QUALIFIED_ACCOUNT_SEPARATOR );
    if ( fContainsDomain )
    {
        if ( pnlsDomainName != NULL )
        {
            ISTR istrStart( nlsScratch ) ;
            NLS_STR *pnlsTemp = nlsScratch.QuerySubStr( istrStart,
                                                       istrSep );
            if ( pnlsTemp == NULL )
            {
                return ERROR_NOT_ENOUGH_MEMORY ;
            }

            if( ( pnlsTemp->QueryTextLength() == 1 ) &&
                ( nlsScratch.QueryChar( istrStart ) == TCH('.') ) )
            {
                *pnlsDomainName = SZ("");
            }
            else
            {
                *pnlsDomainName = *pnlsTemp ;
            }

            delete pnlsTemp ;

            err = pnlsDomainName->QueryError() ;
        }

        /* Move the ISTR to the first character of the Account Name in case
         * the user requested it also.
         */
        ++istrSep ;
    }
    else
    {
        /* No domain to be found
         */
        if ( pnlsDomainName != NULL )
        {
            *pnlsDomainName = SZ("") ;
            err = pnlsDomainName->QueryError() ;
        }

        /* The ISTR was set to the end of the string since we didn't find
         * a '\\' marking a domain name.  Get it ready for any User name
         * munging.
         */
        istrSep.Reset() ;
    }

    if ( !err && pnlsAccountName != NULL )
    {
        /* Truncate the string if it has a " (name, full)" on the end
         *
         * We specifically look for a space followed by a '(' followed by
         * a ')'
         */
        ISTR istrEnd( istrSep ) ;

        if ( nlsScratch.strchr( &istrEnd, TCH(' ')))
        {
            ISTR istrOpenParen( istrEnd ) ;
            ISTR istrCloseParen( istrEnd ) ;
            if ( nlsScratch.strchr( &istrOpenParen,
                                                 TCH('('),
                                                 istrEnd )       &&
                 nlsScratch.strchr( &istrCloseParen,
                                                 TCH(')'),
                                                 istrOpenParen)    )
            {
                nlsScratch.DelSubStr( istrEnd ) ;
            }
        }

        /* Since we modified the string, we have to find the account name/
         * domain name separator again
         */
        if ( nlsScratch.strchr( &istrSep, QUALIFIED_ACCOUNT_SEPARATOR))
        {
            /* Move beyond the '\\' if found
             */
            ++istrSep ;
        }
        else
        {
            istrSep.Reset() ;
        }

        *pnlsAccountName = nlsScratch.QueryPch( istrSep ) ;
        err = pnlsAccountName->QueryError() ;
    }

    return err ;
}

/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::ValidateQualifiedAccountName

    SYNOPSIS:   Validates the (optional) domain name and the user name
                of a qualified account.

    ENTRY:      nlsQualifiedAccountName - An account name of the form
                    "KeithMo" or "NtProject\KeithMo (Moore, Keith)".

                pfInvalidDomain - Optional parameter will receive TRUE
                    if the qualified account name contained an invalid
                    domain name, FALSE otherwise.

    RETURNS:    (APIERR)  NERR_Success if the domain & account names
                          are both valid.  ERROR_INVALID_PARAMETER if
                          either is malformed.  Other errors as appropriate
                          (most probably ERROR_NOT_ENOUGH_MEMORY).

    HISTORY:
        KeithMo 20-Jul-1992     Created.

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::ValidateQualifiedAccountName(
                             const NLS_STR & nlsQualifiedAccountName,
                             BOOL          * pfInvalidDomain )
{
    //
    //  These strings will receive the account name & domain name
    //  portions of the qualified account name.
    //

    NLS_STR nlsAccountName;
    NLS_STR nlsDomainName;
    BOOL    fInvalidDomain = FALSE;     // until proven otherwise

    APIERR err = nlsAccountName.QueryError();

    if( err == NERR_Success )
    {
        err = nlsDomainName.QueryError();
    }

    if( err == NERR_Success )
    {
        //
        //  Crack the qualified name into an account and a domain.
        //

        err = NT_ACCOUNTS_UTILITY::CrackQualifiedAccountName(
                                            nlsQualifiedAccountName,
                                            &nlsAccountName,
                                            &nlsDomainName );
    }

    if( err == NERR_Success )
    {
        //
        //  If the domain was specified, validate it.
        //

        if( nlsDomainName.QueryTextLength() > 0 )
        {
            if( I_MNetNameValidate( NULL,
                                    nlsDomainName,
                                    NAMETYPE_DOMAIN,
                                    0 ) != NERR_Success )
            {
                err = ERROR_INVALID_PARAMETER;
                fInvalidDomain = TRUE;
            }
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Validate the user name.
        //

        if( I_MNetNameValidate( NULL,
                                nlsAccountName,
                                NAMETYPE_USER,
                                0 ) != NERR_Success )
        {
            err = ERROR_INVALID_PARAMETER;
        }
    }

    if( pfInvalidDomain != NULL )
    {
        *pfInvalidDomain = fInvalidDomain;
    }

    return err;

}   // NT_ACCOUNTS_UTILITY :: ValidateQualifiedAccountName


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::QuerySystemSid

    SYNOPSIS:   Retrieves the requested SID

    ENTRY:      UI_SystemSid - Which SID to retrieve
                possidSystemSid - Pointer to OS_SID that will recieve the
                    system sid.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      pszServer is not currently used

    HISTORY:
        Johnl    13-Mar-1992    Created
        DavidHov 18-Aug-1992    Added UI_SID_Replicator

********************************************************************/

SID_IDENTIFIER_AUTHORITY IDAuthorityWorld   = SECURITY_WORLD_SID_AUTHORITY ;
SID_IDENTIFIER_AUTHORITY IDAuthorityLocal   = SECURITY_LOCAL_SID_AUTHORITY ;
SID_IDENTIFIER_AUTHORITY IDAuthorityNT      = SECURITY_NT_AUTHORITY ;
SID_IDENTIFIER_AUTHORITY IDAuthorityCreator = SECURITY_CREATOR_SID_AUTHORITY ;
SID_IDENTIFIER_AUTHORITY IDAuthorityNull    = SECURITY_NULL_SID_AUTHORITY ;


APIERR NT_ACCOUNTS_UTILITY::QuerySystemSid(
                              enum UI_SystemSid   SystemSid,
                                   OS_SID       * possidSystemSid,
                                   const TCHAR  * pszServer )
{
    UNREFERENCED( pszServer ) ;

    if ( possidSystemSid == NULL )
    {
        ASSERT( FALSE ) ;
        return ERROR_INVALID_PARAMETER ;
    }

    APIERR err = NERR_Success ;
    switch ( SystemSid )
    {
    case UI_SID_Null:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNull,
                              1,
                              SECURITY_NULL_RID ) ;
        break ;

    case UI_SID_Local:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityLocal,
                              1,
                              SECURITY_LOCAL_RID ) ;
        break ;




    case UI_SID_CreatorOwner:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityCreator,
                              1,
                              SECURITY_CREATOR_OWNER_RID ) ;
        break ;

    case UI_SID_CreatorGroup:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityCreator,
                              1,
                              SECURITY_CREATOR_GROUP_RID ) ;
        break ;

    case UI_SID_NTAuthority:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              0 ) ;

        break ;
    case UI_SID_Dialup:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_DIALUP_RID ) ;
        break ;

    case UI_SID_Network:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_NETWORK_RID ) ;
        break ;

    case UI_SID_Batch:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_BATCH_RID ) ;
        break ;

    case UI_SID_Interactive:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_INTERACTIVE_RID ) ;
        break ;

    case UI_SID_Service:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              1,
                              SECURITY_SERVICE_RID ) ;
        break ;

    case UI_SID_BuiltIn:
            err = BuildAndCopySysSid( possidSystemSid,
                                  &IDAuthorityNT,
                                  1,
                                  SECURITY_BUILTIN_DOMAIN_RID ) ;
        break ;

    case UI_SID_System:
            err = BuildAndCopySysSid( possidSystemSid,
                                  &IDAuthorityNT,
                                  1,
                                  SECURITY_LOCAL_SYSTEM_RID ) ;
        break ;

    case UI_SID_Restricted:
            err = BuildAndCopySysSid( possidSystemSid,
                                  &IDAuthorityNT,
                                  1,
                                  SECURITY_RESTRICTED_CODE_RID ) ;
        break ;

    case UI_SID_World:
        err = BuildAndCopySysSid( possidSystemSid,
                                  &IDAuthorityWorld,
                                  1,
                                  SECURITY_WORLD_RID ) ;
        break ;

    case UI_SID_Admins:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_ADMINS ) ;
        break ;

    case UI_SID_Users:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_USERS ) ;
        break ;

    case UI_SID_Guests:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_GUESTS ) ;
        break ;


    case UI_SID_PowerUsers:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_POWER_USERS ) ;
        break ;

    case UI_SID_AccountOperators:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_ACCOUNT_OPS ) ;
        break ;


    case UI_SID_SystemOperators:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_SYSTEM_OPS ) ;
        break ;

    case UI_SID_BackupOperators:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_BACKUP_OPS ) ;
        break ;

    case UI_SID_PrintOperators:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_PRINT_OPS ) ;
        break ;

    case UI_SID_Replicator:
        err = BuildAndCopySysSid( possidSystemSid,
                              &IDAuthorityNT,
                              2,
                              SECURITY_BUILTIN_DOMAIN_RID,
                              DOMAIN_ALIAS_RID_REPLICATOR ) ;
        break ;

    case UI_SID_CurrentProcessUser:
        do
        {
            BUFFER buffUser(   sizeof (SID_AND_ATTRIBUTES)
                              + sizeof (ULONG) * SID_MAX_SUB_AUTHORITIES ) ;
            ULONG  cbBuffRequired ;
            HANDLE hProcess = ::GetCurrentProcess() ;

            if ( (err = buffUser.QueryError() ) )
            {
                break ;
            }

            /* Get the current process's user's SID
             */
            HANDLE hProcessToken = NULL ;
            if (   !::OpenProcessToken( hProcess, TOKEN_QUERY, &hProcessToken )
                || !::GetTokenInformation( hProcessToken,
                                         TokenUser,
                                         buffUser.QueryPtr(),
                                         buffUser.QuerySize(),
                                         &cbBuffRequired ) )
            {
                err = ::GetLastError() ;
                if (hProcessToken)
                {
                    ::CloseHandle( hProcessToken );
                }

                DBGEOL( SZ("OpenProcess or GetTokenInfo failed with error ") << (ULONG) err ) ;
                break ;
            }
            ::CloseHandle( hProcessToken );

            TOKEN_USER * ptokenUser = (TOKEN_USER *) buffUser.QueryPtr() ;
            OS_SID ossidNewUser( ptokenUser->User.Sid ) ;
            if ( (err = ossidNewUser.QueryError()) ||
                 (err = possidSystemSid->Copy( ossidNewUser )))
            {
                break ;
            }
        }
        while (FALSE) ;
        break ;

    case UI_SID_CurrentProcessOwner:
        do
        {
            BUFFER buffOwner(   sizeof (SID_AND_ATTRIBUTES)
                              + sizeof (ULONG) * SID_MAX_SUB_AUTHORITIES ) ;
            ULONG  cbBuffRequired ;
            HANDLE hProcess = ::GetCurrentProcess() ;

            if ( (err = buffOwner.QueryError() ) )
            {
                break ;
            }

            /* Get the current process Owner's SID
             */
            HANDLE hProcessToken = NULL ;
            if (   !::OpenProcessToken( hProcess, TOKEN_QUERY, &hProcessToken )
                || !::GetTokenInformation( hProcessToken,
                                         TokenOwner,
                                         buffOwner.QueryPtr(),
                                         buffOwner.QuerySize(),
                                         &cbBuffRequired ) )
            {
                err = ::GetLastError() ;
                if (hProcessToken)
                {
                    ::CloseHandle( hProcessToken );
                }

                DBGEOL( SZ("OpenProcess or GetTokenInfo failed with error ") << (ULONG) err ) ;
                break ;
            }
            ::CloseHandle( hProcessToken );

            TOKEN_OWNER * ptokenOwner = (TOKEN_OWNER *) buffOwner.QueryPtr() ;
            OS_SID ossidNewOwner( ptokenOwner->Owner ) ;
            if ( (err = ossidNewOwner.QueryError()) ||
                 (err = possidSystemSid->Copy( ossidNewOwner )))
            {
                break ;
            }
        }
        while (FALSE) ;
        break ;

    case UI_SID_CurrentProcessPrimaryGroup:
        do {
            BUFFER buffGroup( sizeof(SID) + sizeof(ULONG)*SID_MAX_SUB_AUTHORITIES) ;
            ULONG  cbBuffRequired ;
            HANDLE hProcess = ::GetCurrentProcess() ;

            if ( (err = buffGroup.QueryError() ) )
            {
                break ;
            }

            /* Get the current process's primary group SID
             */
            HANDLE hProcessToken = NULL ;
            if ( !::OpenProcessToken( hProcess, TOKEN_QUERY, &hProcessToken ) ||
                 !::GetTokenInformation( hProcessToken,
                                         TokenPrimaryGroup,
                                         buffGroup.QueryPtr(),
                                         buffGroup.QuerySize(),
                                         &cbBuffRequired ) )
            {
                err = ::GetLastError() ;
                if (hProcessToken)
                {
                    ::CloseHandle( hProcessToken );
                }
                DBGEOL( SZ("OpenProcess or GetTokenInfo failed with error ") << (ULONG) err ) ;
                break ;
            }
            ::CloseHandle( hProcessToken );

            TOKEN_PRIMARY_GROUP * ptokengroup = (TOKEN_PRIMARY_GROUP*) buffGroup.QueryPtr() ;
            OS_SID ossidNewGroup( ptokengroup->PrimaryGroup ) ;
            if ( (err = ossidNewGroup.QueryError()) ||
                 (err = possidSystemSid->Copy( ossidNewGroup )))
            {
                break ;
            }
        } while (FALSE) ;
        break ;

    case UI_SID_Invalid:
    default:
        DBGEOL(SZ("NT_ACCOUNTS_UTILITY::QuerySystemSid Unrecognized SystemSid request")) ;
        UIASSERT( FALSE ) ;
        err = ERROR_INVALID_PARAMETER ;
        break ;
    }

    return err ;

}


#if 0 // uncomment if needed

/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::IsEqualToSystemSid

    SYNOPSIS:   Compares the SID to the requested system SID

    ENTRY:      UI_SystemSid - Which SID to compare
                possidSystemSid - Pointer to OS_SID that will compare

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      pszServer is not currently used

    HISTORY:
        JonN     17-Nov-1992    Created

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::IsEqualToSystemSid(
                                   BOOL *         pfEqual,
                              enum UI_SystemSid   SystemSid,
                                   const OS_SID & ossidCompare,
                                   const TCHAR  * pszServer )
{
    UIASSERT( pfEqual != NULL && ossidCompare.QueryError() == NERR_Success );

    APIERR err = NERR_Success;
    OS_SID ossidSystem;
    // CODEWORK cache the builtin sid
    if (   (err = ossidSystem.QueryError()) != NERR_Success
        || (err = QuerySystemSid( SystemSid,
                                  &ossidSystem,
                                  pszServer )) != NERR_Success
       )
    {
        DBGEOL( "NT_ACCOUNTS_UTILITY:: error loading SystemSid " << (INT)SystemSid );
    }
    else
    {
        *pfEqual = (ossidCompare == ossidSystem);
    }

    return err;

}

#endif


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::BuildAndCopySysSid

    SYNOPSIS:   Builds a SID from scratch given the identifier authority
                and subauthorities.  It then copies the resulting
                SID to possid

    ENTRY:      possid - Pointer to OS_SID that will receive the
                    newly built SID
                pIDAuthority - Pointer to an Identifier Authority
                cSubAuthorities - Count of sub-authorities
                ulSubAuthority0 -> ulSubAuthority7 - Subauthorities

    EXIT:       possid will contain the newly built SID

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   25-Apr-1992     Created

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::BuildAndCopySysSid(
                    OS_SID                   *possid,
                    PSID_IDENTIFIER_AUTHORITY pIDAuthority,
                    UCHAR                     cSubAuthorities,
                    ULONG                     ulSubAuthority0,
                    ULONG                     ulSubAuthority1,
                    ULONG                     ulSubAuthority2,
                    ULONG                     ulSubAuthority3,
                    ULONG                     ulSubAuthority4,
                    ULONG                     ulSubAuthority5,
                    ULONG                     ulSubAuthority6,
                    ULONG                     ulSubAuthority7 )
{
    PSID psid ;
    APIERR err = ERRMAP::MapNTStatus(RtlAllocateAndInitializeSid(
                                                     pIDAuthority,
                                                     cSubAuthorities,
                                                     ulSubAuthority0,
                                                     ulSubAuthority1,
                                                     ulSubAuthority2,
                                                     ulSubAuthority3,
                                                     ulSubAuthority4,
                                                     ulSubAuthority5,
                                                     ulSubAuthority6,
                                                     ulSubAuthority7,
                                                     &psid )) ;
    if ( err )
    {
        return err ;
    }

    OS_SID ossidTemp( psid ) ;
    if ( (err = ossidTemp.QueryError()) ||
         (err = possid->Copy( ossidTemp )) )
    {
        /* Fall Through
         */
    }

    RtlFreeSid( psid ) ;
    return err ;
}



/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_FetchDCList

    SYNOPSIS:   Worker function for GetQualifiedAccountNames
                Fetches DC names for each referenced domain where
                needed

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      afDCFound is passed in, an array of BOOL which indocates
                whether a DC could be found for each domain.

    HISTORY:
        JonN           16-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/

APIERR I_FetchDCList(   const LSA_TRANSLATED_NAME_MEM & lsatnm,
                        const LSA_REF_DOMAIN_MEM &  lsardm,
                        PSID                        psidLSAAcctDom,
                        PSID                        psidBuiltIn,
                        NLS_STR **                  apnlsPDCs,
                        STRLIST *                   pstrlistPDCs,
                        BOOL *                      afDCFound,
                        APIERR *                    perrNonFatal,
                        const TCHAR *               pszServer,
                        BOOL                        fFetchUserFlags,
                        BOOL                        fFetchFullNames,
                        BOOL                        fFetchComments )
{
    ASSERT( pstrlistPDCs != NULL );

    APIERR err = NERR_Success;
    NLS_STR nlsDC;
    if ((err = nlsDC.QueryError()) != NERR_Success)
        return err;

    for ( INT i = 0; i < (INT)lsardm.QueryCount(); i++ )
    {
        /* Get the DC for any referenced domains that contain user accounts.
         * Skip any domains that do not have any user accounts.
         */
        BOOL fFetchDCForDomain = FALSE ;
        for (   ULONG iNameMem = 0 ;
                (!fFetchDCForDomain) && (iNameMem < lsatnm.QueryCount()) ;
                iNameMem++)
        {
            //
            //  If this account's referenced domain doesn't match the domain
            //  we are currently considering, then skip this account
            //
            if ( lsatnm.QueryDomainIndex( iNameMem ) != i )
            {
                continue ;
            }

            switch ( lsatnm.QueryUse( iNameMem ) )
            {
            case SidTypeUser:
                if (fFetchUserFlags || fFetchFullNames || fFetchComments)
                {
                    fFetchDCForDomain = TRUE;
                }
                break;
            case SidTypeGroup:
            case SidTypeAlias:
                if (fFetchComments)
                {
                    fFetchDCForDomain = TRUE;
                }
                break;
            default:
                break;
            }
        }

        if ( !fFetchDCForDomain )
        {
            afDCFound[i] = FALSE ;
            continue ;
        }

        NLS_STR nlsDomainName;
        const TCHAR * pszDCName;

        if (   (err = nlsDomainName.QueryError()) != NERR_Success
            || (err = lsardm.QueryName( i, &nlsDomainName )) != NERR_Success
           )
        {
            return err;
        }

        //
        //  Skip the "BuiltIn" and "Accounts" domains
        //
        if (   ::EqualSid( psidLSAAcctDom, lsardm.QueryPSID( i ) )
            || ::EqualSid( psidBuiltIn,    lsardm.QueryPSID( i ) )
           )
        {
            // "Accounts" or "BuiltIn" domain

            afDCFound[i] = TRUE ;
            pszDCName = NULL ;
            nlsDomainName = SZ("") ;  // Empty so pszServer is used
        }
        else
        {
            // not "Accounts" or "BuiltIn" domain

            /* If the domain name is zero length (i.e., NULL) then the DC name
             * should be the focused machine (pszServer).
             */
            if ( (err = DOMAIN_WITH_DC_CACHE::GetAnyDC( NULL,
                                                   nlsDomainName.QueryPch(),
                                                   &nlsDC)) != NERR_Success )
            {
                ASSERT( nlsDomainName.strlen() > 0 );

                /* Any error as result DC not found is NOT fatal
                 *
                 */
                afDCFound[i] = FALSE ;
                pszDCName = NULL ;
                if ( perrNonFatal != NULL && !*perrNonFatal )
                {
                    *perrNonFatal = NERR_DCNotFound ;
                }

                DBGEOL(   "NT_ACCOUNTS_UTILITY::I_FetchDCList"
                       << " - Warning - Unable to get DC for domain \""
                       << nlsDomainName << "\", error " << err );

                err = NERR_Success;
            }
            else
            {
                pszDCName = nlsDC.QueryPch();
                afDCFound[i] = TRUE ;
            }

        }

        apnlsPDCs[i] = new NLS_STR( nlsDomainName.strlen() == 0 ? pszServer :
                                                                  pszDCName);
        err = ERROR_NOT_ENOUGH_MEMORY ;
        if ( (apnlsPDCs[i] == NULL) ||
             (err = apnlsPDCs[i]->QueryError()) ||
             (err = pstrlistPDCs->Append( apnlsPDCs[i] )) )
        {
            delete apnlsPDCs[i];
            apnlsPDCs[i] = NULL;
            return err ;
        }
    }

    return NERR_Success;

} // I_FetchDCList


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_FetchAliasFields

    SYNOPSIS:   Worker function for GetQualifiedAccountNames

                Loads the comment for this alias

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      This call will allocate a new ADMIN_AUTHORITY for the
                domain (in *ppadminauth) if none has yet been allocated.
                This way, they are loaded on demand, and not at all if
                not needed.

    HISTORY:
        JonN           18-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/

APIERR I_FetchAliasFields(  NLS_STR *       pnlsComment,
                            ADMIN_AUTHORITY ** ppadminauth,
                            SLIST_OF(ADMIN_AUTHORITY) * pslistADMIN_AUTH,
                            ULONG           ulRID,
                            BOOL            fDomainIsBuiltIn,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal )
{
    ASSERT( pnlsComment != NULL );
    ASSERT( ppadminauth != NULL );
    ASSERT( pslistADMIN_AUTH != NULL );

    APIERR err = NERR_Success;

    // Load alias comment

    if (*ppadminauth == NULL)
    {
        *ppadminauth = new ADMIN_AUTHORITY(
                        (pnlsPDC != NULL)
                            ? pnlsPDC->QueryPch()
                            : NULL );
                        // default access
        err = ERROR_NOT_ENOUGH_MEMORY;
        if (    *ppadminauth == NULL
            || (err = pslistADMIN_AUTH->Append( *ppadminauth )) != NERR_Success
           )
        {
            /* Note that this will cause repeated failures and long delays
             * in the unusual case where the ADMIN_AUTHORITY is successfully
             * created but the Append() fails.
             */
            delete *ppadminauth;
            *ppadminauth = NULL;
            return err;
        }
    }
    if ( (*ppadminauth)->QueryError() != NERR_Success )
    {
        return NERR_Success;
    }

    // At this point the ADMIN_AUTHORITY is ready

    SAM_ALIAS samalias( (fDomainIsBuiltIn)
                            ? *((*ppadminauth)->QueryBuiltinDomain())
                            : *((*ppadminauth)->QueryAccountDomain()),
                        ulRID,
                        ALIAS_READ_INFORMATION );

    if (   (err = samalias.QueryError()) != NERR_Success
        || (err = samalias.GetComment( pnlsComment )) != NERR_Success
       )
    {
        /* Treat this as a non-fatal error
         */
        DBGEOL("NT_ACCOUNTS_UTILITY::I_FetchAliasFields"
               << ", error " << err
               << " getting comment for alias \""
               << nlsAccountName << "\" from server \""
               << (*ppadminauth)->QuerySamServer()->QueryServerName()
               << "\"" );

        if ( perrNonFatal && !*perrNonFatal )
        {
            *perrNonFatal = err ;
        }
        err = NERR_Success;
    }

    return err;
}


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_FetchGroupFields

    SYNOPSIS:   Worker function for GetQualifiedAccountNames

                Loads the comment for this group

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      CODEWORK -- would a SAM_GROUP be faster?  Maybe, maybe not,
                since we would then need an ADMIN_AUTHORITY.

    HISTORY:
        JonN           16-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/

APIERR I_FetchGroupFields(  NLS_STR *       pnlsComment,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal )
{
    ASSERT( pnlsComment != NULL );

    APIERR err = NERR_Success;
    GROUP_1 group1( nlsAccountName.QueryPch(),
                    (pnlsPDC != NULL) ? pnlsPDC->QueryPch() : NULL );
    if (   (err = group1.QueryError()) != NERR_Success
        || (err = group1.GetInfo()) != NERR_Success
        || (err = pnlsComment->CopyFrom( group1.QueryComment())) != NERR_Success
       )
    {
        /* Treat this as a non-fatal error
         */
#if defined(DEBUG)
        DBGOUT("NT_ACCOUNTS_UTILITY::I_FetchGroupFields"
               << ", error " << err
               << " getting comment for group \""
               << nlsAccountName << "\" from server " );
        if ( pnlsPDC == NULL )
        {
            DBGEOL( "<NULL>" );
        }
        else
        {
            DBGEOL( "\"" << *pnlsPDC << "\"" );
        }
#endif

        if ( perrNonFatal && !*perrNonFatal )
        {
            *perrNonFatal = err ;
        }
        err = NERR_Success;
    }

    return err;

} // I_FetchGroupFields


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_FetchUserFields

    SYNOPSIS:   Worker function for GetQualifiedAccountNames

                Loads the comment, fullname and/or user flags for this user

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        JonN           18-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/
APIERR I_FetchUserFields(   NLS_STR *       pnlsComment,
                            NLS_STR *       pnlsFullName,
                            ULONG *         pulUserFlags,
                            const NLS_STR & nlsAccountName,
                            const NLS_STR * pnlsPDC,
                            APIERR *        perrNonFatal )
{
    APIERR err = NERR_Success;

    do { // false loop

        USER_2 * puser2;
        if ( pnlsPDC == NULL )
        {
            puser2 = new USER_2( nlsAccountName.QueryPch() );
        }
        else
        {
            puser2 = new USER_2( nlsAccountName.QueryPch(),
                            pnlsPDC->QueryPch() );
        }

        err = ERROR_NOT_ENOUGH_MEMORY;

        if ( puser2 == NULL
            || (err = puser2->QueryError()) != NERR_Success
            || (err = puser2->GetInfo()) != NERR_Success )
        {
            /* Treat this as a non-fatal error
             */
#if defined(DEBUG)
            DBGOUT("NT_ACCOUNTS_UTILITY::I_FetchUserFields"
                   << ", error " << err << " getting fields for user \""
                   << nlsAccountName << "\" from server " ) ;
            if ( pnlsPDC == NULL )
            {
                DBGEOL( "<NULL>" );
            }
            else
            {
                DBGEOL( "\"" << *pnlsPDC << "\"" );
            }
#endif

            delete puser2 ;
            puser2 = NULL ;

            if ( perrNonFatal && !*perrNonFatal )
            {
                *perrNonFatal = err ;
            }

            err = NERR_Success ;

            break;
        }

        if ( pulUserFlags != NULL )
        {
            *pulUserFlags = puser2->QueryUserFlags() ;
        }

        if ( pnlsFullName != NULL )
        {
            err = pnlsFullName->CopyFrom( puser2->QueryFullName() );
        }
        if ( (err == NERR_Success) && (pnlsComment != NULL) )
        {
            err = pnlsComment->CopyFrom( puser2->QueryComment() );
        }

        delete puser2;

    } while (FALSE); // false loop

    return err;

} // I_FetchUserFields


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::I_AppendToSTRLIST

    SYNOPSIS:   Worker function for GetQualifiedAccountNames

                Creates a copy of an NLS_STR and appends the copy
                to a STRLIST (so that it will be destructed with the
                STRLIST)

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      Does nothing if the STRLIST pointer is NULL

    HISTORY:
        JonN           19-Nov-1992      Split from GetQualifiedAccountNames

********************************************************************/

APIERR I_AppendToSTRLIST(   STRLIST *       pstrlist,
                            NLS_STR &       nlsToCopy )
{
    ASSERT( nlsToCopy.QueryError() == NERR_Success );

    APIERR err = NERR_Success;

    if ( pstrlist != NULL )
    {
        NLS_STR * pnls = new NLS_STR( nlsToCopy ) ;
        err = ERROR_NOT_ENOUGH_MEMORY ;
        if (   pnls == NULL
            || (err = pnls->QueryError()) != NERR_Success
            || (err = pstrlist->Append(pnls)) != NERR_Success
           )
        {
            delete pnls;
        }
    }

    return err;
}


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames

    SYNOPSIS:   Builds a fully qualified Account name of the form
                "NtProject\JohnL".

    ENTRY:
                lsapol          - LSA_POLICY object to perform the lookup
                                  on
                samdomFocus    -  SAM_DOMAIN object that points to the
                                  domain that has the current "focus"
                ppsids          - array of PSIDs for which qualified names
                                  are desired.
                cSids           - count of PSIDs to lookup
                fFullNames      - TRUE if FullNames are to be returned for Users
                pstrlistQualifiedNames - STRLIST that will receive the qualified
                                  names
                afUserFlags     - Optional array that will receive user account
                                  flags (such as remote users etc.)
                aSidType        - Optional array that will indicate the sid
                                  type
                perrNonFatal    - Non-fatal error indicator (such as DC not
                                  found)
                pszServer       - Optional (defaults to local machine) Server
                                  name to use for remote lookups of user
                                  full names (in form of "\\server").  Also
                                  used as a domain qualifier.
                pstrlistAccountNames - Optional stand alone account name
                pstrlistFullNames    - Optional stand alone Full Name
                pstrlistComments     - Optional stand alone Comment
                pstrlistDomainNames  - Optional stand alone Domain Name

    EXIT:       *strlistQualifiedNames will contain a strlist of
                qualified names in one of the following formats:


                "DOMAIN\NAME"   Resouce in domain other than current domain

                "NAME"          Resource in current domain

                Additionally, for Usernames, if fFullNames is TRUE:

                "DOMAIN\NAME (FULL NAME)"

                "NAME (FULL NAME)"

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        thomaspa        7-May-1992      Created
        Johnl          14-May-1992      Added optional aSidType parameter
        Johnl          08-Jul-1992      Added optional pszServer
        Johnl          15-Oct-1992      Added domain prefixing for Local groups
        Johnl          18-Nov-1992      Added PSID version for focused domain

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                      LSA_POLICY      & lsapol,
                                const SAM_DOMAIN      & samdomFocus,
                                const PSID            * ppsids,
                                ULONG                   cSids,
                                BOOL                    fFullNames,
                                STRLIST               * pstrlistQualifiedNames,
                                ULONG                 * afUserFlags,
                                SID_NAME_USE          * aSidType,
                                APIERR                * perrNonFatal,
                                const TCHAR           * pszServer,
                                STRLIST               * pstrlistAccountNames,
                                STRLIST               * pstrlistFullNames,
                                STRLIST               * pstrlistComments,
                                STRLIST               * pstrlistDomainNames  )
{
    return NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                         lsapol,
                         samdomFocus.QueryPSID(),
                         ppsids,
                         cSids,
                         fFullNames,
                         pstrlistQualifiedNames,
                         afUserFlags,
                         aSidType,
                         perrNonFatal,
                         pszServer,
                         pstrlistAccountNames,
                         pstrlistFullNames,
                         pstrlistComments,
                         pstrlistDomainNames ) ;
}


/*******************************************************************

    NAME:       NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames

    SYNOPSIS:   Builds a fully qualified Account name of the form
                "NtProject\JohnL".

    ENTRY:
                lsapol          - LSA_POLICY object to perform the lookup
                                  on
                psidSamDomainFocus - SID of the domain that has the current
                                  "focus", or NULL if all names should
                                  be qualified
                ppsids          - array of PSIDs for which qualified names
                                  are desired.
                cSids           - count of PSIDs to lookup
                fFullNames      - TRUE if FullNames are to be returned for Users
                pstrlistQualifiedNames - STRLIST that will receive the qualified
                                  names
                afUserFlags     - Optional array that will receive user account
                                  flags (such as remote users etc.)
                aSidType        - Optional array that will indicate the sid
                                  type
                perrNonFatal    - Non-fatal error indicator (such as DC not
                                  found)
                pszServer       - Optional (defaults to local machine) Server
                                  name to use for remote lookups of user
                                  full names (in form of "\\server").  Also
                                  used as a domain qualifier.
                pstrlistAccountNames - Optional stand alone account name
                pstrlistFullNames    - Optional stand alone Full Name
                pstrlistComments     - Optional stand alone Comment
                pstrlistDomainNames  - Optional stand alone Domain Name

    EXIT:       *strlistQualifiedNames will contain a strlist of
                qualified names in one of the following formats:


                "DOMAIN\NAME"   Resouce in domain other than current domain

                "NAME"          Resource in current domain

                Additionally, for Usernames, if fFullNames is TRUE:

                "DOMAIN\NAME (FULL NAME)"

                "NAME (FULL NAME)"

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        thomaspa        7-May-1992      Created
        Johnl          14-May-1992      Added optional aSidType parameter
        Johnl          08-Jul-1992      Added optional pszServer
        Johnl          15-Oct-1992      Added domain prefixing for Local groups

********************************************************************/

APIERR NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                LSA_POLICY &            lsapol,
                const PSID              psidSamDomainFocus,
                const PSID            * ppsids,
                ULONG                   cSids,
                BOOL                    fFullNames,
                STRLIST               * pstrlistQualifiedNames,
                ULONG                 * afUserFlags,
                SID_NAME_USE          * aSidType,
                APIERR                * perrNonFatal,
                const TCHAR           * pszServer,
                STRLIST               * pstrlistAccountNames,
                STRLIST               * pstrlistFullNames,
                STRLIST               * pstrlistComments,
                STRLIST               * pstrlistDomainNames )
{
    ASSERT( ppsids != NULL || cSids == 0 );
    ASSERT( pstrlistQualifiedNames != NULL );
    ASSERT( (psidSamDomainFocus == NULL) || ::IsValidSid( psidSamDomainFocus ) );

    LSA_TRANSLATED_NAME_MEM lsatnm;
    LSA_REF_DOMAIN_MEM    lsardm;
    LSA_ACCT_DOM_INFO_MEM LSAAcctDomMem ;

    APIERR err;
    if ( perrNonFatal != NULL )
    {
        *perrNonFatal = NERR_Success ;
    }

    if ( (err = lsapol.TranslateSidsToNames( ppsids,
                                              cSids,
                                              &lsatnm,
                                              &lsardm )) ||
         (err = lsapol.GetAccountDomain( &LSAAcctDomMem )))
    {
        return err;
    }

    ASSERT( cSids == lsatnm.QueryCount() );

    PSID psidLSAAcctDom = LSAAcctDomMem.QueryPSID() ;

    //
    // Create an array of PDC names, one for each referenced domain
    //
    BUFFER bufPDCs( sizeof(NLS_STR *) * lsardm.QueryCount() );
    if ( (err = bufPDCs.QueryError()) != NERR_Success )
    {
        return err;
    }
    NLS_STR ** apnlsPDCs = (NLS_STR **) bufPDCs.QueryPtr();

    //
    // This STRLIST ensures that all of the strings in the array will be freed.
    //
    STRLIST strlistPDCs ;

    //
    // This array remembers which DCs we have found
    //
    BUFFER buffDomainFoundArray( (UINT) (sizeof(BOOL) * lsardm.QueryCount())) ;
    if ( err = buffDomainFoundArray.QueryError() )
    {
        return err ;
    }
    BOOL *afDCFound = (BOOL *) buffDomainFoundArray.QueryPtr() ;

    ULONG i;
    for ( i = 0; i < lsardm.QueryCount(); i++ )
    {
        apnlsPDCs[i] = NULL;
        afDCFound[i] = FALSE;
    }

    //
    // Cache builtin SID for future reference
    //
    OS_SID ossidBuiltIn;
    if (   (err = ossidBuiltIn.QueryError()) != NERR_Success
        || (err = QuerySystemSid( UI_SID_BuiltIn, &ossidBuiltIn )) != NERR_Success
       )
    {
        return err;
    }

    //
    // First Get all the PDCs
    //
    if ( (err = I_FetchDCList(  lsatnm,
                                lsardm,
                                psidLSAAcctDom,
                                ossidBuiltIn.QueryPSID(),
                                apnlsPDCs,
                                &strlistPDCs,
                                afDCFound,
                                perrNonFatal,
                                pszServer,
                                (afUserFlags != NULL),
                                (fFullNames || (pstrlistFullNames != NULL)),
                                (pstrlistComments != NULL))) != NERR_Success )
    {
        return err;
    }

    //
    // Create API_SESSIONs to all the known DCs (best effort only)
    //
    // This array will contain API_SESSIONs to DCs for all domains
    // for which we were able to find a PDC, EXCEPT for the "Accounts"
    // and "BuiltIn" domains.  We do not attempt to open an API_SESSION
    // to that DC since we already have an LSA_POLICY to that server,
    // so we should already have a working connection.
    //
    BUFFER bufAPI_SESSION( sizeof(API_SESSION *) * lsardm.QueryCount() );
    if ( (err = bufAPI_SESSION.QueryError()) != NERR_Success )
        return err;
    API_SESSION ** apapisess = (API_SESSION **) bufAPI_SESSION.QueryPtr();
    SLIST_OF(API_SESSION) slistAPI_SESSION;

    //
    // These ADMIN_AUTHORITYs are used to load alias comments
    //
    BUFFER bufADMIN_AUTH( sizeof(ADMIN_AUTHORITY *) * lsardm.QueryCount() );
    if ( (err = bufADMIN_AUTH.QueryError()) != NERR_Success )
        return err;
    ADMIN_AUTHORITY ** apadminauth = (ADMIN_AUTHORITY **) bufADMIN_AUTH.QueryPtr();
    SLIST_OF(ADMIN_AUTHORITY) slistADMIN_AUTH;

    //
    // Get an API_SESSION to each known PDC
    //
    for ( i = 0; i < lsardm.QueryCount(); i++ )
    {
        apapisess[i] = NULL;
        apadminauth[i] = NULL;

        if (   afDCFound[i]
            && !::EqualSid( psidLSAAcctDom,           lsardm.QueryPSID(i) )
            && !::EqualSid( ossidBuiltIn.QueryPSID(), lsardm.QueryPSID(i) )
           )
        {
            const TCHAR * pchPDC = (apnlsPDCs[i] == NULL)
                                        ? NULL
                                        : apnlsPDCs[i]->QueryPch() ;
            apapisess[i] = new API_SESSION( pchPDC, TRUE );
            err = ERROR_NOT_ENOUGH_MEMORY;
            if (   (apapisess[i] == NULL)
                || (err = slistAPI_SESSION.Append( apapisess[i] )) != NERR_Success
               )
            {
                delete apapisess[i];
                apapisess[i] = NULL;
                return err;
            }
#if defined(DEBUG)
            if ( (err = apapisess[i]->QueryError()) != NERR_Success)
            {
                DBGEOL(   "NT_ACCOUNTS_UTILITY error " << err
                       << "adding API_SESSION to \"" << pchPDC << "\"" );
                err = NERR_Success;
            }
#endif

        }

        ASSERT(   !afDCFound[i]
               || apapisess[i] != NULL // may be in error state
               || ::EqualSid( psidLSAAcctDom,           lsardm.QueryPSID(i) )
               || ::EqualSid( ossidBuiltIn.QueryPSID(), lsardm.QueryPSID(i) )
              );
    }

    NLS_STR nlsQualifiedAccountName;
    NLS_STR nlsAccountName;
    NLS_STR nlsFullName;
    NLS_STR nlsComment;
    NLS_STR nlsDomainDisplayName;
    if (   (err = nlsQualifiedAccountName.QueryError()) != NERR_Success
        || (err = nlsAccountName.QueryError()) != NERR_Success
        || (err = nlsFullName.QueryError()) != NERR_Success
        || (err = nlsComment.QueryError()) != NERR_Success
        || (err = nlsDomainDisplayName.QueryError()) != NERR_Success
       )
    {
        return err;
    }

    //
    // Now build the qualified names
    //
    for ( i = 0; i < lsatnm.QueryCount(); i++ )
    {
        nlsQualifiedAccountName = NULL;
        nlsAccountName = NULL;
        nlsFullName = NULL;
        nlsComment = NULL;
        nlsDomainDisplayName = NULL;
        ASSERT(   nlsQualifiedAccountName.QueryError() == NERR_Success
               && nlsAccountName.QueryError() == NERR_Success
               && nlsFullName.QueryError() == NERR_Success
               && nlsComment.QueryError() == NERR_Success
               && nlsDomainDisplayName.QueryError() == NERR_Success
              );

        PSID psidDomainForName = NULL ;

        SID_NAME_USE sidtype = lsatnm.QueryUse( i );

        if ( afUserFlags != NULL )
            afUserFlags[i] = 0;

        if ( aSidType != NULL )
            aSidType[i] = sidtype ;

        OS_SID ossidDomain( ppsids[i], TRUE );
        ULONG ulRID;
        if (   (err = ossidDomain.QueryError()) != NERR_Success
            || (err = ossidDomain.TrimLastSubAuthority( &ulRID )) != NERR_Success
           )
        {
            break;
        }

        LONG nIndex = lsatnm.QueryDomainIndex( i );

        if ( nIndex >= 0 ) // valid domain index
        {

            //
            // If the name is an alias, it might be in the Builtin domain.
            // If so, use the name of the LSA Accounts domain instead.
            //
            if ( (sidtype == SidTypeAlias) && (ossidDomain == ossidBuiltIn) )
            {
                err = LSAAcctDomMem.QueryName( &nlsDomainDisplayName );
            }
            else
            {
                err = lsardm.QueryName( nIndex, &nlsDomainDisplayName );
            }

            if (err != NERR_Success)
            {
                break;
            }

            psidDomainForName = lsardm.QueryPSID( nIndex );
        }

        PSID psidDomainToQualify = psidDomainForName;

        if (sidtype != SidTypeInvalid)
        {
            if ( (err = lsatnm.QueryName( i, &nlsAccountName )) != NERR_Success )
            {
                break;
            }
        }

        //
        // Load special information, such as fullnames, comments and user flags
        //
        switch (sidtype)
        {

        case SidTypeInvalid:
        case SidTypeWellKnownGroup:
        case SidTypeDomain:
        case SidTypeDeletedAccount:
        case SidTypeUnknown:
            break;

        case SidTypeAlias:
            {

                UIASSERT(   ::IsValidSid( psidLSAAcctDom ) );

                psidDomainToQualify = psidLSAAcctDom;

                if (   nIndex >= 0         // valid domain index
                    && afDCFound[nIndex]
                    && (pstrlistComments != NULL) )
                {
                    // Load alias comment

                    // Do not load if we failed to get an API_SESSION
                    if (   apapisess[nIndex] != NULL
                        && (err = apapisess[nIndex]->QueryError()) != NERR_Success )
                    {
                        /* Treat this as a non-fatal error
                         */
#if defined(DEBUG)
                        DBGOUT("NT_ACCOUNTS_UTILITY::GetQualifiedAccountName"
                               << ", cannot load alias fields due to error " << err
                               << " in API_SESSION for server " );
                        if ( apnlsPDCs[nIndex] == NULL )
                        {
                            DBGEOL( "<NULL>" );
                        }
                        else
                        {
                            DBGEOL( "\"" << *(apnlsPDCs[nIndex]) << "\"" );
                        }
#endif // DEBUG

                        err = NERR_Success ;
                    }
                    else
                    {
                        err = I_FetchAliasFields( &nlsComment,
                                                  &(apadminauth[nIndex]),
                                                  &slistADMIN_AUTH,
                                                  ulRID,
                                                  (ossidDomain == ossidBuiltIn),
                                                  nlsAccountName,
                                                  apnlsPDCs[nIndex],
                                                  perrNonFatal );
                    }
                }

            }
            break;

        case SidTypeGroup:
            if (   nIndex >= 0
                && afDCFound[nIndex]
                && (pstrlistComments != NULL)
               )
            {
                err = I_FetchGroupFields( &nlsComment,
                                          nlsAccountName,
                                          apnlsPDCs[nIndex],
                                          perrNonFatal );
            }
            break;

        case SidTypeUser:
            /* If there were no DCs to find or we failed to lookup this
             * DC then don't use the fullname.
             */
            if (   nIndex >= 0
                && afDCFound[nIndex]
                && (    (afUserFlags != NULL)
                     || (fFullNames || (pstrlistFullNames != NULL))
                     || (pstrlistComments != NULL)) )
            {
                // Do not load if we failed to get an API_SESSION
                if (   apapisess[nIndex] != NULL
                    && (err = apapisess[nIndex]->QueryError()) != NERR_Success )
                {
                    /* Treat this as a non-fatal error
                     */
#if defined(DEBUG)
                    DBGOUT("NT_ACCOUNTS_UTILITY::GetQualifiedAccountName"
                           << ", cannot load user fields due to error " << err
                           << " in API_SESSION for server " );
                    if ( apnlsPDCs[nIndex] == NULL )
                    {
                        DBGEOL( "<NULL>" );
                    }
                    else
                    {
                        DBGEOL( "\"" << *(apnlsPDCs[nIndex]) << "\"" );
                    }
#endif // DEBUG

                    err = NERR_Success ;
                }
                else
                {
                    err = I_FetchUserFields( &nlsComment,
                                             &nlsFullName,
                                             (afUserFlags == NULL)
                                               ? NULL
                                               : &(afUserFlags[i]),
                                             nlsAccountName,
                                             apnlsPDCs[nIndex],
                                             perrNonFatal );
                }

            }
            break;

        default:
            DBGEOL( "NTACUTIL: bad sid type " << (INT)sidtype );
            break;

        } // switch (sidtype)

        if ( err != NERR_Success )
            break;

        //
        // Load qualified name
        //
        switch (sidtype)
        {

        case SidTypeUser:
        case SidTypeGroup:
        case SidTypeAlias:
        case SidTypeDomain:
        case SidTypeDeletedAccount:
        case SidTypeUnknown:
        case SidTypeInvalid:
            //
            //  If the domain SIDs are pointing at the same domain, then
            //  don't prefix the alias, otherwise prefix it.
            //
            err = NT_ACCOUNTS_UTILITY::BuildQualifiedAccountName(
                                        &nlsQualifiedAccountName,
                                        nlsAccountName,
                                        psidDomainToQualify,
                                        nlsDomainDisplayName,
                                        &nlsFullName,
                                        psidSamDomainFocus,
                                        sidtype ) ;

            break;

        case SidTypeWellKnownGroup:
            /* Well known SIDs should never be prefixed by domains
             */
            err = nlsQualifiedAccountName.CopyFrom( nlsAccountName ) ;
            break;

        default:
            break;
        }

        if ( err )
        {
            break ;
        }

        //
        // Note that I_AppendToSTRLIST does nothing if the
        // strlist pointer is NULL
        //

        if (   (err = I_AppendToSTRLIST( pstrlistQualifiedNames,
                                         nlsQualifiedAccountName )) != NERR_Success
            || (err = I_AppendToSTRLIST( pstrlistAccountNames,
                                         nlsAccountName )) != NERR_Success
            || (err = I_AppendToSTRLIST( pstrlistFullNames,
                                         nlsFullName )) != NERR_Success
            || (err = I_AppendToSTRLIST( pstrlistComments,
                                         nlsComment )) != NERR_Success
            || (err = I_AppendToSTRLIST( pstrlistDomainNames,
                                         nlsDomainDisplayName )) != NERR_Success
           )
        {
            DBGEOL("NT_ACCOUNTS_UTILITY::GetQualifiedAccountName"
                   << ", error " << err
                   << " copying strings to STRLISTs" );
            break;
        }

    } // loop i=0 to lsatnm.QueryCount()-1

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\lsaaccnt.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    lsaaccnt.hxx

    This file contains the LSA account object.

    FILE HISTORY:
        Yi-HsinS         3-Mar-1992     Created
*/

#include "pchlmobj.hxx"  // Precompiled header


// The size of STANDARD_PRIVILEGE_SET_SIZE can contain 3 privileges.
#define DEFAULT_NUM_PRIVILEGE        3
#define STANDARD_PRIVILEGE_SET_SIZE  ( sizeof( PRIVILEGE_SET ) +  \
                                       (DEFAULT_NUM_PRIVILEGE - 1 ) * \
                                       sizeof( LUID_AND_ATTRIBUTES ) )

BOOL OS_LUID :: operator==( const OS_LUID & osluid ) const
{
#if defined(_CFRONT_PASS_)
    return _luid.u.LowPart  == (osluid.QueryLuid()).u.LowPart &&
              _luid.u.HighPart == (osluid.QueryLuid()).u.HighPart;
#else
    return _luid.LowPart  == (osluid.QueryLuid()).LowPart &&
           _luid.HighPart == (osluid.QueryLuid()).HighPart;
#endif
}


/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::OS_PRIVILEGE_SET

    SYPNOSIS:   Constructor

    ENTRY:      pPrivSet - pointer to a PRIVILEGE_SET or NULL. If it is
                           NULL, then we allocate memory locally.

    EXITS:

    RETURNS:

    NOTES:      If pPrivSet is NULL, the buffer allcated can contain at
                most DEFAULT_NUM_PRIVILEGE. The buffer will be resized
                if necessary.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

OS_PRIVILEGE_SET::OS_PRIVILEGE_SET( PPRIVILEGE_SET pPrivSet )
    : OS_OBJECT_WITH_DATA( (UINT)(pPrivSet == NULL? STANDARD_PRIVILEGE_SET_SIZE: 0 )),
      _pPrivSet( pPrivSet == NULL? (PPRIVILEGE_SET) QueryPtr() : pPrivSet ),
      _osluidAndAttrib(),
      _ulMaxNumPrivInBuf( pPrivSet == NULL? DEFAULT_NUM_PRIVILEGE
                                           : pPrivSet->PrivilegeCount )
{
    if ( QueryError() != NERR_Success )
        return;

    if ( pPrivSet == NULL )
    {
        InitializeMemory();
    }

}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::~OS_PRIVILEGE_SET

    SYPNOSIS:   Destructor

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      Free the memory only if it's allocated by some API.
                Otherwise, the BUFFER object in OS_OBJECT_WITH_DATA
                will free the memory that we allocated ourselves.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

OS_PRIVILEGE_SET::~OS_PRIVILEGE_SET()
{
    if ( IsOwnerAlloc() )
        ::LsaFreeMemory( _pPrivSet );

    _pPrivSet = NULL;
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::InitializeMemory

    SYPNOSIS:   Initialize local memory

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

VOID OS_PRIVILEGE_SET::InitializeMemory( VOID )
{
    UIASSERT( !IsOwnerAlloc() );

    _pPrivSet->PrivilegeCount = 0;
    _pPrivSet->Control = 0;
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::QueryPrivilege

    SYPNOSIS:   Query the ith privilege contained in the OS_PRIVILEGE_SET

    ENTRY:

    EXITS:

    RETURNS:    Returns the ith OS_LUID_AND_ATTRIBUTES contained in the
                privilege set.

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

const OS_LUID_AND_ATTRIBUTES *OS_PRIVILEGE_SET::QueryPrivilege( LONG i )
{
    UIASSERT( ( i >= 0) && ( i < (LONG) _pPrivSet->PrivilegeCount) );

    _osluidAndAttrib.SetLuidAndAttrib( _pPrivSet->Privilege[i] );

    return &_osluidAndAttrib;
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::FindPrivilege

    SYPNOSIS:   Find a privilege in the set

    ENTRY:      luid - id of the privilege to search for

    EXITS:

    RETURNS:    Returns the index to the privilege set that contains
                the luid passed in

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LONG OS_PRIVILEGE_SET::FindPrivilege( LUID luid ) const
{
    for ( LONG i = 0; i < (LONG) _pPrivSet->PrivilegeCount; i++ )
    {
         if (
#if defined(_CFRONT_PASS_)
               ( _pPrivSet->Privilege[i].Luid.u.LowPart == luid.u.LowPart )
            && ( _pPrivSet->Privilege[i].Luid.u.HighPart == luid.u.HighPart )

#else
               ( _pPrivSet->Privilege[i].Luid.LowPart == luid.LowPart )
            && ( _pPrivSet->Privilege[i].Luid.HighPart == luid.HighPart )
#endif
            )
         {
             return i;
         }
    }

    return -1;  // No match!
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::AddPrivilege

    SYPNOSIS:   Add a privilege to the privilege set

    ENTRY:      luid - the id of the privilege to add
                ulAttribs - the attributes to be assigned to the privilege

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR OS_PRIVILEGE_SET::AddPrivilege( LUID luid, ULONG ulAttribs )
{
    UIASSERT( !IsOwnerAlloc() );

    APIERR err = NERR_Success;
    LONG iAdd = FindPrivilege( luid );

    //
    //  If the luid is already in the privilege set, just return.
    //

    if ( iAdd >= 0 )
    {
        _pPrivSet->Privilege[ iAdd ].Attributes = ulAttribs;
        return err;
    }

    //
    //  If the buffer is full, resize it to accommodate more privileges
    //

    if ( _pPrivSet->PrivilegeCount == _ulMaxNumPrivInBuf )
    {

        err = Resize( QueryAllocSize() + sizeof( LUID_AND_ATTRIBUTES ) *
                                         DEFAULT_NUM_PRIVILEGE );

        _pPrivSet = (PPRIVILEGE_SET) QueryPtr();

        if ( err != NERR_Success )
            return err;

        _ulMaxNumPrivInBuf += DEFAULT_NUM_PRIVILEGE;
    }

    //
    //  Add the privilege to the set
    //

    iAdd = _pPrivSet->PrivilegeCount++;

    _pPrivSet->Privilege[ iAdd ].Luid = luid;
    _pPrivSet->Privilege[ iAdd ].Attributes = ulAttribs;

    return err;
}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::RemovePrivilege

    SYPNOSIS:   Remove the privilege from the set

    ENTRY:      luid - the privilege to be removed

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR OS_PRIVILEGE_SET::RemovePrivilege( LUID luid )
{

    UIASSERT( !IsOwnerAlloc() );

    LONG iDelete = FindPrivilege( luid );

    //
    // If we can't find luid, just return success.
    // Else delete it from the set.
    //

    if (( iDelete >= 0 )  && ( iDelete < (LONG) _pPrivSet->PrivilegeCount ))
    {
         _pPrivSet->Privilege[ iDelete ] =
                 _pPrivSet->Privilege[ _pPrivSet->PrivilegeCount - 1];

        _pPrivSet->PrivilegeCount--;
    }

    return NERR_Success;

}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::RemovePrivilege

    SYPNOSIS:   Remove the ith privilege from the privilege set.

    ENTRY:      i - the index of the privilege to remove.

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR OS_PRIVILEGE_SET::RemovePrivilege( LONG i )
{

    UIASSERT( !IsOwnerAlloc() );

    UIASSERT( ( i >= 0) && ( i < (LONG) _pPrivSet->PrivilegeCount));

    _pPrivSet->Privilege[ i ] =
            _pPrivSet->Privilege[ _pPrivSet->PrivilegeCount - 1];

    _pPrivSet->PrivilegeCount--;

    return NERR_Success;

}

/*************************************************************************

    NAME:       OS_PRIVILEGE_SET::Clear

    SYPNOSIS:   Clear the privilege set, i.e., set the privilege count to zero.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      This is only valid when the set is allocated by
                ourselves and not returned to us by some API.

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

VOID OS_PRIVILEGE_SET::Clear( VOID )
{
    UIASSERT( !IsOwnerAlloc() );

    _pPrivSet->PrivilegeCount = 0;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::LSA_ACCOUNT_PRIVILEGE_ENUM_ITER

    SYNOPSIS:   Constructor

    ENTRY:      pOsPrivSet - the privilege set to iterate over

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::LSA_ACCOUNT_PRIVILEGE_ENUM_ITER(
                                 OS_PRIVILEGE_SET * pOsPrivSet )
    :  _pOsPrivSet( pOsPrivSet ),
       _iNext( 0 )
{
    if ( QueryError() != NERR_Success )
        return;
}

/*************************************************************************

    NAME:      LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::~LSA_ACCOUNT_PRIVILEGE_ENUM_ITER

    SYNOPSIS:  Destructor

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::~LSA_ACCOUNT_PRIVILEGE_ENUM_ITER()
{
    _pOsPrivSet = NULL;
}

/*************************************************************************

    NAME:      LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::operator()

    SYNOPSIS:  Iterator to return the next privilege in the privilege set

    ENTRY:

    EXITS:

    RETURNS:   Returns the next privilege OS_LUID_AND_ATTRIBUTES in the set.

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

const OS_LUID_AND_ATTRIBUTES *LSA_ACCOUNT_PRIVILEGE_ENUM_ITER::operator()( VOID)
{
    if ( _iNext < (LONG) _pOsPrivSet->QueryNumberOfPrivileges() )
    {
        return _pOsPrivSet->QueryPrivilege( _iNext++ );
    }

    return NULL;  // Reach the end
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::LSA_ACCOUNT

    SYNOPSIS:   Constructor

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY object
                psid - the sid of the account
                accessDesired - access desired to handle the account

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNT::LSA_ACCOUNT( LSA_POLICY *plsaPolicy,
                          PSID psid,
                          ACCESS_MASK accessDesired,
                          const TCHAR * pszFocus,
                          PSID psidFocus )
    : NEW_LM_OBJ(),
      _plsaPolicy( plsaPolicy ),
      _handleAccount( 0 ),
      _ossid( psid, TRUE ),
      _accessDesired( accessDesired ),
      _osPrivSetCurrent(),
      _osPrivSetAdd(),
      _osPrivSetDelete(),
      _ulSystemAccessCurrent( 0 ),
      _ulSystemAccessNew( 0 )
{

    if ( QueryError() != NERR_Success )
        return;

    APIERR err;
    if (  ((err = _ossid.QueryError()) != NERR_Success )
       || ((err = _ossid.QueryName( &_nlsName, pszFocus, psidFocus )) != NERR_Success )
       )
    {
        ReportError( err );
        return;
    }

}

/*************************************************************************

    NAME:       LSA_ACCOUNT::PrintInfo

    SYNOPSIS:   Dump the information in the LSA_ACCOUNT

    ENTRY:      pszString - the title to print out for the dump

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

VOID LSA_ACCOUNT::PrintInfo( const TCHAR *pszString )
{
#ifndef TRACE
    UNREFERENCED( pszString );
#endif
    TRACEEOL( pszString << SZ(":") );
    TRACEEOL( SZ("Name:") << _nlsName );
    TRACEEOL( SZ("New:") << _osPrivSetAdd.QueryNumberOfPrivileges() );
    TRACEEOL( SZ("Current:") << _osPrivSetCurrent.QueryNumberOfPrivileges() );
    TRACEEOL( SZ("Delete:") << _osPrivSetDelete.QueryNumberOfPrivileges() );
    TRACEEOL( SZ("Current SystemAccess:") << _ulSystemAccessCurrent );
    TRACEEOL( SZ("New SystemAccess:") << _ulSystemAccessNew );
    TRACEEOL( SZ("") );
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::~LSA_ACCOUNT

    SYNOPSIS:   Destructor

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNT::~LSA_ACCOUNT()
{
    //
    // Close the handle if it has been opened
    //
    if ( _handleAccount != 0 )
        ::LsaClose( _handleAccount );

    _plsaPolicy = NULL;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::QueryPrivilegeEnumIter

    SYNOPSIS:   Return an iterator that can be iterated to get the
                privileges the account has.

    ENTRY:

    EXITS:      *ppIter - contains a pointer to the iterator

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::QueryPrivilegeEnumIter( LSA_ACCOUNT_PRIVILEGE_ENUM_ITER
                                            **ppIter )
{
    *ppIter = new LSA_ACCOUNT_PRIVILEGE_ENUM_ITER( &_osPrivSetCurrent );

    APIERR err = (*ppIter == NULL)? ERROR_NOT_ENOUGH_MEMORY
                                  : (*ppIter)->QueryError();

    if ( err != NERR_Success )
    {
        delete *ppIter;
        *ppIter = NULL;
    }

    return err;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::InsertPrivilege

    SYNOPSIS:   Add a privilege to the account

    ENTRY:      luid - the privilege to be added
                ulAttribs - the attribute to be assigned to the privilege

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::InsertPrivilege( LUID luid, ULONG ulAttribs )
{
    APIERR err = NERR_Success;

    // Remove the privilege from the "deleted" privilege set if it's there
    err = _osPrivSetDelete.RemovePrivilege( luid );

    //
    // See if the privilege is in the current privilege set
    // If so, do nothing.
    // Else, add the privilege to the "add" privilege set.
    //
    if (  (err == NERR_Success)
       && ( _osPrivSetCurrent.FindPrivilege( luid ) < 0)
       )
    {
        err = _osPrivSetAdd.AddPrivilege( luid, ulAttribs );
    }

    return err;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::DeletePrivilege

    SYNOPSIS:   Remove the privilege from the account

    ENTRY:      luid - the privilege to be removed

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::DeletePrivilege( LUID luid )
{
    APIERR err = NERR_Success;
    LONG i;

    //
    // See if the privilege is in the current privilege set.
    // If so, add the privilege to the "deleted" privilege set.
    // Else if the privilege is in the "add" privilege set,
    //        remove it from the "add" privilege set.
    // Else, do nothing.
    //
    if ( _osPrivSetCurrent.FindPrivilege( luid ) >= 0 )
    {
        err = _osPrivSetDelete.AddPrivilege( luid );
    }
    else if ( (i = _osPrivSetAdd.FindPrivilege( luid )) >= 0 )
    {
        err = _osPrivSetAdd.RemovePrivilege( i );
    }

    return err;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_GetInfo

    SYNOPSIS:   Get all information about the account, including the
                privileges and system access modes.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_GetInfo( VOID )
{
    APIERR err = ERRMAP::MapNTStatus( ::LsaOpenAccount(
                                          _plsaPolicy->QueryHandle(),
                                          _ossid.QuerySid(),
                                          _accessDesired,
                                         &_handleAccount  ));


    if ( err == NERR_Success )
    {
        PPRIVILEGE_SET pPrivSet;
        err = ERRMAP::MapNTStatus(
                  ::LsaEnumeratePrivilegesOfAccount(  _handleAccount,
                                                     &pPrivSet ) );

        if ( err == NERR_Success )
        {
            _osPrivSetCurrent.SetPtr( pPrivSet );

            err = ERRMAP::MapNTStatus(
                      ::LsaGetSystemAccessAccount(  _handleAccount,
                                                   &_ulSystemAccessCurrent ) );

            if ( err == NERR_Success )
            {
                _ulSystemAccessNew = _ulSystemAccessCurrent;
            }
        }
    }

    return err;

}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_WriteInfo

    SYNOPSIS:   Write all information about the account back to the LSA
                including the privileges and system access modes.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_WriteInfo( VOID )
{
    APIERR err = NERR_Success;

    //
    // If there are new privileges to be added, add them.
    //
    if ( _osPrivSetAdd.QueryNumberOfPrivileges() > 0 )
    {
        err = ERRMAP::MapNTStatus( ::LsaAddPrivilegesToAccount(
                                              _handleAccount,
                                              _osPrivSetAdd.QueryPrivSet()));
    }

    //
    // If there are privileges to be deleted from the account, delete them.
    //
    if (  ( err == NERR_Success )
       && ( _osPrivSetDelete.QueryNumberOfPrivileges() > 0 )
       )
    {
        err = ERRMAP::MapNTStatus( ::LsaRemovePrivilegesFromAccount(
                                              _handleAccount,
                                              FALSE,
                                              _osPrivSetDelete.QueryPrivSet()));
    }

    //
    // If we have modified the system access mode, write them out.
    //
    if (  ( err == NERR_Success )
       && ( _ulSystemAccessNew != _ulSystemAccessCurrent )
       )
    {
        err = ERRMAP::MapNTStatus( ::LsaSetSystemAccessAccount(
                                              _handleAccount,
                                              _ulSystemAccessNew ));
    }

    return err;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::W_CreateNew

    SYNOPSIS:   Initialize internal variables for a new account

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::W_CreateNew( VOID )
{
    APIERR err;

    if ( (err =  NEW_LM_OBJ::W_CreateNew()) != NERR_Success )
        return err;

    _handleAccount = 0;

    _osPrivSetCurrent.Clear();
    _osPrivSetAdd.Clear();
    _osPrivSetDelete.Clear();

    _ulSystemAccessCurrent = 0;
    _ulSystemAccessNew = 0;

    return NERR_Success;
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_CreateNew

    SYNOPSIS:   Create a new account.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_CreateNew( VOID )
{
    return W_CreateNew();
}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_WriteNew

    SYNOPSIS:   Write out the new lsa account.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_WriteNew( VOID )
{
    APIERR err = NERR_Success;

    //
    // If we have not modified the privileges of the account nor
    // add system access mode to the account, then we don't need
    // to create the account in the LSA.
    //
    if (  ( _osPrivSetAdd.QueryNumberOfPrivileges() == 0 )
       && ( _ulSystemAccessNew == 0 )
       )
    {
        // No privilege is added, so we don't need to create the account.
        return err;   // Return NERR_Success
    }

    //
    // Create the LSA account
    //
    err = ERRMAP::MapNTStatus( ::LsaCreateAccount( _plsaPolicy->QueryHandle(),
                                                   _ossid.QuerySid(),
                                                   _accessDesired,
                                                  &_handleAccount ));

    if ( err == NERR_Success )
    {
        //
        // Add the privileges to the account if modified
        //
        if ( _osPrivSetAdd.QueryNumberOfPrivileges() != 0 )
        {
            err = ERRMAP::MapNTStatus( ::LsaAddPrivilegesToAccount(
                                               _handleAccount,
                                               _osPrivSetAdd.QueryPrivSet()));
        }

        //
        // Set the system access modes if modified
        //
        if ( ( err == NERR_Success ) && ( _ulSystemAccessNew != 0 ) )
        {
            err = ERRMAP::MapNTStatus( ::LsaSetSystemAccessAccount(
                                               _handleAccount,
                                               _ulSystemAccessNew ));
        }
    }

    return err;

}

/*************************************************************************

    NAME:       LSA_ACCOUNT::I_Delete

    SYNOPSIS:   Delete the lsa account.

    ENTRY:

    EXITS:

    RETURNS:

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNT::I_Delete( UINT uiForce )
{
    UNREFERENCED( uiForce );

    APIERR err = NERR_Success;
    if ( _handleAccount != 0 )
    {
        err =  ERRMAP::MapNTStatus( ::LsaDelete( _handleAccount ));
        _handleAccount = 0;
    }

    return err;

}

/*************************************************************************

    NAME:       LSA_ACCOUNT::IsDefaultSettings

    SYNOPSIS:   Check if the account has default settings, i.e., no
                privileges, no system access modes ...

    ENTRY:

    EXITS:

    RETURNS:    TRUE if the account has default settings, FALSE otherwise.

    NOTES:      

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

BOOL LSA_ACCOUNT::IsDefaultSettings( VOID )
{
    //CODEWORK : Need to check whether quota is default settings
    return (  ( _osPrivSetAdd.QueryNumberOfPrivileges() == 0 )
           && ( _osPrivSetCurrent.QueryNumberOfPrivileges() ==
                   _osPrivSetDelete.QueryNumberOfPrivileges() )
           && ( _ulSystemAccessNew == 0 )
           );
}

// End of LSAACCNT.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\security.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1991                **/
/**********************************************************************/

/*
    Security.cxx

    This file contains wrapper classes for the Win32 security structures.
    Specifically: ACE, ACL, SECURITY_DESCRIPTOR,
    and SECURITY_DESCRIPTOR_CONTROL.

    The wrapper classes follow the same name except the class
    names will begin with an "OS_".

    FILE HISTORY:
        Johnl   11-Dec-1991     Created
        JohnL   09-Mar-1992     Code review changes
        JohnL   04-May-1992     Moved OS_SID out to its own file

*/

#include "pchlmobj.hxx"  // Precompiled header


#ifndef max
#define max(a,b)   ((a)>(b)?(a):(b))
#endif

/* The initial allocation size for an NT SID
 */
#define STANDARD_SID_SIZE  (sizeof(SID))

/* Initial allocation size of a basic *known* ACE.
 * Note that the SID is variable length, thus this number
 * is only a starting point.
 */
#define STANDARD_ACE_SIZE  (max(sizeof(ACCESS_ALLOWED_ACE),     \
                            max(sizeof(ACCESS_DENIED_ACE),      \
                            max(sizeof(SYSTEM_AUDIT_ACE),       \
                                sizeof(SYSTEM_ALARM_ACE)) ))    \
                            - sizeof(ULONG) + STANDARD_SID_SIZE)

/* Initial allocation size of an NT ACL (room for 1 ACE)
 */
#define STANDARD_ACL_SIZE  (sizeof(ACL) + STANDARD_ACE_SIZE)

/*******************************************************************

    NAME:       OS_ACE::OS_ACE

    SYNOPSIS:   Standard constructor and destructor

    ENTRY:      pACE - Pointer to valid ACE or NULL.  If pACE is non-NULL,
                it should point to a valid ACE we can operate on (all
                operations except anything that causes expansion).  If
                pACE is NULL, then we allocate the memory locally.

    EXIT:

    RETURNS:

    NOTES:      This ACE defaults to an ACCESS_DENIED_ACE_TYPE if pACE
                is NULL.  Note that QuerySIDMemory may break if the
                different ACE sizes ever differ (we key off the type so
                we use the correct cast, however if the ace type is
                different and has a different SID offset, then the
                wrong portion of memory will be initialized by QuerySIDMemory.

                Note that there is no ::IsValidAce API, thus we can only
                check the SID for validity.

    HISTORY:
        Johnl   13-Dec-1991     Created

********************************************************************/

OS_ACE::OS_ACE( void * pACE )
    : OS_OBJECT_WITH_DATA( (UINT)(pACE == NULL ? STANDARD_ACE_SIZE : 0 )),
      _pACEHeader( NULL ),
      _possid( NULL )
{
    if ( QueryError() )
        return ;

    _pACEHeader = (PACE_HEADER) (pACE == NULL ? QueryPtr() : pACE ) ;

    APIERR err ;

    if ( pACE == NULL )
    {
        /* Initialize the whole chunk of memory to zeros
         */
        ::memsetf( QueryPtr(), 0, QueryAllocSize() ) ;

        _pACEHeader->AceSize = (USHORT)QueryAllocSize() ;
        _pACEHeader->AceType = ACCESS_DENIED_ACE_TYPE ;

        /* Rather then do a switch on each ACE type when we know they all look
         * the same, we will make sure all of the fields resolve to the same
         * address and just query off of one ACE type.
         */
        UIASSERT(  (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->SidStart) ==
                    ((void*)&((ACCESS_DENIED_ACE*)QueryACE())->SidStart)    ) &&
                    (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->SidStart) ==
                    ((void*)&((SYSTEM_AUDIT_ACE*)QueryACE())->SidStart)    )  &&
                    (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->SidStart) ==
                    ((void*)&((SYSTEM_ALARM_ACE*)QueryACE())->SidStart)      )) ;

        /* Initialize SID portion of this ACE
         */
        OS_SID::InitializeMemory( (void *) QuerySIDMemory() ) ;
    }

    if ( !IsKnownACE() )
    {
        DBGEOL(SZ("OS_ACE::ct - Attempted to add an unkown ACE type")) ;
        ReportError( ERROR_INVALID_PARAMETER ) ;
        return ;
    }

    _possid = new OS_SID( (PSID) QuerySIDMemory() ) ;
    if ( err = ( _possid==NULL ? ERROR_NOT_ENOUGH_MEMORY : _possid->QueryError()))
    {
        ReportError( err ) ;
        return ;
    }

    /* Rather then do a switch on each ACE type when we know they all look
     * the same, we will make sure all of the fields resolve to the same
     * address and just query off of one ACE type.
     */
     UIASSERT(  (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->Mask) ==
                 ((void*)&((ACCESS_DENIED_ACE*)QueryACE())->Mask)     ) &&
                (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->Mask) ==
                 ((void*)&((SYSTEM_AUDIT_ACE*)QueryACE())->Mask)      )  &&
                (((void*)&((ACCESS_ALLOWED_ACE*)QueryACE())->Mask) ==
                 ((void*)&((SYSTEM_ALARM_ACE*)QueryACE())->Mask)      )) ;

    UIASSERT( _possid->IsValid() ) ;
}

OS_ACE::~OS_ACE()
{
    delete _possid ;
    _possid = NULL ;
    _pACEHeader = NULL ;
}

/*******************************************************************

    NAME:       OS_ACE::QueryAccessMask

    SYNOPSIS:   Gets the access mask of this ACE

    ENTRY:

    EXIT:

    RETURNS:    Returns the ACCESS_MASK bitfield of this ACE

    NOTES:

    HISTORY:
        Johnl   14-Dec-1991     Created

********************************************************************/

ACCESS_MASK OS_ACE::QueryAccessMask( void ) const
{
    UIASSERT( IsKnownACE() ) ;

    return ((ACCESS_ALLOWED_ACE*)QueryACE())->Mask ;
}


/*******************************************************************

    NAME:       OS_ACE::QuerySID

    SYNOPSIS:   Retrieves a pointer to the OS_SID of this ACE

    ENTRY:      ppossid - Pointer that will receive the pointer to the
                OS_SID

    EXIT:       ppossid will contain the pointer to this ACE's OS_SID

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   16-Dec-1991     Created

********************************************************************/

APIERR OS_ACE::QuerySID( OS_SID * * ppossid ) const
{
    if ( !IsKnownACE() )
    {
        UIASSERT(!SZ("QuerySID on unknown ACE")) ;
        return ERROR_INVALID_PARAMETER ;
    }

    *ppossid = _possid ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACE::QuerySIDMemory

    SYNOPSIS:


    EXIT:

    RETURNS:    Returns a pointer to the memory in this ACE that the
                SID resides

    NOTES:

    HISTORY:
        Johnl   13-Dec-1991     Created

********************************************************************/

void * OS_ACE::QuerySIDMemory( void ) const
{
    UIASSERT( IsKnownACE() ) ;

    return &((ACCESS_ALLOWED_ACE*)QueryACE())->SidStart ;
}

/*******************************************************************

    NAME:       OS_ACE::QueryRevision

    SYNOPSIS:   Returns the revision level of the ACEs supported by this
                class

    EXIT:

    RETURNS:    The current revision list

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

ULONG OS_ACE::QueryRevision()
{
    return ACL_REVISION2 ;
}

/*******************************************************************

    NAME:       OS_ACE::SetAccessMask

    SYNOPSIS:   Sets the access permission mask for this ACE

    ENTRY:      accmask - New value of the permission mask for this ACE

    RETURNS:

    NOTES:      This method can only be used on known ace types

    HISTORY:
        Johnl   16-Dec-1991     Created

********************************************************************/

void OS_ACE::SetAccessMask( ACCESS_MASK accmask )
{
    if ( !IsKnownACE() )
    {
        UIASSERT( FALSE ) ;
        return ;
    }

    ((ACCESS_ALLOWED_ACE*)QueryACE())->Mask = accmask ;
}

/*******************************************************************

    NAME:       OS_ACE::SetSize

    SYNOPSIS:   Sets the size field on this ACE and resizes the memory
                block if necessary.

    ENTRY:      cbSize - New size of this ACE to set

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   16-Dec-1991     Created

********************************************************************/

APIERR OS_ACE::SetSize( UINT cbSize )
{
    UIASSERT( IsKnownACE() ) ;
    UIASSERT( IsOwnerAlloc() ||
              (!IsOwnerAlloc() && QuerySize() <= QueryAllocSize())) ;

    if ( IsOwnerAlloc() )
    {
        if ( cbSize > QuerySize() )
        {
            DBGEOL(SZ("OS_ACE::SetSize - not enough room in buffer for requested size")) ;
            return ERROR_INSUFFICIENT_BUFFER ;
        }
    }
    else if ( QueryAllocSize() < cbSize )
    {
        APIERR err = Resize( cbSize ) ;
        if ( err != NERR_Success )
            return err ;

        /* The memory block's contents will be preserved across the Resize
         * call, so just watch out for a new pointer.
         */
        if ( err = SetPtr( (PACE_HEADER) QueryPtr() ))
        {
            return err ;
        }
    }

    _pACEHeader->AceSize = (USHORT)cbSize ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACE::SetSID

    SYNOPSIS:   Sets the SID of this ACE

    ENTRY:      ossid - SID to copy to this ACE

    EXIT:       NERR_Success if successful, error code otherwise

    RETURNS:

    NOTES:      If there isn't enough room to fit the SID in this ACE and
                the ACE is owner alloced, then ERROR_INSUFFICIENT_BUFFER
                will be returned.

    HISTORY:
        Johnl   10-Jan-1992     Created

********************************************************************/

APIERR OS_ACE::SetSID( const OS_SID & ossid )
{
    UIASSERT( IsKnownACE() ) ;
    UIASSERT( IsOwnerAlloc() ||
              (!IsOwnerAlloc() && QuerySize() <= QueryAllocSize())) ;

    /* Figure the total memory we have to work with to see if we can shoehorn
     * the SID into the ACE.
     */
    ULONG cbSizeOfConstantPortion = (ULONG)((BYTE *)QuerySIDMemory() - (BYTE *)QueryPtr()) ;
    ULONG cbMemoryFreeForSID = (ULONG) QuerySize() - cbSizeOfConstantPortion ;


    if ( ossid.QueryLength() > cbMemoryFreeForSID )
    {
        if ( IsOwnerAlloc() )
        {
            return ERROR_INSUFFICIENT_BUFFER ;
        }
        else
        {
            APIERR err = SetSize( (UINT) (cbSizeOfConstantPortion + ossid.QueryLength()) ) ;
            if ( err != NERR_Success )
                return err ;
        }
    }

    ::memcpyf( QuerySIDMemory(), (PSID) ossid, (UINT) ossid.QueryLength() ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACE::SetPtr

    SYNOPSIS:   Points this OS_ACE at a new ACE

    ENTRY:      pace - Memory to use as new ACE

    EXIT:       *this will now operate on the ace pointed at by pace

    RETURNS:    NERR_Success if everything is valid, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/
APIERR OS_ACE::SetPtr( void * pace )
{
    _pACEHeader = (PACE_HEADER) pace ;

    APIERR err = _possid->SetPtr( QuerySIDMemory() ) ;

    return err ;
}

/*******************************************************************

    NAME:       OS_ACE::_DbgPrint

    SYNOPSIS:   Takes apart this ACE and outputs it to cdebug

    ENTRY:

    NOTES:

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

void OS_ACE::_DbgPrint( void ) const
{
#if defined(DEBUG)

    APIERR err ;
    cdebug << SZ("\tIsOwnerAlloc      = ") << (IsOwnerAlloc() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tQuerySize         = ") << QuerySize() << dbgEOL ;
    cdebug << SZ("\tIsKnownACE        = ") << (IsKnownACE()  ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tQueryAceFlags     = ") << (HEX_STR)((ULONG) QueryAceFlags()) << dbgEOL ;
    cdebug << SZ("\t\tIsInherittedByNewObjects    = ") << (IsInherittedByNewObjects() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\t\tIsInherittedByNewContainers = ") << (IsInherittedByNewContainers() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\t\tIsInheritancePropagated     = ") << (IsInheritancePropagated() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\t\tIsInheritOnly               = ") << (IsInheritOnly() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;

    cdebug << SZ("\tAceType           = ") << (UINT) QueryType() << SZ("  ");
    switch ( QueryType() )
    {
    case ACCESS_ALLOWED_ACE_TYPE:
        cdebug << SZ("(ACCESS_ALLOWED_ACE_TYPE)") ;
        break ;

    case ACCESS_DENIED_ACE_TYPE:
        cdebug << SZ("(ACCESS_DENIED_ACE_TYPE)") ;
        break ;

    case SYSTEM_AUDIT_ACE_TYPE:
        cdebug << SZ("(SYSTEM_AUDIT_ACE_TYPE)") ;
        break ;

    case SYSTEM_ALARM_ACE_TYPE:
        cdebug << SZ("(SYSTEM_ALARM_ACE_TYPE)") ;
        break ;

    default:
        cdebug << SZ("(Unknown Ace Type)") ;
        return ;
    }
    cdebug << dbgEOL ;

    cdebug << SZ("\tQueryAccessMask   = ") << (HEX_STR)((ULONG)QueryAccessMask()) << dbgEOL ;

    OS_SID * possid ;
    err = QuerySID( &possid ) ;
    if ( err )
        cdebug << SZ("\tError retrieving SID, error code ") << err << dbgEOL ;
    else
    {
        cdebug << SZ("\tSID for this ACE:") << dbgEOL ;
        possid->_DbgPrint() ;
    }
#endif  // DEBUG
}

/*******************************************************************

    NAME:       OS_ACL::OS_ACL

    SYNOPSIS:   Standard constructor/destructor for the OS_ACL class

    ENTRY:      pACL - Pointer to valid ACL or NULL.  If NULL, then we
                allocate memory locally, else we assume the pointer
                points to a valid ACL.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

OS_ACL::OS_ACL( PACL pACL,
                BOOL fCopy,
                OS_SECURITY_DESCRIPTOR * pOwner )
    : OS_OBJECT_WITH_DATA( (UINT)(pACL == NULL ? STANDARD_ACL_SIZE : 0 )),
      _pACL( NULL ),
      _pOwner( pOwner )
{
    if ( QueryError() )
        return ;

    APIERR err ;
    if ( fCopy && pACL != NULL )
    {
        ACL_SIZE_INFORMATION aclsizeinfo ;
        if ( !::GetAclInformation( pACL,
                                   &aclsizeinfo,
                                   sizeof( ACL_SIZE_INFORMATION ),
                                   AclSizeInformation ))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }

        if ( err = Resize( aclsizeinfo.AclBytesInUse ) )
        {
            ReportError( err ) ;
            return ;
        }
        ::memcpy( QueryPtr(), pACL, aclsizeinfo.AclBytesInUse ) ;
    }

    _pACL = (PACL) (pACL == NULL || fCopy ? QueryPtr() : pACL )  ;
    UIASSERT( (pACL == NULL ) || ::IsValidAcl( _pACL ) ) ;

    if ( pACL == NULL )
    {
        /* Initialize the whole chunk of memory to zeros
         */
        if ( !::InitializeAcl( _pACL, QueryAllocSize(), ACL_REVISION2 ) )
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }
        UIASSERT( IsValid() ) ;
    }
}

OS_ACL::~OS_ACL()
{
    _pACL = NULL ;
}

/*******************************************************************

    NAME:       OS_ACL::IsValid

    SYNOPSIS:   Checks the validity of the ACL contained in this OS_ACL

    RETURNS:    TRUE if the ACL is valid, FALSE otherwise.

    NOTES:      If FALSE is returned, GetLastError can be used to get a
                more specific error code, however I do not know how
                useful this would be.

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

BOOL OS_ACL::IsValid( void ) const
{
    return (QueryError() == NERR_Success) || ::IsValidAcl( _pACL ) ;
}

/*******************************************************************

    NAME:       OS_ACL::QuerySizeInformation

    SYNOPSIS:   Retrieves the ACL_SIZE_INFORMATION structure about this ACL

    ENTRY:      paclsizeinfo - pointer to ACL_SIZE_INFORMATION that will
                    receive the data.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::QuerySizeInformation( ACL_SIZE_INFORMATION * paclsizeinfo ) const
{
    if ( !::GetAclInformation( _pACL, paclsizeinfo,
                       sizeof( ACL_SIZE_INFORMATION ), AclSizeInformation ) )
    {
        return ::GetLastError() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::QueryBytesInUse

    SYNOPSIS:   Determines how much storage (in bytes) this ACL needs
                based on its current size.  This is different from
                the Allocated memory size (QueryAllocSize).

    ENTRY:      pcbBytesInUse - Pointer to item that will receive the
                    number of bytes used by this ACL

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::QueryBytesInUse( PULONG pcbBytesInUse ) const
{
    ACL_SIZE_INFORMATION aclsizeinfo ;

    APIERR err ;
    if ( err = QuerySizeInformation( &aclsizeinfo ) )
        return err ;

    *pcbBytesInUse = aclsizeinfo.AclBytesInUse ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::QueryACECount

    SYNOPSIS:   Retrieves the count of ACEs in this ACL

    ENTRY:      pcAces - Pointer to variable that will receive the count of ACEs

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created
********************************************************************/

APIERR OS_ACL::QueryACECount( PULONG pcAces ) const
{
    ACL_SIZE_INFORMATION aclsizeinfo ;

    APIERR err ;
    if ( err = QuerySizeInformation( &aclsizeinfo ) )
        return err ;

    *pcAces = aclsizeinfo.AceCount ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::AddACE

    SYNOPSIS:   Adds an ACE to this ACL

    ENTRY:      iAce - Index of ACE to add, MAXULONG to append the ace
                osace - ACE to add to this ACL

    EXIT:       The ACE will be inserted at position iAce into this ACL

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The ACE is *copied* into this ACL.  Note that you should avoid
                doing a QueryACE (which references the real ACL) then an AddACE,
                as you will have duplicate ACEs in this ACL.

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::AddACE( ULONG iAce, const OS_ACE & osace )
{
    APIERR err ;

    /* Check if enough size to fit ACE, resize if necessary
     */
    ACL_SIZE_INFORMATION aclsizeinfo ;
    if ( err = QuerySizeInformation( &aclsizeinfo ) )
        return err ;

    if ( err = SetSize( (UINT) (aclsizeinfo.AclBytesInUse + osace.QuerySize())) )
        return err ;

    if ( !::AddAce( _pACL, OS_ACE::QueryRevision(),
                  iAce, osace.QueryACE(), osace.QuerySize() ))
    {
        return ::GetLastError() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::QueryACE

    SYNOPSIS:   Retrieves the ace at index iAce

    ENTRY:      iAce - Index of ACE to retrieve
                posace - Pointer to OS_ACE that will receive the reference
                    to the requested ACE.

    EXIT:       *posace will *reference* the requested ACE.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The ACE is not copied, it directly references the ACE that
                is in the ACL.  Thus resizing it is problematical.

                It is not recommended you keep OS_ACEs around for any
                length of time when they directly reference an ACL
                (as is the case after using QueryAce).

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::QueryACE( ULONG iAce, OS_ACE * posace ) const
{
    void * pAce ;
    if ( !::GetAce( _pACL, iAce, &pAce ) )
        return ::GetLastError() ;

    return posace->SetPtr( pAce ) ;
}

/*******************************************************************

    NAME:       OS_ACL::DeleteACE

    SYNOPSIS:   Deletes an ACE from this ACL

    ENTRY:      iAce - Index of ACE to delete

    EXIT:       The ace at iAce will have been deleted and the rest of
                ACEs will have been moved to replace it

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::DeleteACE( ULONG iAce )
{
    if ( !::DeleteAce( _pACL, iAce ))
        return ::GetLastError() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::FindACE

    SYNOPSIS:   Searchs this ACL for an ACE whose SID is equal to ossidKey

    ENTRY:      ossidKey - OS_SID to search this ACL for
                pfFound - Set to TRUE if we found an ACE that contains
                    the key value, FALSE otherwise.  If the ACE is not
                    found, then the rest of the parameters should be ignored.
                posace - pointer to an OS_ACE that will receive the OS_ACE
                    if one is found.
                piAce - The index of where the ACE was found in this ACL
                iStart - Optional start searching position.  Defaults to
                    starting at the beginning of the ACL.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise.  If an
                error code is returned, then the parameters will not
                contain valid values.

    NOTES:

    HISTORY:
        Johnl   27-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::FindACE( const OS_SID & ossidKey,
                        BOOL         * pfFound,
                        OS_ACE       * posace,
                        PULONG         piAce,
                        ULONG          iStart ) const
{
    UIASSERT( ossidKey.IsValid() ) ;
    *pfFound = FALSE ;

    APIERR err ;
    ULONG cTotalAces ;
    if ( err = QueryACECount( &cTotalAces ) )
        return err ;

    if ( iStart >= cTotalAces )
    {
        UIASSERT(!SZ("Search start index greater then total number of ACEs!!")) ;
        return ERROR_INVALID_PARAMETER ;
    }

    for ( ; iStart < cTotalAces ; iStart++ )
    {
        OS_SID * possidTarget ;

        if ( (err = QueryACE( iStart, posace )) ||
             (err = posace->QuerySID( &possidTarget )) )
        {
            return err ;
        }

        if ( *possidTarget == ossidKey )
        {
            *pfFound = TRUE ;
            *piAce   = iStart ;
            return NERR_Success ;
        }
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::SetSize

    SYNOPSIS:   Resizes this ACL and sets the ACL's header information to
                reflect the change.

    ENTRY:      cbNewACLSize - New desired size of this ACL

    EXIT:       The ACL will be resized as requested

    RETURNS:    NERR_Success if successful, error code otherwise.
                ERROR_INSUFFICIENT_BUFFER will be returned if this is an
                owner alloced ACL and we've ran out of room OR the ACL has
                run out of space all together.

    NOTES:      We directly access the ACL header which may not be the
                safest way to do things, but it is the only way currently.

                The size info in the ACL header is the total allocated size,
                thus we don't change this information unless we actually
                resize the buffer.
    HISTORY:
        Johnl   26-Dec-1991     Created
        Johnl   22-Apr-1993     Check for exceeding an ACL's max size

********************************************************************/

APIERR OS_ACL::SetSize( UINT cbNewACLSize, BOOL fForceToNonOwnerAlloced  )
{
    ACL_SIZE_INFORMATION aclsizeinfo ;
    APIERR err = QuerySizeInformation( &aclsizeinfo ) ;
    UIASSERT( sizeof( _pACL->AclSize ) == sizeof( USHORT ) ) ;

    if ( err )
        return err ;

    if ( cbNewACLSize > QueryAllocSize() )
    {
        //
        //  An ACL's maximum size is 65k bytes, make sure we haven't exceeded
        //  that limit
        //
        if ( (!fForceToNonOwnerAlloced && IsOwnerAlloc()) ||
             ( cbNewACLSize >= 0xffff ) )
        {
            return ERROR_INSUFFICIENT_BUFFER ;
        }

        if ( err = Resize( cbNewACLSize ) )
            return err ;

        /* The memory block contents are preserved across the Resize
         * call, watch for pointer shift though.
         */
        _pACL = (PACL) QueryPtr() ;
        _pACL->AclSize = (USHORT) cbNewACLSize ;

        /* If this ACL is part of a security descriptor, update our
         * security descriptor with our new memory location.
         */
        if ( _pOwner != NULL )
        {
            if ( err = _pOwner->UpdateReferencedSecurityObject( this ))
            {
                return err ;
            }
        }

    }

    UIASSERT( IsValid() ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::Copy

    SYNOPSIS:   Copies osaclSrc to *this

    ENTRY:      osaclSrc - ACL to copy
                fForceToNonOwnerAlloced - Set to TRUE if you want this object
                    to own (and thus be able to reallocate as needed) the
                    memory for the copy of the passed ACL.  Set to FALSE
                    if using the original buffer (whether owner alloced
                    or not) is preferred.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise.  If this
                is an owner alloced ACL and fForceToNonOwnerAlloced is FALSE
                and there isn't enough room, then
                ERROR_INSUFFICIENT_BUFFER will be returned.

    NOTES:      An ACL is self contained, thus it doesn't contain pointers
                which would cause problems in the memcpyf we use to
                do the copy.

    HISTORY:
        Johnl   26-Dec-1991     Created

********************************************************************/

APIERR OS_ACL::Copy( const OS_ACL & osaclSrc, BOOL fForceToNonOwnerAlloced )
{
    UIASSERT( osaclSrc.IsValid() ) ;

    ULONG cbAclSrcSize ;
    ULONG cbDestBuffSize = 0 ;
    APIERR err ;

    if ( (err = osaclSrc.QueryBytesInUse( &cbAclSrcSize )) ||
         (err = SetSize( (UINT) cbAclSrcSize, fForceToNonOwnerAlloced ))       )
    {
        return err ;
    }

    ::memcpyf( (PACL) *this, (PACL) osaclSrc, (UINT) cbAclSrcSize ) ;

    if ( !IsOwnerAlloc() )
        _pACL->AclSize = (USHORT)QueryAllocSize() ;

    UIASSERT( IsValid() ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL::_DbgPrint

    SYNOPSIS:   Takes apart this ACL and outputs it to cdebug

    ENTRY:

    NOTES:

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

void OS_ACL::_DbgPrint( void ) const
{
#if defined(DEBUG)
    APIERR err ;
    ACL_SIZE_INFORMATION aclsizeinfo ;

    cdebug << SZ("\tIsOwnerAlloc      = ") << (IsOwnerAlloc() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tIsValid           = ") << (IsValid() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tAddress of _pACL  = ") << (HEX_STR)(PtrToUlong(_pACL)) ;

    if ( err = QuerySizeInformation( &aclsizeinfo ))
    {
        cdebug << SZ("\tQuerySizeInformation returned error code ") << err << dbgEOL ;
        return ;
    }
    else
    {
        cdebug << SZ("\tAceCount          = ") << aclsizeinfo.AceCount << dbgEOL ;
        cdebug << SZ("\tAclBytesInUse     = ") << aclsizeinfo.AclBytesInUse << dbgEOL ;
        cdebug << SZ("\tAclBytesFree      = ") << aclsizeinfo.AclBytesFree << dbgEOL ;
    }

    OS_ACE osace ;
    if ( osace.QueryError() )
    {
        cdebug << SZ("OS_ACE Failed to construct, error code ") << osace.QueryError() << dbgEOL ;
        return ;
    }

    for ( ULONG iAce = 0 ; iAce < aclsizeinfo.AceCount ; iAce++ )
    {
        if ( err = QueryACE( iAce, &osace ))
        {
            cdebug << SZ("QueryACE failed with error code ") << (ULONG) err << dbgEOL ;
            return ;
        }

        cdebug << SZ("\t==================================================") << dbgEOL ;
        cdebug << SZ("\tAce # ") << iAce << dbgEOL ;
        osace._DbgPrint() ;
    }
#endif  // DEBUG
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::OS_SECURITY_DESCRIPTOR

    SYNOPSIS:   Standard constructor/destructor for this class

    ENTRY:      psecuritydesc - Pointer to valid security descriptor else
                    NULL if we are creating a new one.

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

OS_SECURITY_DESCRIPTOR::OS_SECURITY_DESCRIPTOR( PSECURITY_DESCRIPTOR psecuritydesc,
                                                BOOL fCopy )
    : OS_OBJECT_WITH_DATA( psecuritydesc==NULL || fCopy ?
                                                 sizeof(SECURITY_DESCRIPTOR)
                                                 : 0 ),
      _psecuritydesc   ( NULL ),

      _secdesccont     ( 0 ),
      _osSecDescControl( &_secdesccont ),
      _posaclDACL      ( NULL ),
      _posaclSACL      ( NULL ),
      _possidOwner     ( NULL ),
      _possidGroup     ( NULL )
{
    if ( QueryError() )
        return ;

    //
    //  If fCopy is TRUE, then we will set _psecuritydesc to our memory and
    //  use the flags from the psecdesc parameter, copying each of the
    //  items from psecdesc to _psecuritydesc.  If psecdesc is NULL then
    //  _psecuritydesc == psecuritydesc (i.e., empty security descriptor).
    //
    //  If fCopy is FALSE, then _psecuritydesc == psecuritydesc
    //
    _psecuritydesc = fCopy || psecuritydesc == NULL ?
                           (PSECURITY_DESCRIPTOR) QueryPtr() : psecuritydesc ;

    if ( fCopy || psecuritydesc == NULL )
    {
        if ( psecuritydesc == NULL )
            psecuritydesc = (PSECURITY_DESCRIPTOR) QueryPtr() ;

        if ( !::InitializeSecurityDescriptor( _psecuritydesc,
                                              SECURITY_DESCRIPTOR_REVISION1 ) )
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }
    }
    else
    {
        psecuritydesc = _psecuritydesc ;
    }

    ULONG ulRevision ;
    SECURITY_DESCRIPTOR_CONTROL secdesccont ;
    if ( !::GetSecurityDescriptorControl( psecuritydesc,
                                          &secdesccont,
                                          &ulRevision     ))
    {
        ReportError( ::GetLastError() ) ;
        return ;
    }

    APIERR err ;
    /* Now we need to create each of the OS_* members iff the corresponding
     * item exists in this security descriptor.
     */

    if ( secdesccont & SE_DACL_PRESENT )
    {
        BOOL fDACLPresent, fDACLDefaulted ;
        PACL pDACL ;
        if ( !::GetSecurityDescriptorDacl( psecuritydesc,
                                           &fDACLPresent,
                                           &pDACL,
                                           &fDACLDefaulted))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }
        UIASSERT( fDACLPresent ) ;

        /* A NULL DACL means World gets Full access
         */
        if ( pDACL != NULL )
        {
            _posaclDACL = new OS_ACL( pDACL, fCopy, this ) ;
            if ( _posaclDACL == NULL )
            {
                ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
                return ;
            }
            else if ( _posaclDACL->QueryError() )
            {
                ReportError( _posaclDACL->QueryError() ) ;
                return ;
            }
            UIASSERT( _posaclDACL->IsValid()) ;
        }

        if ( fCopy )
        {
            if ( !::SetSecurityDescriptorDacl( _psecuritydesc,
                                               fDACLPresent,
                                               _posaclDACL == NULL ? NULL :
                                                         (PACL)*_posaclDACL,
                                               fDACLDefaulted ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }

    }

    if ( secdesccont & SE_SACL_PRESENT  )
    {
        BOOL fSACLPresent, fSACLDefaulted ;
        PACL pSACL ;
        if ( !::GetSecurityDescriptorSacl( psecuritydesc,
                                           &fSACLPresent,
                                           &pSACL,
                                           &fSACLDefaulted))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }
        UIASSERT( fSACLPresent ) ;

        /* Note that pSACL maybe NULL
         */
        _posaclSACL = new OS_ACL( pSACL, fCopy, this ) ;
        if ( _posaclSACL == NULL )
        {
            ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
            return ;
        }
        else if ( _posaclSACL->QueryError() )
        {
            ReportError( _posaclSACL->QueryError() ) ;
            return ;
        }
        UIASSERT( _posaclSACL->IsValid()) ;

        if ( fCopy )
        {
            if ( !::SetSecurityDescriptorSacl( _psecuritydesc,
                                               fSACLPresent,
                                               _posaclSACL == NULL ? NULL :
                                                         (PACL)*_posaclSACL,
                                               fSACLDefaulted ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }

    }

    /* Get the Owner.  Note that if the Owner isn't present *yet*, then
     * psidOwner can come back NULL.
     */
    {
        BOOL fOwnerDefaulted ;
        PSID psidOwner ;
        if ( !::GetSecurityDescriptorOwner( psecuritydesc,
                                            &psidOwner,
                                            &fOwnerDefaulted))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }

        if ( psidOwner != NULL )
        {
            _possidOwner = new OS_SID( psidOwner, fCopy, this ) ;
            if ( _possidOwner == NULL )
            {
                ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
                return ;
            }
            else if ( _possidOwner->QueryError() )
            {
                ReportError( _possidOwner->QueryError() ) ;
                return ;
            }
        }

        if ( fCopy )
        {
            if ( !::SetSecurityDescriptorOwner(  _psecuritydesc,
                                                 psidOwner ?
                                                      _possidOwner->QueryPSID() :
                                                      NULL,
                                                 fOwnerDefaulted ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }
    }

    /* Get the group.  Note that if the group isn't present *yet*, then
     * psidGroup can come back NULL.
     */
    {
        BOOL fGroupDefaulted ;
        PSID psidGroup ;
        if ( !::GetSecurityDescriptorGroup( psecuritydesc,
                                            &psidGroup,
                                            &fGroupDefaulted))
        {
            ReportError( ::GetLastError() ) ;
            return ;
        }

        if ( psidGroup != NULL )
        {
            _possidGroup = new OS_SID( psidGroup, fCopy, this ) ;
            if ( _possidGroup == NULL )
            {
                ReportError( ERROR_NOT_ENOUGH_MEMORY ) ;
                return ;
            }
            else if ( _possidGroup->QueryError() )
            {
                ReportError( _possidGroup->QueryError() ) ;
                return ;
            }
        }

        if ( fCopy )
        {
            if ( !::SetSecurityDescriptorGroup(  _psecuritydesc,
                                                 psidGroup ?
                                                      _possidGroup->QueryPSID() :
                                                      NULL,
                                                 fGroupDefaulted ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }
    }

    //
    //  Finally, update the control field to reflect the items we have
    //  set in the security descriptor
    //
    if ( err = UpdateControl() )
    {
        ReportError( err ) ;
        return ;
    }

    UIASSERT( IsValid() ) ;
}

OS_SECURITY_DESCRIPTOR::~OS_SECURITY_DESCRIPTOR()
{
    delete _posaclDACL ;
    delete _posaclSACL ;
    delete _possidOwner ;
    delete _possidGroup ;
    _posaclDACL  = NULL ;
    _posaclSACL  = NULL ;
    _possidOwner = NULL ;
    _possidGroup = NULL ;

    _secdesccont = 0 ;
    _psecuritydesc = NULL ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::UpdateControl

    SYNOPSIS:   Forces an update of our private SECURITY_DESCRIPTOR_CONTROL.
                Call after changes to the security descriptor.

    ENTRY:

    EXIT:       _secdesccont will be updated to reflect the current state
                of the security descriptor.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::UpdateControl( void )
{
    ULONG ulRevision ;
    if ( !::GetSecurityDescriptorControl( _psecuritydesc,
                                          &_secdesccont,
                                          &ulRevision     ))
    {
        return ::GetLastError() ;
    }

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::QueryDACL

    SYNOPSIS:   Retrieves the DACL for this security descriptor

    ENTRY:      pfDACLPresent - If set to FALSE, then the DACL isn't present
                    and the rest of the parameters should be ignored.
                ppOSACL - Pointer to pointer to receive the OS_ACL that
                    represents the DACL.  THIS MAYBE NULL!
                pfDACLDefaulted - Set to TRUE if the ACL was assigned using
                    some default ACL (OPTIONAL)

    EXIT:       The parameters will be set as above

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::QueryDACL( PBOOL      pfDACLPresent,
                                          OS_ACL * * ppOSACL,
                                          PBOOL      pfDACLDefaulted
                                        ) const
{
    *pfDACLPresent = _osSecDescControl.IsDACLPresent() ;
    if ( pfDACLDefaulted != NULL )
        *pfDACLDefaulted = _osSecDescControl.IsDACLDefaulted() ;

    *ppOSACL = _posaclDACL ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::QuerySACL

    SYNOPSIS:   Retrieves the SACL for this security descriptor

    ENTRY:      pfSACLPresent - If set to FALSE, then the SACL isn't present
                    and the rest of the parameters should be ignored.
                ppOSACL - Pointer to pointer to receive the OS_ACL that
                    represents the SACL
                pfSACLDefaulted - Set to TRUE if the ACL was assigned using
                    some default ACL (OPTIONAL)

    EXIT:       The parameters will be set as above

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::QuerySACL( PBOOL      pfSACLPresent,
                                          OS_ACL * * ppOSACL,
                                          PBOOL      pfSACLDefaulted
                                        ) const
{
    *pfSACLPresent = _osSecDescControl.IsSACLPresent() ;
    if ( pfSACLDefaulted != NULL )
        *pfSACLDefaulted = _osSecDescControl.IsSACLDefaulted() ;

    *ppOSACL = _posaclSACL ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::QueryGroup

    SYNOPSIS:   Retrieves the Group SID for this security descriptor

    ENTRY:      pfGroupPresent - If set to FALSE, then the Group isn't present
                    and the rest of the parameters should be ignored.
                ppOSACL - Pointer to pointer to receive the OS_SID that
                    represents the Group
                pfGroupDefaulted - Set to TRUE if the group was assigned using
                    some default group (OPTIONAL)

    EXIT:       The parameters will be set as above

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::QueryGroup( PBOOL      pfContainsGroup,
                                           OS_SID * * ppOSSID,
                                           PBOOL      pfGroupDefaulted
                                         ) const
{
    if ( pfGroupDefaulted != NULL )
        *pfGroupDefaulted = _osSecDescControl.IsGroupDefaulted() ;
    *ppOSSID = _possidGroup ;
    *pfContainsGroup = (_possidGroup != NULL) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::QueryOwner

    SYNOPSIS:   Retrieves the Owner SID for this security descriptor

    ENTRY:      pfOwnerPresent - If set to FALSE, then the Owner isn't present
                    and the rest of the parameters should be ignored.
                ppOSACL - Pointer to pointer to receive the OS_SID that
                    represents the Owner
                pfOwnerDefaulted - Set to TRUE if the Owner was assigned using
                    some default Owner (OPTIONAL)

    EXIT:       The parameters will be set as above

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/
APIERR OS_SECURITY_DESCRIPTOR::QueryOwner( PBOOL      pfContainsOwner,
                                           OS_SID * * ppOSSID,
                                           PBOOL      pfOwnerDefaulted
                                         ) const
{
    if ( pfOwnerDefaulted != NULL )
        *pfOwnerDefaulted = _osSecDescControl.IsOwnerDefaulted() ;
    *ppOSSID = _possidOwner ;
    *pfContainsOwner = (_possidOwner != NULL) ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::UpdateReferencedSecurityObject

    SYNOPSIS:   This method finds which security object is requesting to
                be updated and updates this security descriptor's pointer
                to match the new security object.

    ENTRY:      posobj - Pointer to the os object (must be equal to _posaclDACL,
                    _posaclSACL, _possidOwner, _possidGroup).  Can't be NULL.

    EXIT:       This security descriptor's reference to the object will
                updated.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      Validation should not be performed on the passed security
                object because only the memory location has changed,
                the contents of the memory may not yet be valid.


    HISTORY:
        JohnL   26-Feb-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::UpdateReferencedSecurityObject(
                                            OS_OBJECT_WITH_DATA * posobj )
{
    APIERR err = NERR_Success ;
    UIASSERT( posobj != NULL ) ;

    if ( posobj == _posaclDACL )
    {
        if ( !::SetSecurityDescriptorDacl( _psecuritydesc,
                                           TRUE,
                                           (PACL)*_posaclDACL,
                                           FALSE ) )
        {
            err = ::GetLastError() ;
        }
    }
    else if ( posobj == _posaclSACL )
    {
        if ( !::SetSecurityDescriptorSacl( _psecuritydesc,
                                           TRUE,
                                           (PACL)*_posaclSACL,
                                           FALSE ) )
        {
            err = ::GetLastError() ;
        }
    }
    else if ( posobj == _possidOwner )
    {
        if ( !::SetSecurityDescriptorOwner( _psecuritydesc,
                                                     *_possidOwner,
                                                     FALSE ) )
        {
            err = ::GetLastError() ;
        }
    }
    else if ( posobj == _possidGroup )
    {
        if ( !::SetSecurityDescriptorGroup( _psecuritydesc,
                                                     *_possidGroup,
                                                     FALSE ) )
        {
            err = ::GetLastError() ;
        }

    }
    else
    {
        DBGEOL( SZ("OS_SECURITY_DESCRIPTOR::UpdateReferencedSecurityObject passed object that isn't in this security descriptor")) ;
        UIASSERT(FALSE) ;
        err = ERROR_INVALID_PARAMETER ;
    }

    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetDACL

    SYNOPSIS:   Sets the DACL on this security descriptor

    ENTRY:      fDACLPresent - Set to FALSE if you are removing the DACL
                    from this SECURITY_DESCRIPTOR.  The rest of the
                    parameters will be ignored.
                posacl - OS_ACL that we are setting.  This may be NULL.
                fDACLDefaulted - Set to TRUE to indicate the ACL was selected
                    throug some default mechanism

    EXIT:       The security descriptor will either use the new ACL or
                the current ACL will become unreferenced.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If setting the DACL, then the ACL contained in osacl is
                copied.

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetDACL( BOOL           fDACLPresent,
                                        const OS_ACL * posacl,
                                        BOOL           fDACLDefaulted
                                      )
{
    APIERR err = NERR_Success ;
    if ( fDACLPresent )
    {
        /* If the Security Descriptor didn't contain a DACL previously, then
         * we need to create a new one, otherwise just copy it.
         */
        if ( _posaclDACL == NULL && posacl != NULL )
        {
            if ( (_posaclDACL = new OS_ACL( posacl ? posacl->QueryAcl() : NULL,
                                            TRUE,
                                            this )) == NULL )
                return ERROR_NOT_ENOUGH_MEMORY ;
            else if ( _posaclDACL->QueryError() )
                return _posaclDACL->QueryError() ;

            UIASSERT( _posaclDACL->IsValid() ) ;
        }
        else if ( posacl == NULL )
        {
            //
            //  If we are setting a NULL DACL, then delete the OS_ACL wrapper
            //
            delete _posaclDACL ;
            _posaclDACL = NULL ;
        }
        else
        {
            if ( err = _posaclDACL->Copy( *posacl ) )
                return err ;

            UIASSERT( _posaclDACL->IsValid() ) ;
        }
    }

    /* The reason for the ternary operator is because _posaclDACL may or
     * may not be NULL, and we obviously do not want to dereference a
     * NULL pointer.  When _posaclDACL is not NULL, then the *_posaclDACL
     * will resolve to a PACL using the conversion operator.
     */
    if ( !::SetSecurityDescriptorDacl( _psecuritydesc,
                                       fDACLPresent,
                                       _posaclDACL == NULL ? NULL :
                                                 (PACL)*_posaclDACL,
                                       fDACLDefaulted ) )
    {
        return ::GetLastError() ;
    }

    if ( !fDACLPresent )
    {
        /* The DACL is being removed from this security descriptor, so free
         * up the potentially large chunk of memory in this OS_ACL.
         */
        delete _posaclDACL ;
        _posaclDACL = NULL ;
    }

    UIASSERT( IsValid() ) ;
    UIASSERT( (_posaclDACL == NULL) || (_posaclDACL->IsValid())) ;
    return UpdateControl() ;
}


/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetSACL

    SYNOPSIS:   Sets the SACL on this security descriptor

    ENTRY:      fSACLPresent - Set to FALSE if you are removing the SACL
                    from this SECURITY_DESCRIPTOR.  The rest of the
                    parameters will be ignored.
                posacl - OS_ACL that we are setting.
                fSACLDefaulted - Set to TRUE to indicate the ACL was selected
                    throug some default mechanism

    EXIT:       The security descriptor will either use the new ACL or
                the current ACL will become unreferenced.

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      If setting the SACL, then the ACL contained in osacl is
                copied.

    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetSACL( BOOL           fSACLPresent,
                                        const OS_ACL * posacl,
                                        BOOL           fSACLDefaulted
                                      )
{
    APIERR err = NERR_Success ;
    if ( fSACLPresent )
    {
        /* If the Security Descriptor didn't contain a SACL previously, then
         * we need to create a new one, otherwise just copy it.
         */
        if ( _posaclSACL == NULL && posacl != NULL )
        {
            if ( (_posaclSACL = new OS_ACL( posacl ? posacl->QueryAcl() : NULL,
                                            TRUE,
                                            this )) == NULL )
                return ERROR_NOT_ENOUGH_MEMORY ;
            else if ( _posaclSACL->QueryError() )
                return _posaclSACL->QueryError() ;

            UIASSERT( _posaclSACL->IsValid() ) ;
        }
        else if ( posacl == NULL )
        {
            //
            //  If we are setting a NULL SACL, then delete the OS_ACL wrapper
            //
            delete _posaclSACL ;
            _posaclSACL = NULL ;
        }
        else
        {
            if ( err = _posaclSACL->Copy( *posacl ) )
                return err ;

            UIASSERT( _posaclSACL->IsValid() ) ;
        }
    }

    /* The reason for the ternary operator is because _posaclSACL may or
     * may not be NULL, and we obviously do not want to dereference a
     * NULL pointer.  When _posaclSACL is not NULL, then the *_posaclSACL
     * will resolve to a PACL using the conversion operator.
     */
    if ( !::SetSecurityDescriptorSacl( _psecuritydesc,
                                       fSACLPresent,
                                       _posaclSACL == NULL ? NULL :
                                                   (PACL)*_posaclSACL,
                                       fSACLDefaulted ) )
    {
        return ::GetLastError() ;
    }

    if ( !fSACLPresent )
    {
        /* The SACL is being removed from this security descriptor, so free
         * up the potentially large chunk of memory in this OS_ACL.
         */
        delete _posaclSACL ;
        _posaclSACL = NULL ;
    }

    UIASSERT( IsValid() ) ;
    return  UpdateControl() ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetOwner

    SYNOPSIS:   Sets the Owner SID on this security descriptor

    ENTRY:      fOwnerPresent - If FALSE, then the SID is marked as not
                                present and the rest of the params are ignored
                possid - Owner SID we are setting for this security descriptor
                fOwnerDefaulted - Set to TRUE to indicate the SID was selected
                    throug some default mechanism

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The Owner SID is copied


    HISTORY:
        Johnl   13-Oct-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetOwner( BOOL           fOwnerPresent,
                                         const OS_SID * possid,
                                         BOOL           fOwnerDefaulted
                                       )
{
    UIASSERT( !fOwnerPresent || (possid != NULL && possid->IsValid()) ) ;

    //
    //  SetSecurityDescriptorOwner will fail with invalid security descriptor
    //  if this is a self relative security descriptor.
    //
    UIASSERT( !QueryControl()->IsSelfRelative() ) ;

    APIERR err = NERR_Success ;
    if ( fOwnerPresent )
    {
        /* If the Owner SID didn't contain a SID previously, then
         * we need to create a new one, otherwise just copy it.
         */
        if ( _possidOwner == NULL )
        {
            if ( (_possidOwner = new OS_SID( NULL, FALSE, this )) == NULL )
                return ERROR_NOT_ENOUGH_MEMORY ;
            else if ( _possidOwner->QueryError() )
                return _possidOwner->QueryError() ;
        }

        err = _possidOwner->Copy( *possid ) ;
        if ( err )
            return err ;
    }
    else
    {
        delete _possidOwner ;
        _possidOwner = NULL ;
        possid = NULL ;
    }

    if ( !::SetSecurityDescriptorOwner(  _psecuritydesc,
                                         fOwnerPresent ?
                                              _possidOwner->QueryPSID() :
                                              NULL,
                                         fOwnerDefaulted ) )
    {
        return ::GetLastError() ;
    }

    UIASSERT( IsValid() ) ;
    err = UpdateControl() ;
    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetGroup

    SYNOPSIS:   Sets the Group SID on this security descriptor

    ENTRY:      fGroupPresent - If FALSE, then the SID is marked as not
                                present and the rest of the params are ignored
                possid - Group SID we are setting for this security descriptor
                fGroupDefaulted - Set to TRUE to indicate the SID was selected
                    throug some default mechanism

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The Group SID is copied


    HISTORY:
        Johnl   13-Oct-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetGroup( BOOL           fGroupPresent,
                                         const OS_SID * possid,
                                         BOOL           fGroupDefaulted
                                       )
{
    UIASSERT( !fGroupPresent || (possid != NULL && possid->IsValid()) ) ;

    //
    //  SetSecurityDescriptorGroup will fail with invalid security descriptor
    //  if this is a self relative security descriptor.
    //
    UIASSERT( !QueryControl()->IsSelfRelative() ) ;

    APIERR err = NERR_Success ;
    if ( fGroupPresent )
    {
        /* If the Group SID didn't contain a SID previously, then
         * we need to create a new one, otherwise just copy it.
         */
        if ( _possidGroup == NULL )
        {
            if ( (_possidGroup = new OS_SID( NULL, FALSE, this )) == NULL )
                return ERROR_NOT_ENOUGH_MEMORY ;
            else if ( _possidGroup->QueryError() )
                return _possidGroup->QueryError() ;
        }

        err = _possidGroup->Copy( *possid ) ;
        if ( err )
            return err ;
    }
    else
    {
        delete _possidGroup ;
        _possidGroup = NULL ;
        possid = NULL ;
    }

    if ( !::SetSecurityDescriptorGroup(  _psecuritydesc,
                                         fGroupPresent ?
                                              _possidGroup->QueryPSID() :
                                              NULL,
                                         fGroupDefaulted ) )
    {
        return ::GetLastError() ;
    }

    UIASSERT( IsValid() ) ;
    err = UpdateControl() ;
    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetGroup

    SYNOPSIS:   Sets the Group SID on this security descriptor

    ENTRY:      ossid - Group SID we are setting for this security descriptor
                fGroupDefaulted - Set to TRUE to indicate the ACL was selected
                    throug some default mechanism

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The group SID is copied


    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetGroup( const OS_SID & ossid,
                                         BOOL  fGroupDefaulted
                                       )
{
    UIASSERT( ossid.IsValid() ) ;

    /* If the Group SID didn't contain a SID previously, then
     * we need to create a new one, otherwise just copy it.
     */
    if ( _possidGroup == NULL )
    {
        if ( (_possidGroup = new OS_SID( NULL, FALSE, this )) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( _possidGroup->QueryError() )
            return _possidGroup->QueryError() ;
    }

    APIERR err = _possidGroup->Copy( ossid ) ;
    if ( err )
        return err ;

    if ( !::SetSecurityDescriptorGroup( _psecuritydesc,
                                        *_possidGroup,
                                       fGroupDefaulted ) )
    {
        return ::GetLastError() ;
    }

    UIASSERT( IsValid() ) ;

    return UpdateControl() ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::SetOwner

    SYNOPSIS:   Sets the Owner SID on this security descriptor

    ENTRY:      ossid - OS_SID we are setting for the owner of this sec. desc.
                fOwnerDefaulted - Set to TRUE to indicate the ACL was selected
                    throug some default mechanism

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      The Owner SID is copied


    HISTORY:
        Johnl   18-Dec-1991     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::SetOwner( const OS_SID & ossid,
                                         BOOL  fOwnerDefaulted
                                       )
{
    UIASSERT( ossid.IsValid() ) ;

    /* If the Owner SID didn't contain a SID previously, then
     * we need to create a new one, otherwise just copy it.
     */
    if ( _possidOwner == NULL )
    {
        if ( (_possidOwner = new OS_SID( NULL, FALSE, this )) == NULL )
            return ERROR_NOT_ENOUGH_MEMORY ;
        else if ( _possidOwner->QueryError() )
            return _possidOwner->QueryError() ;
    }

    APIERR err = _possidOwner->Copy( ossid ) ;
    if ( err )
        return err ;

    if ( !::SetSecurityDescriptorOwner( _psecuritydesc,
                                        *_possidOwner,
                                       fOwnerDefaulted ) )
    {
        return ::GetLastError() ;
    }

    UIASSERT( IsValid() ) ;
    err = UpdateControl() ;
    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::Copy

    SYNOPSIS:   Copies the given security descriptor to this

    ENTRY:      ossecdescSrc - Security descriptor to copy

    EXIT:       This will be a replica of ossecdescSrc (with its own
                memory).

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   28-Aug-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::Copy( const OS_SECURITY_DESCRIPTOR & ossecdescSrc )
{
    APIERR err = NERR_Success ;
    UIASSERT( ossecdescSrc.IsValid() ) ;

    do { // error break out

        /*
         *  Copy the SACL and DACL
         */
        BOOL fSIDPresent, fACLPresent ;
        OS_ACL * pOsAcl ;
        OS_SID * pOsSid ;

        if ( (err = ossecdescSrc.QueryDACL(&fACLPresent, &pOsAcl)) ||
             (err = SetDACL(fACLPresent, pOsAcl) ))
        {
            break ;
        }

        if ( (err = ossecdescSrc.QuerySACL(&fACLPresent, &pOsAcl)) ||
             (err = SetSACL(fACLPresent, pOsAcl)))
        {
            break ;
        }

        /* Copy the Owner and Group
         */
        if ( (err = ossecdescSrc.QueryOwner(&fSIDPresent, &pOsSid)) ||
             (err = SetOwner(fSIDPresent, pOsSid)) )
        {
            break ;
        }
        
        if ( (err = ossecdescSrc.QueryGroup(&fSIDPresent, &pOsSid)) ||
             (err = SetGroup(fSIDPresent, pOsSid)))
        {
            break ;
        }
    } while (FALSE) ;

    return err ;
}

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::AccessCheck

    SYNOPSIS:   Determines if the current process can access the object this
                security descriptor is attached to with the passed access
                mask.

    ENTRY:      DesiredAccess - The desired access (should not have any
                    generic bits set)
                pGenericMapping - Generic mapping appropriate for the object
                pfAccessGranted - Will be set to TRUE if access is granted,
                    FALSE otherwise
                pGrantedAccess - Indicates which accesses were actually
                    granted (optional, can be NULL).

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      This method has to impersonate itself to call the AccessCheck
                API that was designed to be called only from Server
                Applications.

    HISTORY:
        Johnl   04-May-1992     Created

********************************************************************/

#if 0

//
//  Not used for anything.  Note that AccessChecks can only be done
//  with security descriptors from the local machine thus seriously limiting
//  the usefulness of this method.
//

APIERR OS_SECURITY_DESCRIPTOR::AccessCheck(
                    ACCESS_MASK       DesiredAccess,
                    PGENERIC_MAPPING  pGenericMapping,
                    BOOL            * pfAccessGranted,
                    PACCESS_MASK      pGrantedAccess )
{
    APIERR err = NERR_Success ;
    BOOL fImpersonated = FALSE ;    // Set if we have to revert to self
    HANDLE hToken1, hToken2;


    do { // Error breakout

        DWORD dwTmpGrantedAccess ;
        BUFFER buffPrivilegeSet( 254 ) ;
        if ( err = buffPrivilegeSet.QueryError())
        {
            break ;
        }

        /* Get the thread token required by the AccessCheck API
         */
        OBJECT_ATTRIBUTES ObjectAttributes;
        SECURITY_QUALITY_OF_SERVICE Qos;
        InitializeObjectAttributes(&ObjectAttributes, NULL, 0, 0, NULL);

        Qos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        Qos.ImpersonationLevel = SecurityImpersonation ;
        Qos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        Qos.EffectiveOnly = FALSE;
        ObjectAttributes.SecurityQualityOfService = &Qos;

        /* Try impersonating our current thread token, if that fails, then
         * do it with our process token.
         */
        if ( (err = ERRMAP::MapNTStatus(::NtOpenThreadToken( NtCurrentThread(),
                                                              TOKEN_DUPLICATE,
                                                              FALSE,
                                                              &hToken1 ))))
        {
            if ( (err == ERROR_NO_TOKEN) &&
                !(err = ERRMAP::MapNTStatus(
                                 ::NtOpenProcessToken( NtCurrentProcess(),
                                                       TOKEN_DUPLICATE,
                                                       &hToken1 ))))
            {
                /* Openning the process token worked, so proceed
                 */
            }
            else
            {
                DBGEOL("OS_SECURITY_DESCRIPTOR::AccessCheck - Token  Open failed -  error "
                    << (ULONG) err ) ;
                break ;
            }
        }

        if ((err = ERRMAP::MapNTStatus(::NtDuplicateToken(
                                            hToken1,
                                            TOKEN_IMPERSONATE |
                                            TOKEN_QUERY |
                                            TOKEN_ADJUST_PRIVILEGES,
                                            &ObjectAttributes,
                                            FALSE,                 //EffectiveOnly
                                            TokenImpersonation,
                                            &hToken2
                                            ))))
        {
            DBGEOL("OS_SECURITY_DESCRIPTOR::AccessCheck - Token impersonation failed -  error "
                    << (ULONG) err ) ;
            break ;
        }
        fImpersonated = TRUE ;

        /* Loop until we get the buffer size right (should go through at
         * most twice because cbPrivilegeSetLength will be set to the
         * required buffer size).
         */
        BOOL fAccessStatus ;
        do {
            DWORD cbPrivilegeSetLength = buffPrivilegeSet.QuerySize() ;
            if ( !::AccessCheck( QueryDescriptor(),
                                 hToken2,
                                 (DWORD) DesiredAccess,
                                 pGenericMapping,
                                 (PPRIVILEGE_SET) buffPrivilegeSet.QueryPtr(),
                                 &cbPrivilegeSetLength,
                                 &dwTmpGrantedAccess,
                                 &fAccessStatus ))
            {
                if ( (err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER)
                {
                    err = buffPrivilegeSet.Resize( (UINT) cbPrivilegeSetLength) ;
                }
            }
        } while ( err == ERROR_INSUFFICIENT_BUFFER ) ;

        /* If an error occurred on the API or something else happenned
         * trying to do the access check, then bail out (in which case
         * fAccessStatus will be FALSE).
         */
        if ( err ||
            ( !fAccessStatus && (err = ::GetLastError()) &&
              err != ERROR_ACCESS_DENIED ))
        {
            DBGEOL("OS_SECURITY_DESCRIPTOR::AccessCheck - Returning error "
                    << (ULONG) err ) ;
            break ;
        }

        /* If the secondary status failed with an Access check, then the user
         * doesn't have the requested privilege on this security descriptor.
         */
        if ( err == ERROR_ACCESS_DENIED )
        {
            err = NERR_Success ;
            dwTmpGrantedAccess = 0 ;
        }

        *pfAccessGranted = (DesiredAccess ==
                                      (DesiredAccess & dwTmpGrantedAccess)) ;
        if ( pGrantedAccess != NULL )
        {
            *pGrantedAccess  = (ACCESS_MASK) dwTmpGrantedAccess ;
        }
    } while (FALSE) ;

    if ( fImpersonated )
    {
        /* We ignore any errors that occurr here
         */
        ::NtClose( hToken1 ) ;
        ::NtClose( hToken2 ) ;
        if ( !::RevertToSelf() )
        {
            DBGEOL("OS_SECURITY_DESCRIPTOR::AccessCheck - RevertToSelf failed with error code "
                    << (ULONG) ::GetLastError() ) ;
        }
    }

    return err ;
}
#endif // 0

/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::Compare

    SYNOPSIS:   Compares two security descriptors

    ENTRY:      possecdesc - Pointer to other security descriptor to compare
                pfOwnerEqual - Will be set to TRUE if the item is equal,
                                if NULL, then this component won't be checked
                pfGroupEqual -  "
                pfDACLEqual  -  "
                pfSACLEqual  -  "
                pGenericMapping - Generic mapping for this object, used
                                    for SACL/DACL comparison
                pGenericMappingNewObjects - Generic mapping for new objects
                                    if this is a container
                fMapGenAllOnly - Map generic all only, don't map other generics
                fIsContainer   - TRUE if this security descriptor is on a
                                    container

    EXIT:       The pf*Equal flags will be set

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      For SACL/DACL comparisons, the ACLs are compacted and compared
                once for each unique SID.  Thus the ACLs must conform to the
                security editor's canonical form.

    HISTORY:
        Johnl   09-Nov-1992     Created

********************************************************************/

APIERR OS_SECURITY_DESCRIPTOR::Compare(
                OS_SECURITY_DESCRIPTOR * possecdesc,
                BOOL *           pfOwnerEqual,
                BOOL *           pfGroupEqual,
                BOOL *           pfDACLEqual,
                BOOL *           pfSACLEqual,
                PGENERIC_MAPPING pGenericMapping,
                PGENERIC_MAPPING pGenericMappingNewObjects,
                BOOL             fMapGenAllOnly,
                BOOL             fIsContainer )
{
    OS_SID * possid1 ;
    OS_SID * possid2 ;
    BOOL   fPresent1, fPresent2 ;
    APIERR err = NERR_Success ;

    if ( pfOwnerEqual != NULL )
    {
        if ( !(err = QueryOwner( &fPresent1, &possid1 )) &&
             !(err = possecdesc->QueryOwner( &fPresent2, &possid2 )) )
        {
            *pfOwnerEqual = ( fPresent1 == fPresent2 ) &&
                            fPresent1 && (*possid1 == *possid2) ;
        }
    }

    if ( !err && pfGroupEqual != NULL )
    {
        if ( !(err = QueryGroup( &fPresent1, &possid1 )) &&
             !(err = possecdesc->QueryGroup( &fPresent2, &possid2 )) )
        {
            *pfGroupEqual = ( fPresent1 == fPresent2 ) &&
                            fPresent2 && (*possid1 == *possid2) ;
        }
    }

    if ( !err && pfDACLEqual != NULL )
    {
        *pfDACLEqual = TRUE ;
        BOOL fDACL1Present, fDACL2Present ;
        OS_ACL * pacl1, * pacl2 ;

        if ( (err = QueryDACL( &fDACL1Present, &pacl1 )) ||
             (err = possecdesc->QueryDACL( &fDACL2Present, &pacl2 )) ||
             (fDACL1Present != fDACL2Present))
        {
            *pfDACLEqual = FALSE ;
        }
        else if ( IsDACLPresent() )
        {
            if ( pacl1 != NULL && pacl2 != NULL )
            {
                OS_DACL_SUBJECT_ITER subjiter1( pacl1,
                                                pGenericMapping,
                                                pGenericMappingNewObjects,
                                                fMapGenAllOnly,
                                                fIsContainer ) ;
                OS_DACL_SUBJECT_ITER subjiter2( pacl2,
                                                pGenericMapping,
                                                pGenericMappingNewObjects,
                                                fMapGenAllOnly,
                                                fIsContainer ) ;

                if ( (err = subjiter1.QueryError()) ||
                     (err = subjiter2.QueryError()) ||
                     (err = subjiter1.Compare( pfDACLEqual, &subjiter2)) )
                {
                    return err ;
                }
            }
            else
            {
                *pfDACLEqual = (pacl1 == NULL && pacl2 == NULL);
            }
        }
    }

    if ( !err && pfSACLEqual != NULL )
    {
        *pfSACLEqual = TRUE ;
        BOOL fSACL1Present, fSACL2Present ;
        OS_ACL * pacl1, * pacl2 ;

        if ( (err = QuerySACL( &fSACL1Present, &pacl1 )) ||
             (err = possecdesc->QuerySACL( &fSACL2Present, &pacl2 )) ||
             (fSACL1Present != fSACL2Present))
        {
            *pfSACLEqual = FALSE ;
        }
        else if ( IsSACLPresent() )
        {
            OS_SACL_SUBJECT_ITER subjiter1( pacl1,
                                            pGenericMapping,
                                            pGenericMappingNewObjects,
                                            fMapGenAllOnly,
                                            fIsContainer ) ;
            OS_SACL_SUBJECT_ITER subjiter2( pacl2,
                                            pGenericMapping,
                                            pGenericMappingNewObjects,
                                            fMapGenAllOnly,
                                            fIsContainer ) ;

            if ( (err = subjiter1.QueryError()) ||
                 (err = subjiter2.QueryError()) ||
                 (err = subjiter1.Compare( pfSACLEqual, &subjiter2)) )
            {
                return err ;
            }
        }
    }

    return NERR_Success ;
}


/*******************************************************************

    NAME:       OS_SECURITY_DESCRIPTOR::IsValid

    SYNOPSIS:   Returns TRUE if the components of this security descriptor
                are valid.

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   20-Feb-1992     Created

********************************************************************/

BOOL OS_SECURITY_DESCRIPTOR::IsValid( void ) const
{
    BOOL fIsValid1 = TRUE ;
    BOOL fIsValid2 = TRUE ;
    BOOL fIsValid3 = TRUE ;
    BOOL fIsValid4 = TRUE ;


    if ( QueryControl()->IsDACLPresent() )
        if (_posaclDACL != NULL && !(fIsValid1 = _posaclDACL->IsValid()))
            DBGEOL(SZ("OS_SECURITY_DESCRIPTOR::IsValid - DACL is not valid")) ;

    if ( QueryControl()->IsSACLPresent() )
        if ( !(fIsValid2 = _posaclSACL->IsValid()) )
            DBGEOL(SZ("OS_SECURITY_DESCRIPTOR::IsValid - SACL is not valid")) ;

    if ( _possidOwner != NULL )
        if ( !(fIsValid3 = _possidOwner->IsValid()))
            DBGEOL(SZ("OS_SECURITY_DESCRIPTOR::IsValid - Owner SID is not valid")) ;

    if ( _possidGroup != NULL )
        if ( !(fIsValid4 = _possidGroup->IsValid()))
            DBGEOL(SZ("OS_SECURITY_DESCRIPTOR::IsValid - Group SID is not valid")) ;

    return fIsValid1 && fIsValid2 && fIsValid3 && fIsValid4 ;
}

void OS_SECURITY_DESCRIPTOR::_DbgPrint( void ) const
{
#if defined(DEBUG)
    APIERR err ;
    cdebug << SZ("OS_SECURITY_DESCRIPTOR::DbgPrint - ") << dbgEOL ;
    cdebug << SZ("\tIsOwnerAlloc = ") << (IsOwnerAlloc() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tControl flag = ") << (HEX_STR)((ULONG)((SECURITY_DESCRIPTOR_CONTROL)(*QueryControl()))) << dbgEOL ;
    cdebug << SZ("\tIsValid      = ") << (IsValid() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tDACL Present = ") << (QueryControl()->IsDACLPresent() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tSACL Present = ") << (QueryControl()->IsSACLPresent() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    cdebug << SZ("\tAddress of this = ") << (HEX_STR)(PtrToUlong(this)) << SZ("  Address of _psecuritydesc = ") << (HEX_STR)(PtrToUlong(_psecuritydesc)) << dbgEOL ;

    BOOL fDACLPresent, fDACLDefaulted ;
    PACL pDACL ;
    GetSecurityDescriptorDacl( _psecuritydesc, &fDACLPresent,
                               &pDACL, &fDACLDefaulted ) ;
    cdebug << SZ("\tAddress of DACL referenced by _psecuritydesc = ") << (HEX_STR)(PtrToUlong(pDACL)) << dbgEOL ;
    cdebug << dbgEOL ;

    OS_SID * possidOwner ;
    BOOL     fContainsOwner ;
    err = QueryOwner( &fContainsOwner, &possidOwner ) ;
    if ( err )
        cdebug << SZ("Error retrieving Owner SID, error code: ") << err << dbgEOL ;
    else if ( !fContainsOwner )
        cdebug << SZ("Security Descriptor doesn't contain an Owner SID") << dbgEOL ;
    else
    {
        cdebug << SZ("Owner SID:") << dbgEOL ;
        possidOwner->_DbgPrint() ;
    }

    OS_SID * possidGroup ;
    BOOL     fContainsGroup ;
    err = QueryGroup( &fContainsGroup, &possidGroup ) ;
    if ( err )
        cdebug << SZ("Error retrieving Group SID, error code: ") << err << dbgEOL ;
    else if ( !fContainsGroup )
        cdebug << SZ("Security Descriptor doesn't contain a Group SID") << dbgEOL ;
    else
    {
        cdebug << SZ("Group SID:") << dbgEOL ;
        possidGroup->_DbgPrint() ;
    }

    if ( QueryControl()->IsSACLPresent() )
    {
        OS_ACL * pSACL ;
        BOOL     fSACLPresent ;
        APIERR err = QuerySACL( &fSACLPresent, &pSACL ) ;
        if ( err )
            cdebug << SZ("Error retrieving SACL, error code: ") << err << dbgEOL ;
        else
        {
            UIASSERT( fSACLPresent ) ;
            cdebug << SZ("SACL:") << dbgEOL ;
            pSACL->_DbgPrint() ;
        }
    }

    if ( QueryControl()->IsDACLPresent() )
    {
        OS_ACL * pDACL ;
        BOOL     fDACLPresent ;
        APIERR err = QueryDACL( &fDACLPresent, &pDACL ) ;
        if ( err )
            cdebug << SZ("Error retrieving DACL, error code: ") << err << dbgEOL ;
        else
        {
            UIASSERT( fDACLPresent ) ;
            cdebug << SZ("DACL:") << dbgEOL ;
            if ( pDACL == NULL )
            {
                cdebug << SZ("\tNULL") << dbgEOL ;
            }
            else
                pDACL->_DbgPrint() ;
        }
    }
#endif  // DEBUG
}

/*******************************************************************

    NAME:       OS_ACL_SUBJECT_ITER::OS_ACL_SUBJECT_ITER

    SYNOPSIS:   Standard Constructor/destructor

    ENTRY:      posacl - Pointer to valid ACL to iterate over
                pGenericMapping - Pointer to GENERIC_MAPPING structure that
                    is used for specific->Generic conversion and recognition
                    of Deny All aces.
                fMapGenAllOnly - TRUE means only convert specific permissions
                    that correspond to generic all and ignore possible
                    mappings to Generic Read, Write and Execute.

    EXIT:

    RETURNS:

    NOTES:


    HISTORY:
        Johnl   31-Dec-1991     Created

********************************************************************/

OS_ACL_SUBJECT_ITER::OS_ACL_SUBJECT_ITER( const OS_ACL *   posacl,
                                          PGENERIC_MAPPING pGenericMapping,
                                          PGENERIC_MAPPING pGenericMappingNewObjects,
                                          BOOL             fMapGenAllOnly,
                                          BOOL             fIsContainer )
    : BASE(),
      _posacl                   ( posacl ),
      _pGenericMapping          ( pGenericMapping ),
      _pGenericMappingNewObjects( pGenericMappingNewObjects ),
      _fMapGenAllOnly           ( fMapGenAllOnly ),
      _ossidCurrentSubject      ( NULL   ),
      _cTotalAces               ( 0      ),
      _iCurrentAce              ( 0      ),
      _fIsContainer             ( fIsContainer ),
      _ossidCreator             (),
      _ossidCreatorGroup        ()
{
    UIASSERT( posacl != NULL ) ;
    UIASSERT( pGenericMapping != NULL ) ;

    if ( !posacl->IsValid() )
    {
        ReportError( ERROR_INVALID_PARAMETER ) ;
        return ;
    }

    APIERR err ;
    if ( (err = _ossidCurrentSubject.QueryError()) ||
         (err = _posacl->QueryACECount( &_cTotalAces )) ||
         (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorOwner,
                                                     &_ossidCreator )) ||
         (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CreatorGroup,
                                                     &_ossidCreatorGroup )) )

    {
        ReportError( err ) ;
        return ;
    }

}

OS_ACL_SUBJECT_ITER::~OS_ACL_SUBJECT_ITER()
{
    _posacl = NULL ;
}

/*******************************************************************

    NAME:       OS_ACL_SUBJECT_ITER::FindNextSubject

    SYNOPSIS:   Finds the next unique SID in this ACL starting from our
                current position.

    ENTRY:      pfFoundNewSubject - Set to TRUE if a new subject was found, FALSE
                    otherwise.
                possidNewSubj - Pointer to OS_SID that will receive the new subject
                posaceFirstAceWithSubj - pointer to ACE that will receive the first
                    ACE in this ACL that contains the new subject.  The current
                    ACE index will be set to this ACE position also.

    EXIT:       if *pfFoundNewSubject is TRUE, then
                    *possidNewSubj will contain the new SID
                    *posaceFirstAceWithSubj will point to the first ACE in
                            the ACL with this SID

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   31-Dec-1991     Broke out from child classes

********************************************************************/

APIERR OS_ACL_SUBJECT_ITER::FindNextSubject( BOOL   * pfFoundNewSubject,
                                             OS_SID * possidNewSubj,
                                             OS_ACE * posaceFirstAceWithSubj )
{
    APIERR err ;
    UIASSERT( possidNewSubj != NULL ) ;
    UIASSERT( !possidNewSubj->QueryError() &&
              !posaceFirstAceWithSubj->QueryError() ) ;

    /* Assume we won't find a new subject
     */
    *pfFoundNewSubject = FALSE ;

    /* Confirm there are ACEs left to examine in this ACL.
     */
    if ( _iCurrentAce >= QueryTotalAceCount() )
        return NERR_Success ;

    /* Find the next subject that we haven't encountered before.  We do this
     * by looking at the SID in the current ACE, then scanning from the
     * start of the ACL looking for the same SID, if we don't find it before
     * our current location, then this is a new subject, otherwise we go
     * on to the next ACE.
     */
    BOOL fOldSid = TRUE ;
    while ( fOldSid )
    {
        /* Get the candidate SID from the current ACE
         */
        OS_SID * possid ;
        if ( (err =_posacl->QueryACE( _iCurrentAce, posaceFirstAceWithSubj ))||
             (err =posaceFirstAceWithSubj->QuerySID( &possid ))              ||
             (err =possidNewSubj->Copy( *possid )))
        {
            return err ;
        }

        /* Determine if the candidate SID is one we have already encountered
         */
        BOOL fFoundAce ;
        ULONG iFoundAce ;
        if ( (err = _posacl->FindACE( *possidNewSubj, &fFoundAce,
                                       posaceFirstAceWithSubj,
                                       &iFoundAce ))             )
        {
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - Unable to find ACE\n\r")) ;
            return err ;
        }
        UIASSERT( fFoundAce ) ;

        /* If we didn't find the same SID before our current position, then
         * this is indeed a new SID.
         */
        if ( iFoundAce == _iCurrentAce )
        {
            fOldSid = FALSE ;
        }
        else
        {
            _iCurrentAce++ ;
            if ( _iCurrentAce >= _cTotalAces )
            {
                /* We have already set pfFoundNewSubject to FALSE
                 */
                return NERR_Success ;
            }
        }
    }

    //
    //  Special case the Creator Owner SID.  The system makes ACEs with the
    //  Creator Owner SID inherit only.  We compensate for that here by
    //  undoing what the system did.  This is a benign change
    //  since the Creator Owner SID never grants anything directly.  We do
    //  this because this class (and the security editor) expect SIDs to
    //  be on the object (in addition to child containers/objects).
    //
    if ( posaceFirstAceWithSubj->IsInheritOnly() &&
         (
            !IsContainer() ||
            (IsContainer() &&
             posaceFirstAceWithSubj->IsInherittedByNewContainers())
         ) &&
         (*possidNewSubj == _ossidCreator  ||
          *possidNewSubj == _ossidCreatorGroup ))
    {
        TRACEEOL("OS_ACL_SUBJECT_ITER::FindNextSubject - Adjusting Creator Owner ACE inheritance") ;
        posaceFirstAceWithSubj->SetInheritOnly( FALSE ) ;
    }

    *pfFoundNewSubject = TRUE ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_ACL_SUBJECT_ITER::MapSpecificToGeneric

    SYNOPSIS:   This method takes an access mask and maps the specific
                (and sometimes standard) permissions to their Generic
                equivalent, clearing any bits that were mapped.

    ENTRY:      *pAccessMask - Pointer to access mask to map
                fIsInherittedByNewObjects - If TRUE, then the new object
                generic mapping is used.

    EXIT:       The access mask will have some set of generic bits set and
                the corresponding specific/standard bits cleared according
                to the generic mapping passed in at construction.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:

    HISTORY:
        Johnl   26-Feb-1992     Created

********************************************************************/

APIERR OS_ACL_SUBJECT_ITER::MapSpecificToGeneric( ACCESS_MASK * pAccessMask,
                                                  BOOL fIsInherittedByNewObjects )
{
    APIERR err = NERR_Success ;
    PGENERIC_MAPPING pGenMapping = fIsInherittedByNewObjects ?
                                    _pGenericMappingNewObjects :
                                    _pGenericMapping ;
    UIASSERT( pGenMapping != NULL ) ;

    /* First check if the access mask is a "Generic All" access mask
     */
    if ( (pGenMapping->GenericAll & *pAccessMask) == pGenMapping->GenericAll )
    {
        *pAccessMask &= ~pGenMapping->GenericAll ;
        *pAccessMask |= GENERIC_ALL ;

        /* If, after taking out all of the bits mapped by Generic all, there
         * are some bits left over, then something went wrong (generic all
         * mapping didn't cover all possible access bits).
         */
        if ( *pAccessMask & ~GENERIC_ALL )
        {
            DBGEOL(SZ("OS_ACL_SUBJECT_ITER::MapSpecificToGeneric - Generic All map didn't cover all possible bits!!")) ;
            err = ERROR_INVALID_PARAMETER ;
        }
    }
    else if ( !MapGenericAllOnly() )
    {
        /* Look at whether the bits match any of the other generic cases.
         */
        ACCESS_MASK TempGenRead  = *pAccessMask ;
        ACCESS_MASK TempGenWrite = *pAccessMask ;
        ACCESS_MASK TempGenExec  = *pAccessMask ;
        ACCESS_MASK Generics = 0 ;

        if ( (pGenMapping->GenericRead & *pAccessMask) ==
                                                pGenMapping->GenericRead )
        {
            TempGenRead &= ~pGenMapping->GenericRead ;
            Generics |= GENERIC_READ ;
        }

        if ( (pGenMapping->GenericWrite & *pAccessMask) ==
                                                pGenMapping->GenericWrite )
        {
            TempGenWrite &= ~pGenMapping->GenericWrite ;
            Generics |= GENERIC_WRITE ;
        }

        if ( (pGenMapping->GenericExecute & *pAccessMask) ==
                                                pGenMapping->GenericExecute )
        {
            TempGenExec &= ~pGenMapping->GenericExecute ;
            Generics |= GENERIC_EXECUTE ;
        }

        /* At this point, Generics contains all of the generic bits set and
         * anding all of the TempGen* access masks will give all of the bits
         * that weren't masked out by a mapping (such as the standard bits).
         */

        *pAccessMask = Generics | ( TempGenRead & TempGenWrite & TempGenExec ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:       OS_ACL_SUBJECT_ITER::Compare

    SYNOPSIS:   Compares this subject iter with psubjiter

    ENTRY:      pfACLEqual - Will be set to TRUE if the ACLs are equal
                psubjiter - Subj iter to compare

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:

    HISTORY:
        Johnl   09-Nov-1992     Created

********************************************************************/

APIERR OS_ACL_SUBJECT_ITER::Compare( BOOL * pfACLEqual,
                                     OS_ACL_SUBJECT_ITER * psubjiter )
{
    APIERR err = NERR_Success ;
    INT  cSubjIter1Subjects = 0,
         cSubjIter2Subjects = 0 ;
    *pfACLEqual = TRUE ;
    BOOL fQuitCauseACLAintEqual = FALSE ;

    //
    //  First compare the number of unique SIDs in each ACL.  If they are
    //  different, then we get out right away.
    //

    while ( psubjiter->Next( &err ) && !err )
        cSubjIter1Subjects++ ;

    if ( err )
        return err ;

    while ( Next( &err ) && !err )
        cSubjIter2Subjects++ ;

    if ( err )
        return err ;

    if ( cSubjIter1Subjects != cSubjIter2Subjects )
    {
        *pfACLEqual = FALSE ;
        return err ;
    }

    Reset() ;
    psubjiter->Reset() ;

    //
    //  Now go through each subject and compare the masks and inheritance
    //  bits
    //
    //  CODEWORK - This is the expensive way of doing things, would be
    //  prefereable to not have an n^2 algorithm
    //

    while ( psubjiter->Next( &err ) && !err )
    {
        BOOL fFoundMatchingSID = FALSE ;
        while ( Next( &err ) &&
                !err )
        {
            if ( *psubjiter->QuerySID() == *QuerySID() )
            {
                if ( !CompareCurrentSubject( psubjiter ) )
                {
                    fQuitCauseACLAintEqual = TRUE ;
                    break ;
                }
                //
                //  There will be only one unique SID per "Next"
                //
                fFoundMatchingSID = TRUE ;
                break ;
            }
        } // while subjiter2

        //
        //  If no match was found, then these aren't equal
        //
        if ( err || fQuitCauseACLAintEqual || !fFoundMatchingSID )
        {
            fQuitCauseACLAintEqual = TRUE ;
            break ;
        }

        Reset() ;
    } // while psubjiter

    if ( fQuitCauseACLAintEqual )
        *pfACLEqual = FALSE ;

    return err ;
}

/*******************************************************************

    NAME:       OS_DACL_SUBJECT_ITER::OS_DACL_SUBJECT_ITER

    SYNOPSIS:   Standard Constructor/destructor

    ENTRY:      posacl - Pointer to valid ACL to iterate over

    EXIT:

    RETURNS:

    NOTES:      The ACL must conform to the Deny All followed by grants
                form.

                The private data members are initialized when used in Next.

    HISTORY:
        Johnl   23-Dec-1991     Created

********************************************************************/

OS_DACL_SUBJECT_ITER::OS_DACL_SUBJECT_ITER( OS_ACL * posacl,
                                            PGENERIC_MAPPING pGenericMapping,
                                            PGENERIC_MAPPING pGenericMappingNewObjects,
                                            BOOL             fMapGenAllOnly,
                                            BOOL             fIsContainer )
    : OS_ACL_SUBJECT_ITER( posacl,
                           pGenericMapping,
                           pGenericMappingNewObjects,
                           fMapGenAllOnly,
                           fIsContainer  )
{
    if ( QueryError() )
        return ;

    //
    //  Check for a bad mix of grants or denies or unrecognized ACEs
    //
    APIERR err = NERR_Success ;
    ULONG  cAces ;
    OS_ACE osace ;
    if ( (err = posacl->QueryACECount( &cAces )) ||
         (err = osace.QueryError()) )
    {
        ReportError( err ) ;
        return ;
    }

    BOOL fFoundGrant = FALSE ;
    for ( ULONG i = 0 ; !err && i < cAces ; i++ )
    {
        if ( err = posacl->QueryACE( i, &osace ) )
        {
            break ;
        }

        switch ( osace.QueryType() )
        {
        case ACCESS_ALLOWED_ACE_TYPE:
            fFoundGrant = TRUE ;
            break ;

        case ACCESS_DENIED_ACE_TYPE:
            if ( fFoundGrant )
            {
                DBGEOL("OS_DACL_SUBJECT_ITER::ct - Found Deny ACE after grant ACE") ;
                err = IERR_UNRECOGNIZED_ACL ;
            }
            break ;

        default:
            err = IERR_UNRECOGNIZED_ACL ;
        }
    }

    if ( err )
        ReportError( err ) ;
}

OS_DACL_SUBJECT_ITER::~OS_DACL_SUBJECT_ITER()
{
    /* Nothing to do */
}

/*******************************************************************

    NAME:       OS_DACL_SUBJECT_ITER::Next

    SYNOPSIS:   Moves to the next subject in this ACL

    ENTRY:      perr - Pointer to receive error code if one occurs

    EXIT:       The Data members will be updated to contain the data
                as specified by the ACEs in this ACL

    RETURNS:    TRUE if a new subject was found in this ACL and the Query
                methods will return valid data.  FALSE if there are no
                more SIDs or an error occurred.

    NOTES:      IERR_UNRECOGNIZED_ACL may be returned if a particular
                series of ACEs occur that cannot be expressed by this
                iterator.

    HISTORY:
        Johnl   23-Dec-1991     Created

********************************************************************/

BOOL OS_DACL_SUBJECT_ITER::Next( APIERR * perr )
{
    /* Assume the operation will succeed
     */
    *perr = NERR_Success ;

    OS_ACE osaceCurrent ;
    OS_SID ossidKey ;
    BOOL   fFoundNewSubj ;
    if ( (*perr = ossidKey.QueryError()) ||
         (*perr = osaceCurrent.QueryError()) ||
         (*perr = FindNextSubject( &fFoundNewSubj, &ossidKey, &osaceCurrent ))||
         ( !fFoundNewSubj ) )
    {
        if ( *perr )
            DBGEOL(SZ("OS_DACL_SUBJECT_ITER::Next - error ") << (ULONG) *perr <<
                    SZ(" occurred on FindNextSubject")) ;

        return FALSE ;
    }

    /* We have found a new SID, so find the rest of the permissions in this
     * ACL and accumulate the permissions as appropriate.
     */
    _accessmask           = 0      ;
    _fDenyAll             = FALSE  ;
    _fHasAce              = FALSE  ;
    _accessmaskNewObj     = 0      ;
    _fDenyAllNewObj       = FALSE  ;
    _fHasAceNewObj        = FALSE  ;
    _accessmaskNewCont    = 0      ;
    _fDenyAllNewCont      = FALSE  ;
    _fHasAceNewCont       = FALSE  ;
    _accessmaskInheritOnly= 0      ;
    _fDenyAllInheritOnly  = FALSE  ;
    _fHasAceInheritOnly   = FALSE  ;

    BOOL fMoreAces = TRUE ;
    ULONG iAce = QueryCurrentACE() ;
    while ( fMoreAces )
    {
        /* If inherittance is "On", then inherittance must also be propagated.
         */
        if ( IsContainer() &&
             (osaceCurrent.IsInherittedByNewObjects() ||
              osaceCurrent.IsInherittedByNewContainers()) &&
             !osaceCurrent.IsInheritancePropagated() )
        {
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - Inheritance not propagated in ACE\n\r")) ;
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        /* The following may not be safe for sub-items that have specific
         * permissions set (that correspond to this container's generic
         * mapping.  This is really the responsibility of the client of the
         * Acl Editor API.
         */
        ACCESS_MASK MappedAccessMask = osaceCurrent.QueryAccessMask() ;
        if ( *perr = MapSpecificToGeneric( &MappedAccessMask,
                                           osaceCurrent.IsInherittedByNewObjects() ))
        {
            return FALSE ;
        }

        switch ( osaceCurrent.QueryType() )
        {
        case ACCESS_DENIED_ACE_TYPE:
            /* If we found a Deny ACE after finding a Grant ACE or
             *    The deny ACE is not Deny ALL
             * then we can't process this DACL.
             */
            if ( !(MappedAccessMask & GENERIC_ALL) )
            {
                DBGEOL("OS_DACL_SUBJECT_ITER::Next - Partial deny ACE found") ;
                *perr = IERR_UNRECOGNIZED_ACL ;
                return FALSE ;
            }

            if ( !osaceCurrent.IsInheritOnly() )
            {
                /* Have we hit a grant already for this type of ACE?  If so
                 * then it is an unrecognized DACL.  Note that the deny
                 * will take precedence over other masks for this ACE.
                 */
                if ( _fHasAce && _accessmask != 0 )
                {
                    *perr = IERR_UNRECOGNIZED_ACL ;
                    break ;
                }

                _accessmask = 0 ;
                _fDenyAll = TRUE ;
                _fHasAce  = TRUE ;
            }
            else
            {
#if 0
//
//  We shouldn't need to check the inherit only flags since we will catch
//  them in either oi or ci case.  We should be able to safely comment
//  the inherit only sections out since they will always be initialized to
//  zero.
//
                if ( _fHasAceInheritOnly && _accessmaskInheritOnly != 0 )
                {
                    *perr = IERR_UNRECOGNIZED_ACL ;
                    break ;
                }

                _accessmaskInheritOnly = 0 ;
                _fDenyAllInheritOnly   = TRUE ;
                _fHasAceInheritOnly    = TRUE ;
#endif //0
            }

            if ( osaceCurrent.IsInherittedByNewObjects() )
            {
                if ( _fHasAceNewObj && _accessmaskNewObj != 0 )
                {
                    *perr = IERR_UNRECOGNIZED_ACL ;
                    break ;
                }

                _accessmaskNewObj = 0 ;
                _fDenyAllNewObj = TRUE ;
                _fHasAceNewObj  = TRUE ;
            }

            if ( osaceCurrent.IsInherittedByNewContainers() )
            {
                if ( _fHasAceNewCont && _accessmaskNewCont != 0 )
                {
                    *perr = IERR_UNRECOGNIZED_ACL ;
                    break ;
                }

                _accessmaskNewCont = 0 ;
                _fDenyAllNewCont = TRUE ;
                _fHasAceNewCont  = TRUE ;
            }
            break ;

        case ACCESS_ALLOWED_ACE_TYPE:
            if ( !osaceCurrent.IsInheritOnly() &&
                 !_fDenyAll )
            {
                _accessmask |= MappedAccessMask ;
                _fHasAce  = TRUE ;
            }
            else if ( !_fDenyAllInheritOnly )
            {
#if 0
                _accessmaskInheritOnly |= MappedAccessMask ;
                _fHasAceInheritOnly  = TRUE ;
#endif
            }


            if ( osaceCurrent.IsInherittedByNewObjects() &&
                 !_fDenyAllNewObj )
            {
                _accessmaskNewObj |= MappedAccessMask ;
                _fHasAceNewObj  = TRUE ;
            }

            if ( osaceCurrent.IsInherittedByNewContainers() &&
                 !_fDenyAllNewCont )
            {
                _accessmaskNewCont |= MappedAccessMask ;
                _fHasAceNewCont  = TRUE ;
            }

            break ;

        default:
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - ACE not Access Allowed or Access Denied\n\r")) ;
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        if ( *perr )
        {
            DBGEOL("OS_DACL_SUBJECT_ITER::Next - Returning error " << (ULONG) *perr ) ;
            return FALSE ;
        }

        /* Find the next ACE for this SID
         *
         * Start searching for the next ACE one after the ACE we just
         * looked at
         */
        iAce++ ;
        if ( iAce >= QueryTotalAceCount() )
        {
            fMoreAces = FALSE ;
        }
        else if ( (*perr = QueryACL()->FindACE( ossidKey,
                                                &fMoreAces,
                                                &osaceCurrent,
                                                &iAce,
                                                iAce )) )
        {
            DBGEOL(SZ("OS_DACL_SUBJECT_ITER::Next - FindACE failed")) ;
            return FALSE ;
        }

        //
        //  Adjust the inherit flags on this ACE if it contains the creator
        //  owner SID
        //
        if ( osaceCurrent.IsInheritOnly() &&
             (
                !IsContainer() ||
                (IsContainer() &&
                 osaceCurrent.IsInherittedByNewContainers())
             ) &&
             ( ossidKey == _ossidCreator  ||
               ossidKey == _ossidCreatorGroup ))
        {
            TRACEEOL("OS_DACL_SUBJECT_ITER::Next - Adjusting Creator Owner ACE inheritance") ;
            osaceCurrent.SetInheritOnly( FALSE ) ;
        }
    }

    if ( *perr = ((OS_SID *)QuerySID())->Copy( ossidKey ))
    {
        DBGEOL(SZ("OS_DACL_SUBJECT_ITER::Next - Copy SID failed")) ;
        return FALSE ;
    }

    SetCurrentACE( QueryCurrentACE() + 1 ) ;
    return TRUE ;
}

/*******************************************************************

    NAME:       OS_DACL_SUBJECT_ITER::CompareCurrentSubject

    SYNOPSIS:   Returns TRUE if the current subject if the passed psubjiter
                equals the current subject of this.  FALSE if they are not
                equal

    ENTRY:      psubjiter - Pointer to subject iter to compare against

    RETURNS:    TRUE if they are equal, FALSE if they are not equal

    NOTES:      psubjiter must be a pointer to a OS_DACL_SUBJECT_ITER.

    HISTORY:
        Johnl   09-Nov-1992     Created

********************************************************************/

BOOL OS_DACL_SUBJECT_ITER::CompareCurrentSubject( OS_ACL_SUBJECT_ITER * psubjiter )
{
    UIASSERT( IsContainer() == psubjiter->IsContainer() ) ;
    OS_DACL_SUBJECT_ITER * pdaclsubjiter = (OS_DACL_SUBJECT_ITER *) psubjiter ;

    if ( pdaclsubjiter->IsDenyAll()  != IsDenyAll()  ||
         pdaclsubjiter->HasThisAce() != HasThisAce() ||
         pdaclsubjiter->QueryAccessMask() != QueryAccessMask())
    {
        return FALSE ;
    }

    if ( IsContainer() &&
        (pdaclsubjiter->IsNewObjectDenyAll()         != IsNewObjectDenyAll() ||
         pdaclsubjiter->IsNewContainerDenyAll()      != IsNewContainerDenyAll() ||
         pdaclsubjiter->IsInheritOnlyDenyAll()       != IsInheritOnlyDenyAll() ||
         pdaclsubjiter->HasNewObjectAce()            != HasNewObjectAce() ||
         pdaclsubjiter->HasNewContainerAce()         != HasNewContainerAce() ||
         pdaclsubjiter->HasInheritOnlyAce()          != HasInheritOnlyAce() ||
         pdaclsubjiter->QueryNewObjectAccessMask()   != QueryNewObjectAccessMask() ||
         pdaclsubjiter->QueryNewContainerAccessMask()!= QueryNewContainerAccessMask() ||
         pdaclsubjiter->QueryInheritOnlyAccessMask() != QueryInheritOnlyAccessMask()))
    {
        return FALSE ;
    }

    return TRUE ;
}

/*******************************************************************

    NAME:       OS_SACL_SUBJECT_ITER::OS_SACL_SUBJECT_ITER

    SYNOPSIS:   Standard Constructor/destructor

    ENTRY:      posacl - Pointer to valid ACL to iterate over

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   23-Dec-1991     Created

********************************************************************/

OS_SACL_SUBJECT_ITER::OS_SACL_SUBJECT_ITER( OS_ACL * posacl,
                                            PGENERIC_MAPPING pGenericMapping,
                                            PGENERIC_MAPPING pGenericMappingNewObjects,
                                            BOOL             fMapGenAllOnly,
                                            BOOL             fIsContainer )
    : OS_ACL_SUBJECT_ITER( posacl,
                           pGenericMapping,
                           pGenericMappingNewObjects,
                           fMapGenAllOnly,
                           fIsContainer )
{
    if ( QueryError() )
        return ;

    InitToZero() ;
}

OS_SACL_SUBJECT_ITER::~OS_SACL_SUBJECT_ITER()
{
    /* Nothing to do */
}

void OS_SACL_SUBJECT_ITER::InitToZero( void )
{
    for ( int i = 0 ; i < OS_SACL_DESC_LAST ; i++ )
        _asaclDesc[i].InitToZero() ;
}

/*******************************************************************

    NAME:       OS_SACL_SUBJECT_ITER::Next

    SYNOPSIS:   Moves to the next subject in this ACL

    ENTRY:      perr - Pointer to receive error code if one occurs

    EXIT:       The Data members will be updated to contain the data
                as specified by the ACEs in this ACL

    RETURNS:    TRUE if a new subject was found in this ACL and the Query
                methods will return valid data.  FALSE if there are no
                more SIDs ore an error occurred.

    NOTES:      IERR_UNRECOGNIZED_ACL may be returned if a particular
                series of ACEs occur that cannot be expressed by this
                iterator.

    HISTORY:
        Johnl   23-Dec-1991     Created

********************************************************************/

BOOL OS_SACL_SUBJECT_ITER::Next( APIERR * perr )
{
    /* Assume the operation will succeed
     */
    *perr = NERR_Success ;

    OS_ACE osaceCurrent ;
    OS_SID ossidKey ;
    BOOL   fFoundNewSubj ;
    if ( (*perr = ossidKey.QueryError()) ||
         (*perr = osaceCurrent.QueryError()) ||
         (*perr = FindNextSubject( &fFoundNewSubj, &ossidKey, &osaceCurrent )) ||
         ( !fFoundNewSubj ) )
    {
        return FALSE ;
    }

    /* We have found a new SID, so find the rest of the permissions in this
     * ACL and accumulate the permissions as appropriate.
     */
    InitToZero() ;

    BOOL fMoreAces = TRUE ;
    ULONG iAce = QueryCurrentACE() ;
    while ( fMoreAces )
    {
        /* If inherittance is "On", then inherittance must also be propagated.
         */
        if ( IsContainer() &&
             (osaceCurrent.IsInherittedByNewObjects() ||
              osaceCurrent.IsInherittedByNewContainers()) &&
             !osaceCurrent.IsInheritancePropagated() )
        {
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - Inheritance not propagated in ACE\n\r")) ;
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        ACCESS_MASK MappedAccessMask = osaceCurrent.QueryAccessMask() ;
        if ( *perr = MapSpecificToGeneric( &MappedAccessMask,
                                           osaceCurrent.IsInherittedByNewObjects() ))
        {
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        /* Since an ACE can only be a system audit or system alarm ace,
         * we can use an offset into the description array to choose
         * the correct item.  All the other attributes are bitfields so
         * we have to check each individually.
         */
        UINT uiTypeOffset = osaceCurrent.QueryType() & SYSTEM_AUDIT_ACE_TYPE ?
                                          0 :
                                          OS_SACL_DESC_THIS_OBJECT_S_ALARM ;
        UIASSERT( (osaceCurrent.QueryType() & SYSTEM_AUDIT_ACE_TYPE) ||
                  (osaceCurrent.QueryType() & SYSTEM_ALARM_ACE_TYPE)    ) ;

        if ( !((osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG) ||
               (osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG)))
        {
            UIDEBUG(SZ("OS_DACL_SUBJECT_ITER::Next - Unrecognized ACE Flags\n\r")) ;
            *perr = IERR_UNRECOGNIZED_ACL ;
            return FALSE ;
        }

        if ( !osaceCurrent.IsInheritOnly() )
        {
            if ( osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_THIS_OBJECT_S_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_THIS_OBJECT_S_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

            if ( osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_THIS_OBJECT_F_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_THIS_OBJECT_F_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

        }
        else
        {
#if 0
            if ( osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_INHERIT_ONLY_S_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_INHERIT_ONLY_S_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

            if ( osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_INHERIT_ONLY_F_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_INHERIT_ONLY_F_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }
#endif
        }

        if ( osaceCurrent.IsInherittedByNewObjects() )
        {
            if ( osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_NEW_OBJECT_S_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_NEW_OBJECT_S_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

            if ( osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_NEW_OBJECT_F_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_NEW_OBJECT_F_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }
        }

        if ( osaceCurrent.IsInherittedByNewContainers() )
        {
            if ( osaceCurrent.QueryAceFlags() & SUCCESSFUL_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_NEW_CONT_S_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_NEW_CONT_S_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }

            if ( osaceCurrent.QueryAceFlags() & FAILED_ACCESS_ACE_FLAG )
            {
                _asaclDesc[OS_SACL_DESC_NEW_CONT_F_AUDIT+uiTypeOffset]._accessmask |=
                        MappedAccessMask ;
                _asaclDesc[OS_SACL_DESC_NEW_CONT_F_AUDIT+uiTypeOffset]._fHasAce = TRUE ;
            }
        }

        /* Start searching for the next ACE with this SID one after
         * the ACE we just looked at
         */
        iAce++ ;
        if ( iAce >= QueryTotalAceCount() )
        {
            fMoreAces = FALSE ;
        }
        else if ( (*perr = QueryACL()->FindACE( ossidKey, &fMoreAces, &osaceCurrent,
                                        &iAce, iAce ))              )
        {
            DBGEOL(SZ("OS_SACL_SUBJECT_ITER::Next - FindACE failed")) ;
            return FALSE ;
        }

        //
        //  Adjust the inherit flags on this ACE if it contains the creator
        //  owner SID
        //
        if ( osaceCurrent.IsInheritOnly() &&
             (
                !IsContainer() ||
                (IsContainer() &&
                 osaceCurrent.IsInherittedByNewContainers())
             ) &&
             ( ossidKey == _ossidCreator  ||
               ossidKey == _ossidCreatorGroup ))
        {
            TRACEEOL("OS_DACL_SUBJECT_ITER::Next - Adjusting Creator Owner ACE inheritance") ;
            osaceCurrent.SetInheritOnly( FALSE ) ;
        }
    }

    if ( *perr = ((OS_SID *) QuerySID())->Copy( ossidKey ))
    {
        DBGEOL(SZ("OS_SACL_SUBJECT_ITER::Next - Copy SID failed")) ;
        return FALSE ;
    }

    SetCurrentACE( QueryCurrentACE() + 1 ) ;
    return TRUE ;
}

/*******************************************************************

    NAME:       OS_SACL_SUBJECT_ITER::CompareCurrentSubject

    SYNOPSIS:   Returns TRUE if the current subject if the passed psubjiter
                equals the current subject of this.  FALSE if they are not
                equal

    ENTRY:      psubjiter - Pointer to subject iter to compare against

    RETURNS:    TRUE if they are equal, FALSE if they are not equal

    NOTES:      psubjiter must be a pointer to a OS_SACL_SUBJECT_ITER.

    HISTORY:
        Johnl   09-Nov-1992     Created

********************************************************************/

BOOL OS_SACL_SUBJECT_ITER::CompareCurrentSubject( OS_ACL_SUBJECT_ITER * psubjiter )
{
    OS_SACL_SUBJECT_ITER * psaclsubjiter = (OS_SACL_SUBJECT_ITER *) psubjiter ;

    if ( psaclsubjiter->HasThisAuditAce_S()      != HasThisAuditAce_S() ||
         psaclsubjiter->QueryAuditAccessMask_S() != QueryAuditAccessMask_S() ||
         psaclsubjiter->HasThisAuditAce_F()      != HasThisAuditAce_F() ||
         psaclsubjiter->QueryAuditAccessMask_F() != QueryAuditAccessMask_F()
       )
    {
        return FALSE ;
    }

    if ( IsContainer() &&
        (psaclsubjiter->HasNewObjectAuditAce_S()      != HasNewObjectAuditAce_S() ||
         psaclsubjiter->QueryNewObjectAuditAccessMask_S() != QueryNewObjectAuditAccessMask_S() ||
         psaclsubjiter->HasNewObjectAuditAce_F()      != HasNewObjectAuditAce_F() ||
         psaclsubjiter->QueryNewObjectAuditAccessMask_F() != QueryNewObjectAuditAccessMask_F() ||

         psaclsubjiter->HasNewContainerAuditAce_S()      != HasNewContainerAuditAce_S() ||
         psaclsubjiter->QueryNewContainerAuditAccessMask_S() != QueryNewContainerAuditAccessMask_S() ||
         psaclsubjiter->HasNewContainerAuditAce_F()      != HasNewContainerAuditAce_F() ||
         psaclsubjiter->QueryNewContainerAuditAccessMask_F() != QueryNewContainerAuditAccessMask_F() ||

         psaclsubjiter->HasInheritOnlyAuditAce_S()      != HasInheritOnlyAuditAce_S() ||
         psaclsubjiter->QueryInheritOnlyAuditAccessMask_S() != QueryInheritOnlyAuditAccessMask_S() ||
         psaclsubjiter->HasInheritOnlyAuditAce_F()      != HasInheritOnlyAuditAce_F() ||
         psaclsubjiter->QueryInheritOnlyAuditAccessMask_F() != QueryInheritOnlyAuditAccessMask_F()
        )
         /* Alert ACEs will go here */
       )
    {
        return FALSE ;
    }

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\svcman.cxx ===
/**********************************************************************/
/**                       Microsoftscman. Windows NT                 **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    SCMAN.cxx
        SC Manager and Service object class. It is used to create, control,
        and query the services and sc manager objects in the NT registry.

    FILE HISTORY:
        terryk  05-May-1992     Created
        KeithMo 11-Nov-1992     Added DisplayName goodies.

*/

#include "pchlmobj.hxx"  // Precompiled header

extern "C"
{
    #include <winsvcp.h>     // EnumServiceGroupW
}



//
// string constants defined
//

#if defined(UNICODE)
  #define SZ_SERVICES_ACTIVE    ((WCHAR *) (SERVICES_ACTIVE_DATABASEW))
  #define SZ_SERVICES_FAILED    ((WCHAR *) (SERVICES_FAILED_DATABASEW))
#else
  #define SZ_SERVICES_ACTIVE    SERVICES_ACTIVE_DATABASEA
  #define SZ_SERVICES_FAILED    SERVICES_FAILED_DATABASEA
#endif

//
//  Slop space for enumeration buffer.
//

#define SERVICE_ENUM_SLOP       ((DWORD)1024)


/*******************************************************************

    NAME:       SERVICE_CONTROL::SERVICE_CONTROL

    SYNOPSIS:   constructor

    HISTORY:
                terryk  20-May-1992     Created

********************************************************************/

SERVICE_CONTROL::SERVICE_CONTROL()
        : _hHandle( NULL ),
        _buffer( 1024 )
{
    APIERR err;

    if (( err =  _buffer.QueryError()) != NERR_Success )
    {
        ReportError( err );
    }
}

/*******************************************************************

    NAME:       SERVICE_CONTROL::Close

    SYNOPSIS:   Close the object handle

    RETURN:     APIERR - NERR_Success if OK. Otherwise, it will return
                the error code. Possible errors:
                        ERROR_INVALID_HANDLE - The specified handle is invalid.

    HISTORY:
        terryk  04-May-1992     Created
        davidhov 5/26/92   Changed to ignore close on NULL handle

********************************************************************/

APIERR SERVICE_CONTROL::Close()
{
    APIERR err = NERR_Success;

    if ( _hHandle )
    {
        if ( !::CloseServiceHandle( _hHandle ) )
        {
            // get the err code
            err = ::GetLastError( );
        }
    }

    _hHandle = NULL ;

    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER::SC_MANAGER

    SYNOPSIS:   Constructor. It will open the registry database for later
                reference.

    ENTRY:      const TCHAR * pszMachine - Name of the target machine; NULL
                        or empty string connects to the local service control
                        manager
                UINT dwAccess - access code. See winsvc.h for detail.
                SERVICE_DATA - either "ACTIVE" or "FAILED". The default
                        is "ACTIVE".

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_MANAGER::SC_MANAGER(
        const TCHAR * pszMachineName,
        UINT dwAccess,
        SERVICE_DATABASE database )
    : _fOwnerAlloc( FALSE )
{
    // BUGBUG:  database name strings don't work, so use NULL (1.256)

    const TCHAR * szDatabase = NULL ;

    if (database == FAILED )
    {
        szDatabase = SZ_SERVICES_FAILED ;
    }

    SC_HANDLE hSCManager = ::OpenSCManager(
                                 (TCHAR *) pszMachineName,
                                 (TCHAR *) szDatabase,
                                 dwAccess );

    SetHandle( hSCManager );

    if ( hSCManager == NULL )
    {
        ReportError( ::GetLastError() );
    }
}


  //  Secondary constructor to wrapper a pre-existing handle

SC_MANAGER::SC_MANAGER ( SC_HANDLE hSvcCtrl )
    : _fOwnerAlloc( TRUE )
{
    SetHandle( hSvcCtrl );
}


/*******************************************************************

    NAME:       SC_MANAGER::~SC_MANAGER

    SYNOPSIS:   Close the sc manager's handle

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_MANAGER::~SC_MANAGER()
{
    if ( ! _fOwnerAlloc )
    {
        if ( Close() != NERR_Success )
        {
            DBGEOL( SZ("Error: Cannot close service") );
        }
    }
}

/*******************************************************************

    NAME:       SC_MANAGER::EnumServiceStatus

    SYNOPSIS:   Enumerate services in the service control manager database
                along with the status of each service.

    ENTRY:      UINT dwServiceType - Value to select the type of
                        services of enumerate. It must be one of the bitwise
                        OR of the following values:
                        SERVICE_WIN32 - enumerate Win32 services only
                        SERVICE_DRIVER - enumerate Driver services only
                UINT dwServiceState - Value to select the services to
                        enumerate based on the running state. It must be one
                        or the bitwise OR of the following values:
                        SERVICE_ACTIVE - enumerate services that have started
                            which includes services that are running, paused,
                            and inpending states.
                        SERVICE_INACTIVE - enumerate services that are stopped.
                LPENUM_SERVICE_STATUS *ppServices - A pointer to a buffer to
                        receive an array of service entries; each entry is
                        the ENUM_SERVICE_STATUS information structure.
                UINT * lpServicesReturned - A pointer to a variable to receive
                        the number of service entries returned.
                const TCHAR * pszGroupName - optional - limits enumeration to 
                        those services who are in the pszGroupName service 
                        order group.

    EXIT:       lpService - an array of service entries.
                lpServicesReturned - the number of service entries returned.

    RETURNS:    Possible errors:
                ERROR_ACCESS_DENIED - The specified handle was not opened with
                        SC_MANAGER_ENUMERATE_SERVICES access.
                ERROR_INVALID_HANDLE - The specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - There are more service entries that would fit
                        into the supplied output buffer.
                ERROR_INVALID_PARAMETER - A parameter specified in invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::EnumServiceStatus(
        UINT dwServiceType,
        UINT dwServiceState,
        LPENUM_SERVICE_STATUS *ppServices,
        DWORD * lpServicesReturned,
        const TCHAR * pszGroupName )
{
    APIERR err = NERR_Success;
    DWORD cbBytesNeeded = 0;

    if (pszGroupName && *pszGroupName == TCH('\0'))
    {
        pszGroupName = NULL;
    }

    if ( !::EnumServiceGroupW( QueryHandle(), dwServiceType, dwServiceState,
        (LPENUM_SERVICE_STATUS)_buffer.QueryPtr(), _buffer.QuerySize(),
        &cbBytesNeeded, lpServicesReturned, 0, pszGroupName ))
    {
        if (( err = ::GetLastError()) == ERROR_MORE_DATA )
        {
            //
            //  We need to enlarge our buffer to get all
            //  of the enumeration data.  We'll also throw
            //  in some slop space, just in case someone
            //  creates a new service between these two
            //  API calls.
            //

            cbBytesNeeded += (DWORD)_buffer.QuerySize() + SERVICE_ENUM_SLOP;

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {
                if ( !::EnumServiceGroupW( QueryHandle(), dwServiceType,
                    dwServiceState, (LPENUM_SERVICE_STATUS)_buffer.QueryPtr(),
                    _buffer.QuerySize(), &cbBytesNeeded, lpServicesReturned, 0, pszGroupName ))
                {
                    err = ::GetLastError();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_MANAGER::EnumServiceStatus returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }

    *ppServices = err
                ? NULL
                : (LPENUM_SERVICE_STATUS) _buffer.QueryPtr();
    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER::Lock

    SYNOPSIS:   Lock a specified database

    RETURNS:    Possible errors:
                ERROR_ACCESS_DENIED - The specified handle was not opened with
                        SC_MANAGER_LOCK access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_SERVICE_DATABASE_LOCKED - The database is locked.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::Lock()
{
    APIERR err = NERR_Success;

    _scLock = ::LockServiceDatabase( QueryHandle() );
    if ( _scLock == NULL )
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER::Unlock

    SYNOPSIS:   Unlock a specified database

    RETURNS:    NERR_Success - OK
                ERROR_INVALID_SERVICE_LOCK - The specified lock is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::Unlock()
{
    APIERR err = NERR_Success;

    if ( ! ::UnlockServiceDatabase( _scLock ))
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER::QueryLockStatus

    SYNOPSIS:   examine the lock status on a specified database

    ENTRY:      LPQUERY_SERVICE_LOCK_STATUS *ppLockStatus - A pointer to a
                        buffer to receive a QUERY_SERVICE_LOCK_STATUS
                        information structure.

    EXIT:       lpLockStatus - status information

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - The specified handle was not opened with
                        SC_MANAGER_QUERY_LOCK_STATUS access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - the supplied output buffer is too
                        small for the QUERY_SERVICE_LOCK_STATUS information
                        structure. Nothing is written to the supplied output
                        buffer.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::QueryLockStatus(
        LPQUERY_SERVICE_LOCK_STATUS *ppLockStatus )
{
    DWORD cbBytesNeeded = 0;
    APIERR err = NERR_Success;

    if ( ! ::QueryServiceLockStatus( QueryHandle(),
        (LPQUERY_SERVICE_LOCK_STATUS)_buffer.QueryPtr(), _buffer.QuerySize(),
        &cbBytesNeeded ))
    {
        if (( err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER )
        {
            cbBytesNeeded *= 2 ;  // BUGBUG

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {

                if ( ! ::QueryServiceLockStatus( QueryHandle(),
                    (LPQUERY_SERVICE_LOCK_STATUS)_buffer.QueryPtr(),
                    _buffer.QuerySize(), &cbBytesNeeded ))
                {
                    err = ::GetLastError();
                }
                else
                {
                    *ppLockStatus = (LPQUERY_SERVICE_LOCK_STATUS)_buffer.QueryPtr();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_MANAGER::QueryLockStatus returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }
    else
    {
        *ppLockStatus = (LPQUERY_SERVICE_LOCK_STATUS)_buffer.QueryPtr();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_MANAGER :: QueryServiceDisplayName

    SYNOPSIS:   Returns the display name of a service given its key name.

    ENTRY:      pszKeyName              - The key name of a service.

                pnlsDisplayName         - Will receive the display name.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 17-Nov-1992     Created.

********************************************************************/
APIERR SC_MANAGER :: QueryServiceDisplayName( const TCHAR * pszKeyName,
                                              NLS_STR     * pnlsDisplayName )
{
    UIASSERT( pszKeyName != NULL );
    UIASSERT( pnlsDisplayName != NULL )
    UIASSERT( pnlsDisplayName->QueryError() == NERR_Success );

    //
    //  Determine the appropriate buffer size.
    //

    BUFFER buffer( SNLEN * sizeof(TCHAR) );

    APIERR err = buffer.QueryError();

    if( err == NERR_Success )
    {
        DWORD cchNeeded = (DWORD)buffer.QuerySize() / sizeof(TCHAR);

        if( !::GetServiceDisplayName( QueryHandle(),
                                      pszKeyName,
                                      (TCHAR *)buffer.QueryPtr(),
                                      &cchNeeded ) )
        {
            err = (APIERR)::GetLastError();
        }

        if( err == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            //  Resize the buffer & try again.
            //

            err = buffer.Resize( (UINT)cchNeeded * sizeof(TCHAR) );

            if( err == NERR_Success )
            {
                cchNeeded = (DWORD)buffer.QuerySize();

                if( !::GetServiceDisplayName( QueryHandle(),
                                              pszKeyName,
                                              (TCHAR *)buffer.QueryPtr(),
                                              &cchNeeded ) )
                {
                    err = (APIERR)::GetLastError();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_MANAGER::QueryServiceDisplayName returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cchNeeded " << cchNeeded );
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Return the name back to the caller.
        //

        err = pnlsDisplayName->CopyFrom( (TCHAR *)buffer.QueryPtr() );
    }
    else
    {
        DBGEOL( "GetServiceDisplayName returned " << err );

        //
        //  Return the key name.
        //

        err = pnlsDisplayName->CopyFrom( pszKeyName );
    }

    return err;

}   // SC_MANAGER :: QueryServiceDisplayName

/*******************************************************************

    NAME:       SC_MANAGER :: QueryServiceKeyName

    SYNOPSIS:   Returns the key name of a service given its display name.

    ENTRY:      pszDisplayName          - The key name of a service.

                pnlsKeyName             - Will receive the display name.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo 17-Nov-1992     Created.

********************************************************************/
APIERR SC_MANAGER :: QueryServiceKeyName( const TCHAR * pszDisplayName,
                                          NLS_STR     * pnlsKeyName )
{
    UIASSERT( pszDisplayName != NULL );
    UIASSERT( pnlsKeyName != NULL )
    UIASSERT( pnlsKeyName->QueryError() == NERR_Success );

    //
    //  Determine the appropriate buffer size.
    //

    BUFFER buffer( SNLEN * sizeof(TCHAR) );

    APIERR err = buffer.QueryError();

    if( err == NERR_Success )
    {
        DWORD cchNeeded = (DWORD)buffer.QuerySize() / sizeof(TCHAR);

        if( !::GetServiceKeyName( QueryHandle(),
                                  pszDisplayName,
                                  (TCHAR *)buffer.QueryPtr(),
                                  &cchNeeded ) )
        {
            err = (APIERR)::GetLastError();
        }

        if( err == ERROR_INSUFFICIENT_BUFFER )
        {
            //
            //  Resize the buffer & try again.
            //

            err = buffer.Resize( (UINT)cchNeeded * sizeof(TCHAR) );

            if( err == NERR_Success )
            {
                cchNeeded = (DWORD)buffer.QuerySize();

                if( !::GetServiceKeyName( QueryHandle(),
                                          pszDisplayName,
                                          (TCHAR *)buffer.QueryPtr(),
                                          &cchNeeded ) )
                {
                    err = (APIERR)::GetLastError();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_MANAGER::QueryServiceKeyName returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cchNeeded " << cchNeeded );
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Return the name back to the caller.
        //

        err = pnlsKeyName->CopyFrom( (TCHAR *)buffer.QueryPtr() );
    }

    return err;

}   // SC_MANAGER :: QueryServiceKeyName


#ifdef _BUILD_263_

/*******************************************************************

    NAME:       SC_MANAGER::UpdateLastKnownGood

    SYNOPSIS:   Update the last-know-good configuration with the configuration
                which the system was booted from.

    RETURNS:    NERR_Success - ok
                ERROR_INVALID_HANDLE - The specified handle is invalid
                ERROR_ACCESS_DENIED - The specified handle was not opened with
                        SC_MANAGER_UPDATE_LASTKNOWGOOD access.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_MANAGER::UpdateLastKnownGood()
{
    APIERR err = NERR_Success;

    if ( ! ::UpdateServiceLastKnownGood( QueryHandle() ))
    {
        err = ::GetLastError();
    }
    return err;
}

#endif // _BUILD_263_

/*******************************************************************

    NAME:       SC_SERVICE::SC_SERVICE

    SYNOPSIS:   constructor - create a new service object

    ENTRY:      const SC_MANAGER & scManager - sc manager database
                const TCHAR * pszServiceName - service name
                const TCHAR * pszDisplayName - display name
                UINT dwAccess - access code. See winsvc.h for detail.
                UINT dwServiceType - Value to indicate the type of
                    service this is.
                        SERVICE_WIN32_OWN_PROCESS - a service which runs in its
                            own Win32 process.
                        SERVICE_WIN32_SHARE_PROCESS - a service which shares a
                            Win32 process with other services.
                        SERVICE_DRIVER - an NT device driver.
                UINT dwStartType - value to specify when to start the
                    service.
                        SERVICE_BOOT_START - Only valid if service type is
                            SERVICE_DRIVER. This device driver is to be started
                            by the OS loader.
                        SERVICE_SYSTEM_START - Only valid if service type is
                            SERVICE_DRIVER. This device driver is to be
                            started by IoInitSystem.
                        SERVICE_AUTO_START - valid for both SERVICE_DRIVER and
                            SERVICE_WIN32 service types. This service is
                            started by the service control manager when a start
                            request is issued via the StartService API.
                        SERVICE_DISABLE - This service can no longer be started.
                UINT dwErrorControl - value to specify the severity of
                    the error if this service fails to start during boot so
                    that the appropriate action can be taken.
                        SERVICE_ERROR_NORMAL - log error but system continues
                            to boot.
                        SERVICE_ERROR_SEVERE - log error, and the system is
                            rebooted with the last-known-good configuration.
                            If the current configuration is last-known-good,
                            press on with boot.
                        SERVICE_ERROR_CRITICAL - log error if possible, and
                            system is rebooted with last-known-good
                            configuration. If the current is last-know-good,
                            boot fails.
                const TCHAR * lpBinaryPathName - fully-qualified path name to the
                    the service binary file.
                const TCHAR * lpLoadOrderGroup - optional group name parameter
                const TCHAR * lpDependencies - space-separate names of services
                    whuch must be running before this service can run. An
                    empty string means that this service has no depencies.
                const TCHAR * lpServiceStartName - if service type is
                    SERVICE_WIN32, this name is the account name on the form
                    of "DomainName\Username" which the service process will
                    be logged on as when it runs. If the account belongs to
                    the built-in domain, ".\Username" can be specified. If
                    service type is SERVICE_DRIVER, this name must be the NT
                    driver object name (eg \FileSystem\LanManRedirector or
                    \Driver\Xns ) which the I/O system uses to load the device
                    driver.
                const TCHAR * lpPassword - Password to the account name specified
                    by lpServiceStartName if service type if SERVICE_WIN32.
                    This password will be changed periodically by the service
                    control manager so that it will not expire. If service
                    type is SERVICE_DRIVER, this parameter is ignored.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_SERVICE::SC_SERVICE(
        const SC_MANAGER & scManager,
        const TCHAR *pszServiceName,
        const TCHAR *pszDisplayName,
        UINT dwServiceType,
        UINT dwStartType,
        UINT dwErrorControl,
        const TCHAR * pszBinaryPathName,
        const TCHAR * pszLoadOrderGroup,
        const TCHAR * pszDependencies,
        const TCHAR * pszServiceStartName,
        const TCHAR * pszPassword,
        UINT dwAccess )
{
    APIERR err = NERR_Success;

    SC_HANDLE hService = ::CreateService( scManager.QueryHandle(),
                                         (TCHAR *) pszServiceName,
                                         (TCHAR *) pszDisplayName,
                                         dwAccess,
                                         dwServiceType,
                                         dwStartType,
                                         dwErrorControl,
                                         pszBinaryPathName,
                                         pszLoadOrderGroup,
                                         NULL,
                                         pszDependencies,
                                         pszServiceStartName,
                                         pszPassword );

    SetHandle( hService );

    if ( hService == NULL )
    {
        ReportError( ::GetLastError());
    }
}

/*******************************************************************

    NAME:       SC_SERVICE::SC_SERVICE

    SYNOPSIS:   constructure - Open an existed service object

    ENTRY:      const SC_MANAGER & scManager - the sc manager database
                const TCHAR * pszServiceName - service name
                UINT dwAccess - access code. See winsvc.h for more
                        detail.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_SERVICE::SC_SERVICE(
        const SC_MANAGER & scManager,
        const TCHAR * pszServiceName,
        UINT dwAccess )
{
    SC_HANDLE hService = ::OpenService( scManager.QueryHandle(),
                                        (TCHAR *)pszServiceName,
                                        dwAccess );
    SetHandle( hService );

    if ( hService == NULL )
    {
        ReportError( ::GetLastError() );
    }
}

/*******************************************************************

    NAME:       SC_SERVICE::~SC_SERVICE

    SYNOPSIS:   destructor - close the handle


    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

SC_SERVICE::~SC_SERVICE()
{
    if ( Close() != NERR_Success )
    {
        DBGEOL( SZ("Error: Cannot close service") );
    }
}

/*******************************************************************

    NAME:       SC_SERVICE::QueryConfig

    SYNOPSIS:   examine the service configuration parameters

    ENTRY:      LPQUERY_SERVICE_CONFIG lpServiceConfig - a pointer to a
                    buffer to receive a QUERY_SERVICE_CONFIG information
                    structure.

    EXIT:       lpServiceConfig - QUERY_SERVUCE_CONFIG information

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specifide handle was not opened with
                    SERVICE_QUERY_CONFIG access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - there is more service configuration
                    information than would fit into the supplied output buffer.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::QueryConfig(
        LPQUERY_SERVICE_CONFIG *ppServiceConfig )
{
    APIERR err = NERR_Success;
    DWORD cbBytesNeeded = 0;

    if ( !::QueryServiceConfig( QueryHandle(),
        (LPQUERY_SERVICE_CONFIG)_buffer.QueryPtr(),
        _buffer.QuerySize(), & cbBytesNeeded ))
    {
        if (( err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER )
        {
            cbBytesNeeded *= 2 ;  // BUGBUG

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {
                if ( !::QueryServiceConfig( QueryHandle(),
                    (LPQUERY_SERVICE_CONFIG)_buffer.QueryPtr(),
                    _buffer.QuerySize(), & cbBytesNeeded ))
                {
                    err = ::GetLastError();
                }
                else
                {
                    *ppServiceConfig = (LPQUERY_SERVICE_CONFIG)_buffer.QueryPtr();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_SERVICE::QueryConfig returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }
    else
    {
        *ppServiceConfig = (LPQUERY_SERVICE_CONFIG)_buffer.QueryPtr();
    }
    return err;

}

/*******************************************************************

    NAME:       SC_SERVICE::QueryStatus

    SYNOPSIS:   examine the service status

    ENTRY:      LPSERVICE_STATUS lpServiceStatus - a pointer to a buffer to
                    receive a SERVICE_STATUS information structure.

    EXIT:       lpServiceStatus - contains SERVICE_STATUS information structure.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    SERVICE_QUERY_STATUS access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::QueryStatus( LPSERVICE_STATUS lpServiceStatus )
{
    APIERR err = NERR_Success;

    if ( !::QueryServiceStatus( QueryHandle(), lpServiceStatus ))
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::Control

    SYNOPSIS:   sends a control to a service

    ENTRY:      UINT dwControl - value which indicates the requested
                    control.
                    SERVICE_CONTROL_STOP - requests the service to stop.
                    SERVICE_CONTROL_PAUSE - requests the service to pause.
                    SERVICE_CONTROL_CONTINUE - requests the paused service to
                        resume.
                    SERVICE_CONTROL_INTERROGATE - requests that the service
                        updates the service control manager of its status
                        information immediately.
                LPSERVICE_STATUS lpServiceStatus - a pointer to a buffer to
                    receive a SERVICE_STATUS information structure.

    EXIT:       lpServiceStatus - receive a SERVICE_STATUS information
                    structure.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened
                    with control access requested.
                ERROR_DEPENDENT_SERVICES_RUNNING - a stop control has been
                    sent to the service which other running services are
                    dependent on.
                ERROR_SERVICE_REQUEST_TIMEOUT - the service did not respond
                    to the start request in a timely fashion.
                ERROR_INVALID_SERVICE_CONTROL - the requested control is not
                    valid, or is unacceptable to the service.
                ERROR_SERVICE_CANNOT_ACCEPT_CTRL - The requested control cannot
                    be sent to the service becayse the state of the service is
                    stopped, stop-pending, or start-pending.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::Control(
        UINT dwControl,
        LPSERVICE_STATUS lpServiceStatus )
{
    APIERR err = NERR_Success;

    if ( !::ControlService( QueryHandle(), dwControl, lpServiceStatus ))
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::ChangeConfig

    SYNOPSIS:   change the service configuration parameters

    ENTRY:      UINT dwServiceType - value to indicate the type of
                    service this is.
                        SERVICE_WIN32_OWN_PROCESS - a service which runs its
                            own Win32 process.
                        SERVICE_WIN32_SHARE_PROCESS - a service which shares a
                            Win32 process with other services.
                        SERVICE_DRIVER - an NT Device driver
                        SERVICE_NO_CHANGE - do not modify existing ServiceType
                            value.
                UINT dwStartType - value to specify when to start the
                    service.
                        SERVICE_BOOT_START - only valid if service type is
                            SERVICE_DRIVER. This device driver is to be started
                            by the OS loader.
                        SERVICE_SYSTEM_START - Only valid if service type is
                            SERVICE_DRIVER. This device driver is to be started
                            by IoInitSystem.
                        SERVICE_AUTO_START - valid for both SERVICE_DRIVER and
                            SERVICE_WIN32 service types. This service is
                            started by the service control manager when a start
                            request is issued via the StartService API.
                        SERVICE_DISABLE - This service can no longer be started.
                        SERVICE_NO_CHANGE - do not modify existing StartType
                            value.
                UINT dwErrorControl - value to specify the severity of
                    the error if this service fails to start during boot so
                    that the appropriate action can be taken.
                        SERVICE_ERROR_NORMAL - log error but system continues
                            to boot.
                        SERVICE_ERROR_SEVERE - log error, and the system is
                            rebooted with the last-known-good configuration.
                            If the current configuration is last-known-good,
                            press on with boot.
                        SERVICE_ERROR_CRITICAL - log error if possible, and
                            system is rebooted with last-known-good
                            configuration. If the current is last-know-good,
                            boot fails.
                        SERVICE_NO_CHANGE - do not modify existing StartType
                            value.
                const TCHAR * lpBinaryPathName - fully-qualified path name to the
                    the service binary file.
                const TCHAR * lpDependencies - space-separate names of services
                    whuch must be running before this service can run. An
                    empty string means that this service has no depencies.
                const TCHAR * lpServiceStartName - if service type is
                    SERVICE_WIN32, this name is the account name on the form
                    of "DomainName\Username" which the service process will
                    be logged on as when it runs. If the account belongs to
                    the built-in domain, ".\Username" can be specified. If
                    service type is SERVICE_DRIVER, this name must be the NT
                    driver object name (eg \FileSystem\LanManRedirector or
                    \Driver\Xns ) which the I/O system uses to load the device
                    driver.
                const TCHAR * lpPassword - Password to the account name specified
                    by lpServiceStartName if service type if SERVICE_WIN32.
                    This password will be changed periodically by the service
                    control manager so that it will not expire. If service
                    type is SERVICE_DRIVER, this parameter is ignored.
                const TCHAR * pszDisplayName - Display name for the service.

    RETURNS:    NERR_Success - no problem
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    SERVICE_CHANGE_CONFIG access.
                ERROR_INVALID_SERVICE_ACCOUNT - the account name does not exist,
                    or the service is specified to share the same binary file
                    as an already installed service but has an account name that
                    is not the same as installed service.
                ERROR_INVALID_PARAMETER - A parameter specified is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::ChangeConfig(
        UINT dwServiceType,
        UINT dwStartType,
        UINT dwErrorControl,
        const TCHAR * pszBinaryPathName,
        const TCHAR * pszLoadOrderGroup,
        const TCHAR * pszDependencies,
        const TCHAR * pszServiceStartName,
        const TCHAR * pszPassword,
        const TCHAR * pszDisplayName )
{
    APIERR err = NERR_Success;

    if ( !::ChangeServiceConfig( QueryHandle(),
                                 dwServiceType,
                                 dwStartType,
                                 dwErrorControl,
                                 pszBinaryPathName,
                                 pszLoadOrderGroup,
                                 NULL,
                                 pszDependencies,
                                 pszServiceStartName,
                                 pszPassword,
                                 pszDisplayName ) )
    {
        err = ::GetLastError();
    }

    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::Start

    SYNOPSIS:   begin the execution of a service

    ENTRY:      UINT dwNumServiceArgs - number of arguments in the
                    lpServiceArgs string. This value is passed on to the
                    service begin started.
                const TCHAR **ppszServiceArgs - An array of argument strings
                    passed on to a service for its use of receiving startup
                    parameters.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened
                    with SERVICE_START access.
                ERROR_INVALID_HANDLE - the handle is invalid.
                ERROR_PATH_NOT_FOUND - The service binary file could not be
                    found.
                ERROR_SERVICE_ALREADY_RUNNING - An instance of the service is
                    already running.
                ERROR_SERVICE_REQUEST_TIMEOUT - the service did not respond to
                    the start request in a timely fashion.
                ERROR_SERVICE_NO_THREAD - A thread could not be created for the
                    Win32 service.
                ERROR_SERVICE_DATABASE_LOCKED - the database is locked.
                ERROR_SERVICE_DISABLED - the service has been disabled.
                ERROR_SERVICE_DEPENDENCY_FAIL - the service depends on
                    another service which has failed to start.
                ERROR_SERVICE_LOGON_FAILED - The service could not be logged on.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::Start(
        UINT dwNumServiceArgs,
        const TCHAR **ppszServiceArgs )
{
    APIERR err = NERR_Success;

    if ( !::StartService( QueryHandle(),
                          dwNumServiceArgs,
                          ppszServiceArgs ) )
    {
        err = ::GetLastError();
    }
    return err;
}


/*******************************************************************

    NAME:       SC_SERVICE::Delete

    SYNOPSIS:   remove the service from the Service Control Manager database

    RETURNS:    NERR_Success - OK
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    DELETE access.
                ERROR_INVALID_HANDLE - the handle is invalid
                ERROR_INVALID_SERVICE_STATE - attempted to delete a service
                    that has not stopped. The service must be stopped first.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::Delete()
{
    APIERR err = NERR_Success;

    if ( !::DeleteService( QueryHandle() ))
    {
        err = ::GetLastError();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::EnumDependent

    SYNOPSIS:   enumerate services that depend on the specified service

    ENTRY:      UINT deServiceState - Value of select the services to
                    enumerate based on the running state. It must be one or the
                    bitwise OR of the following values:
                        SERVICE_ACTIVE - enumerate services that have started
                            which includes services that are running, paused,
                            and in pendinf states.
                        SERVICE_INACTIVE - enumerate services that are stopped.
                LPENUM_SERVICE_STATUS *ppServices - A pointer to a buffer to
                    receive an array of service entries; each entry is the
                    ENUM_SERVICE_STATUS information status.
                UINT * lpServicesReturned - A pointer to a variable to
                    receive the number of service entries returned.

    EXIT:       lpService - receive an array of service entries.
                lpServicesReturned - number of service entries returned.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    SERVICE_ENUMERATE_DEPENDENTS access.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - there are more service entries than would fit
                    into the supplied output buffer.
                ERROR_INVALID_PARAMETER - a parameter specified in invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::EnumDependent(
        UINT dwServiceState,
        LPENUM_SERVICE_STATUS *ppServices,
        DWORD * lpServicesReturned )
{
    APIERR err = NERR_Success;
    DWORD cbBytesNeeded = 0;

    *ppServices = NULL ; // init to NULL
    *lpServicesReturned = 0 ;

    if ( !::EnumDependentServices( QueryHandle(), dwServiceState,
        (LPENUM_SERVICE_STATUS)_buffer.QueryPtr(), _buffer.QuerySize(),
        &cbBytesNeeded, lpServicesReturned ))
    {
        // JonN 3/20/95: Check for both MORE_DATA and INSUFFICIENT_BUFFER;
        //  not sure if downlevel can return INSUFFICIENT_BUFFER or not
        if (( err = ::GetLastError()) == ERROR_MORE_DATA
                              || (err == ERROR_INSUFFICIENT_BUFFER) )
        {
            //
            //  We need to enlarge our buffer to get all
            //  of the enumeration data.  We'll also throw
            //  in some slop space, just in case someone
            //  creates a new service between these two
            //  API calls.
            //

            cbBytesNeeded += (DWORD)_buffer.QuerySize() + SERVICE_ENUM_SLOP;

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {
                if ( !::EnumDependentServices( QueryHandle(), dwServiceState,
                    (LPENUM_SERVICE_STATUS)_buffer.QueryPtr(),
                    _buffer.QuerySize(), &cbBytesNeeded, lpServicesReturned ))
                {
                    err = ::GetLastError();
                }
                else
                {
                    *ppServices = (LPENUM_SERVICE_STATUS)_buffer.QueryPtr();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_SERVICE::EnumDependent returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }
    else
    {
        *ppServices = (LPENUM_SERVICE_STATUS)_buffer.QueryPtr();
    }
    return err;
}

/*******************************************************************

    NAME:       SC_SERVICE::QuerySecurity

    SYNOPSIS:   examine the security descriptor of a service object

    ENTRY:      SECURITY_INFORMATION dwSecurityInformation - Indicates
                    which security information is to be applied to the object.
                    The values to be returned are passed in the
                    lpSecurityDescriptor parameter/
                    THe security information is specified using the following
                    bit flags:
                        OWNER_SECURITY_INFORMATION (object's owner SID is being
                            referenced)
                        GROUP_SECURITY_INFORMATION (object's group SID is being
                            referenced)
                        DACL_SECURITY_INFORMATION (object's discretionary ACL is
                            being referenced)
                        SACL_SECURITY_INFORMATION (object's system ACL is being
                            reference)
                PSECURITY_DESCRIPTOR lpSecurityDescriptor - a pointer to a
                    buffer to receive a copy of the security descriptor of the
                    service object.

    EXIT:       lpSecurityDescriptor - receive the security descriptor of the
                    service object.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    READ_CONTROL access, or the caller is not the owner of the
                    object.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INSUFFICIENT_BUFFER - the specified output buffer is
                    smaller than the required size returned in pcbBytesNeeded.
                ERROR_INVALID_PARAMETER - the specified security information
                    is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::QuerySecurity(
        SECURITY_INFORMATION dwSecurityInformation,
        PSECURITY_DESCRIPTOR *ppSecurityDescriptor )
{
    APIERR err = NERR_Success;
    DWORD cbBytesNeeded = 0;

    if ( !::QueryServiceObjectSecurity( QueryHandle(), dwSecurityInformation,
        (PSECURITY_DESCRIPTOR)_buffer.QueryPtr(), _buffer.QuerySize(),
        &cbBytesNeeded ))
    {
        if (( err = ::GetLastError()) == ERROR_INSUFFICIENT_BUFFER )
        {
            cbBytesNeeded *= 2 ;  // BUGBUG

            if (( err = _buffer.Resize( (UINT)cbBytesNeeded )) == NERR_Success )
            {
                if ( !::QueryServiceObjectSecurity( QueryHandle(),
                    dwSecurityInformation, (PSECURITY_DESCRIPTOR)_buffer.QueryPtr(),
                     _buffer.QuerySize(), &cbBytesNeeded ))
                {
                    err = ::GetLastError();
                }
                else
                {
                    *ppSecurityDescriptor=(PSECURITY_DESCRIPTOR)_buffer.QueryPtr();
                }
            }
        }
        if (err != NERR_Success)
        {
            DBGEOL( "NETUI: SC_SERVICE::QuerySecurity returns "
                 << err
                 << ", bufsize " << _buffer.QuerySize()
                 << ", cbBytesNeeded " << cbBytesNeeded );
        }
    }
    else
    {
        *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR)_buffer.QueryPtr();
    }
    return err;
}


/*******************************************************************

    NAME:       SC_SERVICE::SetSecurity

    SYNOPSIS:   modify the security descriptor of a service object

    ENTRY:      SECURITY_INFORMATION dwSecurityInformation - Indicates
                    which security information is to be applied to the object.
                    The value(s) to be assigned are passed in the
                    lpSecurityDescriptor parameter.
                    The security information is specified using the following
                    bit flags:
                        OWNER_SECURITY_INFORMATION( Object's owner SID is
                            being referenced)
                        GROUP_SECURITY_INFORMATION( Object's group SID is
                            begin referenced)
                        DCAL_SECURITY_INFORMATION( object's discretionary ACL
                            is being referenced)
                        SACL)SECURITY_INFORMATION( object's system ACL is being
                            referenced)
                const PSECURITY_DESCRIPTOR lpSecurityDescriptor - A pointer
                    to a well-formed security descriptor.

    RETURNS:    NERR_Success - ok
                ERROR_ACCESS_DENIED - the specified handle was not opened with
                    the required access, or the caller is not the owner of the
                    object.
                ERROR_INVALID_HANDLE - the specified handle is invalid.
                ERROR_INVALID_PARAMETER - the specified security information or
                    security descriptor is invalid.

    HISTORY:
        terryk  04-May-1992     Created

********************************************************************/

APIERR SC_SERVICE::SetSecurity(
        SECURITY_INFORMATION dwSecurityInformation,
        const PSECURITY_DESCRIPTOR lpSecurityDescriptor )
{
    APIERR err = NERR_Success;
    if ( !::SetServiceObjectSecurity( QueryHandle(), dwSecurityInformation,
        lpSecurityDescriptor ))
    {
        err = ::GetLastError();
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\uintlsa.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
 * This module contains the wrappers for LSA-based objects.
 *
 *
 * History
 *	thomaspa	01/17/92	Created from ntsam.cxx
 */

#include "pchlmobj.hxx"  // Precompiled header



/*******************************************************************

    NAME: LSA_MEMORY::LSA_MEMORY

    SYNOPSIS: Constructor

    ENTRY: pvBuffer - pointer to the LSA allocated buffer
	   cItems - count of items in buffer

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_MEMORY::LSA_MEMORY( BOOL fOwnerAlloc )
	: NT_MEMORY( ),
	_fOwnerAlloc( fOwnerAlloc )
{
    if ( QueryError() != NERR_Success )
	return;
}

/*******************************************************************

    NAME: LSA_MEMORY::~LSA_MEMORY()

    SYNOPSIS: Destructor.  Deallocates the LSA allocated buffer

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_MEMORY::~LSA_MEMORY()
{
    Set( NULL, 0 );
}



/*******************************************************************

    NAME: LSA_TRANSLATED_NAME_MEM::LSA_TRANSLATED_NAME_MEM

    SYNOPSIS: Constructor

    ENTRY: pvBuffer - pointer to the LSA allocated buffer
	   cItems - count of items in buffer

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_TRANSLATED_NAME_MEM::LSA_TRANSLATED_NAME_MEM( BOOL fOwnerAlloc )
    : LSA_MEMORY( fOwnerAlloc )
{
}


/*******************************************************************

    NAME: LSA_TRANSLATED_NAME_MEM::~LSA_TRANSLATED_NAME_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_TRANSLATED_NAME_MEM::~LSA_TRANSLATED_NAME_MEM()
{
}


/*******************************************************************

    NAME: LSA_TRANSLATED_SID_MEM::LSA_TRANSLATED_SID_MEM

    SYNOPSIS: Constuctor

    ENTRY:

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_TRANSLATED_SID_MEM::LSA_TRANSLATED_SID_MEM( BOOL fOwnerAlloc )
    : LSA_MEMORY( fOwnerAlloc )
{
}


/*******************************************************************

    NAME: LSA_TRANSLATED_SID_MEM::~LSA_TRANSLATED_SID_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_TRANSLATED_SID_MEM::~LSA_TRANSLATED_SID_MEM()
{
}

/*******************************************************************

    NAME:	LSA_TRANSLATED_SID_MEM::QueryFailingNameIndex

    SYNOPSIS:	Finds the first name that failed from the lookup

    ENTRY:	pi - Receives the index

    RETURNS:	TRUE if a failing index was found, FALSE otherwise

    NOTES:

    HISTORY:
	Johnl	10-Dec-1992	Created

********************************************************************/

BOOL LSA_TRANSLATED_SID_MEM::QueryFailingNameIndex( ULONG * pi )
{
    UIASSERT( pi != NULL ) ;

    if ( QueryPtr() == NULL )
    {
	*pi = 0 ;
	return TRUE ;
    }

    ULONG cItems = QueryCount() ;
    for ( ULONG i = 0 ; i < cItems ; i++ )
    {
	//
	//  Look at the SID_NAME_USE.  The RID is zero for Everyone and
	//  Creator Owner
	//
	if ( (QueryPtr()[i].Use == SidTypeUnknown) ||
	     (QueryPtr()[i].Use == SidTypeInvalid) )
	{
	    *pi = i ;
	    return TRUE ;
	}
    }

    return FALSE ;
}

/*******************************************************************

    NAME: LSA_TRUST_INFO_MEM::LSA_TRUST_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_TRUST_INFO_MEM::LSA_TRUST_INFO_MEM( BOOL fOwnerAlloc )
	: LSA_MEMORY( fOwnerAlloc )
{
}




/*******************************************************************

    NAME: LSA_TRUST_INFO_MEM::~LSA_TRUST_INFO_MEM

    SYNOPSIS: Destructor

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_TRUST_INFO_MEM::~LSA_TRUST_INFO_MEM()
{
}





/*******************************************************************

    NAME: LSA_REF_DOMAIN_MEM::LSA_REF_DOMAIN_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_REF_DOMAIN_MEM::LSA_REF_DOMAIN_MEM( BOOL fOwnerAlloc )
    : LSA_MEMORY( fOwnerAlloc )
{
}



/*******************************************************************

    NAME: LSA_REF_DOMAIN_MEM::~LSA_REF_DOMAIN_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created

********************************************************************/
LSA_REF_DOMAIN_MEM::~LSA_REF_DOMAIN_MEM()
{
}




/*******************************************************************

    NAME: LSA_ACCT_DOM_INFO_MEM::LSA_ACCT_DOM_INFO

    SYNOPSIS: Constructor

    ENTRY:


    NOTES: This NT_MEMORY-based object is slightly different from the
	others in that it only ever contains a single item.

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_ACCT_DOM_INFO_MEM::LSA_ACCT_DOM_INFO_MEM( BOOL fOwnerAlloc )
	: LSA_MEMORY( fOwnerAlloc )
{
}



/*******************************************************************

    NAME: LSA_ACCT_DOM_INFO_MEM::~LSA_ACCT_DOM_INFO

    SYNOPSIS: Destructor

    ENTRY:


    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_ACCT_DOM_INFO_MEM::~LSA_ACCT_DOM_INFO_MEM()
{
}

/*******************************************************************

    NAME: LSA_PRIMARY_DOM_INFO_MEM::LSA_PRIMARY_DOM_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:


    NOTES: This NT_MEMORY-based object is slightly different from the
	others in that it only ever contains a single item.

    HISTORY:
	DavidHov  04/9/92	Created

********************************************************************/
LSA_PRIMARY_DOM_INFO_MEM::LSA_PRIMARY_DOM_INFO_MEM( BOOL fOwnerAlloc )
	: LSA_MEMORY( fOwnerAlloc )
{
}

/*******************************************************************

    NAME: LSA_PRIMARY_DOM_INFO_MEM::~LSA_PRIMARY_DOM_INFO

    SYNOPSIS: Destructor

    ENTRY:

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
LSA_PRIMARY_DOM_INFO_MEM::~LSA_PRIMARY_DOM_INFO_MEM()
{
}

/*******************************************************************

    NAME: LSA_AUDIT_EVENT_INFO_MEM::LSA_AUDIT_EVENT_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:

    NOTES: This MEM object is slightly different from the others in
	that it only ever contains a single item.

    HISTORY:
	Yi-HsinS	04/01/92	Created

********************************************************************/

LSA_AUDIT_EVENT_INFO_MEM::LSA_AUDIT_EVENT_INFO_MEM( BOOL fOwnerAlloc )
	: LSA_MEMORY( fOwnerAlloc )
{
}

/*******************************************************************

    NAME: LSA_AUDIT_EVENT_INFO_MEM::~LSA_AUDIT_EVENT_INFO_MEM

    SYNOPSIS: Destructor

    ENTRY:


    NOTES:

    HISTORY:
	Yi-HsinS	04/01/92	Created

********************************************************************/

LSA_AUDIT_EVENT_INFO_MEM::~LSA_AUDIT_EVENT_INFO_MEM()
{
}

/*******************************************************************

    NAME: LSA_OBJECT::LSA_OBJECT

    SYNOPSIS: Constructor

    ENTRY: none

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
LSA_OBJECT::LSA_OBJECT()
    : BASE(),
    _hlsa( NULL ),
    _fHandleValid( FALSE )
{
    if ( QueryError() != NERR_Success )
	return;
}



/*******************************************************************

    NAME: LSA_OBJECT::~LSA_OBJECT

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
LSA_OBJECT::~LSA_OBJECT()
{
    CloseHandle() ;
}


/*******************************************************************

    NAME:       LSA_OBJECT::CloseHandle

    SYNOPSIS:   Explict close of handle

    ENTRY:

    EXIT:

    NOTES:      No error is reported if the handle
                has already been closed (invalidated).

    HISTORY:    DavidHov   4/12/92
	 	ChuckC     7/6/92	removed needless assert

********************************************************************/
APIERR LSA_OBJECT :: CloseHandle ( BOOL fDelete )
{
    APIERR err = NERR_Success ;

    if ( _fHandleValid )
    {
        if ( _hlsa != NULL )
        {
            NTSTATUS ntStatus = fDelete
                                ? ::LsaDelete( QueryHandle() )
                                : ::LsaClose( QueryHandle() ) ;

            err = ERRMAP::MapNTStatus( ntStatus ) ;
        }
        ResetHandle() ;
    }
    return err ;
}


/*******************************************************************

    NAME: LSA_POLICY::LSA_POLICY

    SYNOPSIS: Constructor

    ENTRY: pszServerName.  Name of computer on which LSA information
	is desired.  On a LAN Manager for NT cluster, this should
	always be the name of the PDC.

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
LSA_POLICY::LSA_POLICY( const TCHAR * pszServerName,
		       ACCESS_MASK accessDesired )
    : LSA_OBJECT(),
    _lsplType( LSPL_PROD_NONE )
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err = Open( pszServerName, accessDesired ) ;

    if ( err )
        ReportError( err ) ;
}




/*******************************************************************

    NAME: LSA_POLICY::~LSA_POLICY

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
LSA_POLICY::~LSA_POLICY()
{
}

/*******************************************************************

    NAME:       LSA_POLICY::Open

    SYNOPSIS:   Obtain an LSA Policy Handle.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:    DavidHov 4/12/92   Separated from constructor
	
********************************************************************/
APIERR LSA_POLICY :: Open (
    const TCHAR * pszServerName,
    ACCESS_MASK accessDesired )
{
    UNICODE_STRING unistrServerName;
    PUNICODE_STRING punistrServerName = NULL ;
    LSA_HANDLE hlsa;
    OBJECT_ATTRIBUTES oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    APIERR err = 0 ;

    CloseHandle() ;

    if ( pszServerName != NULL && ::strlenf(pszServerName) != 0 )
    {
	NLS_STR nlsServerName = pszServerName;

	if ( err = ::FillUnicodeString( &unistrServerName, nlsServerName ) )
	{
	    return err ;
	}
	punistrServerName = &unistrServerName;
    }
    else
    {
	punistrServerName = NULL;
    }

    InitObjectAttributes( &oa, &sqos );

    err = ERRMAP::MapNTStatus( ::LsaOpenPolicy( punistrServerName,
					 &oa,
					 accessDesired,
					 &hlsa ) );

    if ( err == NERR_Success )
    {
	SetHandle( hlsa );
    }

    if ( punistrServerName != NULL )
    {
	::FreeUnicodeString( punistrServerName );
    }

    return err ;
}


/*******************************************************************

    NAME: LSA_POLICY::TranslateSidsToNames

    SYNOPSIS: Wrapper for LsaLookupSids()

    ENTRY: ppsids - array of PSIDS to look up
	   cSids - Count of PSIDS to look up
	   plsatnm - NT_MEMORY object to receive the data
	   plsardm - NT_MEMORY object to receive referenced domain info

    EXIT: NERR_Success or error code.

    NOTES:

    HISTORY:
	thomaspa	02/22/92	Created from ntsam.hxx

********************************************************************/
APIERR LSA_POLICY::TranslateSidsToNames( const PSID *ppsids,
					ULONG cSids,
                                	LSA_TRANSLATED_NAME_MEM *plsatnm,
					LSA_REF_DOMAIN_MEM *plsardm)
{
    NTSTATUS ntStatus ;
    APIERR err ;

    ASSERT( ppsids != NULL );
    ASSERT( *ppsids != NULL );
    ASSERT( plsatnm != NULL );
    ASSERT( plsardm != NULL );

    if ( cSids == 0 )
	return ERRMAP::MapNTStatus( STATUS_NONE_MAPPED );

    PLSA_REFERENCED_DOMAIN_LIST plsardl = NULL;
    PLSA_TRANSLATED_NAME plsatn = NULL;

    ntStatus =	::LsaLookupSids( QueryHandle(),
	                         cSids,
	                         (PSID *)ppsids,
	                         & plsardl,
	                         & plsatn );

    if ( ntStatus == STATUS_NONE_MAPPED )
    {
        ntStatus = STATUS_SOME_NOT_MAPPED;
    }
    // BUGBUG:  ERRMAP should do the following mapping correctly.
    //          the mapping above is temporary till that status is
    //          correctly NOT an error.

    err = ntStatus == STATUS_NO_MORE_ENTRIES
        ? ERROR_NO_MORE_ITEMS
        : ERRMAP::MapNTStatus( ntStatus ) ;

    if ( err == NERR_Success )
    {
        ASSERT( plsatn != NULL && plsardl != NULL );
	plsatnm->Set( plsatn, plsatn ? cSids : 0 ) ;
        plsardm->Set( plsardl, plsardl ? plsardl->Entries : 0 );
    }
    else
    {
        if ( plsardl )
           ::LsaFreeMemory( plsardl ) ;
        if ( plsatn )
           ::LsaFreeMemory( plsatn ) ;
    }

    return err;
}

/*******************************************************************

    NAME: LSA_POLICY::TranslateNamesToSids

    SYNOPSIS: Wrapper for LsaLookupNames()

    ENTRY: apszAccountNames - An array of '\0' terminated ANSI strings
	   cAccountNames - Count of items in apszAccountNames
	   plsatsidmem - NT_MEMORY object to receive the data
	   plsardm - NT_MEMORY object to receive referenced domain info

    EXIT: NERR_Success or error code.

    NOTES:

    HISTORY:
	JohnL	    08-Apr-1992     Copied from TranslateSidsToNames

********************************************************************/

APIERR LSA_POLICY::TranslateNamesToSids(
			     const TCHAR * const    * apszAccountNames,
			     ULONG		      cAccountNames,
			     LSA_TRANSLATED_SID_MEM * plsatsidmem,
			     LSA_REF_DOMAIN_MEM     * plsardm )
{
    ASSERT( cAccountNames == 0 || apszAccountNames != NULL );
    ASSERT( cAccountNames == 0 || *apszAccountNames != NULL );
    ASSERT( plsatsidmem != NULL );
    ASSERT( plsardm != NULL );

    if ( cAccountNames == 0 )
	return ERRMAP::MapNTStatus( STATUS_NONE_MAPPED );

    APIERR err = NERR_Success ;

    /* Build an array of UNICODE_STRINGs out of the array of cAccountNames
     */
    PUNICODE_STRING aUniStr = (PUNICODE_STRING) new UNICODE_STRING[cAccountNames] ;
    if ( aUniStr == NULL )
    {
	return ERROR_NOT_ENOUGH_MEMORY ;
    } else if ( err = TcharArrayToUnistrArray( apszAccountNames,
					       aUniStr,
					       cAccountNames ))
    {
	return err ;
    }

    PLSA_REFERENCED_DOMAIN_LIST plsardl;
    PLSA_TRANSLATED_SID plsasid;

    err = ERRMAP::MapNTStatus( ::LsaLookupNames( QueryHandle(),
						 cAccountNames,
						 aUniStr,
						 &plsardl,
						 &plsasid ) );

    if ( err == NERR_Success )
    {
	plsatsidmem->Set( plsasid, cAccountNames );
        plsardm->Set( plsardl, plsardl ? plsardl->Entries : 0 );
    }

    CleanupUnistrArray( aUniStr, cAccountNames ) ;
    delete aUniStr ;

    return err;
}


/*******************************************************************

    NAME: LSA_POLICY::EnumerateTrustedDomains

    SYNOPSIS: returns a list of trusted domains

    ENTRY: plsatim -	pointer to a LSA_TRUST_INFO_MEMORY object to
			receive the data.

	   plsaenumh -	pointer to enumeration handle
			This should initially point to a variable initialized
			to 0.  If the call returns ERROR_MORE_DATA, then
			another call should be made using the returned
			plsaenumh to get the next block of data.

	   cbRequested - recommended maximum amount of info to return

    EXIT:  NERR_Success or ERROR_MORE_DATA on success.

    NOTES:

    HISTORY:
	thomaspa	03/05/92	Created from ntsam.hxx

********************************************************************/
APIERR LSA_POLICY::EnumerateTrustedDomains (
    LSA_TRUST_INFO_MEM * plsatim,
    PLSA_ENUMERATION_HANDLE plsaenumh,
    ULONG cbRequested )
{
    ASSERT( plsatim != NULL );

    PVOID pvBuffer;
    ULONG cItems;

    APIERR err = ERRMAP::MapNTStatus(
			::LsaEnumerateTrustedDomains( QueryHandle(),
						      plsaenumh,
						      &pvBuffer,
						      cbRequested,
						      &cItems ) );

    if ( err == NERR_Success || err == ERROR_MORE_DATA )
    {
	plsatim->Set( pvBuffer, cItems );
    }

    return err;


}



/*******************************************************************

    NAME: LSA_POLICY::GetAccountDomain

    SYNOPSIS: returns name and sid of Account domain.

    ENTRY: plsaadim - pointer to a LSA_ACCT_DOM_INFO_MEM object to
	receive the data.

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/05/92	Created from ntsam.hxx

********************************************************************/
APIERR LSA_POLICY::GetAccountDomain(
    LSA_ACCT_DOM_INFO_MEM *plsaadim )  const
{

    PVOID pvBuffer;

    ASSERT( plsaadim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::LsaQueryInformationPolicy( QueryHandle(),
					     PolicyAccountDomainInformation,
					     &pvBuffer ) );
    if ( err == NERR_Success )
    {
	plsaadim->Set( pvBuffer, 1 );
    }

    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::GetAuditEventInfo

    SYNOPSIS: Get the audit events info from LSA

    ENTRY:    plsaaeim - pointer to a LSA_AUDIT_EVENT_INFO_MEM
                         object to receive the data.

    EXIT:

    NOTES:

    HISTORY:
	Yi-HsinS	04/01/92	Created

********************************************************************/

APIERR LSA_POLICY::GetAuditEventInfo( LSA_AUDIT_EVENT_INFO_MEM *plsaaeim )
{

    PVOID pvBuffer = NULL;

    ASSERT( plsaaeim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::LsaQueryInformationPolicy( QueryHandle(),
					     PolicyAuditEventsInformation,
					     &pvBuffer ) );
    if ( err == NERR_Success )
    {
	plsaaeim->Set( pvBuffer, 1 );
    }

    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::SetAuditEventInfo

    SYNOPSIS: Set the audit events info back to the LSA

    ENTRY:    plsaaeim - pointer to a LSA_AUDIT_EVENT_INFO_MEM
                         object for the data to set.

    EXIT:

    NOTES:

    HISTORY:
	Yi-HsinS	04/01/92	Created

********************************************************************/
APIERR LSA_POLICY::SetAuditEventInfo( LSA_AUDIT_EVENT_INFO_MEM *plsaaeim )
{

    ASSERT( plsaaeim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::LsaSetInformationPolicy(  QueryHandle(),
					    PolicyAuditEventsInformation,
					    (PVOID) plsaaeim->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::CheckIfShutDownOnFull

    SYNOPSIS: Query if we shut down the system when the security log is full

    ENTRY:

    EXIT:     fShutDownOnFull - TRUE if the system will be shut down
                                when security log is full, FALSE otherwise.

    RETURNS:

    NOTES:

    HISTORY:
	Yi-HsinS	04/13/92	Created

********************************************************************/

APIERR LSA_POLICY::CheckIfShutDownOnFull( BOOL *pfShutDownOnFull )
{

    UIASSERT( pfShutDownOnFull != NULL );

    PVOID pvBuffer = NULL;

    APIERR err = ERRMAP::MapNTStatus(
	      ::LsaQueryInformationPolicy( QueryHandle(),
		        		   PolicyAuditFullQueryInformation,
					   &pvBuffer ) );
    if ( err == NERR_Success )
    {
        UIASSERT( pvBuffer != NULL );

        *pfShutDownOnFull =
             (( PPOLICY_AUDIT_FULL_QUERY_INFO ) pvBuffer)->ShutDownOnFull;

        ::LsaFreeMemory( pvBuffer );
    }

    return err;
}


/*******************************************************************

    NAME:     LSA_POLICY::SetShutDownOnFull

    SYNOPSIS: Set the info to shut down the system when security log is full
              back to the LSA

    ENTRY:    fShutDownOnFull - TRUE if we want to shut down when
                                security log is full, FALSE otherwise.

    EXIT:

    NOTES:

    HISTORY:
	Yi-HsinS	04/13/92	Created

********************************************************************/

APIERR LSA_POLICY::SetShutDownOnFull( BOOL fShutDownOnFull )
{

    POLICY_AUDIT_FULL_SET_INFO AuditFullInfo;

    AuditFullInfo.ShutDownOnFull = (fShutDownOnFull != FALSE);


    APIERR err = ERRMAP::MapNTStatus(
		::LsaSetInformationPolicy(  QueryHandle(),
					    PolicyAuditFullSetInformation,
					    (PVOID) &AuditFullInfo ));

    return err;
}


/********************************************************************

    NAME:      LSA_POLICY::GetPrimaryDomain

    SYNOPSIS:  returns name and sid of Primary domain.

    ENTRY:     plsapdim - pointer to a LSA_PRIMARY_DOM_INFO_MEM object to
               receive the data.

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/05/92	Created from ntsam.hxx

********************************************************************/
APIERR LSA_POLICY::GetPrimaryDomain (
    LSA_PRIMARY_DOM_INFO_MEM * plsapdim ) const
{

    PVOID pvBuffer;

    ASSERT( plsapdim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::LsaQueryInformationPolicy( QueryHandle(),
					     PolicyPrimaryDomainInformation,
					     &pvBuffer ) );
    if ( err == NERR_Success )
    {
	plsapdim->Set( pvBuffer, 1 );
    }

    return err;
}




/*******************************************************************

    NAME: LSA_POLICY::InitObjectAttributes

    SYNOPSIS:

    This function initializes the given Object Attributes structure, including
    Security Quality Of Service.  Memory must be allcated for both
    ObjectAttributes and Security QOS by the caller.

    ENTRY:

    poa - Pointer to Object Attributes to be initialized.

    psqos - Pointer to Security QOS to be initialized.

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/05/92	Created from ntsam.hxx

********************************************************************/
VOID LSA_POLICY::InitObjectAttributes( POBJECT_ATTRIBUTES poa,
				       PSECURITY_QUALITY_OF_SERVICE psqos )

{
    ASSERT( poa != NULL );
    ASSERT( psqos != NULL );

    psqos->Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    psqos->ImpersonationLevel = SecurityImpersonation;
    psqos->ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    psqos->EffectiveOnly = FALSE;

    //
    // Set up the object attributes prior to opening the LSA.
    //

    InitializeObjectAttributes( poa,
				NULL,
				0L,
				NULL,
				NULL );

    //
    // The InitializeObjectAttributes macro presently stores NULL for
    // the psqos field, so we must manually copy that
    // structure for now.
    //

    poa->SecurityQualityOfService = psqos;
}

//  End of UINTLSA.CXX

/*******************************************************************

    NAME:	LSA_POLICY::TcharArrayToUnistrArray

    SYNOPSIS:	Initializes each element in the unicode array with
		the appropriate data from the corresponding element
		in the TCHAR array.

    ENTRY:	apsz - Array of TCHAR * strings used to initialize
		    the unicode array
		aUniStr - Array of UNICODE_STRINGs to be initialized
		cElements - Count of elements in apsz

    RETURNS:	NERR_Success if successful, error code otherwise

    NOTES:	The method allocates memory for each element of the
		array.	Call CleanupUnistrArray to deallocate this
		memory.

		There must be at least cElements in aUniStr.  No
		checking is performed to confirm this.

		If an error is returned, this method will have cleaned
		up after itself before returning.

    HISTORY:
	Johnl	08-Apr-1992	Created

********************************************************************/

APIERR LSA_POLICY::TcharArrayToUnistrArray( const TCHAR * const *   apsz,
					    PUNICODE_STRING aUniStr,
					    ULONG	    cElements )
{
    APIERR err = NERR_Success ;

    for ( ULONG i = 0 ; i < cElements ; i++ )
    {
	ALIAS_STR nlsString( apsz[i] ) ;
	UINT cb = (nlsString.QueryTextLength() + 1) * sizeof(WCHAR) ;
	aUniStr[i].Buffer = (PWSTR) new BYTE[ cb ] ;
	if ( aUniStr[i].Buffer == NULL )
	{
	    err = ERROR_NOT_ENOUGH_MEMORY ;
	    break ;
	}

	if ( err = nlsString.MapCopyTo( (WCHAR *) aUniStr[i].Buffer, cb ))
	{
	    break ;
	}

	aUniStr[i].Length = (USHORT) nlsString.QueryTextLength()*sizeof(WCHAR);
	aUniStr[i].MaximumLength = (USHORT) cb ;
    }

    if ( err )
    {
	CleanupUnistrArray( aUniStr, i + 1 ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:	LSA_POLICY::CleanupUnistrArray

    SYNOPSIS:	Deletes the Buffer member of each element in the
		UNICODE_STRING array

    ENTRY:	aUniStr - Array of UNICODE_STRINGs
		cElementsConstructed - The number of elements in the
		    array that contain allocated data

    EXIT:

    NOTES:

    HISTORY:
	Johnl	08-Apr-1992	Created

********************************************************************/

void LSA_POLICY::CleanupUnistrArray( PUNICODE_STRING aUniStr,
				     ULONG	     cElementsAllocated )
{
    for ( ULONG i = 0 ; i < cElementsAllocated ; i++ )
    {
	delete aUniStr[i].Buffer ;
	aUniStr[i].Buffer = NULL ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\ossid.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    Ossid.cxx

    This file contains wrapper classes for the Win32 SID structure.

    FILE HISTORY:
        Johnl   04-May-1992     Broke off from security.cxx

*/

#include "pchlmobj.hxx"  // Precompiled header


#ifndef max
#define max(a,b)   ((a)>(b)?(a):(b))
#endif

/* The initial allocation size for an NT SID.  The basic structure plus
 * seven sub-authorities (what most users will have).
 */
#define STANDARD_SID_SIZE  (sizeof(SID) + 7*sizeof(ULONG))

/*******************************************************************

    NAME:       OS_OBJECT_WITH_DATA::OS_OBJECT_WITH_DATA

    SYNOPSIS:   Constructor/Destructor for this class

    ENTRY:      cbInitSize - Initial size of the class buffer

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   11-Dec-1991     Created

********************************************************************/

OS_OBJECT_WITH_DATA::OS_OBJECT_WITH_DATA( UINT cbInitSize )
    : BASE(),
      _buffOSData( cbInitSize )
{
    if ( QueryError() )
        return ;

    if ( _buffOSData.QueryError() )
        ReportError( _buffOSData.QueryError() ) ;
}

OS_OBJECT_WITH_DATA::~OS_OBJECT_WITH_DATA()
{
    Resize( 0 ) ;
}

/*******************************************************************

    NAME:       OS_SID::OS_SID

    SYNOPSIS:   Constructor/Destructor for the OS_SID class

    ENTRY:      psid - Pointer to valid SID this OS_SID will operate on
                       (optionally copies the SID) or NULL if we are
                       creating a SID from scratch.
                fCopy - Set to FALSE if *psid should not be copied, TRUE
                       if *psid should be copied.

    EXIT:       The SID will be initialized (if appropriate) and validated.
                A construction error of ERROR_INVALID_PARAMETER will be
                set if an invalid SID is passed in.

    RETURNS:

    NOTES:

    HISTORY:
        Johnl   12-Dec-1991     Created

********************************************************************/

OS_SID::OS_SID( PSID psid,
                BOOL fCopy,
                OS_SECURITY_DESCRIPTOR * pOwner )
    : OS_OBJECT_WITH_DATA( (UINT)((psid == NULL) || fCopy ? STANDARD_SID_SIZE : 0 )),
      _psid( NULL ),
      _pOwner( pOwner )
{
    if ( QueryError() )
        return ;

    _psid = (psid == NULL ? (PSID) QueryPtr() : psid ) ;

    if ( psid == NULL )
    {
        /* We are using our internal memory for the SID, so initialize
         * it appropriately.
         */
        UIASSERT( !fCopy ) ;
        OS_SID::InitializeMemory( (void *) _psid ) ;
        UIASSERT( IsValid() ) ;
    }
    else
    {
        /* The user passed us a SID, check to see if it is valid.
         */
        if ( !IsValid() )
        {
            UIASSERT(!SZ("Invalid SID!")) ;
            ReportError( ERROR_INVALID_PARAMETER ) ;
            return ;
        }

        if ( fCopy )
        {
            APIERR err = Resize( (UINT) ::GetLengthSid( psid ) ) ;
            if ( err )
            {
                _psid = NULL ;
                ReportError( err ) ;
                return ;
            }

            _psid = (PSID) QueryPtr() ;
            UIASSERT( !IsOwnerAlloc() ) ;

            /* QueryAllocSize contains the size of our memory chunk because
             * we know we aren't OwnerAlloced at this point.
             */
            if (!::CopySid( QueryAllocSize(), (PSID) *this, psid ) )
            {
                ReportError( ::GetLastError() ) ;
                return ;
            }
        }
    }

    UIASSERT( IsValid() ) ;
}

OS_SID::OS_SID( PSID  psidDomain,
                ULONG ridAccount,
                OS_SECURITY_DESCRIPTOR * pOwner )
    : OS_OBJECT_WITH_DATA( ::GetLengthSid( psidDomain ) + sizeof(ridAccount)),
      _psid( NULL ),
      _pOwner( pOwner )
{
    if ( QueryError() )
        return ;

    APIERR err = NERR_Success ;

    do { // Error breakout

        if ( !::IsValidSid( psidDomain ) )
        {
            DBGEOL(SZ("OS_SID::OS_SID - Invalid domain SID")) ;
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        _psid = (PSID) QueryPtr() ;
        if ( !::CopySid( QueryAllocSize(), _psid, psidDomain ))
        {
            err = ::GetLastError() ;
            break ;
        }

        /* Get the sub-authority count field and increment it by one, then
         * set the last sub-authority to be the user's RID.
         */
        UCHAR * pcSubAuthorities ;
        if ( err = QuerySubAuthorityCount( &pcSubAuthorities ))
        {
            DBGEOL(SZ("OS_SID::OS_SID - Error getting sub-authority count")) ;
            break ;
        }
        (*pcSubAuthorities)++ ;

        ULONG * pulSubAuthority ;
        if ( err = QuerySubAuthority( *pcSubAuthorities-1, &pulSubAuthority ))
        {
            DBGEOL(SZ("OS_SID::OS_SID - Error getting sub-authority count")) ;
            break ;
        }

        *pulSubAuthority = ridAccount ;
    } while (FALSE) ;

    if ( err )
    {
        ReportError( err ) ;
    }
    else
    {
        UIASSERT( IsValid() ) ;
    }
}



OS_SID::~OS_SID()
{
    _psid = NULL ;
}

/*******************************************************************

    NAME:       OS_SID::InitializeMemory

    SYNOPSIS:   The static method initializes a chunk of memory as a
                static valid SID.

    ENTRY:      pMemToInitAsSID - Pointer to memory that will contain
                    the SID.  It should be at lease STANDARD_SID_SIZE bytes.

    EXIT:       The memory can be used as a blank SID.

    NOTES:

    HISTORY:
        Johnl   12-Dec-1991     Created

********************************************************************/

void OS_SID::InitializeMemory( void * pMemToInitAsSID )
{
    UIASSERT( pMemToInitAsSID != NULL ) ;

    /* BUGBUG - probably isn't safe, make it static or something
     */
    SID_IDENTIFIER_AUTHORITY sidIDAuthority ;
    UCHAR achIDAuthority[] = SECURITY_NULL_SID_AUTHORITY ;
    for ( int i = 0 ; i < 6 ; i++ )
    {
        sidIDAuthority.Value[i] = achIDAuthority[i] ;
    }

    /* Initialize SID
     */
    ::InitializeSid( (PSID) pMemToInitAsSID,
                     &sidIDAuthority,
                     0 ) ;
}

/*******************************************************************

    NAME:       OS_SID::IsValid

    SYNOPSIS:   Checks the validity of this SID

    RETURNS:    Returns TRUE if the OS thinks we contain a valid SID,
                FALSE otherwise.

    NOTES:

    HISTORY:
        Johnl   12-Dec-1991     Created

********************************************************************/

BOOL OS_SID::IsValid( void ) const
{
    return !QueryError() && ::IsValidSid( _psid ) ;
}

/*******************************************************************

    NAME:       OS_SID::QueryLength

    SYNOPSIS:   Gets the amount of memory this SID occupies

    RETURNS:    Returns the count of bytes this SID uses or 0 if the
                SID is not valid.

    NOTES:

    HISTORY:
        Johnl   10-Feb-1992     Created

********************************************************************/

ULONG OS_SID::QueryLength( void ) const
{
    if ( !IsValid() )
        return 0 ;

    return ::GetLengthSid( (PSID) *this) ;
}


/*******************************************************************

    NAME:       OS_SID::QueryRawID

    SYNOPSIS:   Places the text string of the Identifier Authority into
                *pnlsRawID. The text string will look something like "1-5-17"

    ENTRY:      pnlsRawID - Pointer to NLS_STR that will receive the string

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      CODEWORK - Change to use new Rtl routine

    HISTORY:
        Johnl   12-Dec-1991     Created
        beng    05-Mar-1992     Replaced wsprintf

********************************************************************/

APIERR OS_SID::QueryRawID( NLS_STR * pnlsRawID ) const
{
    UIASSERT( IsValid() ) ;
    APIERR err ;
    UNICODE_STRING UniStr ;

    if ( (err = ERRMAP::MapNTStatus( ::RtlConvertSidToUnicodeString(
                                                         &UniStr,
                                                         QueryPSID(),
                                                         TRUE ))) ||
         (err = pnlsRawID->MapCopyFrom( UniStr.Buffer,
                                        UniStr.Length)) )
    {
        /* Fall through
         */
    }

    if ( !err )
    {
        ::RtlFreeUnicodeString( &UniStr ) ;
    }

    return err ;
}

/*******************************************************************

    NAME:       OS_SID::QueryName

    SYNOPSIS:   Retrieves the User/Group name from user accounts database
                that is associated with this SID.

                The name *may* come back with a domain qualifier also (TBD).

    ENTRY:      pnlsName - NLS_STR that will receive the text string,
                pszServer - Machine to lookup account on
                pszFocus  - What machine is considered to have the "focus"
                    If NULL, then the focus is assumed to be pszServer.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      pszFocus is used to determine the correct domain name
                qualification.  It should contain a server name (in the
                form of "\\server") that has the focus.  If the focus is
                on a domain, then it should contain a BDC or PDC for that
                domain.

                What the above means is that if pszServer is different from
                pszFocus, then the returned name will probably be qualified
                by a domain name (i.e., "NtLan\Johnl").

    HISTORY:
        Johnl   12-Dec-1991     Created
        Johnl   17-Jul-1992     Added server parameter and real lookup

********************************************************************/

APIERR OS_SID::QueryName( NLS_STR * pnlsName,
                          const TCHAR * pszServer,
                          PSID psidFocusedDomain ) const
{
    APIERR err ;
    PSID apsid[1] ;
    STRLIST strlistNames ;

    API_SESSION APISessionTarget( pszServer ) ;
    LSA_POLICY  LSAPolicyTarget( pszServer ) ;
    OS_SID      ossidFocusedDomain( psidFocusedDomain ) ;
    apsid[0] = (PSID) *this ;

    if ((err = APISessionTarget.QueryError())  ||
        (err = LSAPolicyTarget.QueryError())   ||
        (err = ossidFocusedDomain.QueryError())  )
    {
        DBGEOL("OS_SID::QueryName - Error " << (ULONG) err
                << " returned from LSAPolicy") ;
        return err ;
    }

    //
    //  If we weren't given a focused domain SID to qualify the name with,
    //  then use the current user's domain SID.
    //

    if ( psidFocusedDomain == NULL )
    {
        if ( (err = NT_ACCOUNTS_UTILITY::QuerySystemSid(
                                                  UI_SID_CurrentProcessUser,
                                                  &ossidFocusedDomain )) ||
             (err = ossidFocusedDomain.TrimLastSubAuthority()) )
        {
            return err ;
        }
    }


    if ((err = NT_ACCOUNTS_UTILITY::GetQualifiedAccountNames(
                                      LSAPolicyTarget,
                                      ossidFocusedDomain.QueryPSID(),
                                      apsid,
                                      1,
                                      TRUE,
                                      &strlistNames,
                                      NULL,
                                      NULL,
                                      NULL,
                                      pszServer )))
    {
        DBGEOL("OS_SID::QueryName - Error " << (ULONG) err
                << " returned from GetQualifiedAccountNames") ;
        return err ;
    }

    /* Set each of the account names to the looked up name
     */
    ITER_STRLIST iterNames( strlistNames ) ;
    NLS_STR * pnlsNameTmp ;
    if ( (pnlsNameTmp = iterNames.Next()) == NULL )
    {
        /* If everything succeeded, then there should always be at least
         * one name in the strlist.
         */
        UIASSERT( FALSE ) ;
        return ERROR_INVALID_PARAMETER ;
    }

    return pnlsName->CopyFrom( *pnlsNameTmp ) ;
}

#if 0
/*******************************************************************

    NAME:       OS_SID::QueryName

    SYNOPSIS:   Retrieves the User/Group name from user accounts database
                that is associated with this SID.

    ENTRY:      pnlsName - NLS_STR that will receive the text string,
                pszServer - Machine to lookup account on
                pszFocus  - What machine is considered to have the "focus"
                    If NULL, then the focus is assumed to be pszServer.

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise

    NOTES:      pszFocus is used to determine the correct domain name
                qualification.  It should contain a server name (in the
                form of "\\server") that has the focus.  If the focus is
                on a domain, then it should contain a BDC or PDC for that
                domain.

                What the above means is that if pszServer is different from
                pszFocus, then the returned name will probably be qualified
                by a domain name (i.e., "NtLan\Johnl").

    CAVEAT:     This method creates an LSA_POLICY and SAM_DOMAIN to get the
                domain SID.  It is very preferable to use the other version
                of QueryName that accepts a PSID for the focus.

    HISTORY:
        Johnl   12-Dec-1991     Created
        Johnl   17-Jul-1992     Added server parameter and real lookup

********************************************************************/

APIERR OS_SID::QueryName( NLS_STR * pnlsName,
                          const TCHAR * pszServer,
                          const TCHAR * pszFocus ) const
{
    APIERR err ;
    if ( pszFocus == NULL )
        pszFocus = pszServer ;

    API_SESSION APISessionFocus ( pszFocus  ) ;
    LSA_ACCT_DOM_INFO_MEM LSAAcctDomInfoMem ;
    LSA_POLICY LSAPolicyFocus( pszFocus ) ;
    SAM_SERVER SAMServer( pszFocus ) ;

    if ((err = APISessionFocus.QueryError())   ||
        (err = LSAAcctDomInfoMem.QueryError()) ||
        (err = LSAPolicyFocus.QueryError())    ||
        (err = LSAPolicyFocus.GetAccountDomain( &LSAAcctDomInfoMem )) ||
        (err = SAMServer.QueryError()) )
    {
        DBGEOL("OS_SID::QueryName - Error " << (ULONG) err
                << " returned from SAMServer or LSAPolicy") ;
        return err ;
    }

    SAM_DOMAIN SAMDomain( SAMServer, LSAAcctDomInfoMem.QueryPSID() ) ;
    if ((err = SAMDomain.QueryError()) ||
        (err = QueryName( pnlsName, pszServer, SAMDomain.QueryPSID() )) )
    {
        /* Fall through
         */
    }

    return err ;
}

#endif

/*******************************************************************

    NAME:       OS_SID::QuerySubAuthority

    SYNOPSIS:   Retrieves a pointer to the requested sub-authority

    ENTRY:      iSubAuthority - Sub-authority index to retrieve
                ppulSubAuthority - Pointer to a pointer of the sub-authority
                    requested

    EXIT:       ppulSubAuthority will point to the request subauthority

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The API GetSidSubAuthority does not return an error code,
                thus this method could fail and still return success.

    HISTORY:
        Johnl   16-Mar-1992     Created

********************************************************************/

APIERR OS_SID::QuerySubAuthority( UCHAR iSubAuthority,
                                  PULONG * ppulSubAuthority ) const
{
    *ppulSubAuthority = ::GetSidSubAuthority( _psid, iSubAuthority ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       QuerySubAuthorityCount

    SYNOPSIS:   Retrieves a pointer to the sub-authority count field

    ENTRY:      ppucSubAuthority - Pointer to a pointer of the sub-authority
                    count field

    EXIT:       ppcSubAuthority will point to the sub-authority count field

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The API GetSidSubAuthorityCount does not return an error code,
                thus this method could fail and still return success.

    HISTORY:
        Johnl   16-Mar-1992     Created

********************************************************************/

APIERR OS_SID::QuerySubAuthorityCount( UCHAR * * ppcSubAuthority ) const
{
    *ppcSubAuthority = ::GetSidSubAuthorityCount( _psid ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       QueryLastSubAuthority

    SYNOPSIS:   Retrieves a pointer to the last sub-authority, which is
                the RID for SIDS which have RIDs.

    EXIT:       *ppulrid will point to the last sub-authority

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The API GetSidSubAuthorityCount does not return an error code,
                thus this method could fail and still return success.

    HISTORY:
        JonN    30-Oct-1992     Created

********************************************************************/

APIERR OS_SID::QueryLastSubAuthority( PULONG * ppulSubAuthority ) const
{
    ASSERT( ppulSubAuthority != NULL );
    UCHAR * pcSubAuthorityCount = NULL;
    APIERR err = QuerySubAuthorityCount( &pcSubAuthorityCount );
    if ( err == NERR_Success )
    {
        ASSERT( pcSubAuthorityCount != NULL );
        err = QuerySubAuthority( (*pcSubAuthorityCount)-1, ppulSubAuthority );
    }
    return err ;
}

/*******************************************************************

    NAME:       TrimLastSubAuthority

    SYNOPSIS:   Removes the last SubAuthority.  This will change user,
                group and alias SIDs into the SID for their domain.

    RETURNS:    NERR_Success if successful, error code otherwise.

    NOTES:      The API GetSidSubAuthorityCount does not return an error code,
                thus this method could fail and still return success.

    HISTORY:
        JonN    04-Nov-1992     Created
        JonN    17-Nov-1992     Added pulLastSubAuthority param

********************************************************************/

APIERR OS_SID::TrimLastSubAuthority( ULONG * pulLastSubAuthority )
{
    UCHAR * pcSubAuthorityCount = NULL;
    APIERR err = QuerySubAuthorityCount( &pcSubAuthorityCount );
    if ( err == NERR_Success )
    {
        ASSERT( pcSubAuthorityCount != NULL );
        ASSERT( *pcSubAuthorityCount > 0 );
        if ( *pcSubAuthorityCount > 0 )
        {
            if (pulLastSubAuthority != NULL)
            {
                PULONG pulTempLastSubAuthority;
                err = QuerySubAuthority( (*pcSubAuthorityCount)-1,
                                         &pulTempLastSubAuthority );
                if (err == NERR_Success)
                {
                    *pulLastSubAuthority = *pulTempLastSubAuthority;
                }
            }

            (*pcSubAuthorityCount)--;
        }
    }
    return err ;
}

/*******************************************************************

    NAME:       OS_SID::operator==

    SYNOPSIS:   Checks for equality between two SIDs

    ENTRY:      ossid - SID to compare *this to

    EXIT:

    RETURNS:    Returns TRUE if the SIDs are equal, FALSE if they are unequal
                or invalid.

    NOTES:

    HISTORY:
        Johnl   12-Dec-1991     Created

********************************************************************/

BOOL OS_SID::operator==( const OS_SID & ossid ) const
{
    if ( !IsValid() || !ossid.IsValid() )
    {
        UIASSERT(!SZ("Attempted to compare an invalid SID")) ;
        return FALSE ;
    }

    return ::EqualSid( QuerySid(), ossid.QuerySid() ) ;
}

/*******************************************************************

    NAME:       OS_SID::Copy

    SYNOPSIS:   Copies the source SID to *this if there is enough size

    ENTRY:      ossid - SID to copy into *this

    EXIT:

    RETURNS:    NERR_Success if successful, error code otherwise
                ERROR_INSUFFICIENT_BUFFER is returned if this is an
                owner alloced SID and the source SID will not fit.

    NOTES:

    HISTORY:
        Johnl   26-Dec-1991     Created

********************************************************************/

APIERR OS_SID::Copy( const OS_SID & ossid )
{
    ULONG cbSrcSidSize = ::GetLengthSid( (PSID)ossid ) ;
    ULONG cbDestBuffSize = 0 ;

    if ( QueryError() )
        return QueryError() ;

    if ( IsOwnerAlloc() )
    {
        /* If there isn't enough space in a SID that we don't own the
         * memory for, then we return an error.
         */
        cbDestBuffSize = ::GetLengthSid( (PSID)*this ) ;
        if ( cbSrcSidSize > cbDestBuffSize )
            return ERROR_INSUFFICIENT_BUFFER ;
    }
    else
    {
        /* Check if we have to realloc our memory to fit the new SID size.
         */
        cbDestBuffSize = QueryAllocSize() ;
        if ( cbSrcSidSize > cbDestBuffSize )
        {
            /* SIDs shouldn't get larger then 256 bytes
             */
            APIERR err ;
            if ( err = Resize( (UINT) cbSrcSidSize ))
                return err ;

            _psid = (PSID) QueryPtr() ;

            /* If this SID is part of a security descriptor, update our
             * security descriptor with our new memory location.
             */
            if ( _pOwner != NULL )
            {
                if ( err = _pOwner->UpdateReferencedSecurityObject( this ))
                {
                    return err ;
                }
            }

            /* We have a new destination buffer size now.
             */
            cbDestBuffSize = QueryAllocSize() ;
        }
    }

    if ( !::CopySid( cbDestBuffSize, (PSID) *this, (PSID) ossid ) )
        return ::GetLastError() ;

    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SID::SetPtr

    SYNOPSIS:   Points this OS_SID at a new SID

    ENTRY:      psid - Memory to use as new SID

    EXIT:       *this will now operate on the sid pointed at by psid

    RETURNS:    NERR_Success if everything is valid, error code otherwise

    NOTES:

    HISTORY:
        Johnl   17-Dec-1991     Created

********************************************************************/

APIERR OS_SID::SetPtr( PSID psid )
{
    if ( !::IsValidSid( psid ) )
        return ERROR_INVALID_PARAMETER ;

    _psid = psid ;

    UIASSERT( IsValid() ) ;
    return NERR_Success ;
}

/*******************************************************************

    NAME:       OS_SID::_DbgPrint

    SYNOPSIS:   Takes apart this SID and outputs it to cdebug

    ENTRY:

    NOTES:      Doesn't print sub-authorities, can be modified to do so

    HISTORY:
        Johnl   30-Dec-1991     Created

********************************************************************/

void OS_SID::_DbgPrint( void ) const
{
#if defined(DEBUG)
    APIERR err ;
    cdebug << SZ("\tIsOwnerAlloc      = ") << (IsOwnerAlloc() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;
    if ( !IsOwnerAlloc() )
        cdebug << SZ("\tQueryAllocSize    = ") << QueryAllocSize() << dbgEOL ;
    cdebug << SZ("\tLength of SID     = ") << ::GetLengthSid( (PSID)*this ) << dbgEOL ;
    cdebug << SZ("\tIsValid           = ") << (IsValid() ? SZ("TRUE") : SZ("FALSE")) << dbgEOL ;

    NLS_STR nlsRawID(10) ;
    if ( err = QueryRawID( &nlsRawID ) )
        cdebug << SZ("\tQueryRawID returned error ") << err << dbgEOL ;
    else
        cdebug << SZ("\tQueryRawID        = ") << (const TCHAR *) nlsRawID << dbgEOL ;

#if 0
    NLS_STR nlsName(50) ;
    if ( err = QueryName( &nlsName ) )
        cdebug << SZ("\tQueryName returned error ") << err << dbgEOL ;
    else
        cdebug << SZ("\tQueryName         = ") << (const TCHAR *) nlsName << dbgEOL ;
#endif

    UCHAR * pcSubAuthorities ;
    if ( err = QuerySubAuthorityCount( &pcSubAuthorities ) )
        cdebug << SZ("\tQuerySubAuthorityCount returned error ") << err << dbgEOL ;
    else
        cdebug << SZ("\tQuerySubAuthorityCount = ") << (UINT) *pcSubAuthorities << dbgEOL ;
#endif  // DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\ntuser.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		   Copyright(c) Microsoft Corp., 1990		     **/
/**********************************************************************/

/*
 * This module contains the wrappers to NT-specific infolevels of the
 * USER object.  These infolevels are only supported on an NT server; at
 * present, they may only be called from an NT client.
 *
 *
 * HISTORY:
 *	jonn	01/21/92	Created.
 *	jonn     2/26/92	Fixups for 32-bit
 *      jonn    04/27/92        Implemented add'l accessors
 *	thomaspa 04/29/92	Set PrimaryGroup in W_CreateNew
 *      jonn    05/02/92        Set AccountType in W_CreateNew
 *
 */
#include "pchlmobj.hxx"  // Precompiled header


// string constant for "any logon server"
// BUGBUG only define once
#define SERVER_ANY SZ("\\\\*")


/*******************************************************************

    NAME:	USER_3::CtAux

    SYNOPSIS:	Constructor helper for USER_3 class

    EXIT:	ReportError is called if nesessary

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

VOID USER_3::CtAux()
{
    if ( QueryError() != NERR_Success )
	return;

    APIERR err;
    if (   ((err = _nlsProfile.QueryError()) != NERR_Success)
        || ((err = _nlsHomedirDrive.QueryError()) != NERR_Success) )
    {
    	ReportError( err );
	return;
    }
}

/*******************************************************************

    NAME:	USER_3::USER_3

    SYNOPSIS:	Constructor for USER_3 class

    ENTRY:	pszAccount -	account name
		pszLocation -	server or domain name to execute on;
				default (NULL) means the logon domain

    EXIT:	Object is constructed

    NOTES:	Validation is not done until GetInfo() time.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/


USER_3::USER_3( const TCHAR *pszAccount, const TCHAR *pszLocation )
	: USER_2( pszAccount, pszLocation ),	
	  _dwUserId( 0L ),
	  _dwPrimaryGroupId( 0L ),
	  _nlsProfile(),
          _nlsHomedirDrive(),
          _dwPasswordExpired( 0L )
{
    CtAux();
}

USER_3::USER_3( const TCHAR *pszAccount, enum LOCATION_TYPE loctype )
	: USER_2( pszAccount, loctype ),
	  _dwUserId( 0L ),
	  _dwPrimaryGroupId( 0L ),
	  _nlsProfile(),
          _nlsHomedirDrive(),
          _dwPasswordExpired( 0L )
{
    CtAux();
}

USER_3::USER_3( const TCHAR *pszAccount, const LOCATION & loc )
	: USER_2( pszAccount, loc ),
	  _dwUserId( 0L ),
	  _dwPrimaryGroupId( 0L ),
	  _nlsProfile(),
          _nlsHomedirDrive(),
          _dwPasswordExpired( 0L )
{
    CtAux();
}



/*******************************************************************

    NAME:	USER_3::~USER_3

    SYNOPSIS:	Destructor for USER_3 class

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

USER_3::~USER_3()
{
}


/*******************************************************************

    NAME:	USER_3::I_GetInfo

    SYNOPSIS:	Gets information about the local user

    EXIT:	Returns API error code

    NOTES:	In I_GetInfo, we set the password to NULL_USERSETINFO_PASSWD.
   		NetUserGetInfo[3] will never give us a real password, but
		only this value.  If this value is passed though to
		SetInfo, the user's password will not be changed.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::I_GetInfo()
{


    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
	return err;

    BYTE *pBuffer = NULL;
    err = ::MNetUserGetInfo ( QueryServer(), (TCHAR *)_nlsAccount.QueryPch(), 3,
	&pBuffer );
    SetBufferPtr( pBuffer );
    if ( err != NERR_Success )
	return err;

    USER_INFO_3 *lpui3 = (USER_INFO_3 *)QueryBufferPtr();
    UIASSERT( lpui3 != NULL );

    if (   ((err = SetName( lpui3->usri3_name )) != NERR_Success )
	|| ((err = SetPriv( (UINT)lpui3->usri3_priv )) != NERR_Success )
	|| ((err = SetAuthFlags( (UINT)lpui3->usri3_auth_flags )) != NERR_Success )
	|| ((err = SetComment( lpui3->usri3_comment )) != NERR_Success)
	|| ((err = SetUserComment( lpui3->usri3_usr_comment )) != NERR_Success)
	|| ((err = SetFullName( lpui3->usri3_full_name )) != NERR_Success )
    	|| ((err = SetHomeDir( lpui3->usri3_home_dir )) != NERR_Success )
    	|| ((err = SetParms( lpui3->usri3_parms )) != NERR_Success )
	|| ((err = SetScriptPath( lpui3->usri3_script_path )) != NERR_Success )
	|| ((err = SetAccountExpires( lpui3->usri3_acct_expires )) != NERR_Success )
	|| ((err = SetUserFlags( (UINT)lpui3->usri3_flags )) != NERR_Success )
	|| ((err = SetPassword( UI_NULL_USERSETINFO_PASSWD )) != NERR_Success )
	|| ((err = SetWorkstations( lpui3->usri3_workstations )) != NERR_Success )
	|| ((err = SetLogonHours( (BYTE *)lpui3->usri3_logon_hours,
				  (UINT)lpui3->usri3_units_per_week )) != NERR_Success )
	|| ((err = SetUserId( lpui3->usri3_user_id )) != NERR_Success )
	|| ((err = SetPrimaryGroupId( lpui3->usri3_primary_group_id )) != NERR_Success )
	|| ((err = SetProfile( lpui3->usri3_profile )) != NERR_Success )
	|| ((err = SetHomedirDrive( lpui3->usri3_home_dir_drive )) != NERR_Success )
	|| ((err = SetPasswordExpired( lpui3->usri3_password_expired )) != NERR_Success )
       )
    {
	return err;
    }

    return NERR_Success;


}


/*******************************************************************

    NAME:	USER_3::W_CreateNew

    SYNOPSIS:	initializes private data members for new object

    EXIT:	Returns an API error code

    NOTES:	Unlike I_GetInfo, we set the password to NULL.  This is
		an appropriate initial value for a new user.

    HISTORY:
	JonN	01/21/92	Created
        jonn    05/02/92        Set AccountType in W_CreateNew

********************************************************************/

APIERR USER_3::W_CreateNew()
{
    APIERR err = NERR_Success;
    if (   ((err = USER_2::W_CreateNew()) != NERR_Success )
	|| ((err = SetUserId( 0L )) != NERR_Success )
	|| ((err = SetPrimaryGroupId(DOMAIN_GROUP_RID_USERS)) != NERR_Success )
	|| ((err = SetProfile( NULL )) != NERR_Success )
	|| ((err = SetHomedirDrive( NULL )) != NERR_Success )
	|| ((err = SetAccountType( AccountType_Normal )) != NERR_Success )
       )
    {
	UIDEBUG( SZ("USER_3::W_CreateNew failed\r\n") );
	return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::I_CreateNew

    SYNOPSIS:	Sets up object for subsequent WriteNew

    EXIT:	Returns a standard LANMAN error code

    NOTES:	Name validation and memory allocation are done
		at this point, not at construction.  The string-valued
		fields are only valid in the NLS_STR members and are not
		valid in the buffer until WriteNew.

		EXCEPTION: We don't validate the account name until
		WriteNew.

		Default values taken from NetCmd::user_add().

    HISTORY:
	JonN	01/21/92	Created
        JonN    05/08/92        Calls ClearBuffer()

********************************************************************/

APIERR USER_3::I_CreateNew()
{


    APIERR err = NERR_Success;
    if (   ((err = W_CreateNew()) != NERR_Success )
	|| ((err = ResizeBuffer( sizeof(USER_INFO_3) )) != NERR_Success )
	|| ((err = ClearBuffer()) != NERR_Success )
       )
    {
	return err;
    }

    USER_INFO_3 *lpui3 = (USER_INFO_3 *)QueryBufferPtr();
    UIASSERT( lpui3 != NULL );

    /*
	All fields of USER_INFO_3 are listed here.  Some are commented
	out because:
	(1) They are adequately initialized by ClearBuffer()
	(2) The effective value is stored in an NLS_SLR or other data member
    */
    // lpui3->usri3_name =
    // strcpyf( lpui3->usri3_password, QueryPassword() );
    // lpui3->usri3_password_age =
    // lpui3->usri3_priv = _usPriv = USER_PRIV_USER;
    // lpui3->usri3_home_dir =
    // lpui3->usri3_comment = (PSZ)_nlsComment.QueryPch();
    // lpui3->usri3_flags = UF_SCRIPT;
    // lpui3->usri3_script_path =
    // lpui3->usri3_auth_flags = _flAuth = 0L;
    // lpui3->usri3_full_name = (PSZ)_nlsFullName.QueryPch();
    // lpui3->usri3_usr_comment = (PSZ)_nlsUserComment.QueryPch();
    // lpui3->usri3_parms =
    // lpui3->usri3_workstations =
    // lpui3->usri3_last_logon =
    // lpui3->usri3_last_logoff =
    lpui3->usri3_acct_expires = TIMEQ_FOREVER;
    lpui3->usri3_max_storage = USER_MAXSTORAGE_UNLIMITED;
    // lpui3->usri3_units_per_week =
    // lpui3->usri3_logon_hours =
    // lpui3->usri3_bad_pw_count =
    // lpui3->usri3_num_logons =
    lpui3->usri3_logon_server = SERVER_ANY;
    // lpui3->usri3_country_code =
    // lpui3->usri3_code_page =
    // lpui3->usri3_user_id =
    // lpui3->usri3_primary_group_id =
    // lpui3->usri3_profile =
    // lpui3->usri3_home_dir_drive =
    // lpui3->usri3_password_expired =

    return NERR_Success;


}


/*******************************************************************

    NAME:	USER_3::W_CloneFrom

    SYNOPSIS:	Copies information on the user

    EXIT:	Returns an API error code

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::W_CloneFrom( const USER_3 & user3 )
{
    APIERR err = NERR_Success;
    if (   ((err = USER_2::W_CloneFrom( user3 )) != NERR_Success )
	|| ((err = SetUserId( user3.QueryUserId() )) != NERR_Success )
	|| ((err = SetPrimaryGroupId( user3.QueryPrimaryGroupId() )))
	|| ((err = SetProfile( user3.QueryProfile() )) != NERR_Success )
	|| ((err = SetHomedirDrive( user3.QueryHomedirDrive() )) != NERR_Success )
       )
    {
	UIDEBUG( SZ("USER_3::W_CloneFrom failed\r\n") );
	return err;
    }

    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::CloneFrom

    SYNOPSIS:	Copies information on the user

    EXIT:	Returns an API error code

    NOTES:	W_CloneFrom copies all member objects, but it does not
    		update the otherwise unused pointers in the API buffer.
		This is left for the outermost routine, CloneFrom().
		Only the otherwise unused pointers need to be fixed
		here, the rest will be fixed in WriteInfo/WriteNew.

		usri3_logon_server is an "obscure" pointer which may
		have one of two origins:
		(1) It may have been pulled in by GetInfo, in which case
		    it is in the buffer;
		(2) It may have been created by CreateNew, in which case
		    it points to a static string outside the buffer.
		To handle these cases, FixupPointer must try to fixup
		logon_server except where it points outside the buffer.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::CloneFrom( const USER_3 & user3 )
{
    APIERR err = W_CloneFrom( user3 );
    if ( err != NERR_Success )
    {
	UIDEBUG( SZ("USER_3::W_CloneFrom failed with error code ") );
	UIDEBUGNUM( (LONG)err );
	UIDEBUG( SZ("\r\n") );

	ReportError( err ); // BUGBUG make unconstructed here??
	return err;
    }


    /*
	This is where I fix up the otherwise unused pointers.
    */
    USER_INFO_3 *pAPIuser3 = (USER_INFO_3 *)QueryBufferPtr();
	

    /*
	Do not attempt to merge these into a macro, the compiler will not
	interpret the "&(p->field)" correctly if you do.
    */
    FixupPointer32(((TCHAR**)&(pAPIuser3->usri3_name)), (& user3));
    FixupPointer( (TCHAR **)&(pAPIuser3->usri3_script_path), &user3 );
    FixupPointer( (TCHAR **)&(pAPIuser3->usri3_logon_server), &user3 );

    FixupPointer( (TCHAR **)&(pAPIuser3->usri3_full_name), &user3 );


    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::W_Write

    SYNOPSIS:	Helper function for WriteNew and WriteInfo -- loads
		current values into the API buffer

    EXIT:	Returns API error code

    HISTORY:
	JonN	01/21/92	Created
        JonN    04/27/92        Enabled
	thomaspa 04/28/92	Fixed up password handling/remove redundancy

********************************************************************/

APIERR USER_3::W_Write()
{

    USER_INFO_3 *lpui3 = (USER_INFO_3 *)QueryBufferPtr();
    ASSERT( lpui3 != NULL );
    ASSERT( _nlsAccount.QueryError() == NERR_Success );
    ASSERT( _nlsAccount.strlen() <= UNLEN );
    // usri3_name is a buffer rather than a pointer
    COPYTOARRAY( lpui3->usri3_name, (TCHAR *)_nlsAccount.QueryPch() );
    lpui3->usri3_comment = (TCHAR *)QueryComment();
    lpui3->usri3_usr_comment = (TCHAR *)QueryUserComment();
    lpui3->usri3_full_name = (TCHAR *)QueryFullName();
    lpui3->usri3_priv = QueryPriv();
    lpui3->usri3_auth_flags = QueryAuthFlags();
    lpui3->usri3_flags = QueryUserFlags();
    lpui3->usri3_home_dir = (TCHAR *)QueryHomeDir();
    lpui3->usri3_parms = (TCHAR *)QueryParms();
    lpui3->usri3_script_path = (TCHAR *)QueryScriptPath();
    lpui3->usri3_acct_expires = QueryAccountExpires();
    lpui3->usri3_workstations = (TCHAR *)QueryWorkstations();
    lpui3->usri3_units_per_week = QueryLogonHours().QueryUnitsPerWeek();
    lpui3->usri3_logon_hours = (UCHAR *)(QueryLogonHours().QueryHoursBlock());
    lpui3->usri3_user_id = QueryUserId();
    lpui3->usri3_primary_group_id = QueryPrimaryGroupId();
    lpui3->usri3_profile = (TCHAR *)QueryProfile();
    lpui3->usri3_home_dir_drive = (TCHAR *)QueryHomedirDrive();
    lpui3->usri3_password_expired = QueryPasswordExpired();


    // This makes the assumption that the USER_INFO_3 struct has
    // the same format (up until the last 4 members) as the USER_INFO_2
    // struct.
    APIERR err =  USER_2::W_Write();

    // This must be done AFTER the USER_2::W_Write()
    if ( !::strcmpf( (TCHAR*)QueryPassword(), UI_NULL_USERSETINFO_PASSWD ) )
    {
	lpui3->usri3_password = NULL;
    }

    return err;

}


/*******************************************************************

    NAME:	USER_3::I_WriteInfo

    SYNOPSIS:	Writes information about the local user

    EXIT:	Returns API error code

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::I_WriteInfo()
{


    APIERR err = W_Write();
    if ( err != NERR_Success )
	return err;

    return ::MNetUserSetInfo ( QueryServer(), (TCHAR *)_nlsAccount.QueryPch(), 3,
			QueryBufferPtr(),
			sizeof( USER_INFO_3 ), PARMNUM_ALL );


}


/*******************************************************************

    NAME:	USER_3::I_WriteNew

    SYNOPSIS:	Creates a new user

    ENTRY:

    EXIT:	Returns an API error code

    NOTES:	

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::I_WriteNew()
{


    // Validate the account name

    APIERR err = HandleNullAccount();
    if (err != NERR_Success)
	return err;

    err = W_Write();
    if ( err != NERR_Success )
	return err;

/*
    We pass size sizeof(struct USER_INFO_3) instead of QueryBufferSize()
    to force all pointers to point outside of the buffer.
*/

    return ::MNetUserAdd( QueryServer(), 3,
			  QueryBufferPtr(),
			  sizeof( USER_INFO_3 ) );


}


/**********************************************************\

    NAME:	USER_3::I_ChangeToNew

    SYNOPSIS:	NEW_LM_OBJ::ChangeToNew() transforms a NEW_LM_OBJ from VALID
		to NEW status only when a corresponding I_ChangeToNew()
		exists.  The USER_INFO_3 API buffer is the same for new
		and valid objects, so this nethod doesn't have to do
		much.

    HISTORY:
	JonN	01/21/92	Created

\**********************************************************/

APIERR USER_3::I_ChangeToNew()
{
    return W_ChangeToNew();
}


/*******************************************************************

    NAME:	USER_3::SetUserId

    SYNOPSIS:	Changes the user's RID

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::SetUserId( DWORD dwUserId )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _dwUserId = dwUserId;
    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::SetPrimaryGroupId

    SYNOPSIS:	Changes the user's primary group RID

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::SetPrimaryGroupId( DWORD dwPrimaryGroupId )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _dwPrimaryGroupId = dwPrimaryGroupId;
    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::SetPasswordExpired

    SYNOPSIS:	Changes whether the user's password has expired

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	05/28/92	Created

********************************************************************/

APIERR USER_3::SetPasswordExpired( DWORD dwPasswordExpired )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    _dwPasswordExpired = dwPasswordExpired;
    return NERR_Success;
}


/*******************************************************************

    NAME:	USER_3::SetProfile

    SYNOPSIS:	Changes the user's profile path

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	01/21/92	Created

********************************************************************/

APIERR USER_3::SetProfile( const TCHAR * pszProfile )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsProfile.CopyFrom( pszProfile );
}


/*******************************************************************

    NAME:	USER_3::QueryAccountType

    SYNOPSIS:	Queries the NT account type

    EXIT:	ACCOUNT_TYPE

    HISTORY:
	jonn	01/22/92	Created
	jonn	04/27/92	Enabled

********************************************************************/

ACCOUNT_TYPE USER_3::QueryAccountType() const
{


    ACCOUNT_TYPE accountType =
		(ACCOUNT_TYPE)(QueryUserFlags() & UF_ACCOUNT_TYPE_MASK);

// #ifdef DEBUG
    switch (accountType)
    {
    case AccountType_Normal:
    case AccountType_Remote:
    case AccountType_DomainTrust:
    case AccountType_WkstaTrust:
    case AccountType_ServerTrust:
	break;
    default:
	ASSERT( FALSE ); // invalid account type
        UIDEBUG( SZ("User Manager: USER_3::QueryAccountType(): Invalid account type ") );
        UIDEBUGNUM( (ULONG)accountType );
        UIDEBUG( SZ("\n\r") );
        accountType = AccountType_Normal;
	break;
    }
// #endif // DEBUG
    return accountType;


}


/*******************************************************************

    NAME:	USER_3::SetAccountType

    SYNOPSIS:	Sets a specific flag (usriX_flags)

    ENTRY:	BOOL whether flag should be set

    EXIT:	error code

    HISTORY:
	jonn	8/28/91		Created
	jonn	04/27/92	Enabled

********************************************************************/

APIERR USER_3::SetAccountType( ACCOUNT_TYPE accountType )
{
// #if 0
    switch (accountType)
    {
    case AccountType_Normal:
    case AccountType_Remote:
    case AccountType_DomainTrust:
    case AccountType_WkstaTrust:
    case AccountType_ServerTrust:
	break;
    default:
	ASSERT( FALSE ); // invalid account type
        UIDEBUG( SZ("User Manager: USER_3::QueryAccountType(): Invalid account type ") );
        UIDEBUGNUM( (ULONG)accountType );
        UIDEBUG( SZ("\n\r") );
        accountType = AccountType_Normal;
	break;
    }
// #endif // DEBUG


    return SetUserFlags( (QueryUserFlags() & (~UF_ACCOUNT_TYPE_MASK))
			 | ((UINT)accountType) );

}


/*******************************************************************

    NAME:	USER_3::SetHomedirDrive

    SYNOPSIS:	Changes the user's home directory drive

    EXIT:	error code.  If not NERR_Success the object is still valid.

    HISTORY:
	JonN	04/27/92	Created

********************************************************************/

APIERR USER_3::SetHomedirDrive( const TCHAR * pszHomedirDrive )
{
    CHECK_OK( ERROR_GEN_FAILURE );
    return _nlsHomedirDrive.CopyFrom( pszHomedirDrive );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\uintlsax.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    UINTLSAX.CXX


    LSA Extensions:  other LSA_POLICY members and LSA_SECRET
        class.



    FILE HISTORY:
        DavidHov    3/10/92   Created

*/

#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:       LsaxGetComputerName

    SYNOPSIS:   Get the computer name in a NETUI manner.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LsaxGetComputerName ( NLS_STR * pnlsComputerName )
{
    TCHAR szComputerName [MAX_PATH] ;
    DWORD dwCch = sizeof szComputerName / sizeof(szComputerName[0]) - 1 ;
    APIERR err ;

    BOOL fOk = ::GetComputerName( szComputerName, & dwCch ) ;

    if ( fOk )
    {
        szComputerName[dwCch] = 0 ;
        *pnlsComputerName = szComputerName ;
        err = pnlsComputerName->QueryError() ;
    }
    else
    {
        err = ::GetLastError() ;
    }
    return  err ;
}

/*******************************************************************

    NAME:     LSA_SERVER_ROLE_INFO_MEM::LSA_SERVER_ROLE_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:


    NOTES:

    HISTORY:  DavidHov   5/15/92

********************************************************************/
LSA_SERVER_ROLE_INFO_MEM :: LSA_SERVER_ROLE_INFO_MEM (
    BOOL fOwnerAlloc,
    BOOL fPrimary )
    : LSA_MEMORY( fOwnerAlloc )
{
}

/*******************************************************************

    NAME:     LSA_SERVER_ROLE_INFO_MEM::~LSA_SERVER_ROLE_INFO_MEM

    SYNOPSIS: Destructor

    ENTRY:


    NOTES:

    HISTORY:

********************************************************************/
LSA_SERVER_ROLE_INFO_MEM :: ~ LSA_SERVER_ROLE_INFO_MEM ()
{
}

/*******************************************************************

    NAME:     LSA_POLICY::SetPrimaryDomain

    SYNOPSIS: Update the primary domain info.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:  DavidHov   5/16/92

********************************************************************/
APIERR LSA_POLICY::SetPrimaryDomain ( const LSA_PRIMARY_DOM_INFO_MEM * plsapdim )
{
    ASSERT( plsapdim != NULL );

#if defined(DEBUG)
    if ( plsapdim->QueryPtr()->Sid == NULL )
    {
        TRACEEOL("UINTLSA: WARNING Setting primary domain SID to NULL") ;
    }
#endif

    APIERR err = ERRMAP::MapNTStatus(
                ::LsaSetInformationPolicy(  QueryHandle(),
                                            PolicyPrimaryDomainInformation,
                                            (PVOID) plsapdim->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::SetAccountDomain

    SYNOPSIS: Update the Account domain info.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:  DavidHov   5/16/92

********************************************************************/
APIERR LSA_POLICY::SetAccountDomain ( const LSA_ACCT_DOM_INFO_MEM * plsaadim )
{
    ASSERT( plsaadim != NULL );

#if defined(DEBUG)
    if ( plsaadim->QueryPtr()->DomainSid == NULL )
    {
        TRACEEOL("UINTLSA: WARNING Setting account domain SID to NULL") ;
    }
#endif

    APIERR err = ERRMAP::MapNTStatus(
                ::LsaSetInformationPolicy(  QueryHandle(),
                                            PolicyAccountDomainInformation,
                                            (PVOID) plsaadim->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::SetAccountDomainName

    SYNOPSIS: Update the Account domain name.

    ENTRY:

    EXIT:

    NOTES:    A bit of a hack.  Creates and fills an
              LSA_ACCT_DOM_INFO_MEM, then alters its UNICODE_STRING
              to match the input parameters.  The original
              data is then restored.

    HISTORY:  DavidHov   5/16/92
              DavidHov   9/20/92   Extended similarly to
                                   SetPrimaryDomainName

********************************************************************/
APIERR LSA_POLICY :: SetAccountDomainName (
    const NLS_STR * pnlsDomainName,
    const PSID * ppsidDomain )
{
    LSA_ACCT_DOM_INFO_MEM lsaadim ;
    UNICODE_STRING usDomainName,
                   usNameSave ;
    POLICY_ACCOUNT_DOMAIN_INFO * pPolAcctDomInfo ;
    PSID psidCurrent = NULL ;

    APIERR err = GetAccountDomain( & lsaadim ) ;

    if ( err == 0 )
    {
        pPolAcctDomInfo = (POLICY_ACCOUNT_DOMAIN_INFO *) lsaadim.QueryPtr() ;

        //  If we're changing the domain name, make a UNICODE_STRING

        if ( pnlsDomainName )
        {
            usNameSave = pPolAcctDomInfo->DomainName ;
            err = ::FillUnicodeString( & usDomainName, *pnlsDomainName ) ;
        }

        //  If we're changing the SID, save the older one

        if ( ppsidDomain )
        {
            psidCurrent = pPolAcctDomInfo->DomainSid ;
            pPolAcctDomInfo->DomainSid = *ppsidDomain ;
        }

        if ( err == 0 )
        {
            if ( pnlsDomainName )
            {
                pPolAcctDomInfo->DomainName = usDomainName ;
            }

            err = SetAccountDomain( & lsaadim ) ;

            if ( pnlsDomainName )
            {
                pPolAcctDomInfo->DomainName = usNameSave ;
                ::FreeUnicodeString( & usDomainName ) ;
            }
        }

        //  Restore the original SID, if any

        if ( psidCurrent )
        {
            pPolAcctDomInfo->DomainSid = psidCurrent ;
        }
    }

    return err ;
}


/*******************************************************************

    NAME:     LSA_POLICY::SetPrimaryDomainName

    SYNOPSIS: Update the Primary domain name.

    ENTRY:    const NLS_STR * pnlsDomainName    new primary domain name
                                                or NULL if not changing
              const PSID * ppsidDomain          new primary domain SID
                                                or NULL if not changing

    EXIT:

    NOTES:    See SetAccountDomainName() above.

    HISTORY:  DavidHov   5/16/92
              DavidHov   6/5/92    added optional PSID *
              DavidHov   8/4/92    allowed pnlsDomainName to be NULL

********************************************************************/
APIERR LSA_POLICY :: SetPrimaryDomainName (
     const NLS_STR * pnlsDomainName,
     const PSID * ppsidDomain )
{
    LSA_PRIMARY_DOM_INFO_MEM lsapdim ;
    UNICODE_STRING usDomainName,
                   usNameSave ;
    POLICY_PRIMARY_DOMAIN_INFO * pPolPrimDomInfo ;
    PSID psidCurrent = NULL ;

    APIERR err = GetPrimaryDomain( & lsapdim ) ;

    if ( err == 0 )
    {
        //  Access the underlying stucture and prepare to modify the
        //  Unicode name.

        pPolPrimDomInfo = (POLICY_PRIMARY_DOMAIN_INFO *) lsapdim.QueryPtr() ;

        //  If we're changing the domain name, make a UNICODE_STRING

        if ( pnlsDomainName )
        {
            usNameSave = pPolPrimDomInfo->Name ;
            err = ::FillUnicodeString( & usDomainName, *pnlsDomainName ) ;
        }

        //  If we're changing the SID, save the older one

        if ( ppsidDomain )
        {
            psidCurrent = pPolPrimDomInfo->Sid ;
            pPolPrimDomInfo->Sid = *ppsidDomain ;
        }

        if ( err == 0 )
        {
            if ( pnlsDomainName )
            {
               pPolPrimDomInfo->Name = usDomainName ;
            }

            err = SetPrimaryDomain( & lsapdim ) ;

            if ( pnlsDomainName )
            {
               pPolPrimDomInfo->Name = usNameSave ;
               ::FreeUnicodeString( & usDomainName ) ;
            }
        }

        //  Restore the original SID, if any

        if ( psidCurrent )
        {
            pPolPrimDomInfo->Sid = psidCurrent ;
        }
    }

    return err ;
}

/*******************************************************************

    NAME:     LSA_POLICY::GetServerRole

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:  DavidHov   5/16/92

********************************************************************/
APIERR LSA_POLICY :: GetServerRole
   ( LSA_SERVER_ROLE_INFO_MEM * plsasrim ) const
{
    PVOID pvBuffer;

    ASSERT( plsasrim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
                ::LsaQueryInformationPolicy( QueryHandle(),
                                             PolicyLsaServerRoleInformation,
                                             &pvBuffer ) );
    if ( err == NERR_Success )
    {
        plsasrim->Set( pvBuffer, 1 );
    }

    return err;
}

/*******************************************************************

    NAME:     LSA_POLICY::SetServerRole

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:  DavidHov   5/16/92

********************************************************************/
APIERR LSA_POLICY :: SetServerRole
   ( const LSA_SERVER_ROLE_INFO_MEM * plsasrim )
{
    ASSERT( plsasrim != NULL );

    APIERR err = ERRMAP::MapNTStatus(
                ::LsaSetInformationPolicy(  QueryHandle(),
                                            PolicyLsaServerRoleInformation,
                                            (PVOID) plsasrim->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME:       LSA_POLICY::MakeSecretName

    SYNOPSIS:   Create the name of the shared secret
                depending upon its type

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        JonN     12/11/92       Change in global secret naming convention

********************************************************************/

APIERR LSA_POLICY :: MakeSecretName (
    const NLS_STR & nlsDomainName,
    BOOL fPrimary,
    NLS_STR * pnlsSecretName )
{
    APIERR err = 0 ;

    if( fPrimary )
    {
        //  The name is "$MACHINE.ACC"

        err = pnlsSecretName->MapCopyFrom( (WCHAR *)SSI_SECRET_NAME ) ;
    }
    else
    {
        //  The name is of the form  "$DOMAIN"

        err = pnlsSecretName->MapCopyFrom( (WCHAR *)LSA_GLOBAL_SECRET_PREFIX );

        if( err == NERR_Success )
        {
            err = pnlsSecretName->Append( (WCHAR *)SSI_SECRET_PREFIX );
        }

        if( err == NERR_Success )
        {
            err = pnlsSecretName->Append( nlsDomainName );
        }
    }

    return err ? err : pnlsSecretName->QueryError() ;
}

/*******************************************************************

    NAME:       LSA_POLICY::VerifyLsa

    SYNOPSIS:   Return the packaging type of this installation

    ENTRY:      LSA_PRIMARY_DOM_INFO_MEM * plsaprm
                        optional pointer to memory wrapper for
                        primary domain information structure

                const NLS_STR * pnlsDomainName
                        optional domain name to be verified
                        against actual.  If mismatch.
                        NERR_NotPrimary is returned.

    EXIT:      *plsaprm  updated

    RETURNS:   APIERR if failure

    NOTES:

    HISTORY:
               DavidHov  4/10/92   Created
********************************************************************/
APIERR LSA_POLICY :: VerifyLsa (
    LSA_PRIMARY_DOM_INFO_MEM * plsapdim,
    const NLS_STR * pnlsDomainName  ) const
{
    APIERR err ;
    BOOL fAllocated = FALSE ;
    NLS_STR nlsRealDomainName ;

    do
    {
        if ( plsapdim == NULL )
        {
            plsapdim = new LSA_PRIMARY_DOM_INFO_MEM ;
            if ( plsapdim == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
                break ;
            }
            fAllocated = TRUE ;
        }

        //  Get primary domain information.

        err = GetPrimaryDomain( plsapdim ) ;
        if ( err )
            break ;

        //  See if the domain name is to be verified
        if ( pnlsDomainName == NULL )
            break ;

        err = plsapdim->QueryName( & nlsRealDomainName ) ;
        if ( err )
           break ;
        if ( *pnlsDomainName != nlsRealDomainName )
           err = NERR_NotPrimary ;
    }
    while ( FALSE ) ;

    if ( fAllocated )
        delete plsapdim ;

    return err ;
}


/*******************************************************************

    NAME:       LSA_POLICY::QueryProductType

    SYNOPSIS:   Return the packaging type of this installation

    ENTRY:      LSPL_PROD_TYPE * lsplProd       receiving variable

    EXIT:       lsplProd updated if no error

    RETURNS:    APIERR if failure

    NOTES:      This function will be replaced when this data lives
                in the Registry.
                Treat (Dedicated) Server as WinNt

    HISTORY:
                DavidHov   4/10/92    Created

********************************************************************/
APIERR LSA_POLICY :: QueryProductType
    ( LSPL_PROD_TYPE * lsplProd )
{
    NT_PRODUCT_TYPE ntpType ;
    APIERR err = 0 ;

    if ( ::RtlGetNtProductType( & ntpType ) )
    {
        switch ( ntpType )
        {
        case NtProductWinNt:
        case NtProductServer:
            *lsplProd = LSPL_PROD_WIN_NT ;
            break ;
        case NtProductLanManNt:
            *lsplProd = LSPL_PROD_LANMAN_NT ;
            break ;
        default:
            err = ERROR_GEN_FAILURE ;
            break ;
        }
    }
    else
    {
       err = ERROR_GEN_FAILURE ;
    }
    return err ;
}


/*******************************************************************

    NAME:       LSA_POLICY::QueryCurrentUser

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR LSA_POLICY ::QueryCurrentUser
    ( NLS_STR * pnlsUserName ) const
{
    OS_SID osSid ;
    APIERR err ;

    do
    {
        err = osSid.QueryError() ;
        if ( err )
           break ;

        err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_CurrentProcessUser, & osSid  ) ;
        if ( err )
           break ;
        err = osSid.QueryName( pnlsUserName ) ;
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::QueryPrimaryDomainName

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Algorithm is:

                        If LANMan/NT, it's the name of the Accounts domain;

                        If Windows/NT and the Primary Domain SID is NULL,
                            use the machine name,
                        else
                            use the primary domain name.

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: QueryPrimaryDomainName (
    NLS_STR * pnlsDomainName ) const
{
    LSPL_PROD_TYPE lsplProd ;
    APIERR err ;

    *pnlsDomainName = SZ("");

    do
    {
        err = QueryProductType( & lsplProd ) ;
        if ( err )
            break ;
        if ( lsplProd == LSPL_PROD_LANMAN_NT )
        {
            LSA_ACCT_DOM_INFO_MEM lsaadim ;

            err = lsaadim.QueryError() ;
            if ( err )
               break ;
            if ( err = GetAccountDomain( & lsaadim ) )
               break ;

            err = lsaadim.QueryName( pnlsDomainName ) ;
        }
        else
        {
            LSA_PRIMARY_DOM_INFO_MEM lspdim ;

            err = lspdim.QueryError() ;
            if ( err )
                break ;
            err = GetPrimaryDomain( & lspdim ) ;
            if ( err )
                break ;

            if ( lspdim.QueryPSID() == NULL )
            {
                err = LsaxGetComputerName( pnlsDomainName ) ;
            }
            else
            {
                err = lspdim.QueryName( pnlsDomainName ) ;
            }
        }
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::QueryPrimaryBrowserGroup

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR LSA_POLICY ::QueryPrimaryBrowserGroup
    ( NLS_STR * pnlsBrowserGroup ) const
{
    APIERR err ;
    LSA_PRIMARY_DOM_INFO_MEM lspdim ;

    do  // Pseudo-loop for breakout
    {
         if ( err = lspdim.QueryError() )
            break ;
         if ( err = GetPrimaryDomain( & lspdim ) )
            break ;

         err = lspdim.QueryName( pnlsBrowserGroup ) ;
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::SetPrimaryBrowserGroup

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      This function is only applicable to Windows NT
                systems which are NOT currently members of a domain.
                Great pains are taken herein to verify this state;
                ERROR_INVALID_FUNCTION is returned if improper request.

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: SetPrimaryBrowserGroup
    ( const NLS_STR & nlsBrowserGroup )
{
    APIERR err ;
    LSPL_PROD_TYPE lsplProd ;
    LSA_PRIMARY_DOM_INFO_MEM lspdim ;

    do  // Pseudo-loop for breakout
    {
        if ( err = QueryProductType( & lsplProd ) )
            break ;

        if ( lsplProd == LSPL_PROD_LANMAN_NT )
        {
            //  It's not Windows NT!

            err = ERROR_INVALID_FUNCTION ;
            break ;
        }

        if ( err = lspdim.QueryError() )
            break ;

        if ( lspdim.QueryPSID() != NULL )
        {
            //  It's a domain member!

            err = ERROR_INVALID_FUNCTION ;
            break ;
        }

        err = SetPrimaryDomainName( & nlsBrowserGroup ) ;
    }
    while ( FALSE );

    return err ;
}


/*******************************************************************

    NAME:       LSA_POLICY::DeleteAllTrustedDomains

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: DeleteAllTrustedDomains ()
{
    APIERR err ;
    LSA_TRUST_INFO_MEM lsatim ;
    LSA_ENUMERATION_HANDLE lenumHand = NULL ;
    NLS_STR nlsDomain;

    do
    {
        err = nlsDomain.QueryError();
        if( err != NERR_Success )
            break;

        err = lsatim.QueryError() ;
        if ( err )
            break ;

        err = EnumerateTrustedDomains( & lsatim, & lenumHand ) ;
        if ( err )
            break ;

        for ( ULONG i = 0 ; err == 0 && i < lsatim.QueryCount() ; i++ )
        {
            err = lsatim.QueryName( i, &nlsDomain );

            if( err == NERR_Success )
            {
                err = DistrustDomain( lsatim.QueryPSID( i ),
                                      nlsDomain,
                                      TRUE );
            }
        }
    }
    while ( FALSE ) ;

    //  See if there were no trusted domains
    if ( err == ERROR_NO_MORE_ITEMS )
        err = 0 ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::TrustDomain

    SYNOPSIS:   Variant 1:  Given a domain name and a SID,
                establish the LSA_TRUSTED_DOMAIN object
                and associated LSA_SECRET necessary to
                forge the trusted relationship.

    ENTRY:      const NLS_STR & nlsDomainName
                                     name of domain

                const PSID psid      opaque reference to SID

                const NLS_STR nlsPassword
                                     password for the secret object

                BOOL fAsPrimary      create the primary domain
                                     relationship.

                const TCHAR * pszTrustedDcHint   name of DC to use
                                     for operations; used for WAN
                                     configurations to avoid broadcasts
                                     which generally don't work

                BOOL fAsDc           TRUE if this is a Backup Domain
                                     Controller
    EXIT:

    RETURNS:

    NOTES:      This routine is used both for joining domains
                (workstations and BDCs) and for establishing trust
                relationships.

                The "as primary" flag determines how the secret object
                is named.  It also causes any other trusted domains to
                be enumerated and deleted.

    HISTORY:
        DavidHov    01-Apr-1992 Created.
        KeithMo     13-Jul-1992 Reordered operations as requested by CliffV.
        DavidHov    20-Aug-1992 Added 'fAsDc', since BDC's are
                                not supposed to have Trusted Domain
                                objects.
        KeithMo     08-Jan-1993 Don't setup trusted controller list.

                                CODEWORK: THIS ROUTINE NEEDS A REWRITE/REORG!

********************************************************************/
APIERR LSA_POLICY :: TrustDomain ( const NLS_STR & nlsDomainName,
                                   const PSID      psid,
                                   const NLS_STR & nlsPassword,
                                   BOOL            fAsPrimary,
                                   const TCHAR   * pszTrustedDcHint,
                                   BOOL            fAsDc )
{
    //
    //  We'll set this flag to TRUE if we managed to
    //  create the LSA Secret object.  This way, if we
    //  have to bag out, we'll know to first delete the
    //  object.
    //

    BOOL fCreatedSecret = FALSE;

    //
    //  Our secret name.
    //

    NLS_STR nlsSecretName;

    //
    //  Create our secret name.
    //

    APIERR err = nlsSecretName.QueryError();

    if( err == NERR_Success )
    {
        err = MakeSecretName( nlsDomainName,
                              fAsPrimary,
                              &nlsSecretName );
    }

    //
    //  If this domain is to act as a Primary, then delete
    //  all other trusted domains (the First Commandment).
    //

    if( fAsPrimary && ( err == NERR_Success ) )
    {
        err = DeleteAllTrustedDomains();
    }

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Create the actual secret object.
    //

    LSA_SECRET lsaSecret( nlsSecretName );

    err = lsaSecret.QueryError();

    if( err == NERR_Success )
    {
        err = lsaSecret.Create( *this );
        TRACEEOL( "LSA_POLICY::TrustDomain: LSA_SECRET::Create returns " << err );
    }

    if( err == ERROR_ALREADY_EXISTS )
    {
        //
        //  The secret already exists, just open and reuse it.
        //
        err = lsaSecret.Open( *this, SECRET_ALL_ACCESS ) ;
    }
    else
    if( err == NERR_Success )
    {
        fCreatedSecret = TRUE ;
    }

    if( err == NERR_Success )
    {
        err = lsaSecret.SetInfo( &nlsPassword, &nlsPassword );
    }

    if( err != NERR_Success )
    {
        lsaSecret.CloseHandle( fCreatedSecret );
        return err;
    }

    TRACEEOL( "UILMOBJ: LSA_POLICY::TrustDomain() Secret Object created; name: "
              << nlsSecretName.QueryPch()
              << " password: "
              << nlsPassword.QueryPch() ) ;

    //
    //  Create the actual Trusted Domain object.  This occurs for workstations
    //  and for inter-domain trust relationships.
    //

    if ( ! fAsDc )
    {
        //
        // JonN 5/14/99: Bug 339487
        // We previously asked for TRUSTED_ALL_ACCESS (on NT5, 0xF007F).
        // This broke NT5/NT4 compatibility since NT5 defined additional bits in
        // TRUSTED_ALL_ACCESS which NT4 doesn't understand.
        //
        LSA_TRUSTED_DOMAIN ltdomTrusted( *this, nlsDomainName, psid, 0L );

#if defined( DEBUG )

        {
            OS_SID ossidDomain( (PSID)psid );
            NLS_STR nlsRawSid;

            if( ( ossidDomain.QueryError() == NERR_Success ) &&
                ( nlsRawSid.QueryError() == NERR_Success ) &&
                ( ossidDomain.QueryRawID( &nlsRawSid ) == NERR_Success ) )
            {
                TRACEEOL( "UILMOBJ:LSA_POLICY::TrustDomain(); trust domain" <<
                          nlsDomainName.QueryPch() <<
                          " SID " <<
                          nlsRawSid.QueryPch() );
            }
            else
            {
                TRACEEOL( "UILMOBJ:LSA_POLICY::TrustDomain(); can't print raw SID" );
            }
        }

#endif  // DEBUG

        //
        //  Verify that the LSA objects constructed properly.
        //

        err = ltdomTrusted.QueryError();
#ifdef DEBUG
        if (err != NERR_Success)
        {
            DBGEOL( "UILMOBJ:LSA_POLICY::TrustDomain(); LSA_TRUSTED_DOMAIN::ctor error" << err );
        }
#endif  // DEBUG

    }

    //
    //  If we're setting up the primary domain, then set its name and SID
    //  If this is a LanmanNT BDC, set the name and SID of the Accounts
    //    domain.
    //

    if ( fAsPrimary && ( err == NERR_Success ) )
    {
        TRACEEOL( "UILMOBJ:LSA_POLICY: Setting new domain name & SID to: "
                  << nlsDomainName.QueryPch() );

        err = SetPrimaryDomainName( & nlsDomainName, & psid );

        if ( fAsDc && err == NERR_Success )
        {
           err = SetAccountDomainName( & nlsDomainName, & psid );
        }
    }

    //
    //  Let's see if we need to undo anything.
    //

    if ( err != NERR_Success )
    {
        lsaSecret.CloseHandle( fCreatedSecret );
    }

    return err;

}   // TrustDomain


/*******************************************************************

    NAME:       LSA_POLICY::TrustDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: TrustDomain (
    LSA_POLICY & lsapolDC,
    const NLS_STR & nlsPassword,
    BOOL fAsPrimary,
    const TCHAR * pszTrustedDcHint )
{
    return ERROR_INVALID_FUNCTION ;
}

/*******************************************************************

    NAME:       LSA_POLICY::DistrustDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      BUGBUG:  this routine needs to check
                if this is the primary domain and create
                the Secret Name accordingly.  For now,
                it just assumes primary...

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: DistrustDomain ( const PSID psid,
                                      const NLS_STR & nlsDomain,
                                      BOOL fAsPrimary )
{
    UIASSERT( nlsDomain.QueryError() == NERR_Success );

    APIERR err = 0 ;
    NLS_STR nlsSecretName;
    BOOL fDeleteDomain = TRUE ;

    //
    // JonN 5/14/99: Bug 339487
    // We previously asked for TRUSTED_ALL_ACCESS (on NT5, 0xF007F).
    // This broke NT5/NT4 compatibility since NT5 defined additional bits in
    // TRUSTED_ALL_ACCESS which NT4 doesn't understand.
    //
    LSA_TRUSTED_DOMAIN ltdomToDelete( *this, psid, DELETE ) ;

    do
    {
        err = ltdomToDelete.QueryError() ;

        //  If we failed to get access, quit; if it's not there,
        //  continue to try to delete the secret object.

        if ( err == ERROR_FILE_NOT_FOUND )
        {
             fDeleteDomain = FALSE ;
        }
        else
        if ( err )
             break ;

        err = MakeSecretName( nlsDomain, fAsPrimary, & nlsSecretName ) ;
        if ( err )
            break ;

        do
        {   //  Destroy the corresponding Secret Object

            LSA_SECRET lsaSecret( nlsSecretName ) ;
            if ( err = lsaSecret.QueryError() )
                break ;

            err = lsaSecret.Open( *this, SECRET_ALL_ACCESS ) ;

            if( err == ERROR_FILE_NOT_FOUND )
            {
                //
                //  ERROR_FILE_NOT_FOUND is returned if the LSA_SECRET
                //  object does not exist.  Since this is what we want
                //  anyway, we'll just pretend it never happened.
                //

                err = NO_ERROR;
            }

            if ( err )
                break ;

            err = lsaSecret.CloseHandle( TRUE ) ;
        }
        while ( FALSE ) ;

        if ( err )
            break ;

        if ( fDeleteDomain )
            err = ltdomToDelete.Delete() ;
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::JoinDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      An LSA_DOMAIN_INFO is constructed, which represents
                the Primary Domain information from the PDC.  If it
                constructs successfully, create a primary trust
                relationship.

    HISTORY:

********************************************************************/
APIERR LSA_POLICY :: JoinDomain (
    const NLS_STR & nlsDomainName,
    const NLS_STR & nlsPassword,
    BOOL fAsDc,
    const NLS_STR * pnlsDcName,
    const TCHAR   * pszTrustedDcHint )
{
    APIERR err ;

    LSA_DOMAIN_INFO lsadci( nlsDomainName, NULL, pnlsDcName ) ;

    do
    {
        if ( err = lsadci.QueryError() )
            break ;

        err = TrustDomain( nlsDomainName,
                           lsadci.QueryPSID(),
                           nlsPassword,
                           TRUE,
                           pszTrustedDcHint,
                           fAsDc ) ;
        if ( err )
           break ;
    }
    while ( FALSE ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_POLICY::LeaveDomain

    SYNOPSIS:   Delete the primary domain information from
                the LSA.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      This routine now leaves the primary domain name as it
                is; otherwise, the Redirector would fail since it
                can tolerate neither a null name nor the same value
                as the machine name.

    HISTORY:    DavidHov    4/1/92   Created
                DavidHov    8/4/92   Changed to preserve primary
                                     domain name.

********************************************************************/
APIERR LSA_POLICY :: LeaveDomain ()
{
    APIERR err ;
    LSA_PRIMARY_DOM_INFO_MEM lsapdim ;
    NLS_STR nlsDomainName ;
    PSID psidNew = NULL ;

    do
    {
        err = nlsDomainName.QueryError();
        if( err != NERR_Success )
            break;

        err = GetPrimaryDomain( & lsapdim ) ;
        if ( err )
            break ;

        err = lsapdim.QueryName( & nlsDomainName );
        if( err != NERR_Success )
            break;

        TRACEEOL( "UILMOBJ:LSA_POLICY: leaving domain "
                  << nlsDomainName.QueryPch() ) ;

        err = DistrustDomain( lsapdim.QueryPSID(), nlsDomainName ) ;
        if ( err )
           break ;

        //  SUCCESS!  Set the primary domain SID to NULL; leave the
        //   name unchanged.

        err = SetPrimaryDomainName( NULL, & psidNew ) ;
    }
    while ( FALSE ) ;

    return err ;
}


/*******************************************************************

    NAME:       LSA_SECRET::LSA_SECRET

    SYNOPSIS:   Constructror of Lsa "Secret Object"

                Allows open, creation, query and set.

                Open/Create require previously successfully
                constructed LSA_POLICY object.

                Machine referenced is the machine specified when the
                LSA_POLICY object was constructed.

    ENTRY:      const NLS_STR & nlsSecretName
                                name of secret object

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:

********************************************************************/
LSA_SECRET :: LSA_SECRET (
    const NLS_STR & nlsSecretName )
    : _nlsSecretName( nlsSecretName )
{
    if ( QueryError() )
        return ;

    if ( _nlsSecretName.QueryError() )
    {
        ReportError( _nlsSecretName.QueryError() ) ;
        return ;
    }
}

/*******************************************************************

    NAME:       LSA_SECRET::~LSA_SECRET

    SYNOPSIS:   Desctructor of Secret Object wrapper

    ENTRY:      nothing

    EXIT:       nothing

    RETURNS:    nothing

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_SECRET :: ~ LSA_SECRET ()
{
}

/*******************************************************************

    NAME:       LSA_SECRET::Create

    SYNOPSIS:   Create a new Secret Object

    ENTRY:      const LSA_POLICY & lsapol     of open LSA_POLICY
                ACCESS_MASK accessDesired

    EXIT:       Private handle to secret object open and
                available for QueryInfo(), SetInfo().

    RETURNS:    APIERR if failure

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_SECRET :: Create (
    const LSA_POLICY & lsapol,
    ACCESS_MASK accessDesired )
{
    APIERR err ;
    UNICODE_STRING unsName ;
    LSA_HANDLE hlsa ;

    ASSERT( ! IsHandleValid() ) ;

    if ( IsHandleValid() )
    {
        CloseHandle() ;
    }

    err = ::FillUnicodeString( & unsName, _nlsSecretName ) ;

    if ( err == 0 )
    {
        err = ERRMAP::MapNTStatus(
                     ::LsaCreateSecret( lsapol.QueryHandle(),
                                        & unsName,
                                        accessDesired,
                                        & hlsa )  ) ;
        if ( err == 0 )
            SetHandle( hlsa ) ;
    }

    ::FreeUnicodeString( & unsName ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_SECRET::Open

    SYNOPSIS:   Open an existing Secret Object

    ENTRY:      const LSA_POLICY & lsaPol
                                policy to open agains
                ACCESS_MASK accessDesired

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_SECRET :: Open   (
    const LSA_POLICY & lsapol,
    ACCESS_MASK accessDesired )
{
    APIERR err ;
    UNICODE_STRING unsName ;
    LSA_HANDLE hlsa ;

    ASSERT( ! IsHandleValid() ) ;

    if ( IsHandleValid() )
    {
        CloseHandle() ;
    }

    err = ::FillUnicodeString( & unsName, _nlsSecretName ) ;

    if ( err == 0 )
    {
        err = ERRMAP::MapNTStatus(
                     ::LsaOpenSecret( lsapol.QueryHandle(),
                                      & unsName,
                                      accessDesired,
                                      & hlsa )  ) ;
        if ( err == 0 )
            SetHandle( hlsa ) ;
    }

    ::FreeUnicodeString( & unsName ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_SECRET::QueryInfo

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_SECRET :: QueryInfo (
    NLS_STR * pnlsCurrentValue,
    NLS_STR * pnlsOldValue,
    LARGE_INTEGER * plintCurrentValueSetTime,
    LARGE_INTEGER * plintOldValueSetTime ) const
{
    APIERR err ;
    UNICODE_STRING * punsCurrent = NULL,
                   * punsOld     = NULL ;

    ASSERT( IsHandleValid() ) ;

    if ( ! IsHandleValid() )
    {
        return ERROR_INVALID_HANDLE ;
    }

    err = ERRMAP::MapNTStatus(
                ::LsaQuerySecret( QueryHandle(),
                                  pnlsCurrentValue ?
                                        & punsCurrent
                                        : NULL,
                                  plintCurrentValueSetTime,
                                  pnlsOldValue ?
                                        & punsOld
                                        : NULL,
                                  plintOldValueSetTime ) ) ;

     if ( err == 0 && pnlsCurrentValue )
     {
         err = pnlsCurrentValue->MapCopyFrom( punsCurrent->Buffer,
                                              punsCurrent->Length );
     }
     if ( err == 0 &&  pnlsOldValue )
     {
         err = pnlsOldValue->MapCopyFrom( punsOld->Buffer,
                                          punsOld->Length );
     }

     if ( punsCurrent )
        ::LsaFreeMemory( punsCurrent ) ;

     if ( punsOld )
        ::LsaFreeMemory( punsOld ) ;

     return err ;
}

/*******************************************************************

    NAME:       LSA_SECRET::SetInfo

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_SECRET :: SetInfo (
    const NLS_STR * pnlsCurrentValue,
    const NLS_STR * pnlsOldValue )
{
    APIERR err = 0 ;
    UNICODE_STRING unsCurrent,
                   * punsCurrent = NULL,
                   unsOld,
                   * punsOld = NULL ;

    ASSERT( IsHandleValid() ) ;

    if ( ! IsHandleValid() )
    {
        return ERROR_INVALID_HANDLE ;
    }

    if ( err == 0 && pnlsCurrentValue )
    {
        err = ::FillUnicodeString( punsCurrent = & unsCurrent,
                                   *pnlsCurrentValue ) ;
    }

    if ( err == 0 && pnlsOldValue )
    {
        err = ::FillUnicodeString( punsOld = & unsOld,
                                   *pnlsOldValue ) ;
    }

    if ( err == 0 )
    {
        err = ERRMAP::MapNTStatus(
                ::LsaSetSecret( QueryHandle(),
                                punsCurrent,
                                punsOld ) ) ;
    }
    if ( punsCurrent )
    {
        ::FreeUnicodeString( punsCurrent ) ;
    }
    if ( punsOld )
    {
        ::FreeUnicodeString( punsOld ) ;
    }
    return err ;
}


/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::LSA_TRUSTED_DC_LIST

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DC_LIST :: LSA_TRUSTED_DC_LIST (
    const NLS_STR & nlsDomain,
    const TCHAR   * pszTrustedDcHint )
    : _lcDc( 0 ),
    _punsNames( NULL )
{
    if ( QueryError() )
        return ;

    APIERR err = QueryInfo( nlsDomain, pszTrustedDcHint ) ;
    if ( err )
    {
        ReportError( err ) ;
        return ;
    }
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::~LSA_TRUSTED_DC_LIST

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DC_LIST :: ~ LSA_TRUSTED_DC_LIST ()
{
    FreeBuffer() ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::FreeBuffer

    SYNOPSIS:   Delete the Net API-provided buffer

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
VOID LSA_TRUSTED_DC_LIST :: FreeBuffer ()
{
    if ( _punsNames )
    {
        ::NetApiBufferFree( _punsNames ) ;
    }
    _punsNames = NULL ;
    _lcDc = 0 ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::QueryInfo

    SYNOPSIS:   Perform the API call to obtain the
                complete DC list of the domain in question.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DC_LIST :: QueryInfo (
    const NLS_STR & nlsDomain,
    const TCHAR   * pszTrustedDcHint )
{
    APIERR err ;

    FreeBuffer() ;

    _tciInfo.Names = NULL ;
    _tciInfo.Entries = 0 ;

    err = ::I_NetGetDCList( (LPTSTR)pszTrustedDcHint,
                            (TCHAR *) nlsDomain.QueryPch(),
                            & _lcDc,
                            & _punsNames ) ;
    if ( err == 0 )
    {
        _tciInfo.Entries = _lcDc ;
        _tciInfo.Names = _punsNames ;
    }
    return err ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::QueryControllerList

    SYNOPSIS:   Return a reference to a constructed LSA
                structure in memory based upon the
                DC list obtained through the API.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
const TRUSTED_CONTROLLERS_INFO & LSA_TRUSTED_DC_LIST :: QueryControllerList () const
{
    ASSERT( QueryError() == 0 ) ;

    return _tciInfo ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::operator []

    SYNOPSIS:   Index into the DC list, return a reference
                to the UNICODE name of the DC.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
const UNICODE_STRING & LSA_TRUSTED_DC_LIST :: operator [] ( INT iIndex ) const
{
    ASSERT(    QueryError() == 0
           && _punsNames != NULL
           &&  (UINT)iIndex < _lcDc ) ;

    return _punsNames[ iIndex ] ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DC_LIST::QueryCount

    SYNOPSIS:   Return the number of DCs in the list.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
INT LSA_TRUSTED_DC_LIST ::  QueryCount ()
{
    return _lcDc ;
}



/*******************************************************************

    NAME:       LSA_DOMAIN_INFO::LSA_DOMAIN_INFO

    SYNOPSIS:   Constructor of wrapper class for domain info

    ENTRY:      const NLS_STR & nlsDomainName

                                Name of the domain to join; required

                const NLS_STR * pnlsServer

                                Name of server to ask for DC name, if
                                not provided.

                const NLS_STR * pnlsDcName

                                DC name of target domain, if known

    EXIT:       Nothing

    RETURNS:    APIERR if err;

                If successful, underlying primary domain information
                is available for querying.

    NOTES:      This object is a wrapper for the primary domain
                information obtained from the Domain Controller.
                An LSA_POLICY is constructed temporarily, and
                GetPrimaryDomain() called against it.  The handle
                to the information returned is preserved; the
                wrapper is discarded.

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_DOMAIN_INFO :: LSA_DOMAIN_INFO (
     const NLS_STR & nlsDomainName,
     const NLS_STR * pnlsServer,
     const NLS_STR * pnlsDcName )
   : _nlsDomainName( nlsDomainName )
{
    APIERR err = 0 ;
    const TCHAR * pszDomain = NULL ;
    const TCHAR * pszServer = NULL ;
    const TCHAR * pszDcName = NULL ;

    if ( QueryError() )
        return ;

    if ( pnlsServer )
    {
        pszServer = pnlsServer->QueryPch() ;
    }
    if ( pnlsDcName )
    {
        pszDcName = pnlsDcName->QueryPch() ;
    }

    do  // PSEUDO-LOOP
    {
        pszDomain = _nlsDomainName.QueryPch() ;
        if ( err = _nlsDomainName.QueryError() )
            break ;

        //  If we don't have the DC name already, ask for it.

        if ( pszDcName == NULL )
        {
            err = ::MNetGetDCName( pszServer,
                                   pszDomain,
                                   (BYTE * *) & pszDcName ) ;
            if ( err )
                break ;

            _nlsDcName = pszDcName ;
            ::MNetApiBufferFree( (BYTE * *) & pszDcName ) ;
        }
        else
        {
            _nlsDcName = pszDcName ;
        }

        if ( err = _nlsDcName.QueryError() )
            break ;

        TRACEEOL( "UINTLSA:Ct LSA_DOMAIN_INFO: open policy on "
                  << _nlsDcName.QueryPch() ) ;

        LSA_POLICY lsapol( _nlsDcName.QueryPch() ) ;

        err = lsapol.QueryError() ;
        if ( err )
            break ;

        err = lsapol.GetPrimaryDomain( & _lsapdim ) ;
        if ( err )
             break ;
    }
    while ( FALSE ) ;

    if ( err )
    {
        ReportError( err ) ;
    }
}

/*******************************************************************

    NAME:       LSA_DOMAIN_INFO::~LSA_DOMAIN_INFO

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      The purpose of this class is to properly
                dispose of the LSA_PRIMARY_DOM_INFO_MEM
                item.

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_DOMAIN_INFO :: ~ LSA_DOMAIN_INFO ()
{
}

/*******************************************************************

    NAME:       LSA_DOMAIN_INFO::QueryPSID

    SYNOPSIS:   Return the PSID of the given domain

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:      Read the BUGBUG comment below.

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
const PSID LSA_DOMAIN_INFO :: QueryPSID () const
{
    APIERR err ;
    PSID pSid = NULL ;

    return _lsapdim.QueryPSID() ;
}

/*******************************************************************

    NAME:       LSA_DOMAIN_INFO::QueryDcName

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_DOMAIN_INFO :: QueryDcName (
    NLS_STR * pnlsDcName )
{
    return ERROR_INVALID_FUNCTION ;
}


//  End of UINTLSAX.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\uintlstd.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1992                **/
/**********************************************************************/

/*
    UINTLSTD.CXX


    LSA Trusted Domain handling



    FILE HISTORY:
        DavidHov    3/10/92   Created

*/


#include "pchlmobj.hxx"  // Precompiled header


/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::LSA_TRUSTED_DOMAIN

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DOMAIN :: LSA_TRUSTED_DOMAIN (
    const LSA_POLICY & lsapol,
    const PSID psid,
    ACCESS_MASK desiredAccess )
{
    LSA_HANDLE hlsa = NULL ;

    if ( QueryError() )
        return ;

    NTSTATUS ntstatus = ::LsaOpenTrustedDomain(
                            lsapol.QueryHandle(),
                            psid,
                            desiredAccess,
                            & hlsa ) ;
    APIERR err = ERRMAP::MapNTStatus( ntstatus );
    if ( err == 0 )
    {
        SetHandle( hlsa ) ;
    }
    else
    {
        DBGEOL( "NETUI: LSA_TRUSTED_DOMAIN::ctor: LsaOpenTrustedDomain returns NTSTATUS " << err );
        ReportError( err ) ;
    }
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::LSA_TRUSTED_DOMAIN

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DOMAIN :: LSA_TRUSTED_DOMAIN (
    const LSA_POLICY & lsapol,
    const LSA_TRUST_INFORMATION & lstInfo,
    ACCESS_MASK desiredAccess )
{
    LSA_HANDLE hlsa = NULL ;

    if ( QueryError() )
        return ;

    NTSTATUS ntstatus = ::LsaOpenTrustedDomain(
                            lsapol.QueryHandle(),
                            lstInfo.Sid,
                            desiredAccess,
                            & hlsa );
    APIERR err = ERRMAP::MapNTStatus( ntstatus );
    if ( err == 0 )
    {
        SetHandle( hlsa ) ;
    }
    else
    {
        DBGEOL( "NETUI: LSA_TRUSTED_DOMAIN::ctor: LsaOpenTrustedDomain returns NTSTATUS " << err );
        ReportError( err ) ;
    }
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::LSA_TRUSTED_DOMAIN

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DOMAIN :: LSA_TRUSTED_DOMAIN (
    const LSA_POLICY & lsapol,
    const NLS_STR & nlsDomainName,
    const PSID psid,
    ACCESS_MASK desiredAccess )
{
    LSA_HANDLE hlsa = NULL ;
    LSA_TRUST_INFORMATION lstInfo ;
    APIERR err ;

    if ( QueryError() )
        return ;

    lstInfo.Sid = psid ;
    err = ::FillUnicodeString( & lstInfo.Name, nlsDomainName ) ;
    if ( err )
    {
        DBGEOL( "NETUI: LSA_TRUSTED_DOMAIN::ctor: FillUnicodeString returns " << err );
        ReportError( err ) ;
        return ;
    }

    NTSTATUS ntstatus = ::LsaCreateTrustedDomain(
                            lsapol.QueryHandle(),
                            & lstInfo,
                            desiredAccess,
                            & hlsa );
    err = ERRMAP::MapNTStatus( ntstatus );

    ::FreeUnicodeString( & lstInfo.Name ) ;

    if ( err == 0 )
    {
        SetHandle( hlsa ) ;
    }
    else
    {
        DBGEOL( "NETUI: LSA_TRUSTED_DOMAIN::ctor: LsaOpenTrustedDomain returns NTSTATUS " << err );
        ReportError( err ) ;
    }
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::~LSA_TRUSTED_DOMAIN

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
LSA_TRUSTED_DOMAIN :: ~ LSA_TRUSTED_DOMAIN ()
{
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::QueryPosixOffset

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DOMAIN :: QueryPosixOffset (
    ULONG * plPosixOffset ) const
{
    APIERR err = 0 ;
    TRUSTED_POSIX_OFFSET_INFO * pTrustPosix = NULL ;

    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }

    err = ERRMAP::MapNTStatus(
                  ::LsaQueryInfoTrustedDomain(
                        QueryHandle(),
                        TrustedPosixOffsetInformation,
                        (PVOID *) & pTrustPosix ) ) ;

    if ( err == 0 )
    {
        *plPosixOffset = pTrustPosix->Offset ;
    }

    if ( pTrustPosix )
        ::LsaFreeMemory( pTrustPosix ) ;

    return err ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::QueryControllerList

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DOMAIN :: QueryControllerList (
   LSA_REF_DOMAIN_MEM * plsatdm ) const
{
    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }
    return ERROR_INVALID_FUNCTION ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::SetPosixOffset

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DOMAIN :: SetPosixOffset ( ULONG lPosixOffset )
{
    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }
    return ERROR_INVALID_FUNCTION ;
}

/*******************************************************************

    NAME:       LSA_TRUSTED_DOMAIN::SetControllerList

    SYNOPSIS:

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
                DavidHov   4/10/92

********************************************************************/
APIERR LSA_TRUSTED_DOMAIN :: SetControllerList (
    LSA_REF_DOMAIN_MEM * plsatdm )
{
    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }
    return ERROR_INVALID_FUNCTION ;
}

APIERR LSA_TRUSTED_DOMAIN :: SetControllerList (
    const TRUSTED_CONTROLLERS_INFO & tciInfo )
{
    APIERR err ;

    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }
    err = ERRMAP::MapNTStatus(
                        ::LsaSetInformationTrustedDomain(
                                QueryHandle(),
                                TrustedControllersInformation,
                                (PVOID) & tciInfo ) ) ;
    return err ;
}

APIERR LSA_TRUSTED_DOMAIN :: Delete ()
{
    if ( QueryHandle() == NULL )
    {
        return ERROR_INVALID_HANDLE ;
    }

    APIERR err = ERRMAP::MapNTStatus(
                     ::LsaDelete( QueryHandle() ) ) ;

    ResetHandle() ;

    return err ;
}


// End of UINTLSTD.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\uintmem.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
 * NET_MEMORY class implementation
 *
 * History
 *	thomaspa	01/17/92	Created from ntsam.hxx
 */

#include "pchlmobj.hxx"  // Precompiled header



/*******************************************************************

    NAME: ::FillUnicodeString

    SYNOPSIS: Standalone method for filling in a UNICODE_STRING

    ENTRY:	punistr - Unicode string to be filled in.
		nls - Source for filling the unistr

    EXIT:

    NOTES: punistr->Buffer is allocated here and must be deallocated
	by the caller using FreeUnicodeString.

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR FillUnicodeString( UNICODE_STRING * punistr, const NLS_STR & nls )
{


	USHORT cTchar = (USHORT)nls.QueryTextLength();

	// Length and MaximumLength are counts of bytes.
	punistr->Length = cTchar * sizeof(WCHAR);
	punistr->MaximumLength = punistr->Length + sizeof(WCHAR);
	punistr->Buffer = new WCHAR[cTchar + 1];
        APIERR err = ERROR_NOT_ENOUGH_MEMORY;
        if (punistr->Buffer != NULL)
            err = nls.MapCopyTo( punistr->Buffer, punistr->MaximumLength );
        return err;
}




/*******************************************************************

    NAME: ::FreeUnicodeString

    SYNOPSIS: Standalone method for freeing in a UNICODE_STRING

    ENTRY:	unistr - Unicode string whose Buffer is to be freed.

    EXIT:


    HISTORY:
	thomaspa	03/30/92	Created

********************************************************************/
VOID FreeUnicodeString( UNICODE_STRING * punistr )
{
    ASSERT( punistr != NULL );
    delete punistr->Buffer;
}


/*******************************************************************

    NAME: NT_MEMORY::NT_MEMORY

    SYNOPSIS: constructor

    ENTRY:	pvBuffer - pointer to allocated buffer
		cItems - count of items contained in buffer

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/

NT_MEMORY::NT_MEMORY()
	: _pvBuffer( NULL ),
	  _cItems ( 0L )
{
}


/*******************************************************************

    NAME: NT_MEMORY::~NT_MEMORY

    SYNOPSIS: destructor,

    ENTRY:

    EXIT:

    NOTES: subclasses for NT_MEMORY should use the appropriate method
	to free the memory in the destructor.

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
NT_MEMORY::~NT_MEMORY()
{
    ASSERT( _pvBuffer == NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmobj\uintsam.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT	 		     **/
/**		   Copyright(c) Microsoft Corp., 1992		     **/
/**********************************************************************/

/*
 * This module contains the wrappers for SAM handle-based objects.
 *
 *
 * History
 *	thomaspa	01/17/92	Created from ntsam.hxx
        jonn            07/06/92        Added ADMIN_AUTHORITY::ReplaceAccountDomain
 */

#include "pchlmobj.hxx"  // Precompiled header



/*******************************************************************

    NAME: SAM_MEMORY::SAM_MEMORY

    SYNOPSIS: Constructor

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_MEMORY::SAM_MEMORY( BOOL fOwnerAlloc )
	: NT_MEMORY(),
	_fOwnerAlloc( fOwnerAlloc )
{
    if ( QueryError() != NERR_Success )
	return;
}



/*******************************************************************

    NAME: SAM_MEMORY::~SAM_MEMORY

    SYNOPSIS: Destructor

    ENTRY: none

    EXIT: none

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_MEMORY::~SAM_MEMORY()
{
    Set( NULL, 0 );
}





/*******************************************************************

    NAME: SAM_SID_MEM::SAM_SID_MEM

    SYNOPSIS: Constructor

    ENTRY:
	

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_SID_MEM::SAM_SID_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}



/*******************************************************************

    NAME: SAM_SID_MEM::~SAM_SID_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_SID_MEM::~SAM_SID_MEM()
{
}




/*******************************************************************

    NAME: SAM_RID_MEM::SAM_RID_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_RID_MEM::SAM_RID_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}



/*******************************************************************

    NAME: SAM_RID_MEM::~SAM_RID_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_RID_MEM::~SAM_RID_MEM()
{
}




/*******************************************************************

    NAME: SAM_RID_ENUMERATION_MEM::SAM_RID_ENUMERATION_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_RID_ENUMERATION_MEM::SAM_RID_ENUMERATION_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}


/*******************************************************************

    NAME: SAM_RID_ENUMERATION_MEM::~SAM_RID_ENUMERATION_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_RID_ENUMERATION_MEM::~SAM_RID_ENUMERATION_MEM()
{
}


/*******************************************************************

    NAME: SAM_SID_NAME_USE_MEM::SAM_SID_NAME_USE_MEM

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/11/92	Created from ntsam.hxx

********************************************************************/
SAM_SID_NAME_USE_MEM::SAM_SID_NAME_USE_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}


/*******************************************************************

    NAME: SAM_SID_NAME_USE_MEM::~SAM_SID_NAME_USE_MEM

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/11/92	Created from ntsam.hxx

********************************************************************/
SAM_SID_NAME_USE_MEM::~SAM_SID_NAME_USE_MEM()
{
}


/*******************************************************************

    NAME: SAM_PSWD_DOM_INFO_MEM::SAM_PSWD_DOM_INFO_MEM

    SYNOPSIS: Constructor

    ENTRY:

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
SAM_PSWD_DOM_INFO_MEM::SAM_PSWD_DOM_INFO_MEM( BOOL fOwnerAlloc )
	: SAM_MEMORY( fOwnerAlloc )
{
}

/*******************************************************************

    NAME: SAM_PSWD_DOM_INFO_MEM::~SAM_PSWD_DOM_INFO_MEM

    SYNOPSIS: Destructor

    ENTRY:

    NOTES:

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
SAM_PSWD_DOM_INFO_MEM::~SAM_PSWD_DOM_INFO_MEM()
{
}


/*******************************************************************

    NAME: SAM_PSWD_DOM_INFO_MEM::QueryNoAnonChange

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
BOOL SAM_PSWD_DOM_INFO_MEM::QueryNoAnonChange()
{
    return ( QueryPtr()->PasswordProperties
                        & DOMAIN_PASSWORD_NO_ANON_CHANGE );
}


/*******************************************************************

    NAME: SAM_PSWD_DOM_INFO_MEM::SetNoAnonChange

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
void SAM_PSWD_DOM_INFO_MEM::SetNoAnonChange( BOOL fNoAnonChange )
{
    if (fNoAnonChange)
    {
        QueryUpdatePtr()->PasswordProperties |= DOMAIN_PASSWORD_NO_ANON_CHANGE;
    }
    else
    {
        QueryUpdatePtr()->PasswordProperties &= ~DOMAIN_PASSWORD_NO_ANON_CHANGE;
    }
}





/*******************************************************************

    NAME: SAM_OBJECT::SAM_OBJECT

    SYNOPSIS: Constructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_OBJECT::SAM_OBJECT()
	: _hsam( NULL ),
	  _fHandleValid( FALSE )
{
    if ( QueryError() != NERR_Success )
	return;
}


/*******************************************************************

    NAME:       SAM_OBJECT::CloseHandle

    SYNOPSIS:   Explict close of handle

    ENTRY:

    EXIT:

    NOTES:      No error is reported if the handle
                has already been closed (invalidated).

    HISTORY:    Thomaspa   4/17/92	Templated from LSA_OBJECT

********************************************************************/
APIERR SAM_OBJECT::CloseHandle ( )
{
    APIERR err = NERR_Success ;

    if ( _fHandleValid )
    {
        if ( _hsam != NULL )
        {
            NTSTATUS ntStatus = ::SamCloseHandle( QueryHandle() ) ;

            err = ERRMAP::MapNTStatus( ntStatus ) ;
        }
        ResetHandle() ;
    }
    return err ;
}




/*******************************************************************

    NAME: SAM_OBJECT::~SAM_OBJECT

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_OBJECT::~SAM_OBJECT()
{
    CloseHandle();
}




/*******************************************************************

    NAME: SAM_SERVER::SAM_SERVER

    SYNOPSIS: Constructor

    ENTRY: pszServerName - name of server to connect to
	accessDesired - Security access requested

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_SERVER::SAM_SERVER( const TCHAR * pszServerName,
		        ACCESS_MASK   accessDesired )
	: SAM_OBJECT(),
          _nlsServerName( pszServerName )
{
    if ( QueryError() != NERR_Success )
	return;

    APIERR err = _nlsServerName.QueryError();
    if (err != NERR_Success)
    {
        ReportError( err );
        return;
    }

    SAM_HANDLE hsamServer;
    UNICODE_STRING unistrServerName;
    PUNICODE_STRING punistrServerName;

    if ( pszServerName != NULL )
    {
	ALIAS_STR nlsServerName = pszServerName;

	err = ::FillUnicodeString( &unistrServerName, nlsServerName );
	if ( err != NERR_Success )
	{
	    ReportError( err );
	    return;
	}
	punistrServerName = &unistrServerName;
    }
    else
    {
	punistrServerName = NULL;
    }

    err = ERRMAP::MapNTStatus(
	    ::SamConnect( punistrServerName,
		          &hsamServer,
		          accessDesired,
		          NULL ) );

    if ( err == NERR_Success )
    {
	SetHandle( hsamServer );
    }
    else
    {
	ReportError( err );
    }

    if ( punistrServerName != NULL )
    {
	::FreeUnicodeString( punistrServerName );
    }
}




/*******************************************************************

    NAME: SAM_SERVER::~SAM_SERVER

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_SERVER::~SAM_SERVER()
{
}



/*******************************************************************

    NAME: SAM_DOMAIN::SAM_DOMAIN

    SYNOPSIS: Constructor

    ENTRY: server - reference to SAM_SERVER on which the domain resides
	psidDomain - SID for domain
	accessDesired - Security access requested

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_DOMAIN::SAM_DOMAIN( const SAM_SERVER & server,
		       PSID psidDomain,
		       ACCESS_MASK accessDesired )
	: SAM_OBJECT(),
	  _ossidDomain( psidDomain, TRUE )
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err;

    if ( (err = _ossidDomain.QueryError()) != NERR_Success )
    {
	ReportError( err );
	return;
    }

    if ( (err = OpenDomain( server,
			    psidDomain,
			    accessDesired )) != NERR_Success )
    {
	ReportError(err);
	return;
    }
}




/*******************************************************************

    NAME: SAM_DOMAIN::~SAM_DOMAIN

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_DOMAIN::~SAM_DOMAIN()
{
}





/*******************************************************************

    NAME: SAM_DOMAIN::OpenDomain

    SYNOPSIS: wrapper for SamOpenDomain()

    ENTRY: same as constructor

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_DOMAIN::OpenDomain( const SAM_SERVER & server,
		       	      PSID psidDomain,
		       	      ACCESS_MASK accessDesired )
{
    SAM_HANDLE hsamDomain;

    APIERR err = ERRMAP::MapNTStatus(
	    ::SamOpenDomain( server.QueryHandle(),
			     accessDesired,
			     psidDomain,
			     &hsamDomain ) );

    if ( err == NERR_Success )
    {
	SetHandle( hsamDomain );
    }
    return err;

}


/*******************************************************************

    NAME:     SAM_DOMAIN::GetPasswordInfo

    SYNOPSIS: Get the password info from SAM

    ENTRY:    psampswdinfo - pointer to a SAM_PSWD_DOM_INFO_MEM
                         object to receive the data.

    EXIT:

    NOTES:

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/

APIERR SAM_DOMAIN::GetPasswordInfo( SAM_PSWD_DOM_INFO_MEM *psampswdinfo ) const
{

    PVOID pvBuffer = NULL;

    ASSERT( psampswdinfo != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::SamQueryInformationDomain( QueryHandle(),
					     DomainPasswordInformation,
					     &pvBuffer ) );
    if ( err == NERR_Success )
    {
	psampswdinfo->Set( pvBuffer, 1 );
    }

    return err;
}

/*******************************************************************

    NAME:     SAM_DOMAIN::SetPasswordInfo

    SYNOPSIS: Set the password info back to SAM

    ENTRY:    psampswdinfo - pointer to a SAM_PSWD_DOM_INFO_MEM
                         object for the data to set.

    EXIT:

    NOTES:

    HISTORY:
        JonN       12/23/93     Created

********************************************************************/
APIERR SAM_DOMAIN::SetPasswordInfo( const SAM_PSWD_DOM_INFO_MEM *psampswdinfo )
{

    ASSERT( psampswdinfo != NULL );

    APIERR err = ERRMAP::MapNTStatus(
		::SamSetInformationDomain(  QueryHandle(),
					    DomainPasswordInformation,
					    (PVOID) psampswdinfo->QueryPtr() ));
    return err;
}

/*******************************************************************

    NAME: SAM_DOMAIN::TranslateNamesToRids

    SYNOPSIS: Wrapper for SamLookupNames()

    ENTRY: ppszNames - array of names to lookup
	cNames - count of names to lookup
	psamrm - NT_MEMORY object to receive data
	psamsnum - NE_MEMORY object to receive Name Use data

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_DOMAIN::TranslateNamesToRids( const TCHAR * const * ppszNames,
				 ULONG cNames,
                                 SAM_RID_MEM *psamrm,
				 SAM_SID_NAME_USE_MEM *psamsnum) const
{
    ASSERT( ppszNames != NULL );
    ASSERT( *ppszNames != NULL );
    ASSERT( psamrm != NULL );
    ASSERT( psamsnum != NULL );

    if ( cNames == 0 )
    {
	psamrm->Set( NULL, 0 );
	psamsnum->Set( NULL, 0 );
	return ERRMAP::MapNTStatus( STATUS_NONE_MAPPED );
    }

    ULONG *		pulRids;
    SID_NAME_USE *	psidnu;
    APIERR		err;
    UINT		i;

    // First create and fill in the array of UNICODE_STRINGs
    UNICODE_STRING *aunicodeNames = new UNICODE_STRING[ cNames ];

    if (aunicodeNames == NULL)
    {
	return ERROR_NOT_ENOUGH_MEMORY;
    }


    UINT cAllocd = 0;

    for ( i = 0; i < cNames; i++ )
    {
	ALIAS_STR nlsTemp = *ppszNames++;

	if ( (err = ::FillUnicodeString( &aunicodeNames[i], nlsTemp ) )
		!= NERR_Success )
	{
	    break;
	}
	cAllocd++;
    }


    if ( err == NERR_Success )
    {
	err = ERRMAP::MapNTStatus(
			::SamLookupNamesInDomain( QueryHandle(),
						  cNames,
						  aunicodeNames,
						  &pulRids,
						  &psidnu ) );
    }



    if ( err == NERR_Success )
    {
	psamrm->Set( pulRids, cNames );
	psamsnum->Set( psidnu, cNames );
    }

    // Free the array of UNICODE_STRINGS
    for ( i = 0; i < cAllocd; i++ )
    {
	::FreeUnicodeString( &aunicodeNames[i] );
    }
    delete [] aunicodeNames;

    return err;
}


/*******************************************************************

    NAME: SAM_DOMAIN::EnumerateAliases

    SYNOPSIS: Wrapper for SamEnumerateAliasesInDomain()

    ENTRY:
	   psamrem - pointer to MEM object to receive the data.

	   psamenumh -	pointer to enumeration handle
			This should initially point to a variable initialized
			to 0.  If the call returns ERROR_MORE_DATA, then
			another call should be made using the returned
			plsaenumh to get the next block of data.
	   cbRequested - recommended maximum amount of data to return.

    EXIT:  NERR_Success or ERROR_MORE_DATA on success.

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_DOMAIN::EnumerateAliases( SAM_RID_ENUMERATION_MEM * psamrem,
				     PSAM_ENUMERATE_HANDLE psamenumh,
				     ULONG cbRequested ) const
{
    ASSERT( psamrem != NULL );

    ULONG cEntriesRead;
    PVOID pvBuffer;


    APIERR err = ERRMAP::MapNTStatus(
	::SamEnumerateAliasesInDomain( QueryHandle(),
				       psamenumh,
				       &pvBuffer,
				       cbRequested,
				       &cEntriesRead ));
    if ( err == NERR_Success || err == ERROR_MORE_DATA )
    {
	psamrem->Set( pvBuffer, cEntriesRead );
    }

    return err;
}


/*******************************************************************

    NAME: SAM_DOMAIN::EnumerateUsers

    SYNOPSIS: Wrapper for SamEnumerateUsersInDomain()

    ENTRY:
	   psamrem - pointer to MEM object to receive the data.

	   psamenumh -	pointer to enumeration handle
			This should initially point to a variable initialized
			to 0.  If the call returns ERROR_MORE_DATA, then
			another call should be made using the returned
			plsaenumh to get the next block of data.
	   cbRequested - recommended maximum amount of data to return.

    EXIT:  NERR_Success or ERROR_MORE_DATA on success.

    NOTES:

    HISTORY:
	thomaspa	04/13/92	Created

********************************************************************/
APIERR SAM_DOMAIN::EnumerateUsers( SAM_RID_ENUMERATION_MEM * psamrem,
				     PSAM_ENUMERATE_HANDLE psamenumh,
				     ULONG fAccountControl,
				     ULONG cbRequested ) const
{
    ASSERT( psamrem != NULL );

    ULONG cEntriesRead;
    PVOID pvBuffer;


    APIERR err = ERRMAP::MapNTStatus(
	::SamEnumerateUsersInDomain( QueryHandle(),
				     psamenumh,
				     fAccountControl,
				     &pvBuffer,
				     cbRequested,
				     &cEntriesRead ));
    if ( err == NERR_Success || err == ERROR_MORE_DATA )
    {
	psamrem->Set( pvBuffer, cEntriesRead );
    }

    return err;
}

/*******************************************************************

    NAME: SAM_DOMAIN::EnumerateGroups

    SYNOPSIS: Wrapper for SamEnumerateGroupsInDomain()

    ENTRY:
	   psamrem - pointer to MEM object to receive the data.

	   psamenumh -	pointer to enumeration handle
			This should initially point to a variable initialized
			to 0.  If the call returns ERROR_MORE_DATA, then
			another call should be made using the returned
			plsaenumh to get the next block of data.
	   cbRequested - recommended maximum amount of data to return.

    EXIT:  NERR_Success or ERROR_MORE_DATA on success.

    NOTES:

    HISTORY:
	Johnl	    20-Oct-1992     Copied from EnumerateAliases

********************************************************************/

APIERR SAM_DOMAIN::EnumerateGroups( SAM_RID_ENUMERATION_MEM * psamrem,
				     PSAM_ENUMERATE_HANDLE psamenumh,
				     ULONG cbRequested ) const
{
    ASSERT( psamrem != NULL );

    ULONG cEntriesRead;
    PVOID pvBuffer;


    APIERR err = ERRMAP::MapNTStatus(
	::SamEnumerateGroupsInDomain( QueryHandle(),
				       psamenumh,
				       &pvBuffer,
				       cbRequested,
				       &cEntriesRead ));
    if ( err == NERR_Success || err == ERROR_MORE_DATA )
    {
	psamrem->Set( pvBuffer, cEntriesRead );
    }

    return err;
}



/*******************************************************************

    NAME: SAM_DOMAIN::EnumerateAliasesForUser

    SYNOPSIS: Wrapper for SamEnumerateAliasesForUser

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_DOMAIN::EnumerateAliasesForUser( PSID psidUser,
				    SAM_RID_MEM * psamrm ) const
{
    ASSERT( psamrm != NULL );

    ULONG cAliases;
    ULONG *pulRids;

    APIERR err = ERRMAP::MapNTStatus(
			::SamGetAliasMembership( QueryHandle(),
						 1,
						 &psidUser,
						 &cAliases,
						 &pulRids ) );

    if ( err == NERR_Success )
    {
	psamrm->Set( pulRids, cAliases );
    }

    return err;
}



/*******************************************************************

    NAME: SAM_DOMAIN::RemoveMemberFromAliases

    SYNOPSIS: Wrapper for SamRemoveMemberFromForeignDomain

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	02/06/92	Created

********************************************************************/
APIERR SAM_DOMAIN::RemoveMemberFromAliases( PSID psidMember )
{
    return ERRMAP::MapNTStatus(
			::SamRemoveMemberFromForeignDomain( QueryHandle(),
                                                            psidMember )
                              );
}



/*******************************************************************

    NAME: SAM_ALIAS::SAM_ALIAS

    SYNOPSIS: Opens an existing alias or Creates a New Alias

    ENTRY: samdom - SAM_DOMAIN for domain in which to open/create alias
	   accessDesired - security access requested
	   ( open form ) ulAliasRid - Rid for alias to open
	   ( create form ) pszName - name of alias to create

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/03/92	Created

********************************************************************/
/* Open an existing alias */
SAM_ALIAS::SAM_ALIAS(	const SAM_DOMAIN & samdom,
			ULONG ulAliasRid,
			ACCESS_MASK accessDesired )
	: _ulRid( MAXULONG )
{
    SAM_HANDLE hsamAlias;

    APIERR err = ERRMAP::MapNTStatus(
			:: SamOpenAlias( samdom.QueryHandle(),
					 accessDesired,
					 ulAliasRid,
					 &hsamAlias ) );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    SetHandle( hsamAlias );
    _ulRid = ulAliasRid;
}


/* Create a new alias */
SAM_ALIAS::SAM_ALIAS( const SAM_DOMAIN & samdom,
			const TCHAR *pszName,
			ACCESS_MASK accessDesired )
	: _ulRid( MAXULONG )
{
    ASSERT( pszName != NULL );

    if ( QueryError() )
	return;

    SAM_HANDLE hsamAlias;
    ULONG ulRid;
    UNICODE_STRING unistr;
    ALIAS_STR nlsTemp = pszName;
    APIERR err;

    if ( (err = ::FillUnicodeString( &unistr, nlsTemp )) != NERR_Success )
    {
	ReportError( err );
	return;
    }

    err = ERRMAP::MapNTStatus(
	::SamCreateAliasInDomain( samdom.QueryHandle(),
			  &unistr,
			  accessDesired,
			  &hsamAlias,
			  &ulRid ) );

    FreeUnicodeString( &unistr );

    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    SetHandle( hsamAlias );
    _ulRid = ulRid;
}




/*******************************************************************

    NAME: SAM_ALIAS::~SAM_ALIAS

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
SAM_ALIAS::~SAM_ALIAS()
{
    _ulRid = MAXULONG;
}




/*******************************************************************

    NAME: SAM_ALIAS::Delete

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::Delete()
{
    ASSERT( QueryHandle() != NULL );

    APIERR err = ERRMAP::MapNTStatus(
	::SamDeleteAlias( QueryHandle() ) );

    ResetHandle();

    return err;
}




/*******************************************************************

    NAME: SAM_ALIAS::GetMembers

    SYNOPSIS: Get the members of an alias

    ENTRY: psamsm - pointer to NT_MEMORY object to receive the members

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::GetMembers( SAM_SID_MEM * psamsm )
{
    ASSERT( psamsm != NULL );

    PSID * ppsidMembers;
    ULONG cMembers;
    APIERR err = ERRMAP::MapNTStatus(
	::SamGetMembersInAlias( QueryHandle(),
				&ppsidMembers,
				&cMembers ) );
    if ( err == NERR_Success )
	psamsm->Set( (PVOID)ppsidMembers, cMembers );
    return err;
}




/*******************************************************************

    NAME: SAM_ALIAS::AddMember

    SYNOPSIS: Add a member to an alias

    ENTRY: psidMemberSid - sid of member to add

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::AddMember( PSID psidMemberSid )
{
    return ERRMAP::MapNTStatus(
	::SamAddMemberToAlias( QueryHandle(),
			       psidMemberSid ) );

}




/*******************************************************************

    NAME: SAM_ALIAS::RemoveMember

    SYNOPSIS: Removes a member from an alias

    ENTRY: psidMemberSid - Member to remove

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::RemoveMember( PSID psidMemberSid )
{
    return ERRMAP::MapNTStatus(
	::SamRemoveMemberFromAlias( QueryHandle(),
				    psidMemberSid ) );
}




/*******************************************************************

    NAME: SAM_ALIAS::AddMembers

    SYNOPSIS: Add several members to an alias

    ENTRY: apsidMemberSids - sids of members to add
           cSidCount - number of members to add

    EXIT:

    NOTES:

    HISTORY:
        jonn            09/28/94        Created
        jonn            10/08/94        new API now available

********************************************************************/
APIERR SAM_ALIAS::AddMembers( PSID * apsidMemberSids, UINT cSidCount )
{
    APIERR err = NERR_Success;
    if (cSidCount == 0)
    {
        TRACEEOL( "SAM_ALIAS::AddMembers(); cSidCount==0" );
        return NERR_Success;
#ifdef NO_SUCH_API
    } else if (cSidCount > 1) {
        err = ERRMAP::MapNTStatus(
            ::SamAddMultipleMembersToAlias( QueryHandle(),
    			                    apsidMemberSids,
                                            cSidCount ) );
        //
        // Since any number of different error codes could come back if the
        // target server does not support this API, we fall through to
        // AddMember on any error.
        //
        if (err == NERR_Success)
           return NERR_Success;

        DBGEOL( "SAM_ALIAS::AddMembers(): error in new API " << err );
        err = NERR_Success;
#endif
    }

    for (UINT i = 0; i < cSidCount; i++)
    {
        err = AddMember( apsidMemberSids[i] );
        if (   err != NERR_Success
            && err != STATUS_MEMBER_IN_ALIAS
            && err != ERROR_MEMBER_IN_ALIAS )
        {
            DBGEOL(   "SAM_ALIAS::AddMembers(); error " << err
                   << "adding member " << i );
            return err;
        }
    }
    return NERR_Success;
}




/*******************************************************************

    NAME: SAM_ALIAS::RemoveMembers

    SYNOPSIS: Remove several members from an alias

    ENTRY: apsidMemberSids - sids of members to remove
           cSidCount - number of members to remove

    EXIT:

    NOTES:

    HISTORY:
        jonn            09/28/94        Created
        jonn            10/08/94        new API now available

********************************************************************/
APIERR SAM_ALIAS::RemoveMembers( PSID * apsidMemberSids, UINT cSidCount )
{
    APIERR err = NERR_Success;
    if (cSidCount == 0)
    {
        TRACEEOL( "SAM_ALIAS::RemoveMembers(); cSidCount==0" );
        return NERR_Success;
#ifdef NO_SUCH_API
    } else if (cSidCount > 1) {
        err = ERRMAP::MapNTStatus(
                ::SamRemoveMultipleMembersFromAlias( QueryHandle(),
                                                     apsidMemberSids,
                                                     cSidCount ) );
        //
        // Since any number of different error codes could come back if the
        // target server does not support this API, we fall through to
        // RemoveMember on any error.
        //
        if (err == NERR_Success)
           return NERR_Success;

        DBGEOL( "SAM_ALIAS::RemoveMembers(): error in new API " << err );
        err = NERR_Success;
#endif
    }

    for (UINT i = 0; i < cSidCount; i++)
    {
        err = RemoveMember( apsidMemberSids[i] );
        if (   err != NERR_Success
            && err != STATUS_MEMBER_NOT_IN_ALIAS
            && err != ERROR_MEMBER_NOT_IN_ALIAS )
        {
            DBGEOL(   "SAM_ALIAS::RemoveMembers(); error " << err
                   << "removing member " << i );
            return err;
        }
    }
    return NERR_Success;
}




/*******************************************************************

    NAME: SAM_ALIAS::GetComment

    SYNOPSIS: Gets the Comment for an alias using SamGetInformationAlias()

    ENTRY: pnlsComment - pointer an NLS_STR to receive the comment

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::GetComment( NLS_STR * pnlsComment )
{

    ASSERT( pnlsComment != NULL );

    PALIAS_ADM_COMMENT_INFORMATION paaci;

    APIERR err = ERRMAP::MapNTStatus(
		::SamQueryInformationAlias( QueryHandle(),
					    AliasAdminCommentInformation,
					    (PVOID *)&paaci ) );
    if ( err == NERR_Success )
    {
	err = pnlsComment->MapCopyFrom( paaci->AdminComment.Buffer,
					    paaci->AdminComment.Length );
	::SamFreeMemory( (PVOID)paaci );
    }


    return err;
}


/*******************************************************************

    NAME: SAM_ALIAS::SetComment

    SYNOPSIS: Sets the Comment for an alias using SamSetInformationAlias()

    ENTRY: pnlsComment - comment text

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	02/06/92	Created from ntsam.hxx

********************************************************************/
APIERR SAM_ALIAS::SetComment( const NLS_STR * pnlsComment )
{
    ALIAS_ADM_COMMENT_INFORMATION aaci;

    APIERR err = ::FillUnicodeString( &aaci.AdminComment, *pnlsComment );
    if ( err == NERR_Success )
    {
	err = ERRMAP::MapNTStatus(
		::SamSetInformationAlias( QueryHandle(),
					  AliasAdminCommentInformation,
					  (PVOID)&aaci ) );
    }

    FreeUnicodeString( &aaci.AdminComment );
    return err;
}


/*******************************************************************

    NAME: SAM_ALIAS::QueryRID

    SYNOPSIS: Returns the RID for this alias.  Works if alias was
              constructed successfully, regardless of whether it existed
              already or was just created.

    EXIT:       RID for alias

    NOTES:

    HISTORY:
        jonn            05/04/94        Created by JonN (was already defined)

********************************************************************/
ULONG SAM_ALIAS::QueryRID()
{
    ASSERT( QueryError() == NERR_Success );
    return _ulRid;
}



/*******************************************************************

    NAME: SAM_USER::SAM_USER

    SYNOPSIS: Opens an existing user

    ENTRY: samdom - SAM_DOMAIN for domain in which to open user
	   accessDesired - security access requested
	   ulUserRid - Rid for user to open

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
/* Open an existing user */
SAM_USER::SAM_USER(	const SAM_DOMAIN & samdom,
			ULONG ulUserRid,
			ACCESS_MASK accessDesired )
	: _ulRid( MAXULONG )
{
    SAM_HANDLE hsamUser;

    APIERR err = ERRMAP::MapNTStatus(
			:: SamOpenUser(  samdom.QueryHandle(),
					 accessDesired,
					 ulUserRid,
					 &hsamUser ) );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    SetHandle( hsamUser );
    _ulRid = ulUserRid;
}




/*******************************************************************

    NAME: SAM_USER::~SAM_USER

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
SAM_USER::~SAM_USER()
{
    _ulRid = MAXULONG;
}



/*******************************************************************

    NAME: SAM_USER::SetUsername

    SYNOPSIS: Sets the Username for an user using SamSetInformationUser()

    ENTRY: pnlsUsername - username

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
APIERR SAM_USER::SetUsername( const NLS_STR * pnlsUsername )
{
    USER_ACCOUNT_NAME_INFORMATION uani;

    APIERR err = ::FillUnicodeString( &uani.UserName, *pnlsUsername );
    if ( err == NERR_Success )
    {
	err = ERRMAP::MapNTStatus(
		::SamSetInformationUser(  QueryHandle(),
					  UserAccountNameInformation,
					  (PVOID)&uani ) );
    }

    FreeUnicodeString( &uani.UserName );
    return err;
}

/*******************************************************************

    NAME:      SAM_USER::SetPassword

    SYNOPSIS:  Changes the password for a user using the old password

    ENTRY:     const NLS_STR * pnlsOldPassword   -- old password for user
               const NLS_STR * pnlsNewPassword   -- new password for user

    EXIT:

    NOTES:

    HISTORY:
        DavidHov       08/06/92        Created

********************************************************************/
APIERR SAM_USER :: SetPassword (
    const NLS_STR & nlsOldPassword,
    const NLS_STR & nlsNewPassword )
{
    UNICODE_STRING unsOldPw,
                   unsNewPw ;
    APIERR err = 0 ;

    unsOldPw.Buffer = unsNewPw.Buffer = NULL ;

    do
    {
        if ( err = ::FillUnicodeString( & unsOldPw, nlsOldPassword ) )
            break ;

        if ( err = ::FillUnicodeString( & unsNewPw, nlsNewPassword ) )
            break ;

	err = ERRMAP::MapNTStatus(
		::SamChangePasswordUser(  QueryHandle(),
                                          & unsOldPw,
                                          & unsNewPw ) ) ;
    }
    while ( FALSE ) ;

    if ( unsOldPw.Buffer )
    {
       ::FreeUnicodeString( & unsOldPw );
    }

    if ( unsNewPw.Buffer )
    {
       ::FreeUnicodeString( & unsNewPw );
    }

    return err ;
}


/*******************************************************************

    NAME:      SAM_USER::SetPassword

    SYNOPSIS:  Changes the password to a new value

    ENTRY:     const NLS_STR * pnlsPassword   -- password for user
               BOOL fPasswordExpired          -- expiration flag

    EXIT:

    NOTES:

    HISTORY:
        DavidHov       09/03/92        Created

********************************************************************/
APIERR SAM_USER :: SetPassword (
    const NLS_STR & nlsPassword,
    BOOL fPasswordExpired )
{
    APIERR err = 0 ;
    USER_SET_PASSWORD_INFORMATION uspi ;

    uspi.Password.Buffer = NULL ;
    uspi.PasswordExpired = (fPasswordExpired != FALSE);

    do
    {
        if ( err = ::FillUnicodeString( & uspi.Password, nlsPassword ) )
            break ;

        TRACEEOL( SZ("NETUI: SAM_USER::SetPassword to [")
                  << uspi.Password.Buffer
                  << SZ("] length ")
                  << (INT) uspi.Password.Length
                  << SZ(" max lgt ")
                  << (INT) uspi.Password.MaximumLength
                  << SZ(" p/w expired = ")
                  << fPasswordExpired );

	err = ERRMAP::MapNTStatus(
                ::SamSetInformationUser( QueryHandle(),
                                         UserSetPasswordInformation,
                                         & uspi ) ) ;
    }
    while ( FALSE ) ;

    if ( uspi.Password.Buffer )
    {
       ::FreeUnicodeString( & uspi.Password );
    }

    return err ;
}



/*******************************************************************

    NAME: SAM_GROUP::SAM_GROUP

    SYNOPSIS: Opens an existing group

    ENTRY: samdom - SAM_DOMAIN for domain in which to open group
	   accessDesired - security access requested
	   ulGroupRid - Rid for group to open

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
/* Open an existing group */
SAM_GROUP::SAM_GROUP(	const SAM_DOMAIN & samdom,
			ULONG ulGroupRid,
			ACCESS_MASK accessDesired )
	: _ulRid( MAXULONG )
{
    SAM_HANDLE hsamGroup;

    APIERR err = ERRMAP::MapNTStatus(
			:: SamOpenGroup( samdom.QueryHandle(),
					 accessDesired,
					 ulGroupRid,
					 &hsamGroup ) );
    if ( err != NERR_Success )
    {
	ReportError( err );
	return;
    }

    SetHandle( hsamGroup );
    _ulRid = ulGroupRid;
}




/*******************************************************************

    NAME: SAM_GROUP::~SAM_GROUP

    SYNOPSIS: Destructor

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
SAM_GROUP::~SAM_GROUP()
{
    _ulRid = MAXULONG;
}

/*******************************************************************

    NAME: SAM_GROUP::SetGroupname

    SYNOPSIS: Sets the Groupname for a global group using
              SamSetInformationGroup()

    ENTRY: pnlsGroupname - groupname

    EXIT:

    NOTES:

    HISTORY:
        jonn            05/31/94        Templated from SetUsername

********************************************************************/
APIERR SAM_GROUP::SetGroupname( const NLS_STR * pnlsGroupname )
{
    GROUP_NAME_INFORMATION gni;

    APIERR err = ::FillUnicodeString( &gni.Name, *pnlsGroupname );
    if ( err == NERR_Success )
    {
	err = ERRMAP::MapNTStatus(
		::SamSetInformationGroup(  QueryHandle(),
					   GroupNameInformation,
					   (PVOID)&gni ) );
    }

    FreeUnicodeString( &gni.Name );
    return err;
}

/*******************************************************************

    NAME: SAM_GROUP::GetComment

    SYNOPSIS: Gets the Comment for an Group using SamGetInformationGroup()

    ENTRY: pnlsComment - pointer an NLS_STR to receive the comment

    EXIT:

    NOTES:

    HISTORY:
	Johnl	    20-Oct-1992     Copied from SAM_ALIAS

********************************************************************/

APIERR SAM_GROUP::GetComment( NLS_STR * pnlsComment )
{
    ASSERT( pnlsComment != NULL );

    PGROUP_ADM_COMMENT_INFORMATION paaci;

    APIERR err = ERRMAP::MapNTStatus(
		::SamQueryInformationGroup( QueryHandle(),
					    GroupAdminCommentInformation,
					    (PVOID *)&paaci ) );
    if ( err == NERR_Success )
    {
	err = pnlsComment->MapCopyFrom( paaci->AdminComment.Buffer,
					paaci->AdminComment.Length );
	::SamFreeMemory( (PVOID)paaci );
    }

    return err;
}




/*******************************************************************

    NAME: SAM_GROUP::GetMembers

    SYNOPSIS: Wrapper for SamGetMembersInGroup

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/29/92        Created

********************************************************************/
APIERR SAM_GROUP::GetMembers( SAM_RID_MEM * psamrm )
{
    ASSERT( psamrm != NULL );

    ULONG   cMembers;
    ULONG * pulRids;
    ULONG * pulAttributes;

    APIERR err = ERRMAP::MapNTStatus(
			::SamGetMembersInGroup( QueryHandle(),
					        &pulRids,
					        &pulAttributes,
					        &cMembers ) );

    if ( err == NERR_Success )
    {
	psamrm->Set( pulRids, cMembers );

        // We don't care about attributes, delete them
        REQUIRE( ::SamFreeMemory( pulAttributes ) == STATUS_SUCCESS );
    }

    return err;
}


/*******************************************************************

    NAME: SAM_GROUP::AddMember

    SYNOPSIS: Add a member to a group

    ENTRY: ulMemberRid - rid of member to add

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/12/94        Created

********************************************************************/
APIERR SAM_GROUP::AddMember( ULONG ulMemberRid )
{
    return ERRMAP::MapNTStatus(
	::SamAddMemberToGroup( QueryHandle(),
			       ulMemberRid,
                               SE_GROUP_MANDATORY | SE_GROUP_ENABLED) );

}




/*******************************************************************

    NAME: SAM_GROUP::RemoveMember

    SYNOPSIS: Removes a member from a group

    ENTRY: ulMemberRid - Member to remove

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/12/94        Created

********************************************************************/
APIERR SAM_GROUP::RemoveMember( ULONG ulMemberRid )
{
    return ERRMAP::MapNTStatus(
	::SamRemoveMemberFromGroup( QueryHandle(),
				    ulMemberRid ) );
}




/*******************************************************************

    NAME: SAM_GROUP::AddMembers

    SYNOPSIS: Add several members to a group

    ENTRY: aridMemberRids - rids of members to add
           cRidCount - number of members to add

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/12/94        Created (new API now available)

********************************************************************/
APIERR SAM_GROUP::AddMembers( ULONG * aridMemberRids, UINT cRidCount )
{
    APIERR err = NERR_Success;
    if (cRidCount == 0)
    {
        TRACEEOL( "SAM_GROUP::AddMembers(); cRidCount==0" );
        return NERR_Success;
#ifdef NO_SUCH_API
    } else if (cRidCount > 1) {
        err = ERRMAP::MapNTStatus(
    	    ::SamAddMultipleMembersToGroup( QueryHandle(),
                                            aridMemberRids,
                                            cRidCount ) );
        //
        // Since any number of different error codes could come back if the
        // target server does not support this API, we fall through to
        // AddMember on any error.
        //
        if (err == NERR_Success)
           return NERR_Success;

        DBGEOL( "SAM_GROUP::AddMembers(): error in new API " << err );
        err = NERR_Success;
#endif
    }

    for (UINT i = 0; i < cRidCount; i++)
    {
        err = AddMember( aridMemberRids[i] );
        if (   err != NERR_Success
            && err != STATUS_MEMBER_IN_GROUP
            && err != ERROR_MEMBER_IN_GROUP )
        {
            DBGEOL(   "SAM_GROUP::AddMembers(); error " << err
                   << "adding member " << i );
            return err;
        }
    }
    return NERR_Success;
}




/*******************************************************************

    NAME: SAM_GROUP::RemoveMembers

    SYNOPSIS: Remove several members from a group

    ENTRY: aridMemberRids - rids of members to remove
           cRidCount - number of members to remove

    EXIT:

    NOTES:

    HISTORY:
        jonn            10/12/94        Created (new API now available)

********************************************************************/
APIERR SAM_GROUP::RemoveMembers( ULONG * aridMemberRids, UINT cRidCount )
{
    APIERR err = NERR_Success;
    if (cRidCount == 0)
    {
        TRACEEOL( "SAM_GROUP::RemoveMembers(); cRidCount==0" );
        return NERR_Success;
#ifdef NO_SUCH_API
    } else if (cRidCount > 1) {
        err = ERRMAP::MapNTStatus(
    	       ::SamRemoveMultipleMembersFromGroup( QueryHandle(),
                                                    aridMemberRids,
                                                    cRidCount ) );
        //
        // Since any number of different error codes could come back if the
        // target server does not support this API, we fall through to
        // RemoveMember on any error.
        //
        if (err == NERR_Success)
           return NERR_Success;

        DBGEOL( "SAM_GROUP::RemoveMembers(): error in new API " << err );
        err = NERR_Success;
#endif
    }

    for (UINT i = 0; i < cRidCount; i++)
    {
        err = RemoveMember( aridMemberRids[i] );
        if (   err != NERR_Success
            && err != STATUS_MEMBER_NOT_IN_GROUP
            && err != ERROR_MEMBER_NOT_IN_GROUP )
        {
            DBGEOL(   "SAM_GROUP::RemoveMembers(); error " << err
                   << "removing member " << i );
            return err;
        }
    }
    return NERR_Success;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ADMIN_AUTHORITY

    SYNOPSIS: Constructor

    ENTRY: pszServerName - target machine name
	   accessAccountDomain - access desired for Account domain
	   accessBuiltinDomain - access desired for Builtin domain
	   accessLSA - access desired for LSA_POLICY object
	   accessServer - access desired for Sam Server object

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created
        jonn            07/06/92        Added ReplaceAccountDomain

********************************************************************/
ADMIN_AUTHORITY::ADMIN_AUTHORITY( const TCHAR * pszServerName,
                  ACCESS_MASK accessAccountDomain,
		  ACCESS_MASK accessBuiltinDomain,
                  ACCESS_MASK accessLSA,
		  ACCESS_MASK accessServer,
		  BOOL	      fNullSessionOk )
    : _nlsServerName( pszServerName ),
      _psamsrv( NULL ),
      _psamdomAccount( NULL ),
      _psamdomBuiltin( NULL ),
      _plsapol( NULL ),
      _papisess( NULL )
{
    if ( QueryError() )
    {
	return;
    }

    APIERR err;

    // if a non-NULL servername was specified, create an API_SESSION to
    // the server before trying to make any other API calls.
    if ( pszServerName != NULL )
    {
	_papisess = new API_SESSION( pszServerName, fNullSessionOk );

	err = ERROR_NOT_ENOUGH_MEMORY;
	if ( _papisess == NULL
	    || (err = _papisess->QueryError()) != NERR_Success )
	{
	    delete _papisess;
	    _papisess = NULL;
	    ReportError( err );
	}
    }

    if (   (err = _nlsServerName.QueryError()) != NERR_Success
        || (err = ReplaceSamServer( accessServer )) != NERR_Success
        || (err = ReplaceLSAPolicy( accessLSA )) != NERR_Success
        || (err = ReplaceBuiltinDomain( accessBuiltinDomain )) != NERR_Success
        || (err = ReplaceAccountDomain( accessAccountDomain )) != NERR_Success
       )
    {
	ReportError( err );
    }

    return;


}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::~ADMIN_AUTHORITY

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
ADMIN_AUTHORITY::~ADMIN_AUTHORITY()
{
    delete _psamsrv;
    delete _psamdomAccount;
    delete _psamdomBuiltin;
    delete _plsapol;
    delete _papisess;

    _psamsrv = NULL;
    _psamdomAccount = NULL;
    _psamdomBuiltin = NULL;
    _plsapol = NULL;
    _papisess = NULL;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ReplaceSamServer

    SYNOPSIS:   Replaces the current SamServer handle with another
                one, presumably one with different access.  If the
                attempt to obtain the new handle fails, the old one
                is left in place.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::ReplaceSamServer(
            ACCESS_MASK accessServer )
{
    APIERR err = NERR_Success;

    /*
     * Construct SAM_SERVER
     */
    SAM_SERVER * psamsrvNew = new SAM_SERVER( _nlsServerName, accessServer );

    if ( psamsrvNew == NULL )
        err = ERROR_NOT_ENOUGH_MEMORY;
    else if ( (err = psamsrvNew->QueryError()) != NERR_Success )
    {
        delete psamsrvNew;
    }
    else
    {
        delete _psamsrv;
        _psamsrv = psamsrvNew;
        _accessSamServer = accessServer;
    }

    return err;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ReplaceLSAPolicy

    SYNOPSIS:   Replaces the current LSA Policy handle with another
                one, presumably one with different access.  If the
                attempt to obtain the new handle fails, the old one
                is left in place.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::ReplaceLSAPolicy(
            ACCESS_MASK accessLSA )
{
    APIERR err = NERR_Success;

    /*
     * Construct LSA_POLICY
     */
    LSA_POLICY * plsapolNew = new LSA_POLICY( _nlsServerName, accessLSA );

    if ( plsapolNew == NULL )
    {
        err = ERROR_NOT_ENOUGH_MEMORY;
    }
    else if ( (err = plsapolNew->QueryError()) != NERR_Success )
    {
        delete plsapolNew;
    }
    else
    {
        delete _plsapol;
        _plsapol = plsapolNew;
        _accessLSAPolicy = accessLSA;
    }

    return err;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ReplaceBuiltinDomain

    SYNOPSIS:   Replaces the current Builtin Domain handle with another
                one, presumably one with different access.  If the
                attempt to obtain the new handle fails, the old one
                is left in place.

    ENTRY:      SAM Server handle must be ready, any access.

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/07/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::ReplaceBuiltinDomain(
            ACCESS_MASK accessBuiltinDomain )
{
    ASSERT( (_psamsrv != NULL) && (_psamsrv->QueryError() == NERR_Success) );

    APIERR err = NERR_Success;

    /*
     * Construct SAM_DOMAIN for Builtin domain
     */

    OS_SID ossidBuiltIn;

    do		// FAKE LOOP FOR ERROR HANDLING
    {
        if (   (err = ossidBuiltIn.QueryError()) != NERR_Success
            || (err = NT_ACCOUNTS_UTILITY::QuerySystemSid( UI_SID_BuiltIn,
                                                           &ossidBuiltIn ))
                                                  != NERR_Success
           )
        {
            break;
        }

	PSID psidBuiltin = ossidBuiltIn.QuerySid();

	SAM_DOMAIN * psamdomBuiltinNew = new SAM_DOMAIN(
                                          *_psamsrv,
                                          psidBuiltin,
                                          accessBuiltinDomain );

	if ( psamdomBuiltinNew == NULL )
        {
	    err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if ( (err = psamdomBuiltinNew->QueryError()) != NERR_Success )
	{
            delete psamdomBuiltinNew;
	}
        else
        {
            delete _psamdomBuiltin;
            _psamdomBuiltin = psamdomBuiltinNew;
            _accessBuiltinDomain = accessBuiltinDomain;
        }

    } while ( FALSE );	// FAKE LOOP FOR ERROR HANDLING

    return err;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::ReplaceAccountDomain

    SYNOPSIS:   Replaces the current Account Domain handle with another
                one, presumably one with different access.  If the
                attempt to obtain the new handle fails, the old one
                is left in place.

    ENTRY:      LSA Policy handle must already be allocated, and must
                have at least POLICY_VIEW_LOCAL_INFORMATION access.
                SAM Server handle must also be ready, any access.

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/06/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::ReplaceAccountDomain(
            ACCESS_MASK accessAccountDomain )
{
    ASSERT( (_plsapol != NULL) && (_plsapol->QueryError() == NERR_Success) );
    ASSERT( (_psamsrv != NULL) && (_psamsrv->QueryError() == NERR_Success) );

    APIERR err = NERR_Success;

    /*
     * Construct SAM_DOMAIN for Account domain
     */
    LSA_ACCT_DOM_INFO_MEM lsaadim;

    do		// FAKE LOOP FOR ERROR HANDLING
    {

        if ( (err = lsaadim.QueryError()) != NERR_Success )
        {
            break;
        }

        if ( (err = _plsapol->GetAccountDomain( &lsaadim )) != NERR_Success)
        {
            break;
        }

        PSID psidAccount = lsaadim.QueryPSID( );

        SAM_DOMAIN * psamdomAccountNew = new SAM_DOMAIN(
                              *_psamsrv,
        		      psidAccount,
        		      accessAccountDomain );

        if ( psamdomAccountNew == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else if ( (err = psamdomAccountNew->QueryError()) != NERR_Success )
        {
            delete psamdomAccountNew;
        }
        else
        {
            delete _psamdomAccount;
            _psamdomAccount = psamdomAccountNew;
            _accessAccountDomain = accessAccountDomain;
        }

    } while ( FALSE );	// FAKE LOOP FOR ERROR HANDLING

    return err;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QuerySamServer

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
SAM_SERVER * ADMIN_AUTHORITY::QuerySamServer() const
{
    return _psamsrv;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccountDomain

    SYNOPSIS: returns pointer to SAM_DOMAIN object for Account domain

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
SAM_DOMAIN * ADMIN_AUTHORITY::QueryAccountDomain() const
{
    return _psamdomAccount;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryBuiltinDomain

    SYNOPSIS: returns pointer to SAM_DOMAIN object for Builtin domain

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
SAM_DOMAIN * ADMIN_AUTHORITY::QueryBuiltinDomain() const
{
    return _psamdomBuiltin;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryLSAPolicy

    SYNOPSIS: returns pointer to LSA_POLICY object

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	thomaspa	03/06/92	Created

********************************************************************/
LSA_POLICY * ADMIN_AUTHORITY::QueryLSAPolicy() const
{
    return _plsapol;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccessSamServer

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	07/20/92	Created

********************************************************************/
ACCESS_MASK ADMIN_AUTHORITY::QueryAccessSamServer() const
{
    return _accessSamServer;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccessLSAPolicy

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	07/20/92	Created

********************************************************************/
ACCESS_MASK ADMIN_AUTHORITY::QueryAccessLSAPolicy() const
{
    return _accessLSAPolicy;
}



/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccessBuiltinDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	07/20/92	Created

********************************************************************/
ACCESS_MASK ADMIN_AUTHORITY::QueryAccessBuiltinDomain() const
{
    return _accessBuiltinDomain;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::QueryAccessAccountDomain

    SYNOPSIS:

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
	jonn    	07/20/92	Created

********************************************************************/
ACCESS_MASK ADMIN_AUTHORITY::QueryAccessAccountDomain() const
{
    return _accessAccountDomain;
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::UpgradeSamServer

    SYNOPSIS:   Upgrades the current SamServer handle if it does not
                have at least the requested access.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/20/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::UpgradeSamServer(
            ACCESS_MASK accessServer )
{
    ACCESS_MASK accessNew = accessServer | QueryAccessSamServer();

    return (accessNew == QueryAccessSamServer())
                 ? NERR_Success
                 : ReplaceSamServer( accessNew );
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::UpgradeLSAPolicy

    SYNOPSIS:   Upgrades the current LSAPolicy handle if it does not
                have at least the requested access.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/20/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::UpgradeLSAPolicy(
            ACCESS_MASK accessLSA )
{
    ACCESS_MASK accessNew = accessLSA | QueryAccessLSAPolicy();

    return (accessNew == QueryAccessLSAPolicy())
                 ? NERR_Success
                 : ReplaceLSAPolicy( accessNew );
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::UpgradeBuiltinDomain

    SYNOPSIS:   Upgrades the current BuiltinDomain handle if it does not
                have at least the requested access.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/20/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::UpgradeBuiltinDomain(
            ACCESS_MASK accessBuiltinDomain )
{
    ACCESS_MASK accessNew = accessBuiltinDomain | QueryAccessBuiltinDomain();

    return (accessNew == QueryAccessBuiltinDomain())
                 ? NERR_Success
                 : ReplaceBuiltinDomain( accessNew );
}


/*******************************************************************

    NAME: ADMIN_AUTHORITY::UpgradeAccountDomain

    SYNOPSIS:   Upgrades the current AccountDomain handle if it does not
                have at least the requested access.

    ENTRY:

    EXIT:

    NOTES:

    HISTORY:
        jonn            07/20/92        Created

********************************************************************/
APIERR ADMIN_AUTHORITY::UpgradeAccountDomain(
            ACCESS_MASK accessAccountDomain )
{
    ACCESS_MASK accessNew = accessAccountDomain | QueryAccessAccountDomain();

    return (accessNew == QueryAccessAccountDomain())
                 ? NERR_Success
                 : ReplaceAccountDomain( accessNew );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\domenum.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    domenum.cxx
    This file contains the class definition for the BROWSE_DOMAIN_ENUM
    enumerator class.  It also contains the class definition for the
    BRWOSE_DOMAIN_INFO class, which is the return "type" of the domain
    enumerator.

    The BROWSE_DOMAIN_ENUM class is used to enumerate domains.  A number
    of bit flags are passed to the object's constructor to control the
    domain enumeration.

    BROWSE_DOMAIN_ENUM is quite different from the LM_ENUM class of
    enumerators.  All of the "grunt" work is performed in the constructor
    (there is no GetInfo method).

    NOTE:  This code is based on an initial design by Yi-HsinS.


    FILE HISTORY:
        KeithMo     22-Jul-1992     Created.
        KeithMo     16-Nov-1992     Performance tuning.

*/
#include "pchlmobj.hxx"

//
//  Some handy macros for manipulating BROWSE_*_DOMAIN[S] masks.
//

#define IS_EMPTY(mask)          ((mask) == 0L)
#define NOT_EMPTY(mask)         ((mask) != 0L)

#define IS_VALID(mask)          (NOT_EMPTY(mask) && \
                                 IS_EMPTY((mask) & BROWSE_RESERVED))

#define DOES_INCLUDE(a,b)       (NOT_EMPTY((a) & (b)))


//
//  This is the separator list for the "other domains" as
//  returned by the WKSTA_USER_1 (i.e. NetWkstaUserGetInfo) object.
//

#define OTHER_DOMAINS_SEP       SZ(" ")



//
//  BROWSE_DOMAIN_INFO methods.
//

/*******************************************************************

    NAME:       BROWSE_DOMAIN_INFO :: BROWSE_DOMAIN_INFO

    SYNOPSIS:   BROWSE_DOMAIN_INFO class constructor.

    ENTRY:      pszDomainName           - The name of the current domain.

                maskDomainSources       - The sources of the domain.  This
                                          will be one or more of the
                                          BROWSE_*_DOMAIN[S] bitflags.

    EXIT:       The object is constructed.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
BROWSE_DOMAIN_INFO :: BROWSE_DOMAIN_INFO( const TCHAR * pszDomainName,
                                          ULONG         maskDomainSources )
  : _nlsDomainName( pszDomainName ),
    _maskDomainSources( maskDomainSources )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( IS_VALID( maskDomainSources ) );

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDomainName )
    {
        ReportError( _nlsDomainName.QueryError() );
        return;
    }

    _pszDomainName = _nlsDomainName.QueryPch();
    UIASSERT( _pszDomainName != NULL );

}   // BROWSE_DOMAIN_INFO :: BROWSE_DOMAIN_INFO


/*******************************************************************

    NAME:       BROWSE_DOMAIN_INFO :: ~BROWSE_DOMAIN_INFO

    SYNOPSIS:   BROWSE_DOMAIN_INFO class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
BROWSE_DOMAIN_INFO :: ~BROWSE_DOMAIN_INFO( VOID )
{
    _pszDomainName  = NULL;

}   // BROWSE_DOMAIN_INFO :: ~BROWSE_DOMAIN_INFO


DEFINE_SLIST_OF( BROWSE_DOMAIN_INFO );



//
//  BROWSE_DOMAIN_ENUM methods.
//

/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: BROWSE_DOMAIN_ENUM

    SYNOPSIS:   BROWSE_DOMAIN_ENUM class constructor.

    ENTRY:      maskDomainSources       - A set of potential domain
                                          sources.  Must be a bit-OR
                                          combination of one or more
                                          BROWSE_*_DOMAIN[S] flags.

                pmaskSuccessful         - Will receive a bitmask of the
                                          "successful" domain sources.

    EXIT:       The object is constructed.

    NOTES:      Just because a particular bit is set in maskDomainSources
                and returned as successful in *pmaskSuccessful does *NOT*
                necessarily mean that such a domain was returned.

                For example, assume that this object is constructed with
                BROWSE_TRUSTING_DOMAINS set in maskDomainSources.  If the
                trusting domain enumerator is successful, then the
                BROWSE_TRUSTING_DOMAINS bit will get set in *pmaskSuccessful.
                However, the trusting domain enumerator *may* have returned
                an empty list of trusting domains.  In this case, the domain
                source succeeded, but there is no domain of the corresponding
                type in the domain list.

    HISTORY:
        KeithMo     22-Jul-1992     Created.
        Yi-HsinS    12-Nov-1992     Browse trusting domain only if it's
                                    absolutely needed

********************************************************************/
BROWSE_DOMAIN_ENUM :: BROWSE_DOMAIN_ENUM( ULONG   maskDomainSources,
                                          ULONG * pmaskSuccessful )
  : _slDomains(),
    _iterDomains( _slDomains ),
    _nlsComputerName(),
    _maskSourcesUnion( 0 )
{
    UIASSERT( IS_VALID( maskDomainSources ) );

    //
    //  Ensure we constructed properly.
    //

    APIERR err = QueryError();

    if( err == NERR_Success )
    {
        err = _nlsComputerName.QueryError();
    }

    //
    //  Get the local computer name.
    //

    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD cchBuffer = sizeof(szComputerName) / sizeof(TCHAR);

    if( err == NERR_Success )
    {
        if( !::GetComputerName( szComputerName, &cchBuffer ) )
        {
            err = (APIERR)::GetLastError();
        }
    }

    if( err == NERR_Success )
    {
        err = _nlsComputerName.CopyFrom( szComputerName );
    }

    if( err == NERR_Success )
    {
        _nlsComputerName._strupr();
    }

    //
    //  Bag-out if any of the preceeding steps failed.
    //

    if( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

    //
    //  We'll update the "success" mask as we invoke the
    //  requested domain sources.
    //

    ULONG maskSuccessful = 0L;

    //
    //  If the user wants workgroup domains, get 'em.
    //

    if( DOES_INCLUDE( maskDomainSources, BROWSE_WORKGROUP_DOMAINS ) )
    {
        err = GetWorkgroupDomains();

        if( err == NERR_Success )
        {
            maskSuccessful |= BROWSE_WORKGROUP_DOMAINS;
        }
    }

    //
    //  If the user wants the Lanman 2.x domains, add them
    //  to the list.  Note that we retrieve the logon, wksta,
    //  and other domains from a WKSTA_10 object.  Therefore,
    //  we'll get them all from the same worker method.
    //

    if( DOES_INCLUDE( maskDomainSources, BROWSE_LM2X_DOMAINS ) )
    {
        err = GetLanmanDomains( maskDomainSources );

        if( err == NERR_Success )
        {
            maskSuccessful |= ( maskDomainSources & BROWSE_LM2X_DOMAINS );
        }
    }


    //
    //  If the user wants trusting domains, get 'em.
    //  ( We will only get the trusting domain if we don't want the
    //    workgroup or if we can't get anything back from the
    //    workgroup )
    //

    if( DOES_INCLUDE( maskDomainSources, BROWSE_TRUSTING_DOMAINS ) &&
        !DOES_INCLUDE( maskSuccessful, BROWSE_WORKGROUP_DOMAINS ) )
    {
        err = GetTrustingDomains();

        if ( err == NERR_Success )
        {
            maskSuccessful |= BROWSE_TRUSTING_DOMAINS;
        }
    }

    //
    //  Now that everything's been added, reset the iterator
    //  so it's in sync with the new items in the collection.
    //

    Reset();

    //
    //  If the user wants the success mask, give it to 'em.
    //

    if( pmaskSuccessful != NULL )
    {
        *pmaskSuccessful = maskSuccessful;
    }

    //
    //  If *none* of the requested domain sources were
    //  successful, then we'll set our status to the
    //  error code returned by the *last* domain source.
    //
    //  CODEWORK:  There should probably be a better
    //             (i.e. more robust) error reporting
    //             mechanism for multiple domain sources!
    //

    if( IS_EMPTY( maskSuccessful ) )
    {
        ReportError( err );
    }

}   // BROWSE_DOMAIN_ENUM :: BROWSE_DOMAIN_ENUM


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: ~BROWSE_DOMAIN_ENUM

    SYNOPSIS:   BROWSE_DOMAIN_ENUM class destructor.

    EXIT:       The object is destroyed.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
BROWSE_DOMAIN_ENUM :: ~BROWSE_DOMAIN_ENUM( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // BROWSE_DOMAIN_ENUM :: ~BROWSE_DOMAIN_ENUM


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: FindFirst

    SYNOPSIS:   Implements a simple (minded) FindFirst/FindNext strategy.

    ENTRY:      maskDomainSources       - A bitmask of domain sources to
                                          search for.  The first domain
                                          that contains *any* of the bits
                                          in this mask will be returned.

    EXIT:       The _iterDomains iterator will have been reset to a new
                position.

    RETURNS:    BROWSE_DOMAIN_INFO *    - A pointer to the found domain,
                                          or NULL if none were found.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
const BROWSE_DOMAIN_INFO * BROWSE_DOMAIN_ENUM :: FindFirst(
                                                       ULONG maskDomainSources )
{
    UIASSERT( IS_VALID( maskDomainSources ) );

    //
    //  Reset to the beginning of the domain list.
    //

    Reset();

    //
    //  Let FindNext do the dirty work.
    //

    return FindNext( maskDomainSources );

}   // BROWSE_DOMAIN_ENUM :: FindFirst


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: FindNext

    SYNOPSIS:   Implements a simple (minded) FindFirst/FindNext strategy.

    ENTRY:      maskDomainSources       - A bitmask of domain sources to
                                          search for.  The next domain
                                          that contains *any* of the bits
                                          in this mask will be returned.

    EXIT:       The _iterDomains iterator will have been reset to a new
                position.

    RETURNS:    BROWSE_DOMAIN_INFO *    - A pointer to the found domain,
                                          or NULL if none were found.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
const BROWSE_DOMAIN_INFO * BROWSE_DOMAIN_ENUM :: FindNext(
                                                       ULONG maskDomainSources )
{
    UIASSERT( IS_VALID( maskDomainSources ) );

    //
    //  Scan the domain list starting at the current iteration point.
    //

    const BROWSE_DOMAIN_INFO * pbdi;

    while( ( pbdi = Next() ) != NULL )
    {
        //
        //  If the intersection of the current domain's sources list and
        //  the search criteria sources list is not empty, then we've
        //  found a winner.
        //

        if( DOES_INCLUDE( pbdi->QueryDomainSources(), maskDomainSources ) )
        {
            break;
        }
    }

    //
    //  At this point, pbdi will either be NULL (if we ran off the
    //  end of the domain list) or non-NULL (if we found a matching
    //  domain).
    //

    return pbdi;

}   // BROWSE_DOMAIN_ENUM :: FindNext


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: DetermineIfDomainMember

    SYNOPSIS:   This worker method determines if the current machine
                is a member of a domain or a workgroup.

    ENTRY:      pfIsDomainMember        - Will receive TRUE if the
                                          current machine is a member
                                          of a domain, FALSE otherwise.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     23-Jul-1992     Created.

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: DetermineIfDomainMember( BOOL * pfIsDomainMember )
{
    LSA_POLICY lsapol( NULL, GENERIC_EXECUTE );
    LSA_PRIMARY_DOM_INFO_MEM lsapdim;

    APIERR err = lsapol.QueryError();

    if( err == NERR_Success )
    {
        err = lsapdim.QueryError();
    }

    if( err == NERR_Success )
    {
        err = lsapol.GetPrimaryDomain( &lsapdim );
    }

    if( err == NERR_Success )
    {
        *pfIsDomainMember = ( lsapdim.QueryPSID() != NULL );
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: DetermineIfDomainMember


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: AddDomainToList

    SYNOPSIS:   This worker method will add a specified domain to the
                domain list.

    ENTRY:      pszDomainName           - The name of the (new?) domain.

                maskDomainSource        - The source of the domain.

                fBrowserList            - If this is TRUE, then the domain
                                          is assumed to be from the browser.
                                          The browser list is always in
                                          uppercase.

    EXIT:       _slDomains is updated.  If the specified domain is
                already in the domain list, then sources field for
                that domain is updated to include maskDomainSource.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      We make a check here to see if the given domain name
                matches the local machine name.  If so, the domain
                is *not* added to the list.  This is to prevent the
                inclusion of bogus domain names when the user is
                logged onto the local machine.

                Also, this code *MUST* maintain the list in sorted
                order.  OLLB depends on this to optimize listbox
                additions.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: AddDomainToList( const TCHAR * pszDomainName,
                                              ULONG         maskDomainSource,
                                              BOOL          fBrowserList )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( IS_VALID( maskDomainSource ) );

    APIERR err = NERR_Success;

    INT cmpres = 0;

    BROWSE_DOMAIN_INFO * pbdiScan = NULL;
    BDI_ITER iter( _slDomains );

    if( !fBrowserList )
    {
        {
            //
            //  Uppercase the name.
            //

            ALIAS_STR nlsDomainName( pszDomainName );
            UIASSERT( !!nlsDomainName );
            nlsDomainName._strupr();
        }

        //
        //  Check to see if the given domain matches
        //  the local machine name.  If so, ignore it.
        //

        if( !::I_MNetComputerNameCompare( pszDomainName, _nlsComputerName ) )
        {
            return NERR_Success;
        }

        //
        //  Scan the domain list to see if this domain
        //  already exists.
        //

        while( ( pbdiScan = iter.Next() ) != NULL )
        {
            cmpres = ::strcmpf( pszDomainName, pbdiScan->QueryDomainName() );

            if( cmpres <= 0 )
            {
                break;
            }
        }
    }

    if( ( pbdiScan != NULL ) && ( cmpres == 0 ) )
    {
        //
        //  The domain is already in the list.  Update the domain sources.
        //

        pbdiScan->AddDomainSource( maskDomainSource );
        _maskSourcesUnion |= maskDomainSource;
    }
    else
    {
        //
        //  The domain does not exist, so we get to create it.
        //

        BROWSE_DOMAIN_INFO * pbdiNew = new BROWSE_DOMAIN_INFO( pszDomainName,
                                                               maskDomainSource );

        err = ( pbdiNew == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                  : pbdiNew->QueryError();

        if( err == NERR_Success )
        {
            //
            //  Insert/append the node to the domain list.
            //

            err = ( pbdiScan == NULL ) ? _slDomains.Append( pbdiNew )
                                       : _slDomains.Insert( pbdiNew, iter );

            if( err != NERR_Success )
            {
                //
                //  The append failed.  Cleanup by deleting the
                //  BROWSE_DOMAIN_INFO node we created above.
                //

                delete pbdiNew;
                pbdiNew = NULL;
            }
            else
            {
                _maskSourcesUnion |= maskDomainSource;
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: AddDomainToList


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: GetLanmanDomains

    SYNOPSIS:   Retrieve the logon, wksta, and other domains, appending
                them to the domain list.

    ENTRY:      maskDomainSources       - Set of desired domain sources.

    EXIT:       If successful, _slDomains will be updated with
                the retrieved domains.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: GetLanmanDomains( ULONG maskDomainSources )
{
    UIASSERT( IS_VALID( maskDomainSources ) );
    UIASSERT( DOES_INCLUDE( maskDomainSources, BROWSE_LM2X_DOMAINS ) );

    //
    //  We'll use a WKSTA_10 object to retrieve the various
    //  Lanman 2.x domains.
    //

    WKSTA_10 wksta;

    APIERR err = wksta.GetInfo();

    //
    //  Add the logon domain, if requested.
    //

    if( ( err == NERR_Success ) &&
        DOES_INCLUDE( maskDomainSources, BROWSE_LOGON_DOMAIN ) )
    {
        const TCHAR * pszLogonDomain = wksta.QueryLogonDomain();

        if( pszLogonDomain != NULL )
        {
            err = AddDomainToList( pszLogonDomain,
                                   BROWSE_LOGON_DOMAIN );
        }
    }

    //
    //  Add the workstation domain, if requested.
    //

    if( ( err == NERR_Success ) &&
        DOES_INCLUDE( maskDomainSources, BROWSE_WKSTA_DOMAIN ) )
    {
        const TCHAR * pszWkstaDomain = wksta.QueryWkstaDomain();

        if( pszWkstaDomain != NULL )
        {
            err = AddDomainToList( pszWkstaDomain,
                                   BROWSE_WKSTA_DOMAIN );
        }
    }

    //
    //  Add the other domains, if requested.
    //

    if( ( err == NERR_Success ) &&
        DOES_INCLUDE( maskDomainSources, BROWSE_OTHER_DOMAINS ) )
    {
        WKSTA_USER_1 wkstaUser1;

        err = wkstaUser1.GetInfo();

        if( err == NERR_Success )
        {
            STRLIST slOtherDomains( wkstaUser1.QueryOtherDomains(),
                                    OTHER_DOMAINS_SEP );

            ITER_STRLIST islOtherDomains( slOtherDomains );
            NLS_STR * pnls;

            while( ( pnls = islOtherDomains.Next() ) != NULL )
            {
                err = AddDomainToList( pnls->QueryPch(),
                                       BROWSE_OTHER_DOMAINS );

                if( err != NERR_Success )
                {
                    break;
                }
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: GetLanmanDomains


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: GetTrustingDomains

    SYNOPSIS:   Retrieve the trusting domains, appending them to the
                domain list.

    EXIT:       If successful, _slDomains will be updated with
                the retrieved domains.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Jul-1992     Created.
        JonN        31-Mar-1993     Logon domain not trusted domain

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: GetTrustingDomains( VOID )
{
    //
    //  If we're not a domain member, then bag-out.
    //

    BOOL fIsDomainMember = FALSE;
    APIERR err = DetermineIfDomainMember( &fIsDomainMember );

    if( !fIsDomainMember )
    {
        return err;
    }

    //
    //  Determine the user's logon domain.
    //

    NLS_STR nlsLogonDC;

    err = nlsLogonDC.QueryError();

    if( err == NERR_Success )
    {
        err = GetLogonDomainDC( &nlsLogonDC );
    }

    // just return NERR_Success if user logged on locally
    if ( err == NERR_Success && (nlsLogonDC.strlen() > 0) )
    {
        //
        //  Let an ADMIN_AUTHORITY do all of the dirty work
        //  in connecting to the remote SAM.
        //

        ADMIN_AUTHORITY admin( nlsLogonDC );

        err = admin.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Enumerate the interdomain trust accounts.
            //

            SAM_USER_ENUM enumSam( admin.QueryAccountDomain(),
                                   USER_INTERDOMAIN_TRUST_ACCOUNT );
            NLS_STR nlsDomain;

            err = enumSam.QueryError();

            if( err == NERR_Success )
            {
                err = nlsDomain.QueryError();
            }

            if( err == NERR_Success )
            {
                err = enumSam.GetInfo();
            }

            if( err == NERR_Success )
            {
                SAM_USER_ENUM_ITER iterSam( enumSam );
                const SAM_USER_ENUM_OBJ * pobjSam;

                while( ( pobjSam = iterSam.Next( &err ) ) != NULL )
                {
                    //
                    //  Retrieve the domain name.  This will be
                    //  an interdomain trust account and will
                    //  have a trailing '$'.
                    //

                    err = pobjSam->QueryUserName( &nlsDomain );

                    if( err != NERR_Success )
                    {
                        break;
                    }

                    //
                    //  Strip the trailing '$'.
                    //

                    ISTR istr( nlsDomain );

                    while( ( nlsDomain.QueryChar( istr ) != TCH('\0') ) &&
                           ( nlsDomain.QueryChar( istr ) != TCH('$') ) )
                    {
                        ++istr;
                    }

#ifdef DEBUG
                    {
                        ISTR istrDbg( istr );
                        UIASSERT( nlsDomain.QueryChar( istrDbg ) == TCH('$') );
                        ++istrDbg;
                        UIASSERT( nlsDomain.QueryChar( istrDbg ) == TCH('\0') );
                    }
#endif  // DEBUG

                    nlsDomain.DelSubStr( istr );

                    //
                    //  Add the domain to the list.
                    //

                    err = AddDomainToList( nlsDomain,
                                           BROWSE_TRUSTING_DOMAINS );

                    if( err != NERR_Success )
                    {
                        break;
                    }
                }
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: GetTrustingDomains


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: GetWorkgroupDomains

    SYNOPSIS:   Retrieve the workgroup domains, appending them to the
                domain list.

    EXIT:       *pfEmptyList - Contains FALSE if we can't get any workgroup
                               domains, TRUE otherwise.
                If successful, _slDomains will be updated with
                the retrieved domains.

    RETURNS:    APIERR                  - Any errors encountered.

    NOTES:      I have a solemn oath from LarryO that the domain list
                returned from the browser is *always* in uppercase and
                *always* sorted.

    HISTORY:
        KeithMo     22-Jul-1992     Created.
        Yi-HsinS    12-Nov-1992     Add pfEmptyList
        KeithMo     16-Nov-1992     Removed pfEmptyList.

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: GetWorkgroupDomains( VOID )
{
    //
    //  This *MUST* be the first worker called!
    //

    UIASSERT( QueryDomainCount() == 0 );

    //
    //  Our domain enumerator.
    //

    DOMAIN0_ENUM enumDomains;

    APIERR err = enumDomains.GetInfo();

    if( err == NERR_Success )
    {
        //
        //  Sort the domain list.
        //

        enumDomains.Sort();

        //
        //  Scan through the returned list of domains, adding
        //  them to _slDomains.
        //

        DOMAIN0_ENUM_ITER iterDomains( enumDomains );
        const DOMAIN0_ENUM_OBJ * pdom;

        while( ( pdom = iterDomains() ) != NULL )
        {
            err = AddDomainToList( pdom->QueryName(),
                                   BROWSE_WORKGROUP_DOMAINS,
                                   TRUE );

            if( err != NERR_Success )
            {
                break;
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: GetWorkgroupDomains


/*******************************************************************

    NAME:       BROWSE_DOMAIN_ENUM :: GetLogonDomainDC

    SYNOPSIS:   Retrieve the name of a DC in the user's logon domain.
                Returned name is the empty string if user is logged on locally.

    ENTRY:      pnlsLogonDC             - Will receive the name of a DC
                                          in the logon domain.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     23-Jul-1992     Created.
        JonN        31-Mar-1993     Logon domain not primary

********************************************************************/
APIERR BROWSE_DOMAIN_ENUM :: GetLogonDomainDC( NLS_STR * pnlsLogonDC )
{
    //  Determine the user's logon domain.
    //

    WKSTA_10 wksta;
    APIERR err = wksta.QueryError();

    if( err == NERR_Success )
    {
        err = wksta.GetInfo();
    }

    if( err == NERR_Success )
    {
        // check if logged on locally
        TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
        DWORD cchBuffer = sizeof(szComputerName) / sizeof(TCHAR);

        if ( (err = ( ::GetComputerName( szComputerName, &cchBuffer )
                          ? NERR_Success
                          : ::GetLastError()) ) != NERR_Success
           )
        {
            DBGEOL( "BROWSE_DOMAIN_ENUM: can't get local computer name " << err );
        }
        else if ( 0 == ::stricmpf( wksta.QueryLogonDomain(), szComputerName ) )
        {
            TRACEEOL( "BROWSE_DOMAIN_ENUM: logged on locally, skip trusting domains" );
            err = pnlsLogonDC->CopyFrom( SZ("") );
        }
        else
        {
            //
            //  Determine the PDC of the logon domain.
            //

            DOMAIN domainLogon( wksta.QueryLogonDomain(), TRUE );

            err = domainLogon.GetInfo();

            if( err == NERR_Success )
            {
                err = pnlsLogonDC->CopyFrom( domainLogon.QueryPDC() );
            }
        }
    }

    return err;

}   // BROWSE_DOMAIN_ENUM :: GetLogonDomainDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoeali.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1991               **/
/*****************************************************************/

/*
 *  History:
 *      Thomaspa    21-Feb-1992    Created
 *
 */

#include "pchlmobj.hxx"

DEFINE_LM_RESUME_ENUM_ITER_OF( ALIAS, SAM_RID_ENUMERATION )

/**********************************************************\

    NAME:       ALIAS_ENUM::CallAPI

    SYNOPSIS:   Call API to do alias enumeration

    ENTRY:      ppbBuffer       - ptr to ptr to buffer to fill
                pcEntriesRead   - variable to store entry count

    EXIT:       LANMAN error code

    NOTES:

    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
APIERR ALIAS_ENUM::CallAPI( BOOL    fRestartEnum,
                        BYTE ** ppbBuffer,
                        UINT  * pcEntriesRead )
{
    if (fRestartEnum)
        _samenumh = 0;

    APIERR err;

    if ( _psamrem != NULL )
        delete _psamrem;

    _psamrem = new SAM_RID_ENUMERATION_MEM;

    if ( err = _psamrem->QueryError() )
    {
        return err;
    }


    err =  _samdomain.EnumerateAliases( _psamrem, &_samenumh, _cbMaxPreferred );

    *ppbBuffer = ( BYTE * )_psamrem->QueryPtr();
    /* BUGBUG 16bit woes */
    *pcEntriesRead = (UINT)_psamrem->QueryCount();

    return err;

} // ALIAS_ENUM::CallApi



/*******************************************************************

    NAME:           ALIAS_ENUM :: FreeBuffer

    SYNOPSIS:       Frees the API buffer.

    ENTRY:          ppbBuffer           - Points to a pointer to the
                                          enumeration buffer.

    HISTORY:
        KeithMo     31-Mar-1992 Created.

********************************************************************/
VOID ALIAS_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    *ppbBuffer = NULL;

}   // ALIAS_ENUM :: FreeBuffer


/**********************************************************\

    NAME:       ALIAS_ENUM::ALIAS_ENUM

    SYNOPSIS:   Alias enumeration constructor

    ENTRY:      samdomain -     SAM_DOMAIN reference for domain


    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
ALIAS_ENUM::ALIAS_ENUM ( SAM_DOMAIN & samdomain, UINT cbMaxPreferred )
        : LM_RESUME_ENUM( 0 ),
          _samdomain( samdomain ),
          _psamrem( NULL ),
          _cbMaxPreferred( cbMaxPreferred )
{

    if( QueryError() != NERR_Success )
    {
        return;
    }
} // ALIAS_ENUM::ALIAS_ENUM


/**********************************************************\

    NAME:       ALIAS_ENUM::~ALIAS_ENUM

    SYNOPSIS:   Alias enumeration destructor

    ENTRY:


    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
ALIAS_ENUM::~ALIAS_ENUM ( )
{
    NukeBuffers();

    if ( _psamrem != NULL )
        delete _psamrem;

} // ALIAS_ENUM::ALIAS_ENUM



/**********************************************************\

    NAME:       ALIAS_ENUM_OBJ::SetBufferPtr

    SYNOPSIS:   Saves the buffer pointer for this enumeration object.

    ENTRY:      pBuffer                 - Pointer to the new buffer.

    EXIT:       The pointer has been saved.

    NOTES:      Will eventually handle OemToAnsi conversions.

    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
VOID ALIAS_ENUM_OBJ::SetBufferPtr( const SAM_RID_ENUMERATION * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

} // ALIAS_ENUM_OBJ::SetBufferPtr




/**********************************************************\

    NAME:       ALIAS_ENUM_OBJ::GetComment

    SYNOPSIS:   Accessor to return the comment

    ENTRY:      hDomain - handle to domain of alias

    EXIT:       LANMAN error code

    NOTES:      Since the ALIAS_ENUM_OBJ doesn't store the comment,
                GetComment must call SAM to get the comment each time
                this method is called.  The caller should therefore call
                QueryError

    HISTORY:
        thomaspa         22-Feb-1992    Created

\**********************************************************/
APIERR ALIAS_ENUM_OBJ::GetComment( const SAM_DOMAIN & samdomain,
                                   NLS_STR *pnlsComment )
{
    APIERR err;

    SAM_ALIAS  samalias( samdomain, QueryRid(), ALIAS_READ_INFORMATION );

    if ( (err = samalias.QueryError()) != NERR_Success )
    {
        return err;
    }

    err = samalias.GetComment( pnlsComment );

    return err;

} // ALIAS_ENUM_OBJ::GetComment
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoedom.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1991               **/
/*****************************************************************/

/*
 *  HISTORY:
 *      KeithMo     22-Jul-1992     Created.
 *
 */

#include "pchlmobj.hxx"

//
//  DOMAIN_ENUM methods.
//

/*******************************************************************

    NAME:       DOMAIN_ENUM :: DOMAIN_ENUM

    SYNOPSIS:   DOMAIN_ENUM class constructor.

    ENTRY:      pszServer               - Target server for the API.

                level                   - Info level (should be 100).

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
DOMAIN_ENUM :: DOMAIN_ENUM( const TCHAR * pszServer,
                            UINT          level )
  : LOC_LM_ENUM( pszServer, level )
{
    UIASSERT( level == 100 );   // currently only support infolevel 100

    //
    //  Ensure we constructed OK.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // DOMAIN_ENUM :: DOMAIN_ENUM


/*******************************************************************

    NAME:       DOMAIN_ENUM :: CallAPI

    SYNOPSIS:   Invokes the enumeration API.

    ENTRY:      ppbBuffer               - Will receive a pointer to
                                          the enumeration buffer.

                pcEntriesRead           - Will receive the number of
                                          entries in the buffer.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
APIERR DOMAIN_ENUM :: CallAPI( BYTE ** ppbBuffer,
                               UINT  * pcEntriesRead )
{
    UIASSERT( QueryInfoLevel() == 100 );    // currently only support level 100

    return ::MNetServerEnum( QueryServer(),
                             QueryInfoLevel(),
                             ppbBuffer,
                             pcEntriesRead,
                             SV_TYPE_DOMAIN_ENUM,
                             NULL );

}   // APIERR DOMAIN_ENUM :: CallAPI



//
//  DOMAIN0_ENUM methods.
//

/*******************************************************************

    NAME:       DOMAIN0_ENUM :: DOMAIN0_ENUM

    SYNOPSIS:   DOMAIN0_ENUM class constructor.

    ENTRY:      pszServer               - Target server for the API.

    HISTORY:
        KeithMo     22-Jul-1992     Created.

********************************************************************/
DOMAIN0_ENUM :: DOMAIN0_ENUM( const TCHAR * pszServer )
  : DOMAIN_ENUM( pszServer, 100 )
{
    //
    //  This space intentionally left blank.
    //

}   // DOMAIN0_ENUM :: DOMAIN0_ENUM


/*******************************************************************

    NAME:       DOMAIN0_ENUM :: Sort

    SYNOPSIS:   Sort the API buffer into ascending order.

    HISTORY:
        KeithMo     10-Feb-1993     Created.

********************************************************************/
VOID DOMAIN0_ENUM :: Sort( VOID )
{
    ::qsort( (void *)QueryPtr(),
             (size_t)QueryCount(),
             sizeof(SERVER_INFO_100),
             &DOMAIN0_ENUM::CompareDomains0 );

}   // DOMAIN0_ENUM :: Sort


/*******************************************************************

    NAME:       DOMAIN0_ENUM :: CompareDomains0

    SYNOPSIS:   This static method is called by the ::qsort() standard
                library function.  This method will compare two
                SERVER_INFO_100 structures.

    ENTRY:      p1                      - The "left" object.

                p2                      - The "right" object.

    RETURNS:    int                     - -1 if p1  < p2
                                           0 if p1 == p2
                                          +1 if p1  > p2

    HISTORY:
        KeithMo     10-Feb-1993     Created.

********************************************************************/
int __cdecl DOMAIN0_ENUM :: CompareDomains0( const void * p1,
                                              const void * p2 )
{
    SERVER_INFO_100 * psvi1 = (SERVER_INFO_100 *)p1;
    SERVER_INFO_100 * psvi2 = (SERVER_INFO_100 *)p2;

    return ::strcmpf( (TCHAR *)psvi1->sv100_name, (TCHAR *)psvi2->sv100_name );

}   // DOMAIN0_ENUM :: CompareDomains0


DEFINE_LM_ENUM_ITER_OF( DOMAIN0, SERVER_INFO_100 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoeals.cxx ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1991		**/
/*****************************************************************/

/*
 *  HISTORY:
 *	RustanL     11-Jan-1991     Created
 *	RustanL     24-Jan-1991     Added level 90
 *	ChuckC	    23-Mar-1991	    Code Rev Cleanup
 *	KeithMo	    07-Oct-1991	    Win32 Conversion.
 *
 */


#ifdef LATER	// BUGBUG!  Do we really need LanServer interoperability??

#include "pchlmobj.hxx"


/*****************************	SHARE90_ENUM  *****************************/



/**********************************************************\

   NAME:       SHARE90_ENUM::SHARE90_ENUM

   SYNOPSIS:   SHARE enum level 90 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     11-Jan-1991     Created

\**********************************************************/

SHARE90_ENUM::SHARE90_ENUM( const TCHAR * pszServer )
  : SHARE_ENUM( pszServer, 90 )
{
    // do nothing else

}  // SHARE90_ENUM::SHARE90_ENUM



/**********************************************************\

   NAME:       SHARE90_ENUM::QueryItemSize

   SYNOPSIS:   query the total number of item in the share

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     11-Jan-1991     Created

\**********************************************************/

UINT SHARE90_ENUM::QueryItemSize( VOID ) const
{
    UIASSERT( QueryInfoLevel() == 90 );

    // BUGBUG!  NT Structures??

    return sizeof( struct share_info_90 ) + MAXCOMMENTSZ + 1;

}  // SHARE90_ENUM::QueryItemSize


DEFINE_LM_ENUM_ITER_OF( SHARE90, struct share_info_90 );



/*****************************	SHARE91_ENUM  *****************************/



/**********************************************************\

   NAME:       SHARE91_ENUM::SHARE91_ENUM

   SYNOPSIS:   share enum level 91 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     11-Jan-1991     Created

\**********************************************************/

SHARE91_ENUM::SHARE91_ENUM( const TCHAR * pszServer )
  : SHARE_ENUM( pszServer, 91 )
{
    // do nothing else

}  // SHARE91_ENUM::SHARE91_ENUM



/**********************************************************\

   NAME:       SHARE91_ENUM::QueryItemSize

   SYNOPSIS:   query total item size of the share

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     11-Jan-1991     Created

\**********************************************************/

UINT SHARE91_ENUM::QueryItemSize( VOID ) const
{
    UIASSERT( QueryInfoLevel() == 91 );

    // BUGBUG!  NT Structures??

    return sizeof( struct share_info_91 ) + NNLEN + 1 + MAX_PATH + 1 + NNLEN + 1;

}  // SHARE91_ENUM::QueryItemSize


DEFINE_LM_ENUM_ITER_OF( SHARE91, struct share_info_91 );


#endif	// LATER    // BUGBUG!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoechar.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    lmoechar.cxx
    This file contains the class definitions for the CHARDEVQ_ENUM and
    CHARDEVQ1_ENUM enumerator class and their associated iterator classes.

    CHARDEVQ_ENUM is a base enumeration class intended to be subclassed for
    the desired info level.  CHARDEVQ1_ENUM is an info level 1 enumerator.


    FILE HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.
	KeithMo	    07-Oct-1991	    Win32 Conversion.

*/

#include "pchlmobj.hxx"

//
//  CHARDEVQ_ENUM methods
//

/*******************************************************************

    NAME:	    CHARDEVQ_ENUM :: CHARDEVQ_ENUM

    SYNOPSIS:	    CHARDEVQ_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszUserName		- The name of a user to enumerate
		    			  character queue's for.

		    usLevel		- The information level.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
CHARDEVQ_ENUM :: CHARDEVQ_ENUM( const TCHAR * pszServerName,
				const TCHAR * pszUserName,
			  	UINT	     uLevel )
  : LOC_LM_ENUM( pszServerName, uLevel ),
    _nlsUserName( pszUserName )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

    if( !_nlsUserName )
    {
    	ReportError( _nlsUserName.QueryError() );
    }

}   // CHARDEVQ_ENUM :: CHARDEVQ_ENUM


/*******************************************************************

    NAME:	    CHARDEVQ_ENUM :: CallAPI

    SYNOPSIS:	    Invokes the NetCharDevQEnum() enumeration API.

    ENTRY:	    ppbBuffer		- Pointer to a pointer to the
					  enumeration buffer.

		    pcEntriesRead	- Will receive the number of
		    		  	  entries read from the API.

    EXIT:	    The enumeration API is invoked.

    RETURNS:	    APIERR		- Any errors encountered.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.

********************************************************************/
APIERR CHARDEVQ_ENUM :: CallAPI( BYTE ** ppbBuffer,
			 	 UINT  * pcEntriesRead )
{
    return ::MNetCharDevQEnum( QueryServer(),
			       _nlsUserName.QueryPch(),
    			       QueryInfoLevel(),
			       ppbBuffer,
			       pcEntriesRead );

}   // CHARDEVQ_ENUM :: CallAPI


//
//  CHARDEVQ1_ENUM methods
//

/*******************************************************************

    NAME:	    CHARDEVQ1_ENUM :: CHARDEVQ1_ENUM

    SYNOPSIS:	    CHARDEVQ1_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszUserName		- The name of a user to enumerate
		    			  character queue's for.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.

********************************************************************/
CHARDEVQ1_ENUM :: CHARDEVQ1_ENUM( const TCHAR * pszServerName,
				  const TCHAR * pszUserName )
  : CHARDEVQ_ENUM( pszServerName, pszUserName, 1 )
{
    //
    //	This space intentionally left blank.
    //

}   // CHARDEVQ1_ENUM :: CHARDEVQ1_ENUM


/*******************************************************************

    NAME:	CHARDEVQ1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID CHARDEVQ1_ENUM_OBJ :: SetBufferPtr( const struct chardevQ_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // CHARDEVQ1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( CHARDEVQ1, struct chardevQ_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoeconn.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    lmoeconn.cxx
    This file contains the class definitions for the CONN_ENUM,
    CONN0_ENUM, CONN1_ENUM enumerator class and their associated
    iterator classes.

    CONN_ENUM is a base enumeration class intended to be subclassed for
    the desired info level.  CONN0_ENUM is an info level 0 enumerator,
    while CONN1_ENUM is an info level 1 enumerator.


    FILE HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.
	KeithMo	    07-Oct-1991	    Win32 Conversion.

*/

#include "pchlmobj.hxx"

//
//  CONN_ENUM methods
//

/*******************************************************************

    NAME:	    CONN_ENUM :: CONN_ENUM

    SYNOPSIS:	    CONN_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszQualifier	- Determines the scope of the
		    		  	  enumeration.  May be either a
				  	  share name or a computer name.

		    usLevel		- The information level.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
CONN_ENUM :: CONN_ENUM( const TCHAR * pszServerName,
			const TCHAR * pszQualifier,
			UINT	     uLevel )
  : LOC_LM_ENUM( pszServerName, uLevel ),
    _nlsQualifier( pszQualifier )
{
    if( !_nlsQualifier )
    {
    	ReportError( _nlsQualifier.QueryError() );
    }

}   // CONN_ENUM :: CONN_ENUM


/*******************************************************************

    NAME:	    CONN_ENUM :: CallAPI

    SYNOPSIS:	    Invokes the NetConnectionEnum() enumeration API.

    ENTRY:	    ppbBuffer		- Pointer to a pointer to the
					  enumeration buffer.

		    pcEntriesRead	- Will receive the number of
		    		  	  entries read from the API.

    EXIT:	    The enumeration API is invoked.

    RETURNS:	    APIERR		- Any errors encountered.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.

********************************************************************/
APIERR CONN_ENUM :: CallAPI( BYTE ** ppbBuffer,
			     UINT  * pcEntriesRead )
{
    return ::MNetConnectionEnum( QueryServer(),
			         _nlsQualifier.QueryPch(),
    			         QueryInfoLevel(),
			         ppbBuffer,
			         pcEntriesRead );

}   // CONN_ENUM :: CallAPI


//
//  CONN0_ENUM methods
//

/*******************************************************************

    NAME:	    CONN0_ENUM :: CONN0_ENUM

    SYNOPSIS:	    CONN0_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszQualifier	- Determines the scope of the
		    		  	  enumeration.  May be either a
				  	  share name or a computer name.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
CONN0_ENUM :: CONN0_ENUM( const TCHAR * pszServerName,
			  const TCHAR * pszQualifier )
  : CONN_ENUM( pszServerName, pszQualifier, 0 )
{
    //
    //	This space intentionally left blank.
    //

}   // CONN0_ENUM :: CONN0_ENUM


/*******************************************************************

    NAME:	CONN0_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID CONN0_ENUM_OBJ :: SetBufferPtr( const struct connection_info_0 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // CONN0_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( CONN0, struct connection_info_0 );


//
//  CONN1_ENUM methods
//

/*******************************************************************

    NAME:	    CONN1_ENUM :: CONN1_ENUM

    SYNOPSIS:	    CONN1_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    pszQualifier	- Determines the scope of the
		    		  	  enumeration.  May be either a
				  	  share name or a computer name.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
CONN1_ENUM :: CONN1_ENUM( const TCHAR * pszServerName,
			  const TCHAR * pszQualifier )
  : CONN_ENUM( pszServerName, pszQualifier, 1 )
{
    //
    //	This space intentionally left blank.
    //

}   // CONN1_ENUM :: CONN1_ENUM


/*******************************************************************

    NAME:	CONN1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID CONN1_ENUM_OBJ :: SetBufferPtr( const struct connection_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // CONN1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( CONN1, struct connection_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoenum.cxx ===
/*****************************************************************/
/**                  Microsoft LAN Manager                      **/
/**            Copyright(c) Microsoft Corp., 1991               **/
/*****************************************************************/

/*
 *  HISTORY:
 *      RustanL     03-Jan-1991     Wrote initial implementation in shell\util
 *      RustanL     10-Jan-1991     Added iterators, simplified usage and
 *                                  the adding of subclasses.  Moved into
 *                                  LMOBJ.
 *      beng        11-Feb-1991     Uses lmui.hxx
 *      Chuckc      23-Mar-1991     code rev cleanup
 *      gregj       23-May-1991     Added LOCATION support.
 *      rustanl     18-Jul-1991     Added ( const LOCATION & ) constructor
 *      rustanl     19-Jul-1991     Inherit from BASE; Removed ValidateName
 *      rustanl     20-Aug-1991     Changed QuerySize to QueryCount
 *      rustanl     21-Aug-1991     Introduced the ENUM_CALLER class
 *      KeithMo     07-Oct-1991     Win32 Conversion.
 *      Thomaspa    21-Feb-1992     Split LOC_LM_ENUM from LM_ENUM
 *
 */

#include "pchlmobj.hxx"

/******************************** ENUM_CALLER ****************************/


/*******************************************************************

    NAME:       ENUM_CALLER::ENUM_CALLER

    SYNOPSIS:   ENUM_CALLER constructor

    NOTES:      Since this class can't inherit from BASE (since some
                of its subclasses already necessarily do from elsewhere),
                this constructor must guarantee to succeed.

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

ENUM_CALLER::ENUM_CALLER()
  : _cEntriesRead( 0 )
{
    // nothing else to do

}  // ENUM_CALLER::ENUM_CALLER


/*******************************************************************

    NAME:       ENUM_CALLER::W_GetInfo

    SYNOPSIS:   Call the Enum API

    RETURN:     An error code, which is NERR_Success on success.

    HISTORY:
        rustanl     21-Aug-1991     Created from LM_ENUM::GetInfo, which
                                    now calls this method as a worker
                                    function.

********************************************************************/

APIERR ENUM_CALLER::W_GetInfo()
{
    BYTE * pBuffer = NULL;
    APIERR err = CallAPI( &pBuffer,
                          &_cEntriesRead );

    if( pBuffer != NULL )
    {
        EC_SetBufferPtr( pBuffer );
    }

    return err;

}  // ENUM_CALLER::W_GetInfo


/********************************** LM_ENUM ******************************/


/**********************************************************\

   NAME:       LM_ENUM::LM_ENUM

   SYNOPSIS:   lm_enum constructor

   ENTRY:
      pszServer Pointer to server name.  May be NULL.
      uLevel    Information level

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util
      gregj       23-May-1991     Added LOCATION support
      rustanl     18-Jul-1991     Added ( const LOCATION & ) constructor
      rustanl     19-Jul-1991     Added BASE support
      thomaspa    21-Feb-1992     Moved LOCATION to LOC_LM_ENUM

\**********************************************************/

LM_ENUM::LM_ENUM( UINT uLevel )
  : _pBuffer( NULL ),
    _uLevel( uLevel ),
    _cIterRef( 0 )
{
    if ( QueryError() != NERR_Success )
        return;

}  // LM_ENUM::LM_ENUM


/**********************************************************\

   NAME:       LM_ENUM::~LM_ENUM

   SYNOPSIS:   destructor of lm_enum

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

LM_ENUM::~LM_ENUM()
{
    UIASSERT( _cIterRef == 0 );

    ::MNetApiBufferFree( &_pBuffer );

}  // LM_ENUM::~LM_ENUM


/*******************************************************************

    NAME:       LM_ENUM::EC_QueryBufferPtr

    SYNOPSIS:   Returns the pointer to the buffer used in the API
                calls

    RETURNS:    Pointer to said buffer area

    HISTORY:
        rustanl     21-Aug-1991     Created

********************************************************************/

BYTE * LM_ENUM::EC_QueryBufferPtr() const
{
    return _pBuffer;

}  // LM_ENUM::EC_QueryBufferPtr


/*******************************************************************

    NAME:       LM_ENUM::EC_SetBufferPtr

    SYNOPSIS:   Sets the current buffer pointer.

    RETURNS:    APIERR (in this implementation, always NERR_Success).

    HISTORY:
        KeithMo     15-Oct-1991     Created

********************************************************************/

APIERR LM_ENUM::EC_SetBufferPtr( BYTE * pBuffer )
{
    ::MNetApiBufferFree( &_pBuffer );
    _pBuffer = pBuffer;

    return NERR_Success;

}  // LM_ENUM::EC_SetBufferPtr



/*********************************************************************

    NAME:       LM_ENUM::GetInfo

    SYNOPSIS:   Call the Enum API.

    ENTRY:      NONE

    RETURN:     An error code, which is NERR_Success on success.

    NOTES:      This method is guaranteed to call QueryError, and return
                any error.

    HISTORY:
        RustanL     03-Jan-1991     Initial implementation in shell\util
        rustanl     14-Jun-1991     Added LOCATION::GetInfo from
                                    LM_ENUM::QueryServer
        beng        15-Jul-1991     BUFFER::Resize changed return type
        rustanl     20-Aug-1991     Fixed cast error
        rustanl     21-Aug-1991     Moved meat to ENUM_CALLER::W_GetInfo

**********************************************************************/

APIERR LM_ENUM::GetInfo( VOID )
{
    UIASSERT( _cIterRef == 0 );

    APIERR err = QueryError();
    if ( err != NERR_Success)
        return err;

    return W_GetInfo();

}  // LM_ENUM::GetInfo


/**********************************************************\

   NAME:       LM_ENUM::_RegisterIter

   SYNOPSIS:   registerIter

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

VOID LM_ENUM::_RegisterIter( VOID )
{
#if defined(DEBUG)

    _cIterRef++;

#endif // DEBUG
}  // LM_ENUM::RegisterIter


/**********************************************************\

   NAME:       LM_ENUM::_DeregisterIter

   SYNOPSIS:   deisgter iter

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

VOID LM_ENUM::_DeregisterIter( VOID )
{
#if defined(DEBUG)

    if ( _cIterRef == 0 )
    {
        UIASSERT( !SZ("Negative reference count") );
    }
    else
    {
        _cIterRef--;
    }

#endif // DEBUG
}  // LM_ENUM::DeregisterIter


/******************************* LOC_LM_ENUM *****************************/

/**********************************************************\

   NAME:       LOC_LM_ENUM::LOC_LM_ENUM

   SYNOPSIS:   lm_enum constructor

   ENTRY:
      pszServer Pointer to server name.  May be NULL.
      uLevel    Information level

   EXIT:

   NOTES:

   HISTORY:
        Thomaspa        21-Feb-1992     Split from LM_ENUM

\**********************************************************/

LOC_LM_ENUM::LOC_LM_ENUM( const TCHAR * pszServer, UINT uLevel )
  : LM_ENUM( uLevel ),
    _loc( pszServer )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOC_LM_ENUM::LOC_LM_ENUM


LOC_LM_ENUM::LOC_LM_ENUM( LOCATION_TYPE locType, UINT uLevel )
  : LM_ENUM( uLevel ),
    _loc( locType )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOC_LM_ENUM::LOC_LM_ENUM


LOC_LM_ENUM::LOC_LM_ENUM( const LOCATION & loc, UINT uLevel )
  : LM_ENUM( uLevel ),
    _loc( loc )
{
    if ( QueryError() != NERR_Success )
        return;

    APIERR err = _loc.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // LOC_LM_ENUM::LOC_LM_ENUM

/**********************************************************\

   NAME:       LOC_LM_ENUM::~LOC_LM_ENUM

   SYNOPSIS:   destructor of loc_lm_enum

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      Thomaspa     22-Feb-1992     created

\**********************************************************/

LOC_LM_ENUM::~LOC_LM_ENUM()
{
        // do nothing
}


/**********************************************************\

   NAME:       LOC_LM_ENUM::QueryServer

   SYNOPSIS:   query server

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util
      gregj       23-May-1991     Added LOCATION support
      rustanl     14-Jun-1991     Moved LOCATION::GetInfo call to
                                  LM_ENUM::GetInfo
      Thomaspa    21-Feb-1992     Split from LM_ENUM

\**********************************************************/

const TCHAR * LOC_LM_ENUM::QueryServer( VOID ) const
{
    return _loc.QueryServer();

}  // LOC_LM_ENUM::QueryServer



/******************************* LM_ENUM_ITER *****************************/


/**********************************************************\

   NAME:       LM_ENUM_ITER::LM_ENUM_ITER

   SYNOPSIS:   constructor for the lm_enum_iter

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

LM_ENUM_ITER::LM_ENUM_ITER( LM_ENUM & lmenum )
{
    _cItems = lmenum.QueryCount();
    _plmenum = &lmenum;

    _plmenum->RegisterIter();

}  // LM_ENUM_ITER::LM_ENUM_ITER


/**********************************************************\

   NAME:       LM_ENUM_ITER::~LM_ENUM_ITER

   SYNOPSIS:   destructor for the LM_ENUM_ITER

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
      RustanL     03-Jan-1991     Wrote initial implementation in shell\util

\**********************************************************/

LM_ENUM_ITER::~LM_ENUM_ITER()
{
    _plmenum->DeregisterIter();
    _plmenum = NULL ;

}  // LM_ENUM_ITER::~LM_ENUM_ITER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoeprt.cxx ===
#if 0   // unsupported in NT product 1


/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoeprt.cxx
    This file contains the class definitions for the PRINTQ_ENUM and
    PRINTQ1_ENUM enumerator class and their associated iterator classes.

    PRINTQ_ENUM is a base enumeration class intended to be subclassed for
    the desired info level.  PRINTQ1_ENUM is an info level 1 enumerator.


    FILE HISTORY:
        KeithMo     28-Jul-1991     Created.
        KeithMo     12-Aug-1991     Code review cleanup.
        KeithMo     07-Oct-1991     Win32 Conversion.

*/

#include "pchlmobj.hxx"

//
//  PRINTQ_ENUM methods
//

/*******************************************************************

    NAME:           PRINTQ_ENUM :: PRINTQ_ENUM

    SYNOPSIS:       PRINTQ_ENUM class constructor.

    ENTRY:          pszServerName       - The name of the server to execute
                                          the enumeration on.  NULL =
                                          execute locally.

                    usLevel             - The information level.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     28-Jul-1991     Created.

********************************************************************/
PRINTQ_ENUM :: PRINTQ_ENUM( const TCHAR * pszServerName,
                            UINT         uLevel )
  : LOC_LM_ENUM( pszServerName, uLevel )
{
    //
    //  This space intentionally left blank.
    //

}   // PRINTQ_ENUM :: PRINTQ_ENUM


/*******************************************************************

    NAME:           PRINTQ_ENUM :: CallAPI

    SYNOPSIS:       Invokes the DosPrintQEnum() enumeration API.

    ENTRY:          ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API is invoked.

    RETURNS:        APIERR              - Any errors encountered.

    NOTES:

    HISTORY:
        KeithMo     28-Jul-1991     Created.
        KeithMo     12-Aug-1991     Code review cleanup.

********************************************************************/
APIERR PRINTQ_ENUM :: CallAPI( BYTE ** ppbBuffer,
                               UINT  * pcEntriesRead )
{
    return ::MDosPrintQEnum( QueryServer(),
                             QueryInfoLevel(),
                             ppbBuffer,
                             pcEntriesRead );

}   // PRINTQ_ENUM :: CallAPI


//
//  PRINTQ1_ENUM methods
//

/*******************************************************************

    NAME:           PRINTQ1_ENUM :: PRINTQ1_ENUM

    SYNOPSIS:       PRINTQ1_ENUM class constructor.

    ENTRY:          pszServerName       - The name of the server to execute
                                          the enumeration on.  NULL =
                                          execute locally.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     28-Jul-1991     Created.

********************************************************************/
PRINTQ1_ENUM :: PRINTQ1_ENUM( const TCHAR * pszServerName )
  : PRINTQ_ENUM( pszServerName, 1 )
{
    //
    //  This space intentionally left blank.
    //

}   // PRINTQ1_ENUM :: PRINTQ1_ENUM


/*******************************************************************

    NAME:       PRINTQ1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:   Saves the buffer pointer for this enumeration object.

    ENTRY:      pBuffer                 - Pointer to the new buffer.

    EXIT:       The pointer has been saved.

    NOTES:      Will eventually handle OemToAnsi conversions.

    HISTORY:
        KeithMo     09-Oct-1991     Created.

********************************************************************/
VOID PRINTQ1_ENUM_OBJ :: SetBufferPtr( const struct prq_info * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // PRINTQ1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( PRINTQ1, struct prq_info );


#endif  // 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoent.cxx ===
/*****************************************************************/
/**                  Microsoft Windows NT                       **/
/**            Copyright(c) Microsoft Corp., 1992               **/
/*****************************************************************/

/*
 *  HISTORY:
 *      JonN    13-Mar-1992     Split from lmoeusr.cxx
 *      keithmo 16-mar-1992     Added UNICODE -> ASCII conversion hack.
 *      JonN    01-Apr-1992     NT enumerator CR changes, attended by
 *                              JimH, JohnL, KeithMo, JonN, ThomasPa
 *	JonN    27-Jan-1994	Added group enumerator
 *
 */

#include "pchlmobj.hxx"

//
//  These defines are used in the default QueryCountPreferences().
//  The manifest TOTAL_BYTES_REQUESTED gives the number of BYTEs we request
//  from the server on each call to the account enumeration API.  The
//  manifest TOTAL_ENTRIES_REQUESTED gives the number of entries we request
//  from the server on each call to the account enumeration API.
//

#define TOTAL_BYTES_REQUESTED   0x0001FFFF
#define TOTAL_ENTRIES_REQUESTED 1000


//
// The following defines are used in the slow mode timing heuristics in
// QueryCountPreferences2.  A timer determines how long it takes
// to read in each batch of accounts.  If this time is less
// that READ_MORE_MSEC, we double the number of bytes requested on the
// next call.  If it is more than READ_LESS_MSEC, we halve it.
//
// We only manipulate the BytesRequested, and we leave CountRequested
// at a fixed (large) value.
//

#define PREF_INITIAL_BYTES  0x07FFF /*  64K */
#define PREF_MIN_BYTES      0x003FF /*   2K */
#define PREF_MAX_BYTES      0x7FFFF /* 512K */

#define PREF_COUNT          2000

#define PREF_READ_MORE_MSEC 3000
#define PREF_READ_LESS_MSEC 8000



#ifndef UNICODE // HACK

//
//  This is a simple hack to map a UNICODE string to an
//  ASCII string _in_place_.  Note that after this function
//  completes, punicode will no longer be a "real" UNICODE_STRING.
//  Its Buffer field will point to a NULL terminated string of
//  chars (*not* TCHARs or WCHARs) and its Length field will be
//  adjusted accordingly.
//
//  Note that this function is only necessary for non UNICODE builds.
//

VOID MapUnicodeToAsciiPoorly( PUNICODE_STRING punicode )
{
    char   * psz = (char *)punicode->Buffer;
    WCHAR  * pwc = punicode->Buffer;
    USHORT   cb  = punicode->Length / sizeof(WCHAR);

    punicode->Length = cb;

    if( cb == 0 )
    {
        return;
    }

    while( ( cb-- > 0 ) && ( *pwc != L'\0' ) )  // No TCH(), ALWAYS UNICODE!
    {
        *psz++ = (char)*pwc++;
    }

    *psz = '\0';                                // No TCH(), ALWAYS ASCII!

}   // MapUnicodeToAsciiPoorly

#endif  // UNICODE hack



/****************************   NT_ACCOUNT_ENUM  **************************/


/*******************************************************************

    NAME:       NT_ACCOUNT_ENUM::NT_ACCOUNT_ENUM

    SYNOPSIS:   Account enumeration constructor.  These accounts may
                be either user accounts (NT_USER_ENUM) or machine
                accounts (NT_MACHINE_ENUM).

    ENTRY:      psamdomain              - A SAM_DOMAIN representing the
                                          target domain.

                dinfo                   - Either DomainDisplayUser,
                                          DomainDisplayMachine or DomainDisplayGroup.

                fKeepBuffers            - If TRUE then LM_RESUME_ENUM
                                          will keep a list of all buffers
                                          created by CallAPI.

    HISTORY:
        jonn    30-Jan-1992     Templated from USER_ENUM

********************************************************************/
NT_ACCOUNT_ENUM::NT_ACCOUNT_ENUM( const SAM_DOMAIN * psamdomain,
                                  enum _DOMAIN_DISPLAY_INFORMATION dinfo,
                                  BOOL fKeepBuffers  )
  : LM_RESUME_ENUM( (UINT)dinfo, fKeepBuffers ),
    _psamdomain( psamdomain ),
    _ulIndex( 0 ),
    _nCalls( 0 ),
    _msTimeLastCall( 0 ),
    _cEntriesRequested( TOTAL_ENTRIES_REQUESTED ),
    _cbBytesRequested( TOTAL_BYTES_REQUESTED )
{
    ASSERT( (psamdomain != NULL) && (psamdomain->QueryError() == NERR_Success) );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}  // NT_ACCOUNT_ENUM::NT_ACCOUNT_ENUM


/*******************************************************************

    NAME:           NT_ACCOUNT_ENUM :: ~NT_ACCOUNT_ENUM

    SYNOPSIS:       Account (user or machine) enumeration destructor.

    HISTORY:
        JonN        29-Mar-1992 Created
        KeithMo     10-Sep-1992 Added NukeBuffers().

********************************************************************/
NT_ACCOUNT_ENUM :: ~NT_ACCOUNT_ENUM()
{
    NukeBuffers();

    _psamdomain = NULL;
    _ulIndex = 0;
    _nCalls = 0;
    _msTimeLastCall = 0;
    _cEntriesRequested = 0;
    _cbBytesRequested = 0;

}   // NT_ACCOUNT_ENUM :: ~NT_ACCOUNT_ENUM()


/*******************************************************************

    NAME:           NT_ACCOUNT_ENUM :: FreeBuffer

    SYNOPSIS:       Frees the buffer _pBuffer.

    RETURNS:        No return value.

    NOTE:           Some code relies on the pointer being reset to NULL.

    HISTORY:
        JonN        31-Jan-1992 Created
        JonN        03-Jun-1996 Must reset pointer to 0

********************************************************************/

VOID NT_ACCOUNT_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{

    UNREFERENCED( this );

    REQUIRE( ::SamFreeMemory( *ppbBuffer ) == STATUS_SUCCESS );

    *ppbBuffer = NULL;


}   // NT_ACCOUNT_ENUM :: FreeBuffer


/*******************************************************************

    NAME:       NT_ACCOUNT_ENUM::CallAPI

    SYNOPSIS:   Call API to do account enumeration

    ENTRY:      fRestartEnum            - If TRUE, then the enumeration
                                          handle should be reset to its
                                          starting position before invoking
                                          the API.

                ppbBuffer               - ptr to ptr to buffer returned

                pcEntriesRead           - variable to store entry count

    EXIT:       LANMAN error code

    HISTORY:
        jonn    30-Jan-1992     Templated from USER_ENUM

********************************************************************/
APIERR NT_ACCOUNT_ENUM :: CallAPI( BOOL    fRestartEnum,
                                   BYTE ** ppbBuffer,
                                   UINT  * pcEntriesRead )
{
    ASSERT( (ppbBuffer != NULL) && (pcEntriesRead != NULL) );

    ULONG ulTotalAvailable;
    ULONG cbTotalReturned;

    if( fRestartEnum )
    {
        _ulIndex = 0;
    }

    APIERR err = QueryCountPreferences( &_cEntriesRequested,
                                        &_cbBytesRequested,
                                        _nCalls++,
                                        _cEntriesRequested,
                                        _cbBytesRequested,
                                        _msTimeLastCall );
    if (err != NERR_Success)
        return err;

    DWORD start = ::GetTickCount();
    NTSTATUS ntstatus = ::SamQueryDisplayInformation(
                                _psamdomain->QueryHandle(),
                                (_DOMAIN_DISPLAY_INFORMATION)QueryInfoLevel(),
                                _ulIndex,
                                _cEntriesRequested,
                                _cbBytesRequested,
                                &ulTotalAvailable,
                                &cbTotalReturned,
                                (PULONG)pcEntriesRead,
                                (PVOID *)ppbBuffer );
    DWORD finish = ::GetTickCount();
    _msTimeLastCall = finish - start;

    err = ERRMAP::MapNTStatus( ntstatus );

    if( ( err == NERR_Success ) || ( err == ERROR_MORE_DATA ) )
    {
        TRACEEOL( "NT_ACCOUNT_ENUM: " << _cEntriesRequested
                 << " (" << *pcEntriesRead
                 << ") entries and " << _cbBytesRequested
                 << " (" << cbTotalReturned
                 << ") bytes took " << _msTimeLastCall
                 << " msec" );

        //
        //  If the call was successful, we must update
        //  our API index so we can get the next batch
        //  of data.
        //

        // 379697: Incorrect usage of SamQueryDisplayInformation() in User Browser and net\ui\common\src
        // JonN 8/5/99

        // set starting index for next iteration to index of last returned entry
        // _ulIndex += *pcEntriesRead;
        if (0 >= *pcEntriesRead)
        {
            ASSERT( err == NERR_Success ); // infinite loop?
        }
        else
        {
            switch ( (_DOMAIN_DISPLAY_INFORMATION)QueryInfoLevel() )
            {
            case DomainDisplayUser:
                _ulIndex = ((DOMAIN_DISPLAY_USER*)(*ppbBuffer))[(*pcEntriesRead)-1].Index;
                break;
            case DomainDisplayMachine:
                _ulIndex = ((DOMAIN_DISPLAY_MACHINE*)(*ppbBuffer))[(*pcEntriesRead)-1].Index;
                break;
            case DomainDisplayGroup:
                _ulIndex = ((DOMAIN_DISPLAY_GROUP*)(*ppbBuffer))[(*pcEntriesRead)-1].Index;
                break;
            default:
                ASSERT(FALSE);
                err = E_FAIL;
            }
        }

#ifndef UNICODE

        //
        //  We must also map the UNICODE strings to ASCII if
        //  this is NOT a UNICODE build.
        //

        FixupUnicodeStrings( *ppbBuffer, *pcEntriesRead );

#endif  // UNICODE
    } // if( ( err == NERR_Success ) || ( err == ERROR_MORE_DATA ) )

    ASSERT( err != NERR_BufTooSmall );
    ASSERT(   (*ppbBuffer != NULL)                      \
           == (   ( err == NERR_Success )               \
               || ( err == ERROR_MORE_DATA )            \
               || ( err == NERR_BufTooSmall ) ) );

    return err;

}  // NT_ACCOUNT_ENUM::CallAPI


/*******************************************************************

    NAME:       NT_ACCOUNT_ENUM::QueryCountPreferences

    SYNOPSIS:   Determines how many entries/bytes to request

    EXIT:       LANMAN error code

    HISTORY:
        jonn    23-Mar-1993     Created

********************************************************************/

APIERR NT_ACCOUNT_ENUM::QueryCountPreferences(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall )       // how many milliseconds last call took
{
    UNREFERENCED( nNthCall );
    UNREFERENCED( cLastEntriesRequested );
    UNREFERENCED( cbLastBytesRequested );
    UNREFERENCED( msTimeLastCall );

    *pcEntriesRequested = TOTAL_ENTRIES_REQUESTED;
    *pcbBytesRequested  = TOTAL_BYTES_REQUESTED;

    return NERR_Success;
}


APIERR NT_ACCOUNT_ENUM::QueryCountPreferences2(
        ULONG * pcEntriesRequested,  // how many entries to request on this call
        ULONG * pcbBytesRequested,   // how many bytes to request on this call
        UINT nNthCall,               // 0 just before 1st call, 1 before 2nd call, etc.
        ULONG cLastEntriesRequested, // how many entries requested on last call
                                     //    ignore for nNthCall==0
        ULONG cbLastBytesRequested,  // how many bytes requested on last call
                                     //    ignore for nNthCall==0
        ULONG msTimeLastCall )       // how many milliseconds last call took
{
    ASSERT( pcEntriesRequested != NULL && pcbBytesRequested != NULL );

    *pcEntriesRequested = PREF_COUNT;

    if (nNthCall == 0)
    {
        *pcbBytesRequested = PREF_INITIAL_BYTES;
    }
    else if ( msTimeLastCall < PREF_READ_MORE_MSEC )
    {
        *pcbBytesRequested = cbLastBytesRequested * 2;
    }
    else if ( msTimeLastCall > PREF_READ_LESS_MSEC )
    {
        *pcbBytesRequested = cbLastBytesRequested / 2;
    }
    else
    {
        *pcbBytesRequested = cbLastBytesRequested;
    }

    if ( *pcbBytesRequested < PREF_MIN_BYTES )
    {
        *pcbBytesRequested = PREF_MIN_BYTES;
    }
    else if ( *pcbBytesRequested > PREF_MAX_BYTES )
    {
        *pcbBytesRequested = PREF_MAX_BYTES;
    }

    return NERR_Success;
}


/*****************************  NT_USER_ENUM  ******************************/


/*******************************************************************

    NAME:       NT_USER_ENUM::NT_USER_ENUM

    SYNOPSIS:   Constructor for NT user enumeration

    ENTRY:      psamHandle -    domain or server to execute on

    HISTORY:
        jonn    30-Jan-1992     Templated from USER_ENUM
        jonn    13-Mar-1992     Changed parameters

********************************************************************/
NT_USER_ENUM::NT_USER_ENUM( const SAM_DOMAIN * psamdomain )
  : NT_ACCOUNT_ENUM( psamdomain, DomainDisplayUser )
{
    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}  // NT_USER_ENUM::NT_USER_ENUM


/**********************************************************\

    NAME:       NT_USER_ENUM::~NT_USER_ENUM

    SYNOPSIS:   User enumeration destructor

    HISTORY:
        jonn    29-Mar-1992     Created

\**********************************************************/

NT_USER_ENUM::~NT_USER_ENUM()
{

    //
    //  This space intentionally left blank.
    //

}  // NT_USER_ENUM::~NT_USER_ENUM


#ifndef UNICODE

/*******************************************************************

    NAME:       NT_USER_ENUM :: FixupUnicodeStrings

    SYNOPSIS:   Map all UNICODE strings to ASCII _in_place_.

    ENTRY:      pbBuffer                - Points to the enumeration buffer
                                          returned by CallAPI.

                cEntries                - The number of entries in the
                                          enumeration buffer.

    HISTORY:
        KeithMo 30-Mar-1992     Created.

********************************************************************/
VOID NT_USER_ENUM :: FixupUnicodeStrings( BYTE * pbBuffer,
                                          UINT   cEntries )
{
    return;

}  // NT_USER_ENUM :: FixupUnicodeStrings

#endif  // UNICODE


DEFINE_LM_RESUME_ENUM_ITER_OF( NT_USER, DOMAIN_DISPLAY_USER );



//
//  NT_MACHINE_ENUM methods.
//

/*******************************************************************

    NAME:       NT_MACHINE_ENUM :: NT_MACHINE_ENUM

    SYNOPSIS:   Constructor for NT machine enumeration

    ENTRY:      psamHandle -    domain or server to execute on

    HISTORY:
        KeithMo 16-Mar-1992     Created for the Server Manager.

********************************************************************/
NT_MACHINE_ENUM :: NT_MACHINE_ENUM( const SAM_DOMAIN * psamdomain )
  : NT_ACCOUNT_ENUM( psamdomain, DomainDisplayMachine, TRUE )
{

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}  // NT_MACHINE_ENUM :: NT_MACHINE_ENUM


/**********************************************************\

    NAME:       NT_MACHINE_ENUM::~NT_MACHINE_ENUM

    SYNOPSIS:   Machine enumeration destructor

    HISTORY:
        jonn    29-Mar-1992     Created

\**********************************************************/

NT_MACHINE_ENUM::~NT_MACHINE_ENUM()
{

    //
    //  This space intentionally left blank.
    //

}  // NT_MACHINE_ENUM::~NT_MACHINE_ENUM


#ifndef UNICODE

/*******************************************************************

    NAME:       NT_MACHINE_ENUM :: FixupUnicodeStrings

    SYNOPSIS:   Map all UNICODE strings to ASCII _in_place_.

    ENTRY:      pbBuffer                - Points to the enumeration buffer
                                          returned by CallAPI.

                cEntries                - The number of entries in the
                                          enumeration buffer.

    HISTORY:
        KeithMo 30-Mar-1992     Created.

********************************************************************/
VOID NT_MACHINE_ENUM :: FixupUnicodeStrings( BYTE * pbBuffer,
                                             UINT   cEntries )
{
    //
    //  Scan the returned structure, mapping the UNICODE strings
    //  to ASCII.
    //

    DOMAIN_DISPLAY_MACHINE * pMach = (DOMAIN_DISPLAY_MACHINE *)pbBuffer;

    while( cEntries-- )
    {
        MapUnicodeToAsciiPoorly( &(pMach->Machine) );
        MapUnicodeToAsciiPoorly( &(pMach->Comment) );

        pMach++;
    }

}  // NT_MACHINE_ENUM :: FixupUnicodeStrings

#endif  // UNICODE


DEFINE_LM_RESUME_ENUM_ITER_OF( NT_MACHINE, DOMAIN_DISPLAY_MACHINE );



//
//  NT_GROUP_ENUM methods.
//

/*******************************************************************

    NAME:       NT_GROUP_ENUM :: NT_GROUP_ENUM

    SYNOPSIS:   Constructor for NT group enumeration

    ENTRY:      psamHandle -    domain or server to execute on

    HISTORY:
        JonN        27-Jan-1994 Templated from NT_MACHINE_ENUM

********************************************************************/
NT_GROUP_ENUM :: NT_GROUP_ENUM( const SAM_DOMAIN * psamdomain )
  : NT_ACCOUNT_ENUM( psamdomain, DomainDisplayGroup, TRUE )
{

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}  // NT_GROUP_ENUM :: NT_GROUP_ENUM


/**********************************************************\

    NAME:       NT_GROUP_ENUM::~NT_GROUP_ENUM

    SYNOPSIS:   Group enumeration destructor

    HISTORY:
        JonN        27-Jan-1994 Templated from NT_MACHINE_ENUM

\**********************************************************/

NT_GROUP_ENUM::~NT_GROUP_ENUM()
{

    //
    //  This space intentionally left blank.
    //

}  // NT_GROUP_ENUM::~NT_GROUP_ENUM


#ifndef UNICODE

/*******************************************************************

    NAME:       NT_GROUP_ENUM :: FixupUnicodeStrings

    SYNOPSIS:   Map all UNICODE strings to ASCII _in_place_.

    ENTRY:      pbBuffer                - Points to the enumeration buffer
                                          returned by CallAPI.

                cEntries                - The number of entries in the
                                          enumeration buffer.

    HISTORY:
        JonN        27-Jan-1994 Templated from NT_MACHINE_ENUM

********************************************************************/
VOID NT_GROUP_ENUM :: FixupUnicodeStrings( BYTE * pbBuffer,
                                           UINT   cEntries )
{
    //
    //  Scan the returned structure, mapping the UNICODE strings
    //  to ASCII.
    //

    DOMAIN_DISPLAY_GROUP * pGrp = (DOMAIN_DISPLAY_GROUP *)pbBuffer;

    while( cEntries-- )
    {
        MapUnicodeToAsciiPoorly( &(pGrp->Group) );
        MapUnicodeToAsciiPoorly( &(pGrp->Comment) );

        pGrp++;
    }

}  // NT_GROUP_ENUM :: FixupUnicodeStrings

#endif  // UNICODE


DEFINE_LM_RESUME_ENUM_ITER_OF( NT_GROUP, DOMAIN_DISPLAY_GROUP );

// End of LMOENT.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoefile.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoefile.cxx
    This file contains the class definitions for the FILE3_ENUM and
    FILE3_ENUM_ITER classes.

    FILE3_ENUM is an enumeration class used to enumerate the open
    resources on a particular server.  FILE3_ENUM_ITER is an iterator
    used to iterate the open resources from the FILE3_ENUM class.


    FILE HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Code review revisions (code review
                                attended by ChuckC, Hui-LiCh, JimH,
                                JonN, KevinL).
        KeithMo     07-Oct-1991 Win32 Conversion.
        JonN        30-Jan-1992 Split LOC_LM_RESUME_ENUM from LM_RESUME_ENUM

*/

#include "pchlmobj.hxx"

//
//  These are the buffer sizes used when growing the enumeration
//  buffer.  The buffer is initially SMALL_BUFFER_SIZE bytes long.
//  If this is insufficient for the enumeration, the buffer is
//  grown to LARGE_BUFFER_SIZE.
//

#define SMALL_BUFFER_SIZE       (  4 * 1024 )
#define LARGE_BUFFER_SIZE       ( 16 * 1024 )


/*******************************************************************

    NAME:           FILE_ENUM :: FILE_ENUM

    SYNOPSIS:       FILE_ENUM class constructor.

    ENTRY:          pszServerName   - The name of the server to execute
                                      the enumeration on.  NULL =
                                      execute locally.

                    pszBasePath     - The root directory for the
                                      enumeration.  NULL = enumerate all
                                      open files.

                    pszUserName     - The name of the user to enumerate
                                      the files for.  NULL = enumerate
                                      for all users.

                    usLevel         - The information level.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
FILE_ENUM :: FILE_ENUM( const TCHAR * pszServerName,
                        const TCHAR * pszBasePath,
                        const TCHAR * pszUserName,
                        UINT         uLevel )
  : LOC_LM_RESUME_ENUM( pszServerName, uLevel ),
    _nlsBasePath( pszBasePath ),
    _nlsUserName( pszUserName ),
    _fBigBuffer( FALSE )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsBasePath )
    {
        ReportError( _nlsBasePath.QueryError() );
        return;
    }

    if( !_nlsUserName )
    {
        ReportError( _nlsUserName.QueryError() );
        return;
    }

}   // FILE_ENUM :: FILE_ENUM


/*******************************************************************

    NAME:           FILE_ENUM :: ~FILE_ENUM

    SYNOPSIS:       FILE_ENUM class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     11-Sep-1992 Created.

********************************************************************/
FILE_ENUM :: ~FILE_ENUM( VOID )
{
    NukeBuffers();

}   // FILE_ENUM :: ~FILE_ENUM


/*******************************************************************

    NAME:           FILE_ENUM :: CallAPI

    SYNOPSIS:       Invokes the enumeration API (NetFileEnum2()).

    ENTRY:          fRestartEnum        - Indicates whether to start at the
                                          beginning.  The first call to
                                          CallAPI will always pass TRUE.

                    ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API has been invoked.

    RETURNS:        APIERR          - Any errors encountered.

    NOTES:

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
APIERR FILE_ENUM :: CallAPI( BOOL    fRestartEnum,
                             BYTE ** ppbBuffer,
                             UINT  * pcEntriesRead )
{

    //
    //  Restart the enumeration if fRestartEnum is TRUE
    //

    if ( fRestartEnum )
    {
        FRK_INIT( _frk );
    }

    //
    //  Most LanMan API treat a NULL pointer the same as a
    //  NULL string (pointer to '\0').  Unfortunately,
    //  NetFileEnum2() does not work this way.  If all files
    //  opened by all users are to be enumerated, then
    //  NULLs must be passed for the base path and user name.
    //  However, a NULL passed to the NLS_STR constructor
    //  will result in NLS_STR::QueryPch() returning an
    //  empty string.
    //
    //  To get around this behaviour, we must explicitly
    //  convert empty strings to NULL pointers before
    //  passing them to NetFileEnum2().
    //

    const TCHAR * pszBasePath = _nlsBasePath.QueryPch();
    const TCHAR * pszUserName = _nlsUserName.QueryPch();

    UINT cTotalAvailable;

    APIERR err = ::MNetFileEnum( QueryServer(),
                                 ( *pszBasePath == TCH('\0') ) ? NULL : pszBasePath,
                                 ( *pszUserName == TCH('\0') ) ? NULL : pszUserName,
                                 QueryInfoLevel(),
                                 ppbBuffer,
                                 (_fBigBuffer)  ? LARGE_BUFFER_SIZE
                                                : SMALL_BUFFER_SIZE,
                                 pcEntriesRead,
                                 &cTotalAvailable,
                                 &_frk );

    //
    //  At first, the enumeration API is attempted with
    //  a small buffer.  If the buffer is too small, we
    //  pass this data back to the caller, then use a
    //  larger buffer in future.
    //

    switch (err)
    {
    case NERR_BufTooSmall:
    case ERROR_MORE_DATA:

        _fBigBuffer = TRUE;
        // fall through

    case NERR_Success:
    default:
        break;
    }

    return err;

}   // FILE_ENUM :: CallAPI


/*******************************************************************

    NAME:           FILE_ENUM :: FreeBuffer

    SYNOPSIS:       Frees the API buffer.

    ENTRY:          ppbBuffer           - Points to a pointer to the
                                          enumeration buffer.

    HISTORY:
        KeithMo     31-Mar-1992 Created.

********************************************************************/
VOID FILE_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    UIASSERT( ppbBuffer != NULL );

    ::MNetApiBufferFree( ppbBuffer );

}   // FILE_ENUM :: FreeBuffer


/*******************************************************************

    NAME:           FILE2_ENUM :: FILE2_ENUM

    SYNOPSIS:       FILE2_ENUM class constructor.

    ENTRY:          pszServerName   - The name of the server to execute
                                      the enumeration on.  NULL =
                                      execute locally.

                    pszBasePath     - The root directory for the
                                      enumeration.  NULL = enumerate all
                                      open files.

                    pszUserName     - The name of the user to enumerate
                                      the files for.  NULL = enumerate
                                      for all users.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
FILE2_ENUM :: FILE2_ENUM( const TCHAR * pszServerName,
                          const TCHAR * pszBasePath,
                          const TCHAR * pszUserName )
  : FILE_ENUM( pszServerName, pszBasePath, pszUserName, 2 )
{
    //
    //  This space intentionally left blank.
    //

}   // FILE2_ENUM :: FILE2_ENUM


/*******************************************************************

    NAME:       FILE2_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:   Saves the buffer pointer for this enumeration object.

    ENTRY:      pBuffer                 - Pointer to the new buffer.

    EXIT:       The pointer has been saved.

    NOTES:      Will eventually handle OemToAnsi conversions.

    HISTORY:
        KeithMo     09-Oct-1991     Created.

********************************************************************/
VOID FILE2_ENUM_OBJ :: SetBufferPtr( const struct file_info_2 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // FILE2_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_RESUME_ENUM_ITER_OF( FILE2, struct file_info_2 );


/*******************************************************************

    NAME:           FILE3_ENUM :: FILE3_ENUM

    SYNOPSIS:       FILE3_ENUM class constructor.

    ENTRY:          pszServerName   - The name of the server to execute
                                      the enumeration on.  NULL =
                                      execute locally.

                    pszBasePath     - The root directory for the
                                      enumeration.  NULL = enumerate all
                                      open files.

                    pszUserName     - The name of the user to enumerate
                                      the files for.  NULL = enumerate
                                      for all users.

    EXIT:           The object is constructed.

    RETURNS:        No return value.

    NOTES:

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
FILE3_ENUM :: FILE3_ENUM( const TCHAR * pszServerName,
                          const TCHAR * pszBasePath,
                          const TCHAR * pszUserName )
  : FILE_ENUM( pszServerName, pszBasePath, pszUserName, 3 )
{
    //
    //  This space intentionally left blank.
    //

}   // FILE3_ENUM :: FILE3_ENUM


/*******************************************************************

    NAME:       FILE3_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:   Saves the buffer pointer for this enumeration object.

    ENTRY:      pBuffer                 - Pointer to the new buffer.

    EXIT:       The pointer has been saved.

    NOTES:      Will eventually handle OemToAnsi conversions.

    HISTORY:
        KeithMo     09-Oct-1991     Created.

********************************************************************/
VOID FILE3_ENUM_OBJ :: SetBufferPtr( const struct file_info_3 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // FILE3_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_RESUME_ENUM_ITER_OF( FILE3, struct file_info_3 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoerepl.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    lmoerepl.hxx
    This file contains the class definitions for the REPL_EDIR0_ENUM,
    REPL_EDIR1_ENUM, REPL_EDIR2_ENUM, REPL_IDIR0_ENUM, and
    REPL_IDIR1_ENUM classes and their associated iterators.
    and FILE3_ENUM_ITER classes.

    FILE HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

*/

#include "pchlmobj.hxx"

//
//  REPL_EDIRx_ENUM methods.
//

/*******************************************************************

    NAME:	REPL_EDIR_ENUM :: REPL_EDIR_ENUN

    SYNOPSIS:	REPL_EDIR_ENUM class constructor.

    ENTRY:	pszServer		- Name of the target server.

		Level			- Info-level for this enumerator.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
REPL_EDIR_ENUM :: REPL_EDIR_ENUM( const TCHAR * pszServer,
				  UINT		Level )
  : LOC_LM_ENUM( pszServer, Level )
{
    UIASSERT( Level <= 2 );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
	return;
    }

}   // REPL_EDIR_ENUM :: REPL_EDIR_ENUM


/*******************************************************************

    NAME:	    REPL_EDIR_ENUM :: CallAPI

    SYNOPSIS:	    Invokes the NetReplExportDirEnum API.

    ENTRY:	    ppbBuffer		- Pointer to a pointer to the
					  enumeration buffer.

		    pcEntriesRead	- Will receive the number of
		    		  	  entries read from the API.

    EXIT:	    The enumeration API is invoked.

    RETURNS:	    APIERR		- Any errors encountered.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
APIERR REPL_EDIR_ENUM :: CallAPI( BYTE ** ppbBuffer,
			          UINT  * pcEntriesRead )
{
    return ::MNetReplExportDirEnum( QueryServer(),
				    QueryInfoLevel(),
				    ppbBuffer,
				    pcEntriesRead );

}   // REPL_EDIR_ENUM :: CallAPI

/*******************************************************************

    NAME:	REPL_EDIR0_ENUM :: REPL_EDIR0_ENUN

    SYNOPSIS:	REPL_EDIR0_ENUM class constructor.

    ENTRY:	pszServer		- Name of the target server.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
REPL_EDIR0_ENUM :: REPL_EDIR0_ENUM( const TCHAR * pszServer )
  : REPL_EDIR_ENUM( pszServer, 0 )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
	return;
    }

}   // REPL_EDIR0_ENUM :: REPL_EDIR0_ENUM

DEFINE_LM_ENUM_ITER_OF( REPL_EDIR0, REPL_EDIR_INFO_0 );

/*******************************************************************

    NAME:	REPL_EDIR1_ENUM :: REPL_EDIR1_ENUN

    SYNOPSIS:	REPL_EDIR1_ENUM class constructor.

    ENTRY:	pszServer		- Name of the target server.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
REPL_EDIR1_ENUM :: REPL_EDIR1_ENUM( const TCHAR * pszServer )
  : REPL_EDIR_ENUM( pszServer, 1 )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
	return;
    }

}   // REPL_EDIR1_ENUM :: REPL_EDIR1_ENUM

DEFINE_LM_ENUM_ITER_OF( REPL_EDIR1, REPL_EDIR_INFO_1 );

/*******************************************************************

    NAME:	REPL_EDIR2_ENUM :: REPL_EDIR2_ENUN

    SYNOPSIS:	REPL_EDIR2_ENUM class constructor.

    ENTRY:	pszServer		- Name of the target server.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
REPL_EDIR2_ENUM :: REPL_EDIR2_ENUM( const TCHAR * pszServer )
  : REPL_EDIR_ENUM( pszServer, 2 )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
	return;
    }

}   // REPL_EDIR2_ENUM :: REPL_EDIR2_ENUM

DEFINE_LM_ENUM_ITER_OF( REPL_EDIR2, REPL_EDIR_INFO_2 );


//
//  REPL_IDIRx_ENUM methods.
//

/*******************************************************************

    NAME:	REPL_IDIR_ENUM :: REPL_IDIR_ENUN

    SYNOPSIS:	REPL_IDIR_ENUM class constructor.

    ENTRY:	pszServer		- Name of the target server.

		Level			- Info-level for this enumerator.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
REPL_IDIR_ENUM :: REPL_IDIR_ENUM( const TCHAR * pszServer,
				  UINT		Level )
  : LOC_LM_ENUM( pszServer, Level )
{
    UIASSERT( Level <= 1 );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
	return;
    }

}   // REPL_IDIR_ENUM :: REPL_IDIR_ENUM


/*******************************************************************

    NAME:	    REPL_IDIR_ENUM :: CallAPI

    SYNOPSIS:	    Invokes the NetReplImportDirEnum API.

    ENTRY:	    ppbBuffer		- Pointer to a pointer to the
					  enumeration buffer.

		    pcEntriesRead	- Will receive the number of
		    		  	  entries read from the API.

    EXIT:	    The enumeration API is invoked.

    RETURNS:	    APIERR		- Any errors encountered.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
APIERR REPL_IDIR_ENUM :: CallAPI( BYTE ** ppbBuffer,
			          UINT  * pcEntriesRead )
{
    return ::MNetReplImportDirEnum( QueryServer(),
				    QueryInfoLevel(),
				    ppbBuffer,
				    pcEntriesRead );

}   // REPL_IDIR_ENUM :: CallAPI

/*******************************************************************

    NAME:	REPL_IDIR0_ENUM :: REPL_IDIR0_ENUN

    SYNOPSIS:	REPL_IDIR0_ENUM class constructor.

    ENTRY:	pszServer		- Name of the target server.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
REPL_IDIR0_ENUM :: REPL_IDIR0_ENUM( const TCHAR * pszServer )
  : REPL_IDIR_ENUM( pszServer, 0 )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
	return;
    }

}   // REPL_IDIR0_ENUM :: REPL_IDIR0_ENUM

DEFINE_LM_ENUM_ITER_OF( REPL_IDIR0, REPL_IDIR_INFO_0 );

/*******************************************************************

    NAME:	REPL_IDIR1_ENUM :: REPL_IDIR1_ENUN

    SYNOPSIS:	REPL_IDIR1_ENUM class constructor.

    ENTRY:	pszServer		- Name of the target server.

    EXIT:	The object is constructed.

    HISTORY:
	KeithMo	    26-Feb-1992	    Created for the Server Manager.

********************************************************************/
REPL_IDIR1_ENUM :: REPL_IDIR1_ENUM( const TCHAR * pszServer )
  : REPL_IDIR_ENUM( pszServer, 1 )
{
    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
	return;
    }

}   // REPL_IDIR1_ENUM :: REPL_IDIR1_ENUM

DEFINE_LM_ENUM_ITER_OF( REPL_IDIR1, REPL_IDIR_INFO_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoesh.cxx ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1991		**/
/*****************************************************************/

/*
 *  HISTORY:
 *	RustanL     03-Jan-1991     Created
 *	RustanL     10-Jan-1991     Added SHARE1 subclass and iterator
 *	RustanL     24-Jan-1991     Changed UIASSERT's to also support
 *				    the recently added level 90
 *	beng	    11-Feb-1991     Uses lmui.hxx
 *	chuckc	    20-Mar-1991     Share Enum level 91, not 92
 *	chuckc	    23-Mar-1991     code rev cleanup
 *	KeithMo	    28-Jul-1991	    Added SHARE2 subclass and iterator
 *	KeithMo	    12-Aug-1991	    Code review cleanup.
 *	KeithMo	    07-Oct-1991	    Win32 Conversion.
 *      Yi-HsinS    20-Nov-1992     Added support for calling NetShareEnumSticky
 *
 */

#include "pchlmobj.hxx"


/*****************************	SHARE_ENUM  ******************************/


/**********************************************************\

   NAME:       SHARE_ENUM::SHARE_ENUM

   SYNOPSIS:   share enum constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

SHARE_ENUM::SHARE_ENUM( const TCHAR * pszServer, UINT uLevel, BOOL fSticky )
  : LOC_LM_ENUM( pszServer, uLevel ),
    _fSticky( fSticky )
{
    // only supports levels 1, 2, 90, 91 at this time
    UIASSERT( uLevel == 1 || uLevel == 2 || uLevel == 90 || uLevel == 91 );

}  // SHARE_ENUM::SHARE_ENUM



/**********************************************************\

   NAME:       SHARE_ENUM::CallAPI

   SYNOPSIS:   call share enum api

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created
	KeithMo	    12-Aug-1991	    Code review cleanup.

\**********************************************************/

APIERR SHARE_ENUM::CallAPI( BYTE ** ppbBuffer,
			    UINT  * pcEntriesRead )
{
    // only levels support at the time
    UIASSERT( QueryInfoLevel() == 1 ||
	      QueryInfoLevel() == 2 ||
	      QueryInfoLevel() == 90 ||
	      QueryInfoLevel() == 91 );

    if ( _fSticky )
    {
        return ::MNetShareEnumSticky( QueryServer(),
	 		              QueryInfoLevel(),
			              ppbBuffer,
			              pcEntriesRead );
    }
    else
    {
        return ::MNetShareEnum( QueryServer(),
	      		        QueryInfoLevel(),
			        ppbBuffer,
			        pcEntriesRead );
    }

}  // SHARE_ENUM::CallAPI



/*****************************	SHARE1_ENUM  ******************************/



/**********************************************************\

   NAME:       SHARE1_ENUM::SHARE1_ENUM

   SYNOPSIS:   share enum 1 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

SHARE1_ENUM::SHARE1_ENUM( const TCHAR * pszServer, BOOL fSticky )
  : SHARE_ENUM( pszServer, 1, fSticky )
{
    // do nothing else

}  // SHARE1_ENUM::SHARE1_ENUM



/*******************************************************************

    NAME:	SHARE1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID SHARE1_ENUM_OBJ :: SetBufferPtr( const struct share_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SHARE1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( SHARE1, struct share_info_1 );



/*****************************	SHARE2_ENUM  ******************************/



/*******************************************************************

    NAME:	SHARE2_ENUM :: SHARE2_ENUM

    SYNOPSIS:	Constructor for the level 2 share enumerator.

    ENTRY:	pszServer		- The name of the target server.

    EXIT:

    RETURNS:	No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
SHARE2_ENUM :: SHARE2_ENUM( const TCHAR * pszServer, BOOL fSticky )
  : SHARE_ENUM( pszServer, 2, fSticky )
{
    //
    //	This space intentionally left blank.
    //

}   // SHARE2_ENUM :: SHARE2_ENUM


/*******************************************************************

    NAME:	SHARE2_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID SHARE2_ENUM_OBJ :: SetBufferPtr( const struct share_info_2 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SHARE2_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( SHARE2, struct share_info_2 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoesess.cxx ===
/**********************************************************************/
/**			  Microsoft LAN Manager 		     **/
/**		Copyright(c) Microsoft Corp., 1990, 1991	     **/
/**********************************************************************/

/*
    lmoesess.cxx
    This file contains the class definitions for the SESSION_ENUM and
    SESSION0_ENUM enumerator class and their associated iterator classes.

    SESSION_ENUM is a base enumeration class intended to be subclassed for
    the desired info level.  SESSION0_ENUM is an info level 0 enumerator.


    FILE HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.
	KeithMo	    07-Oct-1991	    Win32 Conversion.

*/

#include "pchlmobj.hxx"

//
//  SESSION_ENUM methods
//

/*******************************************************************

    NAME:	    SESSION_ENUM :: SESSION_ENUM

    SYNOPSIS:	    SESSION_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

		    usLevel		- The information level.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
SESSION_ENUM :: SESSION_ENUM( const TCHAR * pszServerName,
			      UINT	   uLevel )
  : LOC_LM_ENUM( pszServerName, uLevel )
{
    //
    //	This space intentionally left blank.
    //

}   // SESSION_ENUM :: SESSION_ENUM


/*******************************************************************

    NAME:	    SESSION_ENUM :: CallAPI

    SYNOPSIS:	    Invokes the NetSessionEnum() enumeration API.

    ENTRY:	    ppbBuffer		- Pointer to a pointer to the
					  enumeration buffer.

		    pcEntriesRead	- Will receive the number of
		    		  	  entries read from the API.

    EXIT:	    The enumeration API is invoked.

    RETURNS:	    APIERR		- Any errors encountered.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.
	KeithMo	    12-Aug-1991	    Code review cleanup.

********************************************************************/
APIERR SESSION_ENUM :: CallAPI( BYTE ** ppbBuffer,
			 	UINT  * pcEntriesRead )
{
    return ::MNetSessionEnum( QueryServer(),
    			      QueryInfoLevel(),
			      ppbBuffer,
			      pcEntriesRead );

}   // SESSION_ENUM :: CallAPI


//
//  SESSION0_ENUM methods
//

/*******************************************************************

    NAME:	    SESSION0_ENUM :: SESSION0_ENUM

    SYNOPSIS:	    SESSION0_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KeithMo	    28-Jul-1991	    Created.

********************************************************************/
SESSION0_ENUM :: SESSION0_ENUM( const TCHAR * pszServerName )
  : SESSION_ENUM( pszServerName, 0 )
{
    //
    //	This space intentionally left blank.
    //

}   // SESSION0_ENUM :: SESSION0_ENUM


/*******************************************************************

    NAME:	SESSION0_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID SESSION0_ENUM_OBJ :: SetBufferPtr( const struct session_info_0 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SESSION0_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( SESSION0, struct session_info_0 );


//
//  SESSION1_ENUM methods
//

/*******************************************************************

    NAME:	    SESSION1_ENUM :: SESSION1_ENUM

    SYNOPSIS:	    SESSION1_ENUM class constructor.

    ENTRY:	    pszServerName	- The name of the server to execute
    				  	  the enumeration on.  NULL =
				  	  execute locally.

    EXIT:	    The object is constructed.

    RETURNS:	    No return value.

    NOTES:

    HISTORY:
	KevinL	    15-Sep-1991	    Created.

********************************************************************/
SESSION1_ENUM :: SESSION1_ENUM( const TCHAR * pszServerName )
  : SESSION_ENUM( pszServerName, 1 )
{
    //
    //	This space intentionally left blank.
    //

}   // SESSION1_ENUM :: SESSION1_ENUM


/*******************************************************************

    NAME:	SESSION1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
VOID SESSION1_ENUM_OBJ :: SetBufferPtr( const struct session_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SESSION1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( SESSION1, struct session_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoersm.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    lmoersm.cxx
    This file contains the class definitions for the LM_RESUME_ENUM
    and LM_RESUME_ENUM_ITER classes.

    LM_RESUME_ENUM is a generic enumeration class for resumeable
    API.  LM_RESUME_ENUM_ITER is an iterator for iterating objects
    created from the LM_RESUME_ENUM class.

    NOTE:  All classes contained in this file were derived from
           RustanL's LM_ENUM/LM_ENUM_ITER classes.


    FILE HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup, added LOCATION support.
        KeithMo     19-Aug-1991 Code review revisions (code review
                                attended by ChuckC, Hui-LiCh, JimH,
                                JonN, KevinL).
        KeithMo     07-Oct-1991 Win32 Conversion.
        JonN        30-Jan-1992 Split LOC_LM_RESUME_ENUM from LM_RESUME_ENUM
        KeithMo     18-Mar-1992 Added optional constructor parameter to
                                force enumerator to keep all buffers.
                                (single/multi buffer support).
        KeithMo     31-Mar-1992 Code review revisions (code review
                                attended by JimH, JohnL, JonN, and ThomasPa).
*/

#include "pchlmobj.hxx"



//
//  LM_RESUME_BUFFER methods.
//

/*******************************************************************

    NAME:           LM_RESUME_BUFFER :: LM_RESUME_BUFFER

    SYNOPSIS:       LM_RESUME_BUFFER class constructor.

    ENTRY:          penum               - Points to the LM_RESUME_ENUM
                                          enumerator that "owns" this
                                          node.

                    cItems              - The number of enumeration items
                                          in the buffer.

                    pbBuffer            - The enumeration buffer.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     15-Mar-1992 Created for the Server Manager.

********************************************************************/
LM_RESUME_BUFFER :: LM_RESUME_BUFFER( LM_RESUME_ENUM * penum,
                                      UINT             cItems,
                                      BYTE           * pbBuffer )
  : BASE(),
    _penum( penum ),
    _cItems( cItems ),
    _pbBuffer( pbBuffer )
{
    UIASSERT( _penum != NULL );
    UIASSERT( _cItems > 0 );
    UIASSERT( _pbBuffer != NULL );

    //
    //  Ensure that everything constructed propertly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

}   // LM_RESUME_BUFFER :: LM_RESUME_BUFFER


/*******************************************************************

    NAME:           LM_RESUME_BUFFER :: ~LM_RESUME_BUFFER

    SYNOPSIS:       LM_RESUME_BUFFER class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     15-Mar-1992 Created for the Server Manager.

********************************************************************/
LM_RESUME_BUFFER :: ~LM_RESUME_BUFFER( VOID )
{
    _penum->FreeBuffer( &_pbBuffer );

    _pbBuffer = NULL;
    _cItems   = 0;

}   // LM_RESUME_BUFFER :: ~LM_RESUME_BUFFER

DEFINE_SLIST_OF( LM_RESUME_BUFFER );



//
//  LM_RESUME_ENUM methods.
//

/*******************************************************************

    NAME:           LM_RESUME_ENUM :: LM_RESUME_ENUM

    SYNOPSIS:       LM_RESUME_ENUM class constructor.

    ENTRY:          pszServerName       - Pointer to the server name.

                    uLevel              - Information level.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Moved constructor validation to CtAux().
        JonN        30-Jan-1992 Recombined constructors

********************************************************************/
LM_RESUME_ENUM :: LM_RESUME_ENUM( UINT uLevel,
                                  BOOL fKeepBuffers )
  : _uLevel( uLevel ),
    _fKeepBuffers( fKeepBuffers ),
    _pbBuffer( NULL ),
    _cEntriesRead( 0 ),
    _fMoreData( FALSE ),
    _cAllItems( 0 )
{

    //
    //  Ensure that everything constructed propertly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    //
    //  Clear the iterator reference counter.
    //

    _cIterRef = 0;

}   // LM_RESUME_ENUM :: LM_RESUME_ENUM



/*******************************************************************

    NAME:           LM_RESUME_ENUM :: ~LM_RESUME_ENUM

    SYNOPSIS:       LM_RESUME_ENUM class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.

********************************************************************/
LM_RESUME_ENUM :: ~LM_RESUME_ENUM()
{
    UIASSERT( _cIterRef == 0 );

}   // LM_RESUME_ENUM :: ~LM_RESUME_ENUM


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: GetInfo

    SYNOPSIS:       Invokes the enumeration API.

    ENTRY:          fRestartEnum        - Should we start at the
                                          beginning?  Note that this
                                          flag is only used if
                                          DoesKeepBuffers() is FALSE.


    EXIT:           If DoesKeepBuffers() is TRUE, then GetInfoMulti()
                    is invoked to collect all of the enumeration
                    buffers.  Otherwise, GetInfoSingle() is invoked
                    to get the first enumeration buffer.

    RETURNS:        APIERR      - Any errors encountered.

    HISTORY:
        KeithMo     18-Mar-1991 Created for the Server Manager.

********************************************************************/
APIERR LM_RESUME_ENUM :: GetInfo( BOOL fRestartEnum )
{
    return DoesKeepBuffers() ? GetInfoMulti()
                             : GetInfoSingle( fRestartEnum );

}   // LM_RESUME_ENUM :: GetInfo


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: GetInfoSingle

    SYNOPSIS:       Invokes the enumeration API.

    ENTRY:          fRestartEnum - Should we start at the beginning?

    EXIT:           The enumeration buffer is allocated, and the
                    enumeration API is invoked.  If the API is
                    successful, then the buffer will contain
                    the first chunk of the enumeration data.
                    Further calls to GetInfo() may be required to
                    complete the enumeration.

    RETURNS:        APIERR      - Any errors encountered.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        rustanl     15-Jul-1991 Changed to use new BUFFER::Resize return
                                type
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Improved error handling and buffer
                                management.
        KeithMo     18-Mar-1992 Renamed from GetInfo to GetInfoSingle
                                for single/multi buffer support.

********************************************************************/
APIERR LM_RESUME_ENUM :: GetInfoSingle( BOOL fRestartEnum )
{
    //
    //  We must be careful to free any enumeration buffers
    //  allocated on our behalf by the API.
    //

    FreeBuffer( &_pbBuffer );
    ASSERT( _pbBuffer == NULL );

    //
    //  Invoke the API.
    //

    APIERR err = CallAPI( fRestartEnum,
                          &_pbBuffer,
                          &_cEntriesRead );

    //
    //  Interpret the return code.
    //

    switch ( err )
    {
    case NERR_Success:

        //
        //  Success!
        //
        //  Setting this flag to FALSE will tell the
        //  LM_RESUME_ENUM_ITER class that there's no point
        //  in issuing further calls to GetInfo().
        //

        _fMoreData = FALSE;
        // CODEWORK: We should assert here that
        // ASSERT( _pbBuffer != NULL );
        // , but this is not the case for FILE_ENUM, which sometimes
        // returns a NULL buffer and NERR_Success.  This assertion can be
        // restored when LMOEFILE.CXX is fixed to change the return in
        // that case to ERROR_NO_MORE_ITEMS.  JonN 7/10/96

        break;

    case NERR_BufTooSmall:
    case ERROR_MORE_DATA:

        //
        //  The enumeration API is telling us that our buffer
        //  is too small.  Since we don't want to grow the
        //  buffer any larger than this, we'll just have to
        //  live with it and make multiple calls to GetInfo().
        //
        //  Setting this flag to TRUE tells LM_RESUME_ENUM_ITER
        //  that more enumeration data is available.
        //

        _fMoreData = TRUE;
        // CODEWORK This should probably be present, but strange
        // error-handling in lsaenum.cxx will set it off.  The code
        // will muddle through despite the confusion.  I have filed a
        // bug in this.
        // ASSERT( _pbBuffer != NULL );

        //
        //  Since we're using resumable API, we'll pretend
        //  that the API was successful.  Subsequent calls
        //  to GetInfo() will retrieve the remaining enumeration
        //  data.

        break;

    default:

        //
        //      Unknown error.  Return it to the caller.
        //

        ASSERT( _pbBuffer == NULL );

        return err;
    }

    //
    //  Success!
    //

    return NERR_Success;

}   // LM_RESUME_ENUM :: GetInfoSingle


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: GetInfoMulti

    SYNOPSIS:       Invokes the enumeration API.

    EXIT:           The enumeration buffer(s) are allocated, and the
                    enumeration API is invoked.  If the API is
                    successful, then the buffer(s) will contain
                    the enumeration data.

    RETURNS:        APIERR      - Any errors encountered.

    HISTORY:
        KeithMo     18-Mar-1991 Created for the Server Manager.

********************************************************************/
APIERR LM_RESUME_ENUM :: GetInfoMulti( VOID )
{
    UIASSERT( _BufferList.QueryNumElem() == 0 );

    BYTE * pbBuffer;
    UINT   cEntriesRead;
    APIERR err = NERR_Success;
    BOOL   fRestartEnum = TRUE;

    for( BOOL fMoreData = TRUE ; fMoreData && ( err == NERR_Success ) ; )
    {
        //
        //  Invoke the API.
        //

        err = CallAPI( fRestartEnum,
                       &pbBuffer,
                       &cEntriesRead );

        fRestartEnum = FALSE;

        //
        //  Interpret the return code.
        //

        if( err == NERR_Success )
        {
            //
            //  This is very good.  It means that we've retrieved
            //  all of the enumeration data.  We still need to
            //  save the current buffer away, though.
            //

            fMoreData = FALSE;
        }
        else
        if( ( err == NERR_BufTooSmall ) || ( err == ERROR_MORE_DATA ) )
        {
            UIASSERT( cEntriesRead != 0 );

            //
            //  This is also good, it just means that the API
            //  could not allocate enough buffer space for *all*
            //  of the enumeration data.  We'll save away the
            //  current buffer, then loop around & get some more.
            //

            //
            //  Just to make the looping logic somewhat simpler,
            //  we'll map these return codes to NERR_Success.
            //

            err = NERR_Success;
        }
        else
        {
            //
            //  This is not good at all.  Something tragic must
            //  have happened in the API, so break out of the
            //  loop.
            //

            break;
        }

        if( cEntriesRead == 0 )
        {
            //
            //  I'm not sure if this will ever happen, but
            //  we might as well check for it.
            //

            continue;
        }

        _cAllItems += cEntriesRead;

        //
        //  Allocate a new buffer node for our buffer list.
        //

        LM_RESUME_BUFFER * plmrb = new LM_RESUME_BUFFER( this,
                                                         cEntriesRead,
                                                         pbBuffer );

        err = ( plmrb == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                : plmrb->QueryError();

        if( err == NERR_Success )
        {
            //
            //  Add the node to our buffer list.
            //

            err = _BufferList.Append( plmrb );
        }
    }

    return err;

}   // LM_RESUME_ENUM :: GetInfoMulti


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: NukeBuffers

    SYNOPSIS:       Destroys any buffer(s) allocated by this enumerator.

    EXIT:           The enumeration buffer(s) are history.

    NOTES:          THIS METHOD **MUST** BE CALLED FROM THE DESTRUCTOR
                    OF ANY DERIVED SUBCLASS THAT OVERRIDES THE FreeBuffer()
                    VIRTUAL!!!

    HISTORY:
        KeithMo     11-Sep-1992 Created in a fit of stress & confusion.

********************************************************************/
VOID LM_RESUME_ENUM :: NukeBuffers( VOID )
{
    if( DoesKeepBuffers() )
    {
        _BufferList.Clear();
    }
    else
    {
        FreeBuffer( &_pbBuffer );
        ASSERT( _pbBuffer == NULL );
    }

}   // LM_RESUME_ENUM :: NukeBuffer


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: _RegisterIter

    SYNOPSIS:       Register a new iterator by incrementing a
                    reference counter.

    EXIT:           The iterator reference counter is incremented.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
VOID LM_RESUME_ENUM :: _RegisterIter( VOID )
{
#if defined(DEBUG)
    //
    //  If DoesKeepBuffers() is FALSE, then LM_RESUME_ENUM can only
    //  handle one iterator binding at a time.  To enforce this,
    //  we'll ensure that _cIterRef is 0.
    //

    UIASSERT( DoesKeepBuffers() || ( _cIterRef == 0 ) );

    _cIterRef++;

#endif // DEBUG
}   // LM_RESUME_ENUM :: RegisterIter


/*******************************************************************

    NAME:           LM_RESUME_ENUM :: _DeregisterIter

    SYNOPSIS:       Deregister an existing iterator by decrementing
                    a reference counter.

    EXIT:           The iterator reference counter is decremented.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.

********************************************************************/
VOID LM_RESUME_ENUM :: _DeregisterIter( VOID )
{
#if defined(DEBUG)
    if ( _cIterRef == 0 )
    {
        UIASSERT( FALSE );
    }
    else
    {
        _cIterRef--;
    }

#endif // DEBUG
}   // LM_RESUME_ENUM :: DeregisterIter


//
//  LOC_LM_RESUME_ENUM methods.
//


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM

    SYNOPSIS:       LOC_LM_RESUME_ENUM class constructor.

    ENTRY:          pszServerName       - Pointer to the server name.

                    uLevel              - Information level.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Moved constructor validation to CtAux().

********************************************************************/

LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM( const TCHAR * pszServerName,
                                          UINT          uLevel,
                                          BOOL          fKeepBuffers  )
  : LM_RESUME_ENUM( uLevel, fKeepBuffers ),
    _loc( pszServerName )
{

    if( !_loc )
    {
        ReportError( _loc.QueryError() );
        return;
    }

}   // LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM

    SYNOPSIS:       LOC_LM_RESUME_ENUM class constructor.

    ENTRY:          locType             - Location type (a server).

                    uLevel              - Information level.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     13-Aug-1991 Created this constructor.
        KeithMo     19-Aug-1991 Moved constructor validation to CtAux().

********************************************************************/

LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM( LOCATION_TYPE locType,
                                          UINT          uLevel,
                                          BOOL          fKeepBuffers  )
  : LM_RESUME_ENUM( uLevel, fKeepBuffers ),
    _loc( locType )
{

    if( !_loc )
    {
        ReportError( _loc.QueryError() );
        return;
    }


}   // LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM

    SYNOPSIS:       LOC_LM_RESUME_ENUM class constructor.

    ENTRY:          loc                 - A LOCATION reference.

                    uLevel              - Information level.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     13-Aug-1991 Created this constructor.
        KeithMo     19-Aug-1991 Moved constructor validation to CtAux().

********************************************************************/
LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM( const LOCATION & loc,
                                          UINT             uLevel,
                                          BOOL             fKeepBuffers  )
  : LM_RESUME_ENUM( uLevel, fKeepBuffers ),
    _loc( loc )
{

    if( !_loc )
    {
        ReportError( _loc.QueryError() );
        return;
    }

}   // LOC_LM_RESUME_ENUM :: LOC_LM_RESUME_ENUM


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: ~LOC_LM_RESUME_ENUM

    SYNOPSIS:       LOC_LM_RESUME_ENUM class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.

********************************************************************/
LOC_LM_RESUME_ENUM :: ~LOC_LM_RESUME_ENUM()
{
    NukeBuffers();

}   // LM_RESUME_ENUM :: ~LM_RESUME_ENUM


/*******************************************************************

    NAME:           LOC_LM_RESUME_ENUM :: FreeBuffer

    SYNOPSIS:       Frees the API buffer.

    ENTRY:          ppbBuffer           - Points to a pointer to the
                                          enumeration buffer.

    NOTE:           Some code relies on the pointer being reset to NULL.

    HISTORY:
        KeithMo     31-Mar-1992 Created.

********************************************************************/
VOID LOC_LM_RESUME_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    UIASSERT( ppbBuffer != NULL );

    ::MNetApiBufferFree( ppbBuffer );

    ASSERT( *ppbBuffer == NULL );

}   // LOC_LM_RESUME_ENUM :: FreeBuffer



//
//  LM_RESUME_ENUM_ITER methods.
//

/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: LM_RESUME_ENUM_ITER

    SYNOPSIS:       LM_RESUME_ENUM_ITER class constructor.

    ENTRY:          lmenum      - The enumerator to iterate.

    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
LM_RESUME_ENUM_ITER :: LM_RESUME_ENUM_ITER( LM_RESUME_ENUM & lmenum )
  : BASE(),
    _plmenum( &lmenum ),
    _iterBuffer( lmenum._BufferList )
{
    //
    //  Register this iterator with the enumerator.
    //

    _plmenum->RegisterIter();

    //
    //  The the enumerator we're "bound to" keeps all of its
    //  buffers hanging around, then we must "prime the pump".
    //  This will retrieve the first LM_RESUME_BUFFER from the
    //  enumerator's slist.
    //

    if( _plmenum->DoesKeepBuffers() )
    {
        _plmbuffer = _iterBuffer.Next();
    }

}   // LM_RESUME_ENUM_ITER :: LM_RESUME_ENUM_ITER


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: ~LM_RESUME_ENUM_ITER

    SYNOPSIS:       LM_RESUME_ENUM_ITER class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.

********************************************************************/
LM_RESUME_ENUM_ITER :: ~LM_RESUME_ENUM_ITER()
{
    //
    //  Deregister this iterator from the enumerator.
    //

    _plmenum->DeregisterIter();

    _plmenum = NULL ;

}   // LM_RESUME_ENUM_ITER :: ~LM_RESUME_ENUM_ITER


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: QueryBasePtr

    SYNOPSIS:       Queries the base pointer of the current enumeration
                    buffer.

    RETURNS:        const BYTE *        - The enumerator's base pointer.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     18-Mar-1992 Added single/multi buffer support.
        KeithMo     14-Apr-1992 Fixed empty enumeration case.

********************************************************************/
const BYTE * LM_RESUME_ENUM_ITER :: QueryBasePtr( VOID ) const
{
    if( _plmenum->DoesKeepBuffers() )
    {
        return ( _plmbuffer == NULL ) ? NULL
                                      : _plmbuffer->QueryBufferPtr();
    }
    else
    {
        return _plmenum->_pbBuffer;
    }

}   // LM_RESUME_ENUM_ITER :: QueryBasePtr


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: QueryCount

    SYNOPSIS:       Queries the number of objects in the current
                    enumeration buffer.

    RETURNS:        UINT        - The number of objects in the
                                  current enumeration buffer.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Renamed QueryCount() from QuerySize().
        KeithMo     18-Mar-1992 Added single/multi buffer support.
        KeithMo     14-Apr-1992 Fixed empty enumeration case.

********************************************************************/
UINT LM_RESUME_ENUM_ITER :: QueryCount( VOID ) const
{
    if( _plmenum->DoesKeepBuffers() )
    {
        return ( _plmbuffer == NULL ) ? 0
                                      : _plmbuffer->QueryItemCount();
    }
    else
    {
        return _plmenum->_cEntriesRead;
    }

}   // LM_RESUME_ENUM_ITER :: QueryCount


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: HasMoreData

    SYNOPSIS:       Queries the _fMoreData flag.

    RETURNS:        BOOL        - TRUE  if there is more data available.
                                  FALSE if there is no more data.

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     19-Aug-1991 Renamed HasMoreData() from
                                QueryMoreData().
        KeithMo     18-Mar-1992 Added single/multi buffer support.
        KeithMo     14-Apr-1992 Fixed empty enumeration case.

********************************************************************/
BOOL LM_RESUME_ENUM_ITER :: HasMoreData( VOID ) const
{
    if( _plmenum->DoesKeepBuffers() )
    {
        if( _plmbuffer == NULL )
        {
            return FALSE;
        }

        ITER_SL iter( _iterBuffer );

        return iter.Next() != NULL;
    }
    else
    {
        return _plmenum->_fMoreData;
    }

}   // LM_RESUME_ENUM_ITER :: HasMoreData


/*******************************************************************

    NAME:           LM_RESUME_ENUM_ITER :: NextGetInfo

    SYNOPSIS:       Call the enumerator's GetInfo() method to read
                    the next available chuck of enumeration data.

    RETURNS:        APIERR      - Any errors returned from GetInfo().

    HISTORY:
        KeithMo     29-May-1991 Created for the Server Manager.
        KeithMo     13-Aug-1991 Cleanup.
        KeithMo     19-Aug-1991 Renamed NextGetInfo() from EnumNext().
        KeithMo     18-Mar-1992 Added single/multi buffer support.

********************************************************************/
APIERR LM_RESUME_ENUM_ITER :: NextGetInfo( VOID )
{
    UIASSERT( HasMoreData() );

    APIERR err = NERR_Success;

    if( _plmenum->DoesKeepBuffers() )
    {
        _plmbuffer = _iterBuffer.Next();
        UIASSERT( _plmbuffer != NULL );
    }
    else
    {
        err = _plmenum->GetInfo( FALSE );
    }

    return err;

}   // LM_RESUME_ENUM_ITER :: NextGetInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoesu.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoesu.cxx

    This file contains the class definitions for the SAM_USER_ENUM
    class and its associated iterator classes.


    FILE HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

*/

#include "pchlmobj.hxx"


//
//  The manifest TOTAL_BYTES_REQUESTED gives the number of BYTEs we request
//  from the server on each call to the trusted domain enumeration API.
//

#define TOTAL_BYTES_REQUESTED   0x0001FFFF



//
//  SAM_USER_ENUM methods.
//

/*******************************************************************

    NAME:       SAM_USER_ENUM :: SAM_USER_ENUM

    SYNOPSIS:   SAM_USER_ENUM class constructor.

    ENTRY:      psamdomain              - A pointer to a properly constructed
                                          SAM_DOMAIN object representing the
                                          target server (usually a PDC).

                lAccountControl         - A bitmask used to filter the
                                          enumeration.  This mask may be any
                                          combination of USER_* flags from
                                          NTSAM.H.

                fKeepBuffers            - If TRUE then LM_RESUME_ENUM
                                          will keep a list of all buffers
                                          created by CallAPI.

    HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

********************************************************************/
SAM_USER_ENUM :: SAM_USER_ENUM( const SAM_DOMAIN * psamdomain,
                                ULONG              lAccountControl,
                                BOOL               fKeepBuffers )
  : LM_RESUME_ENUM( 0, fKeepBuffers ),
    _psamdomain( psamdomain ),
    _ResumeKey( (SAM_ENUMERATE_HANDLE)0 ),
    _samrem(),
    _lAccountControl( lAccountControl )
{
    UIASSERT( psamdomain != NULL );
    UIASSERT( psamdomain->QueryError() == NERR_Success );
    UIASSERT( lAccountControl != 0L );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_samrem )
    {
        ReportError( _samrem.QueryError() );
        return;
    }

}  // SAM_USER_ENUM :: SAM_USER_ENUM


/*******************************************************************

    NAME:       SAM_USER_ENUM :: ~SAM_USER_ENUM

    SYNOPSIS:   SAM_USER_ENUM class destructor.

    HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

********************************************************************/
SAM_USER_ENUM :: ~SAM_USER_ENUM()
{
    NukeBuffers();

    _psamdomain = NULL;
    _ResumeKey  = (SAM_ENUMERATE_HANDLE)0;

}   // SAM_USER_ENUM :: ~SAM_USER_ENUM()


/*******************************************************************

    NAME:       SAM_USER_ENUM :: FreeBuffer

    SYNOPSIS:   Frees the enumeration buffer.

    ENTRY:      ppbBuffer               - Points to a pointer to the
                                          enumeration buffer.

    HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

********************************************************************/
VOID SAM_USER_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( *ppbBuffer == (BYTE *)_samrem.QueryPtr() );

    _samrem.Set( NULL, 0 );
    *ppbBuffer = NULL;

}   // SAM_USER_ENUM :: FreeBuffer


/*******************************************************************

    NAME:       SAM_USER_ENUM :: CallAPI

    SYNOPSIS:   Invokes the SamEnumerateUsersInDomain() API.

    ENTRY:      fRestartEnum            - If TRUE, then the enumeration
                                          handle should be reset to its
                                          starting position before invoking
                                          the API.

                ppbBuffer               - Points to a pointer to the
                                          buffer returned by the API.

                pcEntriesRead           - Will receive the number of
                                          enumeration entries read.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     13-Apr-1992     Created for the Server Manager.

********************************************************************/
APIERR SAM_USER_ENUM :: CallAPI( BOOL    fRestartEnum,
                                 BYTE ** ppbBuffer,
                                 UINT  * pcEntriesRead )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( pcEntriesRead != NULL );

    if( fRestartEnum )
    {
        _ResumeKey = (SAM_ENUMERATE_HANDLE)0;
    }

    APIERR err = _psamdomain->EnumerateUsers( &_samrem,
                                              &_ResumeKey,
                                              _lAccountControl );

    if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) )
    {
        *ppbBuffer     = (BYTE *)_samrem.QueryPtr();
        *pcEntriesRead = (UINT)_samrem.QueryCount();
    }

    return err;

}  // SAM_USER_ENUM :: CallAPI


DEFINE_LM_RESUME_ENUM_ITER_OF( SAM_USER, SAM_RID_ENUMERATION );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoesrv.cxx ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1991		**/
/*****************************************************************/

/*
 *  HISTORY:
 *	RustanL     03-Jan-1991     Created
 *	RustanL     10-Jan-1991     Added SERVER1 subclass and iterator
 *	beng	    11-Feb-1991     Uses lmui.hxx
 *	KeithMo	    21-Oct-1991	    Remove INCL_WINDOWS, enhanced WIN32.
 *
 */

#include "pchlmobj.hxx"

/*****************************	SERVER_ENUM  ******************************/


/**********************************************************\

   NAME:       SERVER_ENUM::SERVER_ENUM

   SYNOPSIS:   server_enum constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

SERVER_ENUM::SERVER_ENUM( const TCHAR * pszServer,
			  UINT	       uLevel,
			  const TCHAR * pszDomain,
			  ULONG        flServerType )
  : LOC_LM_ENUM( pszServer, uLevel ),
    _nlsDomain( pszDomain ),
    _flServerType( flServerType )
{
    UIASSERT( uLevel == 1 );	// only supports level 1 at this time

    if( QueryError() != NERR_Success )
    {
    	return;
    }

    if( !_nlsDomain )
    {
	ReportError( _nlsDomain.QueryError() );
    	return;
    }

}  // SERVER_ENUM::SERVER_ENUM



/**********************************************************\

   NAME:       SERVER_ENUM::CallAPI

   SYNOPSIS:   server enum call api

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

APIERR SERVER_ENUM::CallAPI( BYTE ** ppbBuffer,
			     UINT  * pcEntriesRead )
{
    UIASSERT( QueryInfoLevel() == 1 );	    // only level support at the time

    return ::MNetServerEnum( QueryServer(),
			     SERVER_INFO_LEVEL( QueryInfoLevel() ),
			     ppbBuffer,
			     pcEntriesRead,
			     _flServerType,
			     (TCHAR *)_nlsDomain.QueryPch() );

}  // SERVER_ENUM::CallAPI



/*****************************	SERVER1_ENUM  ******************************/


/**********************************************************\

   NAME:       SERVER1_ENUM::SERVER1_ENUM

   SYNOPSIS:   server enum 1 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	RustanL     03-Jan-1991     Created

\**********************************************************/

SERVER1_ENUM::SERVER1_ENUM( const TCHAR * pszServer,
			    const TCHAR * pszDomain,
			    ULONG	 flServerType )
  : SERVER_ENUM( pszServer, 1, pszDomain, flServerType )
{
    // do nothing else

}  // SERVER1_ENUM::SERVER1_ENUM



/*******************************************************************

    NAME:	SERVER1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
	KeithMo	    09-Oct-1991	    Created.

********************************************************************/
#ifdef WIN32

VOID SERVER1_ENUM_OBJ :: SetBufferPtr( const SERVER_INFO_101 * pBuffer )

#else	// !WIN32

VOID SERVER1_ENUM_OBJ :: SetBufferPtr( const struct server_info_1 * pBuffer )

#endif	// WIN32
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SERVER1_ENUM_OBJ :: SetBufferPtr


#ifdef WIN32

DEFINE_LM_ENUM_ITER_OF( SERVER1, SERVER_INFO_101 );

#else	// !WIN32

DEFINE_LM_ENUM_ITER_OF( SERVER1, struct server_info_1 );

#endif	// WIN32


/*****************************	CONTEXT_ENUM  ******************************/
/*
 * BUGBUG   Ideally, this should be derived from SERVER1_ENUM, but that
 *          class must first allow overriding the CallAPI method.
 */

/**********************************************************\

   NAME:       CONTEXT_ENUM::CONTEXT_ENUM

   SYNOPSIS:   CONTEXT_ENUM constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        AnirudhS    22-Mar-1995     Created

\**********************************************************/

CONTEXT_ENUM::CONTEXT_ENUM( ULONG        flServerType )
  : LOC_LM_ENUM( NULL, 1 ),     // server and info level
    _flServerType( flServerType )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

}  // CONTEXT_ENUM::CONTEXT_ENUM



/**********************************************************\

   NAME:       CONTEXT_ENUM::CallAPI

   SYNOPSIS:   server enum call api

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
        AnirudhS    22-Mar-1995     Created

\**********************************************************/

APIERR CONTEXT_ENUM::CallAPI( BYTE ** ppbBuffer,
			     UINT  * pcEntriesRead )
{
    UIASSERT( QueryInfoLevel() == 1 );	    // only level support at the time

    return ::MNetServerEnum( NULL,
			     SERVER_INFO_LEVEL( QueryInfoLevel() ),
			     ppbBuffer,
			     pcEntriesRead,
			     _flServerType,
			     NULL );

}  // CONTEXT_ENUM::CallAPI



/*******************************************************************

    NAME:	CONTEXT_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
        AnirudhS    22-Mar-1995     Created

********************************************************************/

VOID CONTEXT_ENUM_OBJ :: SetBufferPtr( const SERVER_INFO_101 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // CONTEXT_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( CONTEXT, SERVER_INFO_101 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoesvc.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoesvc.hxx
    This file contains the class declarations for the SERVICE_ENUM
    enumerator class and its associated iterator class.

    The SERVICE_ENUM class is used to enumerate the services installed
    on a target (possibly remote) server.

    NOTE:  This class uses the Win32 Service Control API.


    FILE HISTORY:
        KeithMo     17-Jan-1992     Created.
        KeithMo     31-Jan-1992     Changes from code review on 29-Jan-1992
                                    attended by ChuckC, EricCh, TerryK.
        KeithMo     04-Jun-1992     Handle NT & LM servers differently.
        KeithMo     11-Nov-1992     Added DisplayName goodies.

*/


#include "pchlmobj.hxx"

//
//  SERVICE_ENUM methods
//

/*******************************************************************

    NAME:           SERVICE_ENUM :: SERVICE_ENUM

    SYNOPSIS:       SERVICE_ENUM class constructor.

    ENTRY:          pszServerName       - The name of the server to execute
                                          the enumeration on.  NULL =
                                          execute locally.

                    fIsNtServer         - TRUE  if this is an NT server.
                                          FALSE if this is an LM server.

                    ServiceType         - Either SERVICE_WIN32 (for "normal"
                                          services or SERVICE_DRIVER (for
                                          drivers).

                    pszGroupName        - Service Order Group to limit enumeration
    EXIT:           The object is constructed.

    HISTORY:
        KeithMo     17-Jan-1992     Created.

********************************************************************/
SERVICE_ENUM :: SERVICE_ENUM( const TCHAR * pszServerName,
                              BOOL          fIsNtServer,
                              UINT          ServiceType,
                              const TCHAR * pszGroupName )
  : LOC_LM_ENUM( pszServerName, 0 ),
    _ServiceType( ServiceType ),
    _fIsNtServer( fIsNtServer ),
    _nlsGroupName( pszGroupName )
{
    UIASSERT( sizeof(ENUM_SVC_STATUS) <= sizeof(ENUM_SERVICE_STATUS) );
//    UIASSERT( (ServiceType == SERVICE_WIN32)||(ServiceType == SERVICE_DRIVER) );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }
    APIERR err = NERR_Success;
    if ((err = _nlsGroupName.QueryError()) != NERR_Success )
    {
        ReportError( err );
        return;
    }

}   // SERVICE_ENUM :: SERVICE_ENUM


/*******************************************************************

    NAME:           SERVICE_ENUM :: ~SERVICE_ENUM

    SYNOPSIS:       SERVICE_ENUM class destructor.

    EXIT:           The object is destroyed.

    HISTORY:
        KeithMo     17-Jan-1992     Created.

********************************************************************/
SERVICE_ENUM :: ~SERVICE_ENUM( VOID )
{
    //
    //  This space intentionally left blank.
    //

}   // SERVICE_ENUM :: ~SERVICE_ENUM


/*******************************************************************

    NAME:           SERVICE_ENUM :: CallAPI

    SYNOPSIS:       Invokes the EnumServicesStatus() API.

    ENTRY:          ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API is invoked.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     17-Jan-1992     Created.
        KeithMo     04-Jun-1992     Handle NT & LM servers differently.

********************************************************************/
APIERR SERVICE_ENUM :: CallAPI( BYTE ** ppbBuffer,
                                UINT  * pcEntriesRead )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( pcEntriesRead != NULL );

    return _fIsNtServer ? EnumNtServices( ppbBuffer, pcEntriesRead )
                        : EnumLmServices( ppbBuffer, pcEntriesRead );

}   // SERVICE_ENUM :: CallAPI


/*******************************************************************

    NAME:           SERVICE_ENUM :: EnumNtServices

    SYNOPSIS:       Enumerates the services on an NT server.

    ENTRY:          ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API is invoked.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     04-Jun-1992     Created.

********************************************************************/
APIERR SERVICE_ENUM :: EnumNtServices( BYTE ** ppbBuffer,
                                       UINT  * pcEntriesRead )
{
    //
    //  Connect to the service manager on the target server.
    //

    SC_MANAGER scman( QueryServer(),
                      GENERIC_READ | SC_MANAGER_ENUMERATE_SERVICE,
                      ACTIVE );

    LPENUM_SERVICE_STATUS pSvcStatus;
    APIERR err = scman.QueryError();

    if( err == NERR_Success )
    {
        //
        //  Enumerate the services.
        //

        err = scman.EnumServiceStatus( _ServiceType,
                                       SERVICE_ACTIVE | SERVICE_INACTIVE,
                                       &pSvcStatus,
                                       (DWORD *)pcEntriesRead,
                                       _nlsGroupName );
    }

    if( ( err == NERR_Success ) && ( *pcEntriesRead == 0 ) )
    {
        *ppbBuffer = NULL;
        return NERR_Success;
    }

    BYTE FAR * pbTmpBuffer;
    UINT cbBuffer;

    if( err == NERR_Success )
    {
        //
        //  Allocate a new buffer that the LM_ENUM destructor can
        //  successfully destroy.
        //
        //  CODEWORK:  We must allocate a buffer with MNetApiBufferAlloc
        //  because that's what LM_ENUM expects.  What we really need is
        //  to add a new virtual to LM_ENUM for destroying the API buffer.
        //  With such an addition, we could override the virtual in
        //  this class and destroy the buffer appropriately.
        //

        cbBuffer = scman.QueryBuffer().QuerySize();
        pbTmpBuffer = MNetApiBufferAlloc( cbBuffer );

        if( pbTmpBuffer == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Copy the data into the new buffer.
        //

        ::memcpyf( pbTmpBuffer,
                   pSvcStatus,
                   cbBuffer );

        //
        //  Map the ENUM_SERVICE_STATUS structures to ENUM_SVC_STATUS.
        //

        ENUM_SVC_STATUS     * pNewStatus = (ENUM_SVC_STATUS *)pbTmpBuffer;
        ENUM_SERVICE_STATUS * pOldStatus = (ENUM_SERVICE_STATUS *)pSvcStatus;

        for( UINT i = *pcEntriesRead ; i > 0 ; i-- )
        {
            //
            //  Cache the entries from the old structure in case
            //  it overlaps with the new structure.
            //

            //
            //  NOTE:  Since we copied the data, including strings, from
            //  the original API buffer to our newly allocated buffer,
            //  we must perform "fixups" on the string pointers.  This
            //  is the purpose of this first two somewhat elaborate
            //  assignments.
            //

            const TCHAR * pszServiceName =
                (const TCHAR *)( (const BYTE *)pbTmpBuffer +
                                 ( (const BYTE *)pOldStatus->lpServiceName -
                                   (const BYTE *)pSvcStatus ) );

            const TCHAR * pszDisplayName =
                (const TCHAR *)( (const BYTE *)pbTmpBuffer +
                                 ( (const BYTE *)pOldStatus->lpDisplayName -
                                   (const BYTE *)pSvcStatus ) );

            ULONG nCurrentState =
                (ULONG)pOldStatus->ServiceStatus.dwCurrentState;

            ULONG nControlsAccepted =
                (ULONG)pOldStatus->ServiceStatus.dwControlsAccepted;

            pNewStatus->pszServiceName    = pszServiceName;
            pNewStatus->pszDisplayName    = pszDisplayName;
            pNewStatus->nCurrentState     = nCurrentState;
            pNewStatus->nControlsAccepted = nControlsAccepted;

            SC_SERVICE scsvc( scman,
                              pszServiceName,
                              GENERIC_READ | SERVICE_QUERY_CONFIG );

            // if we cannot get to service, assume its disabled

            if (scsvc.QueryError() != NERR_Success)
                pNewStatus->nStartType = SERVICE_DISABLED;
            else
            {
                LPQUERY_SERVICE_CONFIG lpServiceConfig ;

                if (scsvc.QueryConfig(&lpServiceConfig) != NERR_Success)
                    pNewStatus->nStartType = SERVICE_DISABLED;
                else
                    pNewStatus->nStartType = (ULONG)lpServiceConfig->dwStartType;
            }

            pNewStatus++;
            pOldStatus++;
        }

        //
        //  Return the new buffer to LM_ENUM.
        //

        *ppbBuffer = pbTmpBuffer;
    }

    return err;

}   // SERVICE_ENUM :: EnumNtServices


/*******************************************************************

    NAME:           SERVICE_ENUM :: EnumLmServices

    SYNOPSIS:       Enumerates the services on an LM server.

    ENTRY:          ppbBuffer           - Pointer to a pointer to the
                                          enumeration buffer.

                    pcEntriesRead       - Will receive the number of
                                          entries read from the API.

    EXIT:           The enumeration API is invoked.

    RETURNS:        APIERR              - Any errors encountered.

    HISTORY:
        KeithMo     04-Jun-1992     Created.
        KeithMo     08-Sep-1992     Map "LanmanServer" -> "SERVER" et al.

********************************************************************/
APIERR SERVICE_ENUM :: EnumLmServices( BYTE ** ppbBuffer,
                                       UINT  * pcEntriesRead )
{
    UIASSERT( _ServiceType == SERVICE_WIN32 );

    //
    //  First off, we need to read LANMAN.INI to get the list
    //  of available services.
    //

    BYTE * pbCfgBuffer = NULL;

#if 1
    APIERR err = ::MNetConfigGetAll( QueryServer(),
                                     NULL,
                                     (TCHAR *)SECT_LM20_SERVICES,
                                     &pbCfgBuffer );
#else
    //
    //  BUGBUG!
    //
    //  At the time this code was written (04-Jun-1992) the
    //  NetConfigGetAll API had major UNICODE problems when
    //  remoted to downlevel servers.  As a temporary workaround,
    //  we'll use a hard-coded list of known services for downlevel
    //  servers.
    //

    TRACEEOL( "NetConfigGetAll doesn't work on downlevel servers." );
    TRACEEOL( "Using hard-coded service list." );

    const TCHAR * pchCannedNames =
SZ("WORKSTATION=wksta.exe\0SERVER=netsvini.exe\0MESSENGER=msrvinit.exe\0NETPOPUP=netpopup.exe\0ALERTER=alerter.exe\0NETRUN=runservr.exe\0REPLICATOR=replicat.exe\0UPS=ups.exe\0NETLOGON=netlogon.exe\0REMOTEBOOT=rplservr.exe\0TIMESOURCE=timesrc.exe\0\0");

#define SIZEOF_CANNED_NAME_LIST (332 * sizeof(TCHAR))   // must be accurate!!

    pbCfgBuffer = ::MNetApiBufferAlloc( SIZEOF_CANNED_NAME_LIST );

    APIERR err = ( pbCfgBuffer == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                         : NERR_Success;

    if( err == NERR_Success )
    {
        ::memcpyf( pbCfgBuffer,
                   pchCannedNames,
                   SIZEOF_CANNED_NAME_LIST );
    }
#endif

    if( err != NERR_Success )
    {
        return err;
    }

    //
    //  Count the number of services and the total *BYTE*
    //  count for the service names.
    //

    UINT cServices;
    UINT cbServiceNames;

    CountServices( pbCfgBuffer, &cServices, &cbServiceNames );

    //
    //  We now know how large our return buffer must be.  It
    //  should be (cServices*sizeof(ENUM_SVC_STATUS))+cbServiceNames.
    //  Note that this assumes that the services returned by
    //  NetConfigGetAll is always a superset of the services
    //  returned by NetServiceEnum.
    //

    UINT cbSvcStatus = cServices * sizeof(ENUM_SVC_STATUS);
    BYTE * pbSvcBuffer = ::MNetApiBufferAlloc( cbSvcStatus + cbServiceNames );

    if( pbSvcBuffer == NULL )
    {
        ::MNetApiBufferFree( &pbCfgBuffer );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //  We'll place the service names just past the last
    //  ENUM_SVC_STATUS structure.
    //

    TCHAR * pchServiceNames = (TCHAR *)( pbSvcBuffer + cbSvcStatus );

    ::memcpyf( pchServiceNames,
               pbCfgBuffer,
               cbServiceNames );

    //
    //  Now we can build our ENUM_SVC_STATUS structures.
    //  We'll assume that the services are stopped and only
    //  accept the start command (until proven otherwise).
    //  We'll also assume DisplayName == ServiceName.
    //

    ENUM_SVC_STATUS * pSvcStatus = (ENUM_SVC_STATUS *)pbSvcBuffer;

    for( UINT i = cServices ; i > 0 ; i-- )
    {
        pSvcStatus->pszServiceName    = pchServiceNames;
        pSvcStatus->pszDisplayName    = pchServiceNames;
        pSvcStatus->nCurrentState     = SERVICE_STOPPED;
        pSvcStatus->nControlsAccepted = SERVICE_ACCEPT_STOP;
        pSvcStatus->nStartType        = SERVICE_DEMAND_START;

        pSvcStatus++;
        pchServiceNames += ::strlenf( pchServiceNames ) + 1;
    }

    //
    //  Now that we're done with the configuration buffer
    //  we can kill it.
    //

    ::MNetApiBufferFree( &pbCfgBuffer );

    //
    //  Let's see if we can get the "real" services status.
    //

    struct service_info_1 * psvci1 = NULL;
    UINT   cLmServices;

    err = ::MNetServiceEnum( QueryServer(),
                             1,
                             (BYTE **)&psvci1,
                             &cLmServices );

    if( ( err == NERR_Success ) && ( cLmServices > cServices ) )
    {
        //
        //  BUGBUG!
        //
        //  In theory (yea, right) we should never receive
        //  more services from NetServiceEnum than we receive
        //  from NetConfigGetAll.  But, in the odd chance that
        //  we do, what do we do?  For now, I'll just pretend
        //  that it never happened...
        //

        TRACEEOL( "cLmServices > cServices??") ;
    }

    if( err != NERR_Success )
    {
        ::MNetApiBufferFree( &pbSvcBuffer );
        return err;
    }

    {
        //
        //  BUGBUG!  08-Sep-1992
        //
        //  Recent changes to the NetServiceXxx API cause the service
        //  names (on downlevel servers) to get mapped from the old names
        //  (such as "SERVER") to the new names (such as "LanmanServer").
        //  Unfortunately, the key names retrieved from NetConfigGetAll
        //  do *NOT* get mapped to the new names.  So, until the Net API
        //  group gets things fixed correctly, we'll map the new names
        //  back to the old names.
        //

        struct service_info_1 * psvci1Tmp = psvci1;

        for( UINT i = cLmServices ; i > 0 ; i-- )
        {
            //
            //  NOTE:  This code assumes that
            //         strlen(SERVICE_SERVER) >= strlen(SERVICE_LM20_SERVER).
            //

            if( ::stricmpf( (const TCHAR *)psvci1Tmp->svci1_name,
                            (const TCHAR *)SERVICE_SERVER ) == 0 )
            {
                ::strcpy( (TCHAR *)psvci1Tmp->svci1_name,
                          (TCHAR *)SERVICE_LM20_SERVER );
            }
            else
            if( ::stricmpf( (const TCHAR *)psvci1Tmp->svci1_name,
                            (const TCHAR *)SERVICE_WORKSTATION ) == 0 )
            {
                ::strcpy( (TCHAR *)psvci1Tmp->svci1_name,
                          (TCHAR *)SERVICE_LM20_WORKSTATION );
            }

            psvci1Tmp++;
        }
    }

    //
    //  Now that we have the NetConfig list and the NetService
    //  list, we can update the status of the services in the
    //  intersection of the two sets.
    //

    pSvcStatus = (ENUM_SVC_STATUS *)pbSvcBuffer;

    for( i = cServices ; i > 0 ; i-- )
    {
        struct service_info_1 * psvci1Tmp = psvci1;

        for( UINT j = cLmServices ; j > 0 ; j-- )
        {
            if( ::stricmpf( (const TCHAR *)pSvcStatus->pszServiceName,
                            (const TCHAR *)psvci1Tmp->svci1_name ) == 0 )
            {
                //
                //  We've got a match.  Update the state & control
                //  set to reflect reality.
                //

                MapLmStatusToNtState( psvci1Tmp->svci1_status,
                                      &pSvcStatus->nCurrentState,
                                      &pSvcStatus->nControlsAccepted );
                break;
            }

            psvci1Tmp++;
        }

        pSvcStatus++;
    }

    *ppbBuffer     = pbSvcBuffer;
    *pcEntriesRead = cServices;

    return NERR_Success;

}   // SERVICE_ENUM :: EnumLmServices



/*******************************************************************

    NAME:           SERVICE_ENUM :: CountServices

    SYNOPSIS:       Counts the services & total string counts in
                    a buffer returned from NetConfigGetAll for
                    the LanMan [Services] section.

    ENTRY:          pbBuffer            - Pointer to the NetConfigGetAll
                                          buffer.

                    pcServices          - Will receive the number of
                                          services in the buffer.

                    pcbServiceNames     - Will return the total number
                                          of *BYTES* necessary for all
                                          of the service names in the
                                          buffer.

    EXIT:           Initially, the configuration buffer will be of
                    the form:

                        SERVICE_NAME=PATH_TO_EXE\0SERVICE_NAME=
                        PATH_TO_EXE\0SERVICE_NAME=PATH_TO_EXE\0\0

                    After this routine completes, the buffer has been
                    rearranged slightly to be of the form:

                        SERVICE_NAME\0SERVICE_NAME\0SERVICE_NAME\0...

                    In other words, all of the paths to the service
                    executables have been removed from the buffer.

    HISTORY:
        KeithMo     04-Jun-1992     Created.

********************************************************************/
VOID SERVICE_ENUM :: CountServices( BYTE * pbBuffer,
                                    UINT * pcServices,
                                    UINT * pcbServiceNames )
{
    UIASSERT( pbBuffer != NULL );
    UIASSERT( pcServices != NULL );
    UIASSERT( pcbServiceNames != NULL );

    TCHAR * pchSrc = (TCHAR *)pbBuffer;
    TCHAR * pchDst = pchSrc;

    UINT cServices = 0;

    //
    //  Loop until we're out of strings.
    //

    while( *pchSrc != TCH('\0') )
    {
        //
        //  Scan for either the end of the current string, or
        //  the '=' separator.  We *should* always find the '='
        //  separator, but you never know...
        //

        TCHAR * pszSeparator = ::strchrf( pchSrc, TCH('=') );
        UINT cbSrc = ::strlenf( pchSrc );

        //
        //  If we found a separator, terminate the service
        //  name at the separator.
        //

        if( pszSeparator != NULL )
        {
            *pszSeparator = TCH('\0');
        }

        //
        //  Copy the service name to its new location.  This is
        //  done to "compact" the service names in the buffer.
        //

        ::strcpyf( pchDst, pchSrc );

        pchSrc += cbSrc + 1;
        pchDst += ::strlenf( pchDst ) + 1;

        cServices++;
    }

    *pcServices      = cServices;
    *pcbServiceNames = (UINT)((BYTE *)pchDst - pbBuffer);

}   // SERVICE_ENUM :: CountServices



/*******************************************************************

    NAME:           SERVICE_ENUM :: MapLmStatusToNtState

    SYNOPSIS:       Maps the service status returned by NetServiceEnum
                    to the NT State & ControlsAccepted values.

    ENTRY:          dwLmStatus          - The LM status from NetServiceEnum.

                    pnCurrentState      - Will receive the current state.

                    pnControlsAccepted  - Will receive a bitmask of
                                          valid controls this service
                                          will accept.

    HISTORY:
        KeithMo     04-Jun-1992     Created.
        KeithMo     20-Aug-1992     Fixed handling of paused state.

********************************************************************/
VOID SERVICE_ENUM :: MapLmStatusToNtState( DWORD   dwLmStatus,
                                           ULONG * pnCurrentState,
                                           ULONG * pnControlsAccepted )
{
    UIASSERT( pnCurrentState != NULL );
    UIASSERT( pnControlsAccepted != NULL );

    ULONG nCurrentState     = 0;
    ULONG nControlsAccepted = 0;

    switch( dwLmStatus & SERVICE_INSTALL_STATE )
    {
    case SERVICE_INSTALLED :
        nCurrentState = SERVICE_RUNNING;
        break;

    case SERVICE_UNINSTALLED :
        nCurrentState = SERVICE_STOPPED;
        break;

    case SERVICE_INSTALL_PENDING :
        nCurrentState = SERVICE_START_PENDING;
        break;

    case SERVICE_UNINSTALL_PENDING :
        nCurrentState = SERVICE_STOP_PENDING;
        break;
    }

    switch( dwLmStatus & SERVICE_PAUSE_STATE )
    {
    case LM20_SERVICE_PAUSED :
        nCurrentState = SERVICE_PAUSED;
        break;

    case LM20_SERVICE_CONTINUE_PENDING :
        nCurrentState = SERVICE_CONTINUE_PENDING;
        break;

    case LM20_SERVICE_PAUSE_PENDING :
        nCurrentState = SERVICE_PAUSE_PENDING;
        break;
    }

    if( dwLmStatus & SERVICE_UNINSTALLABLE )
    {
        nControlsAccepted |= SERVICE_CONTROL_STOP;
    }

    if( dwLmStatus & SERVICE_PAUSABLE )
    {
        nControlsAccepted |= SERVICE_CONTROL_PAUSE | SERVICE_CONTROL_CONTINUE;
    }

    *pnCurrentState     = nCurrentState;
    *pnControlsAccepted = nControlsAccepted;

}   // SERVICE_ENUM :: MapLmStatusToNtState



DEFINE_LM_ENUM_ITER_OF( SERVICE, ENUM_SVC_STATUS );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoetd.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoetd.cxx

    This file contains the class definitions for the TRUSTED_DOMAIN_ENUM
    class and its associated iterator classes.


    FILE HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

*/

#include "pchlmobj.hxx"


//
//  The manifest TOTAL_BYTES_REQUESTED gives the number of BYTEs we request
//  from the server on each call to the trusted domain enumeration API.
//

#define TOTAL_BYTES_REQUESTED   0x0001FFFF



//
//  TRUSTED_DOMAIN_ENUM methods.
//

/*******************************************************************

    NAME:       TRUSTED_DOMAIN_ENUM :: TRUSTED_DOMAIN_ENUM

    SYNOPSIS:   TRUSTED_DOMAIN_ENUM class constructor.

    ENTRY:      plsapolicy              - A pointer to a properly constructed
                                          LSA_POLICY object representing the
                                          target server (usually a PDC).

                fKeepBuffers            - If TRUE then LM_RESUME_ENUM
                                          will keep a list of all buffers
                                          created by CallAPI.

    HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

********************************************************************/
TRUSTED_DOMAIN_ENUM :: TRUSTED_DOMAIN_ENUM( const LSA_POLICY * plsapolicy,
                                            BOOL               fKeepBuffers )
  : LM_RESUME_ENUM( 0, fKeepBuffers ),
    _plsapolicy( plsapolicy ),
    _ResumeKey( (LSA_ENUMERATION_HANDLE)0 ),
    _lsatim()
{
    UIASSERT( plsapolicy != NULL );
    UIASSERT( plsapolicy->QueryError() == NERR_Success );

    //
    //  Ensure we constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_lsatim )
    {
        ReportError( _lsatim.QueryError() );
        return;
    }

}  // TRUSTED_DOMAIN_ENUM :: TRUSTED_DOMAIN_ENUM


/*******************************************************************

    NAME:       TRUSTED_DOMAIN_ENUM :: ~TRUSTED_DOMAIN_ENUM

    SYNOPSIS:   TRUSTED_DOMAIN_ENUM class destructor.

    HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

********************************************************************/
TRUSTED_DOMAIN_ENUM :: ~TRUSTED_DOMAIN_ENUM()
{
    NukeBuffers();

    _plsapolicy = NULL;
    _ResumeKey  = (LSA_ENUMERATION_HANDLE)0;

}   // TRUSTED_DOMAIN_ENUM :: ~TRUSTED_DOMAIN_ENUM()


/*******************************************************************

    NAME:       TRUSTED_DOMAIN_ENUM :: FreeBuffer

    SYNOPSIS:   Frees the enumeration buffer.

    ENTRY:      ppbBuffer               - Points to a pointer to the
                                          enumeration buffer.

    HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

********************************************************************/
VOID TRUSTED_DOMAIN_ENUM :: FreeBuffer( BYTE ** ppbBuffer )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( *ppbBuffer == (BYTE *)_lsatim.QueryPtr() );

    _lsatim.Set( NULL, 0 );
    *ppbBuffer = NULL;

}   // TRUSTED_DOMAIN_ENUM :: FreeBuffer


/*******************************************************************

    NAME:       TRUSTED_DOMAIN_ENUM :: CallAPI

    SYNOPSIS:   Invokes the LsaEnumerateTrustedDomains() API.

    ENTRY:      fRestartEnum            - If TRUE, then the enumeration
                                          handle should be reset to its
                                          starting position before invoking
                                          the API.

                ppbBuffer               - Points to a pointer to the
                                          buffer returned by the API.

                pcEntriesRead           - Will receive the number of
                                          enumeration entries read.

    RETURNS:    APIERR                  - Any errors encountered.

    HISTORY:
        KeithMo     09-Apr-1992     Created for the Server Manager.

********************************************************************/
APIERR TRUSTED_DOMAIN_ENUM :: CallAPI( BOOL    fRestartEnum,
                                       BYTE ** ppbBuffer,
                                       UINT  * pcEntriesRead )
{
    UIASSERT( ppbBuffer != NULL );
    UIASSERT( pcEntriesRead != NULL );

    if( fRestartEnum )
    {
        _ResumeKey = (LSA_ENUMERATION_HANDLE)0;
    }

    APIERR err = ((LSA_POLICY *) _plsapolicy)->EnumerateTrustedDomains(
                                                       &_lsatim,
                                                       &_ResumeKey,
                                                       TOTAL_BYTES_REQUESTED );

    if( ( err == NO_ERROR ) || ( err == ERROR_MORE_DATA ) )
    {
        *ppbBuffer     = (BYTE *)_lsatim.QueryPtr();
        *pcEntriesRead = (UINT)_lsatim.QueryCount();
    }

    return err;

}  // TRUSTED_DOMAIN_ENUM :: CallAPI


DEFINE_LM_RESUME_ENUM_ITER_OF( TRUSTED_DOMAIN, LSA_TRUST_INFORMATION );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoesrv3.cxx ===
/**********************************************************************/
/**                       Microsoft LAN Manager                      **/
/**             Copyright(c) Microsoft Corp., 1990, 1991             **/
/**********************************************************************/

/*
    lmoesrv3.hxx

    This file contains the class declarations for the TRIPLE_SERVER_ENUM
    class and its associated iterator classes.


    FILE HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.
        JonN        01-Apr-1992     Adjusted to changes in NT_MACHINE_ENUM
        JonN        07-Jul-1995     DeadPrimary appears even when !ALLOW_WKSTAS

*/

#include "pchlmobj.hxx"


//
//  Define some handy macros.
//

#define MY_PRIMARY_MASK    (SV_TYPE_DOMAIN_CTRL)
#define MY_BACKUP_MASK     (SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_SERVER)
#define MY_SERVER_MASK     (SV_TYPE_SERVER_NT)
#define MY_WKSTA_MASK      (SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL | SV_TYPE_SERVER_NT)

#define IS_WKSTA_TRUST(x)  (((x) & USER_WORKSTATION_TRUST_ACCOUNT) != 0)
#define IS_SERVER_TRUST(x) (((x) & USER_SERVER_TRUST_ACCOUNT) != 0)

#define IS_PRIMARY(x)      (((x) & MY_PRIMARY_MASK) == MY_PRIMARY_MASK)
#define IS_BACKUP(x)       (((x) & MY_BACKUP_MASK) == MY_BACKUP_MASK)
#define IS_SERVER(x)       (((x) & MY_SERVER_MASK) == MY_SERVER_MASK)
#define IS_WKSTA(x)        (((x) & MY_WKSTA_MASK) == 0)

#define IS_NT_SERVER(x)    (((x) & SV_TYPE_NT) != 0)
#define IS_WFW_SERVER(x)   (((x) & SV_TYPE_WFW) != 0)
#define IS_LM_SERVER(x)    (((x) & (SV_TYPE_NT | SV_TYPE_WFW)) == 0)
#define IS_WIN95_SERVER(x) (((x) & SV_TYPE_WINDOWS) != 0)

#define ALLOW_WKSTAS       (_fAllowWkstas == TRUE)
#define ALLOW_SERVERS      (_fAllowServers == TRUE)



//
//  TRIPLE_SERVER_ENUM methods.
//

/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: TRIPLE_SERVER_ENUM

    SYNOPSIS:   TRIPLE_SERVER_ENUM class constructor.

    ENTRY:      pszDomainName           - The name of the target domain.

                pszPrimaryName          - The name of the target domain's
                                          Primary controller.  If this
                                          parameter is NULL, then the
                                          PDC is assumed to be down.

    EXIT:       The object has been constructed.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
TRIPLE_SERVER_ENUM :: TRIPLE_SERVER_ENUM( const TCHAR * pszDomainName,
                                          const TCHAR * pszPrimaryName,
                                          BOOL          fIsNtPrimary,
                                          BOOL          fAllowWkstas,
                                          BOOL          fAllowServers,
                                          BOOL          fAccountsOnly )
  : LM_ENUM( 0 ),
    _pmach( NULL ),
    _puser( NULL ),
    _psrv( NULL ),
    _nlsDomainName( pszDomainName ),
    _nlsPrimaryName( pszPrimaryName ),
    _fIsNtPrimary( fIsNtPrimary ),
    _fAllowWkstas( fAllowWkstas ),
    _fAllowServers( fAllowServers ),
    _fAccountsOnly( fAccountsOnly ),
    _fPDCAvailable( pszPrimaryName != NULL ),
    _pszPrimaryNoWhacks( NULL )
{
    UIASSERT( pszDomainName != NULL );
    UIASSERT( fAllowWkstas | fAllowServers );

    //
    //  Ensure everything constructed properly.
    //

    if( QueryError() != NERR_Success )
    {
        return;
    }

    if( !_nlsDomainName )
    {
        ReportError( _nlsDomainName.QueryError() );
        return;
    }

    if( !_nlsPrimaryName )
    {
        ReportError( _nlsPrimaryName.QueryError() );
        return;
    }

    if( _fPDCAvailable )
    {
        //
        //  Get a pointer to the primary name without the
        //  leading backslashes.
        //

        ISTR istr( _nlsPrimaryName );
        istr += 2;

        _pszPrimaryNoWhacks = _nlsPrimaryName.QueryPch( istr );
    }

}   // TRIPLE_SERVER_ENUM :: TRIPLE_SERVER_ENUM


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: ~TRIPLE_SERVER_ENUM

    SYNOPSIS:   TRIPLE_SERVER_ENUM class destructor.

    EXIT:       The object has been destroyed.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
TRIPLE_SERVER_ENUM :: ~TRIPLE_SERVER_ENUM( VOID )
{
    delete _psrv;
    _psrv = NULL;

    delete _puser;
    _puser = NULL;

    delete _pmach;
    _pmach = NULL;

}   // TRIPLE_SERVER_ENUM :: ~TRIPLE_SERVER_ENUM


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CallAPI

    SYNOPSIS:   Invoke the necessary API(s) for the enumeration.

    ENTRY:      ppbBuffer               - Pointer to a pointer to
                                          the enumeration buffer.

                pcEntriesRead           - Will receive the number
                                          of enumeration entries read.

    RETURNS:    APIERR                  - Any error encountered.

    NOTES:      TRIPLE_SERVER_ENUM is rather unique among the LMOBJ
                enumerators in that it must invoke three separate
                API to retrieve the enumeration data.  Also, during
                the operation of the CallAPI() method, numerous
                buffers will be allocated and freed.  There are
                many places where errors may occur.  Thus, a single
                return status does little more than point the app
                in the general direction of the error.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
APIERR TRIPLE_SERVER_ENUM :: CallAPI( BYTE ** ppbBuffer,
                                      UINT  * pcEntriesRead )
{
    TRACEEOL( "In TRIPLE_SERVER_ENUM::CallAPI()" );

    //
    //  We'll need the following buffers.
    //

    BUFFER bufNtServers;
    BUFFER bufLmServers;
    BUFFER bufKnownServers;
    BUFFER bufBrowserServers;

    APIERR err = NERR_Success;

    if( ( ( err = bufNtServers.QueryError()      ) != NERR_Success ) ||
        ( ( err = bufLmServers.QueryError()      ) != NERR_Success ) ||
        ( ( err = bufKnownServers.QueryError()   ) != NERR_Success ) ||
        ( ( err = bufBrowserServers.QueryError() ) != NERR_Success ) )
    {
        return err;
    }

    //
    //  Various counters we'll need often.
    //

    UINT cNtServers      = 0;
    UINT cLmServers      = 0;
    UINT cKnownServers   = 0;
    UINT cBrowserServers = 0;
    UINT cAllServers     = 0;

    if( _fIsNtPrimary && _fPDCAvailable )
    {
        TRACEEOL( "Building NT Server List" );

#if FORCE_PDC
        //
        //  Setup a "fake" DOMAIN_DISPLAY_MACHINE for the PDC
        //  (in case we need to manually insert it in the list).
        //

        _ddm.Index          = 0L;   // not used
        _ddm.Rid            = 0L;   // not used
        _ddm.AccountControl = USER_SERVER_TRUST_ACCOUNT;
        _ddm.Comment.Buffer = NULL; // not used
        _ddm.Comment.Length = 0;    // not used
        _ddm.Machine.Buffer = (PWSTR)_pszPrimaryNoWhacks;
        _ddm.Machine.Length = _nlsPrimaryName.QueryTextSize() - (2*sizeof(TCHAR));
#endif  // FORCE_PDC

        //
        //  Create an ADMIN_AUTHORITY so we can connect to the
        //  Primary's SAM database.
        //

        ADMIN_AUTHORITY adminauth( _nlsPrimaryName.QueryPch() );

        err = adminauth.QueryError();

        if( err == NERR_Success )
        {
            //
            //  Create our NT enumerator.
            //

            _pmach = new NT_MACHINE_ENUM( adminauth.QueryAccountDomain() );

            err = ( _pmach == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : _pmach->GetInfo();
        }

        if( err == NERR_Success )
        {
            cNtServers = _pmach->QueryTotalItemCount();

            err = bufNtServers.Resize( ( cNtServers + 1 ) *
                                       sizeof(NT_MACHINE_ENUM_OBJ *) );
        }

        if( err == NERR_Success )
        {
            const DOMAIN_DISPLAY_MACHINE ** ppddm =
                    (const DOMAIN_DISPLAY_MACHINE **)bufNtServers.QueryPtr();

            const NT_MACHINE_ENUM_OBJ * pobj;
            NT_MACHINE_ENUM_ITER iter( *_pmach );

#if FORCE_PDC
            BOOL fPDCInList = FALSE;
#endif  // FORCE_PDC

            while( ( pobj = iter( &err ) ) != NULL )
            {
                if( ( ALLOW_WKSTAS && IS_WKSTA_TRUST( pobj->QueryAccountCtrl() ) ) ||
                    ( ALLOW_SERVERS && IS_SERVER_TRUST( pobj->QueryAccountCtrl() ) ) )
                {
                    *ppddm++ = pobj->QueryBufferPtr();

                    //
                    //  Strip the trailing '$' from the machine name.
                    //

                    TCHAR * pchName = (TCHAR *)pobj->QueryUnicodeMachine()->Buffer;
                    TCHAR * pchTmp  = pchName
                                      + ( pobj->QueryUnicodeMachine()->Length /
                                          sizeof(TCHAR) )
                                      - 1;

                    UIASSERT( *pchTmp == TCH('$') );
                    *pchTmp = TCH('\0');

#if FORCE_PDC
                    if( IS_SERVER_TRUST( pObj->QueryAccountCtrl() ) &&
                        ALLOW_SERVERS &&
                        !fPDCInList )
                    {
                        //
                        //  We're allowing servers, and the PDC is not
                        //  yet in the list.
                        //
                        //  See if the current enumeration object *is*
                        //  the PDC.
                        //

                        INT cmp = ::strcmpf( _pszPrimaryNoWhacks, pchName );

                        if( cmp == 0 )
                        {
                            //
                            //  This is the PDC, therefore it's already
                            //  in the list.
                            //

                            fPDCInList = TRUE;
                        }
                        else
                        if( cmp < 0 )
                        {
                            //
                            //  The current enum object is > than the PDC,
                            //  so we know it *isn't* in the list.  So
                            //  add it.
                            //

                            *ppddm++ = &_ddm;
                            cNtServers++;
                            fPDCInList = TRUE;
                        }
                    }
#endif  // FORCE_PDC

                }
                else
                {
                    cNtServers--;
                }
            }

#if FORCE_PDC
            if( ALLOW_SERVERS && !fPDCInList )
            {
                //
                //  The PDC was not in the list, so add it.
                //
                //  This is necessary for cases in which the PDC should
                //  be the *last* machine account returned from SAM.
                //

                *ppddm++ = &_ddm;
                cNtServers++;
                fPDCInList = TRUE;
            }
#endif  // FORCE_PDC

        }

        if( err == NERR_Success )
        {
            ::qsort( (void *)bufNtServers.QueryPtr(),
                     (size_t)cNtServers,
                     sizeof(DOMAIN_DISPLAY_MACHINE *),
                     &TRIPLE_SERVER_ENUM::CompareNtServers );
        }
    }

    if( ALLOW_SERVERS && _fPDCAvailable )
    {
        //
        //  Create our LM enumerator.
        //

        TRACEEOL( "Building LM Server List" );

        if( err == NERR_Success )
        {
            _puser = new USER0_ENUM( _nlsPrimaryName.QueryPch(),
                                     SZ("SERVERS"), TRUE );

            err = ( _puser == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                     : _puser->GetInfo();
        }

        if( err == NERR_GroupNotFound )
        {
            //
            //  If the group doesn't exist, then there obviously
            //  aren't any servers in the group.  Just pretend
            //  that it never happened.
            //

            err = NERR_Success;
        }
        else
        {
            if( err == NERR_Success )
            {
                cLmServers = _puser->QueryTotalItemCount();

                err = bufLmServers.Resize( cLmServers * sizeof(USER0_ENUM_OBJ *) );
            }

            if( err == NERR_Success )
            {
                const struct user_info_0 ** ppui0 =
                        (const struct user_info_0 **)bufLmServers.QueryPtr();

                const USER0_ENUM_OBJ * pobj;
                USER0_ENUM_ITER iter( *_puser );

                while( ( pobj = iter( &err ) ) != NULL )
                {
                    if ( err != NERR_Success )
                        break;

                    *ppui0 = pobj->QueryBufferPtr();

                    TCHAR * pszTmp = (TCHAR *)(*ppui0)->usri0_name;

                    REQUIRE( ::I_MNetNameCanonicalize(
                                    NULL,
                                    pszTmp,
                                    pszTmp,
                                    ( ::strlenf( pszTmp ) + 1 ) * sizeof(TCHAR),
                                    NAMETYPE_COMPUTER,
                                    0 ) == NERR_Success );

                    ppui0++;
                }
            }

            if( err == NERR_Success )
            {
                ::qsort( (void *)bufLmServers.QueryPtr(),
                         (size_t)cLmServers,
                         sizeof(struct user_info_0 *),
                         &TRIPLE_SERVER_ENUM::CompareLmServers );
            }
        }
    }

    //
    //  Merge the NT servers and LM servers into the Known Servers list.
    //

    TRACEEOL( "Merging NT and LM Server List into Known Server List" );

    if( err == NERR_Success )
    {
        cKnownServers = cNtServers + cLmServers;

        err = bufKnownServers.Resize( cKnownServers * sizeof(KNOWN_SERVER_INFO) );
    }

    if( err == NERR_Success )
    {
        const DOMAIN_DISPLAY_MACHINE ** ppddm =
                (const DOMAIN_DISPLAY_MACHINE **)bufNtServers.QueryPtr();

        const struct user_info_0 ** ppui0 =
                (const struct user_info_0 **)bufLmServers.QueryPtr();

        KNOWN_SERVER_INFO * pKnown =
                (KNOWN_SERVER_INFO *)bufKnownServers.QueryPtr();

        UINT cNtTmp = cNtServers;
        UINT cLmTmp = cLmServers;

        while( ( cNtTmp > 0 ) || ( cLmTmp > 0 ) )
        {
            if( cNtTmp == 0 )
            {
                MapLmToKnown( *ppui0++, pKnown++ );
                cLmTmp--;
            }
            else
            if( cLmTmp == 0 )
            {
                MapNtToKnown( *ppddm++, pKnown++ );
                cNtTmp--;
            }
            else
            {
                NT_MACHINE_ENUM_OBJ NtObj;
                NtObj.SetBufferPtr( *ppddm );

                USER0_ENUM_OBJ LmObj;
                LmObj.SetBufferPtr( *ppui0 );

                INT result =
                       ::strcmpf( (TCHAR *)NtObj.QueryUnicodeMachine()->Buffer,
                                  LmObj.QueryName() );

                if( result < 0 )
                {
                    MapNtToKnown( *ppddm++, pKnown++ );
                    cNtTmp--;
                }
                else
                if( result > 0 )
                {
                    MapLmToKnown( *ppui0++, pKnown++ );
                    cLmTmp--;
                }
                else
                {
                    //
                    //  The same machine is in the SAM list *and*
                    //  the SERVERS group.  This probably indicates
                    //  the machine dual-boots NT and OS/2.  We'll
                    //  assume it's NT unless the browser indicates
                    //  otherwise.
                    //

                    MapNtToKnown( *ppddm++, pKnown++ );
                    cNtTmp--;
                    ppui0++;
                    cLmTmp--;
                    cKnownServers--;
                }
            }
        }
    }

    //
    //  We've finally got a list of known servers.  Now we
    //  can enumerate from the Browser and sort that list.
    //

    TRACEEOL( "Building BROWSER Server List" );

    if( err == NERR_Success && !_fAccountsOnly )
    {
        ULONG flServerTypes = SV_TYPE_ALL;

#if 0
        //
        //  This was a good idea; unfortunately, it won't
        //  pick up non-DC LM Servers.
        //

        if( ALLOW_SERVERS && !ALLOW_WKSTAS )
        {
            flServerTypes = SV_TYPE_DOMAIN_CTRL | SV_TYPE_DOMAIN_BAKCTRL;
        }
        else
        {
            flServerTypes = SV_TYPE_ALL;
        }
#endif

        _psrv = new SERVER1_ENUM( NULL,
                                  _nlsDomainName.QueryPch(),
                                  flServerTypes );

        err = ( _psrv == NULL ) ? ERROR_NOT_ENOUGH_MEMORY
                                : _psrv->GetInfo();

        if( err == NERR_Success )
        {
            cBrowserServers = _psrv->QueryCount();
            err = bufBrowserServers.Resize( cBrowserServers *
                                                sizeof(SERVER1_ENUM_OBJ *) );
        }
        else
        {
            //
            //  NetServerEnum failed.
            //

            cBrowserServers = 0;
            err = NERR_Success;
        }
    }

    if( ( err == NERR_Success ) && ( cBrowserServers > 0 ) )
    {
        const struct server_info_1 ** ppsi1 =
                (const struct server_info_1 **)bufBrowserServers.QueryPtr();

        const SERVER1_ENUM_OBJ * pobj;
        SERVER1_ENUM_ITER iter( *_psrv );

        while( ( pobj = iter() ) != NULL )
        {
            ULONG TypeMask = pobj->QueryServerType();

            //
            // JonN 7/6/95:  Note that we allow workstations to slip through
            // into the browser list even if !ALLOW_WKSTAS.  This is because
            // a "DeadPrimary" machine will register as a workstation to the
            // browser and we still want to be able to identify it as a
            // DeadPrimary.
            //
            if( ( IS_WKSTA( TypeMask ) && !IS_LM_SERVER( TypeMask ) ) ||
                ( ALLOW_SERVERS && IS_LM_SERVER( TypeMask ) ) ||
                ( ALLOW_SERVERS && IS_BACKUP( TypeMask ) ) ||
                ( ALLOW_SERVERS && IS_SERVER( TypeMask ) ) ||
                ( ALLOW_SERVERS && IS_PRIMARY( TypeMask ) ) )
            {
                *ppsi1++ = pobj->QueryBufferPtr();
            }
            else
            {
                cBrowserServers--;
            }
        }
    }

    if( ( err == NERR_Success ) && ( cBrowserServers > 0 ) )
    {
        ::qsort( (void *)bufBrowserServers.QueryPtr(),
                 (size_t)cBrowserServers,
                 sizeof(struct server_info_1 *),
                 &TRIPLE_SERVER_ENUM::CompareBrowserServers );
    }

    //
    //  Now (finally...) merge the known servers list with the
    //  browser server list.
    //

    TRACEEOL( "Merging Known Server and BROWSER Lists into ALL Server List" );

    TRIPLE_SERVER_INFO * p3srv;

    if( err == NERR_Success )
    {
        cAllServers = cKnownServers + cBrowserServers;

        if( cAllServers > 0 )
        {
            p3srv = (TRIPLE_SERVER_INFO *)
                        ::MNetApiBufferAlloc( cAllServers *
                                              sizeof(TRIPLE_SERVER_INFO) );

            if( p3srv == NULL )
            {
                err = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            p3srv = NULL;
        }
    }

    if( err == NERR_Success )
    {
        //
        //  Return the buffer pointer to LM_ENUM.
        //

        *ppbBuffer = (BYTE *)p3srv;

        const struct server_info_1 ** ppsi1 =
                (const struct server_info_1 **)bufBrowserServers.QueryPtr();

        KNOWN_SERVER_INFO * pKnown =
                (KNOWN_SERVER_INFO *)bufKnownServers.QueryPtr();

        UINT cKnownTmp   = cKnownServers;
        UINT cBrowserTmp = cBrowserServers;

        while( ( cKnownTmp > 0 ) || ( cBrowserTmp > 0 ) )
        {
            if( cBrowserTmp == 0 )
            {
                MapKnownToTriple( pKnown, p3srv );
                p3srv++;
                pKnown++;
                cKnownTmp--;
            }
            else
            if( cKnownTmp == 0 )
            {
                //
                // JonN 7/6/95:  Note that we allow workstations to slip through
                // into the browser list even if !ALLOW_WKSTAS.  This is because
                // a "DeadPrimary" machine will register as a workstation to the
                // browser and we still want to be able to identify it as a
                // DeadPrimary.
                // We repeat the validity test here since the machine cannot be
                // a DeadMachineCandidate since no known server was found.
                //

                ULONG TypeMask = (*ppsi1)->sv1_type;

                if( ( ALLOW_WKSTAS && IS_WKSTA( TypeMask ) && !IS_LM_SERVER( TypeMask ) ) ||
                    ( ALLOW_SERVERS && IS_LM_SERVER( TypeMask ) ) ||
                    ( ALLOW_SERVERS && IS_BACKUP( TypeMask ) ) ||
                    ( ALLOW_SERVERS && IS_SERVER( TypeMask ) ) ||
                    ( ALLOW_SERVERS && IS_PRIMARY( TypeMask ) ) )
                {
                    MapBrowserToTriple( *ppsi1, p3srv );
                    p3srv++;
                }
                else
                {
                    cAllServers--;
                }
                ppsi1++;
                cBrowserTmp--;
            }
            else
            {
                SERVER1_ENUM_OBJ ServerObj;
                ServerObj.SetBufferPtr( *ppsi1 );

                INT result = ::strcmpf( pKnown->pszName, ServerObj.QueryName() );

                if( result < 0 )
                {
                    MapKnownToTriple( pKnown, p3srv );
                    p3srv++;
                    pKnown++;
                    cKnownTmp--;
                }
                else
                if( result > 0 )
                {
                    //
                    // JonN 7/6/95:  Note that we allow workstations to slip through
                    // into the browser list even if !ALLOW_WKSTAS.  This is because
                    // a "DeadPrimary" machine will register as a workstation to the
                    // browser and we still want to be able to identify it as a
                    // DeadPrimary.
                    // We repeat the validity test here since the machine cannot be
                    // a DeadMachineCandidate since no known server was found.
                    //

                    ULONG TypeMask = (*ppsi1)->sv1_type;

                    if( ( ALLOW_WKSTAS && IS_WKSTA( TypeMask ) && !IS_LM_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_LM_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_BACKUP( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_PRIMARY( TypeMask ) ) )
                    {
                        MapBrowserToTriple( *ppsi1, p3srv );
                        p3srv++;
                    }
                    else
                    {
                        cAllServers--;
                    }
                    ppsi1++;
                    cBrowserTmp--;
                }
                else
                {
                    //
                    // JonN 7/6/95:  Note that we allow workstations to slip through
                    // into the browser list even if !ALLOW_WKSTAS.  This is because
                    // a "DeadPrimary" machine will register as a workstation to the
                    // browser and we still want to be able to identify it as a
                    // DeadPrimary.
                    // We repeat the validity test here and remove the tripleobj
                    // retroactively if the browser object is invalid and
                    // the tripleobj is not a DeadMachine.
                    //

                    ULONG TypeMask = (*ppsi1)->sv1_type;

                    CombineIntoTriple( *ppsi1++, pKnown, p3srv );
                    cBrowserTmp--;
                    cAllServers--;
                    if( ( ALLOW_WKSTAS && IS_WKSTA( TypeMask ) && !IS_LM_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_LM_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_BACKUP( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_SERVER( TypeMask ) ) ||
                        ( ALLOW_SERVERS && IS_PRIMARY( TypeMask ) ) ||
                        (      p3srv->ServerRole == DeadPrimaryRole
                            || p3srv->ServerRole == DeadBackupRole  ) )
                    {
                        // Either the browser object was valid, or the
                        // machine is DeadPrimary or DeadBackup.  Leave the
                        // tripleobj alone.
                    }
                    else
                    {
                        // The browser object was invalid and the machine
                        // is neither a DeadPrimary nor DeadBackup.  Remap
                        // the tripleobj using just the KNOWN_SERVER_INFO.

                        MapKnownToTriple( pKnown, p3srv );
                    }
                    pKnown++;
                    cKnownTmp--;
                    p3srv++;
                }
            }
        }
    }

    if( err == NERR_Success )
    {
        *pcEntriesRead = cAllServers;
    }

    return err;

}   // TRIPLE_SERVER_ENUM :: CallAPI


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapNtToKnown

    SYNOPSIS:   Takes a DOMAIN_DISPLAY_MACHINE and maps the appropriate
                fields to KNOWN_SERVER_INFO.

    ENTRY:      pddm                    - Points to a DOMAIN_DISPLAY_MACHINE
                                          representing the source server.

                pKnownObj               - Points to a KNOWN_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: MapNtToKnown(
                                    const DOMAIN_DISPLAY_MACHINE * pddm,
                                    KNOWN_SERVER_INFO            * pKnownObj )
{
    NT_MACHINE_ENUM_OBJ NtObj;
    NtObj.SetBufferPtr( pddm );

    //
    //  Migrate the various fields across.
    //

    pKnownObj->pszName    = (TCHAR *)(NtObj.QueryUnicodeMachine()->Buffer);
    pKnownObj->ServerType = InactiveNtServerType;

    //
    //  To determine if the source server is a primary, we must
    //  compare its name with the name of the primary for this
    //  domain.
    //

    BOOL fIsPrimary = FALSE;

    if( _fPDCAvailable )
    {
        fIsPrimary = ( ::strcmpf( (TCHAR *)NtObj.QueryUnicodeMachine()->Buffer,
                                  _pszPrimaryNoWhacks ) ) == 0;
    }

    if( fIsPrimary )
    {
        pKnownObj->ServerRole = PrimaryRole;
    }
    else
    if( IS_WKSTA_TRUST( NtObj.QueryAccountCtrl() ) )
    {
        pKnownObj->ServerRole = WkstaOrServerRole;
    }
    else
    if( IS_SERVER_TRUST( NtObj.QueryAccountCtrl() ) )
    {
        pKnownObj->ServerRole = BackupRole;
    }
    else
    {
        pKnownObj->ServerRole = UnknownRole;
    }

}   // TRIPLE_SERVER_ENUM :: MapNtToKnown


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapLmToKnown

    SYNOPSIS:   Takes a user_info_0 and maps the appropriate
                fields to KNOWN_SERVER_INFO.

    ENTRY:      pui0                    - Points to a user_info_0 structure
                                          representing the source server.

                pKnownObj               - Points to a KNOWN_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: MapLmToKnown(
                                    const struct user_info_0 * pui0,
                                    KNOWN_SERVER_INFO        * pKnownObj )
{
    USER0_ENUM_OBJ LmObj;
    LmObj.SetBufferPtr( pui0 );

    pKnownObj->pszName    = LmObj.QueryName();
    pKnownObj->ServerType = InactiveLmServerType;
    pKnownObj->ServerRole = BackupRole;

}   // TRIPLE_SERVER_ENUM :: MapLmToKnown


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapKnownToTriple

    SYNOPSIS:   Takes a KNOWN_SERVER_INFO and maps the appropriate
                fields to TRIPLE_SERVER_INFO

    ENTRY:      pKnownObj               - Points to a KNOWN_SERVER_INFO
                                          representing the source server.

                pTripleObj              - Points to a TRIPLE_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: MapKnownToTriple(
                                    const KNOWN_SERVER_INFO * pKnownObj,
                                    TRIPLE_SERVER_INFO      * pTripleObj )
{
    SERVER_ROLE role = pKnownObj->ServerRole;
    SERVER_TYPE type = pKnownObj->ServerType;

    if( _fPDCAvailable &&
        ( role != PrimaryRole ) &&
        ( ::strcmpf( _pszPrimaryNoWhacks, pKnownObj->pszName ) == 0 ) )
    {
        //
        //  The role for this known server was *not* Primary,
        //  but its name matches the name of the domain's PDC.
        //  Therefore, it must be the primary.
        //

        role = PrimaryRole;
    }

    if( ( role == PrimaryRole ) && _fPDCAvailable )
    {
        //
        //  Compensate for one of the NT Browser's
        //  many inadequacies...
        //

        if( type == InactiveNtServerType )
        {
            type = ActiveNtServerType;
        }
        else
        if( type == InactiveLmServerType )
        {
            type = ActiveLmServerType;
        }
    }

    pTripleObj->pszName    = pKnownObj->pszName;
    pTripleObj->pszComment = SZ("");
    pTripleObj->ServerType = type;
    pTripleObj->ServerRole = role;
    pTripleObj->verMajor   = 0;
    pTripleObj->verMinor   = 0;
    pTripleObj->TypeMask   = 0L;

}   // TRIPLE_SERVER_ENUM :: MapKnownToTriple


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapBrowserToTriple

    SYNOPSIS:   Takes a server_info_1 and maps the appropriate
                fields to TRIPLE_SERVER_INFO

    ENTRY:      psi1                    - Points to a server_info_1 structure
                                          representing the source server.

                pTripleObj              - Points to a TRIPLE_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: MapBrowserToTriple(
                                    const struct server_info_1 * psi1,
                                    TRIPLE_SERVER_INFO         * pTripleObj )
{
    SERVER1_ENUM_OBJ ServerObj;
    ServerObj.SetBufferPtr( psi1 );

    ULONG TypeMask = ServerObj.QueryServerType();

    pTripleObj->pszName    = ServerObj.QueryName();
    pTripleObj->pszComment = ServerObj.QueryComment();
    pTripleObj->verMajor   = ServerObj.QueryMajorVer();
    pTripleObj->verMinor   = ServerObj.QueryMinorVer();
    pTripleObj->TypeMask   = TypeMask;

    pTripleObj->ServerType = MapTypeMaskToType( TypeMask );
    pTripleObj->ServerRole = MapTypeMaskToRole( TypeMask );

    if( _fPDCAvailable &&
        ( ::strcmpf( _pszPrimaryNoWhacks, pTripleObj->pszName ) == 0 ) )
    {
        //
        //  This is the PDC.  Ensure the other data is set correctly.
        //

        pTripleObj->ServerRole  = PrimaryRole;
        pTripleObj->TypeMask   &= ~SV_TYPE_DOMAIN_BAKCTRL;
        pTripleObj->TypeMask   |=  SV_TYPE_DOMAIN_CTRL;
    }
    else
    {
        if( pTripleObj->ServerRole == PrimaryRole )
        {
            //
            //  The browser has told us that this machine is
            //  a primary, but we *know* it isn't.  Either the
            //  PDC is not available, or the names don't match.
            //  This generally indicates that the browser is
            //  giving us stale data.  In any case, this machine
            //  is definitely *not* the real PDC.  We'll assume
            //  it's a Server.
            //

            pTripleObj->ServerRole  = BackupRole;
            pTripleObj->TypeMask   &= ~SV_TYPE_DOMAIN_CTRL;
            pTripleObj->TypeMask   |=  SV_TYPE_DOMAIN_BAKCTRL;
        }
    }

}   // TRIPLE_SERVER_ENUM :: MapBrowserToTriple


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CombineIntoTriple

    SYNOPSIS:   Takes a server_info_1 and a KNOWN_SERVER_INFO and
                maps the appropriate fields to TRIPLE_SERVER_INFO

    ENTRY:      psi1                    - Points to a server_info_1 structure
                                          representing the source server.

                pKnownObj               - Points to a KNOWN_SERVER_INFO
                                          also representing the source
                                          server.

                pTripleObj              - Points to a TRIPLE_SERVER_INFO
                                          representing the destination.

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
VOID TRIPLE_SERVER_ENUM :: CombineIntoTriple(
                                    const struct server_info_1 * psi1,
                                    const KNOWN_SERVER_INFO    * pKnownObj,
                                    TRIPLE_SERVER_INFO         * pTripleObj )
{
    //
    //  We'll let MapBrowserToTriple do most of the grunt work.
    //

    MapBrowserToTriple( psi1, pTripleObj );

    BOOL fDeadMachineCandidate = FALSE; // until proven otherwise

    if( _fIsNtPrimary && _fPDCAvailable &&
        IS_NT_SERVER( pTripleObj->TypeMask ) )
    {
        //
        //  Determine if this is a "dead" primary or server.
        //

        if( ( pKnownObj->ServerRole == BackupRole ) &&
            IS_WKSTA( pTripleObj->TypeMask ) )
        {
            //
            //  The machine had a SAM server trust account, but
            //  is broadcasting like a workstation.  This indicates
            //  that the machine is setup as a primary or server, but
            //  its NETLOGON service is not running.  It might be
            //  a dead primary or server.
            //

            fDeadMachineCandidate = TRUE;
        }
    }

    if( fDeadMachineCandidate )
    {
        //
        //  We've found a system that might be a dead primary or server.
        //  To verify, we'll query the machines domain role.
        //  If the role is primary, then we've found a dead one.
        //

        //
        //  CODEWORK:  We need LMOBJ support for this!
        //

        ISTACK_NLS_STR( nlsUNC, MAX_PATH, SZ("\\\\") );
        UIASSERT( !!nlsUNC );
        ALIAS_STR nlsBare( pTripleObj->pszName );
        UIASSERT( !!nlsBare );
        nlsUNC.strcat( nlsBare );
        UIASSERT( !!nlsUNC );

        struct user_modals_info_1 * pumi1 = NULL;

        //
        //  Setup a (potentially NULL) session to the target
        //  server.  This will be necessary if the NetLogon
        //  service is not running on the target server.
        //

        API_SESSION apisess( nlsUNC );

        APIERR err = apisess.QueryError();

        if( err == NERR_Success )
        {
            err = ::MNetUserModalsGet( nlsUNC, 1, (BYTE **)&pumi1 );
        }

        if( err == NERR_Success )
        {
            if( pumi1->usrmod1_role == UAS_ROLE_PRIMARY )
            {
                //
                //  It's a dead primary.
                //

                pTripleObj->ServerRole = DeadPrimaryRole;
            }
            else
            if( pumi1->usrmod1_role == UAS_ROLE_BACKUP )
            {
                //
                //  It's a dead server.
                //

                pTripleObj->ServerRole = DeadBackupRole;
            }

            //
            //  Free the API buffer.
            //

            ::MNetApiBufferFree( (BYTE **)&pumi1 );
        }
    }

}   // TRIPLE_SERVER_ENUM :: CombineIntoTriple


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CompareNtServers

    SYNOPSIS:   This static method is called by the ::qsort() standard
                library function.  This method will compare two
                NT_MACHINE_ENUM_OBJ objects.

    ENTRY:      p1                      - The "left" object.

                p2                      - The "right" object.

    RETURNS:    int                     - -1 if p1  < p2
                                           0 if p1 == p2
                                          +1 if p1  > p2

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
int __cdecl TRIPLE_SERVER_ENUM :: CompareNtServers( const void * p1,
                                                     const void * p2 )
{
    NT_MACHINE_ENUM_OBJ Obj1;
    NT_MACHINE_ENUM_OBJ Obj2;

    Obj1.SetBufferPtr( *((const DOMAIN_DISPLAY_MACHINE **)p1) );
    Obj2.SetBufferPtr( *((const DOMAIN_DISPLAY_MACHINE **)p2) );

    //
    //  We can use the UNICODE machine name since it's already
    //  been NULL terminated.
    //

    return ::strcmpf( (TCHAR *)Obj1.QueryUnicodeMachine()->Buffer,
                      (TCHAR *)Obj2.QueryUnicodeMachine()->Buffer );

}   // TRIPLE_SERVER_ENUM :: CompareNtServers


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CompareLmServers

    SYNOPSIS:   This static method is called by the ::qsort() standard
                library function.  This method will compare two
                USER0_ENUM_OBJ objects.

    ENTRY:      p1                      - The "left" object.

                p2                      - The "right" object.

    RETURNS:    int                     - -1 if p1  < p2
                                           0 if p1 == p2
                                          +1 if p1  > p2

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
int __cdecl TRIPLE_SERVER_ENUM :: CompareLmServers( const void * p1,
                                                     const void * p2 )
{
    USER0_ENUM_OBJ Obj1;
    USER0_ENUM_OBJ Obj2;

    Obj1.SetBufferPtr( *((const struct user_info_0 **)p1) );
    Obj2.SetBufferPtr( *((const struct user_info_0 **)p2) );

    return ::strcmpf( Obj1.QueryName(), Obj2.QueryName() );

}   // TRIPLE_SERVER_ENUM :: CompareLmServers


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: CompareBrowserServers

    SYNOPSIS:   This static method is called by the ::qsort() standard
                library function.  This method will compare two
                SERVER1_ENUM_OBJ objects.

    ENTRY:      p1                      - The "left" object.

                p2                      - The "right" object.

    RETURNS:    int                     - -1 if p1  < p2
                                           0 if p1 == p2
                                          +1 if p1  > p2

    HISTORY:
        KeithMo     17-Mar-1992     Created for the Server Manager.

********************************************************************/
int __cdecl TRIPLE_SERVER_ENUM :: CompareBrowserServers( const void * p1,
                                                          const void * p2 )
{
    SERVER1_ENUM_OBJ Obj1;
    SERVER1_ENUM_OBJ Obj2;

    Obj1.SetBufferPtr( *((const struct server_info_1 **)p1) );
    Obj2.SetBufferPtr( *((const struct server_info_1 **)p2) );

    return ::strcmpf( Obj1.QueryName(), Obj2.QueryName() );

}   // TRIPLE_SERVER_ENUM :: CompareBrowserServers


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapTypeMaskToRole

    SYNOPSIS:   Maps a server type mask (such as return from the
                browser) to a SERVER_ROLE enum.

    ENTRY:      TypeMask                - The server type mask.

    RETURNS:    SERVER_ROLE             - The role represented by the mask.

    HISTORY:
        KeithMo     05-Oct-1992     Created.

********************************************************************/
SERVER_ROLE TRIPLE_SERVER_ENUM :: MapTypeMaskToRole( ULONG TypeMask ) const
{
    SERVER_ROLE role;

    if( IS_WFW_SERVER( TypeMask ) )
    {
        //
        //  Winball machines are always workstations.
        //

        role = WkstaRole;
    }
    else
    if( IS_PRIMARY( TypeMask ) )
    {
        //
        //  A primary is a primary is a primary.
        //

        role = PrimaryRole;
    }
    else
    if( ( TypeMask & SV_TYPE_DOMAIN_BAKCTRL ) )
    {
        role = BackupRole;
    }
    else
    if ( IS_SERVER( TypeMask ) )
    {
        role = ServerRole;
    }
    else
    if( IS_LM_SERVER( TypeMask ) )
    {
        //
        //  All LanMan machines that isn't a BDC.
        //

        role = LmServerRole;
    }
    else
    {
        //
        //  Everything else is just a workstation.
        //

        role = WkstaRole;
    }

    return role;

}   // TRIPLE_SERVER_ENUM :: MapTypeMaskToRole


/*******************************************************************

    NAME:       TRIPLE_SERVER_ENUM :: MapTypeMaskToType

    SYNOPSIS:   Maps a server type mask (such as return from the
                browser) to a SERVER_TYPE enum.

    ENTRY:      TypeMask                - The server type mask.

    RETURNS:    SERVER_TYPE             - The role represented by the mask.

    HISTORY:
        KeithMo     05-Oct-1992     Created.

********************************************************************/
SERVER_TYPE TRIPLE_SERVER_ENUM :: MapTypeMaskToType( ULONG TypeMask ) const
{
    SERVER_TYPE type;

    if( IS_NT_SERVER( TypeMask ) )
    {
        //
        //  It's an NT server.
        //

        type = ActiveNtServerType;
    }
    else
    if( IS_WIN95_SERVER( TypeMask ) )
    {
        //
        //  It's a Windows95 server.  This takes precedence over WFW.
        //

        type = Windows95ServerType;
    }
    else
    if( IS_WFW_SERVER( TypeMask ) )
    {
        //
        //  It's a Winball server.
        //

        type = WfwServerType;
    }
    else
    {
        //
        //  Otherwise, assume it's LanMan.
        //

        type = ActiveLmServerType;
    }

    return type;

}   // TRIPLE_SERVER_ENUM :: MapTypeMaskToType


DEFINE_LM_ENUM_ITER_OF( TRIPLE_SERVER, TRIPLE_SERVER_INFO );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lsaenum.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1992                   **/
/**********************************************************************/

/*
    lsaenum.cxx

    This file contains the enumerators for enumerating all the accounts
    and privileges in the LSA.

                          LM_RESUME_ENUM
                               |
                               |
                            LSA_ENUM
                           /   |    \
                          /    |     ...
                         /     |
          LSA_ACCOUNT_ENUM   LSA_PRIVILEGE_ENUM


    FILE HISTORY:
        Yi-HsinS          3-Mar-1992    Created
        Yi-HsinS         15-May-1992    Added QueryDisplayName
*/

#include "pchlmobj.hxx"

#define LSA_MAX_PREFERRED_LENGTH (4*1024)

/*************************************************************************

    NAME:       LSA_ENUM::LSA_ENUM

    SYNOPSIS:   Constructor

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ENUM::LSA_ENUM( const LSA_POLICY *plsaPolicy )
    : LM_RESUME_ENUM( 0 ), // 0 is the level - not used here
      _plsaPolicy( plsaPolicy ),
      _lsaEnumHandle( 0 )
{
    if ( QueryError() != NERR_Success )
        return;
}

/*************************************************************************

    NAME:       LSA_ENUM::~LSA_ENUM

    SYNOPSIS:   Destructor

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ENUM::~LSA_ENUM()
{
    NukeBuffers();

    _plsaPolicy = NULL;
}

/*************************************************************************

    NAME:       LSA_ENUM::FreeBuffer

    SYNOPSIS:   Free the memory allocated by LSA APIs

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

VOID LSA_ENUM::FreeBuffer( BYTE **ppbBuffer )
{
    ::LsaFreeMemory( *ppbBuffer );
    *ppbBuffer = NULL;
}

/*************************************************************************

    NAME:       LSA_ACCOUNTS_ENUM::LSA_ACCOUNTS_ENUM

    SYNOPSIS:   Constructor

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_ACCOUNTS_ENUM::LSA_ACCOUNTS_ENUM( const LSA_POLICY *plsaPolicy )
    :  LSA_ENUM( plsaPolicy )
{
    if ( QueryError() != NERR_Success )
        return;
}


/*************************************************************************

    NAME:       LSA_ACCOUNTS_ENUM::CallAPI

    SYNOPSIS:   Invokes the LsaEnumerateAccounts API

    ENTRY:      fRestartEnum  - Indicates whether to start at the beginning.
                                The first call to CallAPI will always pass TRUE.

                ppbBuffer     - Pointer to a pointer to a enumeration buffer.

                pcEntriesRead - Will receive the number of entries read from
                                the API.

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_ACCOUNTS_ENUM::CallAPI( BOOL fRestartEnum,
                                   BYTE **ppbBuffer,
                                   UINT  *pcbEntries )
{
    if ( fRestartEnum )
    {
        _lsaEnumHandle = 0;
    }

    NTSTATUS ntStatus = ::LsaEnumerateAccounts(  _plsaPolicy->QueryHandle(),
                                                &_lsaEnumHandle,
                                                (PVOID *) ppbBuffer,
                                                LSA_MAX_PREFERRED_LENGTH,
                                                (PULONG) pcbEntries );

    APIERR err = ERRMAP::MapNTStatus( ntStatus );

    switch ( err )
    {
        case NERR_Success:
            err = ERROR_MORE_DATA;
            break;

        case ERROR_NO_MORE_ITEMS:
            err = NERR_Success;
            break;

        default:
            break;
    }

    return err;
}


// LSA_ACCOUNTS_ENUM_ITER
DEFINE_LM_RESUME_ENUM_ITER_OF( LSA_ACCOUNTS, PSID );

/*************************************************************************

    NAME:       LSA_PRIVILEGES_ENUM::LSA_PRIVILEGES_ENUM

    SYNOPSIS:   Constructor

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

LSA_PRIVILEGES_ENUM::LSA_PRIVILEGES_ENUM( const LSA_POLICY *plsaPolicy )
    :  LSA_ENUM( plsaPolicy )
{
    if ( QueryError() != NERR_Success )
        return;
}

/*************************************************************************

    NAME:       LSA_PRIVILEGES_ENUM::CallAPI

    SYNOPSIS:   Invokes the LsaEnumeratePrivileges API

    ENTRY:      fRestartEnum  - Indicates whether to start at the beginning.
                                The first call to CallAPI will always pass TRUE.

                ppbBuffer     - Pointer to a pointer to a enumeration buffer.

                pcEntriesRead - Will receive the number of entries read from
                                the API.

    EXIT:

    RETURNS:    APIERR

    NOTES:

    HISTORY:
        Yi-HsinS        15-Mar-1992     Created

**************************************************************************/

APIERR LSA_PRIVILEGES_ENUM::CallAPI( BOOL fRestartEnum,
                                     BYTE **ppbBuffer,
                                     UINT  *pcbEntries )
{

    if ( fRestartEnum )
    {
        _lsaEnumHandle = 0;
    }


    NTSTATUS ntStatus = ::LsaEnumeratePrivileges(  _plsaPolicy->QueryHandle(),
                                                  &_lsaEnumHandle,
                                                  (PVOID *) ppbBuffer,
                                                  LSA_MAX_PREFERRED_LENGTH,
                                                  (PULONG) pcbEntries );

    APIERR err = ERRMAP::MapNTStatus( ntStatus );

    switch ( err )
    {
        case NERR_Success:
            err = ERROR_MORE_DATA;
            break;

        case ERROR_NO_MORE_ITEMS:
            err = NERR_Success;
            break;

        default:
            break;
    }

    return err;
}

// LSA_PRIVILEGES_ENUM_ITER
DEFINE_LM_RESUME_ENUM_ITER_OF( LSA_PRIVILEGES, POLICY_PRIVILEGE_DEFINITION );

/*************************************************************************

    NAME:       LSA_PRIVILEGES_ENUM_OBJ::QueryDisplayName

    SYNOPSIS:   Query the display name of the privilege

    ENTRY:      plsaPolicy - pointer to the LSA_POLICY

    EXIT:       pnls - place to hold the display name

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        15-May-1992     Created

**************************************************************************/

APIERR LSA_PRIVILEGES_ENUM_OBJ::QueryDisplayName( NLS_STR *pnls,
                                const LSA_POLICY *plsaPolicy ) const
{
    PUNICODE_STRING punsDisplayName;
    SHORT nLanguageReturned;

    APIERR err = ERRMAP::MapNTStatus(
           ::LsaLookupPrivilegeDisplayName( plsaPolicy->QueryHandle(),
                                            (PUNICODE_STRING) & QueryBufferPtr()->Name,
                                            &punsDisplayName,
                                            &nLanguageReturned ));

    if ( err == NERR_Success )
    {
        err = pnls->MapCopyFrom( punsDisplayName->Buffer,
                                 punsDisplayName->Length  );

        ::LsaFreeMemory( punsDisplayName->Buffer );
        ::LsaFreeMemory( punsDisplayName );
    }

    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\log\elfsrc.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT			     **/
/**		   Copyright(c) Microsoft Corp., 1991		     **/
/**********************************************************************/

/*
    ELFSRC.CXX

    Event Log sourcing classes.

    FILE HISTORY:
	DavidHov      2/16/93     Created

*/

#include "pchlmobj.hxx"  // Precompiled header

#include "elfsrc.hxx"


EVENT_LOG_SOURCE :: EVENT_LOG_SOURCE (
    const TCHAR * pchSourceName,
    const TCHAR * pchDllName,
    DWORD dwTypesSupported,
    const TCHAR * pchServerName )
    : _hndl( NULL )
{
    APIERR err = Create( pchSourceName,
                         pchDllName,
                         dwTypesSupported,
                         pchServerName ) ;
    if ( err )
    {
        ReportError( err ) ;
    }
}

EVENT_LOG_SOURCE :: EVENT_LOG_SOURCE (
    const TCHAR * pchSourceName,
    const TCHAR * pchServerName )
    : _hndl( NULL )
{
    APIERR err = Open( pchSourceName,
                       pchServerName ) ;
    if ( err )
    {
        ReportError( err ) ;
    }
}

EVENT_LOG_SOURCE :: ~ EVENT_LOG_SOURCE ()
{
    Close() ;
}


APIERR EVENT_LOG_SOURCE :: Create (
    const TCHAR * pchSourceName,
    const TCHAR * pchDllName,
    DWORD dwTypesSupported,
    const TCHAR * pchServerName )
{
    APIERR err = 0 ;
    REG_KEY rkMachine( HKEY_LOCAL_MACHINE ) ;
    NLS_STR nlsKeyName( SZ("SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\") ) ;
    NLS_STR nlsDllName( SZ("%SystemRoot%\\System32\\") ) ;
    REG_KEY_CREATE_STRUCT rkcStruct ;
    REG_KEY * prkLog = NULL ;

    rkcStruct.dwTitleIndex   = 0 ;
    rkcStruct.ulOptions      = 0 ;
    rkcStruct.ulDisposition  = 0 ;
    rkcStruct.regSam         = 0 ;
    rkcStruct.pSecAttr       = NULL ;
    rkcStruct.nlsClass       = SZ("GenericClass") ;

    do
    {
        Close() ;

        if ( err = rkMachine.QueryError() )
            break ;

        if ( err = nlsKeyName.QueryError() )
            break ;

        if ( err = nlsKeyName.Append( pchSourceName ) )
            break ;

        if ( err = nlsDllName.Append( pchDllName ) )
            break ;

        prkLog = new REG_KEY( rkMachine, nlsKeyName, & rkcStruct ) ;
        if ( err = prkLog
                 ? prkLog->QueryError()
                 : ERROR_NOT_ENOUGH_MEMORY )
            break ;

        //  If the key already existed, just go and open the source.

        if ( rkcStruct.ulDisposition == REG_OPENED_EXISTING_KEY )
            break;

        if ( err = prkLog->SetValue( SZ("EventMessageFile"),
                                     & nlsDllName,
                                     NULL,
                                     TRUE ) )
            break ;

        if ( err = prkLog->SetValue( SZ("TypesSupported"),
                                     dwTypesSupported ) )
            break ;
    }
    while ( FALSE ) ;

    if ( err == 0 )
    {
        err = Open( pchSourceName, pchServerName ) ;
    }

    delete prkLog ;
    return err ;
}

APIERR EVENT_LOG_SOURCE :: Open (
    const TCHAR * pchSourceName,
    const TCHAR * pchServerName )
{
    APIERR err = 0 ;

    _hndl = ::RegisterEventSource( (LPTSTR) pchServerName,
                                   (LPTSTR) pchSourceName ) ;

    if ( _hndl == NULL )
    {
        err = ::GetLastError() ;
    }

    return err ;
}

APIERR EVENT_LOG_SOURCE :: Close ()
{
    APIERR err = 0 ;

    if ( _hndl )
    {
        if ( ! ::DeregisterEventSource( _hndl ) )
        {
            err = ::GetLastError() ;
        }
        _hndl = NULL ;
    }

    return err ;
}


APIERR EVENT_LOG_SOURCE :: Log (
    WORD wType,
    WORD wCategory,
    DWORD dwEventId,
    const TCHAR * pchStr1, ... )
{
    APIERR err = 0 ;
    const TCHAR * apchStrs [ ELFSRC_MAX_STRINGS + 1 ] ;
    const TCHAR * pchNext ;
    INT cStrs ;

    va_list vargList ;

    va_start( vargList, pchStr1 ) ;

    for ( cStrs = 0, pchNext = pchStr1 ;
          cStrs < ELFSRC_MAX_STRINGS && pchNext != NULL ;
          cStrs++ )
    {
        apchStrs[cStrs] = pchNext ;
        pchNext = va_arg( vargList, const TCHAR * ) ;
    }

    apchStrs[cStrs] = NULL ;

    if ( ! ::ReportEvent( _hndl,
                          wType,
                          wCategory,
                          dwEventId,
                          NULL,
                          (USHORT)cStrs,
                          0,
                          (LPCTSTR *) apchStrs,
                          NULL )
       )
    {
        err = ::GetLastError() ;
    }

    return err ;
}

APIERR EVENT_LOG_SOURCE :: Log (
    WORD wType,
    WORD wCategory,
    DWORD dwEventId,
    PVOID pvRawData,
    DWORD cbRawData,
    PSID pSid,
    const TCHAR * pchStr1, ... )
{
    APIERR err = 0 ;
    const TCHAR * apchStrs [ ELFSRC_MAX_STRINGS + 1 ] ;
    const TCHAR * pchNext ;
    INT cStrs ;

    va_list vargList ;

    va_start( vargList, pchStr1 ) ;

    for ( cStrs = 0, pchNext = pchStr1 ;
          cStrs < ELFSRC_MAX_STRINGS && pchNext != NULL ;
          cStrs++ )
    {
        apchStrs[cStrs] = pchNext ;
        pchNext = va_arg( vargList, const TCHAR * ) ;
    }

    apchStrs[cStrs] = NULL ;

    if ( ! ::ReportEvent( _hndl,
                          wType,
                          wCategory,
                          dwEventId,
                          pSid,
                          (USHORT)cStrs,
                          cbRawData,
                          (LPCTSTR *) apchStrs,
                          pvRawData )
       )
    {
        err = ::GetLastError() ;
    }

    return err ;
}

//  End of ELFSRC.CXX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoeuse.cxx ===
/*****************************************************************/
/**		     Microsoft Windows NT			**/
/**	       Copyright(c) Microsoft Corp., 1992		**/
/*****************************************************************/

/*
 *  lmoeuse.cxx
 *
 *  HISTORY:
 *	Yi-HsinS     09-Jun-1992     Created
 *
 */

#include "pchlmobj.hxx"


/***************************** USE_ENUM  ******************************/


/**********************************************************\

   NAME:       USE_ENUM::USE_ENUM

   SYNOPSIS:   use enum constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	Yi-HsinS     09-Jun-1992     Created

\**********************************************************/

USE_ENUM::USE_ENUM( const TCHAR * pszServer, UINT uLevel )
  : LOC_LM_ENUM( pszServer, uLevel )
{
    // only supports levels 1 at this time
    UIASSERT( uLevel == 1 );

}  // USE_ENUM::USE_ENUM



/**********************************************************\

   NAME:       USE_ENUM::CallAPI

   SYNOPSIS:   call use enum api

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	Yi-HsinS     09-Jun-1992     Created

\**********************************************************/

APIERR USE_ENUM::CallAPI( BYTE ** ppbBuffer,
			  UINT  * pcEntriesRead )
{
    // only levels support at the time
    UIASSERT( QueryInfoLevel() == 1 );

    return ::MNetUseEnum( QueryServer(),
			  QueryInfoLevel(),
			  ppbBuffer,
			  pcEntriesRead );

}  // USE_ENUM::CallAPI



/*****************************	USE1_ENUM  ******************************/

/**********************************************************\

   NAME:       USE1_ENUM::USE1_ENUM

   SYNOPSIS:   use enum 1 constructor

   ENTRY:

   EXIT:

   NOTES:

   HISTORY:
   	Yi-HsinS     09-Jun-1992     Created

\**********************************************************/

USE1_ENUM::USE1_ENUM( const TCHAR * pszServer )
  : USE_ENUM( pszServer, 1 )
{
    // do nothing else

}  // USE1_ENUM::USE1_ENUM


/*******************************************************************

    NAME:	USE1_ENUM_OBJ :: SetBufferPtr

    SYNOPSIS:	Saves the buffer pointer for this enumeration object.

    ENTRY:	pBuffer			- Pointer to the new buffer.

    EXIT:	The pointer has been saved.

    NOTES:	Will eventually handle OemToAnsi conversions.

    HISTORY:
   	Yi-HsinS     09-Jun-1992     Created

********************************************************************/

VOID USE1_ENUM_OBJ :: SetBufferPtr( const struct use_info_1 * pBuffer )
{
    ENUM_OBJ_BASE :: SetBufferPtr( (const BYTE *)pBuffer );

}   // SHARE1_ENUM_OBJ :: SetBufferPtr


DEFINE_LM_ENUM_ITER_OF( USE1, struct use_info_1 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\log\loglm.cxx ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**             Copyright(c) Microsoft Corp., 1991                   **/
/**********************************************************************/

/*
    loglm.cxx

    LM Audit and Error Log classes

        LM_EVENT_LOG
            LM_AUDIT_LOG
            LM_ERROR_LOG

    FILE HISTORY:
        DavidHov        6/6/91          Created
        Yi-HsinS        12/5/91         Separated from eventlog.cxx
        terryk          12/20/91        Added WriteTextEntry
        Yi-HsinS        1/15/92         Added SeekOldestLogEntry,
                                        SeekNewestLogEntry and modified
                                        WriteTextEntry
        JonN            6/22/00         WriteTextEntry no longer supported

*/

#include "pchlmobj.hxx"  // Precompiled header

extern "C"
{
    #include "apperr2.h"
}

#define WHITE_SPACE    TCH(' ')
#define PERM_SEPARATOR TCH('/')
#define EMPTY_STRING   SZ("")
#define END_OF_LINE    SZ("\r\n")
#define COMMA_CHAR     TCH(',')
#define PERIOD_CHAR    TCH('.')

// NOTE: cfront prevents this from being a natural TCHAR[]
static TCHAR *const pszNoUser = SZ("***");


/*******************************************************************

    NAME:           LM_EVENT_LOG::LM_EVENT_LOG

    SYNOPSIS:       Constructor for the base class of LM audit log
                    and LM error log

    ENTRY:          pszServer - name of the server
                    evdir     - direction of browsing
                    pszModule - name of the module

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

LM_EVENT_LOG::LM_EVENT_LOG( const TCHAR     *pszServer,
                            EVLOG_DIRECTION  evdir,
                            const TCHAR     *pszModule )
    :  EVENT_LOG( pszServer, evdir, pszModule ),
       _pbBuf( NULL ),
       _ulRecordNum( MAXULONG ),
       _ulStartRecordNum( 0 ),
       _cbOffset( 0 ),
       _cbReturned( 0 ),
       _cbTotalAvail( MAXUINT )
{
    if ( QueryError() != NERR_Success )
        return;
}

/*******************************************************************

    NAME:           LM_EVENT_LOG::~LM_EVENT_LOG

    SYNOPSIS:       Destructor ( virtual )

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

LM_EVENT_LOG::~LM_EVENT_LOG()
{
    ::MNetApiBufferFree( &_pbBuf );
    _pbBuf = NULL;
}

/*******************************************************************

    NAME:           LM_EVENT_LOG::Reset

    SYNOPSIS:       Reset the stream to is original limit position based
                    upon the direction in question.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/
VOID LM_EVENT_LOG::Reset( VOID )
{
    /*
     *  Initialize the handle to the log file
     */
    EVENT_LOG::Reset();

    _hLog.time    = _hLog.last_flags = 0 ;
    _hLog.offset  = _hLog.rec_offset = MAXUINT;

    _ulRecordNum  = MAXULONG;
    _ulStartRecordNum = 0;

    _cbOffset     = 0;
    _cbReturned   = 0 ;
    _cbTotalAvail = MAXUINT;

}

/*******************************************************************


    NAME:           LM_EVENT_LOG::QueryPos

    SYNOPSIS:       Retrieve the position of the current log entry

    ENTRY:          plogEntryNum - pointer to the place to store the
                                   position

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_EVENT_LOG::QueryPos( LOG_ENTRY_NUMBER *plogEntryNum )
{
    UIASSERT( plogEntryNum != NULL );
    plogEntryNum->SetRecordNum( _ulRecordNum );
    plogEntryNum->SetDirection( _evdir );
    return plogEntryNum->QueryError();
}

/*******************************************************************


    NAME:           LM_EVENT_LOG::SeekOldestLogEntry

    SYNOPSIS:       Get the oldest log entry in the log into the buffer

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/19/92         Created

********************************************************************/

APIERR LM_EVENT_LOG::SeekOldestLogEntry( VOID )
{
    UIASSERT( IsOpened() );

    // Remember the original direction
    EVLOG_DIRECTION evdirOld = _evdir;

    LOG_ENTRY_NUMBER logEntryNum( 0, EVLOG_FWD );

    APIERR err = SeekLogEntry( logEntryNum );

    // Set the direction back to the original direction
    SetDirection( evdirOld );

    return err;

}

/*******************************************************************


    NAME:           LM_EVENT_LOG::SeekNewestLogEntry

    SYNOPSIS:       Get the newest log entry in the log into the buffer

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/19/92         Created

********************************************************************/

APIERR LM_EVENT_LOG::SeekNewestLogEntry( VOID )
{
    UIASSERT( IsOpened() );

    // Remember the original direction
    EVLOG_DIRECTION evdirOld = _evdir;

    LOG_ENTRY_NUMBER logEntryNum( 0, EVLOG_BACK );

    APIERR err = SeekLogEntry( logEntryNum );

    // Set the direction back to the original direction
    SetDirection( evdirOld );

    return err;

}

/*******************************************************************


    NAME:           LM_EVENT_LOG::QueryNumberOfEntries

    SYNOPSIS:       Get an estimate of the number of entries in the
                    log file.

    ENTRY:

    EXIT:           *pcEntries - contains the number of entries
                                 in the log

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        2/19/92         Created

********************************************************************/

APIERR LM_EVENT_LOG::QueryNumberOfEntries( ULONG *pcEntries )
{
    UIASSERT( IsOpened() );

    *pcEntries = 0;

    Reset();

    BOOL fContinue;
    APIERR err = I_Next( &fContinue );
    if ( err != NERR_Success )
        return err;

    *pcEntries = 0;
    if ( _cbReturned  > 0 )
    {
        *pcEntries = QueryEntriesInBuffer();

        UINT nMultiple = _cbTotalAvail / _cbReturned;
        if ( nMultiple > 0 )
            *pcEntries *= nMultiple;
    }

    Reset();

    return NERR_Success;
}

/*******************************************************************

    NAME:           LM_EVENT_LOG::I_Open

    SYNOPSIS:       Helper method to open the log for reading.
                    We don't need to do anything for LM logs.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_EVENT_LOG::I_Open( VOID )
{
    // Nothing to do
    return NERR_Success;
}

/*******************************************************************

    NAME:           LM_EVENT_LOG::I_Close

    SYNOPSIS:       Helper method to close the log.
                    We don't need to do anything for LM logs.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_EVENT_LOG::I_Close( VOID )
{
    // Nothing to do
    return NERR_Success;
}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::LM_AUDIT_LOG

    SYNOPSIS:       Constructor

    ENTRY:          pszServer - name of the server
                    evdir     - direction of browsing
                    pszModule - name of the module

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

LM_AUDIT_LOG::LM_AUDIT_LOG( const TCHAR     *pszServer,
                            EVLOG_DIRECTION  evdir,
                            const TCHAR     *pszModule)
    : LM_EVENT_LOG( pszServer, evdir, pszModule ),
      _pAE( NULL ),
      _pstrlstCategory( NULL )
{

    if ( QueryError() != NERR_Success )
        return;

}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::~LM_AUDIT_LOG

    SYNOPSIS:       Destructor ( virtual )

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

LM_AUDIT_LOG::~LM_AUDIT_LOG()
{
    delete _pstrlstCategory;
    _pstrlstCategory = NULL;
}

/*******************************************************************

    NAME:	    LM_AUDIT_LOG::QuerySrcSupportedCategoryList

    SYNOPSIS:	    Query the category list supported LM audit log.

    ENTRY:	    nlsSource - This is ignored here. This is used only
                                in NT event logs.


    EXIT:	    *pstrlstCategory - pointer to the category list

    RETURNS:	

    NOTES:

    HISTORY:
	Yi-HsinS	3/9/92       Created

********************************************************************/

MSGID LMAuditCategoryTable[] = { APE2_AUDIT_SERVER,    APE2_AUDIT_SESS,
                                 APE2_AUDIT_SHARE,     APE2_AUDIT_ACCESS,
                                 APE2_AUDIT_ACCESS_D,  APE2_AUDIT_ACCESSEND,
                                 APE2_AUDIT_NETLOGON,  APE2_AUDIT_NETLOGOFF,
                                 APE2_AUDIT_ACCOUNT,   APE2_AUDIT_ACCLIMIT,
                                 APE2_AUDIT_SVC,       APE2_AUDIT_LOCKOUT };

#define LM_AUDIT_CATEGORY_TABLE_SIZE ( sizeof(LMAuditCategoryTable)   \
                                       /  sizeof(MSGID) )

APIERR LM_AUDIT_LOG::QuerySrcSupportedCategoryList( const NLS_STR &nlsSource,
                                                    STRLIST **ppstrlstCategory )
{
    UNREFERENCED( nlsSource );

    //
    // If _pstrlstCategory has not already been initialized,
    // initialize it with strings from LMAuditCategoryTable
    //
    APIERR err;
    if ( _pstrlstCategory == NULL )
    {
        _pstrlstCategory = new STRLIST;

        if  ( _pstrlstCategory == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
        }
        else
        {
            for ( UINT i = 0; i < LM_AUDIT_CATEGORY_TABLE_SIZE; i++ )
            {
                RESOURCE_STR *pnls = new RESOURCE_STR(LMAuditCategoryTable[i], NLS_BASE_DLL_HMOD );
                if (  ( pnls == NULL )
                   || (( err = pnls->QueryError() ) != NERR_Success )
                   || (( err = _pstrlstCategory->Add( pnls )) != NERR_Success )
                   )
                {
                    break;
                }
            }
        }
    }

    *ppstrlstCategory = _pstrlstCategory;
    return err;
}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::Clear

    SYNOPSIS:       Clear the audit log

    ENTRY:          pszBackupFile - name of the file to backup the
                                    audit log to

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_AUDIT_LOG::Clear( const TCHAR *pszBackupFile )
{
    UIASSERT( IsOpened() );

    APIERR err = ::MNetAuditClear( _nlsServer, pszBackupFile, NULL );
    if ( err == NERR_Success )
        Reset();
    return err;
}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::Reset

    SYNOPSIS:       Reset the log file to its minimum position.

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

VOID LM_AUDIT_LOG::Reset( VOID )
{
    LM_EVENT_LOG::Reset();

    _pAE = NULL;
}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::QueryEntriesInBuffer

    SYNOPSIS:       Get the number of entries currently contained
                    in the buffer.

    ENTRY:

    EXIT:

    RETURNS:        Return the number of entries in the buffer

    NOTES:

    HISTORY:
        Yi-HsinS        5/23/92        Created

********************************************************************/

ULONG LM_AUDIT_LOG::QueryEntriesInBuffer( VOID )
{
    ULONG cEntries = 0;
    ULONG cbOffset = 0;
    AUDIT_ENTRY *pAE = NULL;

    while ( cbOffset < _cbReturned )
    {
        pAE = (AUDIT_ENTRY *) ( _pbBuf + cbOffset);
        cbOffset += (UINT) pAE->ae_len ;
        cEntries++;
    }

    return cEntries;

}

/*******************************************************************


    NAME:           LM_AUDIT_LOG::SetPos

    SYNOPSIS:       Prepare all internal variables to get the requested log
                    entry in the next read

    ENTRY:          logEntryNum -  the requested record position
                    fForceRead  -  If TRUE, we will always read from the log.
                                   Else we will only read if the entry is not
                                   in the buffer

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

VOID LM_AUDIT_LOG::SetPos( const LOG_ENTRY_NUMBER &logEntryNum, BOOL fForceRead)
{

    BOOL fRead = fForceRead;

    if ( !fRead )
    {
        fRead = TRUE;
        // Check to see if the requested log entry is in the buffer
        // and set the direction and record number for the next read accordingly

        ULONG ulRecCount = _ulStartRecordNum;
        ULONG ulRecSeek  = logEntryNum.QueryRecordNum();

        // Check to see if the requested log entry is in the buffer already.
        if (  ( logEntryNum.QueryDirection() == _evdirBuf )
           && ( ulRecSeek >= ulRecCount )
           )
        {
            _cbOffset = 0;
            while ( _cbOffset < _cbReturned )
            {
                if ( ulRecCount == ulRecSeek )
                {
                    fRead = FALSE;
                    break;
                }
                else
                {
                    _pAE = (AUDIT_ENTRY *) ( _pbBuf + _cbOffset);
                    _cbOffset += (UINT) _pAE->ae_len ;
                    ulRecCount++;
                }

            }

        }
    }

    // If entry not in buffer, reset some variables to prepare for next read
    if ( fRead )
    {
        _cbOffset = _cbReturned;
        _evdir = logEntryNum.QueryDirection();
        _cbTotalAvail = MAXUINT;
    }

    // We need to minus one because I_Next always increments the record number
    // by one before reading.
    _ulRecordNum = logEntryNum.QueryRecordNum() - 1;

}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::I_Next

    SYNOPSIS:       Helper method that actually reads the next log
                    entry if it's not in the buffer already

    ENTRY:          ulBufferSize - buffer size used for the Net APIs

    EXIT:           *pfContinue - TRUE if not end of log file, FALSE otherwise.

    RETURNS:

    NOTES:

    HISTORY:
        DavidHov        10/23/91        Created
        Yi-HsinS        10/23/91        Modified for efficient seek read

********************************************************************/

APIERR LM_AUDIT_LOG::I_Next( BOOL *pfContinue, ULONG ulBufferSize )
{
    APIERR err;

    _ulRecordNum++;
    _pAE = NULL;

    TRACEEOL( "Audit Number:" <<  _ulRecordNum );

    // Do a Net API call to get the entry we wanted!
    if ( _cbOffset >= _cbReturned )
    {
        // Reached the end of log
        if ( _cbTotalAvail == 0 )
        {
            *pfContinue = FALSE;
            return NERR_Success;
        }

        _cbOffset = 0;

        // Free the previous buffer allocated by the Net API or mapping layer
        ::MNetApiBufferFree( &_pbBuf );
        _pbBuf = NULL;

        // Don't need to worry about buffer not large enough because
        // the mapping layer will take care of it.
        err = ::MNetAuditRead( _nlsServer,
                               NULL,
                               &_hLog,
                               _ulRecordNum,   // will be ignored
                               NULL,
                               0,
                               ( ( ( _evdir == EVLOG_FWD)? LOGFLAGS_FORWARD
                                                         : LOGFLAGS_BACKWARD)
                               | (  IsSeek()? LOGFLAGS_SEEK : 0 )
                               ),
                               &_pbBuf,
                               (UINT) ulBufferSize,
                               & _cbReturned,
                               & _cbTotalAvail
                             );

        _ulStartRecordNum = _ulRecordNum;
        _evdirBuf = _evdir;

        DBGEOL( "AUDIT RETURNED: " << _cbReturned
                << " AVAILABLE: "  << _cbTotalAvail );

        // Reached end of log
        if ( err == NERR_Success && _cbTotalAvail == 0 && _cbReturned == 0 )
        {
            *pfContinue = FALSE;
            return NERR_Success;
        }

        if ( err != NERR_Success )
        {
            _cbReturned = 0 ;
            *pfContinue = FALSE;
            return err;
        }
    }

    SetSeekFlag( FALSE );

    _pAE = (AUDIT_ENTRY *) ( _pbBuf + _cbOffset);

    if ( _cbReturned - _cbOffset < _pAE->ae_len )
    {
        // Report the same error that NET CMD does (cf. AUDERR.C)
        _cbOffset = _cbReturned;
        *pfContinue = FALSE;
        return IDS_UI_LOG_RECORD_CORRUPT;
    }

    _cbOffset += (UINT) _pAE->ae_len ;

    *pfContinue = TRUE;
    return NERR_Success;
}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::PermMap

    SYNOPSIS:       Helper method to map permissions into a readable
                    string

    ENTRY:          uiPerm - permission mask

    EXIT:           pnlsPerm - pointer to a readable permission string

    RETURNS:

    NOTES:          All msgid for Read/Write/... are consecutive ids.

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_AUDIT_LOG::PermMap( UINT uiPerm, NLS_STR *pnlsPerm )
{
    APIERR err  = NERR_Success;
    MSGID msgid = IDS_UI_READ;

    if ( (err = pnlsPerm->CopyFrom( EMPTY_STRING )) != NERR_Success )
        return err;

    for ( ; (uiPerm != 0) && (msgid <= IDS_UI_CHANGE_PERM);
            uiPerm >>= 1, msgid++ )
    {
        if ( uiPerm & 1 )
        {
            if ( pnlsPerm->QueryTextLength() != 0)
                err = pnlsPerm->AppendChar( PERM_SEPARATOR );

            RESOURCE_STR nlsTemp( msgid, NLS_BASE_DLL_HMOD  );
            if (  ( err != NERR_Success )
               || ((err = nlsTemp.QueryError() ) != NERR_Success )
               || ((err = pnlsPerm->Append( nlsTemp ) ) != NERR_Success )
               )
            {
                break;
            }
        }
    }

    return err;
}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::CreateCurrentRawEntry

    SYNOPSIS:       Helper function for constructing the RAW_LOG_ENTRY
                    to be used mainly when filter the log

    ENTRY:

    EXIT:           pRawLogEntry - Return the pointer to the raw log
                                    entry created.

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_AUDIT_LOG::CreateCurrentRawEntry( RAW_LOG_ENTRY *pRawLogEntry )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pAE != NULL );

    APIERR err = NERR_Success;
    TCHAR *pszComp = pszNoUser;
    TCHAR *pszUser = pszNoUser;

    switch ( _pAE->ae_type )
    {
        case AE_SRVSTATUS:
        case AE_GENERIC:
            // No user or computer name contained in these two kinds
            // of audit records.
            break;

        default:
        {
            // Get the computer and user name
            BYTE *pbVarData = (BYTE *) _pAE + _pAE->ae_data_offset;
            pszComp = (TCHAR *) ( (BYTE *) pbVarData + (UINT) (*pbVarData));

            UINT uiUserOffset = (UINT) *( pbVarData + sizeof(UINT));
            if ( uiUserOffset == 0)
                pszUser = pszComp;
            else
                pszUser = (TCHAR *) ( (BYTE *) pbVarData + uiUserOffset );
            break;
        }
    }

    RESOURCE_STR nlsCategory( QueryCurrentEntryCategory(), NLS_BASE_DLL_HMOD );

    REQUIRE( nlsCategory.QueryError() == NERR_Success );

    return pRawLogEntry->Set(  _ulRecordNum,
                               (ULONG) _pAE->ae_time,
                               TYPE_NONE,  // No Type
                               nlsCategory,
                               TYPE_NONE,  // No Event ID
                               pszNoUser,  // No Source
                               pszUser,
                               pszComp,
                               this
                            );

}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::CreateCurrentFormatEntry

    SYNOPSIS:       Helper function for constructing the  FORMATTED_LOG_ENTRY
                    for displaying in the listbox.

    ENTRY:

    EXIT:           ppFmtLogEntry - Return the pointer to the formatted log
                                    entry created.

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_AUDIT_LOG::CreateCurrentFormatEntry( FORMATTED_LOG_ENTRY **ppFmtLogEntry )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pAE != NULL );

    APIERR err = NERR_Success;

    NLS_STR nlsComp( pszNoUser );
    NLS_STR nlsUser( pszNoUser );

    if (  (( err = nlsComp.QueryError()) != NERR_Success )
       || (( err = nlsUser.QueryError()) != NERR_Success )
       )
    {
        return err;
    }

    switch ( _pAE->ae_type )
    {
        case AE_SRVSTATUS:
        case AE_GENERIC:
            // No user or computer name contained in these two kinds
            // of audit records.
            break;

        default:
        {
            // Get the computer and user name
            BYTE *pbVarData = (BYTE *) _pAE + _pAE->ae_data_offset;
            err = nlsComp.CopyFrom((TCHAR *) ( (BYTE *) pbVarData +
                                               (UINT) (*pbVarData)));

            if ( err == NERR_Success )
            {
                UINT uiUserOffset = (UINT) *( pbVarData + sizeof(UINT));
                if ( uiUserOffset == 0)
                    nlsUser = nlsComp;
                else
                    err = nlsUser.CopyFrom((TCHAR *) ( (BYTE *)pbVarData
                                                           + uiUserOffset));
            }
            break;
        }
    }


    RESOURCE_STR nlsCategory( QueryCurrentEntryCategory(), NLS_BASE_DLL_HMOD );

    if (  ( err == NERR_Success )
       && (( err = nlsComp.QueryError()) == NERR_Success )
       && (( err = nlsUser.QueryError()) == NERR_Success )
       && (( err = nlsCategory.QueryError()) == NERR_Success )
       )
    {

         *ppFmtLogEntry = new FORMATTED_LOG_ENTRY( _ulRecordNum,
                                                   (ULONG) _pAE->ae_time,
                                                   TYPE_NONE,    // No Type
                                                   EMPTY_STRING, // No Type
                                                   nlsCategory,
                                                   TYPE_NONE,    // No Event ID
                                                   pszNoUser,    // No Source
                                                   nlsUser,
                                                   nlsComp,
                                                   NULL,  // delay until needed
                                                   this
                                                 );

          err = ( *ppFmtLogEntry == NULL? (APIERR ) ERROR_NOT_ENOUGH_MEMORY
                                        : (*ppFmtLogEntry)->QueryError() );
          if ( err != NERR_Success )
          {
              delete *ppFmtLogEntry;
              *ppFmtLogEntry = NULL;
          }

    }

    return err;

}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::QueryCurrentEntryCategory

    SYNOPSIS:       Get the category of the current audit log entry

    ENTRY:

    EXIT:

    RETURNS:        Returns the category of the audit log record

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

MSGID LM_AUDIT_LOG::QueryCurrentEntryCategory( VOID )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pAE != NULL );

    MSGID msgidCategory = (MSGID) APE2_AUDIT_UNKNOWN;

    switch ( _pAE->ae_type )
    {
        case AE_SRVSTATUS:
            msgidCategory = APE2_AUDIT_SERVER;
            break;

        case AE_SESSLOGON:
        case AE_SESSLOGOFF:
        case AE_SESSPWERR:
            msgidCategory = APE2_AUDIT_SESS;
            break;

        case AE_CONNSTART:
        case AE_CONNSTOP:
        case AE_CONNREJ:
            msgidCategory = APE2_AUDIT_SHARE;
            break;

        case AE_RESACCESS:
        case AE_RESACCESS2:
            msgidCategory = APE2_AUDIT_ACCESS;
            break;

        case AE_RESACCESSREJ:
            msgidCategory = APE2_AUDIT_ACCESS_D;
            break;

        case AE_CLOSEFILE:
            msgidCategory = APE2_AUDIT_ACCESSEND;
            break;

#ifndef WIN32
        // Not supported in LANMAN 2.0?
        case AE_NETLOGDENIED:
#endif
        case AE_NETLOGON:
            msgidCategory = APE2_AUDIT_NETLOGON;
            break;

        case AE_NETLOGOFF:
            msgidCategory = APE2_AUDIT_NETLOGOFF;


        case AE_UASMOD:
            msgidCategory = APE2_AUDIT_ACCOUNT;
            break;

        case AE_ACLMOD:
        case AE_ACLMODFAIL:
            msgidCategory = ( _pAE->ae_type == AE_ACLMOD?
                          APE2_AUDIT_ACCESS : APE2_AUDIT_ACCESS_D );
            break;

        case AE_ACCLIMITEXCD:
            msgidCategory = APE2_AUDIT_ACCLIMIT;
            break;

        case AE_SERVICESTAT:
            msgidCategory = APE2_AUDIT_SVC;
            break;

        case AE_LOCKOUT:
            msgidCategory = APE2_AUDIT_LOCKOUT;
            break;

        case AE_GENERIC:
            msgidCategory = APE2_AUDIT_SVC;
            break;

        default:
            // Unknown Type
            break;

      }

      return msgidCategory;

}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::QueryCurrentEntryDesc

    SYNOPSIS:       Get the description associated with the current
                    log entry

    ENTRY:

    EXIT:           pnlsDesc - pointer to the description of the audit record

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_AUDIT_LOG::QueryCurrentEntryDesc( NLS_STR *pnlsDesc )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pAE != NULL );

    APIERR err = NERR_Success;

    NLS_STR nlsParam;   // will be empty if no parameters
    if (( err = nlsParam.QueryError()) != NERR_Success )
    {
        return err;
    }

    MSGID msgidDesc = (MSGID) APE2_AUDIT_UNKNOWN;
    BYTE *pbVarData = (BYTE *) _pAE + _pAE->ae_data_offset;

    // All defaults in switch statements below are omitted because all
    // variables are properly initialized to  recognize the
    // unknown cases.

    switch ( _pAE->ae_type )
    {
        case AE_SRVSTATUS:
        {
             switch( (( struct ae_srvstatus *) pbVarData)->ae_sv_status )
             {
                  case AE_SRVSTART:
                      msgidDesc = APE2_AUDIT_SRV_STARTED;
                      break;

                  case AE_SRVPAUSED:
                      msgidDesc = APE2_AUDIT_SRV_PAUSED;
                      break;

                  case AE_SRVCONT:
                      msgidDesc = APE2_AUDIT_SRV_CONTINUED;
                      break;

                  case AE_SRVSTOP:
                      msgidDesc = APE2_AUDIT_SRV_STOPPED;
                      break;

              }
              break;
          }

          case AE_SESSLOGON:
          {
              switch( (( struct ae_sesslogon *) pbVarData)->ae_so_privilege )
              {
                  case AE_GUEST:
                      msgidDesc = APE2_AUDIT_SESS_GUEST;
                      break;

                  case AE_USER:
                      msgidDesc = APE2_AUDIT_SESS_USER;
                      break;

                  case AE_ADMIN:
                      msgidDesc = APE2_AUDIT_SESS_ADMIN;
                      break;

              }
              break;
          }

          case AE_SESSLOGOFF:
          {
              switch( (( struct ae_sesslogoff *) pbVarData)->ae_sf_reason )
              {
                  case AE_NORMAL:
                      msgidDesc = APE2_AUDIT_SESS_NORMAL;
                      break;

                  case AE_ERROR:
                      msgidDesc = APE2_AUDIT_SESS_ERROR;
                      break;

                  case AE_AUTODIS:
                      msgidDesc = APE2_AUDIT_SESS_AUTODIS;
                      break;

                  case AE_ADMINDIS:
                      msgidDesc = APE2_AUDIT_SESS_ADMINDIS;
                      break;

                  case AE_ACCRESTRICT:
                      msgidDesc = APE2_AUDIT_SESS_ACCRESTRICT;
                      break;
              }
              break;
          }

          case AE_SESSPWERR:
          {
              msgidDesc = APE2_AUDIT_BADPW;
              break;
          }

          case AE_CONNSTART:
          {
              msgidDesc = APE2_AUDIT_USE;
              err = nlsParam.CopyFrom( (TCHAR *) ( (BYTE *) pbVarData +
                          ((struct ae_connstart *) pbVarData)->ae_ct_netname));
              break;
          }


          case AE_CONNSTOP:
          {
              switch( (( struct ae_connstop *) pbVarData)->ae_cp_reason )
              {
                  case AE_NORMAL:
                      msgidDesc = APE2_AUDIT_UNUSE;
                      break;

                  case AE_SESSDIS:
                      msgidDesc = APE2_AUDIT_SESSDIS;
                      break;

                  case AE_UNSHARE:
                      msgidDesc = APE2_AUDIT_SHARE_D;
                      break;

              }

              err = nlsParam.CopyFrom( (TCHAR *) ( (BYTE *) pbVarData +
                          ((struct ae_connstop *) pbVarData)->ae_cp_netname));
              break;
          }

          case AE_CONNREJ:
          {

              switch( (( struct ae_connrej *) pbVarData)->ae_cr_reason )
              {
                  case AE_USERLIMIT:
                      msgidDesc = APE2_AUDIT_USERLIMIT;
                      break;

                  case AE_BADPW:
                      msgidDesc = APE2_AUDIT_BADPW;
                      break;

                  case AE_ADMINPRIVREQD:
                      msgidDesc = APE2_AUDIT_ADMINREQD;
                      break;

                  // Not in netcmd or nif?
                  // case AE_NOACCESSPERM:
                  //     msgidDesc = APE2_AUDIT_NOACCESSPERM;
                  //     break;

              }

              err = nlsParam.CopyFrom( (TCHAR *) ( (BYTE *) pbVarData +
                             ((struct ae_connrej *) pbVarData)->ae_cr_netname));
              break;
          }

          case AE_RESACCESS:
          {
              msgidDesc = APE2_AUDIT_NONE;
              NLS_STR nlsTemp( (TCHAR *) ( (BYTE *) pbVarData +
                               ((struct ae_resaccess *)
                                pbVarData)->ae_ra_resname ));

              if (  (( err = nlsTemp.QueryError()) != NERR_Success )
                 || ((err = PermMap( (UINT) ((struct ae_resaccess *)
                          pbVarData)->ae_ra_operation, &nlsParam))
                      != NERR_Success )
                 )
              {
                  return err;
              }

              nlsParam.AppendChar( WHITE_SPACE );
              nlsParam.Append( nlsTemp );
              break;
          }

          case AE_RESACCESS2:
          {
              msgidDesc = APE2_AUDIT_NONE;

              NLS_STR nlsTemp( (TCHAR *) ( (BYTE *) pbVarData +
                               ((struct ae_resaccess2 *)
                               pbVarData)->ae_ra2_resname ));

              if (  (( err = nlsTemp.QueryError()) != NERR_Success )
                 || (( err = PermMap( (UINT) ((struct ae_resaccess2 *)
                          pbVarData)->ae_ra2_operation, &nlsParam))
                       != NERR_Success )
                 )
              {
                  return err;
              }
              nlsParam.AppendChar( WHITE_SPACE );
              nlsParam.Append( nlsTemp );
              break;
          }

          case AE_RESACCESSREJ:
          {
              msgidDesc = APE2_AUDIT_NONE;

              NLS_STR nlsTemp( (TCHAR *) ( (BYTE *) pbVarData +
                               ((struct ae_resaccessrej *)
                               pbVarData)->ae_rr_resname ));

              if (  (( err = nlsTemp.QueryError()) != NERR_Success )
                 || (( err = PermMap( (UINT) ((struct ae_resaccessrej *)
                         pbVarData)->ae_rr_operation, &nlsParam))
                       != NERR_Success )
                 )
              {
                  return err;
              }

              nlsParam.AppendChar( WHITE_SPACE );
              nlsParam.Append( nlsTemp );
              break;
          }

          case AE_CLOSEFILE:
          {
              switch ( ((struct ae_closefile *) pbVarData)->ae_cf_reason )
              {
                  case AE_NORMAL_CLOSE:
                       msgidDesc = APE2_AUDIT_CLOSED;
                       break;

                  case AE_SES_CLOSE:
                       msgidDesc = APE2_AUDIT_DISCONN;
                       break;

                  case AE_ADMIN_CLOSE:
                       msgidDesc = APE2_AUDIT_ADMINCLOSED;
                       break;

              }
              err = nlsParam.CopyFrom( (TCHAR *) ( (BYTE *) pbVarData +
                       ((struct ae_closefile *)  pbVarData)->ae_cf_resname));
              break;
          }

          case AE_NETLOGON:
          {
              switch ( ((struct ae_netlogon *) pbVarData)->ae_no_privilege)
              {
                  case AE_GUEST:
                      msgidDesc = APE2_AUDIT_SESS_GUEST;
                      break;

                  case AE_USER:
                      msgidDesc = APE2_AUDIT_SESS_USER;
                      break;

                  case AE_ADMIN:
                      msgidDesc = APE2_AUDIT_SESS_ADMIN;
                      break;

              }
              break;
          }

          case AE_NETLOGOFF:
          {
              msgidDesc = APE2_AUDIT_NONE;
              break;
          }

#ifndef WIN32
          // Not supported in LANMAN 2.0
          case AE_NETLOGDENIED:
          {
              switch ( ((struct ae_netlogdenied *) pbVarData)->ae_nd_reason)
              {
                  case AE_GENERAL:
                      msgidDesc = APE2_AUDIT_LOGDENY_GEN;
                      break;

                  case AE_BADPW:
                      msgidDesc = APE2_AUDIT_BADPW;
                      break;

                  case AE_ACCRESTRICT:
                      msgidDesc = APE2_AUDIT_SESS_ACCRESTRICT;
                      break;
              }

              break;
          }
#endif

          case AE_UASMOD:
          {
              switch ( ((struct ae_uasmod *) pbVarData)->ae_um_action )
              {
                  case AE_MOD:
                  {
                      switch ( ((struct ae_uasmod *) pbVarData)->ae_um_rectype)
                      {
                          case AE_UAS_USER:
                              msgidDesc = APE2_AUDIT_ACCOUNT_USER_MOD;
                              break;

                          case AE_UAS_GROUP:
                              msgidDesc = APE2_AUDIT_ACCOUNT_GROUP_MOD;
                              break;

                          case AE_UAS_MODALS:
                              msgidDesc = APE2_AUDIT_ACCOUNT_SETTINGS;
                              break;

                      }
                      break;
                  }

                  case AE_DELETE:
                  {

                      switch ( ((struct ae_uasmod *) pbVarData)->ae_um_rectype)
                      {
                          case AE_UAS_USER:
                              msgidDesc = APE2_AUDIT_ACCOUNT_USER_DEL;
                              break;

                          case AE_UAS_GROUP:
                              msgidDesc = APE2_AUDIT_ACCOUNT_GROUP_DEL;
                              break;
                      }
                      break;
                  }

                  case AE_ADD:
                  {

                      switch ( ((struct ae_uasmod *) pbVarData)->ae_um_rectype)
                      {
                          case AE_UAS_USER:
                              msgidDesc = APE2_AUDIT_ACCOUNT_USER_ADD;
                              break;

                          case AE_UAS_GROUP:
                              msgidDesc = APE2_AUDIT_ACCOUNT_GROUP_ADD;
                              break;
                      }
                      break;
                  }

              }

              err = nlsParam.CopyFrom( (TCHAR *) ( (BYTE *) pbVarData +
                         ((struct ae_uasmod *) pbVarData)->ae_um_resname));
              break;
          }

          case AE_ACLMOD:
          case AE_ACLMODFAIL:
          {
              switch ( ((struct ae_aclmod *) pbVarData)->ae_am_action )
              {
                  case AE_MOD:
                      msgidDesc = APE2_AUDIT_ACCESS_MOD;
                      break;

                  case AE_DELETE:
                      msgidDesc = APE2_AUDIT_ACCESS_DEL;
                      break;

                  case AE_ADD:
                      msgidDesc = APE2_AUDIT_ACCESS_ADD;
                      break;
              }

              err = nlsParam.CopyFrom( (TCHAR *) ( (BYTE *) pbVarData +
                         ((struct ae_aclmod *) pbVarData)->ae_am_resname));
              break;
          }

          case AE_ACCLIMITEXCD:
          {
              switch ( ((struct ae_acclim *) pbVarData)->ae_al_limit )
              {
                  case AE_LIM_UNKNOWN:
                      msgidDesc = APE2_AUDIT_ACCLIMIT_UNKNOWN;
                      break;

                  case AE_LIM_LOGONHOURS:
                      msgidDesc = APE2_AUDIT_ACCLIMIT_HOURS;
                      break;

                  // The following cases are not documented?
                  case AE_LIM_EXPIRED:
                      msgidDesc = APE2_AUDIT_ACCLIMIT_EXPIRED;
                      break;

                  case AE_LIM_INVAL_WKSTA:
                      msgidDesc = APE2_AUDIT_ACCLIMIT_INVAL;
                      break;

                  case AE_LIM_DISABLED:
                      msgidDesc = APE2_AUDIT_ACCLIMIT_DISABLED;
                      break;

                  case AE_LIM_DELETED:
                      msgidDesc = APE2_AUDIT_ACCLIMIT_DELETED;
                      break;

              }
              break;
          }

          case AE_SERVICESTAT:
          {
              switch ( ((struct ae_servicestat *) pbVarData)->ae_ss_status
                       & SERVICE_INSTALL_STATE )
              {
                  case SERVICE_UNINSTALLED:
                      msgidDesc = APE2_AUDIT_SVC_STOP;
                      break;

                  case SERVICE_UNINSTALL_PENDING:
                      msgidDesc = APE2_AUDIT_SVC_STOP_PEND;
                      break;

                  case SERVICE_INSTALL_PENDING:
                      msgidDesc = APE2_AUDIT_SVC_INST_PEND;
                      break;

                  case SERVICE_INSTALLED:
                      switch ( ((struct ae_servicestat *) pbVarData)->
                               ae_ss_status & SERVICE_PAUSE_STATE)
                      {
			  case LM20_SERVICE_PAUSED:
                              msgidDesc = APE2_AUDIT_SVC_PAUSED;
                              break;

			  case LM20_SERVICE_PAUSE_PENDING:
                              msgidDesc = APE2_AUDIT_SVC_PAUS_PEND;
                              break;

			  case LM20_SERVICE_CONTINUE_PENDING:
                              msgidDesc = APE2_AUDIT_SVC_CONT_PEND;
                              break;

			  case LM20_SERVICE_ACTIVE:
                              msgidDesc = APE2_AUDIT_SVC_INSTALLED;
                              break;

                      }
                      break;

              }
              err = nlsParam.CopyFrom( (TCHAR *) ( (BYTE *) pbVarData +
                         ((struct ae_servicestat *) pbVarData)->ae_ss_svcname));
              break;

          }

          case AE_LOCKOUT:
          {
              switch ( ((struct ae_lockout *) pbVarData)->ae_lk_action )
              {
                  case ACTION_LOCKOUT:
                  {
                      msgidDesc = APE2_AUDIT_LKOUT_LOCK;
                      err = nlsParam.CopyFrom( DEC_STR(
                        ((struct ae_lockout *) pbVarData)->ae_lk_bad_pw_count));
                      break;
                  }

                  case ACTION_ADMINUNLOCK:
                      msgidDesc = APE2_AUDIT_LKOUT_ADMINUNLOCK;
                      break;
              }
              break;
          }

          case AE_GENERIC:
          default:
              // Unknown description
              break;

      }

      if (  ( err == NERR_Success )
         && (( err = nlsParam.QueryError()) == NERR_Success )
         )
      {

          if ( pnlsDesc != NULL )
          {

              // If type is AE_RESACCESS or AE_RESACCESS2 or AE_RESACCESSREJ
              // IDS_AUDIT will be none and the desc. is contained in nlsParam
              if (  ( msgidDesc == APE2_AUDIT_NONE )
                 && (_pAE->ae_type != AE_NETLOGOFF)
                 )
              {
                  *pnlsDesc = nlsParam;
                  err = pnlsDesc->QueryError();
              }
              else
              {
                  NLS_STR *apnlsParams[2];
                  apnlsParams[0] = &nlsParam;
                  apnlsParams[1] = NULL;

                  RESOURCE_STR nlsDesc( msgidDesc, NLS_BASE_DLL_HMOD );

                  if (  ((err = nlsDesc.QueryError()) == NERR_Success )
                     && ((err = nlsDesc.InsertParams( (const NLS_STR * * ) apnlsParams ))
                         == NERR_Success)
                     )
                  {
                      *pnlsDesc = nlsDesc;
                      err = pnlsDesc->QueryError();
                  }
              }
          }

      }

      return err;

}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::QueryCurrentEntryData

    SYNOPSIS:       Return the binary information of the current
                    log entry

    ENTRY:          ppbDataOut

    EXIT:           ppbDataOut -  points to the raw data.

    RETURNS:        The size of the raw data in bytes.

    NOTES:          Audit log records have only one block of binary
                    data: the "ae_xxxxxx" structure.

    HISTORY:
        DavidHov   created    6 Jun 91

********************************************************************/

ULONG LM_AUDIT_LOG::QueryCurrentEntryData( BYTE **ppbDataOut )
{

    UIASSERT( IsOpened() );
    UIASSERT( _pAE != NULL );

    MSGID msgidCategory = QueryCurrentEntryCategory();
    UINT  uiRawDataLen = 0;

    // Only if the audit type is unknown, then we treat the
    // data as raw data.
    if ( msgidCategory == (MSGID) APE2_AUDIT_UNKNOWN )
    {
#ifndef WIN32
        uiRawDataLen = (UINT)  _pAE->ae_len - _pAE->ae_data_offset;
#else
        uiRawDataLen = (UINT)  _pAE->ae_data_size;
#endif
    }

    if ( uiRawDataLen != 0  )
        *ppbDataOut =  (BYTE *) _pAE + _pAE->ae_data_offset;

    return (ULONG) uiRawDataLen;

}

/*******************************************************************

    NAME:           LM_AUDIT_LOG::QueryCurrentEntryTime

    SYNOPSIS:       Get the time associated with the current log entry

    ENTRY:

    EXIT:

    RETURNS:        Returns the time in ULONG

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

ULONG LM_AUDIT_LOG::QueryCurrentEntryTime( VOID )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pAE != NULL );
    return _pAE->ae_time;
}

/*******************************************************************

    NAME:       LM_AUDIT_LOG::WriteTextEntry

    SYNOPSIS:   Write the specified log entry to a file as normal text

    ENTRY:      ULONG ulFileHandle - file handle
                INTL_PROFILE - international profile information
                chSeparator  - character to separate the different fields
                               info. in a log entry.

    RETURNS:    APIERR - in case error occurs

    HISTORY:
        terryk          20-Dec-1991     Created
        Yi-HsinS        2-Feb-1991      Added chSeparator
        JonN            6/22/00         WriteTextEntry no longer supported

********************************************************************/

APIERR LM_AUDIT_LOG::WriteTextEntry( ULONG ulFileHandle,
                     INTL_PROFILE &intlprof, TCHAR chSeparator )
{
    return ERROR_CALL_NOT_IMPLEMENTED;
/*
    UIASSERT( IsOpened() );

    APIERR err = NERR_Success;

    FORMATTED_LOG_ENTRY *pfle;
    if ( (err = CreateCurrentFormatEntry( &pfle )) != NERR_Success )
    {
        return err;
    }

    UIASSERT( pfle != NULL );

    NLS_STR nlsStr;     // Initialize to empty string on construction
    NLS_STR nlsTime;
    NLS_STR nlsDate;

    if ((( err = nlsStr.QueryError()) != NERR_Success ) ||
        (( err = nlsTime.QueryError()) != NERR_Success ) ||
        (( err = nlsDate.QueryError()) != NERR_Success ))
    {
        return err;
    }

    WIN_TIME winTime( pfle->QueryTime() );

    if ((( err = winTime.QueryError()) ) ||
        (( err = intlprof.QueryTimeString( winTime, &nlsTime )) ) ||
        (( err = intlprof.QueryShortDateString( winTime, &nlsDate )) ))
    {
        return err;
    }

    nlsStr.strcat( nlsDate );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( nlsTime );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QueryComputer()) );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QueryUser()) );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QueryCategory()) );
    nlsStr.AppendChar( chSeparator );

    NLS_STR *pnls = pfle->QueryDescription();

    if ( pnls->QueryTextLength() == 0 )
    {
        NLS_STR nlsDesc;

        err = nlsDesc.QueryError()? nlsDesc.QueryError()
                                  : QueryCurrentEntryDesc( &nlsDesc );
        nlsStr.strcat( nlsDesc );
    }
    else
    {
        nlsStr.strcat( *pnls );
    }

    nlsStr.Append( END_OF_LINE );

    delete pfle;
    pfle = NULL;

    if ((err = nlsStr.QueryError()) != NERR_Success )
        return err;

    BUFFER buf((nlsStr.QueryTextLength() + 1) * sizeof(WCHAR) );
    if (  ((err = buf.QueryError()) != NERR_Success )
       || ((err = nlsStr.MapCopyTo( (CHAR *) buf.QueryPtr(), buf.QuerySize()))
           != NERR_Success )
       )
    {
        return err;
    }

    return ::FileWriteLineAnsi( ulFileHandle, (CHAR *) buf.QueryPtr(),
                               ::strlen((CONST CHAR *)buf.QueryPtr()) ); // don't need to copy '\0'
*/
}

/*******************************************************************

    NAME:           LM_ERROR_LOG::LM_ERROR_LOG

    SYNOPSIS:       Constructor

    ENTRY:          pszServer - name of the server
                    evdir     - direction of browsing
                    pszModule - name of the module

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        DavidHov        6/6/91          Created

********************************************************************/
LM_ERROR_LOG::LM_ERROR_LOG( const TCHAR     *pszServer,
                            EVLOG_DIRECTION  evdir,
                            const TCHAR     *pszModule )
    : LM_EVENT_LOG( pszServer, evdir, pszModule ),
      _pEE( NULL ),
      _iStrings( 0 )
{
     if ( QueryError() != NERR_Success )
         return;
}

/*******************************************************************

    NAME:           LM_ERROR_LOG::~LM_ERROR_LOG

    SYNOPSIS:       Destructor ( virtual )

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        DavidHov        6/6/91          Created

********************************************************************/

LM_ERROR_LOG::~LM_ERROR_LOG()
{
}

/*******************************************************************

    NAME:           LM_ERROR_LOG::Clear

    SYNOPSIS:       Clear the error log

    ENTRY:          pszBackupFile - name of the file to backup the
                                    error log to

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_ERROR_LOG::Clear( const TCHAR *pszBackupFile )
{
    UIASSERT( IsOpened() );

    APIERR err = ::MNetErrorLogClear( _nlsServer, pszBackupFile, NULL );
    if ( err == NERR_Success )
        Reset();
    return err;
}

/*******************************************************************

    NAME:           LM_ERROR_LOG::Reset

    SYNOPSIS:       Reset all internal variables

    ENTRY:

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        DavidHov        6/6/91          Created

********************************************************************/
VOID LM_ERROR_LOG::Reset( VOID )
{
    LM_EVENT_LOG::Reset() ;

    _pEE = NULL;
    _iStrings = 0;
}

/*******************************************************************

    NAME:           LM_ERROR_LOG::QueryEntriesInBuffer

    SYNOPSIS:       Get the number of entries currently contained
                    in the buffer.

    ENTRY:

    EXIT:

    RETURNS:        Return the number of entries in the buffer

    NOTES:

    HISTORY:
        Yi-HsinS        5/23/92        Created

********************************************************************/

ULONG LM_ERROR_LOG::QueryEntriesInBuffer( VOID )
{
    ULONG cEntries = 0;
    ULONG cbOffset = 0;
    ERROR_ENTRY *pEE = NULL;

    while ( cbOffset < _cbReturned )
    {
        pEE = (ERROR_ENTRY *) ( _pbBuf + cbOffset);
        cbOffset += (UINT) pEE->el_len ;
        cEntries++;
    }

    return cEntries;

}

/*******************************************************************


    NAME:           LM_ERROR_LOG::SetPos

    SYNOPSIS:       Prepare all internal variables to get the requested log
                    entry in the next read

    ENTRY:          logEntryNum -  the requested record position
                    fForceRead  -  If TRUE, we will always read from the log.
                                   Else we will only read if the entry is not
                                   in the buffer

    EXIT:

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

VOID LM_ERROR_LOG::SetPos( const LOG_ENTRY_NUMBER &logEntryNum, BOOL fForceRead)
{

    BOOL fRead = fForceRead;

    if ( !fRead )
    {
        fRead = TRUE;
        ULONG ulRecCount = _ulStartRecordNum;
        ULONG ulRecSeek = logEntryNum.QueryRecordNum();

        // Check to see if the requested log entry is in the buffer already.
        if (  ( logEntryNum.QueryDirection() == _evdirBuf )
           && ( ulRecSeek >= ulRecCount )
           )
        {
            _cbOffset = 0;
            while ( _cbOffset < _cbReturned )
            {
                if ( ulRecCount == ulRecSeek )
                {
                    fRead = FALSE;
                    break;
                }
                else
                {
                    _pEE = (ERROR_ENTRY *) ( _pbBuf + _cbOffset) ;
                    _cbOffset += (UINT) _pEE->el_len ;
                    ulRecCount++;
                }
            }
        }
    }

    // If the log entry is not in the buffer, reset some variables to
    // prepare for the next read.
    if ( fRead )
    {
        _cbOffset = _cbReturned;
        _evdir = logEntryNum.QueryDirection();
        _cbTotalAvail = MAXUINT;
    }

    // We need to minus one because I_Next always increments
    // by one first before reading.
    _ulRecordNum = logEntryNum.QueryRecordNum() - 1;

}

/*******************************************************************

    NAME:           LM_ERROR_LOG::I_Next

    SYNOPSIS:       Helper method that actually reads the next log
                    entry.


    ENTRY:          ulBufferSize - buffer size used for the Net APIs

    EXIT:           *pfContinue - TRUE if not end of log file, FALSE otherwise.

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_ERROR_LOG::I_Next( BOOL *pfContinue, ULONG ulBufferSize )
{
    APIERR err;

    _ulRecordNum++;

    TRACEEOL( "Error Number:" << _ulRecordNum );

    _pEE = NULL;
    _iStrings = 0;

    // Do a Net API call to get the entry we wanted.
    if ( _cbOffset >= _cbReturned )
    {
        // Reached the end of log
        if ( _cbTotalAvail == 0 )
        {
            *pfContinue = FALSE;
            return NERR_Success;
        }

        _cbOffset = 0 ;

        // Free the previous buffer allocated by the Net API
        ::MNetApiBufferFree( &_pbBuf );
        _pbBuf = NULL;

        // Don't need to worry about buffer not large enough because
        // the mapping layer will take care of it.
        err = ::MNetErrorLogRead( _nlsServer,
                                  NULL,
                                  &_hLog,
                                  _ulRecordNum,
                                  NULL,
                                  0,
                                  ( ( _evdir == EVLOG_FWD ? LOGFLAGS_FORWARD
                                                          : LOGFLAGS_BACKWARD )
                                  | ( IsSeek() ? LOGFLAGS_SEEK : 0 )
                                  ),
                                  &_pbBuf,
                                  (UINT) ulBufferSize,
                                  & _cbReturned,
                                  & _cbTotalAvail
                                );

        _ulStartRecordNum = _ulRecordNum;
        _evdirBuf = _evdir;

        DBGEOL( "ERROR RETURNED: " << _cbReturned
                << " AVAILABLE: "  << _cbTotalAvail );

        // Reached end of log
        if ( err == NERR_Success && _cbTotalAvail == 0 && _cbReturned == 0 )
        {
            *pfContinue = FALSE;
            return NERR_Success;
        }

        if ( err != NERR_Success )
        {
            _cbReturned = 0 ;
            *pfContinue = FALSE;
            return err;
        }

    }

    SetSeekFlag( FALSE );

    _pEE = (ERROR_ENTRY *) ( _pbBuf + _cbOffset) ;

    if ( _cbReturned - _cbOffset < _pEE->el_len )
    {
        // Report the same error that NET CMD does (cf. AUDERR.C)
        _cbOffset = _cbReturned ;
        *pfContinue = FALSE;
        return IDS_UI_LOG_RECORD_CORRUPT;
    }

    _cbOffset +=  (UINT) _pEE->el_len;

    *pfContinue = TRUE;
    return NERR_Success;

}


/*******************************************************************

    NAME:           LM_ERROR_LOG::NextString

    SYNOPSIS:       Return the next string associated with the current
                    log entry

    ENTRY:

    EXIT:           pfContinue  - pointer to a BOOL which is TRUE
                                  if there are more strings to read.
                    ppnlsString - pointer to the next string

    RETURNS:        APIERR

    NOTES:

    HISTORY:
        DavidHov         6/6/91         Created
        Yi-HsinS       10/23/91         Modified for NT to downlevel case

********************************************************************/

APIERR LM_ERROR_LOG::NextString( BOOL *pfContinue, NLS_STR **ppnlsString )
{

    UIASSERT( IsOpened() );
    UIASSERT( _pEE != NULL );

    BYTE *pszStr;
#ifndef WIN32
    BYTE *pszEnd;
#endif

    _iStrings++;

    if ( _iStrings > _pEE->el_nstrings )
    {
        *pfContinue = FALSE;
        return NERR_Success;
    }

#ifndef WIN32
    pszStr = ((BYTE *) _pEE) + sizeof( *_pEE );
    pszEnd = ((BYTE *) _pEE) + _pEE->el_data_offset ;
#else
    pszStr = (BYTE *) _pEE->el_text;
#endif

    for ( UINT i = 1; i < _iStrings; i++ )
    {
         pszStr += (::strlenf( (TCHAR *) pszStr ) + 1 ) * sizeof( TCHAR );

#ifndef WIN32
         if ( pszStr >= pszEnd )
         {
             *pfContinue = FALSE ;
             return IDS_UI_LOG_RECORD_CORRUPT;
         }
#endif

    }

    *ppnlsString = new NLS_STR( (TCHAR *)  pszStr );

    APIERR err = ( *ppnlsString? (*ppnlsString)->QueryError()
                               : (APIERR) ERROR_NOT_ENOUGH_MEMORY );

    if ( err != NERR_Success )
    {
        delete *ppnlsString;
        *ppnlsString = NULL;
        *pfContinue = FALSE;
        return err;
    }

    *pfContinue = TRUE;
    return NERR_Success;
}

/*******************************************************************

    NAME:           LM_ERROR_LOG::QueryCurrentEntryDesc

    SYNOPSIS:       Helper function for constructing the Description
                    for the current log entry

    ENTRY:

    EXIT:           pnlsDesc - pointer to the description

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_ERROR_LOG::QueryCurrentEntryDesc( NLS_STR *pnlsDesc )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEE != NULL );

    APIERR err = NERR_Success;
    RESOURCE_STR nlsError( (MSGID) _pEE->el_error, NLS_BASE_DLL_HMOD );
    NLS_STR *apnlsParams[ MAX_INSERT_PARAMS + 1 ];

    apnlsParams[0] = NULL;
    err = pnlsDesc->CopyFrom( EMPTY_STRING );

    if ( err != NERR_Success )
        return err;

    // Start reading from the first string again.
    // Reset the string enumerator
    _iStrings = 0;

    if ( ( err = nlsError.QueryError()) != NERR_Success )
    {
        if ( err == ERROR_MR_MID_NOT_FOUND )
        {
            pnlsDesc->Load( IDS_UI_DEFAULT_DESC, NLS_BASE_DLL_HMOD );
            pnlsDesc->InsertParams( _pEE->el_name, DEC_STR( _pEE->el_error ) );
            if ( (err = pnlsDesc->QueryError()) == NERR_Success )
            {

                BOOL fContinue;
                NLS_STR *pnlsTemp = NULL;
                for ( UINT i = 0; i < _pEE->el_nstrings; i++ )
                {
                    if ( i != 0 )
                        err = pnlsDesc->AppendChar( COMMA_CHAR );

                    if (  ( err != NERR_Success )
                       || ( (err = NextString( &fContinue, &pnlsTemp ))
                            != NERR_Success )
                       || ( !fContinue )
                       || ( (err = pnlsDesc->Append( *pnlsTemp ))
                            != NERR_Success)
                       )
                    {
                        break;
                    }
                    delete pnlsTemp;
                    pnlsTemp = NULL;
                }

                delete pnlsTemp;
                pnlsTemp = NULL;
                err = err? err : pnlsDesc->AppendChar( PERIOD_CHAR );
            }
        }
    }
    else
    {

        // Get the strings associated with the current log entry
        NLS_STR *pnlsTemp;
        BOOL fContinue;

        if ( _pEE->el_nstrings > MAX_INSERT_PARAMS )
            _pEE->el_nstrings = MAX_INSERT_PARAMS;

        for ( UINT i = 0; i < _pEE->el_nstrings; i++ )
        {
             if (( err = NextString( &fContinue, &pnlsTemp )) != NERR_Success )
                 break;

             if ( !fContinue )
                 break;

             apnlsParams[i] = pnlsTemp;
        }
        apnlsParams[i] = NULL;

        if ( err == NERR_Success )
        {
            if ( (err = nlsError.InsertParams( (const NLS_STR * *) apnlsParams )) == NERR_Success)
            {
                *pnlsDesc = nlsError;
            }

        }

        err = ( err ?  err :  pnlsDesc->QueryError());

        // Do some clean up!
        for ( i = 0; apnlsParams[i] != NULL; i++ )
             delete apnlsParams[i];
    }

    return err;

}

/*******************************************************************

    NAME:           LM_ERROR_LOG::CreateCurrentRawEntry

    SYNOPSIS:       Helper function for constructing the RAW_LOG_ENTRY
                    to be used when filtering the log

    ENTRY:

    EXIT:           pRawLogEntry - The raw log entry returned

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_ERROR_LOG::CreateCurrentRawEntry( RAW_LOG_ENTRY *pRawLogEntry )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEE != NULL );

    return pRawLogEntry->Set(  _ulRecordNum,
                               _pEE->el_time,
                               TYPE_NONE,      // No Type
                               EMPTY_STRING,   // No Category
                               (ULONG) _pEE->el_error,
                               _pEE->el_name,
                               pszNoUser,      // No User
                               pszNoUser,      // No Computer
                               this
                            );


}

/*******************************************************************

    NAME:           LM_ERROR_LOG::CreateCurrentFormatEntry

    SYNOPSIS:       Helper function for constructing the  FORMATTED_LOG_ENTRY
                    to be displayed

    ENTRY:

    EXIT:           ppFmtLogEntry - The formatted log entry returned.

    RETURNS:

    NOTES:

    HISTORY:
        Yi-HsinS        10/23/91        Created

********************************************************************/

APIERR LM_ERROR_LOG::CreateCurrentFormatEntry( FORMATTED_LOG_ENTRY **ppFmtLogEntry )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEE != NULL );

    APIERR err = NERR_Success;

    *ppFmtLogEntry = new FORMATTED_LOG_ENTRY( _ulRecordNum,
                                              _pEE->el_time,
                                              TYPE_NONE,     // No Type
                                              EMPTY_STRING,  // No Type
                                              EMPTY_STRING,  // No Category
                                              (ULONG) _pEE->el_error,
                                              _pEE->el_name,
                                              pszNoUser,     // No User
                                              pszNoUser,     // No Computer
                                              NULL,          // delay til needed
                                              this );

    err = ( ( *ppFmtLogEntry  == NULL ) ? (APIERR) ERROR_NOT_ENOUGH_MEMORY
                                        : (*ppFmtLogEntry)->QueryError());

    if ( err != NERR_Success )
    {
        delete *ppFmtLogEntry;
        *ppFmtLogEntry = NULL;
    }

    return err;
}

/*******************************************************************

    NAME:           LM_ERROR_LOG::QueryCurrentEntryData

    SYNOPSIS:       Return the binary information of the current
                    log entry.

    ENTRY:          ppbDataOut

    EXIT:           ppbDataOut -  points to the raw data.

    RETURNS:        The size of the raw data in bytes.

    NOTES:

    HISTORY:
        DavidHov         6/6/91         Created
        Yi-HsinS       10/23/91         Added #ifdef for WIN32

********************************************************************/

ULONG LM_ERROR_LOG::QueryCurrentEntryData( BYTE **ppbDataOut )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEE != NULL );

#ifndef WIN32
    UINT uiRawDataLen = (UINT) _pEE->el_len - _pEE->el_data_offset;
#else
    UINT uiRawDataLen = (UINT) _pEE->el_data_size;
#endif

    if ( uiRawDataLen != 0 )
#ifndef WIN32
        *ppbDataOut = (BYTE *)  _pEE + _pEE->el_data_offset;
#else
        *ppbDataOut = (BYTE *)  _pEE->el_data;
#endif

    return (ULONG) uiRawDataLen;

}

/*******************************************************************

    NAME:           LM_ERROR_LOG::QueryCurrentEntryTime

    SYNOPSIS:       Return the time of the current event log entry

    ENTRY:

    EXIT:

    RETURNS:        Return the time in ULONG

    NOTES:

    HISTORY:
        Yi-HsinS          10/23/91      Created

********************************************************************/

ULONG LM_ERROR_LOG::QueryCurrentEntryTime( VOID )
{
    UIASSERT( IsOpened() );
    UIASSERT( _pEE != NULL );

    return _pEE->el_time;
}

/*******************************************************************

    NAME:       LM_ERROR_LOG::WriteTextEntry

    SYNOPSIS:   Write the specified log entry to a file as normal text

    ENTRY:      ULONG ulFileHandle      - file handle
                INTL_PROFILE & intlprof - international profile information
                chSeparator             - character to separate the different
                                          info. in a log entry.

    RETURNS:    APIERR - in case of error occurs

    HISTORY:
        terryk          20-Dec-1991     Created
        Yi-HsinS         3-Feb-1992     Added chSeparator
        beng            05-Mar-1992     Remove wsprintf call
        JonN            6/22/00         WriteTextEntry no longer supported

********************************************************************/

APIERR LM_ERROR_LOG::WriteTextEntry( ULONG ulFileHandle,
                                     INTL_PROFILE & intlprof, TCHAR chSeparator)
{
    return ERROR_CALL_NOT_IMPLEMENTED;
/*
    UIASSERT( IsOpened() );

    APIERR err = NERR_Success;

    FORMATTED_LOG_ENTRY *pfle;

    if ( (err = CreateCurrentFormatEntry( & pfle )) != NERR_Success )
    {
        return err;
    }

    UIASSERT( pfle != NULL );

    NLS_STR nlsStr;   // Set to empty string on construction
    NLS_STR nlsTime;
    NLS_STR nlsDate;

    if ((( err = nlsStr.QueryError()) != NERR_Success ) ||
        (( err = nlsTime.QueryError()) != NERR_Success ) ||
        (( err = nlsDate.QueryError()) != NERR_Success ))
    {
        return err;
    }

    WIN_TIME winTime( pfle->QueryTime() );

    if ((( err = winTime.QueryError()) ) ||
        (( err = intlprof.QueryTimeString( winTime, &nlsTime )) ) ||
        (( err = intlprof.QueryShortDateString( winTime, &nlsDate )) ))
    {
        return err;
    }

    nlsStr.strcat( nlsDate );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( nlsTime );
    nlsStr.AppendChar( chSeparator );

    nlsStr.strcat( *(pfle->QuerySource()) );
    nlsStr.AppendChar( chSeparator );

    DEC_STR nlsID( pfle->QueryDisplayEventID() ); //ctor check deferred to below

    nlsStr.strcat( nlsID );
    nlsStr.AppendChar( chSeparator );

    NLS_STR *pnls = pfle->QueryDescription();

    if ( pnls->QueryTextLength() == 0 )
    {
        NLS_STR nlsDesc;

        err = nlsDesc.QueryError()? nlsDesc.QueryError()
                                  : QueryCurrentEntryDesc( &nlsDesc );
        nlsStr.strcat( nlsDesc );
    }
    else
    {
        nlsStr.strcat( *pnls );
    }

    nlsStr.Append( END_OF_LINE );

    delete pfle;
    pfle = NULL;

    if ((err = nlsStr.QueryError()) != NERR_Success )
        return err;

#ifdef FE_SB // APIERR LM_ERROR_LOG::WriteTextEntry()
    BUFFER buf((nlsStr.QueryTextLength() + 1) * sizeof(WORD));
#else
    BUFFER buf( nlsStr.QueryTextLength() + 1);
#endif // FE_SB
    if (  ((err = buf.QueryError()) != NERR_Success )
       || ((err = nlsStr.MapCopyTo( (CHAR *) buf.QueryPtr(), buf.QuerySize()))
           != NERR_Success )
       )
    {
        return err;
    }

#ifdef FE_SB // APIERR LM_ERROR_LOG::WriteTextEntry()
    return ::FileWriteLineAnsi( ulFileHandle, (CHAR *) buf.QueryPtr(),
                               ::strlen((CONST CHAR *)buf.QueryPtr()) ); // don't need to copy '\0'
#else
    return ::FileWriteLineAnsi( ulFileHandle, (CHAR *) buf.QueryPtr(),
                               buf.QuerySize() - 1 ); // don't need to copy '\0'
#endif // FE_SB
*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\log\eventlog.cxx ===
/**********************************************************************/
/**			  Microsoft Windows NT  		     **/
/**		Copyright(c) Microsoft Corp., 1991	  	     **/
/**********************************************************************/

/*
    EVENTLOG.CXX

    The base class for LM Audit, Error Log classes and NT event log classes.
	 EVENT_LOG

    FILE HISTORY:
	Yi-HsinS	10/23/91	Created based on DavidHov's lmlog.cxx
	Yi-HsinS	12/5/91	        Separated NT_EVENT_LOG and LM_EVENT_LOG
					to different files
	terryk		12/20/91	Added SaveAsLog
        Yi-HsinS	12/31/91        Separated the pattern classes and log
					entry classes to logmisc.cxx	
        Yi-HsinS	1/15/92         Added Backup

*/

#include "pchlmobj.hxx"  // Precompiled header

/*******************************************************************

    NAME:	    EVENT_LOG::EVENT_LOG

    SYNOPSIS:	    Constructor for the base class

    ENTRY:	    pszServer - server name, NULL or Empty string
				stands for for local machine.

                    evdir     - EVLOG_FWD ( default ) or EVLOG_BACK
		
                    pszModule - module name

    EXIT:	

    RETURNS:	

    NOTES:

    HISTORY:
	Yi-HsinS	10/23/91	Created

********************************************************************/

EVENT_LOG::EVENT_LOG( const TCHAR *pszServer,
		      EVLOG_DIRECTION evdir,
	              const TCHAR *pszModule)
    : _nlsServer     ( pszServer ),
      _evdir         ( evdir ),
      _evdirBuf      ( evdir ),
      _nlsModule     ( pszModule ),
      _fSeek         ( FALSE ),
      _pFilterPattern( NULL )
{

    if ( QueryError() != NERR_Success )
	return;

    APIERR err;
    if (  (( err = _nlsServer.QueryError() ) != NERR_Success )
       || (( err = _nlsModule.QueryError() ) != NERR_Success )
       )
    {
	ReportError( err );
	return;
    }

}

/*******************************************************************


    NAME:	    EVENT_LOG::~EVENT_LOG

    SYNOPSIS:	    Destructor ( virtual )

    ENTRY:	

    EXIT:	

    RETURNS:	

    NOTES:

    HISTORY:
	Yi-HsinS	10/23/91	Created

********************************************************************/
EVENT_LOG::~EVENT_LOG()
{
}

/*******************************************************************

    NAME:	    EVENT_LOG::QuerySourceList

    SYNOPSIS:	    Query the source list

    ENTRY:	

    EXIT:	

    RETURNS:	

    NOTES:          Default method

    HISTORY:
	Yi-HsinS	3/9/92       Created

********************************************************************/

STRLIST *EVENT_LOG::QuerySourceList( VOID )
{
    return NULL;
}

/*******************************************************************

    NAME:	    EVENT_LOG::QuerySrcSupportedTypeMask

    SYNOPSIS:	    Query the type mask supported by the selected
                    source.

    ENTRY:	

    EXIT:	

    RETURNS:	

    NOTES:          Default method. If this is not redefined, return
                    0 for the type mask.

    HISTORY:
	Yi-HsinS	3/9/92       Created

********************************************************************/

APIERR EVENT_LOG::QuerySrcSupportedTypeMask( const NLS_STR &nlsSource,
                                             USHORT *pusTypeMask )
{
    UNREFERENCED( nlsSource );
    *pusTypeMask = 0;
    return NERR_Success;
}

/*******************************************************************

    NAME:	    EVENT_LOG::QuerySrcSupportedCategoryList

    SYNOPSIS:	    Query the type mask supported by the selected
                    source.

    ENTRY:	

    EXIT:	

    RETURNS:	

    NOTES:          Default method. If this is not redefined, return
                    NULL for category list.

    HISTORY:
	Yi-HsinS	3/9/92       Created

********************************************************************/

APIERR EVENT_LOG::QuerySrcSupportedCategoryList( const NLS_STR &nlsSource,
                                                 STRLIST **ppstrlstCategory )
{
    UNREFERENCED( nlsSource );
    *ppstrlstCategory = NULL;
    return NERR_Success;
}

/*******************************************************************

    NAME:	    EVENT_LOG::Open

    SYNOPSIS:	    Open up a log file for reading

    ENTRY:	

    EXIT:	

    RETURNS:	

    NOTES:

    HISTORY:
	Yi-HsinS	3/9/92       Created

********************************************************************/

APIERR EVENT_LOG::Open( VOID )
{
    Reset();

    APIERR err;
    if ( (err = I_Open() ) == NERR_Success )
        SetOpenFlag( TRUE );

    return err;
}

/*******************************************************************

    NAME:	    EVENT_LOG::Close

    SYNOPSIS:	    Close a log file

    ENTRY:	

    EXIT:	

    RETURNS:	

    NOTES:

    HISTORY:
	Yi-HsinS	3/9/92       Created

********************************************************************/

APIERR EVENT_LOG::Close( VOID )
{
    APIERR err;
    if ( (err = I_Close() ) == NERR_Success )
        SetOpenFlag( FALSE );

    return err;
}

/*******************************************************************

    NAME:	    EVENT_LOG::Backup

    SYNOPSIS:	    Back up a log file without clearing the log

    ENTRY:	    pszBackupFile - The file name to backup the log
                                    file to. It can either be a fully
                                    qualified name or UNC name.

    EXIT:	

    RETURNS:	

    NOTES:          Will assert out if not redefined.

    HISTORY:
	Yi-HsinS	2/7/92       Created

********************************************************************/

APIERR EVENT_LOG::Backup( const TCHAR *pszBackupFile )
{
    UIASSERT( IsOpened() );
    UNREFERENCED( pszBackupFile );
    UIASSERT( FALSE );
    return ERROR_NOT_SUPPORTED;
}

/*******************************************************************

    NAME:	    EVENT_LOG::Reset

    SYNOPSIS:	    Reset the stream to its original limit position based
		    upon the direction in question.

    ENTRY:	

    EXIT:	

    RETURNS:	

    NOTES:

    HISTORY:
	Yi-HsinS	10/23/91       Created

********************************************************************/

VOID EVENT_LOG::Reset( VOID )
{
    _fSeek = FALSE;
    _evdirBuf = _evdir;

}

/*******************************************************************

    NAME:	    EVENT_LOG::Next

    SYNOPSIS:	    Access the next record in the direction specified

    ENTRY:	

    EXIT:	    pfContinue - TRUE if another record exists and was accessed,
				 FALSE if end-of-log reached or error occurred.

    RETURNS:	    APIERR

    NOTES:	

    HISTORY:
	Yi-HsinS	10/23/91	Created

********************************************************************/

APIERR EVENT_LOG::Next( BOOL *pfContinue )
{

    UIASSERT( IsOpened() );

    APIERR err;
    RAW_LOG_ENTRY rawLogEntry;

    while ( (err = I_Next( pfContinue )) == NERR_Success )
    {

	if ( !*pfContinue )
	    break;

	if ( !IsFilterOn() )
	    break;

        BOOL fMatch;
	// If filter is on,check if the current entry matches the filter pattern
	if (  ((err = CreateCurrentRawEntry( &rawLogEntry )) == NERR_Success )
	   && ((err = QueryFilter()->CheckForMatch( &fMatch, &rawLogEntry ))
                == NERR_Success )
	   )
	{
            if ( fMatch )
	        break;
	}

	if ( err != NERR_Success )
	{
	    *pfContinue = FALSE;
	    break;
	}

    }

    return err;
}

/*******************************************************************

    NAME:	    EVENT_LOG::SeekLogEntry

    SYNOPSIS:	    Get the log entry at the specified position
		    as the current entry.

    ENTRY:	    logEntryNum - the position of the requested log entry
                    fRead - TRUE means to read the entry.
                            FALSE means to set the position for the
                            next read.

    EXIT:	

    RETURNS:	

    NOTES:	

    HISTORY:
	Yi-HsinS	10/23/91	Created

********************************************************************/

APIERR EVENT_LOG::SeekLogEntry( const LOG_ENTRY_NUMBER &logEntryNum, BOOL fRead)
{
    UIASSERT( IsOpened() );

    _fSeek = TRUE;

    SetPos( logEntryNum, !fRead );

    APIERR err = NERR_Success;

    if ( fRead )
    {
        // Don't need to worry about fContinue of I_Next
        // because we are not using it as an iterator!
        // We use a smaller buffer because we will be doing seek read.
        BOOL fContinue;
        err = I_Next( &fContinue, SMALL_BUF_DEFAULT_SIZE );
    }

    return err;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\netui\common\src\lmobj\lmoenum\lmoeusr.cxx ===
/*****************************************************************/
/**		     Microsoft LAN Manager			**/
/**	       Copyright(c) Microsoft Corp., 1991		**/
/*****************************************************************/

/*
 *  HISTORY:
 *	gregj	20-May-1991	Cloned from SERVER_ENUM
 *	gregj	23-May-1991	Added LOCATION support
 *	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructors
 *	KeithMo	07-Oct-1991	Win32 Conversion.
 *	JonN	30-Jan-1992	Added NT_USER_ENUM
 *	JonN	13-Mar-1992	Split NT_ACCOUNT_ENUM to lmoent.cxx
 *
 */

#include "pchlmobj.hxx"


/*****************************	USER_ENUM  ******************************/


/**********************************************************\

    NAME:	USER_ENUM::USER_ENUM

    SYNOPSIS:	User enumeration constructor

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

		usLevel -	info level
		pszGroupName -	name of group to enumerate users
				from, default is all users in UAS

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER_ENUM::USER_ENUM( const TCHAR * pszLocation,
		      UINT	    uLevel,
		      const TCHAR * pszGroupName,
                      BOOL          fKeepBuffers )
  : LOC_LM_RESUME_ENUM( pszLocation, uLevel, fKeepBuffers ),
    _nlsGroupName( pszGroupName ),
    _ResumeHandle( 0 )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

    APIERR err = _nlsGroupName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }


}  // USER_ENUM::USER_ENUM


USER_ENUM::USER_ENUM( LOCATION_TYPE  locType,
		      UINT	     uLevel,
		      const TCHAR  * pszGroupName,
                      BOOL           fKeepBuffers )
  : LOC_LM_RESUME_ENUM( locType, uLevel, fKeepBuffers ),
    _nlsGroupName( pszGroupName )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

    APIERR err = _nlsGroupName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // USER_ENUM::USER_ENUM


USER_ENUM::USER_ENUM( const LOCATION  & loc,
		      UINT	        uLevel,
		      const TCHAR     * pszGroupName,
                      BOOL              fKeepBuffers )
  : LOC_LM_RESUME_ENUM( loc, uLevel, fKeepBuffers ),
    _nlsGroupName( pszGroupName )
{
    if( QueryError() != NERR_Success )
    {
    	return;
    }

    APIERR err = _nlsGroupName.QueryError();
    if ( err != NERR_Success )
    {
        ReportError( err );
        return;
    }

}  // USER_ENUM::USER_ENUM


/**********************************************************\

    NAME:	USER_ENUM::CallAPI

    SYNOPSIS:	Call API to do user enumeration

    ENTRY:	ppbBuffer	- ptr to ptr to buffer to fill
		pcEntriesRead	- variable to store entry count

    EXIT:	LANMAN error code

    NOTES:

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER_ENUM

\**********************************************************/

APIERR USER_ENUM :: CallAPI( BOOL    fRestartEnum,
                             BYTE ** ppbBuffer,
			     UINT  * pcEntriesRead )
{
    if ( fRestartEnum )
        _ResumeHandle = 0;

    /* NetGroupGetUsers must be level 0, so: */
    UIASSERT( QueryInfoLevel() == 0 || _nlsGroupName.QueryTextLength() == 0 );

    if ( _nlsGroupName.QueryTextLength() != NULL )
    {
	return ::MNetGroupGetUsers( QueryServer(),
				    _nlsGroupName,
				    QueryInfoLevel(),
				    ppbBuffer,
				    pcEntriesRead );
    }
    else
    {
        UINT cTotalEntries;
	return ::MNetUserEnum( QueryServer(),
			       QueryInfoLevel(),
                               FILTER_TEMP_DUPLICATE_ACCOUNT
                               | FILTER_NORMAL_ACCOUNT,
			       ppbBuffer,
                               MAXPREFERREDLENGTH,
			       pcEntriesRead,
                               &cTotalEntries,
                               &_ResumeHandle );
    }

}  // USER_ENUM::CallAPI



/*****************************	USER0_ENUM  ******************************/


/**********************************************************\

    NAME:	USER0_ENUM::USER0_ENUM

    SYNOPSIS:	Constructor for level 0 user enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

		pszGroupName -	name of group to enumerate users
				from, default is all users in UAS

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER0_ENUM::USER0_ENUM( const TCHAR * pszLocation,
			const TCHAR * pszGroupName,
                        BOOL          fKeepBuffers )
  : USER_ENUM( pszLocation, 0, pszGroupName, fKeepBuffers )
{
    // do nothing else

}  // USER0_ENUM::USER0_ENUM


USER0_ENUM::USER0_ENUM( LOCATION_TYPE locType,
			const TCHAR * pszGroupName,
                        BOOL          fKeepBuffers )
  : USER_ENUM( locType, 0, pszGroupName, fKeepBuffers )
{
    // do nothing else

}  // USER0_ENUM::USER0_ENUM


USER0_ENUM::USER0_ENUM( const LOCATION & loc,
			const TCHAR    * pszGroupName,
                        BOOL             fKeepBuffers )
  : USER_ENUM( loc, 0, pszGroupName, fKeepBuffers )
{
    // do nothing else

}  // USER0_ENUM::USER0_ENUM



DEFINE_LM_RESUME_ENUM_ITER_OF( USER0, struct user_info_0 );



/*****************************	USER1_ENUM  ******************************/


/**********************************************************\

    NAME:	USER1_ENUM::USER1_ENUM

    SYNOPSIS:	Constructor for level 1 user enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER1_ENUM::USER1_ENUM( const TCHAR * pszLocation,
                        BOOL          fKeepBuffers )
  : USER_ENUM( pszLocation, 1, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER1_ENUM::USER1_ENUM


USER1_ENUM::USER1_ENUM( LOCATION_TYPE locType,
                        BOOL          fKeepBuffers )
  : USER_ENUM( locType, 1, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER1_ENUM::USER1_ENUM


USER1_ENUM::USER1_ENUM( const LOCATION & loc,
                        BOOL             fKeepBuffers )
  : USER_ENUM( loc, 1, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER1_ENUM::USER1_ENUM


DEFINE_LM_RESUME_ENUM_ITER_OF( USER1, struct user_info_1 );



/*****************************	USER2_ENUM  ******************************/


/**********************************************************\

    NAME:	USER2_ENUM::USER2_ENUM

    SYNOPSIS:	Constructor for level 2 user enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER2_ENUM::USER2_ENUM( const TCHAR * pszLocation,
                        BOOL          fKeepBuffers )
  : USER_ENUM( pszLocation, 2, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER2_ENUM::USER2_ENUM


USER2_ENUM::USER2_ENUM( LOCATION_TYPE locType,
                        BOOL          fKeepBuffers )
  : USER_ENUM( locType, 2, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER2_ENUM::USER2_ENUM


USER2_ENUM::USER2_ENUM( const LOCATION & loc,
                        BOOL             fKeepBuffers )
  : USER_ENUM( loc, 2, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER2_ENUM::USER2_ENUM


DEFINE_LM_RESUME_ENUM_ITER_OF( USER2, struct user_info_2 );



/*****************************	USER10_ENUM  ******************************/


/**********************************************************\

    NAME:	USER10_ENUM::USER10_ENUM

    SYNOPSIS:	Constructor for level 10 user enumeration

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

    HISTORY:
	gregj	20-May-1991	Cloned from SERVER1_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

USER10_ENUM::USER10_ENUM( const TCHAR * pszLocation,
                          BOOL          fKeepBuffers )
  : USER_ENUM( pszLocation, 10, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER10_ENUM::USER10_ENUM


USER10_ENUM::USER10_ENUM( LOCATION_TYPE locType,
                          BOOL          fKeepBuffers )
  : USER_ENUM( locType, 10, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER10_ENUM::USER10_ENUM


USER10_ENUM::USER10_ENUM( const LOCATION & loc,
                          BOOL             fKeepBuffers )
  : USER_ENUM( loc, 10, NULL, fKeepBuffers )
{
    // do nothing else

}  // USER10_ENUM::USER10_ENUM


DEFINE_LM_RESUME_ENUM_ITER_OF( USER10, struct user_info_10 );


/*****************************	GROUP_ENUM  ******************************/


/**********************************************************\

    NAME:	GROUP_ENUM::GROUP_ENUM

    SYNOPSIS:	Group enumeration constructor

    ENTRY:	pszLocation -	domain or server to execute on
		    -OR-
		locType -	local computer/logon domain code
		    -OR-
		loc -		given location to execute on

		uLevel -	info level
		pszUserName -	name of user to enumerate groups
				from, default is all groups in UAS

    HISTORY:
	gregj	21-May-1991	Cloned from USER_ENUM
	gregj	23-May-1991	Added LOCATION support
	rustanl 18-Jul-1991	Added ( const LOCATION & ) constructor

\**********************************************************/

GROUP_ENUM::GROUP_ENUM( const TCHAR * pszLocation,
			UINT	     uLevel,
			const TCHAR * pszUserName )
  : LOC_LM_ENUM( pszLocation, uLevel ),
    _pszUserName( pszUserName )
{
    // nothing else to do

}  // GROUP_ENUM::GROUP_ENUM


GROUP_ENUM::GROUP_ENUM( LOCATION_TYPE locType,
			UINT	      uLevel,
			const TCHAR  * pszUserName )
  : LOC_LM_ENUM( locType, uLevel ),
    _pszUserName( pszUserName )
{
    // nothing else to do

}  // GROUP_ENUM::GROUP_ENUM


GROUP_ENUM::GROUP_ENUM( const LOCATION & loc,
			UINT		 uLevel,
			const TCHAR     * pszUserName )
  : LOC_LM_ENUM( loc, uLevel ),
    _pszUserName( pszUserName )
{
    // nothing else to do

}  // GROUP_ENUM::GROUP_ENUM


/**********************************************************\

    NAME:	GROUP_ENUM::CallAPI

    SYNOPSIS:	Call API to do group enumeration

    ENTRY:	ppbBuffer	- ptr to ptr to buffer to fill
		pcEntriesRead	- variable to store entry count

    EXIT:	LANMAN error code
